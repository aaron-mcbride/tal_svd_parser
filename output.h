    #include <stdint.h>
    #include <stddef.h>

    /**********************************************************************************************
     * @section Implementation Resources
     **********************************************************************************************/

    #define RO_ const volatile
    #define RW_ volatile

    /**********************************************************************************************
     * @section COMP1 Register Information
     **********************************************************************************************/

    /**** @subsection COMP1 Register Pointers ****/

    static RO_ uint32_t* const COMP1_SR_PTR      = (RO_ uint32_t* const)0x58003800U;   /** @brief Comparator status register */
    static RW_ uint32_t* const COMP1_ICFR_PTR    = (RW_ uint32_t* const)0x58003804U;   /** @brief Comparator interrupt clear flag register */
    static RW_ uint32_t* const COMP1_OR_PTR      = (RW_ uint32_t* const)0x58003808U;   /** @brief Comparator option register */
    static RW_ uint32_t* const COMP1_CFGR1_PTR   = (RW_ uint32_t* const)0x5800380CU;   /** @brief Comparator configuration register 1 */
    static RW_ uint32_t* const COMP1_CFGR2_PTR   = (RW_ uint32_t* const)0x58003810U;   /** @brief Comparator configuration register 2 */

    /**** @subsection COMP1 Register Reset Values ****/

    static const uint32_t COMP1_SR_RST      = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t COMP1_ICFR_RST    = 0x00000000U;   /** @brief ICFR register reset value. */
    static const uint32_t COMP1_OR_RST      = 0x00000000U;   /** @brief OR register reset value. */
    static const uint32_t COMP1_CFGR1_RST   = 0x00000000U;   /** @brief CFGR1 register reset value. */
    static const uint32_t COMP1_CFGR2_RST   = 0x00000000U;   /** @brief CFGR2 register reset value. */

    /**** @subsection Enumerated COMP1 Register Value Types ****/

    typedef uint32_t COMP1_SR_t;      /** @brief SR register value type. */
    typedef uint32_t COMP1_ICFR_t;    /** @brief ICFR register value type. */
    typedef uint32_t COMP1_OR_t;      /** @brief OR register value type. */
    typedef uint32_t COMP1_CFGR1_t;   /** @brief CFGR1 register value type. */
    typedef uint32_t COMP1_CFGR2_t;   /** @brief CFGR2 register value type. */

    /**** @subsection Enumerated COMP1 Register Pointer Types ****/

    typedef uint32_t* const COMP1_SR_PTR_t;      /** @brief SR register pointer type. */
    typedef uint32_t* const COMP1_ICFR_PTR_t;    /** @brief ICFR register pointer type. */
    typedef uint32_t* const COMP1_OR_PTR_t;      /** @brief OR register pointer type. */
    typedef uint32_t* const COMP1_CFGR1_PTR_t;   /** @brief CFGR1 register pointer type. */
    typedef uint32_t* const COMP1_CFGR2_PTR_t;   /** @brief CFGR2 register pointer type. */

    /**** @subsection COMP1 Register Field Masks ****/

    static const uint32_t COMP1_OR_AFOP_MASK          = 0x000007FFU;   /** @brief Selection of source for alternate function of output ports */
    static const uint32_t COMP1_OR_OR_MASK            = 0xFFFFF800U;   /** @brief Option register */
    static const uint32_t COMP1_CFGR1_EN_MASK         = 0x00000001U;   /** @brief COMP channel 1 enable bit */
    static const uint32_t COMP1_CFGR1_BRGEN_MASK      = 0x00000002U;   /** @brief Scaler bridge enable */
    static const uint32_t COMP1_CFGR1_SCALEN_MASK     = 0x00000004U;   /** @brief Voltage scaler enable bit */
    static const uint32_t COMP1_CFGR1_POLARITY_MASK   = 0x00000008U;   /** @brief COMP channel 1 polarity selection bit */
    static const uint32_t COMP1_CFGR1_ITEN_MASK       = 0x00000040U;   /** @brief COMP channel 1 interrupt enable */
    static const uint32_t COMP1_CFGR1_HYST_MASK       = 0x00000300U;   /** @brief COMP channel 1 hysteresis selection bits */
    static const uint32_t COMP1_CFGR1_PWRMODE_MASK    = 0x00003000U;   /** @brief Power mode of the COMP channel 1 */
    static const uint32_t COMP1_CFGR1_INMSEL_MASK     = 0x00070000U;   /** @brief COMP channel 1 inverting input selection field */
    static const uint32_t COMP1_CFGR1_INPSEL_MASK     = 0x00100000U;   /** @brief COMP channel 1 non-inverting input selection bit */
    static const uint32_t COMP1_CFGR1_BLANKING_MASK   = 0x0F000000U;   /** @brief COMP channel 1 blanking source selection bits */
    static const uint32_t COMP1_CFGR1_LOCK_MASK       = 0x80000000U;   /** @brief Lock bit */
    static const uint32_t COMP1_CFGR2_EN_MASK         = 0x00000001U;   /** @brief COMP channel 1 enable bit */
    static const uint32_t COMP1_CFGR2_BRGEN_MASK      = 0x00000002U;   /** @brief Scaler bridge enable */
    static const uint32_t COMP1_CFGR2_SCALEN_MASK     = 0x00000004U;   /** @brief Voltage scaler enable bit */
    static const uint32_t COMP1_CFGR2_POLARITY_MASK   = 0x00000008U;   /** @brief COMP channel 1 polarity selection bit */
    static const uint32_t COMP1_CFGR2_WINMODE_MASK    = 0x00000010U;   /** @brief Window comparator mode selection bit */
    static const uint32_t COMP1_CFGR2_ITEN_MASK       = 0x00000040U;   /** @brief COMP channel 1 interrupt enable */
    static const uint32_t COMP1_CFGR2_HYST_MASK       = 0x00000300U;   /** @brief COMP channel 1 hysteresis selection bits */
    static const uint32_t COMP1_CFGR2_PWRMODE_MASK    = 0x00003000U;   /** @brief Power mode of the COMP channel 1 */
    static const uint32_t COMP1_CFGR2_INMSEL_MASK     = 0x00070000U;   /** @brief COMP channel 1 inverting input selection field */
    static const uint32_t COMP1_CFGR2_INPSEL_MASK     = 0x00100000U;   /** @brief COMP channel 1 non-inverting input selection bit */
    static const uint32_t COMP1_CFGR2_BLANKING_MASK   = 0x0F000000U;   /** @brief COMP channel 1 blanking source selection bits */
    static const uint32_t COMP1_CFGR2_LOCK_MASK       = 0x80000000U;   /** @brief Lock bit */

    /**** @subsection Enumerated COMP1 Register Field Masks ****/

    static const uint32_t COMP1_SR_CxVAL_MASK[3] = {
      [1] = 0x00000001U,   /** @brief COMP channel 1 output status bit */
      [2] = 0x00000002U,   /** @brief COMP channel 2 output status bit */
    };

    static const uint32_t COMP1_SR_CxIF_MASK[3] = {
      [1] = 0x00010000U,   /** @brief COMP channel 1 interrupt flag */
      [2] = 0x00020000U,   /** @brief COMP channel 2 interrupt flag */
    };

    static const uint32_t COMP1_ICFR_CCxIF_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Clear COMP channel 1 interrupt flag */
      [2] = 0x00020000U,   /** @brief Clear COMP channel 2 interrupt flag */
    };

    /**** @subsection COMP1 Register Field Positions ****/

    static const int32_t COMP1_OR_AFOP_POS          = 0;    /** @brief Selection of source for alternate function of output ports */
    static const int32_t COMP1_OR_OR_POS            = 11;   /** @brief Option register */
    static const int32_t COMP1_CFGR1_EN_POS         = 0;    /** @brief COMP channel 1 enable bit */
    static const int32_t COMP1_CFGR1_BRGEN_POS      = 1;    /** @brief Scaler bridge enable */
    static const int32_t COMP1_CFGR1_SCALEN_POS     = 2;    /** @brief Voltage scaler enable bit */
    static const int32_t COMP1_CFGR1_POLARITY_POS   = 3;    /** @brief COMP channel 1 polarity selection bit */
    static const int32_t COMP1_CFGR1_ITEN_POS       = 6;    /** @brief COMP channel 1 interrupt enable */
    static const int32_t COMP1_CFGR1_HYST_POS       = 8;    /** @brief COMP channel 1 hysteresis selection bits */
    static const int32_t COMP1_CFGR1_PWRMODE_POS    = 12;   /** @brief Power mode of the COMP channel 1 */
    static const int32_t COMP1_CFGR1_INMSEL_POS     = 16;   /** @brief COMP channel 1 inverting input selection field */
    static const int32_t COMP1_CFGR1_INPSEL_POS     = 20;   /** @brief COMP channel 1 non-inverting input selection bit */
    static const int32_t COMP1_CFGR1_BLANKING_POS   = 24;   /** @brief COMP channel 1 blanking source selection bits */
    static const int32_t COMP1_CFGR1_LOCK_POS       = 31;   /** @brief Lock bit */
    static const int32_t COMP1_CFGR2_EN_POS         = 0;    /** @brief COMP channel 1 enable bit */
    static const int32_t COMP1_CFGR2_BRGEN_POS      = 1;    /** @brief Scaler bridge enable */
    static const int32_t COMP1_CFGR2_SCALEN_POS     = 2;    /** @brief Voltage scaler enable bit */
    static const int32_t COMP1_CFGR2_POLARITY_POS   = 3;    /** @brief COMP channel 1 polarity selection bit */
    static const int32_t COMP1_CFGR2_WINMODE_POS    = 4;    /** @brief Window comparator mode selection bit */
    static const int32_t COMP1_CFGR2_ITEN_POS       = 6;    /** @brief COMP channel 1 interrupt enable */
    static const int32_t COMP1_CFGR2_HYST_POS       = 8;    /** @brief COMP channel 1 hysteresis selection bits */
    static const int32_t COMP1_CFGR2_PWRMODE_POS    = 12;   /** @brief Power mode of the COMP channel 1 */
    static const int32_t COMP1_CFGR2_INMSEL_POS     = 16;   /** @brief COMP channel 1 inverting input selection field */
    static const int32_t COMP1_CFGR2_INPSEL_POS     = 20;   /** @brief COMP channel 1 non-inverting input selection bit */
    static const int32_t COMP1_CFGR2_BLANKING_POS   = 24;   /** @brief COMP channel 1 blanking source selection bits */
    static const int32_t COMP1_CFGR2_LOCK_POS       = 31;   /** @brief Lock bit */

    /**** @subsection Enumerated COMP1 Register Field Positions ****/

    static const int32_t COMP1_SR_CxVAL_POS[3] = {
      [1] = 0,   /** @brief COMP channel 1 output status bit */
      [2] = 1,   /** @brief COMP channel 2 output status bit */
    };

    static const int32_t COMP1_SR_CxIF_POS[3] = {
      [1] = 16,   /** @brief COMP channel 1 interrupt flag */
      [2] = 17,   /** @brief COMP channel 2 interrupt flag */
    };

    static const int32_t COMP1_ICFR_CCxIF_POS[3] = {
      [1] = 16,   /** @brief Clear COMP channel 1 interrupt flag */
      [2] = 17,   /** @brief Clear COMP channel 2 interrupt flag */
    };

    /**********************************************************************************************
     * @section CRS Register Information
     **********************************************************************************************/

    /**** @subsection CRS Register Pointers ****/

    static RW_ uint32_t* const CRS_CR_PTR     = (RW_ uint32_t* const)0x40008400U;   /** @brief CRS control register */
    static RW_ uint32_t* const CRS_CFGR_PTR   = (RW_ uint32_t* const)0x40008404U;   /** @brief This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected. */
    static RO_ uint32_t* const CRS_ISR_PTR    = (RO_ uint32_t* const)0x40008408U;   /** @brief CRS interrupt and status register */
    static RW_ uint32_t* const CRS_ICR_PTR    = (RW_ uint32_t* const)0x4000840CU;   /** @brief CRS interrupt flag clear register */

    /**** @subsection CRS Register Reset Values ****/

    static const uint32_t CRS_CR_RST     = 0x00002000U;   /** @brief CR register reset value. */
    static const uint32_t CRS_CFGR_RST   = 0x2022BB7FU;   /** @brief CFGR register reset value. */
    static const uint32_t CRS_ISR_RST    = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t CRS_ICR_RST    = 0x00000000U;   /** @brief ICR register reset value. */

    /**** @subsection Enumerated CRS Register Value Types ****/

    typedef uint32_t CRS_CR_t;     /** @brief CR register value type. */
    typedef uint32_t CRS_CFGR_t;   /** @brief CFGR register value type. */
    typedef uint32_t CRS_ISR_t;    /** @brief ISR register value type. */
    typedef uint32_t CRS_ICR_t;    /** @brief ICR register value type. */

    /**** @subsection Enumerated CRS Register Pointer Types ****/

    typedef uint32_t* const CRS_CR_PTR_t;     /** @brief CR register pointer type. */
    typedef uint32_t* const CRS_CFGR_PTR_t;   /** @brief CFGR register pointer type. */
    typedef uint32_t* const CRS_ISR_PTR_t;    /** @brief ISR register pointer type. */
    typedef uint32_t* const CRS_ICR_PTR_t;    /** @brief ICR register pointer type. */

    /**** @subsection CRS Register Field Masks ****/

    static const uint32_t CRS_CR_SYNCOKIE_MASK     = 0x00000001U;   /** @brief SYNC event OK interrupt enable */
    static const uint32_t CRS_CR_SYNCWARNIE_MASK   = 0x00000002U;   /** @brief SYNC warning interrupt enable */
    static const uint32_t CRS_CR_ERRIE_MASK        = 0x00000004U;   /** @brief Synchronization or trimming error interrupt enable */
    static const uint32_t CRS_CR_ESYNCIE_MASK      = 0x00000008U;   /** @brief Expected SYNC interrupt enable */
    static const uint32_t CRS_CR_CEN_MASK          = 0x00000020U;   /** @brief Frequency error counter enable this bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified. */
    static const uint32_t CRS_CR_AUTOTRIMEN_MASK   = 0x00000040U;   /** @brief Automatic trimming enable this bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details. */
    static const uint32_t CRS_CR_SWSYNC_MASK       = 0x00000080U;   /** @brief Generate software SYNC event this bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware. */
    static const uint32_t CRS_CR_TRIM_MASK         = 0x00003F00U;   /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
    static const uint32_t CRS_CFGR_RELOAD_MASK     = 0x0000FFFFU;   /** @brief Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to section7.3.3: frequency error measurement for more details about counter behavior. */
    static const uint32_t CRS_CFGR_FELIM_MASK      = 0x00FF0000U;   /** @brief Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP evaluation. */
    static const uint32_t CRS_CFGR_SYNCDIV_MASK    = 0x07000000U;   /** @brief SYNC divider these bits are set and cleared by software to control the division factor of the SYNC signal. */
    static const uint32_t CRS_CFGR_SYNCSRC_MASK    = 0x30000000U;   /** @brief SYNC signal source selection these bits are set and cleared by software to select the SYNC signal source. Note: when using USB LPM (link power management) and the device is in sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from sleep mode, the LSE or reference clock on the gpios should be used as SYNC signal. */
    static const uint32_t CRS_CFGR_SYNCPOL_MASK    = 0x80000000U;   /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
    static const uint32_t CRS_ISR_SYNCOKF_MASK     = 0x00000001U;   /** @brief SYNC event OK flag this flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_SYNCWARNF_MASK   = 0x00000002U;   /** @brief SYNC warning flag this flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_ERRF_MASK        = 0x00000004U;   /** @brief Error flag this flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits. */
    static const uint32_t CRS_ISR_ESYNCF_MASK      = 0x00000008U;   /** @brief Expected SYNC flag this flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_SYNCERR_MASK     = 0x00000100U;   /** @brief SYNC error this flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_SYNCMISS_MASK    = 0x00000200U;   /** @brief SYNC missed this flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_TRIMOVF_MASK     = 0x00000400U;   /** @brief Trimming overflow or underflow this flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_FEDIR_MASK       = 0x00008000U;   /** @brief Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target. */
    static const uint32_t CRS_ISR_FECAP_MASK       = 0xFFFF0000U;   /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
    static const uint32_t CRS_ICR_SYNCOKC_MASK     = 0x00000001U;   /** @brief SYNC event OK clear flag writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register. */
    static const uint32_t CRS_ICR_SYNCWARNC_MASK   = 0x00000002U;   /** @brief SYNC warning clear flag writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register. */
    static const uint32_t CRS_ICR_ERRC_MASK        = 0x00000004U;   /** @brief Error clear flag writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register. */
    static const uint32_t CRS_ICR_ESYNCC_MASK      = 0x00000008U;   /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

    /**** @subsection CRS Register Field Positions ****/

    static const int32_t CRS_CR_SYNCOKIE_POS     = 0;    /** @brief SYNC event OK interrupt enable */
    static const int32_t CRS_CR_SYNCWARNIE_POS   = 1;    /** @brief SYNC warning interrupt enable */
    static const int32_t CRS_CR_ERRIE_POS        = 2;    /** @brief Synchronization or trimming error interrupt enable */
    static const int32_t CRS_CR_ESYNCIE_POS      = 3;    /** @brief Expected SYNC interrupt enable */
    static const int32_t CRS_CR_CEN_POS          = 5;    /** @brief Frequency error counter enable this bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified. */
    static const int32_t CRS_CR_AUTOTRIMEN_POS   = 6;    /** @brief Automatic trimming enable this bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details. */
    static const int32_t CRS_CR_SWSYNC_POS       = 7;    /** @brief Generate software SYNC event this bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware. */
    static const int32_t CRS_CR_TRIM_POS         = 8;    /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
    static const int32_t CRS_CFGR_RELOAD_POS     = 0;    /** @brief Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to section7.3.3: frequency error measurement for more details about counter behavior. */
    static const int32_t CRS_CFGR_FELIM_POS      = 16;   /** @brief Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP evaluation. */
    static const int32_t CRS_CFGR_SYNCDIV_POS    = 24;   /** @brief SYNC divider these bits are set and cleared by software to control the division factor of the SYNC signal. */
    static const int32_t CRS_CFGR_SYNCSRC_POS    = 28;   /** @brief SYNC signal source selection these bits are set and cleared by software to select the SYNC signal source. Note: when using USB LPM (link power management) and the device is in sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from sleep mode, the LSE or reference clock on the gpios should be used as SYNC signal. */
    static const int32_t CRS_CFGR_SYNCPOL_POS    = 31;   /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
    static const int32_t CRS_ISR_SYNCOKF_POS     = 0;    /** @brief SYNC event OK flag this flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register. */
    static const int32_t CRS_ISR_SYNCWARNF_POS   = 1;    /** @brief SYNC warning flag this flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register. */
    static const int32_t CRS_ISR_ERRF_POS        = 2;    /** @brief Error flag this flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits. */
    static const int32_t CRS_ISR_ESYNCF_POS      = 3;    /** @brief Expected SYNC flag this flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register. */
    static const int32_t CRS_ISR_SYNCERR_POS     = 8;    /** @brief SYNC error this flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const int32_t CRS_ISR_SYNCMISS_POS    = 9;    /** @brief SYNC missed this flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const int32_t CRS_ISR_TRIMOVF_POS     = 10;   /** @brief Trimming overflow or underflow this flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const int32_t CRS_ISR_FEDIR_POS       = 15;   /** @brief Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target. */
    static const int32_t CRS_ISR_FECAP_POS       = 16;   /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
    static const int32_t CRS_ICR_SYNCOKC_POS     = 0;    /** @brief SYNC event OK clear flag writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register. */
    static const int32_t CRS_ICR_SYNCWARNC_POS   = 1;    /** @brief SYNC warning clear flag writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register. */
    static const int32_t CRS_ICR_ERRC_POS        = 2;    /** @brief Error clear flag writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register. */
    static const int32_t CRS_ICR_ESYNCC_POS      = 3;    /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

    /**********************************************************************************************
     * @section DAC Register Information
     **********************************************************************************************/

    /**** @subsection DAC Register Pointers ****/

    static RW_ uint32_t* const DAC_CR_PTR        = (RW_ uint32_t* const)0x40007400U;   /** @brief DAC control register */
    static RW_ uint32_t* const DAC_SWTRGR_PTR    = (RW_ uint32_t* const)0x40007404U;   /** @brief DAC software trigger register */
    static RW_ uint32_t* const DAC_DHR12RD_PTR   = (RW_ uint32_t* const)0x40007420U;   /** @brief Dual DAC 12-bit right-aligned data holding register */
    static RW_ uint32_t* const DAC_DHR12LD_PTR   = (RW_ uint32_t* const)0x40007424U;   /** @brief DUAL DAC 12-bit left aligned data holding register */
    static RW_ uint32_t* const DAC_DHR8RD_PTR    = (RW_ uint32_t* const)0x40007428U;   /** @brief DUAL DAC 8-bit right aligned data holding register */
    static RW_ uint32_t* const DAC_SR_PTR        = (RW_ uint32_t* const)0x40007434U;   /** @brief DAC status register */
    static RW_ uint32_t* const DAC_CCR_PTR       = (RW_ uint32_t* const)0x40007438U;   /** @brief DAC calibration control register */
    static RW_ uint32_t* const DAC_MCR_PTR       = (RW_ uint32_t* const)0x4000743CU;   /** @brief DAC mode control register */
    static RW_ uint32_t* const DAC_SHHR_PTR      = (RW_ uint32_t* const)0x40007448U;   /** @brief DAC sample and hold hold time register */
    static RW_ uint32_t* const DAC_SHRR_PTR      = (RW_ uint32_t* const)0x4000744CU;   /** @brief DAC sample and hold refresh time register */

    /**** @subsection Enumerated DAC Register Pointers ****/

    static RW_ uint32_t* const DAC_DHR12Rx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40007408U,   /** @brief DAC channel1 12-bit right-aligned data holding register */
      [2] = (RW_ uint32_t* const)0x40007414U,   /** @brief DAC channel2 12-bit right aligned data holding register */
    };

    static RW_ uint32_t* const DAC_DHR12Lx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000740CU,   /** @brief DAC channel1 12-bit left aligned data holding register */
      [2] = (RW_ uint32_t* const)0x40007418U,   /** @brief DAC channel2 12-bit left aligned data holding register */
    };

    static RW_ uint32_t* const DAC_DHR8Rx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40007410U,   /** @brief DAC channel1 8-bit right aligned data holding register */
      [2] = (RW_ uint32_t* const)0x4000741CU,   /** @brief DAC channel2 8-bit right-aligned data holding register */
    };

    static RO_ uint32_t* const DAC_DORx_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000742CU,   /** @brief DAC channel1 data output register */
      [2] = (RO_ uint32_t* const)0x40007430U,   /** @brief DAC channel2 data output register */
    };

    static RW_ uint32_t* const DAC_SHSRx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40007440U,   /** @brief DAC sample and hold sample time register 1 */
      [2] = (RW_ uint32_t* const)0x40007444U,   /** @brief DAC sample and hold sample time register 2 */
    };

    /**** @subsection DAC Register Reset Values ****/

    static const uint32_t DAC_CR_RST        = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t DAC_SWTRGR_RST    = 0x00000000U;   /** @brief SWTRGR register reset value. */
    static const uint32_t DAC_DHR12RD_RST   = 0x00000000U;   /** @brief DHR12RD register reset value. */
    static const uint32_t DAC_DHR12LD_RST   = 0x00000000U;   /** @brief DHR12LD register reset value. */
    static const uint32_t DAC_DHR8RD_RST    = 0x00000000U;   /** @brief DHR8RD register reset value. */
    static const uint32_t DAC_SR_RST        = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t DAC_CCR_RST       = 0x00000000U;   /** @brief CCR register reset value. */
    static const uint32_t DAC_MCR_RST       = 0x00000000U;   /** @brief MCR register reset value. */
    static const uint32_t DAC_SHHR_RST      = 0x00010001U;   /** @brief SHHR register reset value. */
    static const uint32_t DAC_SHRR_RST      = 0x00010001U;   /** @brief SHRR register reset value. */

    /**** @subsection Enumerated DAC Register Reset Values ****/

    static const uint32_t DAC_DHR12Rx_RST[3] = {
      [1] = 0x00000000U,   /** @brief DHR12R1 register reset value. */
      [2] = 0x00000000U,   /** @brief DHR12R2 register reset value. */
    };

    static const uint32_t DAC_DHR12Lx_RST[3] = {
      [1] = 0x00000000U,   /** @brief DHR12L1 register reset value. */
      [2] = 0x00000000U,   /** @brief DHR12L2 register reset value. */
    };

    static const uint32_t DAC_DHR8Rx_RST[3] = {
      [1] = 0x00000000U,   /** @brief DHR8R1 register reset value. */
      [2] = 0x00000000U,   /** @brief DHR8R2 register reset value. */
    };

    static const uint32_t DAC_DORx_RST[3] = {
      [1] = 0x00000000U,   /** @brief DOR1 register reset value. */
      [2] = 0x00000000U,   /** @brief DOR2 register reset value. */
    };

    static const uint32_t DAC_SHSRx_RST[3] = {
      [1] = 0x00000000U,   /** @brief SHSR1 register reset value. */
      [2] = 0x00000000U,   /** @brief SHSR2 register reset value. */
    };

    /**** @subsection Enumerated DAC Register Value Types ****/

    typedef uint32_t DAC_CR_t;        /** @brief CR register value type. */
    typedef uint32_t DAC_SWTRGR_t;    /** @brief SWTRGR register value type. */
    typedef uint32_t DAC_DHR12Rx_t;   /** @brief DHR12Rx register value type. */
    typedef uint32_t DAC_DHR12Lx_t;   /** @brief DHR12Lx register value type. */
    typedef uint32_t DAC_DHR8Rx_t;    /** @brief DHR8Rx register value type. */
    typedef uint32_t DAC_DHR12RD_t;   /** @brief DHR12RD register value type. */
    typedef uint32_t DAC_DHR12LD_t;   /** @brief DHR12LD register value type. */
    typedef uint32_t DAC_DHR8RD_t;    /** @brief DHR8RD register value type. */
    typedef uint32_t DAC_DORx_t;      /** @brief DORx register value type. */
    typedef uint32_t DAC_SR_t;        /** @brief SR register value type. */
    typedef uint32_t DAC_CCR_t;       /** @brief CCR register value type. */
    typedef uint32_t DAC_MCR_t;       /** @brief MCR register value type. */
    typedef uint32_t DAC_SHSRx_t;     /** @brief SHSRx register value type. */
    typedef uint32_t DAC_SHHR_t;      /** @brief SHHR register value type. */
    typedef uint32_t DAC_SHRR_t;      /** @brief SHRR register value type. */

    /**** @subsection Enumerated DAC Register Pointer Types ****/

    typedef uint32_t* const DAC_CR_PTR_t;        /** @brief CR register pointer type. */
    typedef uint32_t* const DAC_SWTRGR_PTR_t;    /** @brief SWTRGR register pointer type. */
    typedef uint32_t* const DAC_DHR12Rx_PTR_t;   /** @brief DHR12Rx register pointer type. */
    typedef uint32_t* const DAC_DHR12Lx_PTR_t;   /** @brief DHR12Lx register pointer type. */
    typedef uint32_t* const DAC_DHR8Rx_PTR_t;    /** @brief DHR8Rx register pointer type. */
    typedef uint32_t* const DAC_DHR12RD_PTR_t;   /** @brief DHR12RD register pointer type. */
    typedef uint32_t* const DAC_DHR12LD_PTR_t;   /** @brief DHR12LD register pointer type. */
    typedef uint32_t* const DAC_DHR8RD_PTR_t;    /** @brief DHR8RD register pointer type. */
    typedef uint32_t* const DAC_DORx_PTR_t;      /** @brief DORx register pointer type. */
    typedef uint32_t* const DAC_SR_PTR_t;        /** @brief SR register pointer type. */
    typedef uint32_t* const DAC_CCR_PTR_t;       /** @brief CCR register pointer type. */
    typedef uint32_t* const DAC_MCR_PTR_t;       /** @brief MCR register pointer type. */
    typedef uint32_t* const DAC_SHSRx_PTR_t;     /** @brief SHSRx register pointer type. */
    typedef uint32_t* const DAC_SHHR_PTR_t;      /** @brief SHHR register pointer type. */
    typedef uint32_t* const DAC_SHRR_PTR_t;      /** @brief SHRR register pointer type. */

    /**** @subsection DAC Register Field Masks ****/

    static const uint32_t DAC_DHR12Rx_DACC1DHR_MASK   = 0x00000FFFU;   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const uint32_t DAC_DHR12Lx_DACC1DHR_MASK   = 0x0000FFF0U;   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const uint32_t DAC_DHR8Rx_DACC1DHR_MASK    = 0x000000FFU;   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
    static const uint32_t DAC_DORx_DACC1DOR_MASK      = 0x00000FFFU;   /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
    static const uint32_t DAC_SHSRx_TSAMPLE1_MASK     = 0x000003FFU;   /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */

    /**** @subsection Enumerated DAC Register Field Masks ****/

    static const uint32_t DAC_CR_ENx_MASK[3] = {
      [1] = 0x00000001U,   /** @brief DAC channel1 enable this bit is set and cleared by software to enable/disable DAC channel1. */
      [2] = 0x00010000U,   /** @brief DAC channel2 enable this bit is set and cleared by software to enable/disable DAC channel2. */
    };

    static const uint32_t DAC_CR_TENx_MASK[3] = {
      [1] = 0x00000002U,   /** @brief DAC channel1 trigger enable */
      [2] = 0x00020000U,   /** @brief DAC channel2 trigger enable */
    };

    static const uint32_t DAC_CR_TSELx_MASK[3] = {
      [1] = 0x0000001CU,   /** @brief DAC channel1 trigger selection these bits select the external event used to trigger DAC channel1. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
      [2] = 0x001C0000U,   /** @brief DAC channel2 trigger selection these bits select the external event used to trigger DAC channel2 note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
    };

    static const uint32_t DAC_CR_WAVEx_MASK[3] = {
      [1] = 0x000000C0U,   /** @brief DAC channel1 noise/triangle wave generation enable these bits are set and cleared by software. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
      [2] = 0x00C00000U,   /** @brief DAC channel2 noise/triangle wave generation enable these bits are set/reset by software. 1x: triangle wave generation enabled note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled) */
    };

    static const uint32_t DAC_CR_MAMPx_MASK[3] = {
      [1] = 0x00000F00U,   /** @brief DAC channel1 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
      [2] = 0x0F000000U,   /** @brief DAC channel2 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    };

    static const uint32_t DAC_CR_DMAENx_MASK[3] = {
      [1] = 0x00001000U,   /** @brief DAC channel1 DMA enable this bit is set and cleared by software. */
      [2] = 0x10000000U,   /** @brief DAC channel2 DMA enable this bit is set and cleared by software. */
    };

    static const uint32_t DAC_CR_DMAUDRIEx_MASK[3] = {
      [1] = 0x00002000U,   /** @brief DAC channel1 DMA underrun interrupt enable this bit is set and cleared by software. */
      [2] = 0x20000000U,   /** @brief DAC channel2 DMA underrun interrupt enable this bit is set and cleared by software. */
    };

    static const uint32_t DAC_CR_CENx_MASK[3] = {
      [1] = 0x00004000U,   /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
      [2] = 0x40000000U,   /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    };

    static const uint32_t DAC_SWTRGR_SWTRIGx_MASK[3] = {
      [1] = 0x00000001U,   /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
      [2] = 0x00000002U,   /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
    };

    static const uint32_t DAC_DHR12RD_DACCxDHR_MASK[3] = {
      [1] = 0x00000FFFU,   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
      [2] = 0x0FFF0000U,   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    };

    static const uint32_t DAC_SR_DMAUDRx_MASK[3] = {
      [1] = 0x00002000U,   /** @brief DAC channel1 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
      [2] = 0x20000000U,   /** @brief DAC channel2 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    };

    static const uint32_t DAC_SR_CAL_FLAGx_MASK[3] = {
      [1] = 0x00004000U,   /** @brief DAC channel 1 calibration offset status this bit is set and cleared by hardware */
      [2] = 0x40000000U,   /** @brief DAC channel 2 calibration offset status this bit is set and cleared by hardware */
    };

    static const uint32_t DAC_SR_BWSTx_MASK[3] = {
      [1] = 0x00008000U,   /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
      [2] = 0x80000000U,   /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
    };

    static const uint32_t DAC_CCR_OTRIMx_MASK[3] = {
      [1] = 0x0000001FU,   /** @brief DAC channel 1 offset trimming value */
      [2] = 0x001F0000U,   /** @brief DAC channel 2 offset trimming value */
    };

    static const uint32_t DAC_MCR_MODEx_MASK[3] = {
      [1] = 0x00000007U,   /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode */
      [2] = 0x00070000U,   /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode */
    };

    static const uint32_t DAC_SHHR_THOLDx_MASK[3] = {
      [1] = 0x000003FFU,   /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI */
      [2] = 0x03FF0000U,   /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI */
    };

    static const uint32_t DAC_SHRR_TREFRESHx_MASK[3] = {
      [1] = 0x000000FFU,   /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
      [2] = 0x00FF0000U,   /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
    };

    /**** @subsection DAC Register Field Positions ****/

    static const int32_t DAC_DHR12Rx_DACC1DHR_POS   = 0;   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const int32_t DAC_DHR12Lx_DACC1DHR_POS   = 4;   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const int32_t DAC_DHR8Rx_DACC1DHR_POS    = 0;   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
    static const int32_t DAC_DORx_DACC1DOR_POS      = 0;   /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
    static const int32_t DAC_SHSRx_TSAMPLE1_POS     = 0;   /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */

    /**** @subsection Enumerated DAC Register Field Positions ****/

    static const int32_t DAC_CR_ENx_POS[3] = {
      [1] = 0,    /** @brief DAC channel1 enable this bit is set and cleared by software to enable/disable DAC channel1. */
      [2] = 16,   /** @brief DAC channel2 enable this bit is set and cleared by software to enable/disable DAC channel2. */
    };

    static const int32_t DAC_CR_TENx_POS[3] = {
      [1] = 1,    /** @brief DAC channel1 trigger enable */
      [2] = 17,   /** @brief DAC channel2 trigger enable */
    };

    static const int32_t DAC_CR_TSELx_POS[3] = {
      [1] = 2,    /** @brief DAC channel1 trigger selection these bits select the external event used to trigger DAC channel1. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
      [2] = 18,   /** @brief DAC channel2 trigger selection these bits select the external event used to trigger DAC channel2 note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
    };

    static const int32_t DAC_CR_WAVEx_POS[3] = {
      [1] = 6,    /** @brief DAC channel1 noise/triangle wave generation enable these bits are set and cleared by software. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
      [2] = 22,   /** @brief DAC channel2 noise/triangle wave generation enable these bits are set/reset by software. 1x: triangle wave generation enabled note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled) */
    };

    static const int32_t DAC_CR_MAMPx_POS[3] = {
      [1] = 8,    /** @brief DAC channel1 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
      [2] = 24,   /** @brief DAC channel2 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    };

    static const int32_t DAC_CR_DMAENx_POS[3] = {
      [1] = 12,   /** @brief DAC channel1 DMA enable this bit is set and cleared by software. */
      [2] = 28,   /** @brief DAC channel2 DMA enable this bit is set and cleared by software. */
    };

    static const int32_t DAC_CR_DMAUDRIEx_POS[3] = {
      [1] = 13,   /** @brief DAC channel1 DMA underrun interrupt enable this bit is set and cleared by software. */
      [2] = 29,   /** @brief DAC channel2 DMA underrun interrupt enable this bit is set and cleared by software. */
    };

    static const int32_t DAC_CR_CENx_POS[3] = {
      [1] = 14,   /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
      [2] = 30,   /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    };

    static const int32_t DAC_SWTRGR_SWTRIGx_POS[3] = {
      [1] = 0,   /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
      [2] = 1,   /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
    };

    static const int32_t DAC_DHR12RD_DACCxDHR_POS[3] = {
      [1] = 0,    /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
      [2] = 16,   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    };

    static const int32_t DAC_SR_DMAUDRx_POS[3] = {
      [1] = 13,   /** @brief DAC channel1 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
      [2] = 29,   /** @brief DAC channel2 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    };

    static const int32_t DAC_SR_CAL_FLAGx_POS[3] = {
      [1] = 14,   /** @brief DAC channel 1 calibration offset status this bit is set and cleared by hardware */
      [2] = 30,   /** @brief DAC channel 2 calibration offset status this bit is set and cleared by hardware */
    };

    static const int32_t DAC_SR_BWSTx_POS[3] = {
      [1] = 15,   /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
      [2] = 31,   /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
    };

    static const int32_t DAC_CCR_OTRIMx_POS[3] = {
      [1] = 0,    /** @brief DAC channel 1 offset trimming value */
      [2] = 16,   /** @brief DAC channel 2 offset trimming value */
    };

    static const int32_t DAC_MCR_MODEx_POS[3] = {
      [1] = 0,    /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode */
      [2] = 16,   /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode */
    };

    static const int32_t DAC_SHHR_THOLDx_POS[3] = {
      [1] = 0,    /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI */
      [2] = 16,   /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI */
    };

    static const int32_t DAC_SHRR_TREFRESHx_POS[3] = {
      [1] = 0,    /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
      [2] = 16,   /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
    };

    /**********************************************************************************************
     * @section BDMA Register Information
     **********************************************************************************************/

    /**** @subsection BDMA Register Pointers ****/

    static RO_ uint32_t* const BDMA_ISR_PTR    = (RO_ uint32_t* const)0x58025400U;   /** @brief DMA interrupt status register */
    static RW_ uint32_t* const BDMA_IFCR_PTR   = (RW_ uint32_t* const)0x58025404U;   /** @brief DMA interrupt flag clear register */

    /**** @subsection Enumerated BDMA Register Pointers ****/

    static RW_ uint32_t* const BDMA_CCRx_PTR[9] = {
      [1] = (RW_ uint32_t* const)0x58025408U,   /** @brief DMA channel x configuration register */
      [2] = (RW_ uint32_t* const)0x5802541CU,   /** @brief DMA channel x configuration register */
      [3] = (RW_ uint32_t* const)0x58025430U,   /** @brief DMA channel x configuration register */
      [4] = (RW_ uint32_t* const)0x58025444U,   /** @brief DMA channel x configuration register */
      [5] = (RW_ uint32_t* const)0x58025458U,   /** @brief DMA channel x configuration register */
      [6] = (RW_ uint32_t* const)0x5802546CU,   /** @brief DMA channel x configuration register */
      [7] = (RW_ uint32_t* const)0x58025480U,   /** @brief DMA channel x configuration register */
      [8] = (RW_ uint32_t* const)0x58025494U,   /** @brief DMA channel x configuration register */
    };

    static RW_ uint32_t* const BDMA_CNDTRx_PTR[9] = {
      [1] = (RW_ uint32_t* const)0x5802540CU,   /** @brief DMA channel x number of data register */
      [2] = (RW_ uint32_t* const)0x58025420U,   /** @brief DMA channel x number of data register */
      [3] = (RW_ uint32_t* const)0x58025434U,   /** @brief DMA channel x number of data register */
      [4] = (RW_ uint32_t* const)0x58025448U,   /** @brief DMA channel x number of data register */
      [5] = (RW_ uint32_t* const)0x5802545CU,   /** @brief DMA channel x number of data register */
      [6] = (RW_ uint32_t* const)0x58025470U,   /** @brief DMA channel x number of data register */
      [7] = (RW_ uint32_t* const)0x58025484U,   /** @brief DMA channel x number of data register */
      [8] = (RW_ uint32_t* const)0x58025498U,   /** @brief DMA channel x number of data register */
    };

    static RW_ uint32_t* const BDMA_CPARx_PTR[9] = {
      [1] = (RW_ uint32_t* const)0x58025410U,   /** @brief This register must not be written when the channel is enabled. */
      [2] = (RW_ uint32_t* const)0x58025424U,   /** @brief This register must not be written when the channel is enabled. */
      [3] = (RW_ uint32_t* const)0x58025438U,   /** @brief This register must not be written when the channel is enabled. */
      [4] = (RW_ uint32_t* const)0x5802544CU,   /** @brief This register must not be written when the channel is enabled. */
      [5] = (RW_ uint32_t* const)0x58025460U,   /** @brief This register must not be written when the channel is enabled. */
      [6] = (RW_ uint32_t* const)0x58025474U,   /** @brief This register must not be written when the channel is enabled. */
      [7] = (RW_ uint32_t* const)0x58025488U,   /** @brief This register must not be written when the channel is enabled. */
      [8] = (RW_ uint32_t* const)0x5802549CU,   /** @brief This register must not be written when the channel is enabled. */
    };

    static RW_ uint32_t* const BDMA_CMARx_PTR[9] = {
      [1] = (RW_ uint32_t* const)0x58025414U,   /** @brief This register must not be written when the channel is enabled. */
      [2] = (RW_ uint32_t* const)0x58025428U,   /** @brief This register must not be written when the channel is enabled. */
      [3] = (RW_ uint32_t* const)0x5802543CU,   /** @brief This register must not be written when the channel is enabled. */
      [4] = (RW_ uint32_t* const)0x58025450U,   /** @brief This register must not be written when the channel is enabled. */
      [5] = (RW_ uint32_t* const)0x58025464U,   /** @brief This register must not be written when the channel is enabled. */
      [6] = (RW_ uint32_t* const)0x58025478U,   /** @brief This register must not be written when the channel is enabled. */
      [7] = (RW_ uint32_t* const)0x5802548CU,   /** @brief This register must not be written when the channel is enabled. */
      [8] = (RW_ uint32_t* const)0x580254A0U,   /** @brief This register must not be written when the channel is enabled. */
    };

    /**** @subsection BDMA Register Reset Values ****/

    static const uint32_t BDMA_ISR_RST    = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t BDMA_IFCR_RST   = 0x00000000U;   /** @brief IFCR register reset value. */

    /**** @subsection Enumerated BDMA Register Reset Values ****/

    static const uint32_t BDMA_CCRx_RST[9] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
      [5] = 0x00000000U,   /** @brief CCR5 register reset value. */
      [6] = 0x00000000U,   /** @brief CCR6 register reset value. */
      [7] = 0x00000000U,   /** @brief CCR7 register reset value. */
      [8] = 0x00000000U,   /** @brief CCR8 register reset value. */
    };

    static const uint32_t BDMA_CNDTRx_RST[9] = {
      [1] = 0x00000000U,   /** @brief CNDTR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CNDTR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CNDTR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CNDTR4 register reset value. */
      [5] = 0x00000000U,   /** @brief CNDTR5 register reset value. */
      [6] = 0x00000000U,   /** @brief CNDTR6 register reset value. */
      [7] = 0x00000000U,   /** @brief CNDTR7 register reset value. */
      [8] = 0x00000000U,   /** @brief CNDTR8 register reset value. */
    };

    static const uint32_t BDMA_CPARx_RST[9] = {
      [1] = 0x00000000U,   /** @brief CPAR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CPAR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CPAR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CPAR4 register reset value. */
      [5] = 0x00000000U,   /** @brief CPAR5 register reset value. */
      [6] = 0x00000000U,   /** @brief CPAR6 register reset value. */
      [7] = 0x00000000U,   /** @brief CPAR7 register reset value. */
      [8] = 0x00000000U,   /** @brief CPAR8 register reset value. */
    };

    static const uint32_t BDMA_CMARx_RST[9] = {
      [1] = 0x00000000U,   /** @brief CMAR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CMAR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CMAR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CMAR4 register reset value. */
      [5] = 0x00000000U,   /** @brief CMAR5 register reset value. */
      [6] = 0x00000000U,   /** @brief CMAR6 register reset value. */
      [7] = 0x00000000U,   /** @brief CMAR7 register reset value. */
      [8] = 0x00000000U,   /** @brief CMAR8 register reset value. */
    };

    /**** @subsection Enumerated BDMA Register Value Types ****/

    typedef uint32_t BDMA_ISR_t;      /** @brief ISR register value type. */
    typedef uint32_t BDMA_IFCR_t;     /** @brief IFCR register value type. */
    typedef uint32_t BDMA_CCRx_t;     /** @brief CCRx register value type. */
    typedef uint32_t BDMA_CNDTRx_t;   /** @brief CNDTRx register value type. */
    typedef uint32_t BDMA_CPARx_t;    /** @brief CPARx register value type. */
    typedef uint32_t BDMA_CMARx_t;    /** @brief CMARx register value type. */

    /**** @subsection Enumerated BDMA Register Pointer Types ****/

    typedef uint32_t* const BDMA_ISR_PTR_t;      /** @brief ISR register pointer type. */
    typedef uint32_t* const BDMA_IFCR_PTR_t;     /** @brief IFCR register pointer type. */
    typedef uint32_t* const BDMA_CCRx_PTR_t;     /** @brief CCRx register pointer type. */
    typedef uint32_t* const BDMA_CNDTRx_PTR_t;   /** @brief CNDTRx register pointer type. */
    typedef uint32_t* const BDMA_CPARx_PTR_t;    /** @brief CPARx register pointer type. */
    typedef uint32_t* const BDMA_CMARx_PTR_t;    /** @brief CMARx register pointer type. */

    /**** @subsection BDMA Register Field Masks ****/

    static const uint32_t BDMA_CCRx_EN_MASK        = 0x00000001U;   /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_TCIE_MASK      = 0x00000002U;   /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_HTIE_MASK      = 0x00000004U;   /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_TEIE_MASK      = 0x00000008U;   /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_DIR_MASK       = 0x00000010U;   /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_CIRC_MASK      = 0x00000020U;   /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_PINC_MASK      = 0x00000040U;   /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_MINC_MASK      = 0x00000080U;   /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRx_PSIZE_MASK     = 0x00000300U;   /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRx_MSIZE_MASK     = 0x00000C00U;   /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRx_PL_MASK        = 0x00003000U;   /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRx_MEM2MEM_MASK   = 0x00004000U;   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRx_NDT_MASK     = 0x0000FFFFU;   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */

    /**** @subsection Enumerated BDMA Register Field Masks ****/

    static const uint32_t BDMA_ISR_GIFx_MASK[9] = {
      [1] = 0x00000001U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 0x00000010U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 0x00000100U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 0x00001000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 0x00010000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 0x00100000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 0x01000000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 0x10000000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_ISR_TCIFx_MASK[9] = {
      [1] = 0x00000002U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 0x00000020U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 0x00000200U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 0x00002000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 0x00020000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 0x00200000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 0x02000000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 0x20000000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_ISR_HTIFx_MASK[9] = {
      [1] = 0x00000004U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 0x00000040U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 0x00000400U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 0x00004000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 0x00040000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 0x00400000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 0x04000000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 0x40000000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_ISR_TEIFx_MASK[9] = {
      [1] = 0x00000008U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 0x00000080U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 0x00000800U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 0x00008000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 0x00080000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 0x00800000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 0x08000000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 0x80000000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_IFCR_CGIFx_MASK[9] = {
      [1] = 0x00000001U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [2] = 0x00000010U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [3] = 0x00000100U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [4] = 0x00001000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [5] = 0x00010000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [6] = 0x00100000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [7] = 0x01000000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [8] = 0x10000000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_IFCR_CTCIFx_MASK[9] = {
      [1] = 0x00000002U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [2] = 0x00000020U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [3] = 0x00000200U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [4] = 0x00002000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [5] = 0x00020000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [6] = 0x00200000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [7] = 0x02000000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [8] = 0x20000000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_IFCR_CHTIFx_MASK[9] = {
      [1] = 0x00000004U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [2] = 0x00000040U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [3] = 0x00000400U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [4] = 0x00004000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [5] = 0x00040000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [6] = 0x00400000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [7] = 0x04000000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [8] = 0x40000000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_IFCR_CTEIFx_MASK[9] = {
      [1] = 0x00000008U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [2] = 0x00000080U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [3] = 0x00000800U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [4] = 0x00008000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [5] = 0x00080000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [6] = 0x00800000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [7] = 0x08000000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [8] = 0x80000000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    };

    /**** @subsection BDMA Register Field Positions ****/

    static const int32_t BDMA_CCRx_EN_POS        = 0;    /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_TCIE_POS      = 1;    /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_HTIE_POS      = 2;    /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_TEIE_POS      = 3;    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_DIR_POS       = 4;    /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_CIRC_POS      = 5;    /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_PINC_POS      = 6;    /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_MINC_POS      = 7;    /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CCRx_PSIZE_POS     = 8;    /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CCRx_MSIZE_POS     = 10;   /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CCRx_PL_POS        = 12;   /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CCRx_MEM2MEM_POS   = 14;   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CNDTRx_NDT_POS     = 0;    /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */

    /**** @subsection Enumerated BDMA Register Field Positions ****/

    static const int32_t BDMA_ISR_GIFx_POS[9] = {
      [1] = 0,    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 4,    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 8,    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 12,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 16,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 20,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 24,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 28,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_ISR_TCIFx_POS[9] = {
      [1] = 1,    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 5,    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 9,    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 13,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 17,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 21,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 25,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 29,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_ISR_HTIFx_POS[9] = {
      [1] = 2,    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 6,    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 10,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 14,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 18,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 22,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 26,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 30,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_ISR_TEIFx_POS[9] = {
      [1] = 3,    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [2] = 7,    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 11,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 15,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 19,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 23,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 27,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 31,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_IFCR_CGIFx_POS[9] = {
      [1] = 0,    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [2] = 4,    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [3] = 8,    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [4] = 12,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [5] = 16,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [6] = 20,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [7] = 24,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      [8] = 28,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    };

    static const int32_t BDMA_IFCR_CTCIFx_POS[9] = {
      [1] = 1,    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [2] = 5,    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [3] = 9,    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [4] = 13,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [5] = 17,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [6] = 21,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [7] = 25,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      [8] = 29,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    };

    static const int32_t BDMA_IFCR_CHTIFx_POS[9] = {
      [1] = 2,    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [2] = 6,    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [3] = 10,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [4] = 14,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [5] = 18,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [6] = 22,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [7] = 26,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      [8] = 30,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    };

    static const int32_t BDMA_IFCR_CTEIFx_POS[9] = {
      [1] = 3,    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [2] = 7,    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [3] = 11,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [4] = 15,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [5] = 19,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [6] = 23,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [7] = 27,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [8] = 31,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    };

    /**********************************************************************************************
     * @section DMA2D Register Information
     **********************************************************************************************/

    /**** @subsection DMA2D Register Pointers ****/

    static RW_ uint32_t* const DMA2D_CR_PTR        = (RW_ uint32_t* const)0x52001000U;   /** @brief DMA2D control register */
    static RO_ uint32_t* const DMA2D_ISR_PTR       = (RO_ uint32_t* const)0x52001004U;   /** @brief DMA2D interrupt status register */
    static RW_ uint32_t* const DMA2D_IFCR_PTR      = (RW_ uint32_t* const)0x52001008U;   /** @brief DMA2D interrupt flag clear register */
    static RW_ uint32_t* const DMA2D_FGMAR_PTR     = (RW_ uint32_t* const)0x5200100CU;   /** @brief DMA2D foreground memory address register */
    static RW_ uint32_t* const DMA2D_FGOR_PTR      = (RW_ uint32_t* const)0x52001010U;   /** @brief DMA2D foreground offset register */
    static RW_ uint32_t* const DMA2D_BGMAR_PTR     = (RW_ uint32_t* const)0x52001014U;   /** @brief DMA2D background memory address register */
    static RW_ uint32_t* const DMA2D_BGOR_PTR      = (RW_ uint32_t* const)0x52001018U;   /** @brief DMA2D background offset register */
    static RW_ uint32_t* const DMA2D_FGPFCCR_PTR   = (RW_ uint32_t* const)0x5200101CU;   /** @brief DMA2D foreground PFC control register */
    static RW_ uint32_t* const DMA2D_FGCOLR_PTR    = (RW_ uint32_t* const)0x52001020U;   /** @brief DMA2D foreground color register */
    static RW_ uint32_t* const DMA2D_BGPFCCR_PTR   = (RW_ uint32_t* const)0x52001024U;   /** @brief DMA2D background PFC control register */
    static RW_ uint32_t* const DMA2D_BGCOLR_PTR    = (RW_ uint32_t* const)0x52001028U;   /** @brief DMA2D background color register */
    static RW_ uint32_t* const DMA2D_FGCMAR_PTR    = (RW_ uint32_t* const)0x5200102CU;   /** @brief DMA2D foreground CLUT memory address register */
    static RW_ uint32_t* const DMA2D_BGCMAR_PTR    = (RW_ uint32_t* const)0x52001030U;   /** @brief DMA2D background CLUT memory address register */
    static RW_ uint32_t* const DMA2D_OPFCCR_PTR    = (RW_ uint32_t* const)0x52001034U;   /** @brief DMA2D output PFC control register */
    static RW_ uint32_t* const DMA2D_OCOLR_PTR     = (RW_ uint32_t* const)0x52001038U;   /** @brief DMA2D output color register */
    static RW_ uint32_t* const DMA2D_OMAR_PTR      = (RW_ uint32_t* const)0x5200103CU;   /** @brief DMA2D output memory address register */
    static RW_ uint32_t* const DMA2D_OOR_PTR       = (RW_ uint32_t* const)0x52001040U;   /** @brief DMA2D output offset register */
    static RW_ uint32_t* const DMA2D_NLR_PTR       = (RW_ uint32_t* const)0x52001044U;   /** @brief DMA2D number of line register */
    static RW_ uint32_t* const DMA2D_LWR_PTR       = (RW_ uint32_t* const)0x52001048U;   /** @brief DMA2D line watermark register */
    static RW_ uint32_t* const DMA2D_AMTCR_PTR     = (RW_ uint32_t* const)0x5200104CU;   /** @brief DMA2D AXI master timer configuration register */

    /**** @subsection DMA2D Register Reset Values ****/

    static const uint32_t DMA2D_CR_RST        = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t DMA2D_ISR_RST       = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t DMA2D_IFCR_RST      = 0x00000000U;   /** @brief IFCR register reset value. */
    static const uint32_t DMA2D_FGMAR_RST     = 0x00000000U;   /** @brief FGMAR register reset value. */
    static const uint32_t DMA2D_FGOR_RST      = 0x00000000U;   /** @brief FGOR register reset value. */
    static const uint32_t DMA2D_BGMAR_RST     = 0x00000000U;   /** @brief BGMAR register reset value. */
    static const uint32_t DMA2D_BGOR_RST      = 0x00000000U;   /** @brief BGOR register reset value. */
    static const uint32_t DMA2D_FGPFCCR_RST   = 0x00000000U;   /** @brief FGPFCCR register reset value. */
    static const uint32_t DMA2D_FGCOLR_RST    = 0x00000000U;   /** @brief FGCOLR register reset value. */
    static const uint32_t DMA2D_BGPFCCR_RST   = 0x00000000U;   /** @brief BGPFCCR register reset value. */
    static const uint32_t DMA2D_BGCOLR_RST    = 0x00000000U;   /** @brief BGCOLR register reset value. */
    static const uint32_t DMA2D_FGCMAR_RST    = 0x00000000U;   /** @brief FGCMAR register reset value. */
    static const uint32_t DMA2D_BGCMAR_RST    = 0x00000000U;   /** @brief BGCMAR register reset value. */
    static const uint32_t DMA2D_OPFCCR_RST    = 0x00000000U;   /** @brief OPFCCR register reset value. */
    static const uint32_t DMA2D_OCOLR_RST     = 0x00000000U;   /** @brief OCOLR register reset value. */
    static const uint32_t DMA2D_OMAR_RST      = 0x00000000U;   /** @brief OMAR register reset value. */
    static const uint32_t DMA2D_OOR_RST       = 0x00000000U;   /** @brief OOR register reset value. */
    static const uint32_t DMA2D_NLR_RST       = 0x00000000U;   /** @brief NLR register reset value. */
    static const uint32_t DMA2D_LWR_RST       = 0x00000000U;   /** @brief LWR register reset value. */
    static const uint32_t DMA2D_AMTCR_RST     = 0x00000000U;   /** @brief AMTCR register reset value. */

    /**** @subsection Enumerated DMA2D Register Value Types ****/

    typedef uint32_t DMA2D_CR_t;        /** @brief CR register value type. */
    typedef uint32_t DMA2D_ISR_t;       /** @brief ISR register value type. */
    typedef uint32_t DMA2D_IFCR_t;      /** @brief IFCR register value type. */
    typedef uint32_t DMA2D_FGMAR_t;     /** @brief FGMAR register value type. */
    typedef uint32_t DMA2D_FGOR_t;      /** @brief FGOR register value type. */
    typedef uint32_t DMA2D_BGMAR_t;     /** @brief BGMAR register value type. */
    typedef uint32_t DMA2D_BGOR_t;      /** @brief BGOR register value type. */
    typedef uint32_t DMA2D_FGPFCCR_t;   /** @brief FGPFCCR register value type. */
    typedef uint32_t DMA2D_FGCOLR_t;    /** @brief FGCOLR register value type. */
    typedef uint32_t DMA2D_BGPFCCR_t;   /** @brief BGPFCCR register value type. */
    typedef uint32_t DMA2D_BGCOLR_t;    /** @brief BGCOLR register value type. */
    typedef uint32_t DMA2D_FGCMAR_t;    /** @brief FGCMAR register value type. */
    typedef uint32_t DMA2D_BGCMAR_t;    /** @brief BGCMAR register value type. */
    typedef uint32_t DMA2D_OPFCCR_t;    /** @brief OPFCCR register value type. */
    typedef uint32_t DMA2D_OCOLR_t;     /** @brief OCOLR register value type. */
    typedef uint32_t DMA2D_OMAR_t;      /** @brief OMAR register value type. */
    typedef uint32_t DMA2D_OOR_t;       /** @brief OOR register value type. */
    typedef uint32_t DMA2D_NLR_t;       /** @brief NLR register value type. */
    typedef uint32_t DMA2D_LWR_t;       /** @brief LWR register value type. */
    typedef uint32_t DMA2D_AMTCR_t;     /** @brief AMTCR register value type. */

    /**** @subsection Enumerated DMA2D Register Pointer Types ****/

    typedef uint32_t* const DMA2D_CR_PTR_t;        /** @brief CR register pointer type. */
    typedef uint32_t* const DMA2D_ISR_PTR_t;       /** @brief ISR register pointer type. */
    typedef uint32_t* const DMA2D_IFCR_PTR_t;      /** @brief IFCR register pointer type. */
    typedef uint32_t* const DMA2D_FGMAR_PTR_t;     /** @brief FGMAR register pointer type. */
    typedef uint32_t* const DMA2D_FGOR_PTR_t;      /** @brief FGOR register pointer type. */
    typedef uint32_t* const DMA2D_BGMAR_PTR_t;     /** @brief BGMAR register pointer type. */
    typedef uint32_t* const DMA2D_BGOR_PTR_t;      /** @brief BGOR register pointer type. */
    typedef uint32_t* const DMA2D_FGPFCCR_PTR_t;   /** @brief FGPFCCR register pointer type. */
    typedef uint32_t* const DMA2D_FGCOLR_PTR_t;    /** @brief FGCOLR register pointer type. */
    typedef uint32_t* const DMA2D_BGPFCCR_PTR_t;   /** @brief BGPFCCR register pointer type. */
    typedef uint32_t* const DMA2D_BGCOLR_PTR_t;    /** @brief BGCOLR register pointer type. */
    typedef uint32_t* const DMA2D_FGCMAR_PTR_t;    /** @brief FGCMAR register pointer type. */
    typedef uint32_t* const DMA2D_BGCMAR_PTR_t;    /** @brief BGCMAR register pointer type. */
    typedef uint32_t* const DMA2D_OPFCCR_PTR_t;    /** @brief OPFCCR register pointer type. */
    typedef uint32_t* const DMA2D_OCOLR_PTR_t;     /** @brief OCOLR register pointer type. */
    typedef uint32_t* const DMA2D_OMAR_PTR_t;      /** @brief OMAR register pointer type. */
    typedef uint32_t* const DMA2D_OOR_PTR_t;       /** @brief OOR register pointer type. */
    typedef uint32_t* const DMA2D_NLR_PTR_t;       /** @brief NLR register pointer type. */
    typedef uint32_t* const DMA2D_LWR_PTR_t;       /** @brief LWR register pointer type. */
    typedef uint32_t* const DMA2D_AMTCR_PTR_t;     /** @brief AMTCR register pointer type. */

    /**** @subsection DMA2D Register Field Masks ****/

    static const uint32_t DMA2D_CR_START_MASK        = 0x00000001U;   /** @brief Start this bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers */
    static const uint32_t DMA2D_CR_SUSP_MASK         = 0x00000002U;   /** @brief Suspend this bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset. */
    static const uint32_t DMA2D_CR_ABORT_MASK        = 0x00000004U;   /** @brief Abort this bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset. */
    static const uint32_t DMA2D_CR_TEIE_MASK         = 0x00000100U;   /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_TCIE_MASK         = 0x00000200U;   /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_TWIE_MASK         = 0x00000400U;   /** @brief Transfer watermark interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_CAEIE_MASK        = 0x00000800U;   /** @brief CLUT access error interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_CTCIE_MASK        = 0x00001000U;   /** @brief CLUT transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_CEIE_MASK         = 0x00002000U;   /** @brief Configuration error interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_MODE_MASK         = 0x00030000U;   /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
    static const uint32_t DMA2D_ISR_TEIF_MASK        = 0x00000001U;   /** @brief Transfer error interrupt flag this bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading). */
    static const uint32_t DMA2D_ISR_TCIF_MASK        = 0x00000002U;   /** @brief Transfer complete interrupt flag this bit is set when a DMA2D transfer operation is complete (data transfer only). */
    static const uint32_t DMA2D_ISR_TWIF_MASK        = 0x00000004U;   /** @brief Transfer watermark interrupt flag this bit is set when the last pixel of the watermarked line has been transferred. */
    static const uint32_t DMA2D_ISR_CAEIF_MASK       = 0x00000008U;   /** @brief CLUT access error interrupt flag this bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D. */
    static const uint32_t DMA2D_ISR_CTCIF_MASK       = 0x00000010U;   /** @brief CLUT transfer complete interrupt flag this bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete. */
    static const uint32_t DMA2D_ISR_CEIF_MASK        = 0x00000020U;   /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
    static const uint32_t DMA2D_IFCR_CTEIF_MASK      = 0x00000001U;   /** @brief Clear transfer error interrupt flag programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CTCIF_MASK      = 0x00000002U;   /** @brief Clear transfer complete interrupt flag programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CTWIF_MASK      = 0x00000004U;   /** @brief Clear transfer watermark interrupt flag programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CAECIF_MASK     = 0x00000008U;   /** @brief Clear CLUT access error interrupt flag programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CCTCIF_MASK     = 0x00000010U;   /** @brief Clear CLUT transfer complete interrupt flag programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CCEIF_MASK      = 0x00000020U;   /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_FGOR_LO_MASK         = 0x00003FFFU;   /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const uint32_t DMA2D_BGOR_LO_MASK         = 0x00003FFFU;   /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const uint32_t DMA2D_FGPFCCR_CM_MASK      = 0x0000000FU;   /** @brief Color mode these bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_FGPFCCR_CCM_MASK     = 0x00000010U;   /** @brief CLUT color mode this bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_FGPFCCR_START_MASK   = 0x00000020U;   /** @brief Start this bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer). */
    static const uint32_t DMA2D_FGPFCCR_CS_MASK      = 0x0000FF00U;   /** @brief CLUT size these bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const uint32_t DMA2D_FGPFCCR_AM_MASK      = 0x00030000U;   /** @brief Alpha mode these bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. Other configurations are meaningless */
    static const uint32_t DMA2D_FGPFCCR_CSS_MASK     = 0x000C0000U;   /** @brief Chroma sub-sampling these bits define the chroma sub-sampling mode for ycbcr color mode. Once the transfer has started, these bits are read-only. Others: meaningless */
    static const uint32_t DMA2D_FGPFCCR_AI_MASK      = 0x00100000U;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_FGPFCCR_RBS_MASK     = 0x00200000U;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_FGPFCCR_ALPHA_MASK   = 0xFF000000U;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
    static const uint32_t DMA2D_FGCOLR_BLUE_MASK     = 0x000000FFU;   /** @brief Blue value these bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_FGCOLR_GREEN_MASK    = 0x0000FF00U;   /** @brief Green value these bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_FGCOLR_RED_MASK      = 0x00FF0000U;   /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGPFCCR_CM_MASK      = 0x0000000FU;   /** @brief Color mode these bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_BGPFCCR_CCM_MASK     = 0x00000010U;   /** @brief CLUT color mode these bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_BGPFCCR_START_MASK   = 0x00000020U;   /** @brief Start this bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic background CLUT transfer). */
    static const uint32_t DMA2D_BGPFCCR_CS_MASK      = 0x0000FF00U;   /** @brief CLUT size these bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const uint32_t DMA2D_BGPFCCR_AM_MASK      = 0x00030000U;   /** @brief Alpha mode these bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_BGPFCCR_AI_MASK      = 0x00100000U;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_BGPFCCR_RBS_MASK     = 0x00200000U;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_BGPFCCR_ALPHA_MASK   = 0xFF000000U;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGCOLR_BLUE_MASK     = 0x000000FFU;   /** @brief Blue value these bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGCOLR_GREEN_MASK    = 0x0000FF00U;   /** @brief Green value these bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGCOLR_RED_MASK      = 0x00FF0000U;   /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OPFCCR_CM_MASK       = 0x00000007U;   /** @brief Color mode these bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_OPFCCR_AI_MASK       = 0x00100000U;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_OPFCCR_RBS_MASK      = 0x00200000U;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_OCOLR_BLUE_MASK      = 0x000000FFU;   /** @brief Blue value these bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OCOLR_GREEN_MASK     = 0x0000FF00U;   /** @brief Green value these bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OCOLR_RED_MASK       = 0x00FF0000U;   /** @brief Red value these bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OCOLR_ALPHA_MASK     = 0xFF000000U;   /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OOR_LO_MASK          = 0x00003FFFU;   /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_NLR_NL_MASK          = 0x0000FFFFU;   /** @brief Number of lines number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_NLR_PL_MASK          = 0x3FFF0000U;   /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
    static const uint32_t DMA2D_LWR_LW_MASK          = 0x0000FFFFU;   /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_AMTCR_EN_MASK        = 0x00000001U;   /** @brief Enable enables the dead time functionality. */
    static const uint32_t DMA2D_AMTCR_DT_MASK        = 0x0000FF00U;   /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

    /**** @subsection DMA2D Register Field Positions ****/

    static const int32_t DMA2D_CR_START_POS        = 0;    /** @brief Start this bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers */
    static const int32_t DMA2D_CR_SUSP_POS         = 1;    /** @brief Suspend this bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset. */
    static const int32_t DMA2D_CR_ABORT_POS        = 2;    /** @brief Abort this bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset. */
    static const int32_t DMA2D_CR_TEIE_POS         = 8;    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_CR_TCIE_POS         = 9;    /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_CR_TWIE_POS         = 10;   /** @brief Transfer watermark interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_CR_CAEIE_POS        = 11;   /** @brief CLUT access error interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_CR_CTCIE_POS        = 12;   /** @brief CLUT transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_CR_CEIE_POS         = 13;   /** @brief Configuration error interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_CR_MODE_POS         = 16;   /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
    static const int32_t DMA2D_ISR_TEIF_POS        = 0;    /** @brief Transfer error interrupt flag this bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading). */
    static const int32_t DMA2D_ISR_TCIF_POS        = 1;    /** @brief Transfer complete interrupt flag this bit is set when a DMA2D transfer operation is complete (data transfer only). */
    static const int32_t DMA2D_ISR_TWIF_POS        = 2;    /** @brief Transfer watermark interrupt flag this bit is set when the last pixel of the watermarked line has been transferred. */
    static const int32_t DMA2D_ISR_CAEIF_POS       = 3;    /** @brief CLUT access error interrupt flag this bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D. */
    static const int32_t DMA2D_ISR_CTCIF_POS       = 4;    /** @brief CLUT transfer complete interrupt flag this bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete. */
    static const int32_t DMA2D_ISR_CEIF_POS        = 5;    /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
    static const int32_t DMA2D_IFCR_CTEIF_POS      = 0;    /** @brief Clear transfer error interrupt flag programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_IFCR_CTCIF_POS      = 1;    /** @brief Clear transfer complete interrupt flag programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_IFCR_CTWIF_POS      = 2;    /** @brief Clear transfer watermark interrupt flag programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_IFCR_CAECIF_POS     = 3;    /** @brief Clear CLUT access error interrupt flag programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_IFCR_CCTCIF_POS     = 4;    /** @brief Clear CLUT transfer complete interrupt flag programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_IFCR_CCEIF_POS      = 5;    /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_FGOR_LO_POS         = 0;    /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const int32_t DMA2D_BGOR_LO_POS         = 0;    /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const int32_t DMA2D_FGPFCCR_CM_POS      = 0;    /** @brief Color mode these bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_FGPFCCR_CCM_POS     = 4;    /** @brief CLUT color mode this bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const int32_t DMA2D_FGPFCCR_START_POS   = 5;    /** @brief Start this bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer). */
    static const int32_t DMA2D_FGPFCCR_CS_POS      = 8;    /** @brief CLUT size these bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const int32_t DMA2D_FGPFCCR_AM_POS      = 16;   /** @brief Alpha mode these bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. Other configurations are meaningless */
    static const int32_t DMA2D_FGPFCCR_CSS_POS     = 18;   /** @brief Chroma sub-sampling these bits define the chroma sub-sampling mode for ycbcr color mode. Once the transfer has started, these bits are read-only. Others: meaningless */
    static const int32_t DMA2D_FGPFCCR_AI_POS      = 20;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_FGPFCCR_RBS_POS     = 21;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_FGPFCCR_ALPHA_POS   = 24;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
    static const int32_t DMA2D_FGCOLR_BLUE_POS     = 0;    /** @brief Blue value these bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_FGCOLR_GREEN_POS    = 8;    /** @brief Green value these bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_FGCOLR_RED_POS      = 16;   /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_BGPFCCR_CM_POS      = 0;    /** @brief Color mode these bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_BGPFCCR_CCM_POS     = 4;    /** @brief CLUT color mode these bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const int32_t DMA2D_BGPFCCR_START_POS   = 5;    /** @brief Start this bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic background CLUT transfer). */
    static const int32_t DMA2D_BGPFCCR_CS_POS      = 8;    /** @brief CLUT size these bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const int32_t DMA2D_BGPFCCR_AM_POS      = 16;   /** @brief Alpha mode these bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_BGPFCCR_AI_POS      = 20;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_BGPFCCR_RBS_POS     = 21;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_BGPFCCR_ALPHA_POS   = 24;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_BGCOLR_BLUE_POS     = 0;    /** @brief Blue value these bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_BGCOLR_GREEN_POS    = 8;    /** @brief Green value these bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_BGCOLR_RED_POS      = 16;   /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_OPFCCR_CM_POS       = 0;    /** @brief Color mode these bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_OPFCCR_AI_POS       = 20;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_OPFCCR_RBS_POS      = 21;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_OCOLR_BLUE_POS      = 0;    /** @brief Blue value these bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_OCOLR_GREEN_POS     = 8;    /** @brief Green value these bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_OCOLR_RED_POS       = 16;   /** @brief Red value these bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_OCOLR_ALPHA_POS     = 24;   /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_OOR_LO_POS          = 0;    /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_NLR_NL_POS          = 0;    /** @brief Number of lines number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_NLR_PL_POS          = 16;   /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
    static const int32_t DMA2D_LWR_LW_POS          = 0;    /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_EN_POS        = 0;    /** @brief Enable enables the dead time functionality. */
    static const int32_t DMA2D_AMTCR_DT_POS        = 8;    /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

    /**********************************************************************************************
     * @section DMAMUX2 Register Information
     **********************************************************************************************/

    /**** @subsection DMAMUX2 Register Pointers ****/

    static RO_ uint32_t* const DMAMUX2_RGSR_PTR    = (RO_ uint32_t* const)0x58025940U;   /** @brief DMAMux - DMA request generator status register */
    static RW_ uint32_t* const DMAMUX2_RGCFR_PTR   = (RW_ uint32_t* const)0x58025944U;   /** @brief DMAMux - DMA request generator clear flag register */
    static RO_ uint32_t* const DMAMUX2_CSR_PTR     = (RO_ uint32_t* const)0x58025880U;   /** @brief DMAMUX request line multiplexer interrupt channel status register */
    static RW_ uint32_t* const DMAMUX2_CFR_PTR     = (RW_ uint32_t* const)0x58025884U;   /** @brief DMAMUX request line multiplexer interrupt clear flag register */

    /**** @subsection Enumerated DMAMUX2 Register Pointers ****/

    static RW_ uint32_t* const DMAMUX2_CxCR_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x58025800U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [1] = (RW_ uint32_t* const)0x58025804U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [2] = (RW_ uint32_t* const)0x58025808U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [3] = (RW_ uint32_t* const)0x5802580CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [4] = (RW_ uint32_t* const)0x58025810U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [5] = (RW_ uint32_t* const)0x58025814U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [6] = (RW_ uint32_t* const)0x58025818U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [7] = (RW_ uint32_t* const)0x5802581CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
    };

    static RW_ uint32_t* const DMAMUX2_RGxCR_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x58025900U,   /** @brief DMAMux - DMA request generator channel x control register */
      [1] = (RW_ uint32_t* const)0x58025904U,   /** @brief DMAMux - DMA request generator channel x control register */
      [2] = (RW_ uint32_t* const)0x58025908U,   /** @brief DMAMux - DMA request generator channel x control register */
      [3] = (RW_ uint32_t* const)0x5802590CU,   /** @brief DMAMux - DMA request generator channel x control register */
      [4] = (RW_ uint32_t* const)0x58025910U,   /** @brief DMAMux - DMA request generator channel x control register */
      [5] = (RW_ uint32_t* const)0x58025914U,   /** @brief DMAMux - DMA request generator channel x control register */
      [6] = (RW_ uint32_t* const)0x58025918U,   /** @brief DMAMux - DMA request generator channel x control register */
      [7] = (RW_ uint32_t* const)0x5802591CU,   /** @brief DMAMux - DMA request generator channel x control register */
    };

    /**** @subsection DMAMUX2 Register Reset Values ****/

    static const uint32_t DMAMUX2_RGSR_RST= 0x00000000U;   /** @brief RGSR register reset value. */
    static const uint32_t DMAMUX2_RGCFR_RST= 0x00000000U;   /** @brief RGCFR register reset value. */
    static const uint32_t DMAMUX2_CSR_RST= 0x00000000U;   /** @brief CSR register reset value. */
    static const uint32_t DMAMUX2_CFR_RST= 0x00000000U;   /** @brief CFR register reset value. */

    /**** @subsection Enumerated DMAMUX2 Register Reset Values ****/

    static const uint32_t DMAMUX2_CxCR_RST[8] = {
      [0] = 0x00000000U,   /** @brief C0CR register reset value. */
      [1] = 0x00000000U,   /** @brief C1CR register reset value. */
      [2] = 0x00000000U,   /** @brief C2CR register reset value. */
      [3] = 0x00000000U,   /** @brief C3CR register reset value. */
      [4] = 0x00000000U,   /** @brief C4CR register reset value. */
      [5] = 0x00000000U,   /** @brief C5CR register reset value. */
      [6] = 0x00000000U,   /** @brief C6CR register reset value. */
      [7] = 0x00000000U,   /** @brief C7CR register reset value. */
    };

    static const uint32_t DMAMUX2_RGxCR_RST[8] = {
      [0] = 0x00000000U,   /** @brief RG0CR register reset value. */
      [1] = 0x00000000U,   /** @brief RG1CR register reset value. */
      [2] = 0x00000000U,   /** @brief RG2CR register reset value. */
      [3] = 0x00000000U,   /** @brief RG3CR register reset value. */
      [4] = 0x00000000U,   /** @brief RG4CR register reset value. */
      [5] = 0x00000000U,   /** @brief RG5CR register reset value. */
      [6] = 0x00000000U,   /** @brief RG6CR register reset value. */
      [7] = 0x00000000U,   /** @brief RG7CR register reset value. */
    };

    /**** @subsection Enumerated DMAMUX2 Register Value Types ****/

    typedef uint32_t DMAMUX2_CxCR_t;    /** @brief CxCR register value type. */
    typedef uint32_t DMAMUX2_RGxCR_t;   /** @brief RGxCR register value type. */
    typedef uint32_t DMAMUX2_RGSR_t;    /** @brief RGSR register value type. */
    typedef uint32_t DMAMUX2_RGCFR_t;   /** @brief RGCFR register value type. */
    typedef uint32_t DMAMUX2_CSR_t;     /** @brief CSR register value type. */
    typedef uint32_t DMAMUX2_CFR_t;     /** @brief CFR register value type. */

    /**** @subsection Enumerated DMAMUX2 Register Pointer Types ****/

    typedef uint32_t* const DMAMUX2_CxCR_PTR_t;    /** @brief CxCR register pointer type. */
    typedef uint32_t* const DMAMUX2_RGxCR_PTR_t;   /** @brief RGxCR register pointer type. */
    typedef uint32_t* const DMAMUX2_RGSR_PTR_t;    /** @brief RGSR register pointer type. */
    typedef uint32_t* const DMAMUX2_RGCFR_PTR_t;   /** @brief RGCFR register pointer type. */
    typedef uint32_t* const DMAMUX2_CSR_PTR_t;     /** @brief CSR register pointer type. */
    typedef uint32_t* const DMAMUX2_CFR_PTR_t;     /** @brief CFR register pointer type. */

    /**** @subsection DMAMUX2 Register Field Masks ****/

    static const uint32_t DMAMUX2_CxCR_DMAREQ_ID_MASK   = 0x000000FFU;   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CxCR_SOIE_MASK        = 0x00000100U;   /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CxCR_EGE_MASK         = 0x00000200U;   /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CxCR_SE_MASK          = 0x00010000U;   /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CxCR_SPOL_MASK        = 0x00060000U;   /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CxCR_NBREQ_MASK       = 0x00F80000U;   /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CxCR_SYNC_ID_MASK     = 0x1F000000U;   /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_RGxCR_SIG_ID_MASK     = 0x0000001FU;   /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGxCR_OIE_MASK        = 0x00000100U;   /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGxCR_GE_MASK         = 0x00010000U;   /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGxCR_GPOL_MASK       = 0x00060000U;   /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGxCR_GNBREQ_MASK     = 0x00F80000U;   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGSR_OF_MASK          = 0x000000FFU;   /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const uint32_t DMAMUX2_RGCFR_COF_MASK        = 0x000000FFU;   /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const uint32_t DMAMUX2_CSR_SOF_MASK          = 0x0000FFFFU;   /** @brief Synchronization overrun event flag */
    static const uint32_t DMAMUX2_CFR_CSOF_MASK         = 0x0000FFFFU;   /** @brief Clear synchronization overrun event flag */

    /**** @subsection DMAMUX2 Register Field Positions ****/

    static const int32_t DMAMUX2_CxCR_DMAREQ_ID_POS   = 0;    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CxCR_SOIE_POS        = 8;    /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CxCR_EGE_POS         = 9;    /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CxCR_SE_POS          = 16;   /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CxCR_SPOL_POS        = 17;   /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CxCR_NBREQ_POS       = 19;   /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CxCR_SYNC_ID_POS     = 24;   /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_RGxCR_SIG_ID_POS     = 0;    /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_RGxCR_OIE_POS        = 8;    /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_RGxCR_GE_POS         = 16;   /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_RGxCR_GPOL_POS       = 17;   /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_RGxCR_GNBREQ_POS     = 19;   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_RGSR_OF_POS          = 0;    /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const int32_t DMAMUX2_RGCFR_COF_POS        = 0;    /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const int32_t DMAMUX2_CSR_SOF_POS          = 0;    /** @brief Synchronization overrun event flag */
    static const int32_t DMAMUX2_CFR_CSOF_POS         = 0;    /** @brief Clear synchronization overrun event flag */

    /**********************************************************************************************
     * @section FMC Register Information
     **********************************************************************************************/

    /**** @subsection FMC Register Pointers ****/

    static RW_ uint32_t* const FMC_PCR_PTR     = (RW_ uint32_t* const)0x52004080U;   /** @brief NAND flash control registers */
    static RW_ uint32_t* const FMC_SR_PTR      = (RW_ uint32_t* const)0x52004084U;   /** @brief This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.this is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.the ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty. */
    static RW_ uint32_t* const FMC_PMEM_PTR    = (RW_ uint32_t* const)0x52004088U;   /** @brief The FMC_PMEM read/write register contains the timing information for NAND flash memory bank. This information is used to access either the common memory space of the NAND flash for command, address write access and data read/write access. */
    static RW_ uint32_t* const FMC_PATT_PTR    = (RW_ uint32_t* const)0x5200408CU;   /** @brief The FMC_PATT read/write register contains the timing information for NAND flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND flash for the last address write access if the timing must differ from that of previous accesses (for ready/busy management, refer to section20.8.5: NAND flash prewait feature). */
    static RO_ uint32_t* const FMC_ECCR_PTR    = (RO_ uint32_t* const)0x52004094U;   /** @brief This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND flash memory page at the correct address (refer to section20.8.6: computation of the error correction code (ECC) in NAND flash memory), the data read/written from/to the NAND flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1. */
    static RW_ uint32_t* const FMC_SDCMR_PTR   = (RW_ uint32_t* const)0x52004150U;   /** @brief This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the self-refresh and the power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks. */
    static RW_ uint32_t* const FMC_SDRTR_PTR   = (RW_ uint32_t* const)0x52004154U;   /** @brief This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the refresh timer count value.examplewhere 64 ms is the SDRAM refresh period.the refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.as soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.if a memory access is in progress, the auto-refresh request is delayed. However, if the memory access and auto-refresh requests are generated simultaneously, the auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.this register is common to SDRAM bank 1 and bank 2. */
    static RO_ uint32_t* const FMC_SDSR_PTR    = (RO_ uint32_t* const)0x52004158U;   /** @brief SDRAM status register */

    /**** @subsection Enumerated FMC Register Pointers ****/

    static RW_ uint32_t* const FMC_BCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x52004000U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [2] = (RW_ uint32_t* const)0x52004008U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [3] = (RW_ uint32_t* const)0x52004010U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [4] = (RW_ uint32_t* const)0x52004018U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    };

    static RW_ uint32_t* const FMC_BTRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x52004004U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [2] = (RW_ uint32_t* const)0x5200400CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [3] = (RW_ uint32_t* const)0x52004014U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [4] = (RW_ uint32_t* const)0x5200401CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    };

    static RW_ uint32_t* const FMC_BWTRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x52004104U,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [2] = (RW_ uint32_t* const)0x5200410CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [3] = (RW_ uint32_t* const)0x52004114U,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [4] = (RW_ uint32_t* const)0x5200411CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    };

    static RW_ uint32_t* const FMC_SDCRx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52004140U,   /** @brief This register contains the control parameters for each SDRAM memory bank */
      [2] = (RW_ uint32_t* const)0x52004144U,   /** @brief This register contains the control parameters for each SDRAM memory bank */
    };

    static RW_ uint32_t* const FMC_SDTRx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52004148U,   /** @brief This register contains the timing parameters of each SDRAM bank */
      [2] = (RW_ uint32_t* const)0x5200414CU,   /** @brief This register contains the timing parameters of each SDRAM bank */
    };

    /**** @subsection FMC Register Reset Values ****/

    static const uint32_t FMC_PCR_RST= 0x00000018U;   /** @brief PCR register reset value. */
    static const uint32_t FMC_SR_RST= 0x00000040U;   /** @brief SR register reset value. */
    static const uint32_t FMC_PMEM_RST= 0xFCFCFCFCU;   /** @brief PMEM register reset value. */
    static const uint32_t FMC_PATT_RST= 0xFCFCFCFCU;   /** @brief PATT register reset value. */
    static const uint32_t FMC_ECCR_RST= 0x00000000U;   /** @brief ECCR register reset value. */
    static const uint32_t FMC_SDCMR_RST= 0x00000000U;   /** @brief SDCMR register reset value. */
    static const uint32_t FMC_SDRTR_RST= 0x00000000U;   /** @brief SDRTR register reset value. */
    static const uint32_t FMC_SDSR_RST= 0x00000000U;   /** @brief SDSR register reset value. */

    /**** @subsection Enumerated FMC Register Reset Values ****/

    static const uint32_t FMC_BCRx_RST[5] = {
      [1] = 0x000030DBU,   /** @brief BCR1 register reset value. */
      [2] = 0x000030D2U,   /** @brief BCR2 register reset value. */
      [3] = 0x000030D2U,   /** @brief BCR3 register reset value. */
      [4] = 0x000030D2U,   /** @brief BCR4 register reset value. */
    };

    static const uint32_t FMC_BTRx_RST[5] = {
      [1] = 0x0FFFFFFFU,   /** @brief BTR1 register reset value. */
      [2] = 0x0FFFFFFFU,   /** @brief BTR2 register reset value. */
      [3] = 0x0FFFFFFFU,   /** @brief BTR3 register reset value. */
      [4] = 0x0FFFFFFFU,   /** @brief BTR4 register reset value. */
    };

    static const uint32_t FMC_BWTRx_RST[5] = {
      [1] = 0x0FFFFFFFU,   /** @brief BWTR1 register reset value. */
      [2] = 0x0FFFFFFFU,   /** @brief BWTR2 register reset value. */
      [3] = 0x0FFFFFFFU,   /** @brief BWTR3 register reset value. */
      [4] = 0x0FFFFFFFU,   /** @brief BWTR4 register reset value. */
    };

    static const uint32_t FMC_SDCRx_RST[3] = {
      [1] = 0x000002D0U,   /** @brief SDCR1 register reset value. */
      [2] = 0x000002D0U,   /** @brief SDCR2 register reset value. */
    };

    static const uint32_t FMC_SDTRx_RST[3] = {
      [1] = 0x0FFFFFFFU,   /** @brief SDTR1 register reset value. */
      [2] = 0x0FFFFFFFU,   /** @brief SDTR2 register reset value. */
    };

    /**** @subsection Enumerated FMC Register Value Types ****/

    typedef uint32_t FMC_BCRx_t;    /** @brief BCRx register value type. */
    typedef uint32_t FMC_BTRx_t;    /** @brief BTRx register value type. */
    typedef uint32_t FMC_PCR_t;     /** @brief PCR register value type. */
    typedef uint32_t FMC_SR_t;      /** @brief SR register value type. */
    typedef uint32_t FMC_PMEM_t;    /** @brief PMEM register value type. */
    typedef uint32_t FMC_PATT_t;    /** @brief PATT register value type. */
    typedef uint32_t FMC_ECCR_t;    /** @brief ECCR register value type. */
    typedef uint32_t FMC_BWTRx_t;   /** @brief BWTRx register value type. */
    typedef uint32_t FMC_SDCRx_t;   /** @brief SDCRx register value type. */
    typedef uint32_t FMC_SDTRx_t;   /** @brief SDTRx register value type. */
    typedef uint32_t FMC_SDCMR_t;   /** @brief SDCMR register value type. */
    typedef uint32_t FMC_SDRTR_t;   /** @brief SDRTR register value type. */
    typedef uint32_t FMC_SDSR_t;    /** @brief SDSR register value type. */

    /**** @subsection Enumerated FMC Register Pointer Types ****/

    typedef uint32_t* const FMC_BCRx_PTR_t;    /** @brief BCRx register pointer type. */
    typedef uint32_t* const FMC_BTRx_PTR_t;    /** @brief BTRx register pointer type. */
    typedef uint32_t* const FMC_PCR_PTR_t;     /** @brief PCR register pointer type. */
    typedef uint32_t* const FMC_SR_PTR_t;      /** @brief SR register pointer type. */
    typedef uint32_t* const FMC_PMEM_PTR_t;    /** @brief PMEM register pointer type. */
    typedef uint32_t* const FMC_PATT_PTR_t;    /** @brief PATT register pointer type. */
    typedef uint32_t* const FMC_ECCR_PTR_t;    /** @brief ECCR register pointer type. */
    typedef uint32_t* const FMC_BWTRx_PTR_t;   /** @brief BWTRx register pointer type. */
    typedef uint32_t* const FMC_SDCRx_PTR_t;   /** @brief SDCRx register pointer type. */
    typedef uint32_t* const FMC_SDTRx_PTR_t;   /** @brief SDTRx register pointer type. */
    typedef uint32_t* const FMC_SDCMR_PTR_t;   /** @brief SDCMR register pointer type. */
    typedef uint32_t* const FMC_SDRTR_PTR_t;   /** @brief SDRTR register pointer type. */
    typedef uint32_t* const FMC_SDSR_PTR_t;    /** @brief SDSR register pointer type. */

    /**** @subsection FMC Register Field Masks ****/

    static const uint32_t FMC_BCRx_MBKEN_MASK       = 0x00000001U;   /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const uint32_t FMC_BCRx_MUXEN_MASK       = 0x00000002U;   /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const uint32_t FMC_BCRx_MTYP_MASK        = 0x0000000CU;   /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const uint32_t FMC_BCRx_MWID_MASK        = 0x00000030U;   /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const uint32_t FMC_BCRx_FACCEN_MASK      = 0x00000040U;   /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const uint32_t FMC_BCRx_BURSTEN_MASK     = 0x00000100U;   /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const uint32_t FMC_BCRx_WAITPOL_MASK     = 0x00000200U;   /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const uint32_t FMC_BCRx_WAITCFG_MASK     = 0x00000800U;   /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const uint32_t FMC_BCRx_WREN_MASK        = 0x00001000U;   /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const uint32_t FMC_BCRx_WAITEN_MASK      = 0x00002000U;   /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const uint32_t FMC_BCRx_EXTMOD_MASK      = 0x00004000U;   /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const uint32_t FMC_BCRx_ASYNCWAIT_MASK   = 0x00008000U;   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const uint32_t FMC_BCRx_CPSIZE_MASK      = 0x00070000U;   /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const uint32_t FMC_BCRx_CBURSTRW_MASK    = 0x00080000U;   /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const uint32_t FMC_BCRx_CCLKEN_MASK      = 0x00100000U;   /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const uint32_t FMC_BCRx_WFDIS_MASK       = 0x00200000U;   /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRx_BMAP_MASK        = 0x03000000U;   /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRx_FMCEN_MASK       = 0x80000000U;   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BTRx_ADDSET_MASK      = 0x0000000FU;   /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const uint32_t FMC_BTRx_ADDHLD_MASK      = 0x000000F0U;   /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const uint32_t FMC_BTRx_DATAST_MASK      = 0x0000FF00U;   /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const uint32_t FMC_BTRx_BUSTURN_MASK     = 0x000F0000U;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 126. ... */
    static const uint32_t FMC_BTRx_CLKDIV_MASK      = 0x00F00000U;   /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const uint32_t FMC_BTRx_DATLAT_MASK      = 0x0F000000U;   /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const uint32_t FMC_BTRx_ACCMOD_MASK      = 0x30000000U;   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_PCR_PWAITEN_MASK      = 0x00000002U;   /** @brief Wait feature enable bit. This bit enables the wait feature for the NAND flash memory bank: */
    static const uint32_t FMC_PCR_PBKEN_MASK        = 0x00000004U;   /** @brief NAND flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus */
    static const uint32_t FMC_PCR_PWID_MASK         = 0x00000030U;   /** @brief Data bus width. These bits define the external memory device width. */
    static const uint32_t FMC_PCR_ECCEN_MASK        = 0x00000040U;   /** @brief ECC computation logic enable bit */
    static const uint32_t FMC_PCR_TCLR_MASK         = 0x00001E00U;   /** @brief CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const uint32_t FMC_PCR_TAR_MASK          = 0x0001E000U;   /** @brief ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const uint32_t FMC_PCR_ECCPS_MASK        = 0x000E0000U;   /** @brief ECC page size. These bits define the page size for the extended ECC: */
    static const uint32_t FMC_SR_IRS_MASK           = 0x00000001U;   /** @brief Interrupt rising edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const uint32_t FMC_SR_ILS_MASK           = 0x00000002U;   /** @brief Interrupt high-level status the flag is set by hardware and reset by software. */
    static const uint32_t FMC_SR_IFS_MASK           = 0x00000004U;   /** @brief Interrupt falling edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const uint32_t FMC_SR_IREN_MASK          = 0x00000008U;   /** @brief Interrupt rising edge detection enable bit */
    static const uint32_t FMC_SR_ILEN_MASK          = 0x00000010U;   /** @brief Interrupt high-level detection enable bit */
    static const uint32_t FMC_SR_IFEN_MASK          = 0x00000020U;   /** @brief Interrupt falling edge detection enable bit */
    static const uint32_t FMC_SR_FEMPT_MASK         = 0x00000040U;   /** @brief FIFO empty. Read-only bit that provides the status of the FIFO */
    static const uint32_t FMC_PMEM_MEMSET_MASK      = 0x000000FFU;   /** @brief Common memory x setup time these bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const uint32_t FMC_PMEM_MEMWAIT_MASK     = 0x0000FF00U;   /** @brief Common memory wait time these bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const uint32_t FMC_PMEM_MEMHOLD_MASK     = 0x00FF0000U;   /** @brief Common memory hold time these bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const uint32_t FMC_PMEM_MEMHIZ_MASK      = 0xFF000000U;   /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions: */
    static const uint32_t FMC_PATT_ATTSET_MASK      = 0x000000FFU;   /** @brief Attribute memory setup time these bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const uint32_t FMC_PATT_ATTWAIT_MASK     = 0x0000FF00U;   /** @brief Attribute memory wait time these bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const uint32_t FMC_PATT_ATTHOLD_MASK     = 0x00FF0000U;   /** @brief Attribute memory hold time these bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const uint32_t FMC_PATT_ATTHIZ_MASK      = 0xFF000000U;   /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction: */
    static const uint32_t FMC_BWTRx_ADDSET_MASK     = 0x0000000FU;   /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const uint32_t FMC_BWTRx_ADDHLD_MASK     = 0x000000F0U;   /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const uint32_t FMC_BWTRx_DATAST_MASK     = 0x0000FF00U;   /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const uint32_t FMC_BWTRx_BUSTURN_MASK    = 0x000F0000U;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const uint32_t FMC_BWTRx_ACCMOD_MASK     = 0x30000000U;   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_SDCRx_NC_MASK         = 0x00000003U;   /** @brief Number of column address bits these bits define the number of bits of a column address. */
    static const uint32_t FMC_SDCRx_NR_MASK         = 0x0000000CU;   /** @brief Number of row address bits these bits define the number of bits of a row address. */
    static const uint32_t FMC_SDCRx_MWID_MASK       = 0x00000030U;   /** @brief Memory data bus width. These bits define the memory device width. */
    static const uint32_t FMC_SDCRx_NB_MASK         = 0x00000040U;   /** @brief Number of internal banks this bit sets the number of internal banks. */
    static const uint32_t FMC_SDCRx_CAS_MASK        = 0x00000180U;   /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
    static const uint32_t FMC_SDCRx_WP_MASK         = 0x00000200U;   /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
    static const uint32_t FMC_SDCRx_SDCLK_MASK      = 0x00000C00U;   /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDCRx_RBURST_MASK     = 0x00001000U;   /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDCRx_RPIPE_MASK      = 0x00006000U;   /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDTRx_TMRD_MASK       = 0x0000000FU;   /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
    static const uint32_t FMC_SDTRx_TXSR_MASK       = 0x000000F0U;   /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
    static const uint32_t FMC_SDTRx_TRAS_MASK       = 0x00000F00U;   /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
    static const uint32_t FMC_SDTRx_TRC_MASK        = 0x0000F000U;   /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const uint32_t FMC_SDTRx_TWR_MASK        = 0x000F0000U;   /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
    static const uint32_t FMC_SDTRx_TRP_MASK        = 0x00F00000U;   /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const uint32_t FMC_SDTRx_TRCD_MASK       = 0x0F000000U;   /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
    static const uint32_t FMC_SDCMR_MODE_MASK       = 0x00000007U;   /** @brief Command mode these bits define the command issued to the SDRAM device. Note: when a command is issued, at least one command target bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: if two SDRAM banks are used, the auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: if only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. */
    static const uint32_t FMC_SDCMR_NRFS_MASK       = 0x000001E0U;   /** @brief Number of auto-refresh these bits define the number of consecutive auto-refresh commands issued when MODE = 011. .... */
    static const uint32_t FMC_SDCMR_MRD_MASK        = 0x007FFE00U;   /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
    static const uint32_t FMC_SDRTR_CRE_MASK        = 0x00000001U;   /** @brief Clear refresh error flag this bit is used to clear the refresh error flag (RE) in the status register. */
    static const uint32_t FMC_SDRTR_COUNT_MASK      = 0x00003FFEU;   /** @brief Refresh timer count this 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / number of rows) - 20 */
    static const uint32_t FMC_SDRTR_REIE_MASK       = 0x00004000U;   /** @brief RES interrupt enable */
    static const uint32_t FMC_SDSR_RE_MASK          = 0x00000001U;   /** @brief Refresh error flag an interrupt is generated if REIE = 1 and RE = 1 */

    /**** @subsection Enumerated FMC Register Field Masks ****/

    static const uint32_t FMC_SDCMR_CTBx_MASK[3] = {
      [1] = 0x00000010U,   /** @brief Command target bank 1 this bit indicates whether the command will be issued to SDRAM bank 1 or not. */
      [2] = 0x00000008U,   /** @brief Command target bank 2 this bit indicates whether the command will be issued to SDRAM bank 2 or not. */
    };

    static const uint32_t FMC_SDSR_MODESx_MASK[3] = {
      [1] = 0x00000006U,   /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
      [2] = 0x00000018U,   /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */
    };

    /**** @subsection FMC Register Field Positions ****/

    static const int32_t FMC_BCRx_MBKEN_POS       = 0;    /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const int32_t FMC_BCRx_MUXEN_POS       = 1;    /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const int32_t FMC_BCRx_MTYP_POS        = 2;    /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const int32_t FMC_BCRx_MWID_POS        = 4;    /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const int32_t FMC_BCRx_FACCEN_POS      = 6;    /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const int32_t FMC_BCRx_BURSTEN_POS     = 8;    /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const int32_t FMC_BCRx_WAITPOL_POS     = 9;    /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const int32_t FMC_BCRx_WAITCFG_POS     = 11;   /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const int32_t FMC_BCRx_WREN_POS        = 12;   /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const int32_t FMC_BCRx_WAITEN_POS      = 13;   /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const int32_t FMC_BCRx_EXTMOD_POS      = 14;   /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const int32_t FMC_BCRx_ASYNCWAIT_POS   = 15;   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const int32_t FMC_BCRx_CPSIZE_POS      = 16;   /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const int32_t FMC_BCRx_CBURSTRW_POS    = 19;   /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const int32_t FMC_BCRx_CCLKEN_POS      = 20;   /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const int32_t FMC_BCRx_WFDIS_POS       = 21;   /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_BCRx_BMAP_POS        = 24;   /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_BCRx_FMCEN_POS       = 31;   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_BTRx_ADDSET_POS      = 0;    /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const int32_t FMC_BTRx_ADDHLD_POS      = 4;    /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const int32_t FMC_BTRx_DATAST_POS      = 8;    /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const int32_t FMC_BTRx_BUSTURN_POS     = 16;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 126. ... */
    static const int32_t FMC_BTRx_CLKDIV_POS      = 20;   /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const int32_t FMC_BTRx_DATLAT_POS      = 24;   /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const int32_t FMC_BTRx_ACCMOD_POS      = 28;   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_PCR_PWAITEN_POS      = 1;    /** @brief Wait feature enable bit. This bit enables the wait feature for the NAND flash memory bank: */
    static const int32_t FMC_PCR_PBKEN_POS        = 2;    /** @brief NAND flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus */
    static const int32_t FMC_PCR_PWID_POS         = 4;    /** @brief Data bus width. These bits define the external memory device width. */
    static const int32_t FMC_PCR_ECCEN_POS        = 6;    /** @brief ECC computation logic enable bit */
    static const int32_t FMC_PCR_TCLR_POS         = 9;    /** @brief CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const int32_t FMC_PCR_TAR_POS          = 13;   /** @brief ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const int32_t FMC_PCR_ECCPS_POS        = 17;   /** @brief ECC page size. These bits define the page size for the extended ECC: */
    static const int32_t FMC_SR_IRS_POS           = 0;    /** @brief Interrupt rising edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const int32_t FMC_SR_ILS_POS           = 1;    /** @brief Interrupt high-level status the flag is set by hardware and reset by software. */
    static const int32_t FMC_SR_IFS_POS           = 2;    /** @brief Interrupt falling edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const int32_t FMC_SR_IREN_POS          = 3;    /** @brief Interrupt rising edge detection enable bit */
    static const int32_t FMC_SR_ILEN_POS          = 4;    /** @brief Interrupt high-level detection enable bit */
    static const int32_t FMC_SR_IFEN_POS          = 5;    /** @brief Interrupt falling edge detection enable bit */
    static const int32_t FMC_SR_FEMPT_POS         = 6;    /** @brief FIFO empty. Read-only bit that provides the status of the FIFO */
    static const int32_t FMC_PMEM_MEMSET_POS      = 0;    /** @brief Common memory x setup time these bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const int32_t FMC_PMEM_MEMWAIT_POS     = 8;    /** @brief Common memory wait time these bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const int32_t FMC_PMEM_MEMHOLD_POS     = 16;   /** @brief Common memory hold time these bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const int32_t FMC_PMEM_MEMHIZ_POS      = 24;   /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions: */
    static const int32_t FMC_PATT_ATTSET_POS      = 0;    /** @brief Attribute memory setup time these bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const int32_t FMC_PATT_ATTWAIT_POS     = 8;    /** @brief Attribute memory wait time these bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const int32_t FMC_PATT_ATTHOLD_POS     = 16;   /** @brief Attribute memory hold time these bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const int32_t FMC_PATT_ATTHIZ_POS      = 24;   /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction: */
    static const int32_t FMC_BWTRx_ADDSET_POS     = 0;    /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const int32_t FMC_BWTRx_ADDHLD_POS     = 4;    /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const int32_t FMC_BWTRx_DATAST_POS     = 8;    /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const int32_t FMC_BWTRx_BUSTURN_POS    = 16;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const int32_t FMC_BWTRx_ACCMOD_POS     = 28;   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDCRx_NC_POS         = 0;    /** @brief Number of column address bits these bits define the number of bits of a column address. */
    static const int32_t FMC_SDCRx_NR_POS         = 2;    /** @brief Number of row address bits these bits define the number of bits of a row address. */
    static const int32_t FMC_SDCRx_MWID_POS       = 4;    /** @brief Memory data bus width. These bits define the memory device width. */
    static const int32_t FMC_SDCRx_NB_POS         = 6;    /** @brief Number of internal banks this bit sets the number of internal banks. */
    static const int32_t FMC_SDCRx_CAS_POS        = 7;    /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
    static const int32_t FMC_SDCRx_WP_POS         = 9;    /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
    static const int32_t FMC_SDCRx_SDCLK_POS      = 10;   /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDCRx_RBURST_POS     = 12;   /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDCRx_RPIPE_POS      = 13;   /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDTRx_TMRD_POS       = 0;    /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
    static const int32_t FMC_SDTRx_TXSR_POS       = 4;    /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
    static const int32_t FMC_SDTRx_TRAS_POS       = 8;    /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
    static const int32_t FMC_SDTRx_TRC_POS        = 12;   /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const int32_t FMC_SDTRx_TWR_POS        = 16;   /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
    static const int32_t FMC_SDTRx_TRP_POS        = 20;   /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const int32_t FMC_SDTRx_TRCD_POS       = 24;   /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
    static const int32_t FMC_SDCMR_MODE_POS       = 0;    /** @brief Command mode these bits define the command issued to the SDRAM device. Note: when a command is issued, at least one command target bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: if two SDRAM banks are used, the auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: if only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. */
    static const int32_t FMC_SDCMR_NRFS_POS       = 5;    /** @brief Number of auto-refresh these bits define the number of consecutive auto-refresh commands issued when MODE = 011. .... */
    static const int32_t FMC_SDCMR_MRD_POS        = 9;    /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
    static const int32_t FMC_SDRTR_CRE_POS        = 0;    /** @brief Clear refresh error flag this bit is used to clear the refresh error flag (RE) in the status register. */
    static const int32_t FMC_SDRTR_COUNT_POS      = 1;    /** @brief Refresh timer count this 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / number of rows) - 20 */
    static const int32_t FMC_SDRTR_REIE_POS       = 14;   /** @brief RES interrupt enable */
    static const int32_t FMC_SDSR_RE_POS          = 0;    /** @brief Refresh error flag an interrupt is generated if REIE = 1 and RE = 1 */

    /**** @subsection Enumerated FMC Register Field Positions ****/

    static const int32_t FMC_SDCMR_CTBx_POS[3] = {
      [1] = 4,   /** @brief Command target bank 1 this bit indicates whether the command will be issued to SDRAM bank 1 or not. */
      [2] = 3,   /** @brief Command target bank 2 this bit indicates whether the command will be issued to SDRAM bank 2 or not. */
    };

    static const int32_t FMC_SDSR_MODESx_POS[3] = {
      [1] = 1,   /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
      [2] = 3,   /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */
    };

    /**********************************************************************************************
     * @section CEC Register Information
     **********************************************************************************************/

    /**** @subsection CEC Register Pointers ****/

    static RW_ uint32_t* const CEC_CR_PTR     = (RW_ uint32_t* const)0x40006C00U;   /** @brief CEC control register */
    static RW_ uint32_t* const CEC_CFGR_PTR   = (RW_ uint32_t* const)0x40006C04U;   /** @brief This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0. */
    static RW_ uint32_t* const CEC_TXDR_PTR   = (RW_ uint32_t* const)0x40006C08U;   /** @brief CEC tx data register */
    static RO_ uint32_t* const CEC_RXDR_PTR   = (RO_ uint32_t* const)0x40006C0CU;   /** @brief CEC rx data register */
    static RW_ uint32_t* const CEC_ISR_PTR    = (RW_ uint32_t* const)0x40006C10U;   /** @brief CEC interrupt and status register */
    static RW_ uint32_t* const CEC_IER_PTR    = (RW_ uint32_t* const)0x40006C14U;   /** @brief CEC interrupt enable register */

    /**** @subsection CEC Register Reset Values ****/

    static const uint32_t CEC_CR_RST     = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t CEC_CFGR_RST   = 0x00000000U;   /** @brief CFGR register reset value. */
    static const uint32_t CEC_TXDR_RST   = 0x00000000U;   /** @brief TXDR register reset value. */
    static const uint32_t CEC_RXDR_RST   = 0x00000000U;   /** @brief RXDR register reset value. */
    static const uint32_t CEC_ISR_RST    = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t CEC_IER_RST    = 0x00000000U;   /** @brief IER register reset value. */

    /**** @subsection Enumerated CEC Register Value Types ****/

    typedef uint32_t CEC_CR_t;     /** @brief CR register value type. */
    typedef uint32_t CEC_CFGR_t;   /** @brief CFGR register value type. */
    typedef uint32_t CEC_TXDR_t;   /** @brief TXDR register value type. */
    typedef uint32_t CEC_RXDR_t;   /** @brief RXDR register value type. */
    typedef uint32_t CEC_ISR_t;    /** @brief ISR register value type. */
    typedef uint32_t CEC_IER_t;    /** @brief IER register value type. */

    /**** @subsection Enumerated CEC Register Pointer Types ****/

    typedef uint32_t* const CEC_CR_PTR_t;     /** @brief CR register pointer type. */
    typedef uint32_t* const CEC_CFGR_PTR_t;   /** @brief CFGR register pointer type. */
    typedef uint32_t* const CEC_TXDR_PTR_t;   /** @brief TXDR register pointer type. */
    typedef uint32_t* const CEC_RXDR_PTR_t;   /** @brief RXDR register pointer type. */
    typedef uint32_t* const CEC_ISR_PTR_t;    /** @brief ISR register pointer type. */
    typedef uint32_t* const CEC_IER_PTR_t;    /** @brief IER register pointer type. */

    /**** @subsection CEC Register Field Masks ****/

    static const uint32_t CEC_CR_CECEN_MASK        = 0x00000001U;   /** @brief CEC enable the CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission. */
    static const uint32_t CEC_CR_TXSOM_MASK        = 0x00000002U;   /** @brief Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR headers first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception */
    static const uint32_t CEC_CR_TXEOM_MASK        = 0x00000004U;   /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message) */
    static const uint32_t CEC_CFGR_SFT_MASK        = 0x00000007U;   /** @brief Signal free time SFT bits are set by software. In the sft=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 data-bit periods if CEC is the new bus initiator ** 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods */
    static const uint32_t CEC_CFGR_RXTOL_MASK      = 0x00000008U;   /** @brief Rx-Tolerance the RXTOL bit is set and cleared by software. ** start-bit, +/- 200 s rise, +/- 200 s fall. ** data-bit: +/- 200 s rise. +/- 350 s fall. ** start-bit: +/- 400 s rise, +/- 400 s fall ** data-bit: +/-300 s rise, +/- 500 s fall */
    static const uint32_t CEC_CFGR_BRESTP_MASK     = 0x00000010U;   /** @brief Rx-Stop on bit rising error the BRESTP bit is set and cleared by software. */
    static const uint32_t CEC_CFGR_BREGEN_MASK     = 0x00000020U;   /** @brief Generate error-bit on bit rising error the BREGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0 */
    static const uint32_t CEC_CFGR_LBPEGEN_MASK    = 0x00000040U;   /** @brief Generate error-bit on long bit period error the LBPEGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0 */
    static const uint32_t CEC_CFGR_BRDNOGEN_MASK   = 0x00000080U;   /** @brief Avoid error-bit generation in broadcast the BRDNOGEN bit is set and cleared by software. */
    static const uint32_t CEC_CFGR_SFTOPT_MASK     = 0x00000100U;   /** @brief SFT option bit the SFTOPT bit is set and cleared by software. */
    static const uint32_t CEC_CFGR_OAR_MASK        = 0x7FFF0000U;   /** @brief Own addresses configuration the OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. */
    static const uint32_t CEC_CFGR_LSTN_MASK       = 0x80000000U;   /** @brief Listen mode LSTN bit is set and cleared by software. */
    static const uint32_t CEC_TXDR_TXD_MASK        = 0x000000FFU;   /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 */
    static const uint32_t CEC_RXDR_RXD_MASK        = 0x000000FFU;   /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
    static const uint32_t CEC_ISR_RXBR_MASK        = 0x00000001U;   /** @brief Rx-Byte received the RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_RXEND_MASK       = 0x00000002U;   /** @brief End of reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1. */
    static const uint32_t CEC_ISR_RXOVR_MASK       = 0x00000004U;   /** @brief Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_BRE_MASK         = 0x00000008U;   /** @brief Rx-Bit rising error BRE is set by hardware in case a data-bit waveform is detected with bit rising error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an error-bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_SBPE_MASK        = 0x00000010U;   /** @brief Rx-Short bit period error SBPE is set by hardware in case a data-bit waveform is detected with short bit period error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an error-bit on the CEC line. SBPE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_LBPE_MASK        = 0x00000020U;   /** @brief Rx-Long bit period error LBPE is set by hardware in case a data-bit waveform is detected with long bit period error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an error-bit on the CEC line if LBPEGEN=1. In case of broadcast, error-bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_RXACKE_MASK      = 0x00000040U;   /** @brief Rx-Missing acknowledge in receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_ARBLST_MASK      = 0x00000080U;   /** @brief Arbitration lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXBR_MASK        = 0x00000100U;   /** @brief Tx-Byte request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXEND_MASK       = 0x00000200U;   /** @brief End of transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXUDR_MASK       = 0x00000400U;   /** @brief Tx-Buffer underrun in transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1 */
    static const uint32_t CEC_ISR_TXERR_MASK       = 0x00000800U;   /** @brief Tx-Error in transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXACKE_MASK      = 0x00001000U;   /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
    static const uint32_t CEC_IER_RXBRIE_MASK      = 0x00000001U;   /** @brief Rx-Byte received interrupt enable the RXBRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_RXENDIE_MASK     = 0x00000002U;   /** @brief End of reception interrupt enable the RXENDIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_RXOVRIE_MASK     = 0x00000004U;   /** @brief Rx-Buffer overrun interrupt enable the RXOVRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_BREIE_MASK       = 0x00000008U;   /** @brief Bit rising error interrupt enable the BREIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_SBPEIE_MASK      = 0x00000010U;   /** @brief Short bit period error interrupt enable the SBPEIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_LBPEIE_MASK      = 0x00000020U;   /** @brief Long bit period error interrupt enable the LBPEIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_RXACKIE_MASK     = 0x00000040U;   /** @brief Rx-Missing acknowledge error interrupt enable the RXACKIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_ARBLSTIE_MASK    = 0x00000080U;   /** @brief Arbitration lost interrupt enable the ARBLSTIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXBRIE_MASK      = 0x00000100U;   /** @brief Tx-Byte request interrupt enable the TXBRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXENDIE_MASK     = 0x00000200U;   /** @brief Tx-End of message interrupt enable the TXENDIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXUDRIE_MASK     = 0x00000400U;   /** @brief Tx-Underrun interrupt enable the TXUDRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXERRIE_MASK     = 0x00000800U;   /** @brief Tx-Error interrupt enable the TXERRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXACKIE_MASK     = 0x00001000U;   /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

    /**** @subsection CEC Register Field Positions ****/

    static const int32_t CEC_CR_CECEN_POS        = 0;    /** @brief CEC enable the CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission. */
    static const int32_t CEC_CR_TXSOM_POS        = 1;    /** @brief Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR headers first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception */
    static const int32_t CEC_CR_TXEOM_POS        = 2;    /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message) */
    static const int32_t CEC_CFGR_SFT_POS        = 0;    /** @brief Signal free time SFT bits are set by software. In the sft=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 data-bit periods if CEC is the new bus initiator ** 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods */
    static const int32_t CEC_CFGR_RXTOL_POS      = 3;    /** @brief Rx-Tolerance the RXTOL bit is set and cleared by software. ** start-bit, +/- 200 s rise, +/- 200 s fall. ** data-bit: +/- 200 s rise. +/- 350 s fall. ** start-bit: +/- 400 s rise, +/- 400 s fall ** data-bit: +/-300 s rise, +/- 500 s fall */
    static const int32_t CEC_CFGR_BRESTP_POS     = 4;    /** @brief Rx-Stop on bit rising error the BRESTP bit is set and cleared by software. */
    static const int32_t CEC_CFGR_BREGEN_POS     = 5;    /** @brief Generate error-bit on bit rising error the BREGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0 */
    static const int32_t CEC_CFGR_LBPEGEN_POS    = 6;    /** @brief Generate error-bit on long bit period error the LBPEGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0 */
    static const int32_t CEC_CFGR_BRDNOGEN_POS   = 7;    /** @brief Avoid error-bit generation in broadcast the BRDNOGEN bit is set and cleared by software. */
    static const int32_t CEC_CFGR_SFTOPT_POS     = 8;    /** @brief SFT option bit the SFTOPT bit is set and cleared by software. */
    static const int32_t CEC_CFGR_OAR_POS        = 16;   /** @brief Own addresses configuration the OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. */
    static const int32_t CEC_CFGR_LSTN_POS       = 31;   /** @brief Listen mode LSTN bit is set and cleared by software. */
    static const int32_t CEC_TXDR_TXD_POS        = 0;    /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 */
    static const int32_t CEC_RXDR_RXD_POS        = 0;    /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
    static const int32_t CEC_ISR_RXBR_POS        = 0;    /** @brief Rx-Byte received the RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1. */
    static const int32_t CEC_ISR_RXEND_POS       = 1;    /** @brief End of reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1. */
    static const int32_t CEC_ISR_RXOVR_POS       = 2;    /** @brief Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1. */
    static const int32_t CEC_ISR_BRE_POS         = 3;    /** @brief Rx-Bit rising error BRE is set by hardware in case a data-bit waveform is detected with bit rising error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an error-bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1. */
    static const int32_t CEC_ISR_SBPE_POS        = 4;    /** @brief Rx-Short bit period error SBPE is set by hardware in case a data-bit waveform is detected with short bit period error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an error-bit on the CEC line. SBPE is cleared by software write at 1. */
    static const int32_t CEC_ISR_LBPE_POS        = 5;    /** @brief Rx-Long bit period error LBPE is set by hardware in case a data-bit waveform is detected with long bit period error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an error-bit on the CEC line if LBPEGEN=1. In case of broadcast, error-bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1. */
    static const int32_t CEC_ISR_RXACKE_POS      = 6;    /** @brief Rx-Missing acknowledge in receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1. */
    static const int32_t CEC_ISR_ARBLST_POS      = 7;    /** @brief Arbitration lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1. */
    static const int32_t CEC_ISR_TXBR_POS        = 8;    /** @brief Tx-Byte request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1. */
    static const int32_t CEC_ISR_TXEND_POS       = 9;    /** @brief End of transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1. */
    static const int32_t CEC_ISR_TXUDR_POS       = 10;   /** @brief Tx-Buffer underrun in transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1 */
    static const int32_t CEC_ISR_TXERR_POS       = 11;   /** @brief Tx-Error in transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1. */
    static const int32_t CEC_ISR_TXACKE_POS      = 12;   /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
    static const int32_t CEC_IER_RXBRIE_POS      = 0;    /** @brief Rx-Byte received interrupt enable the RXBRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_RXENDIE_POS     = 1;    /** @brief End of reception interrupt enable the RXENDIE bit is set and cleared by software. */
    static const int32_t CEC_IER_RXOVRIE_POS     = 2;    /** @brief Rx-Buffer overrun interrupt enable the RXOVRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_BREIE_POS       = 3;    /** @brief Bit rising error interrupt enable the BREIE bit is set and cleared by software. */
    static const int32_t CEC_IER_SBPEIE_POS      = 4;    /** @brief Short bit period error interrupt enable the SBPEIE bit is set and cleared by software. */
    static const int32_t CEC_IER_LBPEIE_POS      = 5;    /** @brief Long bit period error interrupt enable the LBPEIE bit is set and cleared by software. */
    static const int32_t CEC_IER_RXACKIE_POS     = 6;    /** @brief Rx-Missing acknowledge error interrupt enable the RXACKIE bit is set and cleared by software. */
    static const int32_t CEC_IER_ARBLSTIE_POS    = 7;    /** @brief Arbitration lost interrupt enable the ARBLSTIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXBRIE_POS      = 8;    /** @brief Tx-Byte request interrupt enable the TXBRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXENDIE_POS     = 9;    /** @brief Tx-End of message interrupt enable the TXENDIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXUDRIE_POS     = 10;   /** @brief Tx-Underrun interrupt enable the TXUDRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXERRIE_POS     = 11;   /** @brief Tx-Error interrupt enable the TXERRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXACKIE_POS     = 12;   /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

    /**********************************************************************************************
     * @section HSEM Register Information
     **********************************************************************************************/

    /**** @subsection HSEM Register Pointers ****/

    static RW_ uint32_t* const HSEM_HSEM_IER_PTR= (RW_ uint32_t* const)0x58026500U;   /** @brief HSEM interrupt enable register */
    static RO_ uint32_t* const HSEM_HSEM_ICR_PTR= (RO_ uint32_t* const)0x58026504U;   /** @brief HSEM interrupt clear register */
    static RO_ uint32_t* const HSEM_HSEM_ISR_PTR= (RO_ uint32_t* const)0x58026508U;   /** @brief HSEM interrupt status register */
    static RO_ uint32_t* const HSEM_HSEM_MISR_PTR= (RO_ uint32_t* const)0x5802650CU;   /** @brief HSEM masked interrupt status register */
    static RW_ uint32_t* const HSEM_HSEM_CR_PTR= (RW_ uint32_t* const)0x58026540U;   /** @brief HSEM clear register */
    static RW_ uint32_t* const HSEM_HSEM_KEYR_PTR= (RW_ uint32_t* const)0x58026544U;   /** @brief HSEM interrupt clear register */

    /**** @subsection Enumerated HSEM Register Pointers ****/

    static RW_ uint32_t* const HSEM_HSEM_Rx_PTR[32] = {
      [0]  = (RW_ uint32_t* const)0x58026400U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [1]  = (RW_ uint32_t* const)0x58026404U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [2]  = (RW_ uint32_t* const)0x58026408U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [3]  = (RW_ uint32_t* const)0x5802640CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [4]  = (RW_ uint32_t* const)0x58026410U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [5]  = (RW_ uint32_t* const)0x58026414U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [6]  = (RW_ uint32_t* const)0x58026418U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [7]  = (RW_ uint32_t* const)0x5802641CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [8]  = (RW_ uint32_t* const)0x58026420U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [9]  = (RW_ uint32_t* const)0x58026424U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [10] = (RW_ uint32_t* const)0x58026428U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [11] = (RW_ uint32_t* const)0x5802642CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [12] = (RW_ uint32_t* const)0x58026430U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [13] = (RW_ uint32_t* const)0x58026434U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [14] = (RW_ uint32_t* const)0x58026438U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [15] = (RW_ uint32_t* const)0x5802643CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [16] = (RW_ uint32_t* const)0x58026440U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [17] = (RW_ uint32_t* const)0x58026444U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [18] = (RW_ uint32_t* const)0x58026448U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [19] = (RW_ uint32_t* const)0x5802644CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [20] = (RW_ uint32_t* const)0x58026450U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [21] = (RW_ uint32_t* const)0x58026454U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [22] = (RW_ uint32_t* const)0x58026458U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [23] = (RW_ uint32_t* const)0x5802645CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [24] = (RW_ uint32_t* const)0x58026460U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [25] = (RW_ uint32_t* const)0x58026464U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [26] = (RW_ uint32_t* const)0x58026468U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [27] = (RW_ uint32_t* const)0x5802646CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [28] = (RW_ uint32_t* const)0x58026470U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [29] = (RW_ uint32_t* const)0x58026474U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [30] = (RW_ uint32_t* const)0x58026478U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [31] = (RW_ uint32_t* const)0x5802647CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    };

    static RO_ uint32_t* const HSEM_HSEM_RLRx_PTR[32] = {
      [0]  = (RO_ uint32_t* const)0x58026480U,   /** @brief HSEM read lock register */
      [1]  = (RO_ uint32_t* const)0x58026484U,   /** @brief HSEM read lock register */
      [2]  = (RO_ uint32_t* const)0x58026488U,   /** @brief HSEM read lock register */
      [3]  = (RO_ uint32_t* const)0x5802648CU,   /** @brief HSEM read lock register */
      [4]  = (RO_ uint32_t* const)0x58026490U,   /** @brief HSEM read lock register */
      [5]  = (RO_ uint32_t* const)0x58026494U,   /** @brief HSEM read lock register */
      [6]  = (RO_ uint32_t* const)0x58026498U,   /** @brief HSEM read lock register */
      [7]  = (RO_ uint32_t* const)0x5802649CU,   /** @brief HSEM read lock register */
      [8]  = (RO_ uint32_t* const)0x580264A0U,   /** @brief HSEM read lock register */
      [9]  = (RO_ uint32_t* const)0x580264A4U,   /** @brief HSEM read lock register */
      [10] = (RO_ uint32_t* const)0x580264A8U,   /** @brief HSEM read lock register */
      [11] = (RO_ uint32_t* const)0x580264ACU,   /** @brief HSEM read lock register */
      [12] = (RO_ uint32_t* const)0x580264B0U,   /** @brief HSEM read lock register */
      [13] = (RO_ uint32_t* const)0x580264B4U,   /** @brief HSEM read lock register */
      [14] = (RO_ uint32_t* const)0x580264B8U,   /** @brief HSEM read lock register */
      [15] = (RO_ uint32_t* const)0x580264BCU,   /** @brief HSEM read lock register */
      [16] = (RO_ uint32_t* const)0x580264C0U,   /** @brief HSEM read lock register */
      [17] = (RO_ uint32_t* const)0x580264C4U,   /** @brief HSEM read lock register */
      [18] = (RO_ uint32_t* const)0x580264C8U,   /** @brief HSEM read lock register */
      [19] = (RO_ uint32_t* const)0x580264CCU,   /** @brief HSEM read lock register */
      [20] = (RO_ uint32_t* const)0x580264D0U,   /** @brief HSEM read lock register */
      [21] = (RO_ uint32_t* const)0x580264D4U,   /** @brief HSEM read lock register */
      [22] = (RO_ uint32_t* const)0x580264D8U,   /** @brief HSEM read lock register */
      [23] = (RO_ uint32_t* const)0x580264DCU,   /** @brief HSEM read lock register */
      [24] = (RO_ uint32_t* const)0x580264E0U,   /** @brief HSEM read lock register */
      [25] = (RO_ uint32_t* const)0x580264E4U,   /** @brief HSEM read lock register */
      [26] = (RO_ uint32_t* const)0x580264E8U,   /** @brief HSEM read lock register */
      [27] = (RO_ uint32_t* const)0x580264ECU,   /** @brief HSEM read lock register */
      [28] = (RO_ uint32_t* const)0x580264F0U,   /** @brief HSEM read lock register */
      [29] = (RO_ uint32_t* const)0x580264F4U,   /** @brief HSEM read lock register */
      [30] = (RO_ uint32_t* const)0x580264F8U,   /** @brief HSEM read lock register */
      [31] = (RO_ uint32_t* const)0x580264FCU,   /** @brief HSEM read lock register */
    };

    /**** @subsection HSEM Register Reset Values ****/

    static const uint32_t HSEM_HSEM_IER_RST= 0x00000000U;   /** @brief HSEM_IER register reset value. */
    static const uint32_t HSEM_HSEM_ICR_RST= 0x00000000U;   /** @brief HSEM_ICR register reset value. */
    static const uint32_t HSEM_HSEM_ISR_RST= 0x00000000U;   /** @brief HSEM_ISR register reset value. */
    static const uint32_t HSEM_HSEM_MISR_RST= 0x00000000U;   /** @brief HSEM_MISR register reset value. */
    static const uint32_t HSEM_HSEM_CR_RST= 0x00000000U;   /** @brief HSEM_CR register reset value. */
    static const uint32_t HSEM_HSEM_KEYR_RST= 0x00000000U;   /** @brief HSEM_KEYR register reset value. */

    /**** @subsection Enumerated HSEM Register Reset Values ****/

    static const uint32_t HSEM_HSEM_Rx_RST[32] = {
      [0]  = 0x00000000U,   /** @brief HSEM_R0 register reset value. */
      [1]  = 0x00000000U,   /** @brief HSEM_R1 register reset value. */
      [2]  = 0x00000000U,   /** @brief HSEM_R2 register reset value. */
      [3]  = 0x00000000U,   /** @brief HSEM_R3 register reset value. */
      [4]  = 0x00000000U,   /** @brief HSEM_R4 register reset value. */
      [5]  = 0x00000000U,   /** @brief HSEM_R5 register reset value. */
      [6]  = 0x00000000U,   /** @brief HSEM_R6 register reset value. */
      [7]  = 0x00000000U,   /** @brief HSEM_R7 register reset value. */
      [8]  = 0x00000000U,   /** @brief HSEM_R8 register reset value. */
      [9]  = 0x00000000U,   /** @brief HSEM_R9 register reset value. */
      [10] = 0x00000000U,   /** @brief HSEM_R10 register reset value. */
      [11] = 0x00000000U,   /** @brief HSEM_R11 register reset value. */
      [12] = 0x00000000U,   /** @brief HSEM_R12 register reset value. */
      [13] = 0x00000000U,   /** @brief HSEM_R13 register reset value. */
      [14] = 0x00000000U,   /** @brief HSEM_R14 register reset value. */
      [15] = 0x00000000U,   /** @brief HSEM_R15 register reset value. */
      [16] = 0x00000000U,   /** @brief HSEM_R16 register reset value. */
      [17] = 0x00000000U,   /** @brief HSEM_R17 register reset value. */
      [18] = 0x00000000U,   /** @brief HSEM_R18 register reset value. */
      [19] = 0x00000000U,   /** @brief HSEM_R19 register reset value. */
      [20] = 0x00000000U,   /** @brief HSEM_R20 register reset value. */
      [21] = 0x00000000U,   /** @brief HSEM_R21 register reset value. */
      [22] = 0x00000000U,   /** @brief HSEM_R22 register reset value. */
      [23] = 0x00000000U,   /** @brief HSEM_R23 register reset value. */
      [24] = 0x00000000U,   /** @brief HSEM_R24 register reset value. */
      [25] = 0x00000000U,   /** @brief HSEM_R25 register reset value. */
      [26] = 0x00000000U,   /** @brief HSEM_R26 register reset value. */
      [27] = 0x00000000U,   /** @brief HSEM_R27 register reset value. */
      [28] = 0x00000000U,   /** @brief HSEM_R28 register reset value. */
      [29] = 0x00000000U,   /** @brief HSEM_R29 register reset value. */
      [30] = 0x00000000U,   /** @brief HSEM_R30 register reset value. */
      [31] = 0x00000000U,   /** @brief HSEM_R31 register reset value. */
    };

    static const uint32_t HSEM_HSEM_RLRx_RST[32] = {
      [0]  = 0x00000000U,   /** @brief HSEM_RLR0 register reset value. */
      [1]  = 0x00000000U,   /** @brief HSEM_RLR1 register reset value. */
      [2]  = 0x00000000U,   /** @brief HSEM_RLR2 register reset value. */
      [3]  = 0x00000000U,   /** @brief HSEM_RLR3 register reset value. */
      [4]  = 0x00000000U,   /** @brief HSEM_RLR4 register reset value. */
      [5]  = 0x00000000U,   /** @brief HSEM_RLR5 register reset value. */
      [6]  = 0x00000000U,   /** @brief HSEM_RLR6 register reset value. */
      [7]  = 0x00000000U,   /** @brief HSEM_RLR7 register reset value. */
      [8]  = 0x00000000U,   /** @brief HSEM_RLR8 register reset value. */
      [9]  = 0x00000000U,   /** @brief HSEM_RLR9 register reset value. */
      [10] = 0x00000000U,   /** @brief HSEM_RLR10 register reset value. */
      [11] = 0x00000000U,   /** @brief HSEM_RLR11 register reset value. */
      [12] = 0x00000000U,   /** @brief HSEM_RLR12 register reset value. */
      [13] = 0x00000000U,   /** @brief HSEM_RLR13 register reset value. */
      [14] = 0x00000000U,   /** @brief HSEM_RLR14 register reset value. */
      [15] = 0x00000000U,   /** @brief HSEM_RLR15 register reset value. */
      [16] = 0x00000000U,   /** @brief HSEM_RLR16 register reset value. */
      [17] = 0x00000000U,   /** @brief HSEM_RLR17 register reset value. */
      [18] = 0x00000000U,   /** @brief HSEM_RLR18 register reset value. */
      [19] = 0x00000000U,   /** @brief HSEM_RLR19 register reset value. */
      [20] = 0x00000000U,   /** @brief HSEM_RLR20 register reset value. */
      [21] = 0x00000000U,   /** @brief HSEM_RLR21 register reset value. */
      [22] = 0x00000000U,   /** @brief HSEM_RLR22 register reset value. */
      [23] = 0x00000000U,   /** @brief HSEM_RLR23 register reset value. */
      [24] = 0x00000000U,   /** @brief HSEM_RLR24 register reset value. */
      [25] = 0x00000000U,   /** @brief HSEM_RLR25 register reset value. */
      [26] = 0x00000000U,   /** @brief HSEM_RLR26 register reset value. */
      [27] = 0x00000000U,   /** @brief HSEM_RLR27 register reset value. */
      [28] = 0x00000000U,   /** @brief HSEM_RLR28 register reset value. */
      [29] = 0x00000000U,   /** @brief HSEM_RLR29 register reset value. */
      [30] = 0x00000000U,   /** @brief HSEM_RLR30 register reset value. */
      [31] = 0x00000000U,   /** @brief HSEM_RLR31 register reset value. */
    };

    /**** @subsection Enumerated HSEM Register Value Types ****/

    typedef uint32_t HSEM_HSEM_Rx_t;     /** @brief HSEM_Rx register value type. */
    typedef uint32_t HSEM_HSEM_RLRx_t;   /** @brief HSEM_RLRx register value type. */
    typedef uint32_t HSEM_HSEM_IER_t;    /** @brief HSEM_IER register value type. */
    typedef uint32_t HSEM_HSEM_ICR_t;    /** @brief HSEM_ICR register value type. */
    typedef uint32_t HSEM_HSEM_ISR_t;    /** @brief HSEM_ISR register value type. */
    typedef uint32_t HSEM_HSEM_MISR_t;   /** @brief HSEM_MISR register value type. */
    typedef uint32_t HSEM_HSEM_CR_t;     /** @brief HSEM_CR register value type. */
    typedef uint32_t HSEM_HSEM_KEYR_t;   /** @brief HSEM_KEYR register value type. */

    /**** @subsection Enumerated HSEM Register Pointer Types ****/

    typedef uint32_t* const HSEM_HSEM_Rx_PTR_t;     /** @brief HSEM_Rx register pointer type. */
    typedef uint32_t* const HSEM_HSEM_RLRx_PTR_t;   /** @brief HSEM_RLRx register pointer type. */
    typedef uint32_t* const HSEM_HSEM_IER_PTR_t;    /** @brief HSEM_IER register pointer type. */
    typedef uint32_t* const HSEM_HSEM_ICR_PTR_t;    /** @brief HSEM_ICR register pointer type. */
    typedef uint32_t* const HSEM_HSEM_ISR_PTR_t;    /** @brief HSEM_ISR register pointer type. */
    typedef uint32_t* const HSEM_HSEM_MISR_PTR_t;   /** @brief HSEM_MISR register pointer type. */
    typedef uint32_t* const HSEM_HSEM_CR_PTR_t;     /** @brief HSEM_CR register pointer type. */
    typedef uint32_t* const HSEM_HSEM_KEYR_PTR_t;   /** @brief HSEM_KEYR register pointer type. */

    /**** @subsection HSEM Register Field Masks ****/

    static const uint32_t HSEM_HSEM_Rx_PROCID_MASK       = 0x000000FFU;   /** @brief Semaphore processid */
    static const uint32_t HSEM_HSEM_Rx_MASTERID_MASK     = 0x0000FF00U;   /** @brief Semaphore masterid */
    static const uint32_t HSEM_HSEM_Rx_LOCK_MASK         = 0x80000000U;   /** @brief Lock indication */
    static const uint32_t HSEM_HSEM_RLRx_PROCID_MASK     = 0x000000FFU;   /** @brief Semaphore processid */
    static const uint32_t HSEM_HSEM_RLRx_MASTERID_MASK   = 0x0000FF00U;   /** @brief Semaphore masterid */
    static const uint32_t HSEM_HSEM_RLRx_LOCK_MASK       = 0x80000000U;   /** @brief Lock indication */
    static const uint32_t HSEM_HSEM_CR_MASTERID_MASK     = 0x0000FF00U;   /** @brief MasterID of semaphores to be cleared */
    static const uint32_t HSEM_HSEM_CR_KEY_MASK          = 0xFFFF0000U;   /** @brief Semaphore clear key */
    static const uint32_t HSEM_HSEM_KEYR_KEY_MASK        = 0xFFFF0000U;   /** @brief Semaphore clear key */

    /**** @subsection Enumerated HSEM Register Field Masks ****/

    static const uint32_t HSEM_HSEM_IER_ISEMx_MASK[32] = {
      [0]  = 0x00000001U,   /** @brief Interrupt semaphore n enable bit */
      [1]  = 0x00000002U,   /** @brief Interrupt semaphore n enable bit */
      [2]  = 0x00000004U,   /** @brief Interrupt semaphore n enable bit */
      [3]  = 0x00000008U,   /** @brief Interrupt semaphore n enable bit */
      [4]  = 0x00000010U,   /** @brief Interrupt semaphore n enable bit */
      [5]  = 0x00000020U,   /** @brief Interrupt semaphore n enable bit */
      [6]  = 0x00000040U,   /** @brief Interrupt semaphore n enable bit */
      [7]  = 0x00000080U,   /** @brief Interrupt semaphore n enable bit */
      [8]  = 0x00000100U,   /** @brief Interrupt semaphore n enable bit */
      [9]  = 0x00000200U,   /** @brief Interrupt semaphore n enable bit */
      [10] = 0x00000400U,   /** @brief Interrupt semaphore n enable bit */
      [11] = 0x00000800U,   /** @brief Interrupt semaphore n enable bit */
      [12] = 0x00001000U,   /** @brief Interrupt semaphore n enable bit */
      [13] = 0x00002000U,   /** @brief Interrupt semaphore n enable bit */
      [14] = 0x00004000U,   /** @brief Interrupt semaphore n enable bit */
      [15] = 0x00008000U,   /** @brief Interrupt semaphore n enable bit */
      [16] = 0x00010000U,   /** @brief Interrupt semaphore n enable bit */
      [17] = 0x00020000U,   /** @brief Interrupt semaphore n enable bit */
      [18] = 0x00040000U,   /** @brief Interrupt semaphore n enable bit */
      [19] = 0x00080000U,   /** @brief Interrupt semaphore n enable bit */
      [20] = 0x00100000U,   /** @brief Interrupt semaphore n enable bit */
      [21] = 0x00200000U,   /** @brief Interrupt semaphore n enable bit */
      [22] = 0x00400000U,   /** @brief Interrupt semaphore n enable bit */
      [23] = 0x00800000U,   /** @brief Interrupt semaphore n enable bit */
      [24] = 0x01000000U,   /** @brief Interrupt semaphore n enable bit */
      [25] = 0x02000000U,   /** @brief Interrupt semaphore n enable bit */
      [26] = 0x04000000U,   /** @brief Interrupt semaphore n enable bit */
      [27] = 0x08000000U,   /** @brief Interrupt semaphore n enable bit */
      [28] = 0x10000000U,   /** @brief Interrupt semaphore n enable bit */
      [29] = 0x20000000U,   /** @brief Interrupt semaphore n enable bit */
      [30] = 0x40000000U,   /** @brief Interrupt semaphore n enable bit */
      [31] = 0x80000000U,   /** @brief Interrupt(N) semaphore n enable bit. */
    };

    /**** @subsection HSEM Register Field Positions ****/

    static const int32_t HSEM_HSEM_Rx_PROCID_POS       = 0;    /** @brief Semaphore processid */
    static const int32_t HSEM_HSEM_Rx_MASTERID_POS     = 8;    /** @brief Semaphore masterid */
    static const int32_t HSEM_HSEM_Rx_LOCK_POS         = 31;   /** @brief Lock indication */
    static const int32_t HSEM_HSEM_RLRx_PROCID_POS     = 0;    /** @brief Semaphore processid */
    static const int32_t HSEM_HSEM_RLRx_MASTERID_POS   = 8;    /** @brief Semaphore masterid */
    static const int32_t HSEM_HSEM_RLRx_LOCK_POS       = 31;   /** @brief Lock indication */
    static const int32_t HSEM_HSEM_CR_MASTERID_POS     = 8;    /** @brief MasterID of semaphores to be cleared */
    static const int32_t HSEM_HSEM_CR_KEY_POS          = 16;   /** @brief Semaphore clear key */
    static const int32_t HSEM_HSEM_KEYR_KEY_POS        = 16;   /** @brief Semaphore clear key */

    /**** @subsection Enumerated HSEM Register Field Positions ****/

    static const int32_t HSEM_HSEM_IER_ISEMx_POS[32] = {
      [0]  = 0,    /** @brief Interrupt semaphore n enable bit */
      [1]  = 1,    /** @brief Interrupt semaphore n enable bit */
      [2]  = 2,    /** @brief Interrupt semaphore n enable bit */
      [3]  = 3,    /** @brief Interrupt semaphore n enable bit */
      [4]  = 4,    /** @brief Interrupt semaphore n enable bit */
      [5]  = 5,    /** @brief Interrupt semaphore n enable bit */
      [6]  = 6,    /** @brief Interrupt semaphore n enable bit */
      [7]  = 7,    /** @brief Interrupt semaphore n enable bit */
      [8]  = 8,    /** @brief Interrupt semaphore n enable bit */
      [9]  = 9,    /** @brief Interrupt semaphore n enable bit */
      [10] = 10,   /** @brief Interrupt semaphore n enable bit */
      [11] = 11,   /** @brief Interrupt semaphore n enable bit */
      [12] = 12,   /** @brief Interrupt semaphore n enable bit */
      [13] = 13,   /** @brief Interrupt semaphore n enable bit */
      [14] = 14,   /** @brief Interrupt semaphore n enable bit */
      [15] = 15,   /** @brief Interrupt semaphore n enable bit */
      [16] = 16,   /** @brief Interrupt semaphore n enable bit */
      [17] = 17,   /** @brief Interrupt semaphore n enable bit */
      [18] = 18,   /** @brief Interrupt semaphore n enable bit */
      [19] = 19,   /** @brief Interrupt semaphore n enable bit */
      [20] = 20,   /** @brief Interrupt semaphore n enable bit */
      [21] = 21,   /** @brief Interrupt semaphore n enable bit */
      [22] = 22,   /** @brief Interrupt semaphore n enable bit */
      [23] = 23,   /** @brief Interrupt semaphore n enable bit */
      [24] = 24,   /** @brief Interrupt semaphore n enable bit */
      [25] = 25,   /** @brief Interrupt semaphore n enable bit */
      [26] = 26,   /** @brief Interrupt semaphore n enable bit */
      [27] = 27,   /** @brief Interrupt semaphore n enable bit */
      [28] = 28,   /** @brief Interrupt semaphore n enable bit */
      [29] = 29,   /** @brief Interrupt semaphore n enable bit */
      [30] = 30,   /** @brief Interrupt semaphore n enable bit */
      [31] = 31,   /** @brief Interrupt(N) semaphore n enable bit. */
    };

    /**********************************************************************************************
     * @section I2Cx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated I2Cx Register Pointers ****/

    static RW_ uint32_t* const I2Cx_CR1_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40005400U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005800U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [3] = (RW_ uint32_t* const)0x40005C00U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [4] = (RW_ uint32_t* const)0x58001C00U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static RW_ uint32_t* const I2Cx_CR2_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40005404U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005804U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [3] = (RW_ uint32_t* const)0x40005C04U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [4] = (RW_ uint32_t* const)0x58001C04U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static RW_ uint32_t* const I2Cx_OAR1_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40005408U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005808U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [3] = (RW_ uint32_t* const)0x40005C08U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [4] = (RW_ uint32_t* const)0x58001C08U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static RW_ uint32_t* const I2Cx_OAR2_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4000540CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x4000580CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [3] = (RW_ uint32_t* const)0x40005C0CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [4] = (RW_ uint32_t* const)0x58001C0CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static RW_ uint32_t* const I2Cx_TIMINGR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40005410U,   /** @brief Access: no wait states */
      [2] = (RW_ uint32_t* const)0x40005810U,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t* const)0x40005C10U,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t* const)0x58001C10U,   /** @brief Access: no wait states */
    };

    static RW_ uint32_t* const I2Cx_TIMEOUTR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40005414U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005814U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [3] = (RW_ uint32_t* const)0x40005C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [4] = (RW_ uint32_t* const)0x58001C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static RW_ uint32_t* const I2Cx_ISR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40005418U,   /** @brief Access: no wait states */
      [2] = (RW_ uint32_t* const)0x40005818U,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t* const)0x40005C18U,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t* const)0x58001C18U,   /** @brief Access: no wait states */
    };

    static RW_ uint32_t* const I2Cx_ICR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4000541CU,   /** @brief Access: no wait states */
      [2] = (RW_ uint32_t* const)0x4000581CU,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t* const)0x40005C1CU,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t* const)0x58001C1CU,   /** @brief Access: no wait states */
    };

    static RO_ uint32_t* const I2Cx_PECR_PTR[5] = {
      [1] = (RO_ uint32_t* const)0x40005420U,   /** @brief Access: no wait states */
      [2] = (RO_ uint32_t* const)0x40005820U,   /** @brief Access: no wait states */
      [3] = (RO_ uint32_t* const)0x40005C20U,   /** @brief Access: no wait states */
      [4] = (RO_ uint32_t* const)0x58001C20U,   /** @brief Access: no wait states */
    };

    static RO_ uint32_t* const I2Cx_RXDR_PTR[5] = {
      [1] = (RO_ uint32_t* const)0x40005424U,   /** @brief Access: no wait states */
      [2] = (RO_ uint32_t* const)0x40005824U,   /** @brief Access: no wait states */
      [3] = (RO_ uint32_t* const)0x40005C24U,   /** @brief Access: no wait states */
      [4] = (RO_ uint32_t* const)0x58001C24U,   /** @brief Access: no wait states */
    };

    static RW_ uint32_t* const I2Cx_TXDR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40005428U,   /** @brief Access: no wait states */
      [2] = (RW_ uint32_t* const)0x40005828U,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t* const)0x40005C28U,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t* const)0x58001C28U,   /** @brief Access: no wait states */
    };

    /**** @subsection Enumerated I2Cx Register Reset Values ****/

    static const uint32_t I2Cx_CR1_RST[5] = {
      [1] = 0x00000000U,   /** @brief CR1 register reset value */
      [2] = 0x00000000U,   /** @brief CR1 register reset value */
      [3] = 0x00000000U,   /** @brief CR1 register reset value */
      [4] = 0x00000000U,   /** @brief CR1 register reset value */
    };

    static const uint32_t I2Cx_CR2_RST[5] = {
      [1] = 0x00000000U,   /** @brief CR2 register reset value */
      [2] = 0x00000000U,   /** @brief CR2 register reset value */
      [3] = 0x00000000U,   /** @brief CR2 register reset value */
      [4] = 0x00000000U,   /** @brief CR2 register reset value */
    };

    static const uint32_t I2Cx_OAR1_RST[5] = {
      [1] = 0x00000000U,   /** @brief OAR1 register reset value */
      [2] = 0x00000000U,   /** @brief OAR1 register reset value */
      [3] = 0x00000000U,   /** @brief OAR1 register reset value */
      [4] = 0x00000000U,   /** @brief OAR1 register reset value */
    };

    static const uint32_t I2Cx_OAR2_RST[5] = {
      [1] = 0x00000000U,   /** @brief OAR2 register reset value */
      [2] = 0x00000000U,   /** @brief OAR2 register reset value */
      [3] = 0x00000000U,   /** @brief OAR2 register reset value */
      [4] = 0x00000000U,   /** @brief OAR2 register reset value */
    };

    static const uint32_t I2Cx_TIMINGR_RST[5] = {
      [1] = 0x00000000U,   /** @brief TIMINGR register reset value */
      [2] = 0x00000000U,   /** @brief TIMINGR register reset value */
      [3] = 0x00000000U,   /** @brief TIMINGR register reset value */
      [4] = 0x00000000U,   /** @brief TIMINGR register reset value */
    };

    static const uint32_t I2Cx_TIMEOUTR_RST[5] = {
      [1] = 0x00000000U,   /** @brief TIMEOUTR register reset value */
      [2] = 0x00000000U,   /** @brief TIMEOUTR register reset value */
      [3] = 0x00000000U,   /** @brief TIMEOUTR register reset value */
      [4] = 0x00000000U,   /** @brief TIMEOUTR register reset value */
    };

    static const uint32_t I2Cx_ISR_RST[5] = {
      [1] = 0x00000001U,   /** @brief ISR register reset value */
      [2] = 0x00000001U,   /** @brief ISR register reset value */
      [3] = 0x00000001U,   /** @brief ISR register reset value */
      [4] = 0x00000001U,   /** @brief ISR register reset value */
    };

    static const uint32_t I2Cx_ICR_RST[5] = {
      [1] = 0x00000000U,   /** @brief ICR register reset value */
      [2] = 0x00000000U,   /** @brief ICR register reset value */
      [3] = 0x00000000U,   /** @brief ICR register reset value */
      [4] = 0x00000000U,   /** @brief ICR register reset value */
    };

    static const uint32_t I2Cx_PECR_RST[5] = {
      [1] = 0x00000000U,   /** @brief PECR register reset value */
      [2] = 0x00000000U,   /** @brief PECR register reset value */
      [3] = 0x00000000U,   /** @brief PECR register reset value */
      [4] = 0x00000000U,   /** @brief PECR register reset value */
    };

    static const uint32_t I2Cx_RXDR_RST[5] = {
      [1] = 0x00000000U,   /** @brief RXDR register reset value */
      [2] = 0x00000000U,   /** @brief RXDR register reset value */
      [3] = 0x00000000U,   /** @brief RXDR register reset value */
      [4] = 0x00000000U,   /** @brief RXDR register reset value */
    };

    static const uint32_t I2Cx_TXDR_RST[5] = {
      [1] = 0x00000000U,   /** @brief TXDR register reset value */
      [2] = 0x00000000U,   /** @brief TXDR register reset value */
      [3] = 0x00000000U,   /** @brief TXDR register reset value */
      [4] = 0x00000000U,   /** @brief TXDR register reset value */
    };

    /**** @subsection Enumerated I2Cx Register Value Types ****/

    typedef uint32_t I2Cx_CR1_t;        /** @brief CR1 register value type. */
    typedef uint32_t I2Cx_CR2_t;        /** @brief CR2 register value type. */
    typedef uint32_t I2Cx_OAR1_t;       /** @brief OAR1 register value type. */
    typedef uint32_t I2Cx_OAR2_t;       /** @brief OAR2 register value type. */
    typedef uint32_t I2Cx_TIMINGR_t;    /** @brief TIMINGR register value type. */
    typedef uint32_t I2Cx_TIMEOUTR_t;   /** @brief TIMEOUTR register value type. */
    typedef uint32_t I2Cx_ISR_t;        /** @brief ISR register value type. */
    typedef uint32_t I2Cx_ICR_t;        /** @brief ICR register value type. */
    typedef uint32_t I2Cx_PECR_t;       /** @brief PECR register value type. */
    typedef uint32_t I2Cx_RXDR_t;       /** @brief RXDR register value type. */
    typedef uint32_t I2Cx_TXDR_t;       /** @brief TXDR register value type. */

    /**** @subsection Enumerated I2Cx Register Pointer Types ****/

    typedef uint32_t* const I2Cx_CR1_PTR_t;        /** @brief CR1 register pointer type. */
    typedef uint32_t* const I2Cx_CR2_PTR_t;        /** @brief CR2 register pointer type. */
    typedef uint32_t* const I2Cx_OAR1_PTR_t;       /** @brief OAR1 register pointer type. */
    typedef uint32_t* const I2Cx_OAR2_PTR_t;       /** @brief OAR2 register pointer type. */
    typedef uint32_t* const I2Cx_TIMINGR_PTR_t;    /** @brief TIMINGR register pointer type. */
    typedef uint32_t* const I2Cx_TIMEOUTR_PTR_t;   /** @brief TIMEOUTR register pointer type. */
    typedef uint32_t* const I2Cx_ISR_PTR_t;        /** @brief ISR register pointer type. */
    typedef uint32_t* const I2Cx_ICR_PTR_t;        /** @brief ICR register pointer type. */
    typedef uint32_t* const I2Cx_PECR_PTR_t;       /** @brief PECR register pointer type. */
    typedef uint32_t* const I2Cx_RXDR_PTR_t;       /** @brief RXDR register pointer type. */
    typedef uint32_t* const I2Cx_TXDR_PTR_t;       /** @brief TXDR register pointer type. */

    /**** @subsection I2Cx Register Field Masks ****/

    static const uint32_t I2Cx_CR1_PE_MASK              = 0x00000001U;   /** @brief Peripheral enable note: when PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles. */
    static const uint32_t I2Cx_CR1_TXIE_MASK            = 0x00000002U;   /** @brief TX interrupt enable */
    static const uint32_t I2Cx_CR1_RXIE_MASK            = 0x00000004U;   /** @brief RX interrupt enable */
    static const uint32_t I2Cx_CR1_ADDRIE_MASK          = 0x00000008U;   /** @brief Address match interrupt enable (slave only) */
    static const uint32_t I2Cx_CR1_NACKIE_MASK          = 0x00000010U;   /** @brief Not acknowledge received interrupt enable */
    static const uint32_t I2Cx_CR1_STOPIE_MASK          = 0x00000020U;   /** @brief STOP detection interrupt enable */
    static const uint32_t I2Cx_CR1_TCIE_MASK            = 0x00000040U;   /** @brief Transfer complete interrupt enable note: any of these events will generate an interrupt: transfer complete (TC) transfer complete reload (TCR) */
    static const uint32_t I2Cx_CR1_ERRIE_MASK           = 0x00000080U;   /** @brief Error interrupts enable note: any of these errors generate an interrupt: arbitration loss (ARLO) bus error detection (BERR) overrun/underrun (OVR) timeout detection (TIMEOUT) PEC error detection (PECERR) alert pin event detection (ALERT) */
    static const uint32_t I2Cx_CR1_DNF_MASK             = 0x00000F00U;   /** @brief Digital noise filter these bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * ti2cclk ... Note: if the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). */
    static const uint32_t I2Cx_CR1_ANFOFF_MASK          = 0x00001000U;   /** @brief Analog noise filter OFF note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const uint32_t I2Cx_CR1_TXDMAEN_MASK         = 0x00004000U;   /** @brief DMA transmission requests enable */
    static const uint32_t I2Cx_CR1_RXDMAEN_MASK         = 0x00008000U;   /** @brief DMA reception requests enable */
    static const uint32_t I2Cx_CR1_SBC_MASK             = 0x00010000U;   /** @brief Slave byte control this bit is used to enable hardware byte control in slave mode. */
    static const uint32_t I2Cx_CR1_NOSTRETCH_MASK       = 0x00020000U;   /** @brief Clock stretching disable this bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const uint32_t I2Cx_CR1_WUPEN_MASK           = 0x00040000U;   /** @brief Wakeup from stop mode enable note: if the wakeup from stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000 */
    static const uint32_t I2Cx_CR1_GCEN_MASK            = 0x00080000U;   /** @brief General call enable */
    static const uint32_t I2Cx_CR1_SMBHEN_MASK          = 0x00100000U;   /** @brief SMBus host address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_CR1_SMBDEN_MASK          = 0x00200000U;   /** @brief SMBus device default address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_CR1_ALERTEN_MASK         = 0x00400000U;   /** @brief SMBus alert enable device mode (SMBHEN=0): host mode (SMBHEN=1): note: when ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_CR1_PECEN_MASK           = 0x00800000U;   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_CR2_RD_WRN_MASK          = 0x00000400U;   /** @brief Transfer direction (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const uint32_t I2Cx_CR2_ADD10_MASK           = 0x00000800U;   /** @brief 10-bit addressing mode (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const uint32_t I2Cx_CR2_HEAD10R_MASK         = 0x00001000U;   /** @brief 10-bit address header only read direction (master receiver mode) note: changing this bit when the START bit is set is not allowed. */
    static const uint32_t I2Cx_CR2_START_MASK           = 0x00002000U;   /** @brief Start generation this bit is set by software, and cleared by hardware after the start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a repeated start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set. */
    static const uint32_t I2Cx_CR2_STOP_MASK            = 0x00004000U;   /** @brief Stop generation (master mode) the bit is set by software, cleared by hardware when a stop condition is detected, or when PE = 0. In master mode: note: writing 0 to this bit has no effect. */
    static const uint32_t I2Cx_CR2_NACK_MASK            = 0x00008000U;   /** @brief NACK generation (slave mode) the bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an address matched is received, or when PE=0. Note: writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value. */
    static const uint32_t I2Cx_CR2_NBYTES_MASK          = 0x00FF0000U;   /** @brief Number of bytes the number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: changing these bits when the START bit is set is not allowed. */
    static const uint32_t I2Cx_CR2_RELOAD_MASK          = 0x01000000U;   /** @brief NBYTES reload mode this bit is set and cleared by software. */
    static const uint32_t I2Cx_CR2_AUTOEND_MASK         = 0x02000000U;   /** @brief Automatic end mode (master mode) this bit is set and cleared by software. Note: this bit has no effect in slave mode or when the RELOAD bit is set. */
    static const uint32_t I2Cx_CR2_PECBYTE_MASK         = 0x04000000U;   /** @brief Packet error checking byte this bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an address matched is received, also when PE=0. Note: writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_OAR1_OA1_MASK            = 0x000003FFU;   /** @brief Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address note: these bits can be written only when OA1EN=0. OA1[7:1]: interface address bits 7:1 of address note: these bits can be written only when OA1EN=0. OA1[0]: interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address note: this bit can be written only when OA1EN=0. */
    static const uint32_t I2Cx_OAR1_OA1MODE_MASK        = 0x00000400U;   /** @brief Own address 1 10-bit mode note: this bit can be written only when OA1EN=0. */
    static const uint32_t I2Cx_OAR1_OA1EN_MASK          = 0x00008000U;   /** @brief Own address 1 enable */
    static const uint32_t I2Cx_OAR2_OA2_MASK            = 0x000000FEU;   /** @brief Interface address bits 7:1 of address note: these bits can be written only when OA2EN=0. */
    static const uint32_t I2Cx_OAR2_OA2MSK_MASK         = 0x00000700U;   /** @brief Own address 2 masks note: these bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. */
    static const uint32_t I2Cx_OAR2_OA2EN_MASK          = 0x00008000U;   /** @brief Own address 2 enable */
    static const uint32_t I2Cx_TIMINGR_SCLL_MASK        = 0x000000FFU;   /** @brief SCL low period (master mode) this field is used to generate the SCL low period in master mode. TSCLL = (SCLL+1) x tpresc note: SCLL is also used to generate tbuf and tsu:sta timings. */
    static const uint32_t I2Cx_TIMINGR_SCLH_MASK        = 0x0000FF00U;   /** @brief SCL high period (master mode) this field is used to generate the SCL high period in master mode. TSCLH = (SCLH+1) x tpresc note: SCLH is also used to generate tsu:sto and thd:sta timing. */
    static const uint32_t I2Cx_TIMINGR_SDADEL_MASK      = 0x000F0000U;   /** @brief Data hold time this field is used to generate the delay tsdadel between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsdadel. TSDADEL= SDADEL x tpresc note: SDADEL is used to generate thd:dat timing. */
    static const uint32_t I2Cx_TIMINGR_SCLDEL_MASK      = 0x00F00000U;   /** @brief Data setup time this field is used to generate a delay tscldel between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tscldel. TSCLDEL = (SCLDEL+1) x tpresc note: tscldel is used to generate tsu:dat timing. */
    static const uint32_t I2Cx_TIMINGR_PRESC_MASK       = 0xF0000000U;   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
    static const uint32_t I2Cx_TIMEOUTR_TIMEOUTA_MASK   = 0x00000FFFU;   /** @brief Bus timeout A this field is used to configure: the SCL low timeout condition ttimeout when TIDLE=0 ttimeout= (TIMEOUTA+1) x 2048 x ti2cclk the bus idle condition (both SCL and SDA high) when TIDLE=1 tidle= (TIMEOUTA+1) x 4 x ti2cclk note: these bits can be written only when TIMOUTEN=0. */
    static const uint32_t I2Cx_TIMEOUTR_TIDLE_MASK      = 0x00001000U;   /** @brief Idle clock timeout detection note: this bit can be written only when TIMOUTEN=0. */
    static const uint32_t I2Cx_TIMEOUTR_TIMOUTEN_MASK   = 0x00008000U;   /** @brief Clock timeout enable */
    static const uint32_t I2Cx_TIMEOUTR_TIMEOUTB_MASK   = 0x0FFF0000U;   /** @brief Bus timeout B this field is used to configure the cumulative clock extension timeout: in master mode, the master cumulative clock low extend time (tlow:mext) is detected in slave mode, the slave cumulative clock low extend time (tlow:sext) is detected tlow:ext= (TIMEOUTB+1) x 2048 x ti2cclk note: these bits can be written only when TEXTEN=0. */
    static const uint32_t I2Cx_TIMEOUTR_TEXTEN_MASK     = 0x80000000U;   /** @brief Extended clock timeout enable */
    static const uint32_t I2Cx_ISR_TXE_MASK             = 0x00000001U;   /** @brief Transmit data register empty (transmitters) this bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: this bit is set by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_TXIS_MASK            = 0x00000002U;   /** @brief Transmit interrupt status (transmitters) this bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_RXNE_MASK            = 0x00000004U;   /** @brief Receive data register not empty (receivers) this bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_ADDR_MASK            = 0x00000008U;   /** @brief Address matched (slave mode) this bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_NACKF_MASK           = 0x00000010U;   /** @brief Not acknowledge received flag this flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_STOPF_MASK           = 0x00000020U;   /** @brief Stop detection flag this flag is set by hardware when a stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. Or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_TC_MASK              = 0x00000040U;   /** @brief Transfer complete (master mode) this flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_TCR_MASK             = 0x00000080U;   /** @brief Transfer complete reload this flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: this bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set. */
    static const uint32_t I2Cx_ISR_BERR_MASK            = 0x00000100U;   /** @brief Bus error this flag is set by hardware when a misplaced start or stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_ARLO_MASK            = 0x00000200U;   /** @brief Arbitration lost this flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_OVR_MASK             = 0x00000400U;   /** @brief Overrun/Underrun (slave mode) this flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_ISR_PECERR_MASK          = 0x00000800U;   /** @brief PEC error in reception this flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_ISR_TIMEOUT_MASK         = 0x00001000U;   /** @brief Timeout or tlow detection flag this flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_ISR_ALERT_MASK           = 0x00002000U;   /** @brief SMBus alert this flag is set by hardware when SMBHEN=1 (smbus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_ISR_BUSY_MASK            = 0x00008000U;   /** @brief Bus busy this flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a stop condition is detected, or when PE=0. */
    static const uint32_t I2Cx_ISR_DIR_MASK             = 0x00010000U;   /** @brief Transfer direction (slave mode) this flag is updated when an address match event occurs (ADDR=1). */
    static const uint32_t I2Cx_ISR_ADDCODE_MASK         = 0x00FE0000U;   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
    static const uint32_t I2Cx_ICR_ADDRCF_MASK          = 0x00000008U;   /** @brief Address matched flag clear writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register. */
    static const uint32_t I2Cx_ICR_NACKCF_MASK          = 0x00000010U;   /** @brief Not acknowledge flag clear writing 1 to this bit clears the ACKF flag in I2C_ISR register. */
    static const uint32_t I2Cx_ICR_STOPCF_MASK          = 0x00000020U;   /** @brief Stop detection flag clear writing 1 to this bit clears the STOPF flag in the I2C_ISR register. */
    static const uint32_t I2Cx_ICR_BERRCF_MASK          = 0x00000100U;   /** @brief Bus error flag clear writing 1 to this bit clears the BERRF flag in the I2C_ISR register. */
    static const uint32_t I2Cx_ICR_ARLOCF_MASK          = 0x00000200U;   /** @brief Arbitration lost flag clear writing 1 to this bit clears the ARLO flag in the I2C_ISR register. */
    static const uint32_t I2Cx_ICR_OVRCF_MASK           = 0x00000400U;   /** @brief Overrun/Underrun flag clear writing 1 to this bit clears the OVR flag in the I2C_ISR register. */
    static const uint32_t I2Cx_ICR_PECCF_MASK           = 0x00000800U;   /** @brief PEC error flag clear writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_ICR_TIMOUTCF_MASK        = 0x00001000U;   /** @brief Timeout detection flag clear writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_ICR_ALERTCF_MASK         = 0x00002000U;   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2Cx_PECR_PEC_MASK            = 0x000000FFU;   /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
    static const uint32_t I2Cx_RXDR_RXDATA_MASK         = 0x000000FFU;   /** @brief 8-bit receive data data byte received from the I2C bus. */
    static const uint32_t I2Cx_TXDR_TXDATA_MASK         = 0x000000FFU;   /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */

    /**** @subsection Enumerated I2Cx Register Field Masks ****/

    static const uint32_t I2Cx_CR2_SADDx_MASK[10] = {
      [0]  = 0x00000001U,   /** @brief Slave address bit 0 (master mode) in 7-bit addressing mode (ADD10 = 0): this bit is dont care in 10-bit addressing mode (ADD10 = 1): this bit should be written with bit 0 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      [1]  = 0x00000002U,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [2]  = 0x00000004U,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [3]  = 0x00000008U,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [4]  = 0x00000010U,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [5]  = 0x00000020U,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [6]  = 0x00000040U,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [7]  = 0x00000080U,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [8]  = 0x00000100U,   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      [9]  = 0x00000200U,   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
    };

    /**** @subsection I2Cx Register Field Positions ****/

    static const int32_t I2Cx_CR1_PE_POS              = 0;    /** @brief Peripheral enable note: when PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles. */
    static const int32_t I2Cx_CR1_TXIE_POS            = 1;    /** @brief TX interrupt enable */
    static const int32_t I2Cx_CR1_RXIE_POS            = 2;    /** @brief RX interrupt enable */
    static const int32_t I2Cx_CR1_ADDRIE_POS          = 3;    /** @brief Address match interrupt enable (slave only) */
    static const int32_t I2Cx_CR1_NACKIE_POS          = 4;    /** @brief Not acknowledge received interrupt enable */
    static const int32_t I2Cx_CR1_STOPIE_POS          = 5;    /** @brief STOP detection interrupt enable */
    static const int32_t I2Cx_CR1_TCIE_POS            = 6;    /** @brief Transfer complete interrupt enable note: any of these events will generate an interrupt: transfer complete (TC) transfer complete reload (TCR) */
    static const int32_t I2Cx_CR1_ERRIE_POS           = 7;    /** @brief Error interrupts enable note: any of these errors generate an interrupt: arbitration loss (ARLO) bus error detection (BERR) overrun/underrun (OVR) timeout detection (TIMEOUT) PEC error detection (PECERR) alert pin event detection (ALERT) */
    static const int32_t I2Cx_CR1_DNF_POS             = 8;    /** @brief Digital noise filter these bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * ti2cclk ... Note: if the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). */
    static const int32_t I2Cx_CR1_ANFOFF_POS          = 12;   /** @brief Analog noise filter OFF note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const int32_t I2Cx_CR1_TXDMAEN_POS         = 14;   /** @brief DMA transmission requests enable */
    static const int32_t I2Cx_CR1_RXDMAEN_POS         = 15;   /** @brief DMA reception requests enable */
    static const int32_t I2Cx_CR1_SBC_POS             = 16;   /** @brief Slave byte control this bit is used to enable hardware byte control in slave mode. */
    static const int32_t I2Cx_CR1_NOSTRETCH_POS       = 17;   /** @brief Clock stretching disable this bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const int32_t I2Cx_CR1_WUPEN_POS           = 18;   /** @brief Wakeup from stop mode enable note: if the wakeup from stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000 */
    static const int32_t I2Cx_CR1_GCEN_POS            = 19;   /** @brief General call enable */
    static const int32_t I2Cx_CR1_SMBHEN_POS          = 20;   /** @brief SMBus host address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_CR1_SMBDEN_POS          = 21;   /** @brief SMBus device default address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_CR1_ALERTEN_POS         = 22;   /** @brief SMBus alert enable device mode (SMBHEN=0): host mode (SMBHEN=1): note: when ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_CR1_PECEN_POS           = 23;   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_CR2_RD_WRN_POS          = 10;   /** @brief Transfer direction (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const int32_t I2Cx_CR2_ADD10_POS           = 11;   /** @brief 10-bit addressing mode (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const int32_t I2Cx_CR2_HEAD10R_POS         = 12;   /** @brief 10-bit address header only read direction (master receiver mode) note: changing this bit when the START bit is set is not allowed. */
    static const int32_t I2Cx_CR2_START_POS           = 13;   /** @brief Start generation this bit is set by software, and cleared by hardware after the start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a repeated start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set. */
    static const int32_t I2Cx_CR2_STOP_POS            = 14;   /** @brief Stop generation (master mode) the bit is set by software, cleared by hardware when a stop condition is detected, or when PE = 0. In master mode: note: writing 0 to this bit has no effect. */
    static const int32_t I2Cx_CR2_NACK_POS            = 15;   /** @brief NACK generation (slave mode) the bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an address matched is received, or when PE=0. Note: writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value. */
    static const int32_t I2Cx_CR2_NBYTES_POS          = 16;   /** @brief Number of bytes the number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: changing these bits when the START bit is set is not allowed. */
    static const int32_t I2Cx_CR2_RELOAD_POS          = 24;   /** @brief NBYTES reload mode this bit is set and cleared by software. */
    static const int32_t I2Cx_CR2_AUTOEND_POS         = 25;   /** @brief Automatic end mode (master mode) this bit is set and cleared by software. Note: this bit has no effect in slave mode or when the RELOAD bit is set. */
    static const int32_t I2Cx_CR2_PECBYTE_POS         = 26;   /** @brief Packet error checking byte this bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an address matched is received, also when PE=0. Note: writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_OAR1_OA1_POS            = 0;    /** @brief Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address note: these bits can be written only when OA1EN=0. OA1[7:1]: interface address bits 7:1 of address note: these bits can be written only when OA1EN=0. OA1[0]: interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address note: this bit can be written only when OA1EN=0. */
    static const int32_t I2Cx_OAR1_OA1MODE_POS        = 10;   /** @brief Own address 1 10-bit mode note: this bit can be written only when OA1EN=0. */
    static const int32_t I2Cx_OAR1_OA1EN_POS          = 15;   /** @brief Own address 1 enable */
    static const int32_t I2Cx_OAR2_OA2_POS            = 1;    /** @brief Interface address bits 7:1 of address note: these bits can be written only when OA2EN=0. */
    static const int32_t I2Cx_OAR2_OA2MSK_POS         = 8;    /** @brief Own address 2 masks note: these bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. */
    static const int32_t I2Cx_OAR2_OA2EN_POS          = 15;   /** @brief Own address 2 enable */
    static const int32_t I2Cx_TIMINGR_SCLL_POS        = 0;    /** @brief SCL low period (master mode) this field is used to generate the SCL low period in master mode. TSCLL = (SCLL+1) x tpresc note: SCLL is also used to generate tbuf and tsu:sta timings. */
    static const int32_t I2Cx_TIMINGR_SCLH_POS        = 8;    /** @brief SCL high period (master mode) this field is used to generate the SCL high period in master mode. TSCLH = (SCLH+1) x tpresc note: SCLH is also used to generate tsu:sto and thd:sta timing. */
    static const int32_t I2Cx_TIMINGR_SDADEL_POS      = 16;   /** @brief Data hold time this field is used to generate the delay tsdadel between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsdadel. TSDADEL= SDADEL x tpresc note: SDADEL is used to generate thd:dat timing. */
    static const int32_t I2Cx_TIMINGR_SCLDEL_POS      = 20;   /** @brief Data setup time this field is used to generate a delay tscldel between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tscldel. TSCLDEL = (SCLDEL+1) x tpresc note: tscldel is used to generate tsu:dat timing. */
    static const int32_t I2Cx_TIMINGR_PRESC_POS       = 28;   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
    static const int32_t I2Cx_TIMEOUTR_TIMEOUTA_POS   = 0;    /** @brief Bus timeout A this field is used to configure: the SCL low timeout condition ttimeout when TIDLE=0 ttimeout= (TIMEOUTA+1) x 2048 x ti2cclk the bus idle condition (both SCL and SDA high) when TIDLE=1 tidle= (TIMEOUTA+1) x 4 x ti2cclk note: these bits can be written only when TIMOUTEN=0. */
    static const int32_t I2Cx_TIMEOUTR_TIDLE_POS      = 12;   /** @brief Idle clock timeout detection note: this bit can be written only when TIMOUTEN=0. */
    static const int32_t I2Cx_TIMEOUTR_TIMOUTEN_POS   = 15;   /** @brief Clock timeout enable */
    static const int32_t I2Cx_TIMEOUTR_TIMEOUTB_POS   = 16;   /** @brief Bus timeout B this field is used to configure the cumulative clock extension timeout: in master mode, the master cumulative clock low extend time (tlow:mext) is detected in slave mode, the slave cumulative clock low extend time (tlow:sext) is detected tlow:ext= (TIMEOUTB+1) x 2048 x ti2cclk note: these bits can be written only when TEXTEN=0. */
    static const int32_t I2Cx_TIMEOUTR_TEXTEN_POS     = 31;   /** @brief Extended clock timeout enable */
    static const int32_t I2Cx_ISR_TXE_POS             = 0;    /** @brief Transmit data register empty (transmitters) this bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: this bit is set by hardware when PE=0. */
    static const int32_t I2Cx_ISR_TXIS_POS            = 1;    /** @brief Transmit interrupt status (transmitters) this bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_RXNE_POS            = 2;    /** @brief Receive data register not empty (receivers) this bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_ADDR_POS            = 3;    /** @brief Address matched (slave mode) this bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_NACKF_POS           = 4;    /** @brief Not acknowledge received flag this flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_STOPF_POS           = 5;    /** @brief Stop detection flag this flag is set by hardware when a stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. Or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_TC_POS              = 6;    /** @brief Transfer complete (master mode) this flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_TCR_POS             = 7;    /** @brief Transfer complete reload this flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: this bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set. */
    static const int32_t I2Cx_ISR_BERR_POS            = 8;    /** @brief Bus error this flag is set by hardware when a misplaced start or stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_ARLO_POS            = 9;    /** @brief Arbitration lost this flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_OVR_POS             = 10;   /** @brief Overrun/Underrun (slave mode) this flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2Cx_ISR_PECERR_POS          = 11;   /** @brief PEC error in reception this flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_ISR_TIMEOUT_POS         = 12;   /** @brief Timeout or tlow detection flag this flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_ISR_ALERT_POS           = 13;   /** @brief SMBus alert this flag is set by hardware when SMBHEN=1 (smbus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_ISR_BUSY_POS            = 15;   /** @brief Bus busy this flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a stop condition is detected, or when PE=0. */
    static const int32_t I2Cx_ISR_DIR_POS             = 16;   /** @brief Transfer direction (slave mode) this flag is updated when an address match event occurs (ADDR=1). */
    static const int32_t I2Cx_ISR_ADDCODE_POS         = 17;   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
    static const int32_t I2Cx_ICR_ADDRCF_POS          = 3;    /** @brief Address matched flag clear writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register. */
    static const int32_t I2Cx_ICR_NACKCF_POS          = 4;    /** @brief Not acknowledge flag clear writing 1 to this bit clears the ACKF flag in I2C_ISR register. */
    static const int32_t I2Cx_ICR_STOPCF_POS          = 5;    /** @brief Stop detection flag clear writing 1 to this bit clears the STOPF flag in the I2C_ISR register. */
    static const int32_t I2Cx_ICR_BERRCF_POS          = 8;    /** @brief Bus error flag clear writing 1 to this bit clears the BERRF flag in the I2C_ISR register. */
    static const int32_t I2Cx_ICR_ARLOCF_POS          = 9;    /** @brief Arbitration lost flag clear writing 1 to this bit clears the ARLO flag in the I2C_ISR register. */
    static const int32_t I2Cx_ICR_OVRCF_POS           = 10;   /** @brief Overrun/Underrun flag clear writing 1 to this bit clears the OVR flag in the I2C_ISR register. */
    static const int32_t I2Cx_ICR_PECCF_POS           = 11;   /** @brief PEC error flag clear writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_ICR_TIMOUTCF_POS        = 12;   /** @brief Timeout detection flag clear writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_ICR_ALERTCF_POS         = 13;   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2Cx_PECR_PEC_POS            = 0;    /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
    static const int32_t I2Cx_RXDR_RXDATA_POS         = 0;    /** @brief 8-bit receive data data byte received from the I2C bus. */
    static const int32_t I2Cx_TXDR_TXDATA_POS         = 0;    /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */

    /**** @subsection Enumerated I2Cx Register Field Positions ****/

    static const int32_t I2Cx_CR2_SADDx_POS[10] = {
      [0]  = 0,   /** @brief Slave address bit 0 (master mode) in 7-bit addressing mode (ADD10 = 0): this bit is dont care in 10-bit addressing mode (ADD10 = 1): this bit should be written with bit 0 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      [1]  = 1,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [2]  = 2,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [3]  = 3,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [4]  = 4,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [5]  = 5,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [6]  = 6,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [7]  = 7,   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      [8]  = 8,   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      [9]  = 9,   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
    };

    /**********************************************************************************************
     * @section GPIOx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated GPIOx Register Pointers ****/

    static RW_ uint32_t* const GPIOx_MODER_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x58020000U,   /** @brief GPIO port mode register */
      [1]  = (RW_ uint32_t* const)0x58020400U,   /** @brief GPIO port mode register */
      [2]  = (RW_ uint32_t* const)0x58020800U,   /** @brief GPIO port mode register */
      [3]  = (RW_ uint32_t* const)0x58020C00U,   /** @brief GPIO port mode register */
      [4]  = (RW_ uint32_t* const)0x58021000U,   /** @brief GPIO port mode register */
      [5]  = (RW_ uint32_t* const)0x58021400U,   /** @brief GPIO port mode register */
      [6]  = (RW_ uint32_t* const)0x58021800U,   /** @brief GPIO port mode register */
      [7]  = (RW_ uint32_t* const)0x58021C00U,   /** @brief GPIO port mode register */
      [8]  = (RW_ uint32_t* const)0x58022000U,   /** @brief GPIO port mode register */
      [9]  = (RW_ uint32_t* const)0x58022400U,   /** @brief GPIO port mode register */
      [10] = (RW_ uint32_t* const)0x58022800U,   /** @brief GPIO port mode register */
    };

    static RW_ uint32_t* const GPIOx_OTYPER_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x58020004U,   /** @brief GPIO port output type register */
      [1]  = (RW_ uint32_t* const)0x58020404U,   /** @brief GPIO port output type register */
      [2]  = (RW_ uint32_t* const)0x58020804U,   /** @brief GPIO port output type register */
      [3]  = (RW_ uint32_t* const)0x58020C04U,   /** @brief GPIO port output type register */
      [4]  = (RW_ uint32_t* const)0x58021004U,   /** @brief GPIO port output type register */
      [5]  = (RW_ uint32_t* const)0x58021404U,   /** @brief GPIO port output type register */
      [6]  = (RW_ uint32_t* const)0x58021804U,   /** @brief GPIO port output type register */
      [7]  = (RW_ uint32_t* const)0x58021C04U,   /** @brief GPIO port output type register */
      [8]  = (RW_ uint32_t* const)0x58022004U,   /** @brief GPIO port output type register */
      [9]  = (RW_ uint32_t* const)0x58022404U,   /** @brief GPIO port output type register */
      [10] = (RW_ uint32_t* const)0x58022804U,   /** @brief GPIO port output type register */
    };

    static RW_ uint32_t* const GPIOx_OSPEEDR_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x58020008U,   /** @brief GPIO port output speed register */
      [1]  = (RW_ uint32_t* const)0x58020408U,   /** @brief GPIO port output speed register */
      [2]  = (RW_ uint32_t* const)0x58020808U,   /** @brief GPIO port output speed register */
      [3]  = (RW_ uint32_t* const)0x58020C08U,   /** @brief GPIO port output speed register */
      [4]  = (RW_ uint32_t* const)0x58021008U,   /** @brief GPIO port output speed register */
      [5]  = (RW_ uint32_t* const)0x58021408U,   /** @brief GPIO port output speed register */
      [6]  = (RW_ uint32_t* const)0x58021808U,   /** @brief GPIO port output speed register */
      [7]  = (RW_ uint32_t* const)0x58021C08U,   /** @brief GPIO port output speed register */
      [8]  = (RW_ uint32_t* const)0x58022008U,   /** @brief GPIO port output speed register */
      [9]  = (RW_ uint32_t* const)0x58022408U,   /** @brief GPIO port output speed register */
      [10] = (RW_ uint32_t* const)0x58022808U,   /** @brief GPIO port output speed register */
    };

    static RW_ uint32_t* const GPIOx_PUPDR_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x5802000CU,   /** @brief GPIO port pull-up/pull-down register */
      [1]  = (RW_ uint32_t* const)0x5802040CU,   /** @brief GPIO port pull-up/pull-down register */
      [2]  = (RW_ uint32_t* const)0x5802080CU,   /** @brief GPIO port pull-up/pull-down register */
      [3]  = (RW_ uint32_t* const)0x58020C0CU,   /** @brief GPIO port pull-up/pull-down register */
      [4]  = (RW_ uint32_t* const)0x5802100CU,   /** @brief GPIO port pull-up/pull-down register */
      [5]  = (RW_ uint32_t* const)0x5802140CU,   /** @brief GPIO port pull-up/pull-down register */
      [6]  = (RW_ uint32_t* const)0x5802180CU,   /** @brief GPIO port pull-up/pull-down register */
      [7]  = (RW_ uint32_t* const)0x58021C0CU,   /** @brief GPIO port pull-up/pull-down register */
      [8]  = (RW_ uint32_t* const)0x5802200CU,   /** @brief GPIO port pull-up/pull-down register */
      [9]  = (RW_ uint32_t* const)0x5802240CU,   /** @brief GPIO port pull-up/pull-down register */
      [10] = (RW_ uint32_t* const)0x5802280CU,   /** @brief GPIO port pull-up/pull-down register */
    };

    static RO_ uint32_t* const GPIOx_IDR_PTR[11] = {
      [0]  = (RO_ uint32_t* const)0x58020010U,   /** @brief GPIO port input data register */
      [1]  = (RO_ uint32_t* const)0x58020410U,   /** @brief GPIO port input data register */
      [2]  = (RO_ uint32_t* const)0x58020810U,   /** @brief GPIO port input data register */
      [3]  = (RO_ uint32_t* const)0x58020C10U,   /** @brief GPIO port input data register */
      [4]  = (RO_ uint32_t* const)0x58021010U,   /** @brief GPIO port input data register */
      [5]  = (RO_ uint32_t* const)0x58021410U,   /** @brief GPIO port input data register */
      [6]  = (RO_ uint32_t* const)0x58021810U,   /** @brief GPIO port input data register */
      [7]  = (RO_ uint32_t* const)0x58021C10U,   /** @brief GPIO port input data register */
      [8]  = (RO_ uint32_t* const)0x58022010U,   /** @brief GPIO port input data register */
      [9]  = (RO_ uint32_t* const)0x58022410U,   /** @brief GPIO port input data register */
      [10] = (RO_ uint32_t* const)0x58022810U,   /** @brief GPIO port input data register */
    };

    static RW_ uint32_t* const GPIOx_ODR_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x58020014U,   /** @brief GPIO port output data register */
      [1]  = (RW_ uint32_t* const)0x58020414U,   /** @brief GPIO port output data register */
      [2]  = (RW_ uint32_t* const)0x58020814U,   /** @brief GPIO port output data register */
      [3]  = (RW_ uint32_t* const)0x58020C14U,   /** @brief GPIO port output data register */
      [4]  = (RW_ uint32_t* const)0x58021014U,   /** @brief GPIO port output data register */
      [5]  = (RW_ uint32_t* const)0x58021414U,   /** @brief GPIO port output data register */
      [6]  = (RW_ uint32_t* const)0x58021814U,   /** @brief GPIO port output data register */
      [7]  = (RW_ uint32_t* const)0x58021C14U,   /** @brief GPIO port output data register */
      [8]  = (RW_ uint32_t* const)0x58022014U,   /** @brief GPIO port output data register */
      [9]  = (RW_ uint32_t* const)0x58022414U,   /** @brief GPIO port output data register */
      [10] = (RW_ uint32_t* const)0x58022814U,   /** @brief GPIO port output data register */
    };

    static RW_ uint32_t* const GPIOx_BSRR_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x58020018U,   /** @brief GPIO port bit set/reset register */
      [1]  = (RW_ uint32_t* const)0x58020418U,   /** @brief GPIO port bit set/reset register */
      [2]  = (RW_ uint32_t* const)0x58020818U,   /** @brief GPIO port bit set/reset register */
      [3]  = (RW_ uint32_t* const)0x58020C18U,   /** @brief GPIO port bit set/reset register */
      [4]  = (RW_ uint32_t* const)0x58021018U,   /** @brief GPIO port bit set/reset register */
      [5]  = (RW_ uint32_t* const)0x58021418U,   /** @brief GPIO port bit set/reset register */
      [6]  = (RW_ uint32_t* const)0x58021818U,   /** @brief GPIO port bit set/reset register */
      [7]  = (RW_ uint32_t* const)0x58021C18U,   /** @brief GPIO port bit set/reset register */
      [8]  = (RW_ uint32_t* const)0x58022018U,   /** @brief GPIO port bit set/reset register */
      [9]  = (RW_ uint32_t* const)0x58022418U,   /** @brief GPIO port bit set/reset register */
      [10] = (RW_ uint32_t* const)0x58022818U,   /** @brief GPIO port bit set/reset register */
    };

    static RW_ uint32_t* const GPIOx_LCKR_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x5802001CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [1]  = (RW_ uint32_t* const)0x5802041CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [2]  = (RW_ uint32_t* const)0x5802081CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [3]  = (RW_ uint32_t* const)0x58020C1CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [4]  = (RW_ uint32_t* const)0x5802101CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [5]  = (RW_ uint32_t* const)0x5802141CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [6]  = (RW_ uint32_t* const)0x5802181CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [7]  = (RW_ uint32_t* const)0x58021C1CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [8]  = (RW_ uint32_t* const)0x5802201CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [9]  = (RW_ uint32_t* const)0x5802241CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      [10] = (RW_ uint32_t* const)0x5802281CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    };

    static RW_ uint32_t* const GPIOx_AFRL_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x58020020U,   /** @brief GPIO alternate function low register */
      [1]  = (RW_ uint32_t* const)0x58020420U,   /** @brief GPIO alternate function low register */
      [2]  = (RW_ uint32_t* const)0x58020820U,   /** @brief GPIO alternate function low register */
      [3]  = (RW_ uint32_t* const)0x58020C20U,   /** @brief GPIO alternate function low register */
      [4]  = (RW_ uint32_t* const)0x58021020U,   /** @brief GPIO alternate function low register */
      [5]  = (RW_ uint32_t* const)0x58021420U,   /** @brief GPIO alternate function low register */
      [6]  = (RW_ uint32_t* const)0x58021820U,   /** @brief GPIO alternate function low register */
      [7]  = (RW_ uint32_t* const)0x58021C20U,   /** @brief GPIO alternate function low register */
      [8]  = (RW_ uint32_t* const)0x58022020U,   /** @brief GPIO alternate function low register */
      [9]  = (RW_ uint32_t* const)0x58022420U,   /** @brief GPIO alternate function low register */
      [10] = (RW_ uint32_t* const)0x58022820U,   /** @brief GPIO alternate function low register */
    };

    static RW_ uint32_t* const GPIOx_AFRH_PTR[11] = {
      [0]  = (RW_ uint32_t* const)0x58020024U,   /** @brief GPIO alternate function high register */
      [1]  = (RW_ uint32_t* const)0x58020424U,   /** @brief GPIO alternate function high register */
      [2]  = (RW_ uint32_t* const)0x58020824U,   /** @brief GPIO alternate function high register */
      [3]  = (RW_ uint32_t* const)0x58020C24U,   /** @brief GPIO alternate function high register */
      [4]  = (RW_ uint32_t* const)0x58021024U,   /** @brief GPIO alternate function high register */
      [5]  = (RW_ uint32_t* const)0x58021424U,   /** @brief GPIO alternate function high register */
      [6]  = (RW_ uint32_t* const)0x58021824U,   /** @brief GPIO alternate function high register */
      [7]  = (RW_ uint32_t* const)0x58021C24U,   /** @brief GPIO alternate function high register */
      [8]  = (RW_ uint32_t* const)0x58022024U,   /** @brief GPIO alternate function high register */
      [9]  = (RW_ uint32_t* const)0x58022424U,   /** @brief GPIO alternate function high register */
      [10] = (RW_ uint32_t* const)0x58022824U,   /** @brief GPIO alternate function high register */
    };

    /**** @subsection Enumerated GPIOx Register Reset Values ****/

    static const uint32_t GPIOx_MODER_RST[11] = {
      [0]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [1]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [2]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [3]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [4]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [5]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [6]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [7]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [8]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [9]  = 0xABFFFFFFU,   /** @brief MODER register reset value */
      [10] = 0xABFFFFFFU,   /** @brief MODER register reset value */
    };

    static const uint32_t GPIOx_OTYPER_RST[11] = {
      [0]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [1]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [2]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [3]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [4]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [5]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [6]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [7]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [8]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [9]  = 0x00000000U,   /** @brief OTYPER register reset value */
      [10] = 0x00000000U,   /** @brief OTYPER register reset value */
    };

    static const uint32_t GPIOx_OSPEEDR_RST[11] = {
      [0]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [1]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [2]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [3]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [4]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [5]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [6]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [7]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [8]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [9]  = 0x0C000000U,   /** @brief OSPEEDR register reset value */
      [10] = 0x0C000000U,   /** @brief OSPEEDR register reset value */
    };

    static const uint32_t GPIOx_PUPDR_RST[11] = {
      [0]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [1]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [2]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [3]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [4]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [5]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [6]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [7]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [8]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [9]  = 0x12100000U,   /** @brief PUPDR register reset value */
      [10] = 0x12100000U,   /** @brief PUPDR register reset value */
    };

    static const uint32_t GPIOx_IDR_RST[11] = {
      [0]  = 0x00000000U,   /** @brief IDR register reset value */
      [1]  = 0x00000000U,   /** @brief IDR register reset value */
      [2]  = 0x00000000U,   /** @brief IDR register reset value */
      [3]  = 0x00000000U,   /** @brief IDR register reset value */
      [4]  = 0x00000000U,   /** @brief IDR register reset value */
      [5]  = 0x00000000U,   /** @brief IDR register reset value */
      [6]  = 0x00000000U,   /** @brief IDR register reset value */
      [7]  = 0x00000000U,   /** @brief IDR register reset value */
      [8]  = 0x00000000U,   /** @brief IDR register reset value */
      [9]  = 0x00000000U,   /** @brief IDR register reset value */
      [10] = 0x00000000U,   /** @brief IDR register reset value */
    };

    static const uint32_t GPIOx_ODR_RST[11] = {
      [0]  = 0x00000000U,   /** @brief ODR register reset value */
      [1]  = 0x00000000U,   /** @brief ODR register reset value */
      [2]  = 0x00000000U,   /** @brief ODR register reset value */
      [3]  = 0x00000000U,   /** @brief ODR register reset value */
      [4]  = 0x00000000U,   /** @brief ODR register reset value */
      [5]  = 0x00000000U,   /** @brief ODR register reset value */
      [6]  = 0x00000000U,   /** @brief ODR register reset value */
      [7]  = 0x00000000U,   /** @brief ODR register reset value */
      [8]  = 0x00000000U,   /** @brief ODR register reset value */
      [9]  = 0x00000000U,   /** @brief ODR register reset value */
      [10] = 0x00000000U,   /** @brief ODR register reset value */
    };

    static const uint32_t GPIOx_BSRR_RST[11] = {
      [0]  = 0x00000000U,   /** @brief BSRR register reset value */
      [1]  = 0x00000000U,   /** @brief BSRR register reset value */
      [2]  = 0x00000000U,   /** @brief BSRR register reset value */
      [3]  = 0x00000000U,   /** @brief BSRR register reset value */
      [4]  = 0x00000000U,   /** @brief BSRR register reset value */
      [5]  = 0x00000000U,   /** @brief BSRR register reset value */
      [6]  = 0x00000000U,   /** @brief BSRR register reset value */
      [7]  = 0x00000000U,   /** @brief BSRR register reset value */
      [8]  = 0x00000000U,   /** @brief BSRR register reset value */
      [9]  = 0x00000000U,   /** @brief BSRR register reset value */
      [10] = 0x00000000U,   /** @brief BSRR register reset value */
    };

    static const uint32_t GPIOx_LCKR_RST[11] = {
      [0]  = 0x00000000U,   /** @brief LCKR register reset value */
      [1]  = 0x00000000U,   /** @brief LCKR register reset value */
      [2]  = 0x00000000U,   /** @brief LCKR register reset value */
      [3]  = 0x00000000U,   /** @brief LCKR register reset value */
      [4]  = 0x00000000U,   /** @brief LCKR register reset value */
      [5]  = 0x00000000U,   /** @brief LCKR register reset value */
      [6]  = 0x00000000U,   /** @brief LCKR register reset value */
      [7]  = 0x00000000U,   /** @brief LCKR register reset value */
      [8]  = 0x00000000U,   /** @brief LCKR register reset value */
      [9]  = 0x00000000U,   /** @brief LCKR register reset value */
      [10] = 0x00000000U,   /** @brief LCKR register reset value */
    };

    static const uint32_t GPIOx_AFRL_RST[11] = {
      [0]  = 0x00000000U,   /** @brief AFRL register reset value */
      [1]  = 0x00000000U,   /** @brief AFRL register reset value */
      [2]  = 0x00000000U,   /** @brief AFRL register reset value */
      [3]  = 0x00000000U,   /** @brief AFRL register reset value */
      [4]  = 0x00000000U,   /** @brief AFRL register reset value */
      [5]  = 0x00000000U,   /** @brief AFRL register reset value */
      [6]  = 0x00000000U,   /** @brief AFRL register reset value */
      [7]  = 0x00000000U,   /** @brief AFRL register reset value */
      [8]  = 0x00000000U,   /** @brief AFRL register reset value */
      [9]  = 0x00000000U,   /** @brief AFRL register reset value */
      [10] = 0x00000000U,   /** @brief AFRL register reset value */
    };

    static const uint32_t GPIOx_AFRH_RST[11] = {
      [0]  = 0x00000000U,   /** @brief AFRH register reset value */
      [1]  = 0x00000000U,   /** @brief AFRH register reset value */
      [2]  = 0x00000000U,   /** @brief AFRH register reset value */
      [3]  = 0x00000000U,   /** @brief AFRH register reset value */
      [4]  = 0x00000000U,   /** @brief AFRH register reset value */
      [5]  = 0x00000000U,   /** @brief AFRH register reset value */
      [6]  = 0x00000000U,   /** @brief AFRH register reset value */
      [7]  = 0x00000000U,   /** @brief AFRH register reset value */
      [8]  = 0x00000000U,   /** @brief AFRH register reset value */
      [9]  = 0x00000000U,   /** @brief AFRH register reset value */
      [10] = 0x00000000U,   /** @brief AFRH register reset value */
    };

    /**** @subsection Enumerated GPIOx Register Value Types ****/

    typedef uint32_t GPIOx_MODER_t;     /** @brief MODER register value type. */
    typedef uint32_t GPIOx_OTYPER_t;    /** @brief OTYPER register value type. */
    typedef uint32_t GPIOx_OSPEEDR_t;   /** @brief OSPEEDR register value type. */
    typedef uint32_t GPIOx_PUPDR_t;     /** @brief PUPDR register value type. */
    typedef uint32_t GPIOx_IDR_t;       /** @brief IDR register value type. */
    typedef uint32_t GPIOx_ODR_t;       /** @brief ODR register value type. */
    typedef uint32_t GPIOx_BSRR_t;      /** @brief BSRR register value type. */
    typedef uint32_t GPIOx_LCKR_t;      /** @brief LCKR register value type. */
    typedef uint32_t GPIOx_AFRL_t;      /** @brief AFRL register value type. */
    typedef uint32_t GPIOx_AFRH_t;      /** @brief AFRH register value type. */

    /**** @subsection Enumerated GPIOx Register Pointer Types ****/

    typedef uint32_t* const GPIOx_MODER_PTR_t;     /** @brief MODER register pointer type. */
    typedef uint32_t* const GPIOx_OTYPER_PTR_t;    /** @brief OTYPER register pointer type. */
    typedef uint32_t* const GPIOx_OSPEEDR_PTR_t;   /** @brief OSPEEDR register pointer type. */
    typedef uint32_t* const GPIOx_PUPDR_PTR_t;     /** @brief PUPDR register pointer type. */
    typedef uint32_t* const GPIOx_IDR_PTR_t;       /** @brief IDR register pointer type. */
    typedef uint32_t* const GPIOx_ODR_PTR_t;       /** @brief ODR register pointer type. */
    typedef uint32_t* const GPIOx_BSRR_PTR_t;      /** @brief BSRR register pointer type. */
    typedef uint32_t* const GPIOx_LCKR_PTR_t;      /** @brief LCKR register pointer type. */
    typedef uint32_t* const GPIOx_AFRL_PTR_t;      /** @brief AFRL register pointer type. */
    typedef uint32_t* const GPIOx_AFRH_PTR_t;      /** @brief AFRH register pointer type. */

    /**** @subsection GPIOx Register Field Masks ****/

    static const uint32_t GPIOx_LCKR_LCKK_MASK   = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    /**** @subsection Enumerated GPIOx Register Field Masks ****/

    static const uint32_t GPIOx_MODER_MODEx_MASK[16] = {
      [0]  = 0x00000003U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOx_OTYPER_OTx_MASK[16] = {
      [0]  = 0x00000001U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOx_OSPEEDR_OSPEEDx_MASK[16] = {
      [0]  = 0x00000003U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOx_PUPDR_PUPDx_MASK[16] = {
      [0]  = 0x00000003U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOx_IDR_IDx_MASK[16] = {
      [0]  = 0x00000001U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOx_ODR_ODx_MASK[16] = {
      [0]  = 0x00000001U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOx_BSRR_BSx_MASK[16] = {
      [0]  = 0x00000001U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [1]  = 0x00000002U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [2]  = 0x00000004U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [3]  = 0x00000008U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [4]  = 0x00000010U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [5]  = 0x00000020U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [6]  = 0x00000040U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [7]  = 0x00000080U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [8]  = 0x00000100U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [9]  = 0x00000200U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [10] = 0x00000400U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [11] = 0x00000800U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [12] = 0x00001000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [13] = 0x00002000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [14] = 0x00004000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [15] = 0x00008000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    };

    static const uint32_t GPIOx_BSRR_BRx_MASK[16] = {
      [0]  = 0x00010000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOx_LCKR_LCKx_MASK[16] = {
      [0]  = 0x00000001U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [1]  = 0x00000002U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [2]  = 0x00000004U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [3]  = 0x00000008U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [4]  = 0x00000010U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [5]  = 0x00000020U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [6]  = 0x00000040U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [7]  = 0x00000080U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [8]  = 0x00000100U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [9]  = 0x00000200U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [10] = 0x00000400U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [11] = 0x00000800U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [12] = 0x00001000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [13] = 0x00002000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [14] = 0x00004000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [15] = 0x00008000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    };

    static const uint32_t GPIOx_AFRL_AFSELx_MASK[8] = {
      [0] = 0x0000000FU,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    /**** @subsection GPIOx Register Field Positions ****/

    static const int32_t GPIOx_LCKR_LCKK_POS   = 16;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    /**** @subsection Enumerated GPIOx Register Field Positions ****/

    static const int32_t GPIOx_MODER_MODEx_POS[16] = {
      [0]  = 0,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [1]  = 2,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 4,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 6,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 8,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 10,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 12,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 14,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 16,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 18,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 20,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 22,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 24,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 26,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 28,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 30,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const int32_t GPIOx_OTYPER_OTx_POS[16] = {
      [0]  = 0,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [1]  = 1,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 2,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 3,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 4,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 5,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 6,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 7,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 8,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 9,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 10,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 11,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 12,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 13,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 14,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 15,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const int32_t GPIOx_OSPEEDR_OSPEEDx_POS[16] = {
      [0]  = 0,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [1]  = 2,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 4,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 6,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 8,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 10,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 12,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 14,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 16,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 18,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 20,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 22,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 24,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 26,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 28,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 30,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const int32_t GPIOx_PUPDR_PUPDx_POS[16] = {
      [0]  = 0,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [1]  = 2,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 4,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 6,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 8,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 10,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 12,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 14,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 16,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 18,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 20,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 22,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 24,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 26,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 28,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 30,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const int32_t GPIOx_IDR_IDx_POS[16] = {
      [0]  = 0,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [1]  = 1,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 2,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 3,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 4,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 5,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 6,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 7,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 8,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 9,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 10,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 11,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 12,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 13,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 14,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 15,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const int32_t GPIOx_ODR_ODx_POS[16] = {
      [0]  = 0,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [1]  = 1,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 2,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 3,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 4,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 5,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 6,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 7,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 8,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 9,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 10,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 11,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 12,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 13,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 14,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 15,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const int32_t GPIOx_BSRR_BSx_POS[16] = {
      [0]  = 0,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [1]  = 1,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [2]  = 2,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [3]  = 3,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [4]  = 4,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [5]  = 5,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [6]  = 6,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [7]  = 7,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [8]  = 8,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [9]  = 9,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [10] = 10,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [11] = 11,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [12] = 12,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [13] = 13,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [14] = 14,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      [15] = 15,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    };

    static const int32_t GPIOx_BSRR_BRx_POS[16] = {
      [0]  = 16,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [1]  = 17,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 18,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 19,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 20,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 21,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 22,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 23,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 24,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 25,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 26,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 27,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 28,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 29,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 30,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 31,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const int32_t GPIOx_LCKR_LCKx_POS[16] = {
      [0]  = 0,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [1]  = 1,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [2]  = 2,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [3]  = 3,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [4]  = 4,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [5]  = 5,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [6]  = 6,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [7]  = 7,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [8]  = 8,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [9]  = 9,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [10] = 10,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [11] = 11,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [12] = 12,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [13] = 13,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [14] = 14,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      [15] = 15,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    };

    static const int32_t GPIOx_AFRL_AFSELx_POS[8] = {
      [0] = 0,    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [1] = 4,    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 8,    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 12,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 16,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 20,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 24,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 28,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    /**********************************************************************************************
     * @section JPEG Register Information
     **********************************************************************************************/

    /**** @subsection JPEG Register Pointers ****/

    static RW_ uint32_t* const JPEG_CONFR0_PTR   = (RW_ uint32_t* const)0x52003000U;   /** @brief JPEG codec control register */
    static RW_ uint32_t* const JPEG_CONFR1_PTR   = (RW_ uint32_t* const)0x52003004U;   /** @brief JPEG codec configuration register 1 */
    static RW_ uint32_t* const JPEG_CONFR2_PTR   = (RW_ uint32_t* const)0x52003008U;   /** @brief JPEG codec configuration register 2 */
    static RW_ uint32_t* const JPEG_CONFR3_PTR   = (RW_ uint32_t* const)0x5200300CU;   /** @brief JPEG codec configuration register 3 */
    static RW_ uint32_t* const JPEG_CR_PTR       = (RW_ uint32_t* const)0x52003030U;   /** @brief JPEG control register */
    static RO_ uint32_t* const JPEG_SR_PTR       = (RO_ uint32_t* const)0x52003034U;   /** @brief JPEG status register */
    static RW_ uint32_t* const JPEG_CFR_PTR      = (RW_ uint32_t* const)0x52003038U;   /** @brief JPEG clear flag register */
    static RW_ uint32_t* const JPEG_DIR_PTR      = (RW_ uint32_t* const)0x52003040U;   /** @brief JPEG data input register */
    static RO_ uint32_t* const JPEG_DOR_PTR      = (RO_ uint32_t* const)0x52003044U;   /** @brief JPEG data output register */

    /**** @subsection Enumerated JPEG Register Pointers ****/

    static RW_ uint32_t* const JPEG_CONFRNx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x52003010U,   /** @brief JPEG codec configuration register 4-7 */
      [2] = (RW_ uint32_t* const)0x52003014U,   /** @brief JPEG codec configuration register 4-7 */
      [3] = (RW_ uint32_t* const)0x52003018U,   /** @brief JPEG codec configuration register 4-7 */
      [4] = (RW_ uint32_t* const)0x5200301CU,   /** @brief JPEG codec configuration register 4-7 */
    };

    /**** @subsection JPEG Register Reset Values ****/

    static const uint32_t JPEG_CONFR0_RST   = 0x00000000U;   /** @brief CONFR0 register reset value. */
    static const uint32_t JPEG_CONFR1_RST   = 0x00000000U;   /** @brief CONFR1 register reset value. */
    static const uint32_t JPEG_CONFR2_RST   = 0x00000000U;   /** @brief CONFR2 register reset value. */
    static const uint32_t JPEG_CONFR3_RST   = 0x00000000U;   /** @brief CONFR3 register reset value. */
    static const uint32_t JPEG_CR_RST       = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t JPEG_SR_RST       = 0x00000006U;   /** @brief SR register reset value. */
    static const uint32_t JPEG_CFR_RST      = 0x00000000U;   /** @brief CFR register reset value. */
    static const uint32_t JPEG_DIR_RST      = 0x00000000U;   /** @brief DIR register reset value. */
    static const uint32_t JPEG_DOR_RST      = 0x00000000U;   /** @brief DOR register reset value. */

    /**** @subsection Enumerated JPEG Register Reset Values ****/

    static const uint32_t JPEG_CONFRNx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CONFRN1 register reset value. */
      [2] = 0x00000000U,   /** @brief CONFRN2 register reset value. */
      [3] = 0x00000000U,   /** @brief CONFRN3 register reset value. */
      [4] = 0x00000000U,   /** @brief CONFRN4 register reset value. */
    };

    /**** @subsection Enumerated JPEG Register Value Types ****/

    typedef uint32_t JPEG_CONFR0_t;    /** @brief CONFR0 register value type. */
    typedef uint32_t JPEG_CONFR1_t;    /** @brief CONFR1 register value type. */
    typedef uint32_t JPEG_CONFR2_t;    /** @brief CONFR2 register value type. */
    typedef uint32_t JPEG_CONFR3_t;    /** @brief CONFR3 register value type. */
    typedef uint32_t JPEG_CONFRNx_t;   /** @brief CONFRNx register value type. */
    typedef uint32_t JPEG_CR_t;        /** @brief CR register value type. */
    typedef uint32_t JPEG_SR_t;        /** @brief SR register value type. */
    typedef uint32_t JPEG_CFR_t;       /** @brief CFR register value type. */
    typedef uint32_t JPEG_DIR_t;       /** @brief DIR register value type. */
    typedef uint32_t JPEG_DOR_t;       /** @brief DOR register value type. */

    /**** @subsection Enumerated JPEG Register Pointer Types ****/

    typedef uint32_t* const JPEG_CONFR0_PTR_t;    /** @brief CONFR0 register pointer type. */
    typedef uint32_t* const JPEG_CONFR1_PTR_t;    /** @brief CONFR1 register pointer type. */
    typedef uint32_t* const JPEG_CONFR2_PTR_t;    /** @brief CONFR2 register pointer type. */
    typedef uint32_t* const JPEG_CONFR3_PTR_t;    /** @brief CONFR3 register pointer type. */
    typedef uint32_t* const JPEG_CONFRNx_PTR_t;   /** @brief CONFRNx register pointer type. */
    typedef uint32_t* const JPEG_CR_PTR_t;        /** @brief CR register pointer type. */
    typedef uint32_t* const JPEG_SR_PTR_t;        /** @brief SR register pointer type. */
    typedef uint32_t* const JPEG_CFR_PTR_t;       /** @brief CFR register pointer type. */
    typedef uint32_t* const JPEG_DIR_PTR_t;       /** @brief DIR register pointer type. */
    typedef uint32_t* const JPEG_DOR_PTR_t;       /** @brief DOR register pointer type. */

    /**** @subsection JPEG Register Field Masks ****/

    static const uint32_t JPEG_CONFR0_START_MASK        = 0x00000001U;   /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
    static const uint32_t JPEG_CONFR1_NF_MASK           = 0x00000003U;   /** @brief Number of color components this field defines the number of color components minus 1. */
    static const uint32_t JPEG_CONFR1_DE_MASK           = 0x00000008U;   /** @brief Decoding enable this bit selects the coding or decoding process */
    static const uint32_t JPEG_CONFR1_COLORSPACE_MASK   = 0x00000030U;   /** @brief Color space this filed defines the number of quantization tables minus 1 to insert in the output stream. */
    static const uint32_t JPEG_CONFR1_NS_MASK           = 0x000000C0U;   /** @brief Number of components for scan this field defines the number of components minus 1 for scan header marker segment. */
    static const uint32_t JPEG_CONFR1_HDR_MASK          = 0x00000100U;   /** @brief Header processing this bit enable the header processing (generation/parsing). */
    static const uint32_t JPEG_CONFR1_YSIZE_MASK        = 0xFFFF0000U;   /** @brief Y size this field defines the number of lines in source image. */
    static const uint32_t JPEG_CONFR2_NMCU_MASK         = 0x03FFFFFFU;   /** @brief Number of MCU for encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated. */
    static const uint32_t JPEG_CONFR3_XSIZE_MASK        = 0xFFFF0000U;   /** @brief X size this field defines the number of pixels per line. */
    static const uint32_t JPEG_CONFRNx_HD_MASK          = 0x00000001U;   /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const uint32_t JPEG_CONFRNx_HA_MASK          = 0x00000002U;   /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const uint32_t JPEG_CONFRNx_QT_MASK          = 0x0000000CU;   /** @brief Quantization table selects quantization table associated with a color component. */
    static const uint32_t JPEG_CONFRNx_NB_MASK          = 0x000000F0U;   /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const uint32_t JPEG_CONFRNx_VSF_MASK         = 0x00000F00U;   /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const uint32_t JPEG_CONFRNx_HSF_MASK         = 0x0000F000U;   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const uint32_t JPEG_CR_JCEN_MASK             = 0x00000001U;   /** @brief JPEG core enable enable the JPEG codec core. */
    static const uint32_t JPEG_CR_IFTIE_MASK            = 0x00000002U;   /** @brief Input FIFO threshold interrupt enable this bit enables the interrupt generation when input FIFO reach the threshold. */
    static const uint32_t JPEG_CR_IFNFIE_MASK           = 0x00000004U;   /** @brief Input FIFO not full interrupt enable this bit enables the interrupt generation when input FIFO is not empty. */
    static const uint32_t JPEG_CR_OFTIE_MASK            = 0x00000008U;   /** @brief Output FIFO threshold interrupt enable this bit enables the interrupt generation when output FIFO reach the threshold. */
    static const uint32_t JPEG_CR_OFNEIE_MASK           = 0x00000010U;   /** @brief Output FIFO not empty interrupt enable this bit enables the interrupt generation when output FIFO is not empty. */
    static const uint32_t JPEG_CR_EOCIE_MASK            = 0x00000020U;   /** @brief End of conversion interrupt enable this bit enables the interrupt generation on the end of conversion. */
    static const uint32_t JPEG_CR_HPDIE_MASK            = 0x00000040U;   /** @brief Header parsing done interrupt enable this bit enables the interrupt generation on the header parsing operation. */
    static const uint32_t JPEG_CR_IDMAEN_MASK           = 0x00000800U;   /** @brief Input DMA enable enable the DMA request generation for the input FIFO. */
    static const uint32_t JPEG_CR_ODMAEN_MASK           = 0x00001000U;   /** @brief Output DMA enable enable the DMA request generation for the output FIFO. */
    static const uint32_t JPEG_CR_IFF_MASK              = 0x00002000U;   /** @brief Input FIFO flush this bit flush the input FIFO. This bit is always read as 0. */
    static const uint32_t JPEG_CR_OFF_MASK              = 0x00004000U;   /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
    static const uint32_t JPEG_SR_IFTF_MASK             = 0x00000002U;   /** @brief Input FIFO threshold flag this bit is set when the input FIFO is not full and is bellow its threshold. */
    static const uint32_t JPEG_SR_IFNFF_MASK            = 0x00000004U;   /** @brief Input FIFO not full flag this bit is set when the input FIFO is not full (a data can be written). */
    static const uint32_t JPEG_SR_OFTF_MASK             = 0x00000008U;   /** @brief Output FIFO threshold flag this bit is set when the output FIFO is not empty and has reach its threshold. */
    static const uint32_t JPEG_SR_OFNEF_MASK            = 0x00000010U;   /** @brief Output FIFO not empty flag this bit is set when the output FIFO is not empty (a data is available). */
    static const uint32_t JPEG_SR_EOCF_MASK             = 0x00000020U;   /** @brief End of conversion flag this bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO. */
    static const uint32_t JPEG_SR_HPDF_MASK             = 0x00000040U;   /** @brief Header parsing done flag this bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated. */
    static const uint32_t JPEG_SR_COF_MASK              = 0x00000080U;   /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
    static const uint32_t JPEG_CFR_CEOCF_MASK           = 0x00000020U;   /** @brief Clear end of conversion flag writing 1 clears the end of conversion flag of the JPEG status register. */
    static const uint32_t JPEG_CFR_CHPDF_MASK           = 0x00000040U;   /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */

    /**** @subsection JPEG Register Field Positions ****/

    static const int32_t JPEG_CONFR0_START_POS        = 0;    /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
    static const int32_t JPEG_CONFR1_NF_POS           = 0;    /** @brief Number of color components this field defines the number of color components minus 1. */
    static const int32_t JPEG_CONFR1_DE_POS           = 3;    /** @brief Decoding enable this bit selects the coding or decoding process */
    static const int32_t JPEG_CONFR1_COLORSPACE_POS   = 4;    /** @brief Color space this filed defines the number of quantization tables minus 1 to insert in the output stream. */
    static const int32_t JPEG_CONFR1_NS_POS           = 6;    /** @brief Number of components for scan this field defines the number of components minus 1 for scan header marker segment. */
    static const int32_t JPEG_CONFR1_HDR_POS          = 8;    /** @brief Header processing this bit enable the header processing (generation/parsing). */
    static const int32_t JPEG_CONFR1_YSIZE_POS        = 16;   /** @brief Y size this field defines the number of lines in source image. */
    static const int32_t JPEG_CONFR2_NMCU_POS         = 0;    /** @brief Number of MCU for encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated. */
    static const int32_t JPEG_CONFR3_XSIZE_POS        = 16;   /** @brief X size this field defines the number of pixels per line. */
    static const int32_t JPEG_CONFRNx_HD_POS          = 0;    /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const int32_t JPEG_CONFRNx_HA_POS          = 1;    /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const int32_t JPEG_CONFRNx_QT_POS          = 2;    /** @brief Quantization table selects quantization table associated with a color component. */
    static const int32_t JPEG_CONFRNx_NB_POS          = 4;    /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const int32_t JPEG_CONFRNx_VSF_POS         = 8;    /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const int32_t JPEG_CONFRNx_HSF_POS         = 12;   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const int32_t JPEG_CR_JCEN_POS             = 0;    /** @brief JPEG core enable enable the JPEG codec core. */
    static const int32_t JPEG_CR_IFTIE_POS            = 1;    /** @brief Input FIFO threshold interrupt enable this bit enables the interrupt generation when input FIFO reach the threshold. */
    static const int32_t JPEG_CR_IFNFIE_POS           = 2;    /** @brief Input FIFO not full interrupt enable this bit enables the interrupt generation when input FIFO is not empty. */
    static const int32_t JPEG_CR_OFTIE_POS            = 3;    /** @brief Output FIFO threshold interrupt enable this bit enables the interrupt generation when output FIFO reach the threshold. */
    static const int32_t JPEG_CR_OFNEIE_POS           = 4;    /** @brief Output FIFO not empty interrupt enable this bit enables the interrupt generation when output FIFO is not empty. */
    static const int32_t JPEG_CR_EOCIE_POS            = 5;    /** @brief End of conversion interrupt enable this bit enables the interrupt generation on the end of conversion. */
    static const int32_t JPEG_CR_HPDIE_POS            = 6;    /** @brief Header parsing done interrupt enable this bit enables the interrupt generation on the header parsing operation. */
    static const int32_t JPEG_CR_IDMAEN_POS           = 11;   /** @brief Input DMA enable enable the DMA request generation for the input FIFO. */
    static const int32_t JPEG_CR_ODMAEN_POS           = 12;   /** @brief Output DMA enable enable the DMA request generation for the output FIFO. */
    static const int32_t JPEG_CR_IFF_POS              = 13;   /** @brief Input FIFO flush this bit flush the input FIFO. This bit is always read as 0. */
    static const int32_t JPEG_CR_OFF_POS              = 14;   /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
    static const int32_t JPEG_SR_IFTF_POS             = 1;    /** @brief Input FIFO threshold flag this bit is set when the input FIFO is not full and is bellow its threshold. */
    static const int32_t JPEG_SR_IFNFF_POS            = 2;    /** @brief Input FIFO not full flag this bit is set when the input FIFO is not full (a data can be written). */
    static const int32_t JPEG_SR_OFTF_POS             = 3;    /** @brief Output FIFO threshold flag this bit is set when the output FIFO is not empty and has reach its threshold. */
    static const int32_t JPEG_SR_OFNEF_POS            = 4;    /** @brief Output FIFO not empty flag this bit is set when the output FIFO is not empty (a data is available). */
    static const int32_t JPEG_SR_EOCF_POS             = 5;    /** @brief End of conversion flag this bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO. */
    static const int32_t JPEG_SR_HPDF_POS             = 6;    /** @brief Header parsing done flag this bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated. */
    static const int32_t JPEG_SR_COF_POS              = 7;    /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
    static const int32_t JPEG_CFR_CEOCF_POS           = 5;    /** @brief Clear end of conversion flag writing 1 clears the end of conversion flag of the JPEG status register. */
    static const int32_t JPEG_CFR_CHPDF_POS           = 6;    /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */

    /**********************************************************************************************
     * @section MDMA Register Information
     **********************************************************************************************/

    /**** @subsection MDMA Register Pointers ****/

    static RO_ uint32_t* const MDMA_MDMA_GISR0_PTR   = (RO_ uint32_t* const)0x52000000U;   /** @brief MDMA global interrupt/status register */

    /**** @subsection Enumerated MDMA Register Pointers ****/

    static RO_ uint32_t* const MDMA_MDMA_CxISR_PTR[16] = {
      [0]  = (RO_ uint32_t* const)0x52000040U,   /** @brief MDMA channel x interrupt/status register */
      [1]  = (RO_ uint32_t* const)0x52000080U,   /** @brief MDMA channel x interrupt/status register */
      [2]  = (RO_ uint32_t* const)0x520000C0U,   /** @brief MDMA channel x interrupt/status register */
      [3]  = (RO_ uint32_t* const)0x52000100U,   /** @brief MDMA channel x interrupt/status register */
      [4]  = (RO_ uint32_t* const)0x52000140U,   /** @brief MDMA channel x interrupt/status register */
      [5]  = (RO_ uint32_t* const)0x52000180U,   /** @brief MDMA channel x interrupt/status register */
      [6]  = (RO_ uint32_t* const)0x520001C0U,   /** @brief MDMA channel x interrupt/status register */
      [7]  = (RO_ uint32_t* const)0x52000200U,   /** @brief MDMA channel x interrupt/status register */
      [8]  = (RO_ uint32_t* const)0x52000240U,   /** @brief MDMA channel x interrupt/status register */
      [9]  = (RO_ uint32_t* const)0x52000280U,   /** @brief MDMA channel x interrupt/status register */
      [10] = (RO_ uint32_t* const)0x520002C0U,   /** @brief MDMA channel x interrupt/status register */
      [11] = (RO_ uint32_t* const)0x52000300U,   /** @brief MDMA channel x interrupt/status register */
      [12] = (RO_ uint32_t* const)0x52000340U,   /** @brief MDMA channel x interrupt/status register */
      [13] = (RO_ uint32_t* const)0x52000380U,   /** @brief MDMA channel x interrupt/status register */
      [14] = (RO_ uint32_t* const)0x520003C0U,   /** @brief MDMA channel x interrupt/status register */
      [15] = (RO_ uint32_t* const)0x52000400U,   /** @brief MDMA channel x interrupt/status register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxIFCR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000044U,   /** @brief MDMA channel x interrupt flag clear register */
      [1]  = (RW_ uint32_t* const)0x52000084U,   /** @brief MDMA channel x interrupt flag clear register */
      [2]  = (RW_ uint32_t* const)0x520000C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [3]  = (RW_ uint32_t* const)0x52000104U,   /** @brief MDMA channel x interrupt flag clear register */
      [4]  = (RW_ uint32_t* const)0x52000144U,   /** @brief MDMA channel x interrupt flag clear register */
      [5]  = (RW_ uint32_t* const)0x52000184U,   /** @brief MDMA channel x interrupt flag clear register */
      [6]  = (RW_ uint32_t* const)0x520001C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [7]  = (RW_ uint32_t* const)0x52000204U,   /** @brief MDMA channel x interrupt flag clear register */
      [8]  = (RW_ uint32_t* const)0x52000244U,   /** @brief MDMA channel x interrupt flag clear register */
      [9]  = (RW_ uint32_t* const)0x52000284U,   /** @brief MDMA channel x interrupt flag clear register */
      [10] = (RW_ uint32_t* const)0x520002C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [11] = (RW_ uint32_t* const)0x52000304U,   /** @brief MDMA channel x interrupt flag clear register */
      [12] = (RW_ uint32_t* const)0x52000344U,   /** @brief MDMA channel x interrupt flag clear register */
      [13] = (RW_ uint32_t* const)0x52000384U,   /** @brief MDMA channel x interrupt flag clear register */
      [14] = (RW_ uint32_t* const)0x520003C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [15] = (RW_ uint32_t* const)0x52000404U,   /** @brief MDMA channel x interrupt flag clear register */
    };

    static RO_ uint32_t* const MDMA_MDMA_CxESR_PTR[16] = {
      [0]  = (RO_ uint32_t* const)0x52000048U,   /** @brief MDMA channel x error status register */
      [1]  = (RO_ uint32_t* const)0x52000088U,   /** @brief MDMA channel x error status register */
      [2]  = (RO_ uint32_t* const)0x520000C8U,   /** @brief MDMA channel x error status register */
      [3]  = (RO_ uint32_t* const)0x52000108U,   /** @brief MDMA channel x error status register */
      [4]  = (RO_ uint32_t* const)0x52000148U,   /** @brief MDMA channel x error status register */
      [5]  = (RO_ uint32_t* const)0x52000188U,   /** @brief MDMA channel x error status register */
      [6]  = (RO_ uint32_t* const)0x520001C8U,   /** @brief MDMA channel x error status register */
      [7]  = (RO_ uint32_t* const)0x52000208U,   /** @brief MDMA channel x error status register */
      [8]  = (RO_ uint32_t* const)0x52000248U,   /** @brief MDMA channel x error status register */
      [9]  = (RO_ uint32_t* const)0x52000288U,   /** @brief MDMA channel x error status register */
      [10] = (RO_ uint32_t* const)0x520002C8U,   /** @brief MDMA channel x error status register */
      [11] = (RO_ uint32_t* const)0x52000308U,   /** @brief MDMA channel x error status register */
      [12] = (RO_ uint32_t* const)0x52000348U,   /** @brief MDMA channel x error status register */
      [13] = (RO_ uint32_t* const)0x52000388U,   /** @brief MDMA channel x error status register */
      [14] = (RO_ uint32_t* const)0x520003C8U,   /** @brief MDMA channel x error status register */
      [15] = (RO_ uint32_t* const)0x52000408U,   /** @brief MDMA channel x error status register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxCR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x5200004CU,   /** @brief This register is used to control the concerned channel. */
      [1]  = (RW_ uint32_t* const)0x5200008CU,   /** @brief This register is used to control the concerned channel. */
      [2]  = (RW_ uint32_t* const)0x520000CCU,   /** @brief This register is used to control the concerned channel. */
      [3]  = (RW_ uint32_t* const)0x5200010CU,   /** @brief This register is used to control the concerned channel. */
      [4]  = (RW_ uint32_t* const)0x5200014CU,   /** @brief This register is used to control the concerned channel. */
      [5]  = (RW_ uint32_t* const)0x5200018CU,   /** @brief This register is used to control the concerned channel. */
      [6]  = (RW_ uint32_t* const)0x520001CCU,   /** @brief This register is used to control the concerned channel. */
      [7]  = (RW_ uint32_t* const)0x5200020CU,   /** @brief This register is used to control the concerned channel. */
      [8]  = (RW_ uint32_t* const)0x5200024CU,   /** @brief This register is used to control the concerned channel. */
      [9]  = (RW_ uint32_t* const)0x5200028CU,   /** @brief This register is used to control the concerned channel. */
      [10] = (RW_ uint32_t* const)0x520002CCU,   /** @brief This register is used to control the concerned channel. */
      [11] = (RW_ uint32_t* const)0x5200030CU,   /** @brief This register is used to control the concerned channel. */
      [12] = (RW_ uint32_t* const)0x5200034CU,   /** @brief This register is used to control the concerned channel. */
      [13] = (RW_ uint32_t* const)0x5200038CU,   /** @brief This register is used to control the concerned channel. */
      [14] = (RW_ uint32_t* const)0x520003CCU,   /** @brief This register is used to control the concerned channel. */
      [15] = (RW_ uint32_t* const)0x5200040CU,   /** @brief This register is used to control the concerned channel. */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxTCR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000050U,   /** @brief This register is used to configure the concerned channel. */
      [1]  = (RW_ uint32_t* const)0x52000090U,   /** @brief This register is used to configure the concerned channel. */
      [2]  = (RW_ uint32_t* const)0x520000D0U,   /** @brief This register is used to configure the concerned channel. */
      [3]  = (RW_ uint32_t* const)0x52000110U,   /** @brief This register is used to configure the concerned channel. */
      [4]  = (RW_ uint32_t* const)0x52000150U,   /** @brief This register is used to configure the concerned channel. */
      [5]  = (RW_ uint32_t* const)0x52000190U,   /** @brief This register is used to configure the concerned channel. */
      [6]  = (RW_ uint32_t* const)0x520001D0U,   /** @brief This register is used to configure the concerned channel. */
      [7]  = (RW_ uint32_t* const)0x52000210U,   /** @brief This register is used to configure the concerned channel. */
      [8]  = (RW_ uint32_t* const)0x52000250U,   /** @brief This register is used to configure the concerned channel. */
      [9]  = (RW_ uint32_t* const)0x52000290U,   /** @brief This register is used to configure the concerned channel. */
      [10] = (RW_ uint32_t* const)0x520002D0U,   /** @brief This register is used to configure the concerned channel. */
      [11] = (RW_ uint32_t* const)0x52000310U,   /** @brief This register is used to configure the concerned channel. */
      [12] = (RW_ uint32_t* const)0x52000350U,   /** @brief This register is used to configure the concerned channel. */
      [13] = (RW_ uint32_t* const)0x52000390U,   /** @brief This register is used to configure the concerned channel. */
      [14] = (RW_ uint32_t* const)0x520003D0U,   /** @brief This register is used to configure the concerned channel. */
      [15] = (RW_ uint32_t* const)0x52000410U,   /** @brief This register is used to configure the concerned channel. */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxBNDTR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000054U,   /** @brief MDMA channel x block number of data register */
      [1]  = (RW_ uint32_t* const)0x52000094U,   /** @brief MDMA channel x block number of data register */
      [2]  = (RW_ uint32_t* const)0x520000D4U,   /** @brief MDMA channel x block number of data register */
      [3]  = (RW_ uint32_t* const)0x52000114U,   /** @brief MDMA channel x block number of data register */
      [4]  = (RW_ uint32_t* const)0x52000154U,   /** @brief MDMA channel x block number of data register */
      [5]  = (RW_ uint32_t* const)0x52000194U,   /** @brief MDMA channel x block number of data register */
      [6]  = (RW_ uint32_t* const)0x520001D4U,   /** @brief MDMA channel x block number of data register */
      [7]  = (RW_ uint32_t* const)0x52000214U,   /** @brief MDMA channel x block number of data register */
      [8]  = (RW_ uint32_t* const)0x52000254U,   /** @brief MDMA channel x block number of data register */
      [9]  = (RW_ uint32_t* const)0x52000294U,   /** @brief MDMA channel x block number of data register */
      [10] = (RW_ uint32_t* const)0x520002D4U,   /** @brief MDMA channel x block number of data register */
      [11] = (RW_ uint32_t* const)0x52000314U,   /** @brief MDMA channel x block number of data register */
      [12] = (RW_ uint32_t* const)0x52000354U,   /** @brief MDMA channel x block number of data register */
      [13] = (RW_ uint32_t* const)0x52000394U,   /** @brief MDMA channel x block number of data register */
      [14] = (RW_ uint32_t* const)0x520003D4U,   /** @brief MDMA channel x block number of data register */
      [15] = (RW_ uint32_t* const)0x52000414U,   /** @brief MDMA channel x block number of data register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxSAR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000058U,   /** @brief MDMA channel x source address register */
      [1]  = (RW_ uint32_t* const)0x52000098U,   /** @brief MDMA channel x source address register */
      [2]  = (RW_ uint32_t* const)0x520000D8U,   /** @brief MDMA channel x source address register */
      [3]  = (RW_ uint32_t* const)0x52000118U,   /** @brief MDMA channel x source address register */
      [4]  = (RW_ uint32_t* const)0x52000158U,   /** @brief MDMA channel x source address register */
      [5]  = (RW_ uint32_t* const)0x52000198U,   /** @brief MDMA channel x source address register */
      [6]  = (RW_ uint32_t* const)0x520001D8U,   /** @brief MDMA channel x source address register */
      [7]  = (RW_ uint32_t* const)0x52000218U,   /** @brief MDMA channel x source address register */
      [8]  = (RW_ uint32_t* const)0x52000258U,   /** @brief MDMA channel x source address register */
      [9]  = (RW_ uint32_t* const)0x52000298U,   /** @brief MDMA channel x source address register */
      [10] = (RW_ uint32_t* const)0x520002D8U,   /** @brief MDMA channel x source address register */
      [11] = (RW_ uint32_t* const)0x52000318U,   /** @brief MDMA channel x source address register */
      [12] = (RW_ uint32_t* const)0x52000358U,   /** @brief MDMA channel x source address register */
      [13] = (RW_ uint32_t* const)0x52000398U,   /** @brief MDMA channel x source address register */
      [14] = (RW_ uint32_t* const)0x520003D8U,   /** @brief MDMA channel x source address register */
      [15] = (RW_ uint32_t* const)0x52000418U,   /** @brief MDMA channel x source address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxDAR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x5200005CU,   /** @brief MDMA channel x destination address register */
      [1]  = (RW_ uint32_t* const)0x5200009CU,   /** @brief MDMA channel x destination address register */
      [2]  = (RW_ uint32_t* const)0x520000DCU,   /** @brief MDMA channel x destination address register */
      [3]  = (RW_ uint32_t* const)0x5200011CU,   /** @brief MDMA channel x destination address register */
      [4]  = (RW_ uint32_t* const)0x5200015CU,   /** @brief MDMA channel x destination address register */
      [5]  = (RW_ uint32_t* const)0x5200019CU,   /** @brief MDMA channel x destination address register */
      [6]  = (RW_ uint32_t* const)0x520001DCU,   /** @brief MDMA channel x destination address register */
      [7]  = (RW_ uint32_t* const)0x5200021CU,   /** @brief MDMA channel x destination address register */
      [8]  = (RW_ uint32_t* const)0x5200025CU,   /** @brief MDMA channel x destination address register */
      [9]  = (RW_ uint32_t* const)0x5200029CU,   /** @brief MDMA channel x destination address register */
      [10] = (RW_ uint32_t* const)0x520002DCU,   /** @brief MDMA channel x destination address register */
      [11] = (RW_ uint32_t* const)0x5200031CU,   /** @brief MDMA channel x destination address register */
      [12] = (RW_ uint32_t* const)0x5200035CU,   /** @brief MDMA channel x destination address register */
      [13] = (RW_ uint32_t* const)0x5200039CU,   /** @brief MDMA channel x destination address register */
      [14] = (RW_ uint32_t* const)0x520003DCU,   /** @brief MDMA channel x destination address register */
      [15] = (RW_ uint32_t* const)0x5200041CU,   /** @brief MDMA channel x destination address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxBRUR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000060U,   /** @brief MDMA channel x block repeat address update register */
      [1]  = (RW_ uint32_t* const)0x520000A0U,   /** @brief MDMA channel x block repeat address update register */
      [2]  = (RW_ uint32_t* const)0x520000E0U,   /** @brief MDMA channel x block repeat address update register */
      [3]  = (RW_ uint32_t* const)0x52000120U,   /** @brief MDMA channel x block repeat address update register */
      [4]  = (RW_ uint32_t* const)0x52000160U,   /** @brief MDMA channel x block repeat address update register */
      [5]  = (RW_ uint32_t* const)0x520001A0U,   /** @brief MDMA channel x block repeat address update register */
      [6]  = (RW_ uint32_t* const)0x520001E0U,   /** @brief MDMA channel x block repeat address update register */
      [7]  = (RW_ uint32_t* const)0x52000220U,   /** @brief MDMA channel x block repeat address update register */
      [8]  = (RW_ uint32_t* const)0x52000260U,   /** @brief MDMA channel x block repeat address update register */
      [9]  = (RW_ uint32_t* const)0x520002A0U,   /** @brief MDMA channel x block repeat address update register */
      [10] = (RW_ uint32_t* const)0x520002E0U,   /** @brief MDMA channel x block repeat address update register */
      [11] = (RW_ uint32_t* const)0x52000320U,   /** @brief MDMA channel x block repeat address update register */
      [12] = (RW_ uint32_t* const)0x52000360U,   /** @brief MDMA channel x block repeat address update register */
      [13] = (RW_ uint32_t* const)0x520003A0U,   /** @brief MDMA channel x block repeat address update register */
      [14] = (RW_ uint32_t* const)0x520003E0U,   /** @brief MDMA channel x block repeat address update register */
      [15] = (RW_ uint32_t* const)0x52000420U,   /** @brief MDMA channel x block repeat address update register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxLAR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000064U,   /** @brief MDMA channel x link address register */
      [1]  = (RW_ uint32_t* const)0x520000A4U,   /** @brief MDMA channel x link address register */
      [2]  = (RW_ uint32_t* const)0x520000E4U,   /** @brief MDMA channel x link address register */
      [3]  = (RW_ uint32_t* const)0x52000124U,   /** @brief MDMA channel x link address register */
      [4]  = (RW_ uint32_t* const)0x52000164U,   /** @brief MDMA channel x link address register */
      [5]  = (RW_ uint32_t* const)0x520001A4U,   /** @brief MDMA channel x link address register */
      [6]  = (RW_ uint32_t* const)0x520001E4U,   /** @brief MDMA channel x link address register */
      [7]  = (RW_ uint32_t* const)0x52000224U,   /** @brief MDMA channel x link address register */
      [8]  = (RW_ uint32_t* const)0x52000264U,   /** @brief MDMA channel x link address register */
      [9]  = (RW_ uint32_t* const)0x520002A4U,   /** @brief MDMA channel x link address register */
      [10] = (RW_ uint32_t* const)0x520002E4U,   /** @brief MDMA channel x link address register */
      [11] = (RW_ uint32_t* const)0x52000324U,   /** @brief MDMA channel x link address register */
      [12] = (RW_ uint32_t* const)0x52000364U,   /** @brief MDMA channel x link address register */
      [13] = (RW_ uint32_t* const)0x520003A4U,   /** @brief MDMA channel x link address register */
      [14] = (RW_ uint32_t* const)0x520003E4U,   /** @brief MDMA channel x link address register */
      [15] = (RW_ uint32_t* const)0x52000424U,   /** @brief MDMA channel x link address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxTBR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000068U,   /** @brief MDMA channel x trigger and bus selection register */
      [1]  = (RW_ uint32_t* const)0x520000A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [2]  = (RW_ uint32_t* const)0x520000E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [3]  = (RW_ uint32_t* const)0x52000128U,   /** @brief MDMA channel x trigger and bus selection register */
      [4]  = (RW_ uint32_t* const)0x52000168U,   /** @brief MDMA channel x trigger and bus selection register */
      [5]  = (RW_ uint32_t* const)0x520001A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [6]  = (RW_ uint32_t* const)0x520001E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [7]  = (RW_ uint32_t* const)0x52000228U,   /** @brief MDMA channel x trigger and bus selection register */
      [8]  = (RW_ uint32_t* const)0x52000268U,   /** @brief MDMA channel x trigger and bus selection register */
      [9]  = (RW_ uint32_t* const)0x520002A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [10] = (RW_ uint32_t* const)0x520002E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [11] = (RW_ uint32_t* const)0x52000328U,   /** @brief MDMA channel x trigger and bus selection register */
      [12] = (RW_ uint32_t* const)0x52000368U,   /** @brief MDMA channel x trigger and bus selection register */
      [13] = (RW_ uint32_t* const)0x520003A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [14] = (RW_ uint32_t* const)0x520003E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [15] = (RW_ uint32_t* const)0x52000428U,   /** @brief MDMA channel x trigger and bus selection register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxMAR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000070U,   /** @brief MDMA channel x mask address register */
      [1]  = (RW_ uint32_t* const)0x520000B0U,   /** @brief MDMA channel x mask address register */
      [2]  = (RW_ uint32_t* const)0x520000F0U,   /** @brief MDMA channel x mask address register */
      [3]  = (RW_ uint32_t* const)0x52000130U,   /** @brief MDMA channel x mask address register */
      [4]  = (RW_ uint32_t* const)0x52000170U,   /** @brief MDMA channel x mask address register */
      [5]  = (RW_ uint32_t* const)0x520001B0U,   /** @brief MDMA channel x mask address register */
      [6]  = (RW_ uint32_t* const)0x520001F0U,   /** @brief MDMA channel x mask address register */
      [7]  = (RW_ uint32_t* const)0x52000230U,   /** @brief MDMA channel x mask address register */
      [8]  = (RW_ uint32_t* const)0x52000270U,   /** @brief MDMA channel x mask address register */
      [9]  = (RW_ uint32_t* const)0x520002B0U,   /** @brief MDMA channel x mask address register */
      [10] = (RW_ uint32_t* const)0x520002F0U,   /** @brief MDMA channel x mask address register */
      [11] = (RW_ uint32_t* const)0x52000330U,   /** @brief MDMA channel x mask address register */
      [12] = (RW_ uint32_t* const)0x52000370U,   /** @brief MDMA channel x mask address register */
      [13] = (RW_ uint32_t* const)0x520003B0U,   /** @brief MDMA channel x mask address register */
      [14] = (RW_ uint32_t* const)0x520003F0U,   /** @brief MDMA channel x mask address register */
      [15] = (RW_ uint32_t* const)0x52000430U,   /** @brief MDMA channel x mask address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxMDR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x52000074U,   /** @brief MDMA channel x mask data register */
      [1]  = (RW_ uint32_t* const)0x520000B4U,   /** @brief MDMA channel x mask data register */
      [2]  = (RW_ uint32_t* const)0x520000F4U,   /** @brief MDMA channel x mask data register */
      [3]  = (RW_ uint32_t* const)0x52000134U,   /** @brief MDMA channel x mask data register */
      [4]  = (RW_ uint32_t* const)0x52000174U,   /** @brief MDMA channel x mask data register */
      [5]  = (RW_ uint32_t* const)0x520001B4U,   /** @brief MDMA channel x mask data register */
      [6]  = (RW_ uint32_t* const)0x520001F4U,   /** @brief MDMA channel x mask data register */
      [7]  = (RW_ uint32_t* const)0x52000234U,   /** @brief MDMA channel x mask data register */
      [8]  = (RW_ uint32_t* const)0x52000274U,   /** @brief MDMA channel x mask data register */
      [9]  = (RW_ uint32_t* const)0x520002B4U,   /** @brief MDMA channel x mask data register */
      [10] = (RW_ uint32_t* const)0x520002F4U,   /** @brief MDMA channel x mask data register */
      [11] = (RW_ uint32_t* const)0x52000334U,   /** @brief MDMA channel x mask data register */
      [12] = (RW_ uint32_t* const)0x52000374U,   /** @brief MDMA channel x mask data register */
      [13] = (RW_ uint32_t* const)0x520003B4U,   /** @brief MDMA channel x mask data register */
      [14] = (RW_ uint32_t* const)0x520003F4U,   /** @brief MDMA channel x mask data register */
      [15] = (RW_ uint32_t* const)0x52000434U,   /** @brief MDMA channel x mask data register */
    };

    /**** @subsection MDMA Register Reset Values ****/

    static const uint32_t MDMA_MDMA_GISR0_RST   = 0x00000000U;   /** @brief MDMA_GISR0 register reset value. */

    /**** @subsection Enumerated MDMA Register Reset Values ****/

    static const uint32_t MDMA_MDMA_CxISR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0ISR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1ISR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2ISR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3ISR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4ISR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5ISR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6ISR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7ISR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8ISR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9ISR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10ISR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11ISR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12ISR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13ISR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14ISR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15ISR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxIFCR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0IFCR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1IFCR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2IFCR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3IFCR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4IFCR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5IFCR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6IFCR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7IFCR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8IFCR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9IFCR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10IFCR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11IFCR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12IFCR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13IFCR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14IFCR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15IFCR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxESR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0ESR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1ESR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2ESR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3ESR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4ESR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5ESR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6ESR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7ESR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8ESR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9ESR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10ESR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11ESR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12ESR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13ESR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14ESR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15ESR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxCR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0CR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1CR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2CR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3CR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4CR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5CR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6CR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7CR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8CR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9CR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10CR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11CR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12CR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13CR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14CR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15CR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxTCR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0TCR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1TCR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2TCR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3TCR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4TCR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5TCR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6TCR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7TCR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8TCR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9TCR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10TCR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11TCR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12TCR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13TCR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14TCR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15TCR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxBNDTR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0BNDTR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1BNDTR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2BNDTR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3BNDTR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4BNDTR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5BNDTR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6BNDTR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7BNDTR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8BNDTR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9BNDTR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10BNDTR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11BNDTR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12BNDTR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13BNDTR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14BNDTR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15BNDTR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxSAR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0SAR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1SAR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2SAR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3SAR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4SAR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5SAR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6SAR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7SAR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8SAR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9SAR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10SAR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11SAR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12SAR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13SAR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14SAR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15SAR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxDAR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0DAR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1DAR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2DAR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3DAR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4DAR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5DAR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6DAR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7DAR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8DAR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9DAR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10DAR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11DAR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12DAR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13DAR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14DAR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15DAR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxBRUR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0BRUR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1BRUR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2BRUR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3BRUR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4BRUR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5BRUR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6BRUR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7BRUR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8BRUR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9BRUR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10BRUR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11BRUR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12BRUR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13BRUR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14BRUR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15BRUR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxLAR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0LAR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1LAR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2LAR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3LAR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4LAR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5LAR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6LAR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7LAR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8LAR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9LAR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10LAR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11LAR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12LAR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13LAR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14LAR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15LAR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxTBR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0TBR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1TBR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2TBR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3TBR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4TBR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5TBR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6TBR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7TBR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8TBR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9TBR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10TBR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11TBR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12TBR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13TBR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14TBR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15TBR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxMAR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0MAR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1MAR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2MAR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3MAR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4MAR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5MAR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6MAR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7MAR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8MAR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9MAR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10MAR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11MAR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12MAR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13MAR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14MAR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15MAR register reset value. */
    };

    static const uint32_t MDMA_MDMA_CxMDR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief MDMA_C0MDR register reset value. */
      [1]  = 0x00000000U,   /** @brief MDMA_C1MDR register reset value. */
      [2]  = 0x00000000U,   /** @brief MDMA_C2MDR register reset value. */
      [3]  = 0x00000000U,   /** @brief MDMA_C3MDR register reset value. */
      [4]  = 0x00000000U,   /** @brief MDMA_C4MDR register reset value. */
      [5]  = 0x00000000U,   /** @brief MDMA_C5MDR register reset value. */
      [6]  = 0x00000000U,   /** @brief MDMA_C6MDR register reset value. */
      [7]  = 0x00000000U,   /** @brief MDMA_C7MDR register reset value. */
      [8]  = 0x00000000U,   /** @brief MDMA_C8MDR register reset value. */
      [9]  = 0x00000000U,   /** @brief MDMA_C9MDR register reset value. */
      [10] = 0x00000000U,   /** @brief MDMA_C10MDR register reset value. */
      [11] = 0x00000000U,   /** @brief MDMA_C11MDR register reset value. */
      [12] = 0x00000000U,   /** @brief MDMA_C12MDR register reset value. */
      [13] = 0x00000000U,   /** @brief MDMA_C13MDR register reset value. */
      [14] = 0x00000000U,   /** @brief MDMA_C14MDR register reset value. */
      [15] = 0x00000000U,   /** @brief MDMA_C15MDR register reset value. */
    };

    /**** @subsection Enumerated MDMA Register Value Types ****/

    typedef uint32_t MDMA_MDMA_GISR0_t;     /** @brief MDMA_GISR0 register value type. */
    typedef uint32_t MDMA_MDMA_CxISR_t;     /** @brief MDMA_CxISR register value type. */
    typedef uint32_t MDMA_MDMA_CxIFCR_t;    /** @brief MDMA_CxIFCR register value type. */
    typedef uint32_t MDMA_MDMA_CxESR_t;     /** @brief MDMA_CxESR register value type. */
    typedef uint32_t MDMA_MDMA_CxCR_t;      /** @brief MDMA_CxCR register value type. */
    typedef uint32_t MDMA_MDMA_CxTCR_t;     /** @brief MDMA_CxTCR register value type. */
    typedef uint32_t MDMA_MDMA_CxBNDTR_t;   /** @brief MDMA_CxBNDTR register value type. */
    typedef uint32_t MDMA_MDMA_CxSAR_t;     /** @brief MDMA_CxSAR register value type. */
    typedef uint32_t MDMA_MDMA_CxDAR_t;     /** @brief MDMA_CxDAR register value type. */
    typedef uint32_t MDMA_MDMA_CxBRUR_t;    /** @brief MDMA_CxBRUR register value type. */
    typedef uint32_t MDMA_MDMA_CxLAR_t;     /** @brief MDMA_CxLAR register value type. */
    typedef uint32_t MDMA_MDMA_CxTBR_t;     /** @brief MDMA_CxTBR register value type. */
    typedef uint32_t MDMA_MDMA_CxMAR_t;     /** @brief MDMA_CxMAR register value type. */
    typedef uint32_t MDMA_MDMA_CxMDR_t;     /** @brief MDMA_CxMDR register value type. */

    /**** @subsection Enumerated MDMA Register Pointer Types ****/

    typedef uint32_t* const MDMA_MDMA_GISR0_PTR_t;     /** @brief MDMA_GISR0 register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxISR_PTR_t;     /** @brief MDMA_CxISR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxIFCR_PTR_t;    /** @brief MDMA_CxIFCR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxESR_PTR_t;     /** @brief MDMA_CxESR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxCR_PTR_t;      /** @brief MDMA_CxCR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxTCR_PTR_t;     /** @brief MDMA_CxTCR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxBNDTR_PTR_t;   /** @brief MDMA_CxBNDTR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxSAR_PTR_t;     /** @brief MDMA_CxSAR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxDAR_PTR_t;     /** @brief MDMA_CxDAR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxBRUR_PTR_t;    /** @brief MDMA_CxBRUR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxLAR_PTR_t;     /** @brief MDMA_CxLAR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxTBR_PTR_t;     /** @brief MDMA_CxTBR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxMAR_PTR_t;     /** @brief MDMA_CxMAR register pointer type. */
    typedef uint32_t* const MDMA_MDMA_CxMDR_PTR_t;     /** @brief MDMA_CxMDR register pointer type. */

    /**** @subsection MDMA Register Field Masks ****/

    static const uint32_t MDMA_MDMA_CxISR_TEIF0_MASK      = 0x00000001U;   /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_MDMA_CxISR_CTCIF0_MASK     = 0x00000002U;   /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_MDMA_CxISR_BRTIF0_MASK     = 0x00000004U;   /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_MDMA_CxISR_BTIF0_MASK      = 0x00000008U;   /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_MDMA_CxISR_TCIF0_MASK      = 0x00000010U;   /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_MDMA_CxISR_CRQA0_MASK      = 0x00010000U;   /** @brief Channel x request active flag */
    static const uint32_t MDMA_MDMA_CxIFCR_CTEIF0_MASK    = 0x00000001U;   /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_MDMA_CxIFCR_CCTCIF0_MASK   = 0x00000002U;   /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_MDMA_CxIFCR_CBRTIF0_MASK   = 0x00000004U;   /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_MDMA_CxIFCR_CBTIF0_MASK    = 0x00000008U;   /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_MDMA_CxIFCR_CLTCIF0_MASK   = 0x00000010U;   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_MDMA_CxESR_TEA_MASK        = 0x0000007FU;   /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_MDMA_CxESR_TED_MASK        = 0x00000080U;   /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_MDMA_CxESR_TELD_MASK       = 0x00000100U;   /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_MDMA_CxESR_TEMD_MASK       = 0x00000200U;   /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_MDMA_CxESR_ASE_MASK        = 0x00000400U;   /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_MDMA_CxESR_BSE_MASK        = 0x00000800U;   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_MDMA_CxCR_EN_MASK          = 0x00000001U;   /** @brief Channel enable */
    static const uint32_t MDMA_MDMA_CxCR_TEIE_MASK        = 0x00000002U;   /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_MDMA_CxCR_CTCIE_MASK       = 0x00000004U;   /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_MDMA_CxCR_BRTIE_MASK       = 0x00000008U;   /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_MDMA_CxCR_BTIE_MASK        = 0x00000010U;   /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_MDMA_CxCR_TCIE_MASK        = 0x00000020U;   /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_MDMA_CxCR_PL_MASK          = 0x000000C0U;   /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_MDMA_CxCR_BEX_MASK         = 0x00001000U;   /** @brief Byte endianness exchange */
    static const uint32_t MDMA_MDMA_CxCR_HEX_MASK         = 0x00002000U;   /** @brief Half word endianes exchange */
    static const uint32_t MDMA_MDMA_CxCR_WEX_MASK         = 0x00004000U;   /** @brief Word endianness exchange */
    static const uint32_t MDMA_MDMA_CxCR_SWRQ_MASK        = 0x00010000U;   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_MDMA_CxTCR_SINC_MASK       = 0x00000003U;   /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_MDMA_CxTCR_DINC_MASK       = 0x0000000CU;   /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_MDMA_CxTCR_SSIZE_MASK      = 0x00000030U;   /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_MDMA_CxTCR_DSIZE_MASK      = 0x000000C0U;   /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_MDMA_CxTCR_SINCOS_MASK     = 0x00000300U;   /** @brief Source increment offset size */
    static const uint32_t MDMA_MDMA_CxTCR_DINCOS_MASK     = 0x00000C00U;   /** @brief Destination increment offset */
    static const uint32_t MDMA_MDMA_CxTCR_SBURST_MASK     = 0x00007000U;   /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_MDMA_CxTCR_DBURST_MASK     = 0x00038000U;   /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_MDMA_CxTCR_TLEN_MASK       = 0x01FC0000U;   /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_MDMA_CxTCR_PKE_MASK        = 0x02000000U;   /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_MDMA_CxTCR_PAM_MASK        = 0x0C000000U;   /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_MDMA_CxTCR_TRGM_MASK       = 0x30000000U;   /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_MDMA_CxTCR_SWRM_MASK       = 0x40000000U;   /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_MDMA_CxTCR_BWM_MASK        = 0x80000000U;   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_MDMA_CxBNDTR_BNDT_MASK     = 0x0001FFFFU;   /** @brief Block number of data to transfer */
    static const uint32_t MDMA_MDMA_CxBNDTR_BRSUM_MASK    = 0x00040000U;   /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_MDMA_CxBNDTR_BRDUM_MASK    = 0x00080000U;   /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_MDMA_CxBNDTR_BRC_MASK      = 0xFFF00000U;   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_MDMA_CxBRUR_SUV_MASK       = 0x0000FFFFU;   /** @brief Source adresse update value */
    static const uint32_t MDMA_MDMA_CxBRUR_DUV_MASK       = 0xFFFF0000U;   /** @brief Destination address update */
    static const uint32_t MDMA_MDMA_CxTBR_TSEL_MASK       = 0x0000003FU;   /** @brief Trigger selection */
    static const uint32_t MDMA_MDMA_CxTBR_SBUS_MASK       = 0x00010000U;   /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_MDMA_CxTBR_DBUS_MASK       = 0x00020000U;   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */

    /**** @subsection Enumerated MDMA Register Field Masks ****/

    static const uint32_t MDMA_MDMA_GISR0_GIFx_MASK[16] = {
      [0]  = 0x00000001U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [1]  = 0x00000002U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [2]  = 0x00000004U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [3]  = 0x00000008U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [4]  = 0x00000010U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [5]  = 0x00000020U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [6]  = 0x00000040U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [7]  = 0x00000080U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [8]  = 0x00000100U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [9]  = 0x00000200U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [10] = 0x00000400U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [11] = 0x00000800U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [12] = 0x00001000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [13] = 0x00002000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [14] = 0x00004000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [15] = 0x00008000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
    };

    /**** @subsection MDMA Register Field Positions ****/

    static const int32_t MDMA_MDMA_CxISR_TEIF0_POS      = 0;    /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_MDMA_CxISR_CTCIF0_POS     = 1;    /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_MDMA_CxISR_BRTIF0_POS     = 2;    /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_MDMA_CxISR_BTIF0_POS      = 3;    /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_MDMA_CxISR_TCIF0_POS      = 4;    /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_MDMA_CxISR_CRQA0_POS      = 16;   /** @brief Channel x request active flag */
    static const int32_t MDMA_MDMA_CxIFCR_CTEIF0_POS    = 0;    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_MDMA_CxIFCR_CCTCIF0_POS   = 1;    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_MDMA_CxIFCR_CBRTIF0_POS   = 2;    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_MDMA_CxIFCR_CBTIF0_POS    = 3;    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_MDMA_CxIFCR_CLTCIF0_POS   = 4;    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_MDMA_CxESR_TEA_POS        = 0;    /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_MDMA_CxESR_TED_POS        = 7;    /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_MDMA_CxESR_TELD_POS       = 8;    /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_MDMA_CxESR_TEMD_POS       = 9;    /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_MDMA_CxESR_ASE_POS        = 10;   /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_MDMA_CxESR_BSE_POS        = 11;   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_MDMA_CxCR_EN_POS          = 0;    /** @brief Channel enable */
    static const int32_t MDMA_MDMA_CxCR_TEIE_POS        = 1;    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_MDMA_CxCR_CTCIE_POS       = 2;    /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_MDMA_CxCR_BRTIE_POS       = 3;    /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_MDMA_CxCR_BTIE_POS        = 4;    /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_MDMA_CxCR_TCIE_POS        = 5;    /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_MDMA_CxCR_PL_POS          = 6;    /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_MDMA_CxCR_BEX_POS         = 12;   /** @brief Byte endianness exchange */
    static const int32_t MDMA_MDMA_CxCR_HEX_POS         = 13;   /** @brief Half word endianes exchange */
    static const int32_t MDMA_MDMA_CxCR_WEX_POS         = 14;   /** @brief Word endianness exchange */
    static const int32_t MDMA_MDMA_CxCR_SWRQ_POS        = 16;   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_MDMA_CxTCR_SINC_POS       = 0;    /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_MDMA_CxTCR_DINC_POS       = 2;    /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_MDMA_CxTCR_SSIZE_POS      = 4;    /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_MDMA_CxTCR_DSIZE_POS      = 6;    /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_MDMA_CxTCR_SINCOS_POS     = 8;    /** @brief Source increment offset size */
    static const int32_t MDMA_MDMA_CxTCR_DINCOS_POS     = 10;   /** @brief Destination increment offset */
    static const int32_t MDMA_MDMA_CxTCR_SBURST_POS     = 12;   /** @brief Source burst transfer configuration */
    static const int32_t MDMA_MDMA_CxTCR_DBURST_POS     = 15;   /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_MDMA_CxTCR_TLEN_POS       = 18;   /** @brief Buffer transfer lengh */
    static const int32_t MDMA_MDMA_CxTCR_PKE_POS        = 25;   /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_MDMA_CxTCR_PAM_POS        = 26;   /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_MDMA_CxTCR_TRGM_POS       = 28;   /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_MDMA_CxTCR_SWRM_POS       = 30;   /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_MDMA_CxTCR_BWM_POS        = 31;   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_MDMA_CxBNDTR_BNDT_POS     = 0;    /** @brief Block number of data to transfer */
    static const int32_t MDMA_MDMA_CxBNDTR_BRSUM_POS    = 18;   /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_MDMA_CxBNDTR_BRDUM_POS    = 19;   /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_MDMA_CxBNDTR_BRC_POS      = 20;   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_MDMA_CxBRUR_SUV_POS       = 0;    /** @brief Source adresse update value */
    static const int32_t MDMA_MDMA_CxBRUR_DUV_POS       = 16;   /** @brief Destination address update */
    static const int32_t MDMA_MDMA_CxTBR_TSEL_POS       = 0;    /** @brief Trigger selection */
    static const int32_t MDMA_MDMA_CxTBR_SBUS_POS       = 16;   /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_MDMA_CxTBR_DBUS_POS       = 17;   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */

    /**** @subsection Enumerated MDMA Register Field Positions ****/

    static const int32_t MDMA_MDMA_GISR0_GIFx_POS[16] = {
      [0]  = 0,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [1]  = 1,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [2]  = 2,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [3]  = 3,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [4]  = 4,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [5]  = 5,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [6]  = 6,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [7]  = 7,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [8]  = 8,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [9]  = 9,    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [10] = 10,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [11] = 11,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [12] = 12,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [13] = 13,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [14] = 14,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [15] = 15,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
    };

    /**********************************************************************************************
     * @section QUADSPI Register Information
     **********************************************************************************************/

    /**** @subsection QUADSPI Register Pointers ****/

    static RW_ uint32_t* const QUADSPI_CR_PTR      = (RW_ uint32_t* const)0x52005000U;   /** @brief QUADSPI control register */
    static RW_ uint32_t* const QUADSPI_DCR_PTR     = (RW_ uint32_t* const)0x52005004U;   /** @brief QUADSPI device configuration register */
    static RO_ uint32_t* const QUADSPI_SR_PTR      = (RO_ uint32_t* const)0x52005008U;   /** @brief QUADSPI status register */
    static RW_ uint32_t* const QUADSPI_FCR_PTR     = (RW_ uint32_t* const)0x5200500CU;   /** @brief QUADSPI flag clear register */
    static RW_ uint32_t* const QUADSPI_DLR_PTR     = (RW_ uint32_t* const)0x52005010U;   /** @brief QUADSPI data length register */
    static RW_ uint32_t* const QUADSPI_CCR_PTR     = (RW_ uint32_t* const)0x52005014U;   /** @brief QUADSPI communication configuration register */
    static RW_ uint32_t* const QUADSPI_AR_PTR      = (RW_ uint32_t* const)0x52005018U;   /** @brief QUADSPI address register */
    static RW_ uint32_t* const QUADSPI_ABR_PTR     = (RW_ uint32_t* const)0x5200501CU;   /** @brief QUADSPI alternate bytes registers */
    static RW_ uint32_t* const QUADSPI_DR_PTR      = (RW_ uint32_t* const)0x52005020U;   /** @brief QUADSPI data register */
    static RW_ uint32_t* const QUADSPI_PSMKR_PTR   = (RW_ uint32_t* const)0x52005024U;   /** @brief QUADSPI polling status mask register */
    static RW_ uint32_t* const QUADSPI_PSMAR_PTR   = (RW_ uint32_t* const)0x52005028U;   /** @brief QUADSPI polling status match register */
    static RW_ uint32_t* const QUADSPI_PIR_PTR     = (RW_ uint32_t* const)0x5200502CU;   /** @brief QUADSPI polling interval register */
    static RW_ uint32_t* const QUADSPI_LPTR_PTR    = (RW_ uint32_t* const)0x52005030U;   /** @brief QUADSPI low-power timeout register */

    /**** @subsection QUADSPI Register Reset Values ****/

    static const uint32_t QUADSPI_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t QUADSPI_DCR_RST     = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t QUADSPI_SR_RST      = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t QUADSPI_FCR_RST     = 0x00000000U;   /** @brief FCR register reset value. */
    static const uint32_t QUADSPI_DLR_RST     = 0x00000000U;   /** @brief DLR register reset value. */
    static const uint32_t QUADSPI_CCR_RST     = 0x00000000U;   /** @brief CCR register reset value. */
    static const uint32_t QUADSPI_AR_RST      = 0x00000000U;   /** @brief AR register reset value. */
    static const uint32_t QUADSPI_ABR_RST     = 0x00000000U;   /** @brief ABR register reset value. */
    static const uint32_t QUADSPI_DR_RST      = 0x00000000U;   /** @brief DR register reset value. */
    static const uint32_t QUADSPI_PSMKR_RST   = 0x00000000U;   /** @brief PSMKR register reset value. */
    static const uint32_t QUADSPI_PSMAR_RST   = 0x00000000U;   /** @brief PSMAR register reset value. */
    static const uint32_t QUADSPI_PIR_RST     = 0x00000000U;   /** @brief PIR register reset value. */
    static const uint32_t QUADSPI_LPTR_RST    = 0x00000000U;   /** @brief LPTR register reset value. */

    /**** @subsection Enumerated QUADSPI Register Value Types ****/

    typedef uint32_t QUADSPI_CR_t;      /** @brief CR register value type. */
    typedef uint32_t QUADSPI_DCR_t;     /** @brief DCR register value type. */
    typedef uint32_t QUADSPI_SR_t;      /** @brief SR register value type. */
    typedef uint32_t QUADSPI_FCR_t;     /** @brief FCR register value type. */
    typedef uint32_t QUADSPI_DLR_t;     /** @brief DLR register value type. */
    typedef uint32_t QUADSPI_CCR_t;     /** @brief CCR register value type. */
    typedef uint32_t QUADSPI_AR_t;      /** @brief AR register value type. */
    typedef uint32_t QUADSPI_ABR_t;     /** @brief ABR register value type. */
    typedef uint32_t QUADSPI_DR_t;      /** @brief DR register value type. */
    typedef uint32_t QUADSPI_PSMKR_t;   /** @brief PSMKR register value type. */
    typedef uint32_t QUADSPI_PSMAR_t;   /** @brief PSMAR register value type. */
    typedef uint32_t QUADSPI_PIR_t;     /** @brief PIR register value type. */
    typedef uint32_t QUADSPI_LPTR_t;    /** @brief LPTR register value type. */

    /**** @subsection Enumerated QUADSPI Register Pointer Types ****/

    typedef uint32_t* const QUADSPI_CR_PTR_t;      /** @brief CR register pointer type. */
    typedef uint32_t* const QUADSPI_DCR_PTR_t;     /** @brief DCR register pointer type. */
    typedef uint32_t* const QUADSPI_SR_PTR_t;      /** @brief SR register pointer type. */
    typedef uint32_t* const QUADSPI_FCR_PTR_t;     /** @brief FCR register pointer type. */
    typedef uint32_t* const QUADSPI_DLR_PTR_t;     /** @brief DLR register pointer type. */
    typedef uint32_t* const QUADSPI_CCR_PTR_t;     /** @brief CCR register pointer type. */
    typedef uint32_t* const QUADSPI_AR_PTR_t;      /** @brief AR register pointer type. */
    typedef uint32_t* const QUADSPI_ABR_PTR_t;     /** @brief ABR register pointer type. */
    typedef uint32_t* const QUADSPI_DR_PTR_t;      /** @brief DR register pointer type. */
    typedef uint32_t* const QUADSPI_PSMKR_PTR_t;   /** @brief PSMKR register pointer type. */
    typedef uint32_t* const QUADSPI_PSMAR_PTR_t;   /** @brief PSMAR register pointer type. */
    typedef uint32_t* const QUADSPI_PIR_PTR_t;     /** @brief PIR register pointer type. */
    typedef uint32_t* const QUADSPI_LPTR_PTR_t;    /** @brief LPTR register pointer type. */

    /**** @subsection QUADSPI Register Field Masks ****/

    static const uint32_t QUADSPI_CR_EN_MASK             = 0x00000001U;   /** @brief Enable enable the QUADSPI. */
    static const uint32_t QUADSPI_CR_ABORT_MASK          = 0x00000002U;   /** @brief Abort request this bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit. */
    static const uint32_t QUADSPI_CR_DMAEN_MASK          = 0x00000004U;   /** @brief DMA enable in indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set. */
    static const uint32_t QUADSPI_CR_TCEN_MASK           = 0x00000008U;   /** @brief Timeout counter enable this bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (ncs) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with ncs maintained low, even if no access to the flash memory occurs for a long time. Since flash memories tend to consume more when ncs is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that ncs is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_SSHIFT_MASK         = 0x00000010U;   /** @brief Sample shift by default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_DFM_MASK            = 0x00000040U;   /** @brief Dual-flash mode this bit activates dual-flash mode, where two external flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_FSEL_MASK           = 0x00000080U;   /** @brief Flash memory selection this bit selects the flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1. */
    static const uint32_t QUADSPI_CR_FTHRES_MASK         = 0x00001F00U;   /** @brief FIFO threshold level defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. */
    static const uint32_t QUADSPI_CR_TEIE_MASK           = 0x00010000U;   /** @brief Transfer error interrupt enable this bit enables the transfer error interrupt. */
    static const uint32_t QUADSPI_CR_TCIE_MASK           = 0x00020000U;   /** @brief Transfer complete interrupt enable this bit enables the transfer complete interrupt. */
    static const uint32_t QUADSPI_CR_FTIE_MASK           = 0x00040000U;   /** @brief FIFO threshold interrupt enable this bit enables the FIFO threshold interrupt. */
    static const uint32_t QUADSPI_CR_SMIE_MASK           = 0x00080000U;   /** @brief Status match interrupt enable this bit enables the status match interrupt. */
    static const uint32_t QUADSPI_CR_TOIE_MASK           = 0x00100000U;   /** @brief TimeOut interrupt enable this bit enables the timeout interrupt. */
    static const uint32_t QUADSPI_CR_APMS_MASK           = 0x00400000U;   /** @brief Automatic poll mode stop this bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_PMM_MASK            = 0x00800000U;   /** @brief Polling match mode this bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_PRESCALER_MASK      = 0xFF000000U;   /** @brief Clock prescaler */
    static const uint32_t QUADSPI_DCR_CKMODE_MASK        = 0x00000001U;   /** @brief Indicates the level that clk takes between command */
    static const uint32_t QUADSPI_DCR_CSHT_MASK          = 0x00000700U;   /** @brief Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (ncs) must remain high between commands issued to the flash memory. ... This field can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_DCR_FSIZE_MASK         = 0x001F0000U;   /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_SR_TEF_MASK            = 0x00000001U;   /** @brief Transfer error flag this bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF. */
    static const uint32_t QUADSPI_SR_TCF_MASK            = 0x00000002U;   /** @brief Transfer complete flag this bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.it is cleared by writing 1 to CTCF. */
    static const uint32_t QUADSPI_SR_FTF_MASK            = 0x00000004U;   /** @brief FIFO threshold flag in indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read. */
    static const uint32_t QUADSPI_SR_SMF_MASK            = 0x00000008U;   /** @brief Status match flag this bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF. */
    static const uint32_t QUADSPI_SR_TOF_MASK            = 0x00000010U;   /** @brief Timeout flag this bit is set when timeout occurs. It is cleared by writing 1 to CTOF. */
    static const uint32_t QUADSPI_SR_BUSY_MASK           = 0x00000020U;   /** @brief Busy this bit is set when an operation is on going. This bit clears automatically when the operation with the flash memory is finished and the FIFO is empty. */
    static const uint32_t QUADSPI_SR_FLEVEL_MASK         = 0x00003F00U;   /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
    static const uint32_t QUADSPI_FCR_CTEF_MASK          = 0x00000001U;   /** @brief Clear transfer error flag writing 1 clears the TEF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_FCR_CTCF_MASK          = 0x00000002U;   /** @brief Clear transfer complete flag writing 1 clears the TCF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_FCR_CSMF_MASK          = 0x00000008U;   /** @brief Clear status match flag writing 1 clears the SMF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_FCR_CTOF_MASK          = 0x00000010U;   /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_CCR_INSTRUCTION_MASK   = 0x000000FFU;   /** @brief Instruction instruction to be send to the external SPI device. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_IMODE_MASK         = 0x00000300U;   /** @brief Instruction mode this field defines the instruction phase mode of operation: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ADMODE_MASK        = 0x00000C00U;   /** @brief Address mode this field defines the address phase mode of operation: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ADSIZE_MASK        = 0x00003000U;   /** @brief Address size this bit defines address size: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ABMODE_MASK        = 0x0000C000U;   /** @brief Alternate bytes mode this field defines the alternate-bytes phase mode of operation: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ABSIZE_MASK        = 0x00030000U;   /** @brief Alternate bytes size this bit defines alternate bytes size: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DCYC_MASK          = 0x007C0000U;   /** @brief Number of dummy cycles this field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DMODE_MASK         = 0x03000000U;   /** @brief Data mode this field defines the data phases mode of operation: this field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_FMODE_MASK         = 0x0C000000U;   /** @brief Functional mode this field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_SIOO_MASK          = 0x10000000U;   /** @brief Send instruction only once mode see section15.3.11: sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DHHC_MASK          = 0x40000000U;   /** @brief DDR hold delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: this feature is only active in DDR mode. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DDRM_MASK          = 0x80000000U;   /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_PIR_INTERVAL_MASK      = 0x0000FFFFU;   /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_LPTR_TIMEOUT_MASK      = 0x0000FFFFU;   /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

    /**** @subsection QUADSPI Register Field Positions ****/

    static const int32_t QUADSPI_CR_EN_POS             = 0;    /** @brief Enable enable the QUADSPI. */
    static const int32_t QUADSPI_CR_ABORT_POS          = 1;    /** @brief Abort request this bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit. */
    static const int32_t QUADSPI_CR_DMAEN_POS          = 2;    /** @brief DMA enable in indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set. */
    static const int32_t QUADSPI_CR_TCEN_POS           = 3;    /** @brief Timeout counter enable this bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (ncs) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with ncs maintained low, even if no access to the flash memory occurs for a long time. Since flash memories tend to consume more when ncs is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that ncs is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_CR_SSHIFT_POS         = 4;    /** @brief Sample shift by default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_CR_DFM_POS            = 6;    /** @brief Dual-flash mode this bit activates dual-flash mode, where two external flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_CR_FSEL_POS           = 7;    /** @brief Flash memory selection this bit selects the flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1. */
    static const int32_t QUADSPI_CR_FTHRES_POS         = 8;    /** @brief FIFO threshold level defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. */
    static const int32_t QUADSPI_CR_TEIE_POS           = 16;   /** @brief Transfer error interrupt enable this bit enables the transfer error interrupt. */
    static const int32_t QUADSPI_CR_TCIE_POS           = 17;   /** @brief Transfer complete interrupt enable this bit enables the transfer complete interrupt. */
    static const int32_t QUADSPI_CR_FTIE_POS           = 18;   /** @brief FIFO threshold interrupt enable this bit enables the FIFO threshold interrupt. */
    static const int32_t QUADSPI_CR_SMIE_POS           = 19;   /** @brief Status match interrupt enable this bit enables the status match interrupt. */
    static const int32_t QUADSPI_CR_TOIE_POS           = 20;   /** @brief TimeOut interrupt enable this bit enables the timeout interrupt. */
    static const int32_t QUADSPI_CR_APMS_POS           = 22;   /** @brief Automatic poll mode stop this bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_CR_PMM_POS            = 23;   /** @brief Polling match mode this bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_CR_PRESCALER_POS      = 24;   /** @brief Clock prescaler */
    static const int32_t QUADSPI_DCR_CKMODE_POS        = 0;    /** @brief Indicates the level that clk takes between command */
    static const int32_t QUADSPI_DCR_CSHT_POS          = 8;    /** @brief Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (ncs) must remain high between commands issued to the flash memory. ... This field can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_DCR_FSIZE_POS         = 16;   /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_SR_TEF_POS            = 0;    /** @brief Transfer error flag this bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF. */
    static const int32_t QUADSPI_SR_TCF_POS            = 1;    /** @brief Transfer complete flag this bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.it is cleared by writing 1 to CTCF. */
    static const int32_t QUADSPI_SR_FTF_POS            = 2;    /** @brief FIFO threshold flag in indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read. */
    static const int32_t QUADSPI_SR_SMF_POS            = 3;    /** @brief Status match flag this bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF. */
    static const int32_t QUADSPI_SR_TOF_POS            = 4;    /** @brief Timeout flag this bit is set when timeout occurs. It is cleared by writing 1 to CTOF. */
    static const int32_t QUADSPI_SR_BUSY_POS           = 5;    /** @brief Busy this bit is set when an operation is on going. This bit clears automatically when the operation with the flash memory is finished and the FIFO is empty. */
    static const int32_t QUADSPI_SR_FLEVEL_POS         = 8;    /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
    static const int32_t QUADSPI_FCR_CTEF_POS          = 0;    /** @brief Clear transfer error flag writing 1 clears the TEF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_FCR_CTCF_POS          = 1;    /** @brief Clear transfer complete flag writing 1 clears the TCF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_FCR_CSMF_POS          = 3;    /** @brief Clear status match flag writing 1 clears the SMF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_FCR_CTOF_POS          = 4;    /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_CCR_INSTRUCTION_POS   = 0;    /** @brief Instruction instruction to be send to the external SPI device. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_IMODE_POS         = 8;    /** @brief Instruction mode this field defines the instruction phase mode of operation: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_ADMODE_POS        = 10;   /** @brief Address mode this field defines the address phase mode of operation: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_ADSIZE_POS        = 12;   /** @brief Address size this bit defines address size: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_ABMODE_POS        = 14;   /** @brief Alternate bytes mode this field defines the alternate-bytes phase mode of operation: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_ABSIZE_POS        = 16;   /** @brief Alternate bytes size this bit defines alternate bytes size: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_DCYC_POS          = 18;   /** @brief Number of dummy cycles this field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_DMODE_POS         = 24;   /** @brief Data mode this field defines the data phases mode of operation: this field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_FMODE_POS         = 26;   /** @brief Functional mode this field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_SIOO_POS          = 28;   /** @brief Send instruction only once mode see section15.3.11: sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_DHHC_POS          = 30;   /** @brief DDR hold delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: this feature is only active in DDR mode. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_CCR_DDRM_POS          = 31;   /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_PIR_INTERVAL_POS      = 0;    /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_TIMEOUT_POS      = 0;    /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

    /**********************************************************************************************
     * @section RNG Register Information
     **********************************************************************************************/

    /**** @subsection RNG Register Pointers ****/

    static RW_ uint32_t* const RNG_CR_PTR   = (RW_ uint32_t* const)0x48021800U;   /** @brief RNG control register */
    static RW_ uint32_t* const RNG_SR_PTR   = (RW_ uint32_t* const)0x48021804U;   /** @brief RNG status register */
    static RO_ uint32_t* const RNG_DR_PTR   = (RO_ uint32_t* const)0x48021808U;   /** @brief The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0. */

    /**** @subsection RNG Register Reset Values ****/

    static const uint32_t RNG_CR_RST   = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t RNG_SR_RST   = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t RNG_DR_RST   = 0x00000000U;   /** @brief DR register reset value. */

    /**** @subsection Enumerated RNG Register Value Types ****/

    typedef uint32_t RNG_CR_t;   /** @brief CR register value type. */
    typedef uint32_t RNG_SR_t;   /** @brief SR register value type. */
    typedef uint32_t RNG_DR_t;   /** @brief DR register value type. */

    /**** @subsection Enumerated RNG Register Pointer Types ****/

    typedef uint32_t* const RNG_CR_PTR_t;   /** @brief CR register pointer type. */
    typedef uint32_t* const RNG_SR_PTR_t;   /** @brief SR register pointer type. */
    typedef uint32_t* const RNG_DR_PTR_t;   /** @brief DR register pointer type. */

    /**** @subsection RNG Register Field Masks ****/

    static const uint32_t RNG_CR_RNGEN_MASK   = 0x00000004U;   /** @brief Random number generator enable */
    static const uint32_t RNG_CR_IE_MASK      = 0x00000008U;   /** @brief Interrupt enable */
    static const uint32_t RNG_CR_CED_MASK     = 0x00000020U;   /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
    static const uint32_t RNG_SR_DRDY_MASK    = 0x00000001U;   /** @brief Data ready note: if IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated. */
    static const uint32_t RNG_SR_CECS_MASK    = 0x00000002U;   /** @brief Clock error current status note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const uint32_t RNG_SR_SECS_MASK    = 0x00000004U;   /** @brief Seed error current status ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) */
    static const uint32_t RNG_SR_CEIS_MASK    = 0x00000020U;   /** @brief Clock error interrupt status this bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const uint32_t RNG_SR_SEIS_MASK    = 0x00000040U;   /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */

    /**** @subsection RNG Register Field Positions ****/

    static const int32_t RNG_CR_RNGEN_POS   = 2;   /** @brief Random number generator enable */
    static const int32_t RNG_CR_IE_POS      = 3;   /** @brief Interrupt enable */
    static const int32_t RNG_CR_CED_POS     = 5;   /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
    static const int32_t RNG_SR_DRDY_POS    = 0;   /** @brief Data ready note: if IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated. */
    static const int32_t RNG_SR_CECS_POS    = 1;   /** @brief Clock error current status note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const int32_t RNG_SR_SECS_POS    = 2;   /** @brief Seed error current status ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) */
    static const int32_t RNG_SR_CEIS_POS    = 5;   /** @brief Clock error interrupt status this bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const int32_t RNG_SR_SEIS_POS    = 6;   /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */

    /**********************************************************************************************
     * @section RTC Register Information
     **********************************************************************************************/

    /**** @subsection RTC Register Pointers ****/

    static RW_ uint32_t* const RTC_RTC_TR_PTR         = (RW_ uint32_t* const)0x58004000U;   /** @brief The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_DR_PTR         = (RW_ uint32_t* const)0x58004004U;   /** @brief The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_CR_PTR         = (RW_ uint32_t* const)0x58004008U;   /** @brief RTC control register */
    static RW_ uint32_t* const RTC_RTC_ISR_PTR        = (RW_ uint32_t* const)0x5800400CU;   /** @brief This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_PRER_PTR       = (RW_ uint32_t* const)0x58004010U;   /** @brief This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to calendar initialization and configuration on page9.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_WUTR_PTR       = (RW_ uint32_t* const)0x58004014U;   /** @brief This register can be written only when WUTWF is set to 1 in rtc_isr.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_ALRMAR_PTR     = (RW_ uint32_t* const)0x5800401CU;   /** @brief This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_ALRMBR_PTR     = (RW_ uint32_t* const)0x58004020U;   /** @brief This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_WPR_PTR        = (RW_ uint32_t* const)0x58004024U;   /** @brief RTC write protection register */
    static RO_ uint32_t* const RTC_RTC_SSR_PTR        = (RO_ uint32_t* const)0x58004028U;   /** @brief RTC sub second register */
    static RW_ uint32_t* const RTC_RTC_SHIFTR_PTR     = (RW_ uint32_t* const)0x5800402CU;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RO_ uint32_t* const RTC_RTC_TSTR_PTR       = (RO_ uint32_t* const)0x58004030U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static RO_ uint32_t* const RTC_RTC_TSDR_PTR       = (RO_ uint32_t* const)0x58004034U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static RO_ uint32_t* const RTC_RTC_TSSSR_PTR      = (RO_ uint32_t* const)0x58004038U;   /** @brief The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset. */
    static RW_ uint32_t* const RTC_RTC_CALR_PTR       = (RW_ uint32_t* const)0x5800403CU;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_TAMPCR_PTR     = (RW_ uint32_t* const)0x58004040U;   /** @brief RTC tamper and alternate function configuration register */
    static RW_ uint32_t* const RTC_RTC_ALRMASSR_PTR   = (RW_ uint32_t* const)0x58004044U;   /** @brief This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9 */
    static RW_ uint32_t* const RTC_RTC_ALRMBSSR_PTR   = (RW_ uint32_t* const)0x58004048U;   /** @brief This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.this register is write protected.the write access procedure is described in section: RTC register write protection. */
    static RW_ uint32_t* const RTC_RTC_OR_PTR         = (RW_ uint32_t* const)0x5800404CU;   /** @brief RTC option register */

    /**** @subsection Enumerated RTC Register Pointers ****/

    static RW_ uint32_t* const RTC_RTC_BKPxR_PTR[32] = {
      [0]  = (RW_ uint32_t* const)0x58004050U,   /** @brief RTC backup registers */
      [1]  = (RW_ uint32_t* const)0x58004054U,   /** @brief RTC backup registers */
      [2]  = (RW_ uint32_t* const)0x58004058U,   /** @brief RTC backup registers */
      [3]  = (RW_ uint32_t* const)0x5800405CU,   /** @brief RTC backup registers */
      [4]  = (RW_ uint32_t* const)0x58004060U,   /** @brief RTC backup registers */
      [5]  = (RW_ uint32_t* const)0x58004064U,   /** @brief RTC backup registers */
      [6]  = (RW_ uint32_t* const)0x58004068U,   /** @brief RTC backup registers */
      [7]  = (RW_ uint32_t* const)0x5800406CU,   /** @brief RTC backup registers */
      [8]  = (RW_ uint32_t* const)0x58004070U,   /** @brief RTC backup registers */
      [9]  = (RW_ uint32_t* const)0x58004074U,   /** @brief RTC backup registers */
      [10] = (RW_ uint32_t* const)0x58004078U,   /** @brief RTC backup registers */
      [11] = (RW_ uint32_t* const)0x5800407CU,   /** @brief RTC backup registers */
      [12] = (RW_ uint32_t* const)0x58004080U,   /** @brief RTC backup registers */
      [13] = (RW_ uint32_t* const)0x58004084U,   /** @brief RTC backup registers */
      [14] = (RW_ uint32_t* const)0x58004088U,   /** @brief RTC backup registers */
      [15] = (RW_ uint32_t* const)0x5800408CU,   /** @brief RTC backup registers */
      [16] = (RW_ uint32_t* const)0x58004090U,   /** @brief RTC backup registers */
      [17] = (RW_ uint32_t* const)0x58004094U,   /** @brief RTC backup registers */
      [18] = (RW_ uint32_t* const)0x58004098U,   /** @brief RTC backup registers */
      [19] = (RW_ uint32_t* const)0x5800409CU,   /** @brief RTC backup registers */
      [20] = (RW_ uint32_t* const)0x580040A0U,   /** @brief RTC backup registers */
      [21] = (RW_ uint32_t* const)0x580040A4U,   /** @brief RTC backup registers */
      [22] = (RW_ uint32_t* const)0x580040A8U,   /** @brief RTC backup registers */
      [23] = (RW_ uint32_t* const)0x580040ACU,   /** @brief RTC backup registers */
      [24] = (RW_ uint32_t* const)0x580040B0U,   /** @brief RTC backup registers */
      [25] = (RW_ uint32_t* const)0x580040B4U,   /** @brief RTC backup registers */
      [26] = (RW_ uint32_t* const)0x580040B8U,   /** @brief RTC backup registers */
      [27] = (RW_ uint32_t* const)0x580040BCU,   /** @brief RTC backup registers */
      [28] = (RW_ uint32_t* const)0x580040C0U,   /** @brief RTC backup registers */
      [29] = (RW_ uint32_t* const)0x580040C4U,   /** @brief RTC backup registers */
      [30] = (RW_ uint32_t* const)0x580040C8U,   /** @brief RTC backup registers */
      [31] = (RW_ uint32_t* const)0x580040CCU,   /** @brief RTC backup registers */
    };

    /**** @subsection RTC Register Reset Values ****/

    static const uint32_t RTC_RTC_TR_RST         = 0x00000000U;   /** @brief RTC_TR register reset value. */
    static const uint32_t RTC_RTC_DR_RST         = 0x00002101U;   /** @brief RTC_DR register reset value. */
    static const uint32_t RTC_RTC_CR_RST         = 0x00000000U;   /** @brief RTC_CR register reset value. */
    static const uint32_t RTC_RTC_ISR_RST        = 0x00000007U;   /** @brief RTC_ISR register reset value. */
    static const uint32_t RTC_RTC_PRER_RST       = 0x007F00FFU;   /** @brief RTC_PRER register reset value. */
    static const uint32_t RTC_RTC_WUTR_RST       = 0x0000FFFFU;   /** @brief RTC_WUTR register reset value. */
    static const uint32_t RTC_RTC_ALRMAR_RST     = 0x00000000U;   /** @brief RTC_ALRMAR register reset value. */
    static const uint32_t RTC_RTC_ALRMBR_RST     = 0x00000000U;   /** @brief RTC_ALRMBR register reset value. */
    static const uint32_t RTC_RTC_WPR_RST        = 0x00000000U;   /** @brief RTC_WPR register reset value. */
    static const uint32_t RTC_RTC_SSR_RST        = 0x00000000U;   /** @brief RTC_SSR register reset value. */
    static const uint32_t RTC_RTC_SHIFTR_RST     = 0x00000000U;   /** @brief RTC_SHIFTR register reset value. */
    static const uint32_t RTC_RTC_TSTR_RST       = 0x00000000U;   /** @brief RTC_TSTR register reset value. */
    static const uint32_t RTC_RTC_TSDR_RST       = 0x00000000U;   /** @brief RTC_TSDR register reset value. */
    static const uint32_t RTC_RTC_TSSSR_RST      = 0x00000000U;   /** @brief RTC_TSSSR register reset value. */
    static const uint32_t RTC_RTC_CALR_RST       = 0x00000000U;   /** @brief RTC_CALR register reset value. */
    static const uint32_t RTC_RTC_TAMPCR_RST     = 0x00000000U;   /** @brief RTC_TAMPCR register reset value. */
    static const uint32_t RTC_RTC_ALRMASSR_RST   = 0x00000000U;   /** @brief RTC_ALRMASSR register reset value. */
    static const uint32_t RTC_RTC_ALRMBSSR_RST   = 0x00000000U;   /** @brief RTC_ALRMBSSR register reset value. */
    static const uint32_t RTC_RTC_OR_RST         = 0x00000000U;   /** @brief RTC_OR register reset value. */

    /**** @subsection Enumerated RTC Register Reset Values ****/

    static const uint32_t RTC_RTC_BKPxR_RST[32] = {
      [0]  = 0x00000000U,   /** @brief RTC_BKP0R register reset value. */
      [1]  = 0x00000000U,   /** @brief RTC_BKP1R register reset value. */
      [2]  = 0x00000000U,   /** @brief RTC_BKP2R register reset value. */
      [3]  = 0x00000000U,   /** @brief RTC_BKP3R register reset value. */
      [4]  = 0x00000000U,   /** @brief RTC_BKP4R register reset value. */
      [5]  = 0x00000000U,   /** @brief RTC_BKP5R register reset value. */
      [6]  = 0x00000000U,   /** @brief RTC_BKP6R register reset value. */
      [7]  = 0x00000000U,   /** @brief RTC_BKP7R register reset value. */
      [8]  = 0x00000000U,   /** @brief RTC_BKP8R register reset value. */
      [9]  = 0x00000000U,   /** @brief RTC_BKP9R register reset value. */
      [10] = 0x00000000U,   /** @brief RTC_BKP10R register reset value. */
      [11] = 0x00000000U,   /** @brief RTC_BKP11R register reset value. */
      [12] = 0x00000000U,   /** @brief RTC_BKP12R register reset value. */
      [13] = 0x00000000U,   /** @brief RTC_BKP13R register reset value. */
      [14] = 0x00000000U,   /** @brief RTC_BKP14R register reset value. */
      [15] = 0x00000000U,   /** @brief RTC_BKP15R register reset value. */
      [16] = 0x00000000U,   /** @brief RTC_BKP16R register reset value. */
      [17] = 0x00000000U,   /** @brief RTC_BKP17R register reset value. */
      [18] = 0x00000000U,   /** @brief RTC_BKP18R register reset value. */
      [19] = 0x00000000U,   /** @brief RTC_BKP19R register reset value. */
      [20] = 0x00000000U,   /** @brief RTC_BKP20R register reset value. */
      [21] = 0x00000000U,   /** @brief RTC_BKP21R register reset value. */
      [22] = 0x00000000U,   /** @brief RTC_BKP22R register reset value. */
      [23] = 0x00000000U,   /** @brief RTC_BKP23R register reset value. */
      [24] = 0x00000000U,   /** @brief RTC_BKP24R register reset value. */
      [25] = 0x00000000U,   /** @brief RTC_BKP25R register reset value. */
      [26] = 0x00000000U,   /** @brief RTC_BKP26R register reset value. */
      [27] = 0x00000000U,   /** @brief RTC_BKP27R register reset value. */
      [28] = 0x00000000U,   /** @brief RTC_BKP28R register reset value. */
      [29] = 0x00000000U,   /** @brief RTC_BKP29R register reset value. */
      [30] = 0x00000000U,   /** @brief RTC_BKP30R register reset value. */
      [31] = 0x00000000U,   /** @brief RTC_BKP31R register reset value. */
    };

    /**** @subsection Enumerated RTC Register Value Types ****/

    typedef uint32_t RTC_RTC_TR_t;         /** @brief RTC_TR register value type. */
    typedef uint32_t RTC_RTC_DR_t;         /** @brief RTC_DR register value type. */
    typedef uint32_t RTC_RTC_CR_t;         /** @brief RTC_CR register value type. */
    typedef uint32_t RTC_RTC_ISR_t;        /** @brief RTC_ISR register value type. */
    typedef uint32_t RTC_RTC_PRER_t;       /** @brief RTC_PRER register value type. */
    typedef uint32_t RTC_RTC_WUTR_t;       /** @brief RTC_WUTR register value type. */
    typedef uint32_t RTC_RTC_ALRMAR_t;     /** @brief RTC_ALRMAR register value type. */
    typedef uint32_t RTC_RTC_ALRMBR_t;     /** @brief RTC_ALRMBR register value type. */
    typedef uint32_t RTC_RTC_WPR_t;        /** @brief RTC_WPR register value type. */
    typedef uint32_t RTC_RTC_SSR_t;        /** @brief RTC_SSR register value type. */
    typedef uint32_t RTC_RTC_SHIFTR_t;     /** @brief RTC_SHIFTR register value type. */
    typedef uint32_t RTC_RTC_TSTR_t;       /** @brief RTC_TSTR register value type. */
    typedef uint32_t RTC_RTC_TSDR_t;       /** @brief RTC_TSDR register value type. */
    typedef uint32_t RTC_RTC_TSSSR_t;      /** @brief RTC_TSSSR register value type. */
    typedef uint32_t RTC_RTC_CALR_t;       /** @brief RTC_CALR register value type. */
    typedef uint32_t RTC_RTC_TAMPCR_t;     /** @brief RTC_TAMPCR register value type. */
    typedef uint32_t RTC_RTC_ALRMASSR_t;   /** @brief RTC_ALRMASSR register value type. */
    typedef uint32_t RTC_RTC_ALRMBSSR_t;   /** @brief RTC_ALRMBSSR register value type. */
    typedef uint32_t RTC_RTC_BKPxR_t;      /** @brief RTC_BKPxR register value type. */
    typedef uint32_t RTC_RTC_OR_t;         /** @brief RTC_OR register value type. */

    /**** @subsection Enumerated RTC Register Pointer Types ****/

    typedef uint32_t* const RTC_RTC_TR_PTR_t;         /** @brief RTC_TR register pointer type. */
    typedef uint32_t* const RTC_RTC_DR_PTR_t;         /** @brief RTC_DR register pointer type. */
    typedef uint32_t* const RTC_RTC_CR_PTR_t;         /** @brief RTC_CR register pointer type. */
    typedef uint32_t* const RTC_RTC_ISR_PTR_t;        /** @brief RTC_ISR register pointer type. */
    typedef uint32_t* const RTC_RTC_PRER_PTR_t;       /** @brief RTC_PRER register pointer type. */
    typedef uint32_t* const RTC_RTC_WUTR_PTR_t;       /** @brief RTC_WUTR register pointer type. */
    typedef uint32_t* const RTC_RTC_ALRMAR_PTR_t;     /** @brief RTC_ALRMAR register pointer type. */
    typedef uint32_t* const RTC_RTC_ALRMBR_PTR_t;     /** @brief RTC_ALRMBR register pointer type. */
    typedef uint32_t* const RTC_RTC_WPR_PTR_t;        /** @brief RTC_WPR register pointer type. */
    typedef uint32_t* const RTC_RTC_SSR_PTR_t;        /** @brief RTC_SSR register pointer type. */
    typedef uint32_t* const RTC_RTC_SHIFTR_PTR_t;     /** @brief RTC_SHIFTR register pointer type. */
    typedef uint32_t* const RTC_RTC_TSTR_PTR_t;       /** @brief RTC_TSTR register pointer type. */
    typedef uint32_t* const RTC_RTC_TSDR_PTR_t;       /** @brief RTC_TSDR register pointer type. */
    typedef uint32_t* const RTC_RTC_TSSSR_PTR_t;      /** @brief RTC_TSSSR register pointer type. */
    typedef uint32_t* const RTC_RTC_CALR_PTR_t;       /** @brief RTC_CALR register pointer type. */
    typedef uint32_t* const RTC_RTC_TAMPCR_PTR_t;     /** @brief RTC_TAMPCR register pointer type. */
    typedef uint32_t* const RTC_RTC_ALRMASSR_PTR_t;   /** @brief RTC_ALRMASSR register pointer type. */
    typedef uint32_t* const RTC_RTC_ALRMBSSR_PTR_t;   /** @brief RTC_ALRMBSSR register pointer type. */
    typedef uint32_t* const RTC_RTC_BKPxR_PTR_t;      /** @brief RTC_BKPxR register pointer type. */
    typedef uint32_t* const RTC_RTC_OR_PTR_t;         /** @brief RTC_OR register pointer type. */

    /**** @subsection RTC Register Field Masks ****/

    static const uint32_t RTC_RTC_TR_SU_MASK               = 0x0000000FU;   /** @brief Second units in BCD format */
    static const uint32_t RTC_RTC_TR_ST_MASK               = 0x00000070U;   /** @brief Second tens in BCD format */
    static const uint32_t RTC_RTC_TR_MNU_MASK              = 0x00000F00U;   /** @brief Minute units in BCD format */
    static const uint32_t RTC_RTC_TR_MNT_MASK              = 0x00007000U;   /** @brief Minute tens in BCD format */
    static const uint32_t RTC_RTC_TR_HU_MASK               = 0x000F0000U;   /** @brief Hour units in BCD format */
    static const uint32_t RTC_RTC_TR_HT_MASK               = 0x00300000U;   /** @brief Hour tens in BCD format */
    static const uint32_t RTC_RTC_TR_PM_MASK               = 0x00400000U;   /** @brief AM/PM notation */
    static const uint32_t RTC_RTC_DR_DU_MASK               = 0x0000000FU;   /** @brief Date units in BCD format */
    static const uint32_t RTC_RTC_DR_DT_MASK               = 0x00000030U;   /** @brief Date tens in BCD format */
    static const uint32_t RTC_RTC_DR_MU_MASK               = 0x00000F00U;   /** @brief Month units in BCD format */
    static const uint32_t RTC_RTC_DR_MT_MASK               = 0x00001000U;   /** @brief Month tens in BCD format */
    static const uint32_t RTC_RTC_DR_WDU_MASK              = 0x0000E000U;   /** @brief Week day units */
    static const uint32_t RTC_RTC_DR_YU_MASK               = 0x000F0000U;   /** @brief Year units in BCD format */
    static const uint32_t RTC_RTC_DR_YT_MASK               = 0x00F00000U;   /** @brief Year tens in BCD format */
    static const uint32_t RTC_RTC_CR_WUCKSEL_MASK          = 0x00000007U;   /** @brief Wakeup clock selection */
    static const uint32_t RTC_RTC_CR_TSEDGE_MASK           = 0x00000008U;   /** @brief Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting. */
    static const uint32_t RTC_RTC_CR_REFCKON_MASK          = 0x00000010U;   /** @brief RTC_REFIN reference clock detection enable (50 or 60hz) note: PREDIV_S must be 0x00ff. */
    static const uint32_t RTC_RTC_CR_BYPSHAD_MASK          = 0x00000020U;   /** @brief Bypass the shadow registers note: if the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1. */
    static const uint32_t RTC_RTC_CR_FMT_MASK              = 0x00000040U;   /** @brief Hour format */
    static const uint32_t RTC_RTC_CR_ALRAE_MASK            = 0x00000100U;   /** @brief Alarm A enable */
    static const uint32_t RTC_RTC_CR_ALRBE_MASK            = 0x00000200U;   /** @brief Alarm B enable */
    static const uint32_t RTC_RTC_CR_WUTE_MASK             = 0x00000400U;   /** @brief Wakeup timer enable */
    static const uint32_t RTC_RTC_CR_TSE_MASK              = 0x00000800U;   /** @brief Timestamp enable */
    static const uint32_t RTC_RTC_CR_ALRAIE_MASK           = 0x00001000U;   /** @brief Alarm A interrupt enable */
    static const uint32_t RTC_RTC_CR_ALRBIE_MASK           = 0x00002000U;   /** @brief Alarm B interrupt enable */
    static const uint32_t RTC_RTC_CR_WUTIE_MASK            = 0x00004000U;   /** @brief Wakeup timer interrupt enable */
    static const uint32_t RTC_RTC_CR_TSIE_MASK             = 0x00008000U;   /** @brief Time-stamp interrupt enable */
    static const uint32_t RTC_RTC_CR_ADD1H_MASK            = 0x00010000U;   /** @brief Add 1 hour (summer time change) when this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0. */
    static const uint32_t RTC_RTC_CR_SUB1H_MASK            = 0x00020000U;   /** @brief Subtract 1 hour (winter time change) when this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0. */
    static const uint32_t RTC_RTC_CR_BKP_MASK              = 0x00040000U;   /** @brief Backup this bit can be written by the user to memorize whether the daylight saving time change has been performed or not. */
    static const uint32_t RTC_RTC_CR_COSEL_MASK            = 0x00080000U;   /** @brief Calibration output selection when COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 khz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to section24.3.15: calibration clock output */
    static const uint32_t RTC_RTC_CR_POL_MASK              = 0x00100000U;   /** @brief Output polarity this bit is used to configure the polarity of RTC_ALARM output */
    static const uint32_t RTC_RTC_CR_OSEL_MASK             = 0x00600000U;   /** @brief Output selection these bits are used to select the flag to be routed to RTC_ALARM output */
    static const uint32_t RTC_RTC_CR_COE_MASK              = 0x00800000U;   /** @brief Calibration output enable this bit enables the RTC_CALIB output */
    static const uint32_t RTC_RTC_CR_ITSE_MASK             = 0x01000000U;   /** @brief Timestamp on internal event enable */
    static const uint32_t RTC_RTC_ISR_ALRAWF_MASK          = 0x00000001U;   /** @brief Alarm A write flag this bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const uint32_t RTC_RTC_ISR_ALRBWF_MASK          = 0x00000002U;   /** @brief Alarm B write flag this bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const uint32_t RTC_RTC_ISR_WUTWF_MASK           = 0x00000004U;   /** @brief Wakeup timer write flag this bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set. */
    static const uint32_t RTC_RTC_ISR_SHPF_MASK            = 0x00000008U;   /** @brief Shift operation pending this flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect. */
    static const uint32_t RTC_RTC_ISR_INITS_MASK           = 0x00000010U;   /** @brief Initialization status flag this bit is set by hardware when the calendar year field is different from 0 (backup domain reset state). */
    static const uint32_t RTC_RTC_ISR_RSF_MASK             = 0x00000020U;   /** @brief Registers synchronization flag this bit is set by hardware each time the calendar registers are copied into the shadow registers (rtc_ssrx, rtc_trx and rtc_drx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode. */
    static const uint32_t RTC_RTC_ISR_INITF_MASK           = 0x00000040U;   /** @brief Initialization flag when this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated. */
    static const uint32_t RTC_RTC_ISR_INIT_MASK            = 0x00000080U;   /** @brief Initialization mode */
    static const uint32_t RTC_RTC_ISR_ALRAF_MASK           = 0x00000100U;   /** @brief Alarm A flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0. */
    static const uint32_t RTC_RTC_ISR_ALRBF_MASK           = 0x00000200U;   /** @brief Alarm B flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0. */
    static const uint32_t RTC_RTC_ISR_WUTF_MASK            = 0x00000400U;   /** @brief Wakeup timer flag this flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again. */
    static const uint32_t RTC_RTC_ISR_TSF_MASK             = 0x00000800U;   /** @brief Time-stamp flag this flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0. */
    static const uint32_t RTC_RTC_ISR_TSOVF_MASK           = 0x00001000U;   /** @brief Time-stamp overflow flag this flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared. */
    static const uint32_t RTC_RTC_ISR_RECALPF_MASK         = 0x00010000U;   /** @brief Recalibration pending flag the RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to re-calibration on-the-fly. */
    static const uint32_t RTC_RTC_ISR_ITSF_MASK            = 0x00020000U;   /** @brief Internal ttime-stamp flag */
    static const uint32_t RTC_RTC_PRER_PREDIV_S_MASK       = 0x00007FFFU;   /** @brief Synchronous prescaler factor this is the synchronous division factor: ck_spre frequency = ck_apre frequency/(prediv_s+1) */
    static const uint32_t RTC_RTC_PRER_PREDIV_A_MASK       = 0x007F0000U;   /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1) */
    static const uint32_t RTC_RTC_WUTR_WUT_MASK            = 0x0000FFFFU;   /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
    static const uint32_t RTC_RTC_ALRMAR_SU_MASK           = 0x0000000FU;   /** @brief Second units in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_ST_MASK           = 0x00000070U;   /** @brief Second tens in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_MNU_MASK          = 0x00000F00U;   /** @brief Minute units in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_MNT_MASK          = 0x00007000U;   /** @brief Minute tens in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_HU_MASK           = 0x000F0000U;   /** @brief Hour units in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_HT_MASK           = 0x00300000U;   /** @brief Hour tens in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_PM_MASK           = 0x00400000U;   /** @brief AM/PM notation */
    static const uint32_t RTC_RTC_ALRMAR_DU_MASK           = 0x0F000000U;   /** @brief Date units or day in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_DT_MASK           = 0x30000000U;   /** @brief Date tens in BCD format. */
    static const uint32_t RTC_RTC_ALRMAR_WDSEL_MASK        = 0x40000000U;   /** @brief Week day selection */
    static const uint32_t RTC_RTC_ALRMBR_SU_MASK           = 0x0000000FU;   /** @brief Second units in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_ST_MASK           = 0x00000070U;   /** @brief Second tens in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_MNU_MASK          = 0x00000F00U;   /** @brief Minute units in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_MNT_MASK          = 0x00007000U;   /** @brief Minute tens in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_HU_MASK           = 0x000F0000U;   /** @brief Hour units in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_HT_MASK           = 0x00300000U;   /** @brief Hour tens in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_PM_MASK           = 0x00400000U;   /** @brief AM/PM notation */
    static const uint32_t RTC_RTC_ALRMBR_DU_MASK           = 0x0F000000U;   /** @brief Date units or day in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_DT_MASK           = 0x30000000U;   /** @brief Date tens in BCD format */
    static const uint32_t RTC_RTC_ALRMBR_WDSEL_MASK        = 0x40000000U;   /** @brief Week day selection */
    static const uint32_t RTC_RTC_WPR_KEY_MASK             = 0x000000FFU;   /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
    static const uint32_t RTC_RTC_SSR_SS_MASK              = 0x0000FFFFU;   /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
    static const uint32_t RTC_RTC_SHIFTR_SUBFS_MASK        = 0x00007FFFU;   /** @brief Subtract a fraction of a second these bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. */
    static const uint32_t RTC_RTC_SHIFTR_ADD1S_MASK        = 0x80000000U;   /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
    static const uint32_t RTC_RTC_TSTR_SU_MASK             = 0x0000000FU;   /** @brief Second units in BCD format. */
    static const uint32_t RTC_RTC_TSTR_ST_MASK             = 0x00000070U;   /** @brief Second tens in BCD format. */
    static const uint32_t RTC_RTC_TSTR_MNU_MASK            = 0x00000F00U;   /** @brief Minute units in BCD format. */
    static const uint32_t RTC_RTC_TSTR_MNT_MASK            = 0x00007000U;   /** @brief Minute tens in BCD format. */
    static const uint32_t RTC_RTC_TSTR_HU_MASK             = 0x000F0000U;   /** @brief Hour units in BCD format. */
    static const uint32_t RTC_RTC_TSTR_HT_MASK             = 0x00300000U;   /** @brief Hour tens in BCD format. */
    static const uint32_t RTC_RTC_TSTR_PM_MASK             = 0x00400000U;   /** @brief AM/PM notation */
    static const uint32_t RTC_RTC_TSDR_DU_MASK             = 0x0000000FU;   /** @brief Date units in BCD format */
    static const uint32_t RTC_RTC_TSDR_DT_MASK             = 0x00000030U;   /** @brief Date tens in BCD format */
    static const uint32_t RTC_RTC_TSDR_MU_MASK             = 0x00000F00U;   /** @brief Month units in BCD format */
    static const uint32_t RTC_RTC_TSDR_MT_MASK             = 0x00001000U;   /** @brief Month tens in BCD format */
    static const uint32_t RTC_RTC_TSDR_WDU_MASK            = 0x0000E000U;   /** @brief Week day units */
    static const uint32_t RTC_RTC_TSSSR_SS_MASK            = 0x0000FFFFU;   /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
    static const uint32_t RTC_RTC_CALR_CALM_MASK           = 0x000001FFU;   /** @brief Calibration minus the frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See section24.3.12: RTC smooth digital calibration on page13. */
    static const uint32_t RTC_RTC_CALR_CALP_MASK           = 0x00008000U;   /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
    static const uint32_t RTC_RTC_TAMPCR_TAMPIE_MASK       = 0x00000004U;   /** @brief Tamper interrupt enable */
    static const uint32_t RTC_RTC_TAMPCR_TAMPTS_MASK       = 0x00000080U;   /** @brief Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register. */
    static const uint32_t RTC_RTC_TAMPCR_TAMPFREQ_MASK     = 0x00000700U;   /** @brief Tamper sampling frequency determines the frequency at which each of the rtc_tampx inputs are sampled. */
    static const uint32_t RTC_RTC_TAMPCR_TAMPFLT_MASK      = 0x00001800U;   /** @brief RTC_TAMPx filter count these bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the rtc_tampx inputs. */
    static const uint32_t RTC_RTC_TAMPCR_TAMPPRCH_MASK     = 0x00006000U;   /** @brief RTC_TAMPx precharge duration these bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the rtc_tampx inputs. */
    static const uint32_t RTC_RTC_TAMPCR_TAMPPUDIS_MASK    = 0x00008000U;   /** @brief RTC_TAMPx pull-up disable this bit determines if each of the rtc_tampx pins are pre-charged before each sample. */
    static const uint32_t RTC_RTC_ALRMASSR_SS_MASK         = 0x00007FFFU;   /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. */
    static const uint32_t RTC_RTC_ALRMASSR_MASKSS_MASK     = 0x0F000000U;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const uint32_t RTC_RTC_ALRMBSSR_SS_MASK         = 0x00007FFFU;   /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. */
    static const uint32_t RTC_RTC_ALRMBSSR_MASKSS_MASK     = 0x0F000000U;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const uint32_t RTC_RTC_OR_RTC_ALARM_TYPE_MASK   = 0x00000001U;   /** @brief RTC_ALARM output type on PC13 */
    static const uint32_t RTC_RTC_OR_RTC_OUT_RMP_MASK      = 0x00000002U;   /** @brief RTC_OUT remap */

    /**** @subsection Enumerated RTC Register Field Masks ****/

    static const uint32_t RTC_RTC_ISR_TAMPxF_MASK[4] = {
      [1] = 0x00002000U,   /** @brief RTC_TAMP1 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0 */
      [2] = 0x00004000U,   /** @brief RTC_TAMP2 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0 */
      [3] = 0x00008000U,   /** @brief RTC_TAMP3 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0 */
    };

    static const uint32_t RTC_RTC_ALRMAR_MSKx_MASK[5] = {
      [1] = 0x00000080U,   /** @brief Alarm A seconds mask */
      [2] = 0x00008000U,   /** @brief Alarm A minutes mask */
      [3] = 0x00800000U,   /** @brief Alarm A hours mask */
      [4] = 0x80000000U,   /** @brief Alarm A date mask */
    };

    static const uint32_t RTC_RTC_CALR_CALWx_MASK[17] = {
      [8]  = 0x00004000U,   /** @brief Use an 8-second calibration cycle period when CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to section24.3.12: RTC smooth digital calibration. */
      [16] = 0x00002000U,   /** @brief Use a 16-second calibration cycle period when CALW16 is set to 1, the 16-second calibration cycle period is selected.this bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    };

    static const uint32_t RTC_RTC_TAMPCR_TAMPxE_MASK[4] = {
      [1] = 0x00000001U,   /** @brief RTC_TAMP1 input detection enable */
      [2] = 0x00000008U,   /** @brief RTC_TAMP2 input detection enable */
      [3] = 0x00000020U,   /** @brief RTC_TAMP3 detection enable */
    };

    static const uint32_t RTC_RTC_TAMPCR_TAMPxTRG_MASK[4] = {
      [1] = 0x00000002U,   /** @brief Active level for RTC_TAMP1 input if TAMPFLT != 00 if TAMPFLT = 00: */
      [2] = 0x00000010U,   /** @brief Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00: */
      [3] = 0x00000040U,   /** @brief Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00: */
    };

    static const uint32_t RTC_RTC_TAMPCR_TAMPxIE_MASK[4] = {
      [1] = 0x00010000U,   /** @brief Tamper 1 interrupt enable */
      [2] = 0x00080000U,   /** @brief Tamper 2 interrupt enable */
      [3] = 0x00400000U,   /** @brief Tamper 3 interrupt enable */
    };

    static const uint32_t RTC_RTC_TAMPCR_TAMPxNOERASE_MASK[4] = {
      [1] = 0x00020000U,   /** @brief Tamper 1 no erase */
      [2] = 0x00100000U,   /** @brief Tamper 2 no erase */
      [3] = 0x00800000U,   /** @brief Tamper 3 no erase */
    };

    static const uint32_t RTC_RTC_TAMPCR_TAMPxMF_MASK[4] = {
      [1] = 0x00040000U,   /** @brief Tamper 1 mask flag */
      [2] = 0x00200000U,   /** @brief Tamper 2 mask flag */
      [3] = 0x01000000U,   /** @brief Tamper 3 mask flag */
    };

    /**** @subsection RTC Register Field Positions ****/

    static const int32_t RTC_RTC_TR_SU_POS               = 0;    /** @brief Second units in BCD format */
    static const int32_t RTC_RTC_TR_ST_POS               = 4;    /** @brief Second tens in BCD format */
    static const int32_t RTC_RTC_TR_MNU_POS              = 8;    /** @brief Minute units in BCD format */
    static const int32_t RTC_RTC_TR_MNT_POS              = 12;   /** @brief Minute tens in BCD format */
    static const int32_t RTC_RTC_TR_HU_POS               = 16;   /** @brief Hour units in BCD format */
    static const int32_t RTC_RTC_TR_HT_POS               = 20;   /** @brief Hour tens in BCD format */
    static const int32_t RTC_RTC_TR_PM_POS               = 22;   /** @brief AM/PM notation */
    static const int32_t RTC_RTC_DR_DU_POS               = 0;    /** @brief Date units in BCD format */
    static const int32_t RTC_RTC_DR_DT_POS               = 4;    /** @brief Date tens in BCD format */
    static const int32_t RTC_RTC_DR_MU_POS               = 8;    /** @brief Month units in BCD format */
    static const int32_t RTC_RTC_DR_MT_POS               = 12;   /** @brief Month tens in BCD format */
    static const int32_t RTC_RTC_DR_WDU_POS              = 13;   /** @brief Week day units */
    static const int32_t RTC_RTC_DR_YU_POS               = 16;   /** @brief Year units in BCD format */
    static const int32_t RTC_RTC_DR_YT_POS               = 20;   /** @brief Year tens in BCD format */
    static const int32_t RTC_RTC_CR_WUCKSEL_POS          = 0;    /** @brief Wakeup clock selection */
    static const int32_t RTC_RTC_CR_TSEDGE_POS           = 3;    /** @brief Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting. */
    static const int32_t RTC_RTC_CR_REFCKON_POS          = 4;    /** @brief RTC_REFIN reference clock detection enable (50 or 60hz) note: PREDIV_S must be 0x00ff. */
    static const int32_t RTC_RTC_CR_BYPSHAD_POS          = 5;    /** @brief Bypass the shadow registers note: if the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1. */
    static const int32_t RTC_RTC_CR_FMT_POS              = 6;    /** @brief Hour format */
    static const int32_t RTC_RTC_CR_ALRAE_POS            = 8;    /** @brief Alarm A enable */
    static const int32_t RTC_RTC_CR_ALRBE_POS            = 9;    /** @brief Alarm B enable */
    static const int32_t RTC_RTC_CR_WUTE_POS             = 10;   /** @brief Wakeup timer enable */
    static const int32_t RTC_RTC_CR_TSE_POS              = 11;   /** @brief Timestamp enable */
    static const int32_t RTC_RTC_CR_ALRAIE_POS           = 12;   /** @brief Alarm A interrupt enable */
    static const int32_t RTC_RTC_CR_ALRBIE_POS           = 13;   /** @brief Alarm B interrupt enable */
    static const int32_t RTC_RTC_CR_WUTIE_POS            = 14;   /** @brief Wakeup timer interrupt enable */
    static const int32_t RTC_RTC_CR_TSIE_POS             = 15;   /** @brief Time-stamp interrupt enable */
    static const int32_t RTC_RTC_CR_ADD1H_POS            = 16;   /** @brief Add 1 hour (summer time change) when this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0. */
    static const int32_t RTC_RTC_CR_SUB1H_POS            = 17;   /** @brief Subtract 1 hour (winter time change) when this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0. */
    static const int32_t RTC_RTC_CR_BKP_POS              = 18;   /** @brief Backup this bit can be written by the user to memorize whether the daylight saving time change has been performed or not. */
    static const int32_t RTC_RTC_CR_COSEL_POS            = 19;   /** @brief Calibration output selection when COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 khz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to section24.3.15: calibration clock output */
    static const int32_t RTC_RTC_CR_POL_POS              = 20;   /** @brief Output polarity this bit is used to configure the polarity of RTC_ALARM output */
    static const int32_t RTC_RTC_CR_OSEL_POS             = 21;   /** @brief Output selection these bits are used to select the flag to be routed to RTC_ALARM output */
    static const int32_t RTC_RTC_CR_COE_POS              = 23;   /** @brief Calibration output enable this bit enables the RTC_CALIB output */
    static const int32_t RTC_RTC_CR_ITSE_POS             = 24;   /** @brief Timestamp on internal event enable */
    static const int32_t RTC_RTC_ISR_ALRAWF_POS          = 0;    /** @brief Alarm A write flag this bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const int32_t RTC_RTC_ISR_ALRBWF_POS          = 1;    /** @brief Alarm B write flag this bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const int32_t RTC_RTC_ISR_WUTWF_POS           = 2;    /** @brief Wakeup timer write flag this bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set. */
    static const int32_t RTC_RTC_ISR_SHPF_POS            = 3;    /** @brief Shift operation pending this flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect. */
    static const int32_t RTC_RTC_ISR_INITS_POS           = 4;    /** @brief Initialization status flag this bit is set by hardware when the calendar year field is different from 0 (backup domain reset state). */
    static const int32_t RTC_RTC_ISR_RSF_POS             = 5;    /** @brief Registers synchronization flag this bit is set by hardware each time the calendar registers are copied into the shadow registers (rtc_ssrx, rtc_trx and rtc_drx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode. */
    static const int32_t RTC_RTC_ISR_INITF_POS           = 6;    /** @brief Initialization flag when this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated. */
    static const int32_t RTC_RTC_ISR_INIT_POS            = 7;    /** @brief Initialization mode */
    static const int32_t RTC_RTC_ISR_ALRAF_POS           = 8;    /** @brief Alarm A flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0. */
    static const int32_t RTC_RTC_ISR_ALRBF_POS           = 9;    /** @brief Alarm B flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0. */
    static const int32_t RTC_RTC_ISR_WUTF_POS            = 10;   /** @brief Wakeup timer flag this flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again. */
    static const int32_t RTC_RTC_ISR_TSF_POS             = 11;   /** @brief Time-stamp flag this flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0. */
    static const int32_t RTC_RTC_ISR_TSOVF_POS           = 12;   /** @brief Time-stamp overflow flag this flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared. */
    static const int32_t RTC_RTC_ISR_RECALPF_POS         = 16;   /** @brief Recalibration pending flag the RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to re-calibration on-the-fly. */
    static const int32_t RTC_RTC_ISR_ITSF_POS            = 17;   /** @brief Internal ttime-stamp flag */
    static const int32_t RTC_RTC_PRER_PREDIV_S_POS       = 0;    /** @brief Synchronous prescaler factor this is the synchronous division factor: ck_spre frequency = ck_apre frequency/(prediv_s+1) */
    static const int32_t RTC_RTC_PRER_PREDIV_A_POS       = 16;   /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1) */
    static const int32_t RTC_RTC_WUTR_WUT_POS            = 0;    /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
    static const int32_t RTC_RTC_ALRMAR_SU_POS           = 0;    /** @brief Second units in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_ST_POS           = 4;    /** @brief Second tens in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_MNU_POS          = 8;    /** @brief Minute units in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_MNT_POS          = 12;   /** @brief Minute tens in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_HU_POS           = 16;   /** @brief Hour units in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_HT_POS           = 20;   /** @brief Hour tens in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_PM_POS           = 22;   /** @brief AM/PM notation */
    static const int32_t RTC_RTC_ALRMAR_DU_POS           = 24;   /** @brief Date units or day in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_DT_POS           = 28;   /** @brief Date tens in BCD format. */
    static const int32_t RTC_RTC_ALRMAR_WDSEL_POS        = 30;   /** @brief Week day selection */
    static const int32_t RTC_RTC_ALRMBR_SU_POS           = 0;    /** @brief Second units in BCD format */
    static const int32_t RTC_RTC_ALRMBR_ST_POS           = 4;    /** @brief Second tens in BCD format */
    static const int32_t RTC_RTC_ALRMBR_MNU_POS          = 8;    /** @brief Minute units in BCD format */
    static const int32_t RTC_RTC_ALRMBR_MNT_POS          = 12;   /** @brief Minute tens in BCD format */
    static const int32_t RTC_RTC_ALRMBR_HU_POS           = 16;   /** @brief Hour units in BCD format */
    static const int32_t RTC_RTC_ALRMBR_HT_POS           = 20;   /** @brief Hour tens in BCD format */
    static const int32_t RTC_RTC_ALRMBR_PM_POS           = 22;   /** @brief AM/PM notation */
    static const int32_t RTC_RTC_ALRMBR_DU_POS           = 24;   /** @brief Date units or day in BCD format */
    static const int32_t RTC_RTC_ALRMBR_DT_POS           = 28;   /** @brief Date tens in BCD format */
    static const int32_t RTC_RTC_ALRMBR_WDSEL_POS        = 30;   /** @brief Week day selection */
    static const int32_t RTC_RTC_WPR_KEY_POS             = 0;    /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
    static const int32_t RTC_RTC_SSR_SS_POS              = 0;    /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
    static const int32_t RTC_RTC_SHIFTR_SUBFS_POS        = 0;    /** @brief Subtract a fraction of a second these bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. */
    static const int32_t RTC_RTC_SHIFTR_ADD1S_POS        = 31;   /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
    static const int32_t RTC_RTC_TSTR_SU_POS             = 0;    /** @brief Second units in BCD format. */
    static const int32_t RTC_RTC_TSTR_ST_POS             = 4;    /** @brief Second tens in BCD format. */
    static const int32_t RTC_RTC_TSTR_MNU_POS            = 8;    /** @brief Minute units in BCD format. */
    static const int32_t RTC_RTC_TSTR_MNT_POS            = 12;   /** @brief Minute tens in BCD format. */
    static const int32_t RTC_RTC_TSTR_HU_POS             = 16;   /** @brief Hour units in BCD format. */
    static const int32_t RTC_RTC_TSTR_HT_POS             = 20;   /** @brief Hour tens in BCD format. */
    static const int32_t RTC_RTC_TSTR_PM_POS             = 22;   /** @brief AM/PM notation */
    static const int32_t RTC_RTC_TSDR_DU_POS             = 0;    /** @brief Date units in BCD format */
    static const int32_t RTC_RTC_TSDR_DT_POS             = 4;    /** @brief Date tens in BCD format */
    static const int32_t RTC_RTC_TSDR_MU_POS             = 8;    /** @brief Month units in BCD format */
    static const int32_t RTC_RTC_TSDR_MT_POS             = 12;   /** @brief Month tens in BCD format */
    static const int32_t RTC_RTC_TSDR_WDU_POS            = 13;   /** @brief Week day units */
    static const int32_t RTC_RTC_TSSSR_SS_POS            = 0;    /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
    static const int32_t RTC_RTC_CALR_CALM_POS           = 0;    /** @brief Calibration minus the frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See section24.3.12: RTC smooth digital calibration on page13. */
    static const int32_t RTC_RTC_CALR_CALP_POS           = 15;   /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
    static const int32_t RTC_RTC_TAMPCR_TAMPIE_POS       = 2;    /** @brief Tamper interrupt enable */
    static const int32_t RTC_RTC_TAMPCR_TAMPTS_POS       = 7;    /** @brief Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register. */
    static const int32_t RTC_RTC_TAMPCR_TAMPFREQ_POS     = 8;    /** @brief Tamper sampling frequency determines the frequency at which each of the rtc_tampx inputs are sampled. */
    static const int32_t RTC_RTC_TAMPCR_TAMPFLT_POS      = 11;   /** @brief RTC_TAMPx filter count these bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the rtc_tampx inputs. */
    static const int32_t RTC_RTC_TAMPCR_TAMPPRCH_POS     = 13;   /** @brief RTC_TAMPx precharge duration these bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the rtc_tampx inputs. */
    static const int32_t RTC_RTC_TAMPCR_TAMPPUDIS_POS    = 15;   /** @brief RTC_TAMPx pull-up disable this bit determines if each of the rtc_tampx pins are pre-charged before each sample. */
    static const int32_t RTC_RTC_ALRMASSR_SS_POS         = 0;    /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. */
    static const int32_t RTC_RTC_ALRMASSR_MASKSS_POS     = 24;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const int32_t RTC_RTC_ALRMBSSR_SS_POS         = 0;    /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. */
    static const int32_t RTC_RTC_ALRMBSSR_MASKSS_POS     = 24;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const int32_t RTC_RTC_OR_RTC_ALARM_TYPE_POS   = 0;    /** @brief RTC_ALARM output type on PC13 */
    static const int32_t RTC_RTC_OR_RTC_OUT_RMP_POS      = 1;    /** @brief RTC_OUT remap */

    /**** @subsection Enumerated RTC Register Field Positions ****/

    static const int32_t RTC_RTC_ISR_TAMPxF_POS[4] = {
      [1] = 13,   /** @brief RTC_TAMP1 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0 */
      [2] = 14,   /** @brief RTC_TAMP2 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0 */
      [3] = 15,   /** @brief RTC_TAMP3 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0 */
    };

    static const int32_t RTC_RTC_ALRMAR_MSKx_POS[5] = {
      [1] = 7,    /** @brief Alarm A seconds mask */
      [2] = 15,   /** @brief Alarm A minutes mask */
      [3] = 23,   /** @brief Alarm A hours mask */
      [4] = 31,   /** @brief Alarm A date mask */
    };

    static const int32_t RTC_RTC_CALR_CALWx_POS[17] = {
      [8]  = 14,   /** @brief Use an 8-second calibration cycle period when CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to section24.3.12: RTC smooth digital calibration. */
      [16] = 13,   /** @brief Use a 16-second calibration cycle period when CALW16 is set to 1, the 16-second calibration cycle period is selected.this bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    };

    static const int32_t RTC_RTC_TAMPCR_TAMPxE_POS[4] = {
      [1] = 0,   /** @brief RTC_TAMP1 input detection enable */
      [2] = 3,   /** @brief RTC_TAMP2 input detection enable */
      [3] = 5,   /** @brief RTC_TAMP3 detection enable */
    };

    static const int32_t RTC_RTC_TAMPCR_TAMPxTRG_POS[4] = {
      [1] = 1,   /** @brief Active level for RTC_TAMP1 input if TAMPFLT != 00 if TAMPFLT = 00: */
      [2] = 4,   /** @brief Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00: */
      [3] = 6,   /** @brief Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00: */
    };

    static const int32_t RTC_RTC_TAMPCR_TAMPxIE_POS[4] = {
      [1] = 16,   /** @brief Tamper 1 interrupt enable */
      [2] = 19,   /** @brief Tamper 2 interrupt enable */
      [3] = 22,   /** @brief Tamper 3 interrupt enable */
    };

    static const int32_t RTC_RTC_TAMPCR_TAMPxNOERASE_POS[4] = {
      [1] = 17,   /** @brief Tamper 1 no erase */
      [2] = 20,   /** @brief Tamper 2 no erase */
      [3] = 23,   /** @brief Tamper 3 no erase */
    };

    static const int32_t RTC_RTC_TAMPCR_TAMPxMF_POS[4] = {
      [1] = 18,   /** @brief Tamper 1 mask flag */
      [2] = 21,   /** @brief Tamper 2 mask flag */
      [3] = 24,   /** @brief Tamper 3 mask flag */
    };

    /**********************************************************************************************
     * @section SAIx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated SAIx Register Pointers ****/

    static RW_ uint32_t* const SAIx_SAI_GCR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015800U,   /** @brief Global configuration register */
      [2] = (RW_ uint32_t* const)0x40015C00U,   /** @brief Global configuration register */
      [3] = (RW_ uint32_t* const)0x40016000U,   /** @brief Global configuration register */
      [4] = (RW_ uint32_t* const)0x58005400U,   /** @brief Global configuration register */
    };

    static RW_ uint32_t* const SAIx_SAI_ACR1_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015804U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40015C04U,   /** @brief Configuration register 1 */
      [3] = (RW_ uint32_t* const)0x40016004U,   /** @brief Configuration register 1 */
      [4] = (RW_ uint32_t* const)0x58005404U,   /** @brief Configuration register 1 */
    };

    static RW_ uint32_t* const SAIx_SAI_ACR2_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015808U,   /** @brief Configuration register 2 */
      [2] = (RW_ uint32_t* const)0x40015C08U,   /** @brief Configuration register 2 */
      [3] = (RW_ uint32_t* const)0x40016008U,   /** @brief Configuration register 2 */
      [4] = (RW_ uint32_t* const)0x58005408U,   /** @brief Configuration register 2 */
    };

    static RW_ uint32_t* const SAIx_SAI_AFRCR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001580CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t* const)0x40015C0CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t* const)0x4001600CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t* const)0x5800540CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_ASLOTR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015810U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t* const)0x40015C10U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t* const)0x40016010U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t* const)0x58005410U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_AIM_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015814U,   /** @brief Interrupt mask register 2 */
      [2] = (RW_ uint32_t* const)0x40015C14U,   /** @brief Interrupt mask register 2 */
      [3] = (RW_ uint32_t* const)0x40016014U,   /** @brief Interrupt mask register 2 */
      [4] = (RW_ uint32_t* const)0x58005414U,   /** @brief Interrupt mask register 2 */
    };

    static RO_ uint32_t* const SAIx_SAI_ASR_PTR[5] = {
      [1] = (RO_ uint32_t* const)0x40015818U,   /** @brief Status register */
      [2] = (RO_ uint32_t* const)0x40015C18U,   /** @brief Status register */
      [3] = (RO_ uint32_t* const)0x40016018U,   /** @brief Status register */
      [4] = (RO_ uint32_t* const)0x58005418U,   /** @brief Status register */
    };

    static RW_ uint32_t* const SAIx_SAI_ACLRFR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001581CU,   /** @brief Clear flag register */
      [2] = (RW_ uint32_t* const)0x40015C1CU,   /** @brief Clear flag register */
      [3] = (RW_ uint32_t* const)0x4001601CU,   /** @brief Clear flag register */
      [4] = (RW_ uint32_t* const)0x5800541CU,   /** @brief Clear flag register */
    };

    static RW_ uint32_t* const SAIx_SAI_ADR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015820U,   /** @brief Data register */
      [2] = (RW_ uint32_t* const)0x40015C20U,   /** @brief Data register */
      [3] = (RW_ uint32_t* const)0x40016020U,   /** @brief Data register */
      [4] = (RW_ uint32_t* const)0x58005420U,   /** @brief Data register */
    };

    static RW_ uint32_t* const SAIx_SAI_BCR1_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015824U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40015C24U,   /** @brief Configuration register 1 */
      [3] = (RW_ uint32_t* const)0x40016024U,   /** @brief Configuration register 1 */
      [4] = (RW_ uint32_t* const)0x58005424U,   /** @brief Configuration register 1 */
    };

    static RW_ uint32_t* const SAIx_SAI_BCR2_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015828U,   /** @brief Configuration register 2 */
      [2] = (RW_ uint32_t* const)0x40015C28U,   /** @brief Configuration register 2 */
      [3] = (RW_ uint32_t* const)0x40016028U,   /** @brief Configuration register 2 */
      [4] = (RW_ uint32_t* const)0x58005428U,   /** @brief Configuration register 2 */
    };

    static RW_ uint32_t* const SAIx_SAI_BFRCR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001582CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t* const)0x40015C2CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t* const)0x4001602CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t* const)0x5800542CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_BSLOTR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015830U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t* const)0x40015C30U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t* const)0x40016030U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t* const)0x58005430U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_BIM_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015834U,   /** @brief Interrupt mask register 2 */
      [2] = (RW_ uint32_t* const)0x40015C34U,   /** @brief Interrupt mask register 2 */
      [3] = (RW_ uint32_t* const)0x40016034U,   /** @brief Interrupt mask register 2 */
      [4] = (RW_ uint32_t* const)0x58005434U,   /** @brief Interrupt mask register 2 */
    };

    static RO_ uint32_t* const SAIx_SAI_BSR_PTR[5] = {
      [1] = (RO_ uint32_t* const)0x40015838U,   /** @brief Status register */
      [2] = (RO_ uint32_t* const)0x40015C38U,   /** @brief Status register */
      [3] = (RO_ uint32_t* const)0x40016038U,   /** @brief Status register */
      [4] = (RO_ uint32_t* const)0x58005438U,   /** @brief Status register */
    };

    static RW_ uint32_t* const SAIx_SAI_BCLRFR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001583CU,   /** @brief Clear flag register */
      [2] = (RW_ uint32_t* const)0x40015C3CU,   /** @brief Clear flag register */
      [3] = (RW_ uint32_t* const)0x4001603CU,   /** @brief Clear flag register */
      [4] = (RW_ uint32_t* const)0x5800543CU,   /** @brief Clear flag register */
    };

    static RW_ uint32_t* const SAIx_SAI_BDR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015840U,   /** @brief Data register */
      [2] = (RW_ uint32_t* const)0x40015C40U,   /** @brief Data register */
      [3] = (RW_ uint32_t* const)0x40016040U,   /** @brief Data register */
      [4] = (RW_ uint32_t* const)0x58005440U,   /** @brief Data register */
    };

    static RW_ uint32_t* const SAIx_SAI_PDMCR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015844U,   /** @brief PDM control register */
      [2] = (RW_ uint32_t* const)0x40015C44U,   /** @brief PDM control register */
      [3] = (RW_ uint32_t* const)0x40016044U,   /** @brief PDM control register */
      [4] = (RW_ uint32_t* const)0x58005444U,   /** @brief PDM control register */
    };

    static RW_ uint32_t* const SAIx_SAI_PDMDLY_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40015848U,   /** @brief PDM delay register */
      [2] = (RW_ uint32_t* const)0x40015C48U,   /** @brief PDM delay register */
      [3] = (RW_ uint32_t* const)0x40016048U,   /** @brief PDM delay register */
      [4] = (RW_ uint32_t* const)0x58005448U,   /** @brief PDM delay register */
    };

    /**** @subsection Enumerated SAIx Register Reset Values ****/

    static const uint32_t SAIx_SAI_GCR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_GCR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_GCR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_GCR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_GCR register reset value */
    };

    static const uint32_t SAIx_SAI_ACR1_RST[5] = {
      [1] = 0x00000040U,   /** @brief SAI_ACR1 register reset value */
      [2] = 0x00000040U,   /** @brief SAI_ACR1 register reset value */
      [3] = 0x00000040U,   /** @brief SAI_ACR1 register reset value */
      [4] = 0x00000040U,   /** @brief SAI_ACR1 register reset value */
    };

    static const uint32_t SAIx_SAI_ACR2_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_ACR2 register reset value */
      [2] = 0x00000000U,   /** @brief SAI_ACR2 register reset value */
      [3] = 0x00000000U,   /** @brief SAI_ACR2 register reset value */
      [4] = 0x00000000U,   /** @brief SAI_ACR2 register reset value */
    };

    static const uint32_t SAIx_SAI_AFRCR_RST[5] = {
      [1] = 0x00000007U,   /** @brief SAI_AFRCR register reset value */
      [2] = 0x00000007U,   /** @brief SAI_AFRCR register reset value */
      [3] = 0x00000007U,   /** @brief SAI_AFRCR register reset value */
      [4] = 0x00000007U,   /** @brief SAI_AFRCR register reset value */
    };

    static const uint32_t SAIx_SAI_ASLOTR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_ASLOTR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_ASLOTR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_ASLOTR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_ASLOTR register reset value */
    };

    static const uint32_t SAIx_SAI_AIM_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_AIM register reset value */
      [2] = 0x00000000U,   /** @brief SAI_AIM register reset value */
      [3] = 0x00000000U,   /** @brief SAI_AIM register reset value */
      [4] = 0x00000000U,   /** @brief SAI_AIM register reset value */
    };

    static const uint32_t SAIx_SAI_ASR_RST[5] = {
      [1] = 0x00000008U,   /** @brief SAI_ASR register reset value */
      [2] = 0x00000008U,   /** @brief SAI_ASR register reset value */
      [3] = 0x00000008U,   /** @brief SAI_ASR register reset value */
      [4] = 0x00000008U,   /** @brief SAI_ASR register reset value */
    };

    static const uint32_t SAIx_SAI_ACLRFR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_ACLRFR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_ACLRFR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_ACLRFR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_ACLRFR register reset value */
    };

    static const uint32_t SAIx_SAI_ADR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_ADR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_ADR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_ADR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_ADR register reset value */
    };

    static const uint32_t SAIx_SAI_BCR1_RST[5] = {
      [1] = 0x00000040U,   /** @brief SAI_BCR1 register reset value */
      [2] = 0x00000040U,   /** @brief SAI_BCR1 register reset value */
      [3] = 0x00000040U,   /** @brief SAI_BCR1 register reset value */
      [4] = 0x00000040U,   /** @brief SAI_BCR1 register reset value */
    };

    static const uint32_t SAIx_SAI_BCR2_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_BCR2 register reset value */
      [2] = 0x00000000U,   /** @brief SAI_BCR2 register reset value */
      [3] = 0x00000000U,   /** @brief SAI_BCR2 register reset value */
      [4] = 0x00000000U,   /** @brief SAI_BCR2 register reset value */
    };

    static const uint32_t SAIx_SAI_BFRCR_RST[5] = {
      [1] = 0x00000007U,   /** @brief SAI_BFRCR register reset value */
      [2] = 0x00000007U,   /** @brief SAI_BFRCR register reset value */
      [3] = 0x00000007U,   /** @brief SAI_BFRCR register reset value */
      [4] = 0x00000007U,   /** @brief SAI_BFRCR register reset value */
    };

    static const uint32_t SAIx_SAI_BSLOTR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_BSLOTR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_BSLOTR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_BSLOTR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_BSLOTR register reset value */
    };

    static const uint32_t SAIx_SAI_BIM_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_BIM register reset value */
      [2] = 0x00000000U,   /** @brief SAI_BIM register reset value */
      [3] = 0x00000000U,   /** @brief SAI_BIM register reset value */
      [4] = 0x00000000U,   /** @brief SAI_BIM register reset value */
    };

    static const uint32_t SAIx_SAI_BSR_RST[5] = {
      [1] = 0x00000008U,   /** @brief SAI_BSR register reset value */
      [2] = 0x00000008U,   /** @brief SAI_BSR register reset value */
      [3] = 0x00000008U,   /** @brief SAI_BSR register reset value */
      [4] = 0x00000008U,   /** @brief SAI_BSR register reset value */
    };

    static const uint32_t SAIx_SAI_BCLRFR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_BCLRFR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_BCLRFR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_BCLRFR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_BCLRFR register reset value */
    };

    static const uint32_t SAIx_SAI_BDR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_BDR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_BDR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_BDR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_BDR register reset value */
    };

    static const uint32_t SAIx_SAI_PDMCR_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_PDMCR register reset value */
      [2] = 0x00000000U,   /** @brief SAI_PDMCR register reset value */
      [3] = 0x00000000U,   /** @brief SAI_PDMCR register reset value */
      [4] = 0x00000000U,   /** @brief SAI_PDMCR register reset value */
    };

    static const uint32_t SAIx_SAI_PDMDLY_RST[5] = {
      [1] = 0x00000000U,   /** @brief SAI_PDMDLY register reset value */
      [2] = 0x00000000U,   /** @brief SAI_PDMDLY register reset value */
      [3] = 0x00000000U,   /** @brief SAI_PDMDLY register reset value */
      [4] = 0x00000000U,   /** @brief SAI_PDMDLY register reset value */
    };

    /**** @subsection Enumerated SAIx Register Value Types ****/

    typedef uint32_t SAIx_SAI_GCR_t;      /** @brief SAI_GCR register value type. */
    typedef uint32_t SAIx_SAI_ACR1_t;     /** @brief SAI_ACR1 register value type. */
    typedef uint32_t SAIx_SAI_ACR2_t;     /** @brief SAI_ACR2 register value type. */
    typedef uint32_t SAIx_SAI_AFRCR_t;    /** @brief SAI_AFRCR register value type. */
    typedef uint32_t SAIx_SAI_ASLOTR_t;   /** @brief SAI_ASLOTR register value type. */
    typedef uint32_t SAIx_SAI_AIM_t;      /** @brief SAI_AIM register value type. */
    typedef uint32_t SAIx_SAI_ASR_t;      /** @brief SAI_ASR register value type. */
    typedef uint32_t SAIx_SAI_ACLRFR_t;   /** @brief SAI_ACLRFR register value type. */
    typedef uint32_t SAIx_SAI_ADR_t;      /** @brief SAI_ADR register value type. */
    typedef uint32_t SAIx_SAI_BCR1_t;     /** @brief SAI_BCR1 register value type. */
    typedef uint32_t SAIx_SAI_BCR2_t;     /** @brief SAI_BCR2 register value type. */
    typedef uint32_t SAIx_SAI_BFRCR_t;    /** @brief SAI_BFRCR register value type. */
    typedef uint32_t SAIx_SAI_BSLOTR_t;   /** @brief SAI_BSLOTR register value type. */
    typedef uint32_t SAIx_SAI_BIM_t;      /** @brief SAI_BIM register value type. */
    typedef uint32_t SAIx_SAI_BSR_t;      /** @brief SAI_BSR register value type. */
    typedef uint32_t SAIx_SAI_BCLRFR_t;   /** @brief SAI_BCLRFR register value type. */
    typedef uint32_t SAIx_SAI_BDR_t;      /** @brief SAI_BDR register value type. */
    typedef uint32_t SAIx_SAI_PDMCR_t;    /** @brief SAI_PDMCR register value type. */
    typedef uint32_t SAIx_SAI_PDMDLY_t;   /** @brief SAI_PDMDLY register value type. */

    /**** @subsection Enumerated SAIx Register Pointer Types ****/

    typedef uint32_t* const SAIx_SAI_GCR_PTR_t;      /** @brief SAI_GCR register pointer type. */
    typedef uint32_t* const SAIx_SAI_ACR1_PTR_t;     /** @brief SAI_ACR1 register pointer type. */
    typedef uint32_t* const SAIx_SAI_ACR2_PTR_t;     /** @brief SAI_ACR2 register pointer type. */
    typedef uint32_t* const SAIx_SAI_AFRCR_PTR_t;    /** @brief SAI_AFRCR register pointer type. */
    typedef uint32_t* const SAIx_SAI_ASLOTR_PTR_t;   /** @brief SAI_ASLOTR register pointer type. */
    typedef uint32_t* const SAIx_SAI_AIM_PTR_t;      /** @brief SAI_AIM register pointer type. */
    typedef uint32_t* const SAIx_SAI_ASR_PTR_t;      /** @brief SAI_ASR register pointer type. */
    typedef uint32_t* const SAIx_SAI_ACLRFR_PTR_t;   /** @brief SAI_ACLRFR register pointer type. */
    typedef uint32_t* const SAIx_SAI_ADR_PTR_t;      /** @brief SAI_ADR register pointer type. */
    typedef uint32_t* const SAIx_SAI_BCR1_PTR_t;     /** @brief SAI_BCR1 register pointer type. */
    typedef uint32_t* const SAIx_SAI_BCR2_PTR_t;     /** @brief SAI_BCR2 register pointer type. */
    typedef uint32_t* const SAIx_SAI_BFRCR_PTR_t;    /** @brief SAI_BFRCR register pointer type. */
    typedef uint32_t* const SAIx_SAI_BSLOTR_PTR_t;   /** @brief SAI_BSLOTR register pointer type. */
    typedef uint32_t* const SAIx_SAI_BIM_PTR_t;      /** @brief SAI_BIM register pointer type. */
    typedef uint32_t* const SAIx_SAI_BSR_PTR_t;      /** @brief SAI_BSR register pointer type. */
    typedef uint32_t* const SAIx_SAI_BCLRFR_PTR_t;   /** @brief SAI_BCLRFR register pointer type. */
    typedef uint32_t* const SAIx_SAI_BDR_PTR_t;      /** @brief SAI_BDR register pointer type. */
    typedef uint32_t* const SAIx_SAI_PDMCR_PTR_t;    /** @brief SAI_PDMCR register pointer type. */
    typedef uint32_t* const SAIx_SAI_PDMDLY_PTR_t;   /** @brief SAI_PDMDLY register pointer type. */

    /**** @subsection SAIx Register Field Masks ****/

    static const uint32_t SAIx_SAI_GCR_SYNCOUT_MASK       = 0x00000030U;   /** @brief Synchronization outputs these bits are set and cleared by software. */
    static const uint32_t SAIx_SAI_GCR_SYNCIN_MASK        = 0x00000003U;   /** @brief Synchronization inputs */
    static const uint32_t SAIx_SAI_ACR1_MODE_MASK         = 0x00000003U;   /** @brief SAIx audio block mode immediately */
    static const uint32_t SAIx_SAI_ACR1_PRTCFG_MASK       = 0x0000000CU;   /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_ACR1_DS_MASK           = 0x000000E0U;   /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_ACR1_LSBFIRST_MASK     = 0x00000100U;   /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const uint32_t SAIx_SAI_ACR1_CKSTR_MASK        = 0x00000200U;   /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const uint32_t SAIx_SAI_ACR1_SYNCEN_MASK       = 0x00000C00U;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const uint32_t SAIx_SAI_ACR1_MONO_MASK         = 0x00001000U;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const uint32_t SAIx_SAI_ACR1_OUTDRIV_MASK      = 0x00002000U;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const uint32_t SAIx_SAI_ACR1_SAIXEN_MASK       = 0x00010000U;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const uint32_t SAIx_SAI_ACR1_DMAEN_MASK        = 0x00020000U;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const uint32_t SAIx_SAI_ACR1_NOMCK_MASK        = 0x00080000U;   /** @brief No divider */
    static const uint32_t SAIx_SAI_ACR1_MCKDIV_MASK       = 0x00F00000U;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const uint32_t SAIx_SAI_ACR1_OSR_MASK          = 0x04000000U;   /** @brief Oversampling ratio for master clock */
    static const uint32_t SAIx_SAI_ACR2_FTH_MASK          = 0x00000007U;   /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const uint32_t SAIx_SAI_ACR2_FFLUSH_MASK       = 0x00000008U;   /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const uint32_t SAIx_SAI_ACR2_TRIS_MASK         = 0x00000010U;   /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const uint32_t SAIx_SAI_ACR2_MUTE_MASK         = 0x00000020U;   /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIx_SAI_ACR2_MUTEVAL_MASK      = 0x00000040U;   /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIx_SAI_ACR2_MUTECNT_MASK      = 0x00001F80U;   /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const uint32_t SAIx_SAI_ACR2_CPL_MASK          = 0x00002000U;   /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const uint32_t SAIx_SAI_ACR2_COMP_MASK         = 0x0000C000U;   /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const uint32_t SAIx_SAI_AFRCR_FRL_MASK         = 0x000000FFU;   /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const uint32_t SAIx_SAI_AFRCR_FSALL_MASK       = 0x00007F00U;   /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_AFRCR_FSDEF_MASK       = 0x00010000U;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_AFRCR_FSPOL_MASK       = 0x00020000U;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_AFRCR_FSOFF_MASK       = 0x00040000U;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_ASLOTR_FBOFF_MASK      = 0x0000001FU;   /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_ASLOTR_SLOTSZ_MASK     = 0x000000C0U;   /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_ASLOTR_NBSLOT_MASK     = 0x00000F00U;   /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_ASLOTR_SLOTEN_MASK     = 0xFFFF0000U;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_AIM_OVRUDRIE_MASK      = 0x00000001U;   /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const uint32_t SAIx_SAI_AIM_MUTEDETIE_MASK     = 0x00000002U;   /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const uint32_t SAIx_SAI_AIM_WCKCFGIE_MASK      = 0x00000004U;   /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const uint32_t SAIx_SAI_AIM_FREQIE_MASK        = 0x00000008U;   /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const uint32_t SAIx_SAI_AIM_CNRDYIE_MASK       = 0x00000010U;   /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const uint32_t SAIx_SAI_AIM_AFSDETIE_MASK      = 0x00000020U;   /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIx_SAI_AIM_LFSDETIE_MASK      = 0x00000040U;   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIx_SAI_ASR_OVRUDR_MASK        = 0x00000001U;   /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_ASR_MUTEDET_MASK       = 0x00000002U;   /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const uint32_t SAIx_SAI_ASR_WCKCFG_MASK        = 0x00000004U;   /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_ASR_FREQ_MASK          = 0x00000008U;   /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const uint32_t SAIx_SAI_ASR_CNRDY_MASK         = 0x00000010U;   /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_ASR_AFSDET_MASK        = 0x00000020U;   /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_ASR_LFSDET_MASK        = 0x00000040U;   /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const uint32_t SAIx_SAI_ASR_FLVL_MASK          = 0x00070000U;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const uint32_t SAIx_SAI_ACLRFR_COVRUDR_MASK    = 0x00000001U;   /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_ACLRFR_CMUTEDET_MASK   = 0x00000002U;   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_ACLRFR_CWCKCFG_MASK    = 0x00000004U;   /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_ACLRFR_CCNRDY_MASK     = 0x00000010U;   /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_ACLRFR_CAFSDET_MASK    = 0x00000020U;   /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_ACLRFR_CLFSDET_MASK    = 0x00000040U;   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_BCR1_MODE_MASK         = 0x00000003U;   /** @brief SAIx audio block mode immediately */
    static const uint32_t SAIx_SAI_BCR1_PRTCFG_MASK       = 0x0000000CU;   /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_BCR1_DS_MASK           = 0x000000E0U;   /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_BCR1_LSBFIRST_MASK     = 0x00000100U;   /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const uint32_t SAIx_SAI_BCR1_CKSTR_MASK        = 0x00000200U;   /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const uint32_t SAIx_SAI_BCR1_SYNCEN_MASK       = 0x00000C00U;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const uint32_t SAIx_SAI_BCR1_MONO_MASK         = 0x00001000U;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const uint32_t SAIx_SAI_BCR1_OUTDRIV_MASK      = 0x00002000U;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const uint32_t SAIx_SAI_BCR1_SAIXEN_MASK       = 0x00010000U;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const uint32_t SAIx_SAI_BCR1_DMAEN_MASK        = 0x00020000U;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const uint32_t SAIx_SAI_BCR1_NOMCK_MASK        = 0x00080000U;   /** @brief No divider */
    static const uint32_t SAIx_SAI_BCR1_MCKDIV_MASK       = 0x00F00000U;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const uint32_t SAIx_SAI_BCR1_OSR_MASK          = 0x04000000U;   /** @brief Oversampling ratio for master clock */
    static const uint32_t SAIx_SAI_BCR2_FTH_MASK          = 0x00000007U;   /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const uint32_t SAIx_SAI_BCR2_FFLUSH_MASK       = 0x00000008U;   /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const uint32_t SAIx_SAI_BCR2_TRIS_MASK         = 0x00000010U;   /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const uint32_t SAIx_SAI_BCR2_MUTE_MASK         = 0x00000020U;   /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIx_SAI_BCR2_MUTEVAL_MASK      = 0x00000040U;   /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIx_SAI_BCR2_MUTECNT_MASK      = 0x00001F80U;   /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const uint32_t SAIx_SAI_BCR2_CPL_MASK          = 0x00002000U;   /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const uint32_t SAIx_SAI_BCR2_COMP_MASK         = 0x0000C000U;   /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const uint32_t SAIx_SAI_BFRCR_FRL_MASK         = 0x000000FFU;   /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const uint32_t SAIx_SAI_BFRCR_FSALL_MASK       = 0x00007F00U;   /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_BFRCR_FSDEF_MASK       = 0x00010000U;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_BFRCR_FSPOL_MASK       = 0x00020000U;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_BFRCR_FSOFF_MASK       = 0x00040000U;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIx_SAI_BSLOTR_FBOFF_MASK      = 0x0000001FU;   /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_BSLOTR_SLOTSZ_MASK     = 0x000000C0U;   /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_BSLOTR_NBSLOT_MASK     = 0x00000F00U;   /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_BSLOTR_SLOTEN_MASK     = 0xFFFF0000U;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIx_SAI_BIM_OVRUDRIE_MASK      = 0x00000001U;   /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const uint32_t SAIx_SAI_BIM_MUTEDETIE_MASK     = 0x00000002U;   /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const uint32_t SAIx_SAI_BIM_WCKCFGIE_MASK      = 0x00000004U;   /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const uint32_t SAIx_SAI_BIM_FREQIE_MASK        = 0x00000008U;   /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const uint32_t SAIx_SAI_BIM_CNRDYIE_MASK       = 0x00000010U;   /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const uint32_t SAIx_SAI_BIM_AFSDETIE_MASK      = 0x00000020U;   /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIx_SAI_BIM_LFSDETIE_MASK      = 0x00000040U;   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIx_SAI_BSR_OVRUDR_MASK        = 0x00000001U;   /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_BSR_MUTEDET_MASK       = 0x00000002U;   /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const uint32_t SAIx_SAI_BSR_WCKCFG_MASK        = 0x00000004U;   /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_BSR_FREQ_MASK          = 0x00000008U;   /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const uint32_t SAIx_SAI_BSR_CNRDY_MASK         = 0x00000010U;   /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_BSR_AFSDET_MASK        = 0x00000020U;   /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const uint32_t SAIx_SAI_BSR_LFSDET_MASK        = 0x00000040U;   /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const uint32_t SAIx_SAI_BSR_FLVL_MASK          = 0x00070000U;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const uint32_t SAIx_SAI_BCLRFR_COVRUDR_MASK    = 0x00000001U;   /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_BCLRFR_CMUTEDET_MASK   = 0x00000002U;   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_BCLRFR_CWCKCFG_MASK    = 0x00000004U;   /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_BCLRFR_CCNRDY_MASK     = 0x00000010U;   /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_BCLRFR_CAFSDET_MASK    = 0x00000020U;   /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_BCLRFR_CLFSDET_MASK    = 0x00000040U;   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const uint32_t SAIx_SAI_PDMCR_PDMEN_MASK       = 0x00000001U;   /** @brief PDM enable */
    static const uint32_t SAIx_SAI_PDMCR_MICNBR_MASK      = 0x00000030U;   /** @brief Number of microphones */

    /**** @subsection Enumerated SAIx Register Field Masks ****/

    static const uint32_t SAIx_SAI_PDMCR_CKENx_MASK[5] = {
      [1] = 0x00000100U,   /** @brief Clock enable of bitstream clock number 1 */
      [2] = 0x00000200U,   /** @brief Clock enable of bitstream clock number 2 */
      [3] = 0x00000400U,   /** @brief Clock enable of bitstream clock number 3 */
      [4] = 0x00000800U,   /** @brief Clock enable of bitstream clock number 4 */
    };

    static const uint32_t SAIx_SAI_PDMDLY_DLYMxL_MASK[5] = {
      [1] = 0x00000007U,   /** @brief Delay line adjust for first microphone of pair 1 */
      [2] = 0x00000700U,   /** @brief Delay line for first microphone of pair 2 */
      [3] = 0x00070000U,   /** @brief Delay line for first microphone of pair 3 */
      [4] = 0x07000000U,   /** @brief Delay line for first microphone of pair 4 */
    };

    static const uint32_t SAIx_SAI_PDMDLY_DLYMxR_MASK[5] = {
      [1] = 0x00000070U,   /** @brief Delay line adjust for second microphone of pair 1 */
      [2] = 0x00007000U,   /** @brief Delay line for second microphone of pair 2 */
      [3] = 0x00700000U,   /** @brief Delay line for second microphone of pair 3 */
      [4] = 0x70000000U,   /** @brief Delay line for second microphone of pair 4 */
    };

    /**** @subsection SAIx Register Field Positions ****/

    static const int32_t SAIx_SAI_GCR_SYNCOUT_POS       = 4;    /** @brief Synchronization outputs these bits are set and cleared by software. */
    static const int32_t SAIx_SAI_GCR_SYNCIN_POS        = 0;    /** @brief Synchronization inputs */
    static const int32_t SAIx_SAI_ACR1_MODE_POS         = 0;    /** @brief SAIx audio block mode immediately */
    static const int32_t SAIx_SAI_ACR1_PRTCFG_POS       = 2;    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_ACR1_DS_POS           = 5;    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_ACR1_LSBFIRST_POS     = 8;    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const int32_t SAIx_SAI_ACR1_CKSTR_POS        = 9;    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const int32_t SAIx_SAI_ACR1_SYNCEN_POS       = 10;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const int32_t SAIx_SAI_ACR1_MONO_POS         = 12;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const int32_t SAIx_SAI_ACR1_OUTDRIV_POS      = 13;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const int32_t SAIx_SAI_ACR1_SAIXEN_POS       = 16;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const int32_t SAIx_SAI_ACR1_DMAEN_POS        = 17;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const int32_t SAIx_SAI_ACR1_NOMCK_POS        = 19;   /** @brief No divider */
    static const int32_t SAIx_SAI_ACR1_MCKDIV_POS       = 20;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const int32_t SAIx_SAI_ACR1_OSR_POS          = 26;   /** @brief Oversampling ratio for master clock */
    static const int32_t SAIx_SAI_ACR2_FTH_POS          = 0;    /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const int32_t SAIx_SAI_ACR2_FFLUSH_POS       = 3;    /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const int32_t SAIx_SAI_ACR2_TRIS_POS         = 4;    /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const int32_t SAIx_SAI_ACR2_MUTE_POS         = 5;    /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIx_SAI_ACR2_MUTEVAL_POS      = 6;    /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIx_SAI_ACR2_MUTECNT_POS      = 7;    /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const int32_t SAIx_SAI_ACR2_CPL_POS          = 13;   /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const int32_t SAIx_SAI_ACR2_COMP_POS         = 14;   /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const int32_t SAIx_SAI_AFRCR_FRL_POS         = 0;    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const int32_t SAIx_SAI_AFRCR_FSALL_POS       = 8;    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_AFRCR_FSDEF_POS       = 16;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_AFRCR_FSPOL_POS       = 17;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_AFRCR_FSOFF_POS       = 18;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_ASLOTR_FBOFF_POS      = 0;    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_ASLOTR_SLOTSZ_POS     = 6;    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_ASLOTR_NBSLOT_POS     = 8;    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_ASLOTR_SLOTEN_POS     = 16;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_AIM_OVRUDRIE_POS      = 0;    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const int32_t SAIx_SAI_AIM_MUTEDETIE_POS     = 1;    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const int32_t SAIx_SAI_AIM_WCKCFGIE_POS      = 2;    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const int32_t SAIx_SAI_AIM_FREQIE_POS        = 3;    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const int32_t SAIx_SAI_AIM_CNRDYIE_POS       = 4;    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const int32_t SAIx_SAI_AIM_AFSDETIE_POS      = 5;    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIx_SAI_AIM_LFSDETIE_POS      = 6;    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIx_SAI_ASR_OVRUDR_POS        = 0;    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_ASR_MUTEDET_POS       = 1;    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const int32_t SAIx_SAI_ASR_WCKCFG_POS        = 2;    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_ASR_FREQ_POS          = 3;    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const int32_t SAIx_SAI_ASR_CNRDY_POS         = 4;    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_ASR_AFSDET_POS        = 5;    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_ASR_LFSDET_POS        = 6;    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const int32_t SAIx_SAI_ASR_FLVL_POS          = 16;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const int32_t SAIx_SAI_ACLRFR_COVRUDR_POS    = 0;    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_ACLRFR_CMUTEDET_POS   = 1;    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_ACLRFR_CWCKCFG_POS    = 2;    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_ACLRFR_CCNRDY_POS     = 4;    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_ACLRFR_CAFSDET_POS    = 5;    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_ACLRFR_CLFSDET_POS    = 6;    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_BCR1_MODE_POS         = 0;    /** @brief SAIx audio block mode immediately */
    static const int32_t SAIx_SAI_BCR1_PRTCFG_POS       = 2;    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_BCR1_DS_POS           = 5;    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_BCR1_LSBFIRST_POS     = 8;    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const int32_t SAIx_SAI_BCR1_CKSTR_POS        = 9;    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const int32_t SAIx_SAI_BCR1_SYNCEN_POS       = 10;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const int32_t SAIx_SAI_BCR1_MONO_POS         = 12;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const int32_t SAIx_SAI_BCR1_OUTDRIV_POS      = 13;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const int32_t SAIx_SAI_BCR1_SAIXEN_POS       = 16;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const int32_t SAIx_SAI_BCR1_DMAEN_POS        = 17;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const int32_t SAIx_SAI_BCR1_NOMCK_POS        = 19;   /** @brief No divider */
    static const int32_t SAIx_SAI_BCR1_MCKDIV_POS       = 20;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const int32_t SAIx_SAI_BCR1_OSR_POS          = 26;   /** @brief Oversampling ratio for master clock */
    static const int32_t SAIx_SAI_BCR2_FTH_POS          = 0;    /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const int32_t SAIx_SAI_BCR2_FFLUSH_POS       = 3;    /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const int32_t SAIx_SAI_BCR2_TRIS_POS         = 4;    /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const int32_t SAIx_SAI_BCR2_MUTE_POS         = 5;    /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIx_SAI_BCR2_MUTEVAL_POS      = 6;    /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIx_SAI_BCR2_MUTECNT_POS      = 7;    /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const int32_t SAIx_SAI_BCR2_CPL_POS          = 13;   /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const int32_t SAIx_SAI_BCR2_COMP_POS         = 14;   /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const int32_t SAIx_SAI_BFRCR_FRL_POS         = 0;    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const int32_t SAIx_SAI_BFRCR_FSALL_POS       = 8;    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_BFRCR_FSDEF_POS       = 16;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_BFRCR_FSPOL_POS       = 17;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_BFRCR_FSOFF_POS       = 18;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIx_SAI_BSLOTR_FBOFF_POS      = 0;    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_BSLOTR_SLOTSZ_POS     = 6;    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_BSLOTR_NBSLOT_POS     = 8;    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_BSLOTR_SLOTEN_POS     = 16;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIx_SAI_BIM_OVRUDRIE_POS      = 0;    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const int32_t SAIx_SAI_BIM_MUTEDETIE_POS     = 1;    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const int32_t SAIx_SAI_BIM_WCKCFGIE_POS      = 2;    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const int32_t SAIx_SAI_BIM_FREQIE_POS        = 3;    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const int32_t SAIx_SAI_BIM_CNRDYIE_POS       = 4;    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const int32_t SAIx_SAI_BIM_AFSDETIE_POS      = 5;    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIx_SAI_BIM_LFSDETIE_POS      = 6;    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIx_SAI_BSR_OVRUDR_POS        = 0;    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_BSR_MUTEDET_POS       = 1;    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const int32_t SAIx_SAI_BSR_WCKCFG_POS        = 2;    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_BSR_FREQ_POS          = 3;    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const int32_t SAIx_SAI_BSR_CNRDY_POS         = 4;    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_BSR_AFSDET_POS        = 5;    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const int32_t SAIx_SAI_BSR_LFSDET_POS        = 6;    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const int32_t SAIx_SAI_BSR_FLVL_POS          = 16;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const int32_t SAIx_SAI_BCLRFR_COVRUDR_POS    = 0;    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_BCLRFR_CMUTEDET_POS   = 1;    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_BCLRFR_CWCKCFG_POS    = 2;    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_BCLRFR_CCNRDY_POS     = 4;    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_BCLRFR_CAFSDET_POS    = 5;    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_BCLRFR_CLFSDET_POS    = 6;    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const int32_t SAIx_SAI_PDMCR_PDMEN_POS       = 0;    /** @brief PDM enable */
    static const int32_t SAIx_SAI_PDMCR_MICNBR_POS      = 4;    /** @brief Number of microphones */

    /**** @subsection Enumerated SAIx Register Field Positions ****/

    static const int32_t SAIx_SAI_PDMCR_CKENx_POS[5] = {
      [1] = 8,    /** @brief Clock enable of bitstream clock number 1 */
      [2] = 9,    /** @brief Clock enable of bitstream clock number 2 */
      [3] = 10,   /** @brief Clock enable of bitstream clock number 3 */
      [4] = 11,   /** @brief Clock enable of bitstream clock number 4 */
    };

    static const int32_t SAIx_SAI_PDMDLY_DLYMxL_POS[5] = {
      [1] = 0,    /** @brief Delay line adjust for first microphone of pair 1 */
      [2] = 8,    /** @brief Delay line for first microphone of pair 2 */
      [3] = 16,   /** @brief Delay line for first microphone of pair 3 */
      [4] = 24,   /** @brief Delay line for first microphone of pair 4 */
    };

    static const int32_t SAIx_SAI_PDMDLY_DLYMxR_POS[5] = {
      [1] = 4,    /** @brief Delay line adjust for second microphone of pair 1 */
      [2] = 12,   /** @brief Delay line for second microphone of pair 2 */
      [3] = 20,   /** @brief Delay line for second microphone of pair 3 */
      [4] = 28,   /** @brief Delay line for second microphone of pair 4 */
    };

    /**********************************************************************************************
     * @section SDMMCx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated SDMMCx Register Pointers ****/

    static RW_ uint32_t* const SDMMCx_POWER_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007000U,   /** @brief SDMMC power control register */
      [2] = (RW_ uint32_t* const)0x48022400U,   /** @brief SDMMC power control register */
    };

    static RW_ uint32_t* const SDMMCx_CLKCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007004U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
      [2] = (RW_ uint32_t* const)0x48022404U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
    };

    static RW_ uint32_t* const SDMMCx_ARGR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007008U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
      [2] = (RW_ uint32_t* const)0x48022408U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
    };

    static RW_ uint32_t* const SDMMCx_CMDR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5200700CU,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
      [2] = (RW_ uint32_t* const)0x4802240CU,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
    };

    static RO_ uint32_t* const SDMMCx_RESPxR_PTR[3][5] = {
      [0] = {
        [1] = (RO_ uint32_t* const)0x52007014U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        [2] = (RO_ uint32_t* const)0x52007018U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        [3] = (RO_ uint32_t* const)0x5200701CU,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        [4] = (RO_ uint32_t* const)0x52007020U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      },
      [1] = {
        [1] = (RO_ uint32_t* const)0x48022414U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        [2] = (RO_ uint32_t* const)0x48022418U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        [3] = (RO_ uint32_t* const)0x4802241CU,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        [4] = (RO_ uint32_t* const)0x48022420U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      },
    };

    static RW_ uint32_t* const SDMMCx_DTIMER_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007024U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
      [2] = (RW_ uint32_t* const)0x48022424U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
    };

    static RW_ uint32_t* const SDMMCx_DLENR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007028U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
      [2] = (RW_ uint32_t* const)0x48022428U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
    };

    static RW_ uint32_t* const SDMMCx_DCTRL_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5200702CU,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
      [2] = (RW_ uint32_t* const)0x4802242CU,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
    };

    static RO_ uint32_t* const SDMMCx_DCNTR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x52007030U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
      [2] = (RO_ uint32_t* const)0x48022430U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
    };

    static RO_ uint32_t* const SDMMCx_STAR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x52007034U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
      [2] = (RO_ uint32_t* const)0x48022434U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
    };

    static RW_ uint32_t* const SDMMCx_ICR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007038U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
      [2] = (RW_ uint32_t* const)0x48022438U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
    };

    static RW_ uint32_t* const SDMMCx_MASKR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5200703CU,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
      [2] = (RW_ uint32_t* const)0x4802243CU,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
    };

    static RW_ uint32_t* const SDMMCx_ACKTIMER_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007040U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
      [2] = (RW_ uint32_t* const)0x48022440U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
    };

    static RW_ uint32_t* const SDMMCx_IDMACTRLR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007050U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
      [2] = (RW_ uint32_t* const)0x48022450U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
    };

    static RW_ uint32_t* const SDMMCx_IDMABSIZER_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007054U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
      [2] = (RW_ uint32_t* const)0x48022454U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
    };

    static RW_ uint32_t* const SDMMCx_IDMABASExR_PTR[3][2] = {
      [0] = {
        [0] = (RW_ uint32_t* const)0x52007058U,   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
        [1] = (RW_ uint32_t* const)0x5200705CU,   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
      },
      [1] = {
        [0] = (RW_ uint32_t* const)0x48022458U,   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
        [1] = (RW_ uint32_t* const)0x4802245CU,   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
      },
    };

    static RW_ uint32_t* const SDMMCx_FIFOR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52007080U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
      [2] = (RW_ uint32_t* const)0x48022480U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
    };

    static RO_ uint32_t* const SDMMCx_RESPCMDR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x52007010U,   /** @brief SDMMC command response register */
      [2] = (RO_ uint32_t* const)0x48022410U,   /** @brief SDMMC command response register */
    };

    /**** @subsection Enumerated SDMMCx Register Reset Values ****/

    static const uint32_t SDMMCx_POWER_RST[3] = {
      [1] = 0x00000000U,   /** @brief POWER register reset value */
      [2] = 0x00000000U,   /** @brief POWER register reset value */
    };

    static const uint32_t SDMMCx_CLKCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CLKCR register reset value */
      [2] = 0x00000000U,   /** @brief CLKCR register reset value */
    };

    static const uint32_t SDMMCx_ARGR_RST[3] = {
      [1] = 0x00000000U,   /** @brief ARGR register reset value */
      [2] = 0x00000000U,   /** @brief ARGR register reset value */
    };

    static const uint32_t SDMMCx_CMDR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CMDR register reset value */
      [2] = 0x00000000U,   /** @brief CMDR register reset value */
    };

    static const uint32_t SDMMCx_RESPxR_RST[3][5] = {
      [0] = {
        [1] = 0x00000000U,   /** @brief RESP1R register reset value. */
        [2] = 0x00000000U,   /** @brief RESP2R register reset value. */
        [3] = 0x00000000U,   /** @brief RESP3R register reset value. */
        [4] = 0x00000000U,   /** @brief RESP4R register reset value. */
      },
      [1] = {
        [1] = 0x00000000U,   /** @brief RESP1R register reset value. */
        [2] = 0x00000000U,   /** @brief RESP2R register reset value. */
        [3] = 0x00000000U,   /** @brief RESP3R register reset value. */
        [4] = 0x00000000U,   /** @brief RESP4R register reset value. */
      },
    };

    static const uint32_t SDMMCx_DTIMER_RST[3] = {
      [1] = 0x00000000U,   /** @brief DTIMER register reset value */
      [2] = 0x00000000U,   /** @brief DTIMER register reset value */
    };

    static const uint32_t SDMMCx_DLENR_RST[3] = {
      [1] = 0x00000000U,   /** @brief DLENR register reset value */
      [2] = 0x00000000U,   /** @brief DLENR register reset value */
    };

    static const uint32_t SDMMCx_DCTRL_RST[3] = {
      [1] = 0x00000000U,   /** @brief DCTRL register reset value */
      [2] = 0x00000000U,   /** @brief DCTRL register reset value */
    };

    static const uint32_t SDMMCx_DCNTR_RST[3] = {
      [1] = 0x00000000U,   /** @brief DCNTR register reset value */
      [2] = 0x00000000U,   /** @brief DCNTR register reset value */
    };

    static const uint32_t SDMMCx_STAR_RST[3] = {
      [1] = 0x00000000U,   /** @brief STAR register reset value */
      [2] = 0x00000000U,   /** @brief STAR register reset value */
    };

    static const uint32_t SDMMCx_ICR_RST[3] = {
      [1] = 0x00000000U,   /** @brief ICR register reset value */
      [2] = 0x00000000U,   /** @brief ICR register reset value */
    };

    static const uint32_t SDMMCx_MASKR_RST[3] = {
      [1] = 0x00000000U,   /** @brief MASKR register reset value */
      [2] = 0x00000000U,   /** @brief MASKR register reset value */
    };

    static const uint32_t SDMMCx_ACKTIMER_RST[3] = {
      [1] = 0x00000000U,   /** @brief ACKTIMER register reset value */
      [2] = 0x00000000U,   /** @brief ACKTIMER register reset value */
    };

    static const uint32_t SDMMCx_IDMACTRLR_RST[3] = {
      [1] = 0x00000000U,   /** @brief IDMACTRLR register reset value */
      [2] = 0x00000000U,   /** @brief IDMACTRLR register reset value */
    };

    static const uint32_t SDMMCx_IDMABSIZER_RST[3] = {
      [1] = 0x00000000U,   /** @brief IDMABSIZER register reset value */
      [2] = 0x00000000U,   /** @brief IDMABSIZER register reset value */
    };

    static const uint32_t SDMMCx_IDMABASExR_RST[3][2] = {
      [0] = {
        [0] = 0x00000000U,   /** @brief IDMABASE0R register reset value. */
        [1] = 0x00000000U,   /** @brief IDMABASE1R register reset value. */
      },
      [1] = {
        [0] = 0x00000000U,   /** @brief IDMABASE0R register reset value. */
        [1] = 0x00000000U,   /** @brief IDMABASE1R register reset value. */
      },
    };

    static const uint32_t SDMMCx_FIFOR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FIFOR register reset value */
      [2] = 0x00000000U,   /** @brief FIFOR register reset value */
    };

    static const uint32_t SDMMCx_RESPCMDR_RST[3] = {
      [1] = 0xA3C5DD01U,   /** @brief RESPCMDR register reset value */
      [2] = 0xA3C5DD01U,   /** @brief RESPCMDR register reset value */
    };

    /**** @subsection Enumerated SDMMCx Register Value Types ****/

    typedef uint32_t SDMMCx_POWER_t;        /** @brief POWER register value type. */
    typedef uint32_t SDMMCx_CLKCR_t;        /** @brief CLKCR register value type. */
    typedef uint32_t SDMMCx_ARGR_t;         /** @brief ARGR register value type. */
    typedef uint32_t SDMMCx_CMDR_t;         /** @brief CMDR register value type. */
    typedef uint32_t SDMMCx_RESPxR_t;       /** @brief RESPxR register value type. */
    typedef uint32_t SDMMCx_DTIMER_t;       /** @brief DTIMER register value type. */
    typedef uint32_t SDMMCx_DLENR_t;        /** @brief DLENR register value type. */
    typedef uint32_t SDMMCx_DCTRL_t;        /** @brief DCTRL register value type. */
    typedef uint32_t SDMMCx_DCNTR_t;        /** @brief DCNTR register value type. */
    typedef uint32_t SDMMCx_STAR_t;         /** @brief STAR register value type. */
    typedef uint32_t SDMMCx_ICR_t;          /** @brief ICR register value type. */
    typedef uint32_t SDMMCx_MASKR_t;        /** @brief MASKR register value type. */
    typedef uint32_t SDMMCx_ACKTIMER_t;     /** @brief ACKTIMER register value type. */
    typedef uint32_t SDMMCx_IDMACTRLR_t;    /** @brief IDMACTRLR register value type. */
    typedef uint32_t SDMMCx_IDMABSIZER_t;   /** @brief IDMABSIZER register value type. */
    typedef uint32_t SDMMCx_IDMABASExR_t;   /** @brief IDMABASExR register value type. */
    typedef uint32_t SDMMCx_FIFOR_t;        /** @brief FIFOR register value type. */
    typedef uint32_t SDMMCx_RESPCMDR_t;     /** @brief RESPCMDR register value type. */

    /**** @subsection Enumerated SDMMCx Register Pointer Types ****/

    typedef uint32_t* const SDMMCx_POWER_PTR_t;        /** @brief POWER register pointer type. */
    typedef uint32_t* const SDMMCx_CLKCR_PTR_t;        /** @brief CLKCR register pointer type. */
    typedef uint32_t* const SDMMCx_ARGR_PTR_t;         /** @brief ARGR register pointer type. */
    typedef uint32_t* const SDMMCx_CMDR_PTR_t;         /** @brief CMDR register pointer type. */
    typedef uint32_t* const SDMMCx_RESPxR_PTR_t;       /** @brief RESPxR register pointer type. */
    typedef uint32_t* const SDMMCx_DTIMER_PTR_t;       /** @brief DTIMER register pointer type. */
    typedef uint32_t* const SDMMCx_DLENR_PTR_t;        /** @brief DLENR register pointer type. */
    typedef uint32_t* const SDMMCx_DCTRL_PTR_t;        /** @brief DCTRL register pointer type. */
    typedef uint32_t* const SDMMCx_DCNTR_PTR_t;        /** @brief DCNTR register pointer type. */
    typedef uint32_t* const SDMMCx_STAR_PTR_t;         /** @brief STAR register pointer type. */
    typedef uint32_t* const SDMMCx_ICR_PTR_t;          /** @brief ICR register pointer type. */
    typedef uint32_t* const SDMMCx_MASKR_PTR_t;        /** @brief MASKR register pointer type. */
    typedef uint32_t* const SDMMCx_ACKTIMER_PTR_t;     /** @brief ACKTIMER register pointer type. */
    typedef uint32_t* const SDMMCx_IDMACTRLR_PTR_t;    /** @brief IDMACTRLR register pointer type. */
    typedef uint32_t* const SDMMCx_IDMABSIZER_PTR_t;   /** @brief IDMABSIZER register pointer type. */
    typedef uint32_t* const SDMMCx_IDMABASExR_PTR_t;   /** @brief IDMABASExR register pointer type. */
    typedef uint32_t* const SDMMCx_FIFOR_PTR_t;        /** @brief FIFOR register pointer type. */
    typedef uint32_t* const SDMMCx_RESPCMDR_PTR_t;     /** @brief RESPCMDR register pointer type. */

    /**** @subsection SDMMCx Register Field Masks ****/

    static const uint32_t SDMMCx_POWER_PWRCTRL_MASK         = 0x00000003U;   /** @brief SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: any further write will be ignored, PWRCTRL value will keep 11. */
    static const uint32_t SDMMCx_POWER_VSWITCH_MASK         = 0x00000004U;   /** @brief Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence: */
    static const uint32_t SDMMCx_POWER_VSWITCHEN_MASK       = 0x00000008U;   /** @brief Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response: */
    static const uint32_t SDMMCx_POWER_DIRPOL_MASK          = 0x00000010U;   /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
    static const uint32_t SDMMCx_CLKCR_CLKDIV_MASK          = 0x000003FFU;   /** @brief Clock divide factor this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. Xxx: etc.. */
    static const uint32_t SDMMCx_CLKCR_PWRSAV_MASK          = 0x00001000U;   /** @brief Power saving configuration bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) for power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV: */
    static const uint32_t SDMMCx_CLKCR_WIDBUS_MASK          = 0x0000C000U;   /** @brief Wide bus mode enable bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const uint32_t SDMMCx_CLKCR_NEGEDGE_MASK         = 0x00010000U;   /** @brief SDMMC_CK dephasing selection bit for data and command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. */
    static const uint32_t SDMMCx_CLKCR_HWFC_EN_MASK         = 0x00020000U;   /** @brief Hardware flow control enable this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) when hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in section56.8.11. */
    static const uint32_t SDMMCx_CLKCR_DDR_MASK             = 0x00040000U;   /** @brief Data rate signaling selection this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0) */
    static const uint32_t SDMMCx_CLKCR_BUSSPEED_MASK        = 0x00080000U;   /** @brief Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const uint32_t SDMMCx_CLKCR_SELCLKRX_MASK        = 0x00300000U;   /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const uint32_t SDMMCx_CMDR_CMDINDEX_MASK         = 0x0000003FU;   /** @brief Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. */
    static const uint32_t SDMMCx_CMDR_CMDTRANS_MASK         = 0x00000040U;   /** @brief The CPSM treats the command as a data transfer command, stops the interrupt period, and signals dataenable to the DPSM this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues dataenable signal to the DPSM when the command is sent. */
    static const uint32_t SDMMCx_CMDR_CMDSTOP_MASK          = 0x00000080U;   /** @brief The CPSM treats the command as a stop transmission command and signals abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the abort signal to the DPSM when the command is sent. */
    static const uint32_t SDMMCx_CMDR_WAITRESP_MASK         = 0x00000300U;   /** @brief Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. */
    static const uint32_t SDMMCx_CMDR_WAITINT_MASK          = 0x00000400U;   /** @brief CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (response). If this bit is cleared in the CPSM wait state, will cause the abort of the interrupt mode. */
    static const uint32_t SDMMCx_CMDR_WAITPEND_MASK         = 0x00000800U;   /** @brief CPSM waits for end of data transfer (cmdpend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card. */
    static const uint32_t SDMMCx_CMDR_CPSMEN_MASK           = 0x00001000U;   /** @brief Command path state machine (CPSM) enable bit this bit is written 1 by firmware, and cleared by hardware when the CPSM enters the idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0. */
    static const uint32_t SDMMCx_CMDR_DTHOLD_MASK           = 0x00002000U;   /** @brief Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the wait_s state to the send state or from the wait_r state to the receive state. */
    static const uint32_t SDMMCx_CMDR_BOOTMODE_MASK         = 0x00004000U;   /** @brief Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0) */
    static const uint32_t SDMMCx_CMDR_BOOTEN_MASK           = 0x00008000U;   /** @brief Enable boot mode procedure. */
    static const uint32_t SDMMCx_CMDR_CMDSUSPEND_MASK       = 0x00010000U;   /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
    static const uint32_t SDMMCx_DLENR_DATALENGTH_MASK      = 0x01FFFFFFU;   /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
    static const uint32_t SDMMCx_DCTRL_DTEN_MASK            = 0x00000001U;   /** @brief Data transfer enable bit this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. Shall not be used with SD or emmc cards. */
    static const uint32_t SDMMCx_DCTRL_DTDIR_MASK           = 0x00000002U;   /** @brief Data transfer direction selection this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCx_DCTRL_DTMODE_MASK          = 0x0000000CU;   /** @brief Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCx_DCTRL_DBLOCKSIZE_MASK      = 0x000000F0U;   /** @brief Data block size this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: when DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) when DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) */
    static const uint32_t SDMMCx_DCTRL_RWSTART_MASK         = 0x00000100U;   /** @brief Read wait start. If this bit is set, read wait operation starts. */
    static const uint32_t SDMMCx_DCTRL_RWSTOP_MASK          = 0x00000200U;   /** @brief Read wait stop this bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state. */
    static const uint32_t SDMMCx_DCTRL_RWMOD_MASK           = 0x00000400U;   /** @brief Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCx_DCTRL_SDIOEN_MASK          = 0x00000800U;   /** @brief SD I/O interrupt enable functions this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation. */
    static const uint32_t SDMMCx_DCTRL_BOOTACKEN_MASK       = 0x00001000U;   /** @brief Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCx_DCTRL_FIFORST_MASK         = 0x00002000U;   /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
    static const uint32_t SDMMCx_DCNTR_DATACOUNT_MASK       = 0x01FFFFFFU;   /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
    static const uint32_t SDMMCx_STAR_CCRCFAIL_MASK         = 0x00000001U;   /** @brief Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_DCRCFAIL_MASK         = 0x00000002U;   /** @brief Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_CTIMEOUT_MASK         = 0x00000004U;   /** @brief Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The command timeout period has a fixed value of 64 SDMMC_CK clock periods. */
    static const uint32_t SDMMCx_STAR_DTIMEOUT_MASK         = 0x00000008U;   /** @brief Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_TXUNDERR_MASK         = 0x00000010U;   /** @brief Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_RXOVERR_MASK          = 0x00000020U;   /** @brief Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_CMDREND_MASK          = 0x00000040U;   /** @brief Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_CMDSENT_MASK          = 0x00000080U;   /** @brief Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_DATAEND_MASK          = 0x00000100U;   /** @brief Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_DHOLD_MASK            = 0x00000200U;   /** @brief Data transfer hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_DBCKEND_MASK          = 0x00000400U;   /** @brief Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_DABORT_MASK           = 0x00000800U;   /** @brief Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_DPSMACT_MASK          = 0x00001000U;   /** @brief Data path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const uint32_t SDMMCx_STAR_CPSMACT_MASK          = 0x00002000U;   /** @brief Command path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const uint32_t SDMMCx_STAR_TXFIFOHE_MASK         = 0x00004000U;   /** @brief Transmit FIFO half empty at least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full. */
    static const uint32_t SDMMCx_STAR_RXFIFOHF_MASK         = 0x00008000U;   /** @brief Receive FIFO half full there are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty. */
    static const uint32_t SDMMCx_STAR_TXFIFOF_MASK          = 0x00010000U;   /** @brief Transmit FIFO full this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty. */
    static const uint32_t SDMMCx_STAR_RXFIFOF_MASK          = 0x00020000U;   /** @brief Receive FIFO full this bit is cleared when one FIFO location becomes empty. */
    static const uint32_t SDMMCx_STAR_TXFIFOE_MASK          = 0x00040000U;   /** @brief Transmit FIFO empty this bit is cleared when one FIFO location becomes full. */
    static const uint32_t SDMMCx_STAR_RXFIFOE_MASK          = 0x00080000U;   /** @brief Receive FIFO empty this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full. */
    static const uint32_t SDMMCx_STAR_BUSYD0_MASK           = 0x00100000U;   /** @brief Inverted value of SDMMC_D0 line (busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt. */
    static const uint32_t SDMMCx_STAR_BUSYD0END_MASK        = 0x00200000U;   /** @brief End of SDMMC_D0 busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_SDIOIT_MASK           = 0x00400000U;   /** @brief SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_ACKFAIL_MASK          = 0x00800000U;   /** @brief Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_ACKTIMEOUT_MASK       = 0x01000000U;   /** @brief Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_VSWEND_MASK           = 0x02000000U;   /** @brief Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_CKSTOP_MASK           = 0x04000000U;   /** @brief SDMMC_CK stopped in voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_IDMATE_MASK           = 0x08000000U;   /** @brief IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_STAR_IDMABTC_MASK          = 0x10000000U;   /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCx_ICR_CCRCFAILC_MASK         = 0x00000001U;   /** @brief CCRCFAIL flag clear bit set by software to clear the CCRCFAIL flag. */
    static const uint32_t SDMMCx_ICR_DCRCFAILC_MASK         = 0x00000002U;   /** @brief DCRCFAIL flag clear bit set by software to clear the DCRCFAIL flag. */
    static const uint32_t SDMMCx_ICR_CTIMEOUTC_MASK         = 0x00000004U;   /** @brief CTIMEOUT flag clear bit set by software to clear the CTIMEOUT flag. */
    static const uint32_t SDMMCx_ICR_DTIMEOUTC_MASK         = 0x00000008U;   /** @brief DTIMEOUT flag clear bit set by software to clear the DTIMEOUT flag. */
    static const uint32_t SDMMCx_ICR_TXUNDERRC_MASK         = 0x00000010U;   /** @brief TXUNDERR flag clear bit set by software to clear TXUNDERR flag. */
    static const uint32_t SDMMCx_ICR_RXOVERRC_MASK          = 0x00000020U;   /** @brief RXOVERR flag clear bit set by software to clear the RXOVERR flag. */
    static const uint32_t SDMMCx_ICR_CMDRENDC_MASK          = 0x00000040U;   /** @brief CMDREND flag clear bit set by software to clear the CMDREND flag. */
    static const uint32_t SDMMCx_ICR_CMDSENTC_MASK          = 0x00000080U;   /** @brief CMDSENT flag clear bit set by software to clear the CMDSENT flag. */
    static const uint32_t SDMMCx_ICR_DATAENDC_MASK          = 0x00000100U;   /** @brief DATAEND flag clear bit set by software to clear the DATAEND flag. */
    static const uint32_t SDMMCx_ICR_DHOLDC_MASK            = 0x00000200U;   /** @brief DHOLD flag clear bit set by software to clear the DHOLD flag. */
    static const uint32_t SDMMCx_ICR_DBCKENDC_MASK          = 0x00000400U;   /** @brief DBCKEND flag clear bit set by software to clear the DBCKEND flag. */
    static const uint32_t SDMMCx_ICR_DABORTC_MASK           = 0x00000800U;   /** @brief DABORT flag clear bit set by software to clear the DABORT flag. */
    static const uint32_t SDMMCx_ICR_BUSYD0ENDC_MASK        = 0x00200000U;   /** @brief BUSYD0END flag clear bit set by software to clear the BUSYD0END flag. */
    static const uint32_t SDMMCx_ICR_SDIOITC_MASK           = 0x00400000U;   /** @brief SDIOIT flag clear bit set by software to clear the SDIOIT flag. */
    static const uint32_t SDMMCx_ICR_ACKFAILC_MASK          = 0x00800000U;   /** @brief ACKFAIL flag clear bit set by software to clear the ACKFAIL flag. */
    static const uint32_t SDMMCx_ICR_ACKTIMEOUTC_MASK       = 0x01000000U;   /** @brief ACKTIMEOUT flag clear bit set by software to clear the ACKTIMEOUT flag. */
    static const uint32_t SDMMCx_ICR_VSWENDC_MASK           = 0x02000000U;   /** @brief VSWEND flag clear bit set by software to clear the VSWEND flag. */
    static const uint32_t SDMMCx_ICR_CKSTOPC_MASK           = 0x04000000U;   /** @brief CKSTOP flag clear bit set by software to clear the CKSTOP flag. */
    static const uint32_t SDMMCx_ICR_IDMATEC_MASK           = 0x08000000U;   /** @brief IDMA transfer error clear bit set by software to clear the IDMATE flag. */
    static const uint32_t SDMMCx_ICR_IDMABTCC_MASK          = 0x10000000U;   /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
    static const uint32_t SDMMCx_MASKR_CCRCFAILIE_MASK      = 0x00000001U;   /** @brief Command CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by command CRC failure. */
    static const uint32_t SDMMCx_MASKR_DCRCFAILIE_MASK      = 0x00000002U;   /** @brief Data CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by data CRC failure. */
    static const uint32_t SDMMCx_MASKR_CTIMEOUTIE_MASK      = 0x00000004U;   /** @brief Command timeout interrupt enable set and cleared by software to enable/disable interrupt caused by command timeout. */
    static const uint32_t SDMMCx_MASKR_DTIMEOUTIE_MASK      = 0x00000008U;   /** @brief Data timeout interrupt enable set and cleared by software to enable/disable interrupt caused by data timeout. */
    static const uint32_t SDMMCx_MASKR_TXUNDERRIE_MASK      = 0x00000010U;   /** @brief Tx FIFO underrun error interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO underrun error. */
    static const uint32_t SDMMCx_MASKR_RXOVERRIE_MASK       = 0x00000020U;   /** @brief Rx FIFO overrun error interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO overrun error. */
    static const uint32_t SDMMCx_MASKR_CMDRENDIE_MASK       = 0x00000040U;   /** @brief Command response received interrupt enable set and cleared by software to enable/disable interrupt caused by receiving command response. */
    static const uint32_t SDMMCx_MASKR_CMDSENTIE_MASK       = 0x00000080U;   /** @brief Command sent interrupt enable set and cleared by software to enable/disable interrupt caused by sending command. */
    static const uint32_t SDMMCx_MASKR_DATAENDIE_MASK       = 0x00000100U;   /** @brief Data end interrupt enable set and cleared by software to enable/disable interrupt caused by data end. */
    static const uint32_t SDMMCx_MASKR_DHOLDIE_MASK         = 0x00000200U;   /** @brief Data hold interrupt enable set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM wait_s state. */
    static const uint32_t SDMMCx_MASKR_DBCKENDIE_MASK       = 0x00000400U;   /** @brief Data block end interrupt enable set and cleared by software to enable/disable interrupt caused by data block end. */
    static const uint32_t SDMMCx_MASKR_DABORTIE_MASK        = 0x00000800U;   /** @brief Data transfer aborted interrupt enable set and cleared by software to enable/disable interrupt caused by a data transfer being aborted. */
    static const uint32_t SDMMCx_MASKR_TXFIFOHEIE_MASK      = 0x00004000U;   /** @brief Tx FIFO half empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO half empty. */
    static const uint32_t SDMMCx_MASKR_RXFIFOHFIE_MASK      = 0x00008000U;   /** @brief Rx FIFO half full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO half full. */
    static const uint32_t SDMMCx_MASKR_RXFIFOFIE_MASK       = 0x00020000U;   /** @brief Rx FIFO full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO full. */
    static const uint32_t SDMMCx_MASKR_TXFIFOEIE_MASK       = 0x00040000U;   /** @brief Tx FIFO empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO empty. */
    static const uint32_t SDMMCx_MASKR_BUSYD0ENDIE_MASK     = 0x00200000U;   /** @brief BUSYD0END interrupt enable set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response. */
    static const uint32_t SDMMCx_MASKR_SDIOITIE_MASK        = 0x00400000U;   /** @brief SDIO mode interrupt received interrupt enable set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt. */
    static const uint32_t SDMMCx_MASKR_ACKFAILIE_MASK       = 0x00800000U;   /** @brief Acknowledgment fail interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment fail. */
    static const uint32_t SDMMCx_MASKR_ACKTIMEOUTIE_MASK    = 0x01000000U;   /** @brief Acknowledgment timeout interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment timeout. */
    static const uint32_t SDMMCx_MASKR_VSWENDIE_MASK        = 0x02000000U;   /** @brief Voltage switch critical timing section completion interrupt enable set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion. */
    static const uint32_t SDMMCx_MASKR_CKSTOPIE_MASK        = 0x04000000U;   /** @brief Voltage switch clock stopped interrupt enable set and cleared by software to enable/disable interrupt caused by voltage switch clock stopped. */
    static const uint32_t SDMMCx_MASKR_IDMABTCIE_MASK       = 0x10000000U;   /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
    static const uint32_t SDMMCx_ACKTIMER_ACKTIME_MASK      = 0x01FFFFFFU;   /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
    static const uint32_t SDMMCx_IDMACTRLR_IDMAEN_MASK      = 0x00000001U;   /** @brief IDMA enable this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCx_IDMACTRLR_IDMABMODE_MASK   = 0x00000002U;   /** @brief Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCx_IDMACTRLR_IDMABACT_MASK    = 0x00000004U;   /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
    static const uint32_t SDMMCx_IDMABSIZER_IDMABNDT_MASK   = 0x00001FE0U;   /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCx_RESPCMDR_RESPCMD_MASK      = 0x0000003FU;   /** @brief Response command index */

    /**** @subsection SDMMCx Register Field Positions ****/

    static const int32_t SDMMCx_POWER_PWRCTRL_POS         = 0;    /** @brief SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: any further write will be ignored, PWRCTRL value will keep 11. */
    static const int32_t SDMMCx_POWER_VSWITCH_POS         = 2;    /** @brief Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence: */
    static const int32_t SDMMCx_POWER_VSWITCHEN_POS       = 3;    /** @brief Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response: */
    static const int32_t SDMMCx_POWER_DIRPOL_POS          = 4;    /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
    static const int32_t SDMMCx_CLKCR_CLKDIV_POS          = 0;    /** @brief Clock divide factor this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. Xxx: etc.. */
    static const int32_t SDMMCx_CLKCR_PWRSAV_POS          = 12;   /** @brief Power saving configuration bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) for power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV: */
    static const int32_t SDMMCx_CLKCR_WIDBUS_POS          = 14;   /** @brief Wide bus mode enable bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const int32_t SDMMCx_CLKCR_NEGEDGE_POS         = 16;   /** @brief SDMMC_CK dephasing selection bit for data and command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. */
    static const int32_t SDMMCx_CLKCR_HWFC_EN_POS         = 17;   /** @brief Hardware flow control enable this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) when hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in section56.8.11. */
    static const int32_t SDMMCx_CLKCR_DDR_POS             = 18;   /** @brief Data rate signaling selection this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0) */
    static const int32_t SDMMCx_CLKCR_BUSSPEED_POS        = 19;   /** @brief Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const int32_t SDMMCx_CLKCR_SELCLKRX_POS        = 20;   /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const int32_t SDMMCx_CMDR_CMDINDEX_POS         = 0;    /** @brief Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. */
    static const int32_t SDMMCx_CMDR_CMDTRANS_POS         = 6;    /** @brief The CPSM treats the command as a data transfer command, stops the interrupt period, and signals dataenable to the DPSM this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues dataenable signal to the DPSM when the command is sent. */
    static const int32_t SDMMCx_CMDR_CMDSTOP_POS          = 7;    /** @brief The CPSM treats the command as a stop transmission command and signals abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the abort signal to the DPSM when the command is sent. */
    static const int32_t SDMMCx_CMDR_WAITRESP_POS         = 8;    /** @brief Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. */
    static const int32_t SDMMCx_CMDR_WAITINT_POS          = 10;   /** @brief CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (response). If this bit is cleared in the CPSM wait state, will cause the abort of the interrupt mode. */
    static const int32_t SDMMCx_CMDR_WAITPEND_POS         = 11;   /** @brief CPSM waits for end of data transfer (cmdpend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card. */
    static const int32_t SDMMCx_CMDR_CPSMEN_POS           = 12;   /** @brief Command path state machine (CPSM) enable bit this bit is written 1 by firmware, and cleared by hardware when the CPSM enters the idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0. */
    static const int32_t SDMMCx_CMDR_DTHOLD_POS           = 13;   /** @brief Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the wait_s state to the send state or from the wait_r state to the receive state. */
    static const int32_t SDMMCx_CMDR_BOOTMODE_POS         = 14;   /** @brief Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0) */
    static const int32_t SDMMCx_CMDR_BOOTEN_POS           = 15;   /** @brief Enable boot mode procedure. */
    static const int32_t SDMMCx_CMDR_CMDSUSPEND_POS       = 16;   /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
    static const int32_t SDMMCx_DLENR_DATALENGTH_POS      = 0;    /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
    static const int32_t SDMMCx_DCTRL_DTEN_POS            = 0;    /** @brief Data transfer enable bit this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. Shall not be used with SD or emmc cards. */
    static const int32_t SDMMCx_DCTRL_DTDIR_POS           = 1;    /** @brief Data transfer direction selection this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCx_DCTRL_DTMODE_POS          = 2;    /** @brief Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCx_DCTRL_DBLOCKSIZE_POS      = 4;    /** @brief Data block size this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: when DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) when DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) */
    static const int32_t SDMMCx_DCTRL_RWSTART_POS         = 8;    /** @brief Read wait start. If this bit is set, read wait operation starts. */
    static const int32_t SDMMCx_DCTRL_RWSTOP_POS          = 9;    /** @brief Read wait stop this bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state. */
    static const int32_t SDMMCx_DCTRL_RWMOD_POS           = 10;   /** @brief Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCx_DCTRL_SDIOEN_POS          = 11;   /** @brief SD I/O interrupt enable functions this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation. */
    static const int32_t SDMMCx_DCTRL_BOOTACKEN_POS       = 12;   /** @brief Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCx_DCTRL_FIFORST_POS         = 13;   /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
    static const int32_t SDMMCx_DCNTR_DATACOUNT_POS       = 0;    /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
    static const int32_t SDMMCx_STAR_CCRCFAIL_POS         = 0;    /** @brief Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_DCRCFAIL_POS         = 1;    /** @brief Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_CTIMEOUT_POS         = 2;    /** @brief Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The command timeout period has a fixed value of 64 SDMMC_CK clock periods. */
    static const int32_t SDMMCx_STAR_DTIMEOUT_POS         = 3;    /** @brief Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_TXUNDERR_POS         = 4;    /** @brief Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_RXOVERR_POS          = 5;    /** @brief Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_CMDREND_POS          = 6;    /** @brief Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_CMDSENT_POS          = 7;    /** @brief Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_DATAEND_POS          = 8;    /** @brief Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_DHOLD_POS            = 9;    /** @brief Data transfer hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_DBCKEND_POS          = 10;   /** @brief Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_DABORT_POS           = 11;   /** @brief Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_DPSMACT_POS          = 12;   /** @brief Data path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const int32_t SDMMCx_STAR_CPSMACT_POS          = 13;   /** @brief Command path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const int32_t SDMMCx_STAR_TXFIFOHE_POS         = 14;   /** @brief Transmit FIFO half empty at least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full. */
    static const int32_t SDMMCx_STAR_RXFIFOHF_POS         = 15;   /** @brief Receive FIFO half full there are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty. */
    static const int32_t SDMMCx_STAR_TXFIFOF_POS          = 16;   /** @brief Transmit FIFO full this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty. */
    static const int32_t SDMMCx_STAR_RXFIFOF_POS          = 17;   /** @brief Receive FIFO full this bit is cleared when one FIFO location becomes empty. */
    static const int32_t SDMMCx_STAR_TXFIFOE_POS          = 18;   /** @brief Transmit FIFO empty this bit is cleared when one FIFO location becomes full. */
    static const int32_t SDMMCx_STAR_RXFIFOE_POS          = 19;   /** @brief Receive FIFO empty this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full. */
    static const int32_t SDMMCx_STAR_BUSYD0_POS           = 20;   /** @brief Inverted value of SDMMC_D0 line (busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt. */
    static const int32_t SDMMCx_STAR_BUSYD0END_POS        = 21;   /** @brief End of SDMMC_D0 busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_SDIOIT_POS           = 22;   /** @brief SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_ACKFAIL_POS          = 23;   /** @brief Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_ACKTIMEOUT_POS       = 24;   /** @brief Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_VSWEND_POS           = 25;   /** @brief Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_CKSTOP_POS           = 26;   /** @brief SDMMC_CK stopped in voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_IDMATE_POS           = 27;   /** @brief IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_STAR_IDMABTC_POS          = 28;   /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCx_ICR_CCRCFAILC_POS         = 0;    /** @brief CCRCFAIL flag clear bit set by software to clear the CCRCFAIL flag. */
    static const int32_t SDMMCx_ICR_DCRCFAILC_POS         = 1;    /** @brief DCRCFAIL flag clear bit set by software to clear the DCRCFAIL flag. */
    static const int32_t SDMMCx_ICR_CTIMEOUTC_POS         = 2;    /** @brief CTIMEOUT flag clear bit set by software to clear the CTIMEOUT flag. */
    static const int32_t SDMMCx_ICR_DTIMEOUTC_POS         = 3;    /** @brief DTIMEOUT flag clear bit set by software to clear the DTIMEOUT flag. */
    static const int32_t SDMMCx_ICR_TXUNDERRC_POS         = 4;    /** @brief TXUNDERR flag clear bit set by software to clear TXUNDERR flag. */
    static const int32_t SDMMCx_ICR_RXOVERRC_POS          = 5;    /** @brief RXOVERR flag clear bit set by software to clear the RXOVERR flag. */
    static const int32_t SDMMCx_ICR_CMDRENDC_POS          = 6;    /** @brief CMDREND flag clear bit set by software to clear the CMDREND flag. */
    static const int32_t SDMMCx_ICR_CMDSENTC_POS          = 7;    /** @brief CMDSENT flag clear bit set by software to clear the CMDSENT flag. */
    static const int32_t SDMMCx_ICR_DATAENDC_POS          = 8;    /** @brief DATAEND flag clear bit set by software to clear the DATAEND flag. */
    static const int32_t SDMMCx_ICR_DHOLDC_POS            = 9;    /** @brief DHOLD flag clear bit set by software to clear the DHOLD flag. */
    static const int32_t SDMMCx_ICR_DBCKENDC_POS          = 10;   /** @brief DBCKEND flag clear bit set by software to clear the DBCKEND flag. */
    static const int32_t SDMMCx_ICR_DABORTC_POS           = 11;   /** @brief DABORT flag clear bit set by software to clear the DABORT flag. */
    static const int32_t SDMMCx_ICR_BUSYD0ENDC_POS        = 21;   /** @brief BUSYD0END flag clear bit set by software to clear the BUSYD0END flag. */
    static const int32_t SDMMCx_ICR_SDIOITC_POS           = 22;   /** @brief SDIOIT flag clear bit set by software to clear the SDIOIT flag. */
    static const int32_t SDMMCx_ICR_ACKFAILC_POS          = 23;   /** @brief ACKFAIL flag clear bit set by software to clear the ACKFAIL flag. */
    static const int32_t SDMMCx_ICR_ACKTIMEOUTC_POS       = 24;   /** @brief ACKTIMEOUT flag clear bit set by software to clear the ACKTIMEOUT flag. */
    static const int32_t SDMMCx_ICR_VSWENDC_POS           = 25;   /** @brief VSWEND flag clear bit set by software to clear the VSWEND flag. */
    static const int32_t SDMMCx_ICR_CKSTOPC_POS           = 26;   /** @brief CKSTOP flag clear bit set by software to clear the CKSTOP flag. */
    static const int32_t SDMMCx_ICR_IDMATEC_POS           = 27;   /** @brief IDMA transfer error clear bit set by software to clear the IDMATE flag. */
    static const int32_t SDMMCx_ICR_IDMABTCC_POS          = 28;   /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
    static const int32_t SDMMCx_MASKR_CCRCFAILIE_POS      = 0;    /** @brief Command CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by command CRC failure. */
    static const int32_t SDMMCx_MASKR_DCRCFAILIE_POS      = 1;    /** @brief Data CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by data CRC failure. */
    static const int32_t SDMMCx_MASKR_CTIMEOUTIE_POS      = 2;    /** @brief Command timeout interrupt enable set and cleared by software to enable/disable interrupt caused by command timeout. */
    static const int32_t SDMMCx_MASKR_DTIMEOUTIE_POS      = 3;    /** @brief Data timeout interrupt enable set and cleared by software to enable/disable interrupt caused by data timeout. */
    static const int32_t SDMMCx_MASKR_TXUNDERRIE_POS      = 4;    /** @brief Tx FIFO underrun error interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO underrun error. */
    static const int32_t SDMMCx_MASKR_RXOVERRIE_POS       = 5;    /** @brief Rx FIFO overrun error interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO overrun error. */
    static const int32_t SDMMCx_MASKR_CMDRENDIE_POS       = 6;    /** @brief Command response received interrupt enable set and cleared by software to enable/disable interrupt caused by receiving command response. */
    static const int32_t SDMMCx_MASKR_CMDSENTIE_POS       = 7;    /** @brief Command sent interrupt enable set and cleared by software to enable/disable interrupt caused by sending command. */
    static const int32_t SDMMCx_MASKR_DATAENDIE_POS       = 8;    /** @brief Data end interrupt enable set and cleared by software to enable/disable interrupt caused by data end. */
    static const int32_t SDMMCx_MASKR_DHOLDIE_POS         = 9;    /** @brief Data hold interrupt enable set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM wait_s state. */
    static const int32_t SDMMCx_MASKR_DBCKENDIE_POS       = 10;   /** @brief Data block end interrupt enable set and cleared by software to enable/disable interrupt caused by data block end. */
    static const int32_t SDMMCx_MASKR_DABORTIE_POS        = 11;   /** @brief Data transfer aborted interrupt enable set and cleared by software to enable/disable interrupt caused by a data transfer being aborted. */
    static const int32_t SDMMCx_MASKR_TXFIFOHEIE_POS      = 14;   /** @brief Tx FIFO half empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO half empty. */
    static const int32_t SDMMCx_MASKR_RXFIFOHFIE_POS      = 15;   /** @brief Rx FIFO half full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO half full. */
    static const int32_t SDMMCx_MASKR_RXFIFOFIE_POS       = 17;   /** @brief Rx FIFO full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO full. */
    static const int32_t SDMMCx_MASKR_TXFIFOEIE_POS       = 18;   /** @brief Tx FIFO empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO empty. */
    static const int32_t SDMMCx_MASKR_BUSYD0ENDIE_POS     = 21;   /** @brief BUSYD0END interrupt enable set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response. */
    static const int32_t SDMMCx_MASKR_SDIOITIE_POS        = 22;   /** @brief SDIO mode interrupt received interrupt enable set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt. */
    static const int32_t SDMMCx_MASKR_ACKFAILIE_POS       = 23;   /** @brief Acknowledgment fail interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment fail. */
    static const int32_t SDMMCx_MASKR_ACKTIMEOUTIE_POS    = 24;   /** @brief Acknowledgment timeout interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment timeout. */
    static const int32_t SDMMCx_MASKR_VSWENDIE_POS        = 25;   /** @brief Voltage switch critical timing section completion interrupt enable set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion. */
    static const int32_t SDMMCx_MASKR_CKSTOPIE_POS        = 26;   /** @brief Voltage switch clock stopped interrupt enable set and cleared by software to enable/disable interrupt caused by voltage switch clock stopped. */
    static const int32_t SDMMCx_MASKR_IDMABTCIE_POS       = 28;   /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
    static const int32_t SDMMCx_ACKTIMER_ACKTIME_POS      = 0;    /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
    static const int32_t SDMMCx_IDMACTRLR_IDMAEN_POS      = 0;    /** @brief IDMA enable this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCx_IDMACTRLR_IDMABMODE_POS   = 1;    /** @brief Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCx_IDMACTRLR_IDMABACT_POS    = 2;    /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
    static const int32_t SDMMCx_IDMABSIZER_IDMABNDT_POS   = 5;    /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCx_RESPCMDR_RESPCMD_POS      = 0;    /** @brief Response command index */

    /**********************************************************************************************
     * @section VREFBUF Register Information
     **********************************************************************************************/

    /**** @subsection VREFBUF Register Pointers ****/

    static RW_ uint32_t* const VREFBUF_CSR_PTR   = (RW_ uint32_t* const)0x58003C00U;   /** @brief VREFBUF control and status register */
    static RW_ uint32_t* const VREFBUF_CCR_PTR   = (RW_ uint32_t* const)0x58003C04U;   /** @brief VREFBUF calibration control register */

    /**** @subsection VREFBUF Register Reset Values ****/

    static const uint32_t VREFBUF_CSR_RST   = 0x00000002U;   /** @brief CSR register reset value. */
    static const uint32_t VREFBUF_CCR_RST   = 0x00000000U;   /** @brief CCR register reset value. */

    /**** @subsection Enumerated VREFBUF Register Value Types ****/

    typedef uint32_t VREFBUF_CSR_t;   /** @brief CSR register value type. */
    typedef uint32_t VREFBUF_CCR_t;   /** @brief CCR register value type. */

    /**** @subsection Enumerated VREFBUF Register Pointer Types ****/

    typedef uint32_t* const VREFBUF_CSR_PTR_t;   /** @brief CSR register pointer type. */
    typedef uint32_t* const VREFBUF_CCR_PTR_t;   /** @brief CCR register pointer type. */

    /**** @subsection VREFBUF Register Field Masks ****/

    static const uint32_t VREFBUF_CSR_ENVR_MASK   = 0x00000001U;   /** @brief Voltage reference buffer mode enable this bit is used to enable the voltage reference buffer mode. */
    static const uint32_t VREFBUF_CSR_HIZ_MASK    = 0x00000002U;   /** @brief High impedance mode this bit controls the analog switch to connect or not the VREF+ pin. Refer to table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration. */
    static const uint32_t VREFBUF_CSR_VRR_MASK    = 0x00000008U;   /** @brief Voltage reference buffer ready */
    static const uint32_t VREFBUF_CSR_VRS_MASK    = 0x00000070U;   /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved */
    static const uint32_t VREFBUF_CCR_TRIM_MASK   = 0x0000003FU;   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

    /**** @subsection VREFBUF Register Field Positions ****/

    static const int32_t VREFBUF_CSR_ENVR_POS   = 0;   /** @brief Voltage reference buffer mode enable this bit is used to enable the voltage reference buffer mode. */
    static const int32_t VREFBUF_CSR_HIZ_POS    = 1;   /** @brief High impedance mode this bit controls the analog switch to connect or not the VREF+ pin. Refer to table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration. */
    static const int32_t VREFBUF_CSR_VRR_POS    = 3;   /** @brief Voltage reference buffer ready */
    static const int32_t VREFBUF_CSR_VRS_POS    = 4;   /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved */
    static const int32_t VREFBUF_CCR_TRIM_POS   = 0;   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

    /**********************************************************************************************
     * @section IWDGx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated IWDGx Register Pointers ****/

    static RW_ uint32_t* const IWDGx_KR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x58004800U,   /** @brief Key register */
      [2] = (RW_ uint32_t* const)0x58004C00U,   /** @brief Key register */
    };

    static RW_ uint32_t* const IWDGx_PR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x58004804U,   /** @brief Prescaler register */
      [2] = (RW_ uint32_t* const)0x58004C04U,   /** @brief Prescaler register */
    };

    static RW_ uint32_t* const IWDGx_RLR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x58004808U,   /** @brief Reload register */
      [2] = (RW_ uint32_t* const)0x58004C08U,   /** @brief Reload register */
    };

    static RO_ uint32_t* const IWDGx_SR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x5800480CU,   /** @brief Status register */
      [2] = (RO_ uint32_t* const)0x58004C0CU,   /** @brief Status register */
    };

    static RW_ uint32_t* const IWDGx_WINR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x58004810U,   /** @brief Window register */
      [2] = (RW_ uint32_t* const)0x58004C10U,   /** @brief Window register */
    };

    /**** @subsection Enumerated IWDGx Register Reset Values ****/

    static const uint32_t IWDGx_KR_RST[3] = {
      [1] = 0x00000000U,   /** @brief KR register reset value */
      [2] = 0x00000000U,   /** @brief KR register reset value */
    };

    static const uint32_t IWDGx_PR_RST[3] = {
      [1] = 0x00000000U,   /** @brief PR register reset value */
      [2] = 0x00000000U,   /** @brief PR register reset value */
    };

    static const uint32_t IWDGx_RLR_RST[3] = {
      [1] = 0x00000FFFU,   /** @brief RLR register reset value */
      [2] = 0x00000FFFU,   /** @brief RLR register reset value */
    };

    static const uint32_t IWDGx_SR_RST[3] = {
      [1] = 0x00000000U,   /** @brief SR register reset value */
      [2] = 0x00000000U,   /** @brief SR register reset value */
    };

    static const uint32_t IWDGx_WINR_RST[3] = {
      [1] = 0x00000FFFU,   /** @brief WINR register reset value */
      [2] = 0x00000FFFU,   /** @brief WINR register reset value */
    };

    /**** @subsection Enumerated IWDGx Register Value Types ****/

    typedef uint32_t IWDGx_KR_t;     /** @brief KR register value type. */
    typedef uint32_t IWDGx_PR_t;     /** @brief PR register value type. */
    typedef uint32_t IWDGx_RLR_t;    /** @brief RLR register value type. */
    typedef uint32_t IWDGx_SR_t;     /** @brief SR register value type. */
    typedef uint32_t IWDGx_WINR_t;   /** @brief WINR register value type. */

    /**** @subsection Enumerated IWDGx Register Pointer Types ****/

    typedef uint32_t* const IWDGx_KR_PTR_t;     /** @brief KR register pointer type. */
    typedef uint32_t* const IWDGx_PR_PTR_t;     /** @brief PR register pointer type. */
    typedef uint32_t* const IWDGx_RLR_PTR_t;    /** @brief RLR register pointer type. */
    typedef uint32_t* const IWDGx_SR_PTR_t;     /** @brief SR register pointer type. */
    typedef uint32_t* const IWDGx_WINR_PTR_t;   /** @brief WINR register pointer type. */

    /**** @subsection IWDGx Register Field Masks ****/

    static const uint32_t IWDGx_KR_KEY_MASK     = 0x0000FFFFU;   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
    static const uint32_t IWDGx_PR_PR_MASK      = 0x00000007U;   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
    static const uint32_t IWDGx_RLR_RL_MASK     = 0x00000FFFU;   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
    static const uint32_t IWDGx_SR_PVU_MASK     = 0x00000001U;   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
    static const uint32_t IWDGx_SR_RVU_MASK     = 0x00000002U;   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
    static const uint32_t IWDGx_SR_WVU_MASK     = 0x00000004U;   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
    static const uint32_t IWDGx_WINR_WIN_MASK   = 0x00000FFFU;   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

    /**** @subsection IWDGx Register Field Positions ****/

    static const int32_t IWDGx_KR_KEY_POS     = 0;   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
    static const int32_t IWDGx_PR_PR_POS      = 0;   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
    static const int32_t IWDGx_RLR_RL_POS     = 0;   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
    static const int32_t IWDGx_SR_PVU_POS     = 0;   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
    static const int32_t IWDGx_SR_RVU_POS     = 1;   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
    static const int32_t IWDGx_SR_WVU_POS     = 2;   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
    static const int32_t IWDGx_WINR_WIN_POS   = 0;   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

    /**********************************************************************************************
     * @section WWDGx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated WWDGx Register Pointers ****/

    static RW_ uint32_t* const WWDGx_CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50003000U,   /** @brief Control register */
      [2] = (RW_ uint32_t* const)0x40002C00U,   /** @brief Control register */
    };

    static RW_ uint32_t* const WWDGx_CFR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50003004U,   /** @brief Configuration register */
      [2] = (RW_ uint32_t* const)0x40002C04U,   /** @brief Configuration register */
    };

    static RW_ uint32_t* const WWDGx_SR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50003008U,   /** @brief Status register */
      [2] = (RW_ uint32_t* const)0x40002C08U,   /** @brief Status register */
    };

    /**** @subsection Enumerated WWDGx Register Reset Values ****/

    static const uint32_t WWDGx_CR_RST[3] = {
      [1] = 0x0000007FU,   /** @brief CR register reset value */
      [2] = 0x0000007FU,   /** @brief CR register reset value */
    };

    static const uint32_t WWDGx_CFR_RST[3] = {
      [1] = 0x0000007FU,   /** @brief CFR register reset value */
      [2] = 0x0000007FU,   /** @brief CFR register reset value */
    };

    static const uint32_t WWDGx_SR_RST[3] = {
      [1] = 0x00000000U,   /** @brief SR register reset value */
      [2] = 0x00000000U,   /** @brief SR register reset value */
    };

    /**** @subsection Enumerated WWDGx Register Value Types ****/

    typedef uint32_t WWDGx_CR_t;    /** @brief CR register value type. */
    typedef uint32_t WWDGx_CFR_t;   /** @brief CFR register value type. */
    typedef uint32_t WWDGx_SR_t;    /** @brief SR register value type. */

    /**** @subsection Enumerated WWDGx Register Pointer Types ****/

    typedef uint32_t* const WWDGx_CR_PTR_t;    /** @brief CR register pointer type. */
    typedef uint32_t* const WWDGx_CFR_PTR_t;   /** @brief CFR register pointer type. */
    typedef uint32_t* const WWDGx_SR_PTR_t;    /** @brief SR register pointer type. */

    /**** @subsection WWDGx Register Field Masks ****/

    static const uint32_t WWDGx_CR_T_MASK        = 0x0000007FU;   /** @brief 7-bit counter (MSB to LSB) these bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3f (T6 becomes cleared). */
    static const uint32_t WWDGx_CR_WDGA_MASK     = 0x00000080U;   /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
    static const uint32_t WWDGx_CFR_W_MASK       = 0x0000007FU;   /** @brief 7-bit window value these bits contain the window value to be compared to the downcounter. */
    static const uint32_t WWDGx_CFR_WDGTB_MASK   = 0x00001800U;   /** @brief Timer base the time base of the prescaler can be modified as follows: */
    static const uint32_t WWDGx_CFR_EWI_MASK     = 0x00000200U;   /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
    static const uint32_t WWDGx_SR_EWIF_MASK     = 0x00000001U;   /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */

    /**** @subsection WWDGx Register Field Positions ****/

    static const int32_t WWDGx_CR_T_POS        = 0;    /** @brief 7-bit counter (MSB to LSB) these bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3f (T6 becomes cleared). */
    static const int32_t WWDGx_CR_WDGA_POS     = 7;    /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
    static const int32_t WWDGx_CFR_W_POS       = 0;    /** @brief 7-bit window value these bits contain the window value to be compared to the downcounter. */
    static const int32_t WWDGx_CFR_WDGTB_POS   = 11;   /** @brief Timer base the time base of the prescaler can be modified as follows: */
    static const int32_t WWDGx_CFR_EWI_POS     = 9;    /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
    static const int32_t WWDGx_SR_EWIF_POS     = 0;    /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */

    /**********************************************************************************************
     * @section PWR Register Information
     **********************************************************************************************/

    /**** @subsection PWR Register Pointers ****/

    static RW_ uint32_t* const PWR_CR1_PTR       = (RW_ uint32_t* const)0x58024800U;   /** @brief PWR control register 1 */
    static RO_ uint32_t* const PWR_CSR1_PTR      = (RO_ uint32_t* const)0x58024804U;   /** @brief PWR control status register 1 */
    static RW_ uint32_t* const PWR_CR2_PTR       = (RW_ uint32_t* const)0x58024808U;   /** @brief This register is not reset by wakeup from standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.after reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection. */
    static RW_ uint32_t* const PWR_CR3_PTR       = (RW_ uint32_t* const)0x5802480CU;   /** @brief Reset only by POR only, not reset by wakeup from standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value. */
    static RW_ uint32_t* const PWR_CPUCR_PTR     = (RW_ uint32_t* const)0x58024810U;   /** @brief This register allows controlling CPU1 power. */
    static RW_ uint32_t* const PWR_D3CR_PTR      = (RW_ uint32_t* const)0x58024818U;   /** @brief This register allows controlling D3 domain power.following reset VOSRDY will be read 1 by software */
    static RW_ uint32_t* const PWR_WKUPCR_PTR    = (RW_ uint32_t* const)0x58024820U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared). */
    static RW_ uint32_t* const PWR_WKUPFR_PTR    = (RW_ uint32_t* const)0x58024824U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */
    static RW_ uint32_t* const PWR_WKUPEPR_PTR   = (RW_ uint32_t* const)0x58024828U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */

    /**** @subsection PWR Register Reset Values ****/

    static const uint32_t PWR_CR1_RST       = 0xF000C000U;   /** @brief CR1 register reset value. */
    static const uint32_t PWR_CSR1_RST      = 0x00004000U;   /** @brief CSR1 register reset value. */
    static const uint32_t PWR_CR2_RST       = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t PWR_CR3_RST       = 0x00000006U;   /** @brief CR3 register reset value. */
    static const uint32_t PWR_CPUCR_RST     = 0x00000000U;   /** @brief CPUCR register reset value. */
    static const uint32_t PWR_D3CR_RST      = 0x00004000U;   /** @brief D3CR register reset value. */
    static const uint32_t PWR_WKUPCR_RST    = 0x00000000U;   /** @brief WKUPCR register reset value. */
    static const uint32_t PWR_WKUPFR_RST    = 0x00000000U;   /** @brief WKUPFR register reset value. */
    static const uint32_t PWR_WKUPEPR_RST   = 0x00000000U;   /** @brief WKUPEPR register reset value. */

    /**** @subsection Enumerated PWR Register Value Types ****/

    typedef uint32_t PWR_CR1_t;       /** @brief CR1 register value type. */
    typedef uint32_t PWR_CSR1_t;      /** @brief CSR1 register value type. */
    typedef uint32_t PWR_CR2_t;       /** @brief CR2 register value type. */
    typedef uint32_t PWR_CR3_t;       /** @brief CR3 register value type. */
    typedef uint32_t PWR_CPUCR_t;     /** @brief CPUCR register value type. */
    typedef uint32_t PWR_D3CR_t;      /** @brief D3CR register value type. */
    typedef uint32_t PWR_WKUPCR_t;    /** @brief WKUPCR register value type. */
    typedef uint32_t PWR_WKUPFR_t;    /** @brief WKUPFR register value type. */
    typedef uint32_t PWR_WKUPEPR_t;   /** @brief WKUPEPR register value type. */

    /**** @subsection Enumerated PWR Register Pointer Types ****/

    typedef uint32_t* const PWR_CR1_PTR_t;       /** @brief CR1 register pointer type. */
    typedef uint32_t* const PWR_CSR1_PTR_t;      /** @brief CSR1 register pointer type. */
    typedef uint32_t* const PWR_CR2_PTR_t;       /** @brief CR2 register pointer type. */
    typedef uint32_t* const PWR_CR3_PTR_t;       /** @brief CR3 register pointer type. */
    typedef uint32_t* const PWR_CPUCR_PTR_t;     /** @brief CPUCR register pointer type. */
    typedef uint32_t* const PWR_D3CR_PTR_t;      /** @brief D3CR register pointer type. */
    typedef uint32_t* const PWR_WKUPCR_PTR_t;    /** @brief WKUPCR register pointer type. */
    typedef uint32_t* const PWR_WKUPFR_PTR_t;    /** @brief WKUPFR register pointer type. */
    typedef uint32_t* const PWR_WKUPEPR_PTR_t;   /** @brief WKUPEPR register pointer type. */

    /**** @subsection PWR Register Field Masks ****/

    static const uint32_t PWR_CR1_LPDS_MASK         = 0x00000001U;   /** @brief Low-power deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit) */
    static const uint32_t PWR_CR1_PVDE_MASK         = 0x00000010U;   /** @brief Programmable voltage detector enable */
    static const uint32_t PWR_CR1_PLS_MASK          = 0x000000E0U;   /** @brief Programmable voltage detector level selection these bits select the voltage threshold detected by the PVD. Note: refer to section electrical characteristics of the product datasheet for more details. */
    static const uint32_t PWR_CR1_DBP_MASK          = 0x00000100U;   /** @brief Disable backup domain write protection in reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers. */
    static const uint32_t PWR_CR1_FLPS_MASK         = 0x00000200U;   /** @brief Flash low-power mode in dstop mode this bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from dstop mode. When it is set, the flash memory enters low-power mode when D1 domain is in dstop mode. */
    static const uint32_t PWR_CR1_SVOS_MASK         = 0x0000C000U;   /** @brief System stop mode voltage scaling selection these bits control the VCORE voltage level in system stop mode, to obtain the best trade-off between power consumption and performance. */
    static const uint32_t PWR_CR1_AVDEN_MASK        = 0x00010000U;   /** @brief Peripheral voltage monitor on VDDA enable */
    static const uint32_t PWR_CR1_ALS_MASK          = 0x00060000U;   /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
    static const uint32_t PWR_CSR1_PVDO_MASK        = 0x00000010U;   /** @brief Programmable voltage detect output this bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the PVDE bit is set. */
    static const uint32_t PWR_CSR1_ACTVOSRDY_MASK   = 0x00002000U;   /** @brief Voltage levels ready bit for currently used VOS and SDLEVEL this bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const uint32_t PWR_CSR1_ACTVOS_MASK      = 0x0000C000U;   /** @brief VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. */
    static const uint32_t PWR_CSR1_AVDO_MASK        = 0x00010000U;   /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
    static const uint32_t PWR_CR2_BREN_MASK         = 0x00000001U;   /** @brief Backup regulator enable when set, the backup regulator (used to maintain the backup RAM content in standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in run and stop modes. However, its content will be lost in standby and VBAT modes. If BREN is set, the application must wait till the backup regulator ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in standby and VBAT modes. */
    static const uint32_t PWR_CR2_MONEN_MASK        = 0x00000010U;   /** @brief VBAT and temperature monitoring enable when set, the VBAT supply and temperature monitoring is enabled. */
    static const uint32_t PWR_CR2_BRRDY_MASK        = 0x00010000U;   /** @brief Backup regulator ready this bit is set by hardware to indicate that the backup regulator is ready. */
    static const uint32_t PWR_CR2_VBATL_MASK        = 0x00100000U;   /** @brief VBAT level monitoring versus low threshold */
    static const uint32_t PWR_CR2_VBATH_MASK        = 0x00200000U;   /** @brief VBAT level monitoring versus high threshold */
    static const uint32_t PWR_CR2_TEMPL_MASK        = 0x00400000U;   /** @brief Temperature level monitoring versus low threshold */
    static const uint32_t PWR_CR2_TEMPH_MASK        = 0x00800000U;   /** @brief Temperature level monitoring versus high threshold */
    static const uint32_t PWR_CR3_BYPASS_MASK       = 0x00000001U;   /** @brief Power management unit bypass */
    static const uint32_t PWR_CR3_LDOEN_MASK        = 0x00000002U;   /** @brief Low drop-out regulator enable */
    static const uint32_t PWR_CR3_SDEN_MASK         = 0x00000004U;   /** @brief SD converter enable */
    static const uint32_t PWR_CR3_VBE_MASK          = 0x00000100U;   /** @brief VBAT charging enable */
    static const uint32_t PWR_CR3_VBRS_MASK         = 0x00000200U;   /** @brief VBAT charging resistor selection */
    static const uint32_t PWR_CR3_USB33DEN_MASK     = 0x01000000U;   /** @brief VDD33USB voltage level detector enable. */
    static const uint32_t PWR_CR3_USBREGEN_MASK     = 0x02000000U;   /** @brief USB regulator enable. */
    static const uint32_t PWR_CR3_USB33RDY_MASK     = 0x04000000U;   /** @brief USB supply ready. */
    static const uint32_t PWR_CPUCR_STOPF_MASK      = 0x00000020U;   /** @brief STOP flag this bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit. */
    static const uint32_t PWR_CPUCR_SBF_MASK        = 0x00000040U;   /** @brief System standby flag this bit is set by hardware and cleared only by a POR (power-on reset) or by setting the CPU1 CSSF bit */
    static const uint32_t PWR_CPUCR_CSSF_MASK       = 0x00000200U;   /** @brief Clear D1 domain CPU1 standby, stop and HOLD flags (always read as 0) this bit is cleared to 0 by hardware. */
    static const uint32_t PWR_CPUCR_RUN_D3_MASK     = 0x00000800U;   /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes */
    static const uint32_t PWR_D3CR_VOSRDY_MASK      = 0x00002000U;   /** @brief VOS ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const uint32_t PWR_D3CR_VOS_MASK         = 0x0000C000U;   /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
    static const uint32_t PWR_WKUPCR_WKUPC_MASK     = 0x0000003FU;   /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

    /**** @subsection Enumerated PWR Register Field Masks ****/

    static const uint32_t PWR_CPUCR_PDDS_Dx_MASK[4] = {
      [1] = 0x00000001U,   /** @brief D1 domain power down deepsleep selection. This bit allows CPU1 to define the deepsleep mode for D1 domain. */
      [2] = 0x00000002U,   /** @brief D2 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for D2 domain. */
      [3] = 0x00000004U,   /** @brief System D3 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for system D3 domain. */
    };

    static const uint32_t PWR_CPUCR_SBF_Dx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief D1 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in dstandby mode. */
      [2] = 0x00000100U,   /** @brief D2 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in dstandby mode. */
    };

    static const uint32_t PWR_WKUPFR_WKUPFx_MASK[7] = {
      [1] = 0x00000001U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [2] = 0x00000002U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [3] = 0x00000004U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [4] = 0x00000008U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [5] = 0x00000010U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [6] = 0x00000020U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    };

    static const uint32_t PWR_WKUPEPR_WKUPENx_MASK[7] = {
      [1] = 0x00000001U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [2] = 0x00000002U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [3] = 0x00000004U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [4] = 0x00000008U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [5] = 0x00000010U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [6] = 0x00000020U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    };

    static const uint32_t PWR_WKUPEPR_WKUPPx_MASK[7] = {
      [1] = 0x00000100U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [2] = 0x00000200U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [3] = 0x00000400U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [4] = 0x00000800U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [5] = 0x00001000U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [6] = 0x00002000U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    };

    static const uint32_t PWR_WKUPEPR_WKUPPUPDx_MASK[7] = {
      [1] = 0x00030000U,   /** @brief Wakeup pin pull configuration */
      [2] = 0x000C0000U,   /** @brief Wakeup pin pull configuration */
      [3] = 0x00300000U,   /** @brief Wakeup pin pull configuration */
      [4] = 0x00C00000U,   /** @brief Wakeup pin pull configuration */
      [5] = 0x03000000U,   /** @brief Wakeup pin pull configuration */
      [6] = 0x0C000000U,   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
    };

    /**** @subsection PWR Register Field Positions ****/

    static const int32_t PWR_CR1_LPDS_POS         = 0;    /** @brief Low-power deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit) */
    static const int32_t PWR_CR1_PVDE_POS         = 4;    /** @brief Programmable voltage detector enable */
    static const int32_t PWR_CR1_PLS_POS          = 5;    /** @brief Programmable voltage detector level selection these bits select the voltage threshold detected by the PVD. Note: refer to section electrical characteristics of the product datasheet for more details. */
    static const int32_t PWR_CR1_DBP_POS          = 8;    /** @brief Disable backup domain write protection in reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers. */
    static const int32_t PWR_CR1_FLPS_POS         = 9;    /** @brief Flash low-power mode in dstop mode this bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from dstop mode. When it is set, the flash memory enters low-power mode when D1 domain is in dstop mode. */
    static const int32_t PWR_CR1_SVOS_POS         = 14;   /** @brief System stop mode voltage scaling selection these bits control the VCORE voltage level in system stop mode, to obtain the best trade-off between power consumption and performance. */
    static const int32_t PWR_CR1_AVDEN_POS        = 16;   /** @brief Peripheral voltage monitor on VDDA enable */
    static const int32_t PWR_CR1_ALS_POS          = 17;   /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
    static const int32_t PWR_CSR1_PVDO_POS        = 4;    /** @brief Programmable voltage detect output this bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the PVDE bit is set. */
    static const int32_t PWR_CSR1_ACTVOSRDY_POS   = 13;   /** @brief Voltage levels ready bit for currently used VOS and SDLEVEL this bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const int32_t PWR_CSR1_ACTVOS_POS      = 14;   /** @brief VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. */
    static const int32_t PWR_CSR1_AVDO_POS        = 16;   /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
    static const int32_t PWR_CR2_BREN_POS         = 0;    /** @brief Backup regulator enable when set, the backup regulator (used to maintain the backup RAM content in standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in run and stop modes. However, its content will be lost in standby and VBAT modes. If BREN is set, the application must wait till the backup regulator ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in standby and VBAT modes. */
    static const int32_t PWR_CR2_MONEN_POS        = 4;    /** @brief VBAT and temperature monitoring enable when set, the VBAT supply and temperature monitoring is enabled. */
    static const int32_t PWR_CR2_BRRDY_POS        = 16;   /** @brief Backup regulator ready this bit is set by hardware to indicate that the backup regulator is ready. */
    static const int32_t PWR_CR2_VBATL_POS        = 20;   /** @brief VBAT level monitoring versus low threshold */
    static const int32_t PWR_CR2_VBATH_POS        = 21;   /** @brief VBAT level monitoring versus high threshold */
    static const int32_t PWR_CR2_TEMPL_POS        = 22;   /** @brief Temperature level monitoring versus low threshold */
    static const int32_t PWR_CR2_TEMPH_POS        = 23;   /** @brief Temperature level monitoring versus high threshold */
    static const int32_t PWR_CR3_BYPASS_POS       = 0;    /** @brief Power management unit bypass */
    static const int32_t PWR_CR3_LDOEN_POS        = 1;    /** @brief Low drop-out regulator enable */
    static const int32_t PWR_CR3_SDEN_POS         = 2;    /** @brief SD converter enable */
    static const int32_t PWR_CR3_VBE_POS          = 8;    /** @brief VBAT charging enable */
    static const int32_t PWR_CR3_VBRS_POS         = 9;    /** @brief VBAT charging resistor selection */
    static const int32_t PWR_CR3_USB33DEN_POS     = 24;   /** @brief VDD33USB voltage level detector enable. */
    static const int32_t PWR_CR3_USBREGEN_POS     = 25;   /** @brief USB regulator enable. */
    static const int32_t PWR_CR3_USB33RDY_POS     = 26;   /** @brief USB supply ready. */
    static const int32_t PWR_CPUCR_STOPF_POS      = 5;    /** @brief STOP flag this bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit. */
    static const int32_t PWR_CPUCR_SBF_POS        = 6;    /** @brief System standby flag this bit is set by hardware and cleared only by a POR (power-on reset) or by setting the CPU1 CSSF bit */
    static const int32_t PWR_CPUCR_CSSF_POS       = 9;    /** @brief Clear D1 domain CPU1 standby, stop and HOLD flags (always read as 0) this bit is cleared to 0 by hardware. */
    static const int32_t PWR_CPUCR_RUN_D3_POS     = 11;   /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes */
    static const int32_t PWR_D3CR_VOSRDY_POS      = 13;   /** @brief VOS ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const int32_t PWR_D3CR_VOS_POS         = 14;   /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
    static const int32_t PWR_WKUPCR_WKUPC_POS     = 0;    /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

    /**** @subsection Enumerated PWR Register Field Positions ****/

    static const int32_t PWR_CPUCR_PDDS_Dx_POS[4] = {
      [1] = 0,   /** @brief D1 domain power down deepsleep selection. This bit allows CPU1 to define the deepsleep mode for D1 domain. */
      [2] = 1,   /** @brief D2 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for D2 domain. */
      [3] = 2,   /** @brief System D3 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for system D3 domain. */
    };

    static const int32_t PWR_CPUCR_SBF_Dx_POS[3] = {
      [1] = 7,   /** @brief D1 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in dstandby mode. */
      [2] = 8,   /** @brief D2 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in dstandby mode. */
    };

    static const int32_t PWR_WKUPFR_WKUPFx_POS[7] = {
      [1] = 0,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [2] = 1,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [3] = 2,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [4] = 3,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [5] = 4,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [6] = 5,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    };

    static const int32_t PWR_WKUPEPR_WKUPENx_POS[7] = {
      [1] = 0,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [2] = 1,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [3] = 2,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [4] = 3,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [5] = 4,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      [6] = 5,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    };

    static const int32_t PWR_WKUPEPR_WKUPPx_POS[7] = {
      [1] = 8,    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [2] = 9,    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [3] = 10,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [4] = 11,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [5] = 12,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      [6] = 13,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    };

    static const int32_t PWR_WKUPEPR_WKUPPUPDx_POS[7] = {
      [1] = 16,   /** @brief Wakeup pin pull configuration */
      [2] = 18,   /** @brief Wakeup pin pull configuration */
      [3] = 20,   /** @brief Wakeup pin pull configuration */
      [4] = 22,   /** @brief Wakeup pin pull configuration */
      [5] = 24,   /** @brief Wakeup pin pull configuration */
      [6] = 26,   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
    };

    /**********************************************************************************************
     * @section SPIx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated SPIx Register Pointers ****/

    static RW_ uint32_t* const SPIx_CR1_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40003800U,   /** @brief Control register 1 */
      [3] = (RW_ uint32_t* const)0x40003C00U,   /** @brief Control register 1 */
      [4] = (RW_ uint32_t* const)0x40013400U,   /** @brief Control register 1 */
      [5] = (RW_ uint32_t* const)0x40015000U,   /** @brief Control register 1 */
      [6] = (RW_ uint32_t* const)0x58001400U,   /** @brief Control register 1 */
    };

    static RW_ uint32_t* const SPIx_CR2_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013004U,   /** @brief Control register 2 */
      [2] = (RW_ uint32_t* const)0x40003804U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40003C04U,   /** @brief Control register 2 */
      [4] = (RW_ uint32_t* const)0x40013404U,   /** @brief Control register 2 */
      [5] = (RW_ uint32_t* const)0x40015004U,   /** @brief Control register 2 */
      [6] = (RW_ uint32_t* const)0x58001404U,   /** @brief Control register 2 */
    };

    static RW_ uint32_t* const SPIx_CFG1_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013008U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40003808U,   /** @brief Configuration register 1 */
      [3] = (RW_ uint32_t* const)0x40003C08U,   /** @brief Configuration register 1 */
      [4] = (RW_ uint32_t* const)0x40013408U,   /** @brief Configuration register 1 */
      [5] = (RW_ uint32_t* const)0x40015008U,   /** @brief Configuration register 1 */
      [6] = (RW_ uint32_t* const)0x58001408U,   /** @brief Configuration register 1 */
    };

    static RW_ uint32_t* const SPIx_CFG2_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x4001300CU,   /** @brief Configuration register 2 */
      [2] = (RW_ uint32_t* const)0x4000380CU,   /** @brief Configuration register 2 */
      [3] = (RW_ uint32_t* const)0x40003C0CU,   /** @brief Configuration register 2 */
      [4] = (RW_ uint32_t* const)0x4001340CU,   /** @brief Configuration register 2 */
      [5] = (RW_ uint32_t* const)0x4001500CU,   /** @brief Configuration register 2 */
      [6] = (RW_ uint32_t* const)0x5800140CU,   /** @brief Configuration register 2 */
    };

    static RW_ uint32_t* const SPIx_IER_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013010U,   /** @brief Interrupt enable register */
      [2] = (RW_ uint32_t* const)0x40003810U,   /** @brief Interrupt enable register */
      [3] = (RW_ uint32_t* const)0x40003C10U,   /** @brief Interrupt enable register */
      [4] = (RW_ uint32_t* const)0x40013410U,   /** @brief Interrupt enable register */
      [5] = (RW_ uint32_t* const)0x40015010U,   /** @brief Interrupt enable register */
      [6] = (RW_ uint32_t* const)0x58001410U,   /** @brief Interrupt enable register */
    };

    static RO_ uint32_t* const SPIx_SR_PTR[7] = {
      [1] = (RO_ uint32_t* const)0x40013014U,   /** @brief Status register */
      [2] = (RO_ uint32_t* const)0x40003814U,   /** @brief Status register */
      [3] = (RO_ uint32_t* const)0x40003C14U,   /** @brief Status register */
      [4] = (RO_ uint32_t* const)0x40013414U,   /** @brief Status register */
      [5] = (RO_ uint32_t* const)0x40015014U,   /** @brief Status register */
      [6] = (RO_ uint32_t* const)0x58001414U,   /** @brief Status register */
    };

    static RW_ uint32_t* const SPIx_IFCR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013018U,   /** @brief Interrupt/Status flags clear register */
      [2] = (RW_ uint32_t* const)0x40003818U,   /** @brief Interrupt/Status flags clear register */
      [3] = (RW_ uint32_t* const)0x40003C18U,   /** @brief Interrupt/Status flags clear register */
      [4] = (RW_ uint32_t* const)0x40013418U,   /** @brief Interrupt/Status flags clear register */
      [5] = (RW_ uint32_t* const)0x40015018U,   /** @brief Interrupt/Status flags clear register */
      [6] = (RW_ uint32_t* const)0x58001418U,   /** @brief Interrupt/Status flags clear register */
    };

    static RW_ uint32_t* const SPIx_TXDR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013020U,   /** @brief Transmit data register */
      [2] = (RW_ uint32_t* const)0x40003820U,   /** @brief Transmit data register */
      [3] = (RW_ uint32_t* const)0x40003C20U,   /** @brief Transmit data register */
      [4] = (RW_ uint32_t* const)0x40013420U,   /** @brief Transmit data register */
      [5] = (RW_ uint32_t* const)0x40015020U,   /** @brief Transmit data register */
      [6] = (RW_ uint32_t* const)0x58001420U,   /** @brief Transmit data register */
    };

    static RO_ uint32_t* const SPIx_RXDR_PTR[7] = {
      [1] = (RO_ uint32_t* const)0x40013030U,   /** @brief Receive data register */
      [2] = (RO_ uint32_t* const)0x40003830U,   /** @brief Receive data register */
      [3] = (RO_ uint32_t* const)0x40003C30U,   /** @brief Receive data register */
      [4] = (RO_ uint32_t* const)0x40013430U,   /** @brief Receive data register */
      [5] = (RO_ uint32_t* const)0x40015030U,   /** @brief Receive data register */
      [6] = (RO_ uint32_t* const)0x58001430U,   /** @brief Receive data register */
    };

    static RW_ uint32_t* const SPIx_CRCPOLY_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013040U,   /** @brief Polynomial register */
      [2] = (RW_ uint32_t* const)0x40003840U,   /** @brief Polynomial register */
      [3] = (RW_ uint32_t* const)0x40003C40U,   /** @brief Polynomial register */
      [4] = (RW_ uint32_t* const)0x40013440U,   /** @brief Polynomial register */
      [5] = (RW_ uint32_t* const)0x40015040U,   /** @brief Polynomial register */
      [6] = (RW_ uint32_t* const)0x58001440U,   /** @brief Polynomial register */
    };

    static RW_ uint32_t* const SPIx_TXCRC_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013044U,   /** @brief Transmitter CRC register */
      [2] = (RW_ uint32_t* const)0x40003844U,   /** @brief Transmitter CRC register */
      [3] = (RW_ uint32_t* const)0x40003C44U,   /** @brief Transmitter CRC register */
      [4] = (RW_ uint32_t* const)0x40013444U,   /** @brief Transmitter CRC register */
      [5] = (RW_ uint32_t* const)0x40015044U,   /** @brief Transmitter CRC register */
      [6] = (RW_ uint32_t* const)0x58001444U,   /** @brief Transmitter CRC register */
    };

    static RW_ uint32_t* const SPIx_RXCRC_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013048U,   /** @brief Receiver CRC register */
      [2] = (RW_ uint32_t* const)0x40003848U,   /** @brief Receiver CRC register */
      [3] = (RW_ uint32_t* const)0x40003C48U,   /** @brief Receiver CRC register */
      [4] = (RW_ uint32_t* const)0x40013448U,   /** @brief Receiver CRC register */
      [5] = (RW_ uint32_t* const)0x40015048U,   /** @brief Receiver CRC register */
      [6] = (RW_ uint32_t* const)0x58001448U,   /** @brief Receiver CRC register */
    };

    static RW_ uint32_t* const SPIx_UDRDR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x4001304CU,   /** @brief Underrun data register */
      [2] = (RW_ uint32_t* const)0x4000384CU,   /** @brief Underrun data register */
      [3] = (RW_ uint32_t* const)0x40003C4CU,   /** @brief Underrun data register */
      [4] = (RW_ uint32_t* const)0x4001344CU,   /** @brief Underrun data register */
      [5] = (RW_ uint32_t* const)0x4001504CU,   /** @brief Underrun data register */
      [6] = (RW_ uint32_t* const)0x5800144CU,   /** @brief Underrun data register */
    };

    static RW_ uint32_t* const SPIx_CGFR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40013050U,   /** @brief Configuration register */
      [2] = (RW_ uint32_t* const)0x40003850U,   /** @brief Configuration register */
      [3] = (RW_ uint32_t* const)0x40003C50U,   /** @brief Configuration register */
      [4] = (RW_ uint32_t* const)0x40013450U,   /** @brief Configuration register */
      [5] = (RW_ uint32_t* const)0x40015050U,   /** @brief Configuration register */
      [6] = (RW_ uint32_t* const)0x58001450U,   /** @brief Configuration register */
    };

    /**** @subsection Enumerated SPIx Register Reset Values ****/

    static const uint32_t SPIx_CR1_RST[7] = {
      [1] = 0x00000000U,   /** @brief CR1 register reset value */
      [2] = 0x00000000U,   /** @brief CR1 register reset value */
      [3] = 0x00000000U,   /** @brief CR1 register reset value */
      [4] = 0x00000000U,   /** @brief CR1 register reset value */
      [5] = 0x00000000U,   /** @brief CR1 register reset value */
      [6] = 0x00000000U,   /** @brief CR1 register reset value */
    };

    static const uint32_t SPIx_CR2_RST[7] = {
      [1] = 0x00000000U,   /** @brief CR2 register reset value */
      [2] = 0x00000000U,   /** @brief CR2 register reset value */
      [3] = 0x00000000U,   /** @brief CR2 register reset value */
      [4] = 0x00000000U,   /** @brief CR2 register reset value */
      [5] = 0x00000000U,   /** @brief CR2 register reset value */
      [6] = 0x00000000U,   /** @brief CR2 register reset value */
    };

    static const uint32_t SPIx_CFG1_RST[7] = {
      [1] = 0x00070007U,   /** @brief CFG1 register reset value */
      [2] = 0x00070007U,   /** @brief CFG1 register reset value */
      [3] = 0x00070007U,   /** @brief CFG1 register reset value */
      [4] = 0x00070007U,   /** @brief CFG1 register reset value */
      [5] = 0x00070007U,   /** @brief CFG1 register reset value */
      [6] = 0x00070007U,   /** @brief CFG1 register reset value */
    };

    static const uint32_t SPIx_CFG2_RST[7] = {
      [1] = 0x00000000U,   /** @brief CFG2 register reset value */
      [2] = 0x00000000U,   /** @brief CFG2 register reset value */
      [3] = 0x00000000U,   /** @brief CFG2 register reset value */
      [4] = 0x00000000U,   /** @brief CFG2 register reset value */
      [5] = 0x00000000U,   /** @brief CFG2 register reset value */
      [6] = 0x00000000U,   /** @brief CFG2 register reset value */
    };

    static const uint32_t SPIx_IER_RST[7] = {
      [1] = 0x00000000U,   /** @brief IER register reset value */
      [2] = 0x00000000U,   /** @brief IER register reset value */
      [3] = 0x00000000U,   /** @brief IER register reset value */
      [4] = 0x00000000U,   /** @brief IER register reset value */
      [5] = 0x00000000U,   /** @brief IER register reset value */
      [6] = 0x00000000U,   /** @brief IER register reset value */
    };

    static const uint32_t SPIx_SR_RST[7] = {
      [1] = 0x00001002U,   /** @brief SR register reset value */
      [2] = 0x00001002U,   /** @brief SR register reset value */
      [3] = 0x00001002U,   /** @brief SR register reset value */
      [4] = 0x00001002U,   /** @brief SR register reset value */
      [5] = 0x00001002U,   /** @brief SR register reset value */
      [6] = 0x00001002U,   /** @brief SR register reset value */
    };

    static const uint32_t SPIx_IFCR_RST[7] = {
      [1] = 0x00000000U,   /** @brief IFCR register reset value */
      [2] = 0x00000000U,   /** @brief IFCR register reset value */
      [3] = 0x00000000U,   /** @brief IFCR register reset value */
      [4] = 0x00000000U,   /** @brief IFCR register reset value */
      [5] = 0x00000000U,   /** @brief IFCR register reset value */
      [6] = 0x00000000U,   /** @brief IFCR register reset value */
    };

    static const uint32_t SPIx_TXDR_RST[7] = {
      [1] = 0x00000000U,   /** @brief TXDR register reset value */
      [2] = 0x00000000U,   /** @brief TXDR register reset value */
      [3] = 0x00000000U,   /** @brief TXDR register reset value */
      [4] = 0x00000000U,   /** @brief TXDR register reset value */
      [5] = 0x00000000U,   /** @brief TXDR register reset value */
      [6] = 0x00000000U,   /** @brief TXDR register reset value */
    };

    static const uint32_t SPIx_RXDR_RST[7] = {
      [1] = 0x00000000U,   /** @brief RXDR register reset value */
      [2] = 0x00000000U,   /** @brief RXDR register reset value */
      [3] = 0x00000000U,   /** @brief RXDR register reset value */
      [4] = 0x00000000U,   /** @brief RXDR register reset value */
      [5] = 0x00000000U,   /** @brief RXDR register reset value */
      [6] = 0x00000000U,   /** @brief RXDR register reset value */
    };

    static const uint32_t SPIx_CRCPOLY_RST[7] = {
      [1] = 0x00000107U,   /** @brief CRCPOLY register reset value */
      [2] = 0x00000107U,   /** @brief CRCPOLY register reset value */
      [3] = 0x00000107U,   /** @brief CRCPOLY register reset value */
      [4] = 0x00000107U,   /** @brief CRCPOLY register reset value */
      [5] = 0x00000107U,   /** @brief CRCPOLY register reset value */
      [6] = 0x00000107U,   /** @brief CRCPOLY register reset value */
    };

    static const uint32_t SPIx_TXCRC_RST[7] = {
      [1] = 0x00000000U,   /** @brief TXCRC register reset value */
      [2] = 0x00000000U,   /** @brief TXCRC register reset value */
      [3] = 0x00000000U,   /** @brief TXCRC register reset value */
      [4] = 0x00000000U,   /** @brief TXCRC register reset value */
      [5] = 0x00000000U,   /** @brief TXCRC register reset value */
      [6] = 0x00000000U,   /** @brief TXCRC register reset value */
    };

    static const uint32_t SPIx_RXCRC_RST[7] = {
      [1] = 0x00000000U,   /** @brief RXCRC register reset value */
      [2] = 0x00000000U,   /** @brief RXCRC register reset value */
      [3] = 0x00000000U,   /** @brief RXCRC register reset value */
      [4] = 0x00000000U,   /** @brief RXCRC register reset value */
      [5] = 0x00000000U,   /** @brief RXCRC register reset value */
      [6] = 0x00000000U,   /** @brief RXCRC register reset value */
    };

    static const uint32_t SPIx_UDRDR_RST[7] = {
      [1] = 0x00000000U,   /** @brief UDRDR register reset value */
      [2] = 0x00000000U,   /** @brief UDRDR register reset value */
      [3] = 0x00000000U,   /** @brief UDRDR register reset value */
      [4] = 0x00000000U,   /** @brief UDRDR register reset value */
      [5] = 0x00000000U,   /** @brief UDRDR register reset value */
      [6] = 0x00000000U,   /** @brief UDRDR register reset value */
    };

    static const uint32_t SPIx_CGFR_RST[7] = {
      [1] = 0x00000000U,   /** @brief CGFR register reset value */
      [2] = 0x00000000U,   /** @brief CGFR register reset value */
      [3] = 0x00000000U,   /** @brief CGFR register reset value */
      [4] = 0x00000000U,   /** @brief CGFR register reset value */
      [5] = 0x00000000U,   /** @brief CGFR register reset value */
      [6] = 0x00000000U,   /** @brief CGFR register reset value */
    };

    /**** @subsection Enumerated SPIx Register Value Types ****/

    typedef uint32_t SPIx_CR1_t;       /** @brief CR1 register value type. */
    typedef uint32_t SPIx_CR2_t;       /** @brief CR2 register value type. */
    typedef uint32_t SPIx_CFG1_t;      /** @brief CFG1 register value type. */
    typedef uint32_t SPIx_CFG2_t;      /** @brief CFG2 register value type. */
    typedef uint32_t SPIx_IER_t;       /** @brief IER register value type. */
    typedef uint32_t SPIx_SR_t;        /** @brief SR register value type. */
    typedef uint32_t SPIx_IFCR_t;      /** @brief IFCR register value type. */
    typedef uint32_t SPIx_TXDR_t;      /** @brief TXDR register value type. */
    typedef uint32_t SPIx_RXDR_t;      /** @brief RXDR register value type. */
    typedef uint32_t SPIx_CRCPOLY_t;   /** @brief CRCPOLY register value type. */
    typedef uint32_t SPIx_TXCRC_t;     /** @brief TXCRC register value type. */
    typedef uint32_t SPIx_RXCRC_t;     /** @brief RXCRC register value type. */
    typedef uint32_t SPIx_UDRDR_t;     /** @brief UDRDR register value type. */
    typedef uint32_t SPIx_CGFR_t;      /** @brief CGFR register value type. */

    /**** @subsection Enumerated SPIx Register Pointer Types ****/

    typedef uint32_t* const SPIx_CR1_PTR_t;       /** @brief CR1 register pointer type. */
    typedef uint32_t* const SPIx_CR2_PTR_t;       /** @brief CR2 register pointer type. */
    typedef uint32_t* const SPIx_CFG1_PTR_t;      /** @brief CFG1 register pointer type. */
    typedef uint32_t* const SPIx_CFG2_PTR_t;      /** @brief CFG2 register pointer type. */
    typedef uint32_t* const SPIx_IER_PTR_t;       /** @brief IER register pointer type. */
    typedef uint32_t* const SPIx_SR_PTR_t;        /** @brief SR register pointer type. */
    typedef uint32_t* const SPIx_IFCR_PTR_t;      /** @brief IFCR register pointer type. */
    typedef uint32_t* const SPIx_TXDR_PTR_t;      /** @brief TXDR register pointer type. */
    typedef uint32_t* const SPIx_RXDR_PTR_t;      /** @brief RXDR register pointer type. */
    typedef uint32_t* const SPIx_CRCPOLY_PTR_t;   /** @brief CRCPOLY register pointer type. */
    typedef uint32_t* const SPIx_TXCRC_PTR_t;     /** @brief TXCRC register pointer type. */
    typedef uint32_t* const SPIx_RXCRC_PTR_t;     /** @brief RXCRC register pointer type. */
    typedef uint32_t* const SPIx_UDRDR_PTR_t;     /** @brief UDRDR register pointer type. */
    typedef uint32_t* const SPIx_CGFR_PTR_t;      /** @brief CGFR register pointer type. */

    /**** @subsection SPIx Register Field Masks ****/

    static const uint32_t SPIx_CR1_IOLOCK_MASK     = 0x00010000U;   /** @brief Locking the AF configuration of associated ios */
    static const uint32_t SPIx_CR1_TCRCI_MASK      = 0x00008000U;   /** @brief CRC calculation initialization pattern control for transmitter */
    static const uint32_t SPIx_CR1_RCRCI_MASK      = 0x00004000U;   /** @brief CRC calculation initialization pattern control for receiver */
    static const uint32_t SPIx_CR1_CRC33_17_MASK   = 0x00002000U;   /** @brief 32-bit CRC polynomial configuration */
    static const uint32_t SPIx_CR1_SSI_MASK        = 0x00001000U;   /** @brief Internal SS signal input level */
    static const uint32_t SPIx_CR1_HDDIR_MASK      = 0x00000800U;   /** @brief Rx/Tx direction at half-duplex mode */
    static const uint32_t SPIx_CR1_CSUSP_MASK      = 0x00000400U;   /** @brief Master suspend request */
    static const uint32_t SPIx_CR1_CSTART_MASK     = 0x00000200U;   /** @brief Master transfer start */
    static const uint32_t SPIx_CR1_MASRX_MASK      = 0x00000100U;   /** @brief Master automatic SUSP in receive mode */
    static const uint32_t SPIx_CR1_SPE_MASK        = 0x00000001U;   /** @brief Serial peripheral enable */
    static const uint32_t SPIx_CR2_TSER_MASK       = 0xFFFF0000U;   /** @brief Number of data transfer extension to be reload into TSIZE just when a previous */
    static const uint32_t SPIx_CR2_TSIZE_MASK      = 0x0000FFFFU;   /** @brief Number of data at current transfer */
    static const uint32_t SPIx_CFG1_MBR_MASK       = 0x70000000U;   /** @brief Master baud rate */
    static const uint32_t SPIx_CFG1_CRCEN_MASK     = 0x00400000U;   /** @brief Hardware CRC computation enable */
    static const uint32_t SPIx_CFG1_CRCSIZE_MASK   = 0x001F0000U;   /** @brief Length of CRC frame to be transacted and compared */
    static const uint32_t SPIx_CFG1_TXDMAEN_MASK   = 0x00008000U;   /** @brief Tx DMA stream enable */
    static const uint32_t SPIx_CFG1_RXDMAEN_MASK   = 0x00004000U;   /** @brief Rx DMA stream enable */
    static const uint32_t SPIx_CFG1_UDRDET_MASK    = 0x00001800U;   /** @brief Detection of underrun condition at slave transmitter */
    static const uint32_t SPIx_CFG1_UDRCFG_MASK    = 0x00000600U;   /** @brief Behavior of slave transmitter at underrun condition */
    static const uint32_t SPIx_CFG1_FTHVL_MASK     = 0x000001E0U;   /** @brief Threshold level */
    static const uint32_t SPIx_CFG1_DSIZE_MASK     = 0x0000001FU;   /** @brief Number of bits in at single SPI data frame */
    static const uint32_t SPIx_CFG2_AFCNTR_MASK    = 0x80000000U;   /** @brief Alternate function gpios control */
    static const uint32_t SPIx_CFG2_SSOM_MASK      = 0x40000000U;   /** @brief SS output management in master mode */
    static const uint32_t SPIx_CFG2_SSOE_MASK      = 0x20000000U;   /** @brief SS output enable */
    static const uint32_t SPIx_CFG2_SSIOP_MASK     = 0x10000000U;   /** @brief SS input/output polarity */
    static const uint32_t SPIx_CFG2_SSM_MASK       = 0x04000000U;   /** @brief Software management of SS signal input */
    static const uint32_t SPIx_CFG2_CPOL_MASK      = 0x02000000U;   /** @brief Clock polarity */
    static const uint32_t SPIx_CFG2_CPHA_MASK      = 0x01000000U;   /** @brief Clock phase */
    static const uint32_t SPIx_CFG2_LSBFRST_MASK   = 0x00800000U;   /** @brief Data frame format */
    static const uint32_t SPIx_CFG2_MASTER_MASK    = 0x00400000U;   /** @brief SPI master */
    static const uint32_t SPIx_CFG2_SP_MASK        = 0x00380000U;   /** @brief Serial protocol */
    static const uint32_t SPIx_CFG2_COMM_MASK      = 0x00060000U;   /** @brief SPI communication mode */
    static const uint32_t SPIx_CFG2_IOSWP_MASK     = 0x00008000U;   /** @brief Swap functionality of MISO and MOSI pins */
    static const uint32_t SPIx_CFG2_MIDI_MASK      = 0x000000F0U;   /** @brief Master inter-data idleness */
    static const uint32_t SPIx_CFG2_MSSI_MASK      = 0x0000000FU;   /** @brief Master SS idleness */
    static const uint32_t SPIx_IER_TSERFIE_MASK    = 0x00000400U;   /** @brief Additional number of transactions reload interrupt enable */
    static const uint32_t SPIx_IER_MODFIE_MASK     = 0x00000200U;   /** @brief Mode fault interrupt enable */
    static const uint32_t SPIx_IER_TIFREIE_MASK    = 0x00000100U;   /** @brief TIFRE interrupt enable */
    static const uint32_t SPIx_IER_CRCEIE_MASK     = 0x00000080U;   /** @brief CRC interrupt enable */
    static const uint32_t SPIx_IER_OVRIE_MASK      = 0x00000040U;   /** @brief OVR interrupt enable */
    static const uint32_t SPIx_IER_UDRIE_MASK      = 0x00000020U;   /** @brief UDR interrupt enable */
    static const uint32_t SPIx_IER_TXTFIE_MASK     = 0x00000010U;   /** @brief TXTFIE interrupt enable */
    static const uint32_t SPIx_IER_EOTIE_MASK      = 0x00000008U;   /** @brief EOT, SUSP and TXC interrupt enable */
    static const uint32_t SPIx_IER_DPXPIE_MASK     = 0x00000004U;   /** @brief DXP interrupt enabled */
    static const uint32_t SPIx_IER_TXPIE_MASK      = 0x00000002U;   /** @brief TXP interrupt enable */
    static const uint32_t SPIx_IER_RXPIE_MASK      = 0x00000001U;   /** @brief RXP interrupt enable */
    static const uint32_t SPIx_SR_CTSIZE_MASK      = 0xFFFF0000U;   /** @brief Number of data frames remaining in current TSIZE session */
    static const uint32_t SPIx_SR_RXWNE_MASK       = 0x00008000U;   /** @brief RxFIFO word not empty */
    static const uint32_t SPIx_SR_RXPLVL_MASK      = 0x00006000U;   /** @brief RxFIFO packing level */
    static const uint32_t SPIx_SR_TXC_MASK         = 0x00001000U;   /** @brief TxFIFO transmission complete */
    static const uint32_t SPIx_SR_SUSP_MASK        = 0x00000800U;   /** @brief SUSPend */
    static const uint32_t SPIx_SR_TSERF_MASK       = 0x00000400U;   /** @brief Additional number of SPI data to be transacted was reload */
    static const uint32_t SPIx_SR_MODF_MASK        = 0x00000200U;   /** @brief Mode fault */
    static const uint32_t SPIx_SR_TIFRE_MASK       = 0x00000100U;   /** @brief TI frame format error */
    static const uint32_t SPIx_SR_CRCE_MASK        = 0x00000080U;   /** @brief CRC error */
    static const uint32_t SPIx_SR_OVR_MASK         = 0x00000040U;   /** @brief Overrun */
    static const uint32_t SPIx_SR_UDR_MASK         = 0x00000020U;   /** @brief Underrun at slave transmission mode */
    static const uint32_t SPIx_SR_TXTF_MASK        = 0x00000010U;   /** @brief Transmission transfer filled */
    static const uint32_t SPIx_SR_EOT_MASK         = 0x00000008U;   /** @brief End of transfer */
    static const uint32_t SPIx_SR_DXP_MASK         = 0x00000004U;   /** @brief Duplex packet */
    static const uint32_t SPIx_SR_TXP_MASK         = 0x00000002U;   /** @brief Tx-Packet space available */
    static const uint32_t SPIx_SR_RXP_MASK         = 0x00000001U;   /** @brief Rx-Packet available */
    static const uint32_t SPIx_IFCR_SUSPC_MASK     = 0x00000800U;   /** @brief SUSPend flag clear */
    static const uint32_t SPIx_IFCR_TSERFC_MASK    = 0x00000400U;   /** @brief TSERFC flag clear */
    static const uint32_t SPIx_IFCR_MODFC_MASK     = 0x00000200U;   /** @brief Mode fault flag clear */
    static const uint32_t SPIx_IFCR_TIFREC_MASK    = 0x00000100U;   /** @brief TI frame format error flag clear */
    static const uint32_t SPIx_IFCR_CRCEC_MASK     = 0x00000080U;   /** @brief CRC error flag clear */
    static const uint32_t SPIx_IFCR_OVRC_MASK      = 0x00000040U;   /** @brief Overrun flag clear */
    static const uint32_t SPIx_IFCR_UDRC_MASK      = 0x00000020U;   /** @brief Underrun flag clear */
    static const uint32_t SPIx_IFCR_TXTFC_MASK     = 0x00000010U;   /** @brief Transmission transfer filled flag clear */
    static const uint32_t SPIx_IFCR_EOTC_MASK      = 0x00000008U;   /** @brief End of transfer flag clear */
    static const uint32_t SPIx_CGFR_MCKOE_MASK     = 0x02000000U;   /** @brief Master clock output enable */
    static const uint32_t SPIx_CGFR_ODD_MASK       = 0x01000000U;   /** @brief Odd factor for the prescaler */
    static const uint32_t SPIx_CGFR_I2SDIV_MASK    = 0x00FF0000U;   /** @brief I2S linear prescaler */
    static const uint32_t SPIx_CGFR_DATFMT_MASK    = 0x00004000U;   /** @brief Data format */
    static const uint32_t SPIx_CGFR_WSINV_MASK     = 0x00002000U;   /** @brief Fixed channel length in SLAVE */
    static const uint32_t SPIx_CGFR_FIXCH_MASK     = 0x00001000U;   /** @brief Word select inversion */
    static const uint32_t SPIx_CGFR_CKPOL_MASK     = 0x00000800U;   /** @brief Serial audio clock polarity */
    static const uint32_t SPIx_CGFR_CHLEN_MASK     = 0x00000400U;   /** @brief Channel length (number of bits per audio channel) */
    static const uint32_t SPIx_CGFR_DATLEN_MASK    = 0x00000300U;   /** @brief Data length to be transferred */
    static const uint32_t SPIx_CGFR_PCMSYNC_MASK   = 0x00000080U;   /** @brief PCM frame synchronization */
    static const uint32_t SPIx_CGFR_I2SSTD_MASK    = 0x00000030U;   /** @brief I2S standard selection */
    static const uint32_t SPIx_CGFR_I2SCFG_MASK    = 0x0000000EU;   /** @brief I2S configuration mode */
    static const uint32_t SPIx_CGFR_I2SMOD_MASK    = 0x00000001U;   /** @brief I2S mode selection */

    /**** @subsection SPIx Register Field Positions ****/

    static const int32_t SPIx_CR1_IOLOCK_POS     = 16;   /** @brief Locking the AF configuration of associated ios */
    static const int32_t SPIx_CR1_TCRCI_POS      = 15;   /** @brief CRC calculation initialization pattern control for transmitter */
    static const int32_t SPIx_CR1_RCRCI_POS      = 14;   /** @brief CRC calculation initialization pattern control for receiver */
    static const int32_t SPIx_CR1_CRC33_17_POS   = 13;   /** @brief 32-bit CRC polynomial configuration */
    static const int32_t SPIx_CR1_SSI_POS        = 12;   /** @brief Internal SS signal input level */
    static const int32_t SPIx_CR1_HDDIR_POS      = 11;   /** @brief Rx/Tx direction at half-duplex mode */
    static const int32_t SPIx_CR1_CSUSP_POS      = 10;   /** @brief Master suspend request */
    static const int32_t SPIx_CR1_CSTART_POS     = 9;    /** @brief Master transfer start */
    static const int32_t SPIx_CR1_MASRX_POS      = 8;    /** @brief Master automatic SUSP in receive mode */
    static const int32_t SPIx_CR1_SPE_POS        = 0;    /** @brief Serial peripheral enable */
    static const int32_t SPIx_CR2_TSER_POS       = 16;   /** @brief Number of data transfer extension to be reload into TSIZE just when a previous */
    static const int32_t SPIx_CR2_TSIZE_POS      = 0;    /** @brief Number of data at current transfer */
    static const int32_t SPIx_CFG1_MBR_POS       = 28;   /** @brief Master baud rate */
    static const int32_t SPIx_CFG1_CRCEN_POS     = 22;   /** @brief Hardware CRC computation enable */
    static const int32_t SPIx_CFG1_CRCSIZE_POS   = 16;   /** @brief Length of CRC frame to be transacted and compared */
    static const int32_t SPIx_CFG1_TXDMAEN_POS   = 15;   /** @brief Tx DMA stream enable */
    static const int32_t SPIx_CFG1_RXDMAEN_POS   = 14;   /** @brief Rx DMA stream enable */
    static const int32_t SPIx_CFG1_UDRDET_POS    = 11;   /** @brief Detection of underrun condition at slave transmitter */
    static const int32_t SPIx_CFG1_UDRCFG_POS    = 9;    /** @brief Behavior of slave transmitter at underrun condition */
    static const int32_t SPIx_CFG1_FTHVL_POS     = 5;    /** @brief Threshold level */
    static const int32_t SPIx_CFG1_DSIZE_POS     = 0;    /** @brief Number of bits in at single SPI data frame */
    static const int32_t SPIx_CFG2_AFCNTR_POS    = 31;   /** @brief Alternate function gpios control */
    static const int32_t SPIx_CFG2_SSOM_POS      = 30;   /** @brief SS output management in master mode */
    static const int32_t SPIx_CFG2_SSOE_POS      = 29;   /** @brief SS output enable */
    static const int32_t SPIx_CFG2_SSIOP_POS     = 28;   /** @brief SS input/output polarity */
    static const int32_t SPIx_CFG2_SSM_POS       = 26;   /** @brief Software management of SS signal input */
    static const int32_t SPIx_CFG2_CPOL_POS      = 25;   /** @brief Clock polarity */
    static const int32_t SPIx_CFG2_CPHA_POS      = 24;   /** @brief Clock phase */
    static const int32_t SPIx_CFG2_LSBFRST_POS   = 23;   /** @brief Data frame format */
    static const int32_t SPIx_CFG2_MASTER_POS    = 22;   /** @brief SPI master */
    static const int32_t SPIx_CFG2_SP_POS        = 19;   /** @brief Serial protocol */
    static const int32_t SPIx_CFG2_COMM_POS      = 17;   /** @brief SPI communication mode */
    static const int32_t SPIx_CFG2_IOSWP_POS     = 15;   /** @brief Swap functionality of MISO and MOSI pins */
    static const int32_t SPIx_CFG2_MIDI_POS      = 4;    /** @brief Master inter-data idleness */
    static const int32_t SPIx_CFG2_MSSI_POS      = 0;    /** @brief Master SS idleness */
    static const int32_t SPIx_IER_TSERFIE_POS    = 10;   /** @brief Additional number of transactions reload interrupt enable */
    static const int32_t SPIx_IER_MODFIE_POS     = 9;    /** @brief Mode fault interrupt enable */
    static const int32_t SPIx_IER_TIFREIE_POS    = 8;    /** @brief TIFRE interrupt enable */
    static const int32_t SPIx_IER_CRCEIE_POS     = 7;    /** @brief CRC interrupt enable */
    static const int32_t SPIx_IER_OVRIE_POS      = 6;    /** @brief OVR interrupt enable */
    static const int32_t SPIx_IER_UDRIE_POS      = 5;    /** @brief UDR interrupt enable */
    static const int32_t SPIx_IER_TXTFIE_POS     = 4;    /** @brief TXTFIE interrupt enable */
    static const int32_t SPIx_IER_EOTIE_POS      = 3;    /** @brief EOT, SUSP and TXC interrupt enable */
    static const int32_t SPIx_IER_DPXPIE_POS     = 2;    /** @brief DXP interrupt enabled */
    static const int32_t SPIx_IER_TXPIE_POS      = 1;    /** @brief TXP interrupt enable */
    static const int32_t SPIx_IER_RXPIE_POS      = 0;    /** @brief RXP interrupt enable */
    static const int32_t SPIx_SR_CTSIZE_POS      = 16;   /** @brief Number of data frames remaining in current TSIZE session */
    static const int32_t SPIx_SR_RXWNE_POS       = 15;   /** @brief RxFIFO word not empty */
    static const int32_t SPIx_SR_RXPLVL_POS      = 13;   /** @brief RxFIFO packing level */
    static const int32_t SPIx_SR_TXC_POS         = 12;   /** @brief TxFIFO transmission complete */
    static const int32_t SPIx_SR_SUSP_POS        = 11;   /** @brief SUSPend */
    static const int32_t SPIx_SR_TSERF_POS       = 10;   /** @brief Additional number of SPI data to be transacted was reload */
    static const int32_t SPIx_SR_MODF_POS        = 9;    /** @brief Mode fault */
    static const int32_t SPIx_SR_TIFRE_POS       = 8;    /** @brief TI frame format error */
    static const int32_t SPIx_SR_CRCE_POS        = 7;    /** @brief CRC error */
    static const int32_t SPIx_SR_OVR_POS         = 6;    /** @brief Overrun */
    static const int32_t SPIx_SR_UDR_POS         = 5;    /** @brief Underrun at slave transmission mode */
    static const int32_t SPIx_SR_TXTF_POS        = 4;    /** @brief Transmission transfer filled */
    static const int32_t SPIx_SR_EOT_POS         = 3;    /** @brief End of transfer */
    static const int32_t SPIx_SR_DXP_POS         = 2;    /** @brief Duplex packet */
    static const int32_t SPIx_SR_TXP_POS         = 1;    /** @brief Tx-Packet space available */
    static const int32_t SPIx_SR_RXP_POS         = 0;    /** @brief Rx-Packet available */
    static const int32_t SPIx_IFCR_SUSPC_POS     = 11;   /** @brief SUSPend flag clear */
    static const int32_t SPIx_IFCR_TSERFC_POS    = 10;   /** @brief TSERFC flag clear */
    static const int32_t SPIx_IFCR_MODFC_POS     = 9;    /** @brief Mode fault flag clear */
    static const int32_t SPIx_IFCR_TIFREC_POS    = 8;    /** @brief TI frame format error flag clear */
    static const int32_t SPIx_IFCR_CRCEC_POS     = 7;    /** @brief CRC error flag clear */
    static const int32_t SPIx_IFCR_OVRC_POS      = 6;    /** @brief Overrun flag clear */
    static const int32_t SPIx_IFCR_UDRC_POS      = 5;    /** @brief Underrun flag clear */
    static const int32_t SPIx_IFCR_TXTFC_POS     = 4;    /** @brief Transmission transfer filled flag clear */
    static const int32_t SPIx_IFCR_EOTC_POS      = 3;    /** @brief End of transfer flag clear */
    static const int32_t SPIx_CGFR_MCKOE_POS     = 25;   /** @brief Master clock output enable */
    static const int32_t SPIx_CGFR_ODD_POS       = 24;   /** @brief Odd factor for the prescaler */
    static const int32_t SPIx_CGFR_I2SDIV_POS    = 16;   /** @brief I2S linear prescaler */
    static const int32_t SPIx_CGFR_DATFMT_POS    = 14;   /** @brief Data format */
    static const int32_t SPIx_CGFR_WSINV_POS     = 13;   /** @brief Fixed channel length in SLAVE */
    static const int32_t SPIx_CGFR_FIXCH_POS     = 12;   /** @brief Word select inversion */
    static const int32_t SPIx_CGFR_CKPOL_POS     = 11;   /** @brief Serial audio clock polarity */
    static const int32_t SPIx_CGFR_CHLEN_POS     = 10;   /** @brief Channel length (number of bits per audio channel) */
    static const int32_t SPIx_CGFR_DATLEN_POS    = 8;    /** @brief Data length to be transferred */
    static const int32_t SPIx_CGFR_PCMSYNC_POS   = 7;    /** @brief PCM frame synchronization */
    static const int32_t SPIx_CGFR_I2SSTD_POS    = 4;    /** @brief I2S standard selection */
    static const int32_t SPIx_CGFR_I2SCFG_POS    = 1;    /** @brief I2S configuration mode */
    static const int32_t SPIx_CGFR_I2SMOD_POS    = 0;    /** @brief I2S mode selection */

    /**********************************************************************************************
     * @section LTDC Register Information
     **********************************************************************************************/

    /**** @subsection LTDC Register Pointers ****/

    static RW_ uint32_t* const LTDC_SSCR_PTR    = (RW_ uint32_t* const)0x50001008U;   /** @brief Synchronization size configuration register */
    static RW_ uint32_t* const LTDC_BPCR_PTR    = (RW_ uint32_t* const)0x5000100CU;   /** @brief Back porch configuration register */
    static RW_ uint32_t* const LTDC_AWCR_PTR    = (RW_ uint32_t* const)0x50001010U;   /** @brief Active width configuration register */
    static RW_ uint32_t* const LTDC_TWCR_PTR    = (RW_ uint32_t* const)0x50001014U;   /** @brief Total width configuration register */
    static RW_ uint32_t* const LTDC_GCR_PTR     = (RW_ uint32_t* const)0x50001018U;   /** @brief Global control register */
    static RW_ uint32_t* const LTDC_SRCR_PTR    = (RW_ uint32_t* const)0x50001024U;   /** @brief Shadow reload configuration register */
    static RW_ uint32_t* const LTDC_BCCR_PTR    = (RW_ uint32_t* const)0x5000102CU;   /** @brief Background color configuration register */
    static RW_ uint32_t* const LTDC_IER_PTR     = (RW_ uint32_t* const)0x50001034U;   /** @brief Interrupt enable register */
    static RO_ uint32_t* const LTDC_ISR_PTR     = (RO_ uint32_t* const)0x50001038U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const LTDC_ICR_PTR     = (RW_ uint32_t* const)0x5000103CU;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const LTDC_LIPCR_PTR   = (RW_ uint32_t* const)0x50001040U;   /** @brief Line interrupt position configuration register */
    static RO_ uint32_t* const LTDC_CPSR_PTR    = (RO_ uint32_t* const)0x50001044U;   /** @brief Current position status register */
    static RO_ uint32_t* const LTDC_CDSR_PTR    = (RO_ uint32_t* const)0x50001048U;   /** @brief Current display status register */

    /**** @subsection Enumerated LTDC Register Pointers ****/

    static RW_ uint32_t* const LTDC_LxCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50001084U,   /** @brief Layerx control register */
      [2] = (RW_ uint32_t* const)0x50001104U,   /** @brief Layerx control register */
    };

    static RW_ uint32_t* const LTDC_LxWHPCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50001088U,   /** @brief Layerx window horizontal position configuration register */
      [2] = (RW_ uint32_t* const)0x50001108U,   /** @brief Layerx window horizontal position configuration register */
    };

    static RW_ uint32_t* const LTDC_LxWVPCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5000108CU,   /** @brief Layerx window vertical position configuration register */
      [2] = (RW_ uint32_t* const)0x5000110CU,   /** @brief Layerx window vertical position configuration register */
    };

    static RW_ uint32_t* const LTDC_LxCKCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50001090U,   /** @brief Layerx color keying configuration register */
      [2] = (RW_ uint32_t* const)0x50001110U,   /** @brief Layerx color keying configuration register */
    };

    static RW_ uint32_t* const LTDC_LxPFCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50001094U,   /** @brief Layerx pixel format configuration register */
      [2] = (RW_ uint32_t* const)0x50001114U,   /** @brief Layerx pixel format configuration register */
    };

    static RW_ uint32_t* const LTDC_LxCACR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x50001098U,   /** @brief Layerx constant alpha configuration register */
      [2] = (RW_ uint32_t* const)0x50001118U,   /** @brief Layerx constant alpha configuration register */
    };

    static RW_ uint32_t* const LTDC_LxDCCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5000109CU,   /** @brief Layerx default color configuration register */
      [2] = (RW_ uint32_t* const)0x5000111CU,   /** @brief Layerx default color configuration register */
    };

    static RW_ uint32_t* const LTDC_LxBFCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x500010A0U,   /** @brief Layerx blending factors configuration register */
      [2] = (RW_ uint32_t* const)0x50001120U,   /** @brief Layerx blending factors configuration register */
    };

    static RW_ uint32_t* const LTDC_LxCFBAR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x500010ACU,   /** @brief Layerx color frame buffer address register */
      [2] = (RW_ uint32_t* const)0x5000112CU,   /** @brief Layerx color frame buffer address register */
    };

    static RW_ uint32_t* const LTDC_LxCFBLR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x500010B0U,   /** @brief Layerx color frame buffer length register */
      [2] = (RW_ uint32_t* const)0x50001130U,   /** @brief Layerx color frame buffer length register */
    };

    static RW_ uint32_t* const LTDC_LxCFBLNR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x500010B4U,   /** @brief Layerx colorframe buffer line number register */
      [2] = (RW_ uint32_t* const)0x50001134U,   /** @brief Layerx colorframe buffer line number register */
    };

    static RW_ uint32_t* const LTDC_LxCLUTWR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x500010C4U,   /** @brief Layerx CLUT write register */
      [2] = (RW_ uint32_t* const)0x50001144U,   /** @brief Layerx CLUT write register */
    };

    /**** @subsection LTDC Register Reset Values ****/

    static const uint32_t LTDC_SSCR_RST    = 0x00000000U;   /** @brief SSCR register reset value. */
    static const uint32_t LTDC_BPCR_RST    = 0x00000000U;   /** @brief BPCR register reset value. */
    static const uint32_t LTDC_AWCR_RST    = 0x00000000U;   /** @brief AWCR register reset value. */
    static const uint32_t LTDC_TWCR_RST    = 0x00000000U;   /** @brief TWCR register reset value. */
    static const uint32_t LTDC_GCR_RST     = 0x00002220U;   /** @brief GCR register reset value. */
    static const uint32_t LTDC_SRCR_RST    = 0x00000000U;   /** @brief SRCR register reset value. */
    static const uint32_t LTDC_BCCR_RST    = 0x00000000U;   /** @brief BCCR register reset value. */
    static const uint32_t LTDC_IER_RST     = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t LTDC_ISR_RST     = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t LTDC_ICR_RST     = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t LTDC_LIPCR_RST   = 0x00000000U;   /** @brief LIPCR register reset value. */
    static const uint32_t LTDC_CPSR_RST    = 0x00000000U;   /** @brief CPSR register reset value. */
    static const uint32_t LTDC_CDSR_RST    = 0x0000000FU;   /** @brief CDSR register reset value. */

    /**** @subsection Enumerated LTDC Register Reset Values ****/

    static const uint32_t LTDC_LxCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1CR register reset value. */
      [2] = 0x00000000U,   /** @brief L2CR register reset value. */
    };

    static const uint32_t LTDC_LxWHPCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1WHPCR register reset value. */
      [2] = 0x00000000U,   /** @brief L2WHPCR register reset value. */
    };

    static const uint32_t LTDC_LxWVPCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1WVPCR register reset value. */
      [2] = 0x00000000U,   /** @brief L2WVPCR register reset value. */
    };

    static const uint32_t LTDC_LxCKCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1CKCR register reset value. */
      [2] = 0x00000000U,   /** @brief L2CKCR register reset value. */
    };

    static const uint32_t LTDC_LxPFCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1PFCR register reset value. */
      [2] = 0x00000000U,   /** @brief L2PFCR register reset value. */
    };

    static const uint32_t LTDC_LxCACR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1CACR register reset value. */
      [2] = 0x00000000U,   /** @brief L2CACR register reset value. */
    };

    static const uint32_t LTDC_LxDCCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1DCCR register reset value. */
      [2] = 0x00000000U,   /** @brief L2DCCR register reset value. */
    };

    static const uint32_t LTDC_LxBFCR_RST[3] = {
      [1] = 0x00000607U,   /** @brief L1BFCR register reset value. */
      [2] = 0x00000607U,   /** @brief L2BFCR register reset value. */
    };

    static const uint32_t LTDC_LxCFBAR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1CFBAR register reset value. */
      [2] = 0x00000000U,   /** @brief L2CFBAR register reset value. */
    };

    static const uint32_t LTDC_LxCFBLR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1CFBLR register reset value. */
      [2] = 0x00000000U,   /** @brief L2CFBLR register reset value. */
    };

    static const uint32_t LTDC_LxCFBLNR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1CFBLNR register reset value. */
      [2] = 0x00000000U,   /** @brief L2CFBLNR register reset value. */
    };

    static const uint32_t LTDC_LxCLUTWR_RST[3] = {
      [1] = 0x00000000U,   /** @brief L1CLUTWR register reset value. */
      [2] = 0x00000000U,   /** @brief L2CLUTWR register reset value. */
    };

    /**** @subsection Enumerated LTDC Register Value Types ****/

    typedef uint32_t LTDC_SSCR_t;       /** @brief SSCR register value type. */
    typedef uint32_t LTDC_BPCR_t;       /** @brief BPCR register value type. */
    typedef uint32_t LTDC_AWCR_t;       /** @brief AWCR register value type. */
    typedef uint32_t LTDC_TWCR_t;       /** @brief TWCR register value type. */
    typedef uint32_t LTDC_GCR_t;        /** @brief GCR register value type. */
    typedef uint32_t LTDC_SRCR_t;       /** @brief SRCR register value type. */
    typedef uint32_t LTDC_BCCR_t;       /** @brief BCCR register value type. */
    typedef uint32_t LTDC_IER_t;        /** @brief IER register value type. */
    typedef uint32_t LTDC_ISR_t;        /** @brief ISR register value type. */
    typedef uint32_t LTDC_ICR_t;        /** @brief ICR register value type. */
    typedef uint32_t LTDC_LIPCR_t;      /** @brief LIPCR register value type. */
    typedef uint32_t LTDC_CPSR_t;       /** @brief CPSR register value type. */
    typedef uint32_t LTDC_CDSR_t;       /** @brief CDSR register value type. */
    typedef uint32_t LTDC_LxCR_t;       /** @brief LxCR register value type. */
    typedef uint32_t LTDC_LxWHPCR_t;    /** @brief LxWHPCR register value type. */
    typedef uint32_t LTDC_LxWVPCR_t;    /** @brief LxWVPCR register value type. */
    typedef uint32_t LTDC_LxCKCR_t;     /** @brief LxCKCR register value type. */
    typedef uint32_t LTDC_LxPFCR_t;     /** @brief LxPFCR register value type. */
    typedef uint32_t LTDC_LxCACR_t;     /** @brief LxCACR register value type. */
    typedef uint32_t LTDC_LxDCCR_t;     /** @brief LxDCCR register value type. */
    typedef uint32_t LTDC_LxBFCR_t;     /** @brief LxBFCR register value type. */
    typedef uint32_t LTDC_LxCFBAR_t;    /** @brief LxCFBAR register value type. */
    typedef uint32_t LTDC_LxCFBLR_t;    /** @brief LxCFBLR register value type. */
    typedef uint32_t LTDC_LxCFBLNR_t;   /** @brief LxCFBLNR register value type. */
    typedef uint32_t LTDC_LxCLUTWR_t;   /** @brief LxCLUTWR register value type. */

    /**** @subsection Enumerated LTDC Register Pointer Types ****/

    typedef uint32_t* const LTDC_SSCR_PTR_t;       /** @brief SSCR register pointer type. */
    typedef uint32_t* const LTDC_BPCR_PTR_t;       /** @brief BPCR register pointer type. */
    typedef uint32_t* const LTDC_AWCR_PTR_t;       /** @brief AWCR register pointer type. */
    typedef uint32_t* const LTDC_TWCR_PTR_t;       /** @brief TWCR register pointer type. */
    typedef uint32_t* const LTDC_GCR_PTR_t;        /** @brief GCR register pointer type. */
    typedef uint32_t* const LTDC_SRCR_PTR_t;       /** @brief SRCR register pointer type. */
    typedef uint32_t* const LTDC_BCCR_PTR_t;       /** @brief BCCR register pointer type. */
    typedef uint32_t* const LTDC_IER_PTR_t;        /** @brief IER register pointer type. */
    typedef uint32_t* const LTDC_ISR_PTR_t;        /** @brief ISR register pointer type. */
    typedef uint32_t* const LTDC_ICR_PTR_t;        /** @brief ICR register pointer type. */
    typedef uint32_t* const LTDC_LIPCR_PTR_t;      /** @brief LIPCR register pointer type. */
    typedef uint32_t* const LTDC_CPSR_PTR_t;       /** @brief CPSR register pointer type. */
    typedef uint32_t* const LTDC_CDSR_PTR_t;       /** @brief CDSR register pointer type. */
    typedef uint32_t* const LTDC_LxCR_PTR_t;       /** @brief LxCR register pointer type. */
    typedef uint32_t* const LTDC_LxWHPCR_PTR_t;    /** @brief LxWHPCR register pointer type. */
    typedef uint32_t* const LTDC_LxWVPCR_PTR_t;    /** @brief LxWVPCR register pointer type. */
    typedef uint32_t* const LTDC_LxCKCR_PTR_t;     /** @brief LxCKCR register pointer type. */
    typedef uint32_t* const LTDC_LxPFCR_PTR_t;     /** @brief LxPFCR register pointer type. */
    typedef uint32_t* const LTDC_LxCACR_PTR_t;     /** @brief LxCACR register pointer type. */
    typedef uint32_t* const LTDC_LxDCCR_PTR_t;     /** @brief LxDCCR register pointer type. */
    typedef uint32_t* const LTDC_LxBFCR_PTR_t;     /** @brief LxBFCR register pointer type. */
    typedef uint32_t* const LTDC_LxCFBAR_PTR_t;    /** @brief LxCFBAR register pointer type. */
    typedef uint32_t* const LTDC_LxCFBLR_PTR_t;    /** @brief LxCFBLR register pointer type. */
    typedef uint32_t* const LTDC_LxCFBLNR_PTR_t;   /** @brief LxCFBLNR register pointer type. */
    typedef uint32_t* const LTDC_LxCLUTWR_PTR_t;   /** @brief LxCLUTWR register pointer type. */

    /**** @subsection LTDC Register Field Masks ****/

    static const uint32_t LTDC_SSCR_HSW_MASK           = 0x03FF0000U;   /** @brief Horizontal synchronization width (in units of pixel clock period) */
    static const uint32_t LTDC_SSCR_VSH_MASK           = 0x000007FFU;   /** @brief Vertical synchronization height (in units of horizontal scan line) */
    static const uint32_t LTDC_BPCR_AHBP_MASK          = 0x0FFF0000U;   /** @brief Accumulated horizontal back porch (in units of pixel clock period) */
    static const uint32_t LTDC_BPCR_AVBP_MASK          = 0x000007FFU;   /** @brief Accumulated vertical back porch (in units of horizontal scan line) */
    static const uint32_t LTDC_AWCR_AAV_MASK           = 0x0FFF0000U;   /** @brief AAV */
    static const uint32_t LTDC_AWCR_AAH_MASK           = 0x000007FFU;   /** @brief Accumulated active height (in units of horizontal scan line) */
    static const uint32_t LTDC_TWCR_TOTALW_MASK        = 0x0FFF0000U;   /** @brief Total width (in units of pixel clock period) */
    static const uint32_t LTDC_TWCR_TOTALH_MASK        = 0x000007FFU;   /** @brief Total height (in units of horizontal scan line) */
    static const uint32_t LTDC_GCR_HSPOL_MASK          = 0x80000000U;   /** @brief Horizontal synchronization polarity */
    static const uint32_t LTDC_GCR_VSPOL_MASK          = 0x40000000U;   /** @brief Vertical synchronization polarity */
    static const uint32_t LTDC_GCR_DEPOL_MASK          = 0x20000000U;   /** @brief Data enable polarity */
    static const uint32_t LTDC_GCR_PCPOL_MASK          = 0x10000000U;   /** @brief Pixel clock polarity */
    static const uint32_t LTDC_GCR_DEN_MASK            = 0x00010000U;   /** @brief Dither enable */
    static const uint32_t LTDC_GCR_DRW_MASK            = 0x00007000U;   /** @brief Dither red width */
    static const uint32_t LTDC_GCR_DGW_MASK            = 0x00000700U;   /** @brief Dither green width */
    static const uint32_t LTDC_GCR_DBW_MASK            = 0x00000070U;   /** @brief Dither blue width */
    static const uint32_t LTDC_GCR_LTDCEN_MASK         = 0x00000001U;   /** @brief LCD-TFT controller enable bit */
    static const uint32_t LTDC_SRCR_VBR_MASK           = 0x00000002U;   /** @brief Vertical blanking reload */
    static const uint32_t LTDC_SRCR_IMR_MASK           = 0x00000001U;   /** @brief Immediate reload */
    static const uint32_t LTDC_BCCR_BCBLUE_MASK        = 0x000000FFU;   /** @brief Background color blue value */
    static const uint32_t LTDC_BCCR_BCGREEN_MASK       = 0x0000FF00U;   /** @brief Background color green value */
    static const uint32_t LTDC_BCCR_BCRED_MASK         = 0x00FF0000U;   /** @brief Background color red value */
    static const uint32_t LTDC_IER_RRIE_MASK           = 0x00000008U;   /** @brief Register reload interrupt enable */
    static const uint32_t LTDC_IER_TERRIE_MASK         = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t LTDC_IER_FUIE_MASK           = 0x00000002U;   /** @brief FIFO underrun interrupt enable */
    static const uint32_t LTDC_IER_LIE_MASK            = 0x00000001U;   /** @brief Line interrupt enable */
    static const uint32_t LTDC_ISR_RRIF_MASK           = 0x00000008U;   /** @brief Register reload interrupt flag */
    static const uint32_t LTDC_ISR_TERRIF_MASK         = 0x00000004U;   /** @brief Transfer error interrupt flag */
    static const uint32_t LTDC_ISR_FUIF_MASK           = 0x00000002U;   /** @brief FIFO underrun interrupt flag */
    static const uint32_t LTDC_ISR_LIF_MASK            = 0x00000001U;   /** @brief Line interrupt flag */
    static const uint32_t LTDC_ICR_CRRIF_MASK          = 0x00000008U;   /** @brief Clears register reload interrupt flag */
    static const uint32_t LTDC_ICR_CTERRIF_MASK        = 0x00000004U;   /** @brief Clears the transfer error interrupt flag */
    static const uint32_t LTDC_ICR_CFUIF_MASK          = 0x00000002U;   /** @brief Clears the FIFO underrun interrupt flag */
    static const uint32_t LTDC_ICR_CLIF_MASK           = 0x00000001U;   /** @brief Clears the line interrupt flag */
    static const uint32_t LTDC_LIPCR_LIPOS_MASK        = 0x000007FFU;   /** @brief Line interrupt position */
    static const uint32_t LTDC_CPSR_CXPOS_MASK         = 0xFFFF0000U;   /** @brief Current X position */
    static const uint32_t LTDC_CPSR_CYPOS_MASK         = 0x0000FFFFU;   /** @brief Current Y position */
    static const uint32_t LTDC_CDSR_HSYNCS_MASK        = 0x00000008U;   /** @brief Horizontal synchronization display status */
    static const uint32_t LTDC_CDSR_VSYNCS_MASK        = 0x00000004U;   /** @brief Vertical synchronization display status */
    static const uint32_t LTDC_CDSR_HDES_MASK          = 0x00000002U;   /** @brief Horizontal data enable display status */
    static const uint32_t LTDC_CDSR_VDES_MASK          = 0x00000001U;   /** @brief Vertical data enable display status */
    static const uint32_t LTDC_LxCR_CLUTEN_MASK        = 0x00000010U;   /** @brief Color look-up table enable */
    static const uint32_t LTDC_LxCR_COLKEN_MASK        = 0x00000002U;   /** @brief Color keying enable */
    static const uint32_t LTDC_LxCR_LEN_MASK           = 0x00000001U;   /** @brief Layer enable */
    static const uint32_t LTDC_LxWHPCR_WHSPPOS_MASK    = 0x0FFF0000U;   /** @brief Window horizontal stop position */
    static const uint32_t LTDC_LxWHPCR_WHSTPOS_MASK    = 0x00000FFFU;   /** @brief Window horizontal start position */
    static const uint32_t LTDC_LxWVPCR_WVSPPOS_MASK    = 0x07FF0000U;   /** @brief Window vertical stop position */
    static const uint32_t LTDC_LxWVPCR_WVSTPOS_MASK    = 0x000007FFU;   /** @brief Window vertical start position */
    static const uint32_t LTDC_LxCKCR_CKRED_MASK       = 0x00FF0000U;   /** @brief Color key red value */
    static const uint32_t LTDC_LxCKCR_CKGREEN_MASK     = 0x0000FF00U;   /** @brief Color key green value */
    static const uint32_t LTDC_LxCKCR_CKBLUE_MASK      = 0x000000FFU;   /** @brief Color key blue value */
    static const uint32_t LTDC_LxPFCR_PF_MASK          = 0x00000007U;   /** @brief Pixel format */
    static const uint32_t LTDC_LxCACR_CONSTA_MASK      = 0x000000FFU;   /** @brief Constant alpha */
    static const uint32_t LTDC_LxDCCR_DCALPHA_MASK     = 0xFF000000U;   /** @brief Default color alpha */
    static const uint32_t LTDC_LxDCCR_DCRED_MASK       = 0x00FF0000U;   /** @brief Default color red */
    static const uint32_t LTDC_LxDCCR_DCGREEN_MASK     = 0x0000FF00U;   /** @brief Default color green */
    static const uint32_t LTDC_LxDCCR_DCBLUE_MASK      = 0x000000FFU;   /** @brief Default color blue */
    static const uint32_t LTDC_LxCFBLR_CFBP_MASK       = 0x1FFF0000U;   /** @brief Color frame buffer pitch in bytes */
    static const uint32_t LTDC_LxCFBLR_CFBLL_MASK      = 0x00001FFFU;   /** @brief Color frame buffer line length */
    static const uint32_t LTDC_LxCFBLNR_CFBLNBR_MASK   = 0x000007FFU;   /** @brief Frame buffer line number */
    static const uint32_t LTDC_LxCLUTWR_CLUTADD_MASK   = 0xFF000000U;   /** @brief CLUT address */
    static const uint32_t LTDC_LxCLUTWR_RED_MASK       = 0x00FF0000U;   /** @brief Red value */
    static const uint32_t LTDC_LxCLUTWR_GREEN_MASK     = 0x0000FF00U;   /** @brief Green value */
    static const uint32_t LTDC_LxCLUTWR_BLUE_MASK      = 0x000000FFU;   /** @brief Blue value */

    /**** @subsection Enumerated LTDC Register Field Masks ****/

    static const uint32_t LTDC_LxBFCR_BFx_MASK[3] = {
      [1] = 0x00000700U,   /** @brief Blending factor 1 */
      [2] = 0x00000007U,   /** @brief Blending factor 2 */
    };

    /**** @subsection LTDC Register Field Positions ****/

    static const int32_t LTDC_SSCR_HSW_POS           = 16;   /** @brief Horizontal synchronization width (in units of pixel clock period) */
    static const int32_t LTDC_SSCR_VSH_POS           = 0;    /** @brief Vertical synchronization height (in units of horizontal scan line) */
    static const int32_t LTDC_BPCR_AHBP_POS          = 16;   /** @brief Accumulated horizontal back porch (in units of pixel clock period) */
    static const int32_t LTDC_BPCR_AVBP_POS          = 0;    /** @brief Accumulated vertical back porch (in units of horizontal scan line) */
    static const int32_t LTDC_AWCR_AAV_POS           = 16;   /** @brief AAV */
    static const int32_t LTDC_AWCR_AAH_POS           = 0;    /** @brief Accumulated active height (in units of horizontal scan line) */
    static const int32_t LTDC_TWCR_TOTALW_POS        = 16;   /** @brief Total width (in units of pixel clock period) */
    static const int32_t LTDC_TWCR_TOTALH_POS        = 0;    /** @brief Total height (in units of horizontal scan line) */
    static const int32_t LTDC_GCR_HSPOL_POS          = 31;   /** @brief Horizontal synchronization polarity */
    static const int32_t LTDC_GCR_VSPOL_POS          = 30;   /** @brief Vertical synchronization polarity */
    static const int32_t LTDC_GCR_DEPOL_POS          = 29;   /** @brief Data enable polarity */
    static const int32_t LTDC_GCR_PCPOL_POS          = 28;   /** @brief Pixel clock polarity */
    static const int32_t LTDC_GCR_DEN_POS            = 16;   /** @brief Dither enable */
    static const int32_t LTDC_GCR_DRW_POS            = 12;   /** @brief Dither red width */
    static const int32_t LTDC_GCR_DGW_POS            = 8;    /** @brief Dither green width */
    static const int32_t LTDC_GCR_DBW_POS            = 4;    /** @brief Dither blue width */
    static const int32_t LTDC_GCR_LTDCEN_POS         = 0;    /** @brief LCD-TFT controller enable bit */
    static const int32_t LTDC_SRCR_VBR_POS           = 1;    /** @brief Vertical blanking reload */
    static const int32_t LTDC_SRCR_IMR_POS           = 0;    /** @brief Immediate reload */
    static const int32_t LTDC_BCCR_BCBLUE_POS        = 0;    /** @brief Background color blue value */
    static const int32_t LTDC_BCCR_BCGREEN_POS       = 8;    /** @brief Background color green value */
    static const int32_t LTDC_BCCR_BCRED_POS         = 16;   /** @brief Background color red value */
    static const int32_t LTDC_IER_RRIE_POS           = 3;    /** @brief Register reload interrupt enable */
    static const int32_t LTDC_IER_TERRIE_POS         = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t LTDC_IER_FUIE_POS           = 1;    /** @brief FIFO underrun interrupt enable */
    static const int32_t LTDC_IER_LIE_POS            = 0;    /** @brief Line interrupt enable */
    static const int32_t LTDC_ISR_RRIF_POS           = 3;    /** @brief Register reload interrupt flag */
    static const int32_t LTDC_ISR_TERRIF_POS         = 2;    /** @brief Transfer error interrupt flag */
    static const int32_t LTDC_ISR_FUIF_POS           = 1;    /** @brief FIFO underrun interrupt flag */
    static const int32_t LTDC_ISR_LIF_POS            = 0;    /** @brief Line interrupt flag */
    static const int32_t LTDC_ICR_CRRIF_POS          = 3;    /** @brief Clears register reload interrupt flag */
    static const int32_t LTDC_ICR_CTERRIF_POS        = 2;    /** @brief Clears the transfer error interrupt flag */
    static const int32_t LTDC_ICR_CFUIF_POS          = 1;    /** @brief Clears the FIFO underrun interrupt flag */
    static const int32_t LTDC_ICR_CLIF_POS           = 0;    /** @brief Clears the line interrupt flag */
    static const int32_t LTDC_LIPCR_LIPOS_POS        = 0;    /** @brief Line interrupt position */
    static const int32_t LTDC_CPSR_CXPOS_POS         = 16;   /** @brief Current X position */
    static const int32_t LTDC_CPSR_CYPOS_POS         = 0;    /** @brief Current Y position */
    static const int32_t LTDC_CDSR_HSYNCS_POS        = 3;    /** @brief Horizontal synchronization display status */
    static const int32_t LTDC_CDSR_VSYNCS_POS        = 2;    /** @brief Vertical synchronization display status */
    static const int32_t LTDC_CDSR_HDES_POS          = 1;    /** @brief Horizontal data enable display status */
    static const int32_t LTDC_CDSR_VDES_POS          = 0;    /** @brief Vertical data enable display status */
    static const int32_t LTDC_LxCR_CLUTEN_POS        = 4;    /** @brief Color look-up table enable */
    static const int32_t LTDC_LxCR_COLKEN_POS        = 1;    /** @brief Color keying enable */
    static const int32_t LTDC_LxCR_LEN_POS           = 0;    /** @brief Layer enable */
    static const int32_t LTDC_LxWHPCR_WHSPPOS_POS    = 16;   /** @brief Window horizontal stop position */
    static const int32_t LTDC_LxWHPCR_WHSTPOS_POS    = 0;    /** @brief Window horizontal start position */
    static const int32_t LTDC_LxWVPCR_WVSPPOS_POS    = 16;   /** @brief Window vertical stop position */
    static const int32_t LTDC_LxWVPCR_WVSTPOS_POS    = 0;    /** @brief Window vertical start position */
    static const int32_t LTDC_LxCKCR_CKRED_POS       = 16;   /** @brief Color key red value */
    static const int32_t LTDC_LxCKCR_CKGREEN_POS     = 8;    /** @brief Color key green value */
    static const int32_t LTDC_LxCKCR_CKBLUE_POS      = 0;    /** @brief Color key blue value */
    static const int32_t LTDC_LxPFCR_PF_POS          = 0;    /** @brief Pixel format */
    static const int32_t LTDC_LxCACR_CONSTA_POS      = 0;    /** @brief Constant alpha */
    static const int32_t LTDC_LxDCCR_DCALPHA_POS     = 24;   /** @brief Default color alpha */
    static const int32_t LTDC_LxDCCR_DCRED_POS       = 16;   /** @brief Default color red */
    static const int32_t LTDC_LxDCCR_DCGREEN_POS     = 8;    /** @brief Default color green */
    static const int32_t LTDC_LxDCCR_DCBLUE_POS      = 0;    /** @brief Default color blue */
    static const int32_t LTDC_LxCFBLR_CFBP_POS       = 16;   /** @brief Color frame buffer pitch in bytes */
    static const int32_t LTDC_LxCFBLR_CFBLL_POS      = 0;    /** @brief Color frame buffer line length */
    static const int32_t LTDC_LxCFBLNR_CFBLNBR_POS   = 0;    /** @brief Frame buffer line number */
    static const int32_t LTDC_LxCLUTWR_CLUTADD_POS   = 24;   /** @brief CLUT address */
    static const int32_t LTDC_LxCLUTWR_RED_POS       = 16;   /** @brief Red value */
    static const int32_t LTDC_LxCLUTWR_GREEN_POS     = 8;    /** @brief Green value */
    static const int32_t LTDC_LxCLUTWR_BLUE_POS      = 0;    /** @brief Blue value */

    /**** @subsection Enumerated LTDC Register Field Positions ****/

    static const int32_t LTDC_LxBFCR_BFx_POS[3] = {
      [1] = 8,   /** @brief Blending factor 1 */
      [2] = 0,   /** @brief Blending factor 2 */
    };

    /**********************************************************************************************
     * @section SPDIFRX Register Information
     **********************************************************************************************/

    /**** @subsection SPDIFRX Register Pointers ****/

    static RW_ uint32_t* const SPDIFRX_CR_PTR      = (RW_ uint32_t* const)0x40004000U;   /** @brief Control register */
    static RW_ uint32_t* const SPDIFRX_IMR_PTR     = (RW_ uint32_t* const)0x40004004U;   /** @brief Interrupt mask register */
    static RO_ uint32_t* const SPDIFRX_SR_PTR      = (RO_ uint32_t* const)0x40004008U;   /** @brief Status register */
    static RW_ uint32_t* const SPDIFRX_IFCR_PTR    = (RW_ uint32_t* const)0x4000400CU;   /** @brief Interrupt flag clear register */
    static RO_ uint32_t* const SPDIFRX_DR_00_PTR   = (RO_ uint32_t* const)0x40004010U;   /** @brief Data input register */
    static RO_ uint32_t* const SPDIFRX_CSR_PTR     = (RO_ uint32_t* const)0x40004014U;   /** @brief Channel status register */
    static RO_ uint32_t* const SPDIFRX_DIR_PTR     = (RO_ uint32_t* const)0x40004018U;   /** @brief Debug information register */
    static RO_ uint32_t* const SPDIFRX_VERR_PTR    = (RO_ uint32_t* const)0x400043F4U;   /** @brief SPDIFRX version register */
    static RO_ uint32_t* const SPDIFRX_IDR_PTR     = (RO_ uint32_t* const)0x400043F8U;   /** @brief SPDIFRX identification register */
    static RO_ uint32_t* const SPDIFRX_SIDR_PTR    = (RO_ uint32_t* const)0x400043FCU;   /** @brief SPDIFRX size identification register */
    static RO_ uint32_t* const SPDIFRX_DR_01_PTR   = (RO_ uint32_t* const)0x40004010U;   /** @brief Data input register */
    static RO_ uint32_t* const SPDIFRX_DR_10_PTR   = (RO_ uint32_t* const)0x40004010U;   /** @brief Data input register */

    /**** @subsection SPDIFRX Register Reset Values ****/

    static const uint32_t SPDIFRX_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t SPDIFRX_IMR_RST     = 0x00000000U;   /** @brief IMR register reset value. */
    static const uint32_t SPDIFRX_SR_RST      = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t SPDIFRX_IFCR_RST    = 0x00000000U;   /** @brief IFCR register reset value. */
    static const uint32_t SPDIFRX_DR_00_RST   = 0x00000000U;   /** @brief DR_00 register reset value. */
    static const uint32_t SPDIFRX_CSR_RST     = 0x00000000U;   /** @brief CSR register reset value. */
    static const uint32_t SPDIFRX_DIR_RST     = 0x00000000U;   /** @brief DIR register reset value. */
    static const uint32_t SPDIFRX_VERR_RST    = 0x00000012U;   /** @brief VERR register reset value. */
    static const uint32_t SPDIFRX_IDR_RST     = 0x00130041U;   /** @brief IDR register reset value. */
    static const uint32_t SPDIFRX_SIDR_RST    = 0xA3C5DD01U;   /** @brief SIDR register reset value. */
    static const uint32_t SPDIFRX_DR_01_RST   = 0x00000000U;   /** @brief DR_01 register reset value. */
    static const uint32_t SPDIFRX_DR_10_RST   = 0x00000000U;   /** @brief DR_10 register reset value. */

    /**** @subsection Enumerated SPDIFRX Register Value Types ****/

    typedef uint32_t SPDIFRX_CR_t;      /** @brief CR register value type. */
    typedef uint32_t SPDIFRX_IMR_t;     /** @brief IMR register value type. */
    typedef uint32_t SPDIFRX_SR_t;      /** @brief SR register value type. */
    typedef uint32_t SPDIFRX_IFCR_t;    /** @brief IFCR register value type. */
    typedef uint32_t SPDIFRX_DR_00_t;   /** @brief DR_00 register value type. */
    typedef uint32_t SPDIFRX_CSR_t;     /** @brief CSR register value type. */
    typedef uint32_t SPDIFRX_DIR_t;     /** @brief DIR register value type. */
    typedef uint32_t SPDIFRX_VERR_t;    /** @brief VERR register value type. */
    typedef uint32_t SPDIFRX_IDR_t;     /** @brief IDR register value type. */
    typedef uint32_t SPDIFRX_SIDR_t;    /** @brief SIDR register value type. */
    typedef uint32_t SPDIFRX_DR_01_t;   /** @brief DR_01 register value type. */
    typedef uint32_t SPDIFRX_DR_10_t;   /** @brief DR_10 register value type. */

    /**** @subsection Enumerated SPDIFRX Register Pointer Types ****/

    typedef uint32_t* const SPDIFRX_CR_PTR_t;      /** @brief CR register pointer type. */
    typedef uint32_t* const SPDIFRX_IMR_PTR_t;     /** @brief IMR register pointer type. */
    typedef uint32_t* const SPDIFRX_SR_PTR_t;      /** @brief SR register pointer type. */
    typedef uint32_t* const SPDIFRX_IFCR_PTR_t;    /** @brief IFCR register pointer type. */
    typedef uint32_t* const SPDIFRX_DR_00_PTR_t;   /** @brief DR_00 register pointer type. */
    typedef uint32_t* const SPDIFRX_CSR_PTR_t;     /** @brief CSR register pointer type. */
    typedef uint32_t* const SPDIFRX_DIR_PTR_t;     /** @brief DIR register pointer type. */
    typedef uint32_t* const SPDIFRX_VERR_PTR_t;    /** @brief VERR register pointer type. */
    typedef uint32_t* const SPDIFRX_IDR_PTR_t;     /** @brief IDR register pointer type. */
    typedef uint32_t* const SPDIFRX_SIDR_PTR_t;    /** @brief SIDR register pointer type. */
    typedef uint32_t* const SPDIFRX_DR_01_PTR_t;   /** @brief DR_01 register pointer type. */
    typedef uint32_t* const SPDIFRX_DR_10_PTR_t;   /** @brief DR_10 register pointer type. */

    /**** @subsection SPDIFRX Register Field Masks ****/

    static const uint32_t SPDIFRX_CR_SPDIFRXEN_MASK   = 0x00000003U;   /** @brief Peripheral block enable */
    static const uint32_t SPDIFRX_CR_RXDMAEN_MASK     = 0x00000004U;   /** @brief Receiver DMA enable for data flow */
    static const uint32_t SPDIFRX_CR_RXSTEO_MASK      = 0x00000008U;   /** @brief STerEO mode */
    static const uint32_t SPDIFRX_CR_DRFMT_MASK       = 0x00000030U;   /** @brief RX data format */
    static const uint32_t SPDIFRX_CR_PMSK_MASK        = 0x00000040U;   /** @brief Mask parity error bit */
    static const uint32_t SPDIFRX_CR_VMSK_MASK        = 0x00000080U;   /** @brief Mask of validity bit */
    static const uint32_t SPDIFRX_CR_CUMSK_MASK       = 0x00000100U;   /** @brief Mask of channel status and user bits */
    static const uint32_t SPDIFRX_CR_PTMSK_MASK       = 0x00000200U;   /** @brief Mask of preamble type bits */
    static const uint32_t SPDIFRX_CR_CBDMAEN_MASK     = 0x00000400U;   /** @brief Control buffer DMA enable for control flow */
    static const uint32_t SPDIFRX_CR_CHSEL_MASK       = 0x00000800U;   /** @brief Channel selection */
    static const uint32_t SPDIFRX_CR_NBTR_MASK        = 0x00003000U;   /** @brief Maximum allowed re-tries during synchronization phase */
    static const uint32_t SPDIFRX_CR_WFA_MASK         = 0x00004000U;   /** @brief Wait for activity */
    static const uint32_t SPDIFRX_CR_INSEL_MASK       = 0x00070000U;   /** @brief Input selection */
    static const uint32_t SPDIFRX_CR_CKSEN_MASK       = 0x00100000U;   /** @brief Symbol clock enable */
    static const uint32_t SPDIFRX_CR_CKSBKPEN_MASK    = 0x00200000U;   /** @brief Backup symbol clock enable */
    static const uint32_t SPDIFRX_IMR_RXNEIE_MASK     = 0x00000001U;   /** @brief RXNE interrupt enable */
    static const uint32_t SPDIFRX_IMR_CSRNEIE_MASK    = 0x00000002U;   /** @brief Control buffer ready interrupt enable */
    static const uint32_t SPDIFRX_IMR_PERRIE_MASK     = 0x00000004U;   /** @brief Parity error interrupt enable */
    static const uint32_t SPDIFRX_IMR_OVRIE_MASK      = 0x00000008U;   /** @brief Overrun error interrupt enable */
    static const uint32_t SPDIFRX_IMR_SBLKIE_MASK     = 0x00000010U;   /** @brief Synchronization block detected interrupt enable */
    static const uint32_t SPDIFRX_IMR_SYNCDIE_MASK    = 0x00000020U;   /** @brief Synchronization done */
    static const uint32_t SPDIFRX_IMR_IFEIE_MASK      = 0x00000040U;   /** @brief Serial interface error interrupt enable */
    static const uint32_t SPDIFRX_SR_RXNE_MASK        = 0x00000001U;   /** @brief Read data register not empty */
    static const uint32_t SPDIFRX_SR_CSRNE_MASK       = 0x00000002U;   /** @brief Control buffer register is not empty */
    static const uint32_t SPDIFRX_SR_PERR_MASK        = 0x00000004U;   /** @brief Parity error */
    static const uint32_t SPDIFRX_SR_OVR_MASK         = 0x00000008U;   /** @brief Overrun error */
    static const uint32_t SPDIFRX_SR_SBD_MASK         = 0x00000010U;   /** @brief Synchronization block detected */
    static const uint32_t SPDIFRX_SR_SYNCD_MASK       = 0x00000020U;   /** @brief Synchronization done */
    static const uint32_t SPDIFRX_SR_FERR_MASK        = 0x00000040U;   /** @brief Framing error */
    static const uint32_t SPDIFRX_SR_SERR_MASK        = 0x00000080U;   /** @brief Synchronization error */
    static const uint32_t SPDIFRX_SR_TERR_MASK        = 0x00000100U;   /** @brief Time-out error */
    static const uint32_t SPDIFRX_SR_WIDTH5_MASK      = 0x7FFF0000U;   /** @brief Duration of 5 symbols counted with SPDIF_CLK */
    static const uint32_t SPDIFRX_IFCR_PERRCF_MASK    = 0x00000004U;   /** @brief Clears the parity error flag */
    static const uint32_t SPDIFRX_IFCR_OVRCF_MASK     = 0x00000008U;   /** @brief Clears the overrun error flag */
    static const uint32_t SPDIFRX_IFCR_SBDCF_MASK     = 0x00000010U;   /** @brief Clears the synchronization block detected flag */
    static const uint32_t SPDIFRX_IFCR_SYNCDCF_MASK   = 0x00000020U;   /** @brief Clears the synchronization done flag */
    static const uint32_t SPDIFRX_DR_00_DR_MASK       = 0x00FFFFFFU;   /** @brief Parity error bit */
    static const uint32_t SPDIFRX_DR_00_PE_MASK       = 0x01000000U;   /** @brief Parity error bit */
    static const uint32_t SPDIFRX_DR_00_V_MASK        = 0x02000000U;   /** @brief Validity bit */
    static const uint32_t SPDIFRX_DR_00_U_MASK        = 0x04000000U;   /** @brief User bit */
    static const uint32_t SPDIFRX_DR_00_C_MASK        = 0x08000000U;   /** @brief Channel status bit */
    static const uint32_t SPDIFRX_DR_00_PT_MASK       = 0x30000000U;   /** @brief Preamble type */
    static const uint32_t SPDIFRX_CSR_USR_MASK        = 0x0000FFFFU;   /** @brief User data information */
    static const uint32_t SPDIFRX_CSR_CS_MASK         = 0x00FF0000U;   /** @brief Channel A status information */
    static const uint32_t SPDIFRX_CSR_SOB_MASK        = 0x01000000U;   /** @brief Start of block */
    static const uint32_t SPDIFRX_DIR_THI_MASK        = 0x00001FFFU;   /** @brief Threshold HIGH */
    static const uint32_t SPDIFRX_DIR_TLO_MASK        = 0x1FFF0000U;   /** @brief Threshold LOW */
    static const uint32_t SPDIFRX_VERR_MINREV_MASK    = 0x0000000FU;   /** @brief Minor revision */
    static const uint32_t SPDIFRX_VERR_MAJREV_MASK    = 0x000000F0U;   /** @brief Major revision */
    static const uint32_t SPDIFRX_DR_01_PE_MASK       = 0x00000001U;   /** @brief Parity error bit */
    static const uint32_t SPDIFRX_DR_01_V_MASK        = 0x00000002U;   /** @brief Validity bit */
    static const uint32_t SPDIFRX_DR_01_U_MASK        = 0x00000004U;   /** @brief User bit */
    static const uint32_t SPDIFRX_DR_01_C_MASK        = 0x00000008U;   /** @brief Channel status bit */
    static const uint32_t SPDIFRX_DR_01_PT_MASK       = 0x00000030U;   /** @brief Preamble type */
    static const uint32_t SPDIFRX_DR_01_DR_MASK       = 0xFFFFFF00U;   /** @brief Data value */

    /**** @subsection Enumerated SPDIFRX Register Field Masks ****/

    static const uint32_t SPDIFRX_DR_10_DRNLx_MASK[3] = {
      [1] = 0x0000FFFFU,   /** @brief Data value */
      [2] = 0xFFFF0000U,   /** @brief Data value */
    };

    /**** @subsection SPDIFRX Register Field Positions ****/

    static const int32_t SPDIFRX_CR_SPDIFRXEN_POS   = 0;    /** @brief Peripheral block enable */
    static const int32_t SPDIFRX_CR_RXDMAEN_POS     = 2;    /** @brief Receiver DMA enable for data flow */
    static const int32_t SPDIFRX_CR_RXSTEO_POS      = 3;    /** @brief STerEO mode */
    static const int32_t SPDIFRX_CR_DRFMT_POS       = 4;    /** @brief RX data format */
    static const int32_t SPDIFRX_CR_PMSK_POS        = 6;    /** @brief Mask parity error bit */
    static const int32_t SPDIFRX_CR_VMSK_POS        = 7;    /** @brief Mask of validity bit */
    static const int32_t SPDIFRX_CR_CUMSK_POS       = 8;    /** @brief Mask of channel status and user bits */
    static const int32_t SPDIFRX_CR_PTMSK_POS       = 9;    /** @brief Mask of preamble type bits */
    static const int32_t SPDIFRX_CR_CBDMAEN_POS     = 10;   /** @brief Control buffer DMA enable for control flow */
    static const int32_t SPDIFRX_CR_CHSEL_POS       = 11;   /** @brief Channel selection */
    static const int32_t SPDIFRX_CR_NBTR_POS        = 12;   /** @brief Maximum allowed re-tries during synchronization phase */
    static const int32_t SPDIFRX_CR_WFA_POS         = 14;   /** @brief Wait for activity */
    static const int32_t SPDIFRX_CR_INSEL_POS       = 16;   /** @brief Input selection */
    static const int32_t SPDIFRX_CR_CKSEN_POS       = 20;   /** @brief Symbol clock enable */
    static const int32_t SPDIFRX_CR_CKSBKPEN_POS    = 21;   /** @brief Backup symbol clock enable */
    static const int32_t SPDIFRX_IMR_RXNEIE_POS     = 0;    /** @brief RXNE interrupt enable */
    static const int32_t SPDIFRX_IMR_CSRNEIE_POS    = 1;    /** @brief Control buffer ready interrupt enable */
    static const int32_t SPDIFRX_IMR_PERRIE_POS     = 2;    /** @brief Parity error interrupt enable */
    static const int32_t SPDIFRX_IMR_OVRIE_POS      = 3;    /** @brief Overrun error interrupt enable */
    static const int32_t SPDIFRX_IMR_SBLKIE_POS     = 4;    /** @brief Synchronization block detected interrupt enable */
    static const int32_t SPDIFRX_IMR_SYNCDIE_POS    = 5;    /** @brief Synchronization done */
    static const int32_t SPDIFRX_IMR_IFEIE_POS      = 6;    /** @brief Serial interface error interrupt enable */
    static const int32_t SPDIFRX_SR_RXNE_POS        = 0;    /** @brief Read data register not empty */
    static const int32_t SPDIFRX_SR_CSRNE_POS       = 1;    /** @brief Control buffer register is not empty */
    static const int32_t SPDIFRX_SR_PERR_POS        = 2;    /** @brief Parity error */
    static const int32_t SPDIFRX_SR_OVR_POS         = 3;    /** @brief Overrun error */
    static const int32_t SPDIFRX_SR_SBD_POS         = 4;    /** @brief Synchronization block detected */
    static const int32_t SPDIFRX_SR_SYNCD_POS       = 5;    /** @brief Synchronization done */
    static const int32_t SPDIFRX_SR_FERR_POS        = 6;    /** @brief Framing error */
    static const int32_t SPDIFRX_SR_SERR_POS        = 7;    /** @brief Synchronization error */
    static const int32_t SPDIFRX_SR_TERR_POS        = 8;    /** @brief Time-out error */
    static const int32_t SPDIFRX_SR_WIDTH5_POS      = 16;   /** @brief Duration of 5 symbols counted with SPDIF_CLK */
    static const int32_t SPDIFRX_IFCR_PERRCF_POS    = 2;    /** @brief Clears the parity error flag */
    static const int32_t SPDIFRX_IFCR_OVRCF_POS     = 3;    /** @brief Clears the overrun error flag */
    static const int32_t SPDIFRX_IFCR_SBDCF_POS     = 4;    /** @brief Clears the synchronization block detected flag */
    static const int32_t SPDIFRX_IFCR_SYNCDCF_POS   = 5;    /** @brief Clears the synchronization done flag */
    static const int32_t SPDIFRX_DR_00_DR_POS       = 0;    /** @brief Parity error bit */
    static const int32_t SPDIFRX_DR_00_PE_POS       = 24;   /** @brief Parity error bit */
    static const int32_t SPDIFRX_DR_00_V_POS        = 25;   /** @brief Validity bit */
    static const int32_t SPDIFRX_DR_00_U_POS        = 26;   /** @brief User bit */
    static const int32_t SPDIFRX_DR_00_C_POS        = 27;   /** @brief Channel status bit */
    static const int32_t SPDIFRX_DR_00_PT_POS       = 28;   /** @brief Preamble type */
    static const int32_t SPDIFRX_CSR_USR_POS        = 0;    /** @brief User data information */
    static const int32_t SPDIFRX_CSR_CS_POS         = 16;   /** @brief Channel A status information */
    static const int32_t SPDIFRX_CSR_SOB_POS        = 24;   /** @brief Start of block */
    static const int32_t SPDIFRX_DIR_THI_POS        = 0;    /** @brief Threshold HIGH */
    static const int32_t SPDIFRX_DIR_TLO_POS        = 16;   /** @brief Threshold LOW */
    static const int32_t SPDIFRX_VERR_MINREV_POS    = 0;    /** @brief Minor revision */
    static const int32_t SPDIFRX_VERR_MAJREV_POS    = 4;    /** @brief Major revision */
    static const int32_t SPDIFRX_DR_01_PE_POS       = 0;    /** @brief Parity error bit */
    static const int32_t SPDIFRX_DR_01_V_POS        = 1;    /** @brief Validity bit */
    static const int32_t SPDIFRX_DR_01_U_POS        = 2;    /** @brief User bit */
    static const int32_t SPDIFRX_DR_01_C_POS        = 3;    /** @brief Channel status bit */
    static const int32_t SPDIFRX_DR_01_PT_POS       = 4;    /** @brief Preamble type */
    static const int32_t SPDIFRX_DR_01_DR_POS       = 8;    /** @brief Data value */

    /**** @subsection Enumerated SPDIFRX Register Field Positions ****/

    static const int32_t SPDIFRX_DR_10_DRNLx_POS[3] = {
      [1] = 0,    /** @brief Data value */
      [2] = 16,   /** @brief Data value */
    };

    /**********************************************************************************************
     * @section ADCx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated ADCx Register Pointers ****/

    static RW_ uint32_t* const ADCx_ISR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022000U,   /** @brief ADC interrupt and status register */
      [2] = (RW_ uint32_t* const)0x40022100U,   /** @brief ADC interrupt and status register */
      [3] = (RW_ uint32_t* const)0x58026000U,   /** @brief ADC interrupt and status register */
    };

    static RW_ uint32_t* const ADCx_IER_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022004U,   /** @brief ADC interrupt enable register */
      [2] = (RW_ uint32_t* const)0x40022104U,   /** @brief ADC interrupt enable register */
      [3] = (RW_ uint32_t* const)0x58026004U,   /** @brief ADC interrupt enable register */
    };

    static RW_ uint32_t* const ADCx_CR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022008U,   /** @brief ADC control register */
      [2] = (RW_ uint32_t* const)0x40022108U,   /** @brief ADC control register */
      [3] = (RW_ uint32_t* const)0x58026008U,   /** @brief ADC control register */
    };

    static RW_ uint32_t* const ADCx_CFGR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x4002200CU,   /** @brief ADC configuration register 1 */
      [2] = (RW_ uint32_t* const)0x4002210CU,   /** @brief ADC configuration register 1 */
      [3] = (RW_ uint32_t* const)0x5802600CU,   /** @brief ADC configuration register 1 */
    };

    static RW_ uint32_t* const ADCx_CFGR2_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022010U,   /** @brief ADC configuration register 2 */
      [2] = (RW_ uint32_t* const)0x40022110U,   /** @brief ADC configuration register 2 */
      [3] = (RW_ uint32_t* const)0x58026010U,   /** @brief ADC configuration register 2 */
    };

    static RW_ uint32_t* const ADCx_SMPR1_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022014U,   /** @brief ADC sampling time register 1 */
      [2] = (RW_ uint32_t* const)0x40022114U,   /** @brief ADC sampling time register 1 */
      [3] = (RW_ uint32_t* const)0x58026014U,   /** @brief ADC sampling time register 1 */
    };

    static RW_ uint32_t* const ADCx_SMPR2_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022018U,   /** @brief ADC sampling time register 2 */
      [2] = (RW_ uint32_t* const)0x40022118U,   /** @brief ADC sampling time register 2 */
      [3] = (RW_ uint32_t* const)0x58026018U,   /** @brief ADC sampling time register 2 */
    };

    static RW_ uint32_t* const ADCx_LTRx_PTR[4][4] = {
      [0] = {
        [1] = (RW_ uint32_t* const)0x40022020U,   /** @brief ADC analog watchdog 1 threshold register */
        [2] = (RW_ uint32_t* const)0x400220B0U,   /** @brief ADC watchdog lower threshold register 2 */
        [3] = (RW_ uint32_t* const)0x400220B8U,   /** @brief ADC watchdog lower threshold register 3 */
      },
      [1] = {
        [1] = (RW_ uint32_t* const)0x40022120U,   /** @brief ADC analog watchdog 1 threshold register */
        [2] = (RW_ uint32_t* const)0x400221B0U,   /** @brief ADC watchdog lower threshold register 2 */
        [3] = (RW_ uint32_t* const)0x400221B8U,   /** @brief ADC watchdog lower threshold register 3 */
      },
      [2] = {
        [1] = (RW_ uint32_t* const)0x58026020U,   /** @brief ADC analog watchdog 1 threshold register */
        [2] = (RW_ uint32_t* const)0x580260B0U,   /** @brief ADC watchdog lower threshold register 2 */
        [3] = (RW_ uint32_t* const)0x580260B8U,   /** @brief ADC watchdog lower threshold register 3 */
      },
    };

    static RW_ uint32_t* const ADCx_LHTR1_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022024U,   /** @brief ADC analog watchdog 2 threshold register */
      [2] = (RW_ uint32_t* const)0x40022124U,   /** @brief ADC analog watchdog 2 threshold register */
      [3] = (RW_ uint32_t* const)0x58026024U,   /** @brief ADC analog watchdog 2 threshold register */
    };

    static RW_ uint32_t* const ADCx_SQR1_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022030U,   /** @brief ADC group regular sequencer ranks register 1 */
      [2] = (RW_ uint32_t* const)0x40022130U,   /** @brief ADC group regular sequencer ranks register 1 */
      [3] = (RW_ uint32_t* const)0x58026030U,   /** @brief ADC group regular sequencer ranks register 1 */
    };

    static RW_ uint32_t* const ADCx_SQR2_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022034U,   /** @brief ADC group regular sequencer ranks register 2 */
      [2] = (RW_ uint32_t* const)0x40022134U,   /** @brief ADC group regular sequencer ranks register 2 */
      [3] = (RW_ uint32_t* const)0x58026034U,   /** @brief ADC group regular sequencer ranks register 2 */
    };

    static RW_ uint32_t* const ADCx_SQR3_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x40022038U,   /** @brief ADC group regular sequencer ranks register 3 */
      [2] = (RW_ uint32_t* const)0x40022138U,   /** @brief ADC group regular sequencer ranks register 3 */
      [3] = (RW_ uint32_t* const)0x58026038U,   /** @brief ADC group regular sequencer ranks register 3 */
    };

    static RW_ uint32_t* const ADCx_SQR4_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x4002203CU,   /** @brief ADC group regular sequencer ranks register 4 */
      [2] = (RW_ uint32_t* const)0x4002213CU,   /** @brief ADC group regular sequencer ranks register 4 */
      [3] = (RW_ uint32_t* const)0x5802603CU,   /** @brief ADC group regular sequencer ranks register 4 */
    };

    static RO_ uint32_t* const ADCx_DR_PTR[4] = {
      [1] = (RO_ uint32_t* const)0x40022040U,   /** @brief ADC group regular conversion data register */
      [2] = (RO_ uint32_t* const)0x40022140U,   /** @brief ADC group regular conversion data register */
      [3] = (RO_ uint32_t* const)0x58026040U,   /** @brief ADC group regular conversion data register */
    };

    static RW_ uint32_t* const ADCx_JSQR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x4002204CU,   /** @brief ADC group injected sequencer register */
      [2] = (RW_ uint32_t* const)0x4002214CU,   /** @brief ADC group injected sequencer register */
      [3] = (RW_ uint32_t* const)0x5802604CU,   /** @brief ADC group injected sequencer register */
    };

    static RW_ uint32_t* const ADCx_OFRx_PTR[4][5] = {
      [0] = {
        [1] = (RW_ uint32_t* const)0x40022060U,   /** @brief ADC offset number 1 register */
        [2] = (RW_ uint32_t* const)0x40022064U,   /** @brief ADC offset number 2 register */
        [3] = (RW_ uint32_t* const)0x40022068U,   /** @brief ADC offset number 3 register */
        [4] = (RW_ uint32_t* const)0x4002206CU,   /** @brief ADC offset number 4 register */
      },
      [1] = {
        [1] = (RW_ uint32_t* const)0x40022160U,   /** @brief ADC offset number 1 register */
        [2] = (RW_ uint32_t* const)0x40022164U,   /** @brief ADC offset number 2 register */
        [3] = (RW_ uint32_t* const)0x40022168U,   /** @brief ADC offset number 3 register */
        [4] = (RW_ uint32_t* const)0x4002216CU,   /** @brief ADC offset number 4 register */
      },
      [2] = {
        [1] = (RW_ uint32_t* const)0x58026060U,   /** @brief ADC offset number 1 register */
        [2] = (RW_ uint32_t* const)0x58026064U,   /** @brief ADC offset number 2 register */
        [3] = (RW_ uint32_t* const)0x58026068U,   /** @brief ADC offset number 3 register */
        [4] = (RW_ uint32_t* const)0x5802606CU,   /** @brief ADC offset number 4 register */
      },
    };

    static RO_ uint32_t* const ADCx_JDRx_PTR[4][5] = {
      [0] = {
        [1] = (RO_ uint32_t* const)0x40022080U,   /** @brief ADC group injected sequencer rank 1 register */
        [2] = (RO_ uint32_t* const)0x40022084U,   /** @brief ADC group injected sequencer rank 2 register */
        [3] = (RO_ uint32_t* const)0x40022088U,   /** @brief ADC group injected sequencer rank 3 register */
        [4] = (RO_ uint32_t* const)0x4002208CU,   /** @brief ADC group injected sequencer rank 4 register */
      },
      [1] = {
        [1] = (RO_ uint32_t* const)0x40022180U,   /** @brief ADC group injected sequencer rank 1 register */
        [2] = (RO_ uint32_t* const)0x40022184U,   /** @brief ADC group injected sequencer rank 2 register */
        [3] = (RO_ uint32_t* const)0x40022188U,   /** @brief ADC group injected sequencer rank 3 register */
        [4] = (RO_ uint32_t* const)0x4002218CU,   /** @brief ADC group injected sequencer rank 4 register */
      },
      [2] = {
        [1] = (RO_ uint32_t* const)0x58026080U,   /** @brief ADC group injected sequencer rank 1 register */
        [2] = (RO_ uint32_t* const)0x58026084U,   /** @brief ADC group injected sequencer rank 2 register */
        [3] = (RO_ uint32_t* const)0x58026088U,   /** @brief ADC group injected sequencer rank 3 register */
        [4] = (RO_ uint32_t* const)0x5802608CU,   /** @brief ADC group injected sequencer rank 4 register */
      },
    };

    static RW_ uint32_t* const ADCx_AWD2CR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x400220A0U,   /** @brief ADC analog watchdog 2 configuration register */
      [2] = (RW_ uint32_t* const)0x400221A0U,   /** @brief ADC analog watchdog 2 configuration register */
      [3] = (RW_ uint32_t* const)0x580260A0U,   /** @brief ADC analog watchdog 2 configuration register */
    };

    static RW_ uint32_t* const ADCx_AWD3CR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x400220A4U,   /** @brief ADC analog watchdog 3 configuration register */
      [2] = (RW_ uint32_t* const)0x400221A4U,   /** @brief ADC analog watchdog 3 configuration register */
      [3] = (RW_ uint32_t* const)0x580260A4U,   /** @brief ADC analog watchdog 3 configuration register */
    };

    static RW_ uint32_t* const ADCx_DIFSEL_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x400220C0U,   /** @brief ADC channel differential or single-ended mode selection register */
      [2] = (RW_ uint32_t* const)0x400221C0U,   /** @brief ADC channel differential or single-ended mode selection register */
      [3] = (RW_ uint32_t* const)0x580260C0U,   /** @brief ADC channel differential or single-ended mode selection register */
    };

    static RW_ uint32_t* const ADCx_CALFACT_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x400220C4U,   /** @brief ADC calibration factors register */
      [2] = (RW_ uint32_t* const)0x400221C4U,   /** @brief ADC calibration factors register */
      [3] = (RW_ uint32_t* const)0x580260C4U,   /** @brief ADC calibration factors register */
    };

    static RW_ uint32_t* const ADCx_PCSEL_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x4002201CU,   /** @brief ADC pre channel selection register */
      [2] = (RW_ uint32_t* const)0x4002211CU,   /** @brief ADC pre channel selection register */
      [3] = (RW_ uint32_t* const)0x5802601CU,   /** @brief ADC pre channel selection register */
    };

    static RW_ uint32_t* const ADCx_HTRx_PTR[4][4] = {
      [0] = {
        [2] = (RW_ uint32_t* const)0x400220B4U,   /** @brief ADC watchdog higher threshold register 2 */
        [3] = (RW_ uint32_t* const)0x400220BCU,   /** @brief ADC watchdog higher threshold register 3 */
      },
      [1] = {
        [2] = (RW_ uint32_t* const)0x400221B4U,   /** @brief ADC watchdog higher threshold register 2 */
        [3] = (RW_ uint32_t* const)0x400221BCU,   /** @brief ADC watchdog higher threshold register 3 */
      },
      [2] = {
        [2] = (RW_ uint32_t* const)0x580260B4U,   /** @brief ADC watchdog higher threshold register 2 */
        [3] = (RW_ uint32_t* const)0x580260BCU,   /** @brief ADC watchdog higher threshold register 3 */
      },
    };

    static RW_ uint32_t* const ADCx_CALFACT2_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x400220C8U,   /** @brief ADC calibration factor register 2 */
      [2] = (RW_ uint32_t* const)0x400221C8U,   /** @brief ADC calibration factor register 2 */
      [3] = (RW_ uint32_t* const)0x580260C8U,   /** @brief ADC calibration factor register 2 */
    };

    /**** @subsection Enumerated ADCx Register Reset Values ****/

    static const uint32_t ADCx_ISR_RST[4] = {
      [1] = 0x00000000U,   /** @brief ISR register reset value */
      [2] = 0x00000000U,   /** @brief ISR register reset value */
      [3] = 0x00000000U,   /** @brief ISR register reset value */
    };

    static const uint32_t ADCx_IER_RST[4] = {
      [1] = 0x00000000U,   /** @brief IER register reset value */
      [2] = 0x00000000U,   /** @brief IER register reset value */
      [3] = 0x00000000U,   /** @brief IER register reset value */
    };

    static const uint32_t ADCx_CR_RST[4] = {
      [1] = 0x00000000U,   /** @brief CR register reset value */
      [2] = 0x00000000U,   /** @brief CR register reset value */
      [3] = 0x00000000U,   /** @brief CR register reset value */
    };

    static const uint32_t ADCx_CFGR_RST[4] = {
      [1] = 0x00000000U,   /** @brief CFGR register reset value */
      [2] = 0x00000000U,   /** @brief CFGR register reset value */
      [3] = 0x00000000U,   /** @brief CFGR register reset value */
    };

    static const uint32_t ADCx_CFGR2_RST[4] = {
      [1] = 0x00000000U,   /** @brief CFGR2 register reset value */
      [2] = 0x00000000U,   /** @brief CFGR2 register reset value */
      [3] = 0x00000000U,   /** @brief CFGR2 register reset value */
    };

    static const uint32_t ADCx_SMPR1_RST[4] = {
      [1] = 0x00000000U,   /** @brief SMPR1 register reset value */
      [2] = 0x00000000U,   /** @brief SMPR1 register reset value */
      [3] = 0x00000000U,   /** @brief SMPR1 register reset value */
    };

    static const uint32_t ADCx_SMPR2_RST[4] = {
      [1] = 0x00000000U,   /** @brief SMPR2 register reset value */
      [2] = 0x00000000U,   /** @brief SMPR2 register reset value */
      [3] = 0x00000000U,   /** @brief SMPR2 register reset value */
    };

    static const uint32_t ADCx_LTRx_RST[4][4] = {
      [0] = {
        [1] = 0x0FFF0000U,   /** @brief LTR1 register reset value. */
        [2] = 0x00000000U,   /** @brief LTR2 register reset value. */
        [3] = 0x00000000U,   /** @brief LTR3 register reset value. */
      },
      [1] = {
        [1] = 0x0FFF0000U,   /** @brief LTR1 register reset value. */
        [2] = 0x00000000U,   /** @brief LTR2 register reset value. */
        [3] = 0x00000000U,   /** @brief LTR3 register reset value. */
      },
      [2] = {
        [1] = 0x0FFF0000U,   /** @brief LTR1 register reset value. */
        [2] = 0x00000000U,   /** @brief LTR2 register reset value. */
        [3] = 0x00000000U,   /** @brief LTR3 register reset value. */
      },
    };

    static const uint32_t ADCx_LHTR1_RST[4] = {
      [1] = 0x0FFF0000U,   /** @brief LHTR1 register reset value */
      [2] = 0x0FFF0000U,   /** @brief LHTR1 register reset value */
      [3] = 0x0FFF0000U,   /** @brief LHTR1 register reset value */
    };

    static const uint32_t ADCx_SQR1_RST[4] = {
      [1] = 0x00000000U,   /** @brief SQR1 register reset value */
      [2] = 0x00000000U,   /** @brief SQR1 register reset value */
      [3] = 0x00000000U,   /** @brief SQR1 register reset value */
    };

    static const uint32_t ADCx_SQR2_RST[4] = {
      [1] = 0x00000000U,   /** @brief SQR2 register reset value */
      [2] = 0x00000000U,   /** @brief SQR2 register reset value */
      [3] = 0x00000000U,   /** @brief SQR2 register reset value */
    };

    static const uint32_t ADCx_SQR3_RST[4] = {
      [1] = 0x00000000U,   /** @brief SQR3 register reset value */
      [2] = 0x00000000U,   /** @brief SQR3 register reset value */
      [3] = 0x00000000U,   /** @brief SQR3 register reset value */
    };

    static const uint32_t ADCx_SQR4_RST[4] = {
      [1] = 0x00000000U,   /** @brief SQR4 register reset value */
      [2] = 0x00000000U,   /** @brief SQR4 register reset value */
      [3] = 0x00000000U,   /** @brief SQR4 register reset value */
    };

    static const uint32_t ADCx_DR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DR register reset value */
      [2] = 0x00000000U,   /** @brief DR register reset value */
      [3] = 0x00000000U,   /** @brief DR register reset value */
    };

    static const uint32_t ADCx_JSQR_RST[4] = {
      [1] = 0x00000000U,   /** @brief JSQR register reset value */
      [2] = 0x00000000U,   /** @brief JSQR register reset value */
      [3] = 0x00000000U,   /** @brief JSQR register reset value */
    };

    static const uint32_t ADCx_OFRx_RST[4][5] = {
      [0] = {
        [1] = 0x00000000U,   /** @brief OFR1 register reset value. */
        [2] = 0x00000000U,   /** @brief OFR2 register reset value. */
        [3] = 0x00000000U,   /** @brief OFR3 register reset value. */
        [4] = 0x00000000U,   /** @brief OFR4 register reset value. */
      },
      [1] = {
        [1] = 0x00000000U,   /** @brief OFR1 register reset value. */
        [2] = 0x00000000U,   /** @brief OFR2 register reset value. */
        [3] = 0x00000000U,   /** @brief OFR3 register reset value. */
        [4] = 0x00000000U,   /** @brief OFR4 register reset value. */
      },
      [2] = {
        [1] = 0x00000000U,   /** @brief OFR1 register reset value. */
        [2] = 0x00000000U,   /** @brief OFR2 register reset value. */
        [3] = 0x00000000U,   /** @brief OFR3 register reset value. */
        [4] = 0x00000000U,   /** @brief OFR4 register reset value. */
      },
    };

    static const uint32_t ADCx_JDRx_RST[4][5] = {
      [0] = {
        [1] = 0x00000000U,   /** @brief JDR1 register reset value. */
        [2] = 0x00000000U,   /** @brief JDR2 register reset value. */
        [3] = 0x00000000U,   /** @brief JDR3 register reset value. */
        [4] = 0x00000000U,   /** @brief JDR4 register reset value. */
      },
      [1] = {
        [1] = 0x00000000U,   /** @brief JDR1 register reset value. */
        [2] = 0x00000000U,   /** @brief JDR2 register reset value. */
        [3] = 0x00000000U,   /** @brief JDR3 register reset value. */
        [4] = 0x00000000U,   /** @brief JDR4 register reset value. */
      },
      [2] = {
        [1] = 0x00000000U,   /** @brief JDR1 register reset value. */
        [2] = 0x00000000U,   /** @brief JDR2 register reset value. */
        [3] = 0x00000000U,   /** @brief JDR3 register reset value. */
        [4] = 0x00000000U,   /** @brief JDR4 register reset value. */
      },
    };

    static const uint32_t ADCx_AWD2CR_RST[4] = {
      [1] = 0x00000000U,   /** @brief AWD2CR register reset value */
      [2] = 0x00000000U,   /** @brief AWD2CR register reset value */
      [3] = 0x00000000U,   /** @brief AWD2CR register reset value */
    };

    static const uint32_t ADCx_AWD3CR_RST[4] = {
      [1] = 0x00000000U,   /** @brief AWD3CR register reset value */
      [2] = 0x00000000U,   /** @brief AWD3CR register reset value */
      [3] = 0x00000000U,   /** @brief AWD3CR register reset value */
    };

    static const uint32_t ADCx_DIFSEL_RST[4] = {
      [1] = 0x00000000U,   /** @brief DIFSEL register reset value */
      [2] = 0x00000000U,   /** @brief DIFSEL register reset value */
      [3] = 0x00000000U,   /** @brief DIFSEL register reset value */
    };

    static const uint32_t ADCx_CALFACT_RST[4] = {
      [1] = 0x00000000U,   /** @brief CALFACT register reset value */
      [2] = 0x00000000U,   /** @brief CALFACT register reset value */
      [3] = 0x00000000U,   /** @brief CALFACT register reset value */
    };

    static const uint32_t ADCx_PCSEL_RST[4] = {
      [1] = 0x00000000U,   /** @brief PCSEL register reset value */
      [2] = 0x00000000U,   /** @brief PCSEL register reset value */
      [3] = 0x00000000U,   /** @brief PCSEL register reset value */
    };

    static const uint32_t ADCx_HTRx_RST[4][4] = {
      [0] = {
        [2] = 0x00000000U,   /** @brief HTR2 register reset value. */
        [3] = 0x00000000U,   /** @brief HTR3 register reset value. */
      },
      [1] = {
        [2] = 0x00000000U,   /** @brief HTR2 register reset value. */
        [3] = 0x00000000U,   /** @brief HTR3 register reset value. */
      },
      [2] = {
        [2] = 0x00000000U,   /** @brief HTR2 register reset value. */
        [3] = 0x00000000U,   /** @brief HTR3 register reset value. */
      },
    };

    static const uint32_t ADCx_CALFACT2_RST[4] = {
      [1] = 0x00000000U,   /** @brief CALFACT2 register reset value */
      [2] = 0x00000000U,   /** @brief CALFACT2 register reset value */
      [3] = 0x00000000U,   /** @brief CALFACT2 register reset value */
    };

    /**** @subsection Enumerated ADCx Register Value Types ****/

    typedef uint32_t ADCx_ISR_t;        /** @brief ISR register value type. */
    typedef uint32_t ADCx_IER_t;        /** @brief IER register value type. */
    typedef uint32_t ADCx_CR_t;         /** @brief CR register value type. */
    typedef uint32_t ADCx_CFGR_t;       /** @brief CFGR register value type. */
    typedef uint32_t ADCx_CFGR2_t;      /** @brief CFGR2 register value type. */
    typedef uint32_t ADCx_SMPR1_t;      /** @brief SMPR1 register value type. */
    typedef uint32_t ADCx_SMPR2_t;      /** @brief SMPR2 register value type. */
    typedef uint32_t ADCx_LTRx_t;       /** @brief LTRx register value type. */
    typedef uint32_t ADCx_LHTR1_t;      /** @brief LHTR1 register value type. */
    typedef uint32_t ADCx_SQR1_t;       /** @brief SQR1 register value type. */
    typedef uint32_t ADCx_SQR2_t;       /** @brief SQR2 register value type. */
    typedef uint32_t ADCx_SQR3_t;       /** @brief SQR3 register value type. */
    typedef uint32_t ADCx_SQR4_t;       /** @brief SQR4 register value type. */
    typedef uint32_t ADCx_DR_t;         /** @brief DR register value type. */
    typedef uint32_t ADCx_JSQR_t;       /** @brief JSQR register value type. */
    typedef uint32_t ADCx_OFRx_t;       /** @brief OFRx register value type. */
    typedef uint32_t ADCx_JDRx_t;       /** @brief JDRx register value type. */
    typedef uint32_t ADCx_AWD2CR_t;     /** @brief AWD2CR register value type. */
    typedef uint32_t ADCx_AWD3CR_t;     /** @brief AWD3CR register value type. */
    typedef uint32_t ADCx_DIFSEL_t;     /** @brief DIFSEL register value type. */
    typedef uint32_t ADCx_CALFACT_t;    /** @brief CALFACT register value type. */
    typedef uint32_t ADCx_PCSEL_t;      /** @brief PCSEL register value type. */
    typedef uint32_t ADCx_HTRx_t;       /** @brief HTRx register value type. */
    typedef uint32_t ADCx_CALFACT2_t;   /** @brief CALFACT2 register value type. */

    /**** @subsection Enumerated ADCx Register Pointer Types ****/

    typedef uint32_t* const ADCx_ISR_PTR_t;        /** @brief ISR register pointer type. */
    typedef uint32_t* const ADCx_IER_PTR_t;        /** @brief IER register pointer type. */
    typedef uint32_t* const ADCx_CR_PTR_t;         /** @brief CR register pointer type. */
    typedef uint32_t* const ADCx_CFGR_PTR_t;       /** @brief CFGR register pointer type. */
    typedef uint32_t* const ADCx_CFGR2_PTR_t;      /** @brief CFGR2 register pointer type. */
    typedef uint32_t* const ADCx_SMPR1_PTR_t;      /** @brief SMPR1 register pointer type. */
    typedef uint32_t* const ADCx_SMPR2_PTR_t;      /** @brief SMPR2 register pointer type. */
    typedef uint32_t* const ADCx_LTRx_PTR_t;       /** @brief LTRx register pointer type. */
    typedef uint32_t* const ADCx_LHTR1_PTR_t;      /** @brief LHTR1 register pointer type. */
    typedef uint32_t* const ADCx_SQR1_PTR_t;       /** @brief SQR1 register pointer type. */
    typedef uint32_t* const ADCx_SQR2_PTR_t;       /** @brief SQR2 register pointer type. */
    typedef uint32_t* const ADCx_SQR3_PTR_t;       /** @brief SQR3 register pointer type. */
    typedef uint32_t* const ADCx_SQR4_PTR_t;       /** @brief SQR4 register pointer type. */
    typedef uint32_t* const ADCx_DR_PTR_t;         /** @brief DR register pointer type. */
    typedef uint32_t* const ADCx_JSQR_PTR_t;       /** @brief JSQR register pointer type. */
    typedef uint32_t* const ADCx_OFRx_PTR_t;       /** @brief OFRx register pointer type. */
    typedef uint32_t* const ADCx_JDRx_PTR_t;       /** @brief JDRx register pointer type. */
    typedef uint32_t* const ADCx_AWD2CR_PTR_t;     /** @brief AWD2CR register pointer type. */
    typedef uint32_t* const ADCx_AWD3CR_PTR_t;     /** @brief AWD3CR register pointer type. */
    typedef uint32_t* const ADCx_DIFSEL_PTR_t;     /** @brief DIFSEL register pointer type. */
    typedef uint32_t* const ADCx_CALFACT_PTR_t;    /** @brief CALFACT register pointer type. */
    typedef uint32_t* const ADCx_PCSEL_PTR_t;      /** @brief PCSEL register pointer type. */
    typedef uint32_t* const ADCx_HTRx_PTR_t;       /** @brief HTRx register pointer type. */
    typedef uint32_t* const ADCx_CALFACT2_PTR_t;   /** @brief CALFACT2 register pointer type. */

    /**** @subsection ADCx Register Field Masks ****/

    static const uint32_t ADCx_ISR_JQOVF_MASK             = 0x00000400U;   /** @brief ADC group injected contexts queue overflow flag */
    static const uint32_t ADCx_ISR_JEOS_MASK              = 0x00000040U;   /** @brief ADC group injected end of sequence conversions flag */
    static const uint32_t ADCx_ISR_JEOC_MASK              = 0x00000020U;   /** @brief ADC group injected end of unitary conversion flag */
    static const uint32_t ADCx_ISR_OVR_MASK               = 0x00000010U;   /** @brief ADC group regular overrun flag */
    static const uint32_t ADCx_ISR_EOS_MASK               = 0x00000008U;   /** @brief ADC group regular end of sequence conversions flag */
    static const uint32_t ADCx_ISR_EOC_MASK               = 0x00000004U;   /** @brief ADC group regular end of unitary conversion flag */
    static const uint32_t ADCx_ISR_EOSMP_MASK             = 0x00000002U;   /** @brief ADC group regular end of sampling flag */
    static const uint32_t ADCx_ISR_ADRDY_MASK             = 0x00000001U;   /** @brief ADC ready flag */
    static const uint32_t ADCx_IER_JQOVFIE_MASK           = 0x00000400U;   /** @brief ADC group injected contexts queue overflow interrupt */
    static const uint32_t ADCx_IER_JEOSIE_MASK            = 0x00000040U;   /** @brief ADC group injected end of sequence conversions interrupt */
    static const uint32_t ADCx_IER_JEOCIE_MASK            = 0x00000020U;   /** @brief ADC group injected end of unitary conversion interrupt */
    static const uint32_t ADCx_IER_OVRIE_MASK             = 0x00000010U;   /** @brief ADC group regular overrun interrupt */
    static const uint32_t ADCx_IER_EOSIE_MASK             = 0x00000008U;   /** @brief ADC group regular end of sequence conversions interrupt */
    static const uint32_t ADCx_IER_EOCIE_MASK             = 0x00000004U;   /** @brief ADC group regular end of unitary conversion interrupt */
    static const uint32_t ADCx_IER_EOSMPIE_MASK           = 0x00000002U;   /** @brief ADC group regular end of sampling interrupt */
    static const uint32_t ADCx_IER_ADRDYIE_MASK           = 0x00000001U;   /** @brief ADC ready interrupt */
    static const uint32_t ADCx_CR_ADCAL_MASK              = 0x80000000U;   /** @brief ADC calibration */
    static const uint32_t ADCx_CR_ADCALDIF_MASK           = 0x40000000U;   /** @brief ADC differential mode for calibration */
    static const uint32_t ADCx_CR_DEEPPWD_MASK            = 0x20000000U;   /** @brief ADC deep power down enable */
    static const uint32_t ADCx_CR_ADVREGEN_MASK           = 0x10000000U;   /** @brief ADC voltage regulator enable */
    static const uint32_t ADCx_CR_ADCALLIN_MASK           = 0x00010000U;   /** @brief Linearity calibration */
    static const uint32_t ADCx_CR_BOOST_MASK              = 0x00000300U;   /** @brief Boost mode control */
    static const uint32_t ADCx_CR_JADSTP_MASK             = 0x00000020U;   /** @brief ADC group injected conversion stop */
    static const uint32_t ADCx_CR_ADSTP_MASK              = 0x00000010U;   /** @brief ADC group regular conversion stop */
    static const uint32_t ADCx_CR_JADSTART_MASK           = 0x00000008U;   /** @brief ADC group injected conversion start */
    static const uint32_t ADCx_CR_ADSTART_MASK            = 0x00000004U;   /** @brief ADC group regular conversion start */
    static const uint32_t ADCx_CR_ADDIS_MASK              = 0x00000002U;   /** @brief ADC disable */
    static const uint32_t ADCx_CR_ADEN_MASK               = 0x00000001U;   /** @brief ADC enable */
    static const uint32_t ADCx_CFGR_JQDIS_MASK            = 0x80000000U;   /** @brief ADC group injected contexts queue disable */
    static const uint32_t ADCx_CFGR_AWDCH1CH_MASK         = 0x7C000000U;   /** @brief ADC analog watchdog 1 monitored channel selection */
    static const uint32_t ADCx_CFGR_JAUTO_MASK            = 0x02000000U;   /** @brief ADC group injected automatic trigger mode */
    static const uint32_t ADCx_CFGR_JAWD1EN_MASK          = 0x01000000U;   /** @brief ADC analog watchdog 1 enable on scope ADC group injected */
    static const uint32_t ADCx_CFGR_AWD1EN_MASK           = 0x00800000U;   /** @brief ADC analog watchdog 1 enable on scope ADC group regular */
    static const uint32_t ADCx_CFGR_AWD1SGL_MASK          = 0x00400000U;   /** @brief ADC analog watchdog 1 monitoring a single channel or all channels */
    static const uint32_t ADCx_CFGR_JQM_MASK              = 0x00200000U;   /** @brief ADC group injected contexts queue mode */
    static const uint32_t ADCx_CFGR_JDISCEN_MASK          = 0x00100000U;   /** @brief ADC group injected sequencer discontinuous mode */
    static const uint32_t ADCx_CFGR_DISCNUM_MASK          = 0x000E0000U;   /** @brief ADC group regular sequencer discontinuous number of ranks */
    static const uint32_t ADCx_CFGR_DISCEN_MASK           = 0x00010000U;   /** @brief ADC group regular sequencer discontinuous mode */
    static const uint32_t ADCx_CFGR_AUTDLY_MASK           = 0x00004000U;   /** @brief ADC low power auto wait */
    static const uint32_t ADCx_CFGR_CONT_MASK             = 0x00002000U;   /** @brief ADC group regular continuous conversion mode */
    static const uint32_t ADCx_CFGR_OVRMOD_MASK           = 0x00001000U;   /** @brief ADC group regular overrun configuration */
    static const uint32_t ADCx_CFGR_EXTEN_MASK            = 0x00000C00U;   /** @brief ADC group regular external trigger polarity */
    static const uint32_t ADCx_CFGR_EXTSEL_MASK           = 0x000003E0U;   /** @brief ADC group regular external trigger source */
    static const uint32_t ADCx_CFGR_RES_MASK              = 0x0000001CU;   /** @brief ADC data resolution */
    static const uint32_t ADCx_CFGR_DMNGT_MASK            = 0x00000003U;   /** @brief ADC DMA transfer enable */
    static const uint32_t ADCx_CFGR2_ROVSE_MASK           = 0x00000001U;   /** @brief ADC oversampler enable on scope ADC group regular */
    static const uint32_t ADCx_CFGR2_JOVSE_MASK           = 0x00000002U;   /** @brief ADC oversampler enable on scope ADC group injected */
    static const uint32_t ADCx_CFGR2_OVSS_MASK            = 0x000001E0U;   /** @brief ADC oversampling shift */
    static const uint32_t ADCx_CFGR2_TROVS_MASK           = 0x00000200U;   /** @brief ADC oversampling discontinuous mode (triggered mode) for ADC group regular */
    static const uint32_t ADCx_CFGR2_ROVSM_MASK           = 0x00000400U;   /** @brief Regular oversampling mode */
    static const uint32_t ADCx_CFGR2_OSR_MASK             = 0x03FF0000U;   /** @brief Oversampling ratio */
    static const uint32_t ADCx_CFGR2_LSHIFT_MASK          = 0xF0000000U;   /** @brief Left shift factor */
    static const uint32_t ADCx_LTRx_LTR1_MASK             = 0x03FFFFFFU;   /** @brief ADC analog watchdog 1 threshold low */
    static const uint32_t ADCx_LHTR1_LHTR1_MASK           = 0x03FFFFFFU;   /** @brief ADC analog watchdog 2 threshold low */
    static const uint32_t ADCx_SQR1_L3_MASK               = 0x0000000FU;   /** @brief L3 */
    static const uint32_t ADCx_DR_RDATA_MASK              = 0x0000FFFFU;   /** @brief ADC group regular conversion data */
    static const uint32_t ADCx_JSQR_JEXTEN_MASK           = 0x00000180U;   /** @brief ADC group injected external trigger polarity */
    static const uint32_t ADCx_JSQR_JEXTSEL_MASK          = 0x0000007CU;   /** @brief ADC group injected external trigger source */
    static const uint32_t ADCx_JSQR_JL_MASK               = 0x00000003U;   /** @brief ADC group injected sequencer scan length */
    static const uint32_t ADCx_OFRx_SSATE_MASK            = 0x80000000U;   /** @brief ADC offset number 1 enable */
    static const uint32_t ADCx_OFRx_OFFSET1_CH_MASK       = 0x7C000000U;   /** @brief ADC offset number 1 channel selection */
    static const uint32_t ADCx_OFRx_OFFSET1_MASK          = 0x03FFFFFFU;   /** @brief ADC offset number 1 offset level */
    static const uint32_t ADCx_AWD2CR_AWD2CH_MASK         = 0x000FFFFFU;   /** @brief ADC analog watchdog 2 monitored channel selection */
    static const uint32_t ADCx_AWD3CR_AWD3CH_MASK         = 0x001FFFFEU;   /** @brief ADC analog watchdog 3 monitored channel selection */
    static const uint32_t ADCx_DIFSEL_DIFSEL_MASK         = 0x000FFFFFU;   /** @brief ADC channel differential or single-ended mode for channel */
    static const uint32_t ADCx_CALFACT_CALFACT_D_MASK     = 0x07FF0000U;   /** @brief ADC calibration factor in differential mode */
    static const uint32_t ADCx_CALFACT_CALFACT_S_MASK     = 0x000007FFU;   /** @brief ADC calibration factor in single-ended mode */
    static const uint32_t ADCx_PCSEL_PCSEL_MASK           = 0x000FFFFFU;   /** @brief Channel x (vinp[i]) pre selection */
    static const uint32_t ADCx_HTRx_HTR2_MASK             = 0x03FFFFFFU;   /** @brief Analog watchdog 2 higher threshold */
    static const uint32_t ADCx_CALFACT2_LINCALFACT_MASK   = 0x3FFFFFFFU;   /** @brief Linearity calibration factor */

    /**** @subsection Enumerated ADCx Register Field Masks ****/

    static const uint32_t ADCx_ISR_AWDx_MASK[4] = {
      [1] = 0x00000080U,   /** @brief ADC analog watchdog 1 flag */
      [2] = 0x00000100U,   /** @brief ADC analog watchdog 2 flag */
      [3] = 0x00000200U,   /** @brief ADC analog watchdog 3 flag */
    };

    static const uint32_t ADCx_IER_AWDxIE_MASK[4] = {
      [1] = 0x00000080U,   /** @brief ADC analog watchdog 1 interrupt */
      [2] = 0x00000100U,   /** @brief ADC analog watchdog 2 interrupt */
      [3] = 0x00000200U,   /** @brief ADC analog watchdog 3 interrupt */
    };

    static const uint32_t ADCx_CR_LINCALRDYWx_MASK[7] = {
      [1] = 0x00400000U,   /** @brief Linearity calibration ready word 1 */
      [2] = 0x00800000U,   /** @brief Linearity calibration ready word 2 */
      [3] = 0x01000000U,   /** @brief Linearity calibration ready word 3 */
      [4] = 0x02000000U,   /** @brief Linearity calibration ready word 4 */
      [5] = 0x04000000U,   /** @brief Linearity calibration ready word 5 */
      [6] = 0x08000000U,   /** @brief Linearity calibration ready word 6 */
    };

    static const uint32_t ADCx_CFGR2_RSHIFTx_MASK[5] = {
      [1] = 0x00000800U,   /** @brief Right-shift data after offset 1 correction */
      [2] = 0x00001000U,   /** @brief Right-shift data after offset 2 correction */
      [3] = 0x00002000U,   /** @brief Right-shift data after offset 3 correction */
      [4] = 0x00004000U,   /** @brief Right-shift data after offset 4 correction */
    };

    static const uint32_t ADCx_SMPR1_SMPx_MASK[10] = {
      [1]  = 0x00000038U,   /** @brief ADC channel 1 sampling time selection */
      [2]  = 0x000001C0U,   /** @brief ADC channel 2 sampling time selection */
      [3]  = 0x00000E00U,   /** @brief ADC channel 3 sampling time selection */
      [4]  = 0x00007000U,   /** @brief ADC channel 4 sampling time selection */
      [5]  = 0x00038000U,   /** @brief ADC channel 5 sampling time selection */
      [6]  = 0x001C0000U,   /** @brief ADC channel 6 sampling time selection */
      [7]  = 0x00E00000U,   /** @brief ADC channel 7 sampling time selection */
      [8]  = 0x07000000U,   /** @brief ADC channel 8 sampling time selection */
      [9]  = 0x38000000U,   /** @brief ADC channel 9 sampling time selection */
    };

    static const uint32_t ADCx_SMPR2_SMP1x_MASK[10] = {
      [0]  = 0x00000007U,   /** @brief ADC channel 10 sampling time selection */
      [1]  = 0x00000038U,   /** @brief ADC channel 11 sampling time selection */
      [2]  = 0x000001C0U,   /** @brief ADC channel 12 sampling time selection */
      [3]  = 0x00000E00U,   /** @brief ADC channel 13 sampling time selection */
      [4]  = 0x00007000U,   /** @brief ADC channel 14 sampling time selection */
      [5]  = 0x00038000U,   /** @brief ADC channel 15 sampling time selection */
      [6]  = 0x001C0000U,   /** @brief ADC channel 16 sampling time selection */
      [7]  = 0x00E00000U,   /** @brief ADC channel 17 sampling time selection */
      [8]  = 0x07000000U,   /** @brief ADC channel 18 sampling time selection */
      [9]  = 0x38000000U,   /** @brief ADC channel 18 sampling time selection */
    };

    static const uint32_t ADCx_SQR1_SQx_MASK[5] = {
      [1] = 0x000007C0U,   /** @brief ADC group regular sequencer rank 1 */
      [2] = 0x0001F000U,   /** @brief ADC group regular sequencer rank 2 */
      [3] = 0x007C0000U,   /** @brief ADC group regular sequencer rank 3 */
      [4] = 0x1F000000U,   /** @brief ADC group regular sequencer rank 4 */
    };

    static const uint32_t ADCx_SQR3_SQ1x_MASK[5] = {
      [0] = 0x0000001FU,   /** @brief ADC group regular sequencer rank 10 */
      [1] = 0x000007C0U,   /** @brief ADC group regular sequencer rank 11 */
      [2] = 0x0001F000U,   /** @brief ADC group regular sequencer rank 12 */
      [3] = 0x007C0000U,   /** @brief ADC group regular sequencer rank 13 */
      [4] = 0x1F000000U,   /** @brief ADC group regular sequencer rank 14 */
    };

    static const uint32_t ADCx_JSQR_JSQx_MASK[5] = {
      [1] = 0x00003E00U,   /** @brief ADC group injected sequencer rank 1 */
      [2] = 0x000F8000U,   /** @brief ADC group injected sequencer rank 2 */
      [3] = 0x03E00000U,   /** @brief ADC group injected sequencer rank 3 */
      [4] = 0xF8000000U,   /** @brief ADC group injected sequencer rank 4 */
    };

    /**** @subsection ADCx Register Field Positions ****/

    static const int32_t ADCx_ISR_JQOVF_POS             = 10;   /** @brief ADC group injected contexts queue overflow flag */
    static const int32_t ADCx_ISR_JEOS_POS              = 6;    /** @brief ADC group injected end of sequence conversions flag */
    static const int32_t ADCx_ISR_JEOC_POS              = 5;    /** @brief ADC group injected end of unitary conversion flag */
    static const int32_t ADCx_ISR_OVR_POS               = 4;    /** @brief ADC group regular overrun flag */
    static const int32_t ADCx_ISR_EOS_POS               = 3;    /** @brief ADC group regular end of sequence conversions flag */
    static const int32_t ADCx_ISR_EOC_POS               = 2;    /** @brief ADC group regular end of unitary conversion flag */
    static const int32_t ADCx_ISR_EOSMP_POS             = 1;    /** @brief ADC group regular end of sampling flag */
    static const int32_t ADCx_ISR_ADRDY_POS             = 0;    /** @brief ADC ready flag */
    static const int32_t ADCx_IER_JQOVFIE_POS           = 10;   /** @brief ADC group injected contexts queue overflow interrupt */
    static const int32_t ADCx_IER_JEOSIE_POS            = 6;    /** @brief ADC group injected end of sequence conversions interrupt */
    static const int32_t ADCx_IER_JEOCIE_POS            = 5;    /** @brief ADC group injected end of unitary conversion interrupt */
    static const int32_t ADCx_IER_OVRIE_POS             = 4;    /** @brief ADC group regular overrun interrupt */
    static const int32_t ADCx_IER_EOSIE_POS             = 3;    /** @brief ADC group regular end of sequence conversions interrupt */
    static const int32_t ADCx_IER_EOCIE_POS             = 2;    /** @brief ADC group regular end of unitary conversion interrupt */
    static const int32_t ADCx_IER_EOSMPIE_POS           = 1;    /** @brief ADC group regular end of sampling interrupt */
    static const int32_t ADCx_IER_ADRDYIE_POS           = 0;    /** @brief ADC ready interrupt */
    static const int32_t ADCx_CR_ADCAL_POS              = 31;   /** @brief ADC calibration */
    static const int32_t ADCx_CR_ADCALDIF_POS           = 30;   /** @brief ADC differential mode for calibration */
    static const int32_t ADCx_CR_DEEPPWD_POS            = 29;   /** @brief ADC deep power down enable */
    static const int32_t ADCx_CR_ADVREGEN_POS           = 28;   /** @brief ADC voltage regulator enable */
    static const int32_t ADCx_CR_ADCALLIN_POS           = 16;   /** @brief Linearity calibration */
    static const int32_t ADCx_CR_BOOST_POS              = 8;    /** @brief Boost mode control */
    static const int32_t ADCx_CR_JADSTP_POS             = 5;    /** @brief ADC group injected conversion stop */
    static const int32_t ADCx_CR_ADSTP_POS              = 4;    /** @brief ADC group regular conversion stop */
    static const int32_t ADCx_CR_JADSTART_POS           = 3;    /** @brief ADC group injected conversion start */
    static const int32_t ADCx_CR_ADSTART_POS            = 2;    /** @brief ADC group regular conversion start */
    static const int32_t ADCx_CR_ADDIS_POS              = 1;    /** @brief ADC disable */
    static const int32_t ADCx_CR_ADEN_POS               = 0;    /** @brief ADC enable */
    static const int32_t ADCx_CFGR_JQDIS_POS            = 31;   /** @brief ADC group injected contexts queue disable */
    static const int32_t ADCx_CFGR_AWDCH1CH_POS         = 26;   /** @brief ADC analog watchdog 1 monitored channel selection */
    static const int32_t ADCx_CFGR_JAUTO_POS            = 25;   /** @brief ADC group injected automatic trigger mode */
    static const int32_t ADCx_CFGR_JAWD1EN_POS          = 24;   /** @brief ADC analog watchdog 1 enable on scope ADC group injected */
    static const int32_t ADCx_CFGR_AWD1EN_POS           = 23;   /** @brief ADC analog watchdog 1 enable on scope ADC group regular */
    static const int32_t ADCx_CFGR_AWD1SGL_POS          = 22;   /** @brief ADC analog watchdog 1 monitoring a single channel or all channels */
    static const int32_t ADCx_CFGR_JQM_POS              = 21;   /** @brief ADC group injected contexts queue mode */
    static const int32_t ADCx_CFGR_JDISCEN_POS          = 20;   /** @brief ADC group injected sequencer discontinuous mode */
    static const int32_t ADCx_CFGR_DISCNUM_POS          = 17;   /** @brief ADC group regular sequencer discontinuous number of ranks */
    static const int32_t ADCx_CFGR_DISCEN_POS           = 16;   /** @brief ADC group regular sequencer discontinuous mode */
    static const int32_t ADCx_CFGR_AUTDLY_POS           = 14;   /** @brief ADC low power auto wait */
    static const int32_t ADCx_CFGR_CONT_POS             = 13;   /** @brief ADC group regular continuous conversion mode */
    static const int32_t ADCx_CFGR_OVRMOD_POS           = 12;   /** @brief ADC group regular overrun configuration */
    static const int32_t ADCx_CFGR_EXTEN_POS            = 10;   /** @brief ADC group regular external trigger polarity */
    static const int32_t ADCx_CFGR_EXTSEL_POS           = 5;    /** @brief ADC group regular external trigger source */
    static const int32_t ADCx_CFGR_RES_POS              = 2;    /** @brief ADC data resolution */
    static const int32_t ADCx_CFGR_DMNGT_POS            = 0;    /** @brief ADC DMA transfer enable */
    static const int32_t ADCx_CFGR2_ROVSE_POS           = 0;    /** @brief ADC oversampler enable on scope ADC group regular */
    static const int32_t ADCx_CFGR2_JOVSE_POS           = 1;    /** @brief ADC oversampler enable on scope ADC group injected */
    static const int32_t ADCx_CFGR2_OVSS_POS            = 5;    /** @brief ADC oversampling shift */
    static const int32_t ADCx_CFGR2_TROVS_POS           = 9;    /** @brief ADC oversampling discontinuous mode (triggered mode) for ADC group regular */
    static const int32_t ADCx_CFGR2_ROVSM_POS           = 10;   /** @brief Regular oversampling mode */
    static const int32_t ADCx_CFGR2_OSR_POS             = 16;   /** @brief Oversampling ratio */
    static const int32_t ADCx_CFGR2_LSHIFT_POS          = 28;   /** @brief Left shift factor */
    static const int32_t ADCx_LTRx_LTR1_POS             = 0;    /** @brief ADC analog watchdog 1 threshold low */
    static const int32_t ADCx_LHTR1_LHTR1_POS           = 0;    /** @brief ADC analog watchdog 2 threshold low */
    static const int32_t ADCx_SQR1_L3_POS               = 0;    /** @brief L3 */
    static const int32_t ADCx_DR_RDATA_POS              = 0;    /** @brief ADC group regular conversion data */
    static const int32_t ADCx_JSQR_JEXTEN_POS           = 7;    /** @brief ADC group injected external trigger polarity */
    static const int32_t ADCx_JSQR_JEXTSEL_POS          = 2;    /** @brief ADC group injected external trigger source */
    static const int32_t ADCx_JSQR_JL_POS               = 0;    /** @brief ADC group injected sequencer scan length */
    static const int32_t ADCx_OFRx_SSATE_POS            = 31;   /** @brief ADC offset number 1 enable */
    static const int32_t ADCx_OFRx_OFFSET1_CH_POS       = 26;   /** @brief ADC offset number 1 channel selection */
    static const int32_t ADCx_OFRx_OFFSET1_POS          = 0;    /** @brief ADC offset number 1 offset level */
    static const int32_t ADCx_AWD2CR_AWD2CH_POS         = 0;    /** @brief ADC analog watchdog 2 monitored channel selection */
    static const int32_t ADCx_AWD3CR_AWD3CH_POS         = 1;    /** @brief ADC analog watchdog 3 monitored channel selection */
    static const int32_t ADCx_DIFSEL_DIFSEL_POS         = 0;    /** @brief ADC channel differential or single-ended mode for channel */
    static const int32_t ADCx_CALFACT_CALFACT_D_POS     = 16;   /** @brief ADC calibration factor in differential mode */
    static const int32_t ADCx_CALFACT_CALFACT_S_POS     = 0;    /** @brief ADC calibration factor in single-ended mode */
    static const int32_t ADCx_PCSEL_PCSEL_POS           = 0;    /** @brief Channel x (vinp[i]) pre selection */
    static const int32_t ADCx_HTRx_HTR2_POS             = 0;    /** @brief Analog watchdog 2 higher threshold */
    static const int32_t ADCx_CALFACT2_LINCALFACT_POS   = 0;    /** @brief Linearity calibration factor */

    /**** @subsection Enumerated ADCx Register Field Positions ****/

    static const int32_t ADCx_ISR_AWDx_POS[4] = {
      [1] = 7,   /** @brief ADC analog watchdog 1 flag */
      [2] = 8,   /** @brief ADC analog watchdog 2 flag */
      [3] = 9,   /** @brief ADC analog watchdog 3 flag */
    };

    static const int32_t ADCx_IER_AWDxIE_POS[4] = {
      [1] = 7,   /** @brief ADC analog watchdog 1 interrupt */
      [2] = 8,   /** @brief ADC analog watchdog 2 interrupt */
      [3] = 9,   /** @brief ADC analog watchdog 3 interrupt */
    };

    static const int32_t ADCx_CR_LINCALRDYWx_POS[7] = {
      [1] = 22,   /** @brief Linearity calibration ready word 1 */
      [2] = 23,   /** @brief Linearity calibration ready word 2 */
      [3] = 24,   /** @brief Linearity calibration ready word 3 */
      [4] = 25,   /** @brief Linearity calibration ready word 4 */
      [5] = 26,   /** @brief Linearity calibration ready word 5 */
      [6] = 27,   /** @brief Linearity calibration ready word 6 */
    };

    static const int32_t ADCx_CFGR2_RSHIFTx_POS[5] = {
      [1] = 11,   /** @brief Right-shift data after offset 1 correction */
      [2] = 12,   /** @brief Right-shift data after offset 2 correction */
      [3] = 13,   /** @brief Right-shift data after offset 3 correction */
      [4] = 14,   /** @brief Right-shift data after offset 4 correction */
    };

    static const int32_t ADCx_SMPR1_SMPx_POS[10] = {
      [1]  = 3,    /** @brief ADC channel 1 sampling time selection */
      [2]  = 6,    /** @brief ADC channel 2 sampling time selection */
      [3]  = 9,    /** @brief ADC channel 3 sampling time selection */
      [4]  = 12,   /** @brief ADC channel 4 sampling time selection */
      [5]  = 15,   /** @brief ADC channel 5 sampling time selection */
      [6]  = 18,   /** @brief ADC channel 6 sampling time selection */
      [7]  = 21,   /** @brief ADC channel 7 sampling time selection */
      [8]  = 24,   /** @brief ADC channel 8 sampling time selection */
      [9]  = 27,   /** @brief ADC channel 9 sampling time selection */
    };

    static const int32_t ADCx_SMPR2_SMP1x_POS[10] = {
      [0]  = 0,    /** @brief ADC channel 10 sampling time selection */
      [1]  = 3,    /** @brief ADC channel 11 sampling time selection */
      [2]  = 6,    /** @brief ADC channel 12 sampling time selection */
      [3]  = 9,    /** @brief ADC channel 13 sampling time selection */
      [4]  = 12,   /** @brief ADC channel 14 sampling time selection */
      [5]  = 15,   /** @brief ADC channel 15 sampling time selection */
      [6]  = 18,   /** @brief ADC channel 16 sampling time selection */
      [7]  = 21,   /** @brief ADC channel 17 sampling time selection */
      [8]  = 24,   /** @brief ADC channel 18 sampling time selection */
      [9]  = 27,   /** @brief ADC channel 18 sampling time selection */
    };

    static const int32_t ADCx_SQR1_SQx_POS[5] = {
      [1] = 6,    /** @brief ADC group regular sequencer rank 1 */
      [2] = 12,   /** @brief ADC group regular sequencer rank 2 */
      [3] = 18,   /** @brief ADC group regular sequencer rank 3 */
      [4] = 24,   /** @brief ADC group regular sequencer rank 4 */
    };

    static const int32_t ADCx_SQR3_SQ1x_POS[5] = {
      [0] = 0,    /** @brief ADC group regular sequencer rank 10 */
      [1] = 6,    /** @brief ADC group regular sequencer rank 11 */
      [2] = 12,   /** @brief ADC group regular sequencer rank 12 */
      [3] = 18,   /** @brief ADC group regular sequencer rank 13 */
      [4] = 24,   /** @brief ADC group regular sequencer rank 14 */
    };

    static const int32_t ADCx_JSQR_JSQx_POS[5] = {
      [1] = 9,    /** @brief ADC group injected sequencer rank 1 */
      [2] = 15,   /** @brief ADC group injected sequencer rank 2 */
      [3] = 21,   /** @brief ADC group injected sequencer rank 3 */
      [4] = 27,   /** @brief ADC group injected sequencer rank 4 */
    };

    /**********************************************************************************************
     * @section ADCx_COMMON Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated ADCx_COMMON Register Pointers ****/

    static RO_ uint32_t* const ADCx_COMMON_CSR_PTR[13] = {
      [3]  = (RO_ uint32_t* const)0x58026300U,   /** @brief ADC common status register */
      [12] = (RO_ uint32_t* const)0x40022300U,   /** @brief ADC common status register */
    };

    static RW_ uint32_t* const ADCx_COMMON_CCR_PTR[13] = {
      [3]  = (RW_ uint32_t* const)0x58026308U,   /** @brief ADC common control register */
      [12] = (RW_ uint32_t* const)0x40022308U,   /** @brief ADC common control register */
    };

    static RO_ uint32_t* const ADCx_COMMON_CDR_PTR[13] = {
      [3]  = (RO_ uint32_t* const)0x5802630CU,   /** @brief ADC common regular data register for dual and triple modes */
      [12] = (RO_ uint32_t* const)0x4002230CU,   /** @brief ADC common regular data register for dual and triple modes */
    };

    static RO_ uint32_t* const ADCx_COMMON_CDR2_PTR[13] = {
      [3]  = (RO_ uint32_t* const)0x58026310U,   /** @brief ADC x common regular data register for 32-bit dual mode */
      [12] = (RO_ uint32_t* const)0x40022310U,   /** @brief ADC x common regular data register for 32-bit dual mode */
    };

    /**** @subsection Enumerated ADCx_COMMON Register Reset Values ****/

    static const uint32_t ADCx_COMMON_CSR_RST[13] = {
      [3]  = 0x00000000U,   /** @brief CSR register reset value */
      [12] = 0x00000000U,   /** @brief CSR register reset value */
    };

    static const uint32_t ADCx_COMMON_CCR_RST[13] = {
      [3]  = 0x00000000U,   /** @brief CCR register reset value */
      [12] = 0x00000000U,   /** @brief CCR register reset value */
    };

    static const uint32_t ADCx_COMMON_CDR_RST[13] = {
      [3]  = 0x00000000U,   /** @brief CDR register reset value */
      [12] = 0x00000000U,   /** @brief CDR register reset value */
    };

    static const uint32_t ADCx_COMMON_CDR2_RST[13] = {
      [3]  = 0x00000000U,   /** @brief CDR2 register reset value */
      [12] = 0x00000000U,   /** @brief CDR2 register reset value */
    };

    /**** @subsection Enumerated ADCx_COMMON Register Value Types ****/

    typedef uint32_t ADCx_COMMON_CSR_t;    /** @brief CSR register value type. */
    typedef uint32_t ADCx_COMMON_CCR_t;    /** @brief CCR register value type. */
    typedef uint32_t ADCx_COMMON_CDR_t;    /** @brief CDR register value type. */
    typedef uint32_t ADCx_COMMON_CDR2_t;   /** @brief CDR2 register value type. */

    /**** @subsection Enumerated ADCx_COMMON Register Pointer Types ****/

    typedef uint32_t* const ADCx_COMMON_CSR_PTR_t;    /** @brief CSR register pointer type. */
    typedef uint32_t* const ADCx_COMMON_CCR_PTR_t;    /** @brief CCR register pointer type. */
    typedef uint32_t* const ADCx_COMMON_CDR_PTR_t;    /** @brief CDR register pointer type. */
    typedef uint32_t* const ADCx_COMMON_CDR2_PTR_t;   /** @brief CDR2 register pointer type. */

    /**** @subsection ADCx_COMMON Register Field Masks ****/

    static const uint32_t ADCx_COMMON_CSR_ADRDY_MST_MASK   = 0x00000001U;   /** @brief Master ADC ready */
    static const uint32_t ADCx_COMMON_CSR_EOSMP_MST_MASK   = 0x00000002U;   /** @brief End of sampling phase flag of the master ADC */
    static const uint32_t ADCx_COMMON_CSR_EOC_MST_MASK     = 0x00000004U;   /** @brief End of regular conversion of the master ADC */
    static const uint32_t ADCx_COMMON_CSR_EOS_MST_MASK     = 0x00000008U;   /** @brief End of regular sequence flag of the master ADC */
    static const uint32_t ADCx_COMMON_CSR_OVR_MST_MASK     = 0x00000010U;   /** @brief Overrun flag of the master ADC */
    static const uint32_t ADCx_COMMON_CSR_JEOC_MST_MASK    = 0x00000020U;   /** @brief End of injected conversion flag of the master ADC */
    static const uint32_t ADCx_COMMON_CSR_JEOS_MST_MASK    = 0x00000040U;   /** @brief End of injected sequence flag of the master ADC */
    static const uint32_t ADCx_COMMON_CSR_JQOVF_MST_MASK   = 0x00000400U;   /** @brief Injected context queue overflow flag of the master ADC */
    static const uint32_t ADCx_COMMON_CSR_ADRDY_SLV_MASK   = 0x00010000U;   /** @brief Slave ADC ready */
    static const uint32_t ADCx_COMMON_CSR_EOSMP_SLV_MASK   = 0x00020000U;   /** @brief End of sampling phase flag of the slave ADC */
    static const uint32_t ADCx_COMMON_CSR_EOC_SLV_MASK     = 0x00040000U;   /** @brief End of regular conversion of the slave ADC */
    static const uint32_t ADCx_COMMON_CSR_EOS_SLV_MASK     = 0x00080000U;   /** @brief End of regular sequence flag of the slave ADC */
    static const uint32_t ADCx_COMMON_CSR_OVR_SLV_MASK     = 0x00100000U;   /** @brief Overrun flag of the slave ADC */
    static const uint32_t ADCx_COMMON_CSR_JEOC_SLV_MASK    = 0x00200000U;   /** @brief End of injected conversion flag of the slave ADC */
    static const uint32_t ADCx_COMMON_CSR_JEOS_SLV_MASK    = 0x00400000U;   /** @brief End of injected sequence flag of the slave ADC */
    static const uint32_t ADCx_COMMON_CSR_JQOVF_SLV_MASK   = 0x04000000U;   /** @brief Injected context queue overflow flag of the slave ADC */
    static const uint32_t ADCx_COMMON_CCR_DUAL_MASK        = 0x0000001FU;   /** @brief Dual ADC mode selection */
    static const uint32_t ADCx_COMMON_CCR_DELAY_MASK       = 0x00000F00U;   /** @brief Delay between 2 sampling phases */
    static const uint32_t ADCx_COMMON_CCR_DAMDF_MASK       = 0x0000C000U;   /** @brief Dual ADC mode data format */
    static const uint32_t ADCx_COMMON_CCR_CKMODE_MASK      = 0x00030000U;   /** @brief ADC clock mode */
    static const uint32_t ADCx_COMMON_CCR_PRESC_MASK       = 0x003C0000U;   /** @brief ADC prescaler */
    static const uint32_t ADCx_COMMON_CCR_VREFEN_MASK      = 0x00400000U;   /** @brief VREFINT enable */
    static const uint32_t ADCx_COMMON_CCR_TSEN_MASK        = 0x00800000U;   /** @brief Temperature sensor enable */
    static const uint32_t ADCx_COMMON_CCR_VBATEN_MASK      = 0x01000000U;   /** @brief VBAT enable */
    static const uint32_t ADCx_COMMON_CDR_RDATA_SLV_MASK   = 0xFFFF0000U;   /** @brief Regular data of the slave ADC */
    static const uint32_t ADCx_COMMON_CDR_RDATA_MST_MASK   = 0x0000FFFFU;   /** @brief Regular data of the master ADC */

    /**** @subsection Enumerated ADCx_COMMON Register Field Masks ****/

    static const uint32_t ADCx_COMMON_CSR_AWDx_MST_MASK[4] = {
      [1] = 0x00000080U,   /** @brief Analog watchdog 1 flag of the master ADC */
      [2] = 0x00000100U,   /** @brief Analog watchdog 2 flag of the master ADC */
      [3] = 0x00000200U,   /** @brief Analog watchdog 3 flag of the master ADC */
    };

    static const uint32_t ADCx_COMMON_CSR_AWDx_SLV_MASK[4] = {
      [1] = 0x00800000U,   /** @brief Analog watchdog 1 flag of the slave ADC */
      [2] = 0x01000000U,   /** @brief Analog watchdog 2 flag of the slave ADC */
      [3] = 0x02000000U,   /** @brief Analog watchdog 3 flag of the slave ADC */
    };

    /**** @subsection ADCx_COMMON Register Field Positions ****/

    static const int32_t ADCx_COMMON_CSR_ADRDY_MST_POS   = 0;    /** @brief Master ADC ready */
    static const int32_t ADCx_COMMON_CSR_EOSMP_MST_POS   = 1;    /** @brief End of sampling phase flag of the master ADC */
    static const int32_t ADCx_COMMON_CSR_EOC_MST_POS     = 2;    /** @brief End of regular conversion of the master ADC */
    static const int32_t ADCx_COMMON_CSR_EOS_MST_POS     = 3;    /** @brief End of regular sequence flag of the master ADC */
    static const int32_t ADCx_COMMON_CSR_OVR_MST_POS     = 4;    /** @brief Overrun flag of the master ADC */
    static const int32_t ADCx_COMMON_CSR_JEOC_MST_POS    = 5;    /** @brief End of injected conversion flag of the master ADC */
    static const int32_t ADCx_COMMON_CSR_JEOS_MST_POS    = 6;    /** @brief End of injected sequence flag of the master ADC */
    static const int32_t ADCx_COMMON_CSR_JQOVF_MST_POS   = 10;   /** @brief Injected context queue overflow flag of the master ADC */
    static const int32_t ADCx_COMMON_CSR_ADRDY_SLV_POS   = 16;   /** @brief Slave ADC ready */
    static const int32_t ADCx_COMMON_CSR_EOSMP_SLV_POS   = 17;   /** @brief End of sampling phase flag of the slave ADC */
    static const int32_t ADCx_COMMON_CSR_EOC_SLV_POS     = 18;   /** @brief End of regular conversion of the slave ADC */
    static const int32_t ADCx_COMMON_CSR_EOS_SLV_POS     = 19;   /** @brief End of regular sequence flag of the slave ADC */
    static const int32_t ADCx_COMMON_CSR_OVR_SLV_POS     = 20;   /** @brief Overrun flag of the slave ADC */
    static const int32_t ADCx_COMMON_CSR_JEOC_SLV_POS    = 21;   /** @brief End of injected conversion flag of the slave ADC */
    static const int32_t ADCx_COMMON_CSR_JEOS_SLV_POS    = 22;   /** @brief End of injected sequence flag of the slave ADC */
    static const int32_t ADCx_COMMON_CSR_JQOVF_SLV_POS   = 26;   /** @brief Injected context queue overflow flag of the slave ADC */
    static const int32_t ADCx_COMMON_CCR_DUAL_POS        = 0;    /** @brief Dual ADC mode selection */
    static const int32_t ADCx_COMMON_CCR_DELAY_POS       = 8;    /** @brief Delay between 2 sampling phases */
    static const int32_t ADCx_COMMON_CCR_DAMDF_POS       = 14;   /** @brief Dual ADC mode data format */
    static const int32_t ADCx_COMMON_CCR_CKMODE_POS      = 16;   /** @brief ADC clock mode */
    static const int32_t ADCx_COMMON_CCR_PRESC_POS       = 18;   /** @brief ADC prescaler */
    static const int32_t ADCx_COMMON_CCR_VREFEN_POS      = 22;   /** @brief VREFINT enable */
    static const int32_t ADCx_COMMON_CCR_TSEN_POS        = 23;   /** @brief Temperature sensor enable */
    static const int32_t ADCx_COMMON_CCR_VBATEN_POS      = 24;   /** @brief VBAT enable */
    static const int32_t ADCx_COMMON_CDR_RDATA_SLV_POS   = 16;   /** @brief Regular data of the slave ADC */
    static const int32_t ADCx_COMMON_CDR_RDATA_MST_POS   = 0;    /** @brief Regular data of the master ADC */

    /**** @subsection Enumerated ADCx_COMMON Register Field Positions ****/

    static const int32_t ADCx_COMMON_CSR_AWDx_MST_POS[4] = {
      [1] = 7,   /** @brief Analog watchdog 1 flag of the master ADC */
      [2] = 8,   /** @brief Analog watchdog 2 flag of the master ADC */
      [3] = 9,   /** @brief Analog watchdog 3 flag of the master ADC */
    };

    static const int32_t ADCx_COMMON_CSR_AWDx_SLV_POS[4] = {
      [1] = 23,   /** @brief Analog watchdog 1 flag of the slave ADC */
      [2] = 24,   /** @brief Analog watchdog 2 flag of the slave ADC */
      [3] = 25,   /** @brief Analog watchdog 3 flag of the slave ADC */
    };

    /**********************************************************************************************
     * @section DMAMUX1 Register Information
     **********************************************************************************************/

    /**** @subsection DMAMUX1 Register Pointers ****/

    static RO_ uint32_t* const DMAMUX1_RGSR_PTR    = (RO_ uint32_t* const)0x40020940U;   /** @brief DMAMux - DMA request generator status register */
    static RW_ uint32_t* const DMAMUX1_RGCFR_PTR   = (RW_ uint32_t* const)0x40020944U;   /** @brief DMAMux - DMA request generator clear flag register */
    static RO_ uint32_t* const DMAMUX1_CSR_PTR     = (RO_ uint32_t* const)0x40020880U;   /** @brief DMAMUX request line multiplexer interrupt channel status register */
    static RW_ uint32_t* const DMAMUX1_CFR_PTR     = (RW_ uint32_t* const)0x40020884U;   /** @brief DMAMUX request line multiplexer interrupt clear flag register */

    /**** @subsection Enumerated DMAMUX1 Register Pointers ****/

    static RW_ uint32_t* const DMAMUX1_CxCR_PTR[16] = {
      [0]  = (RW_ uint32_t* const)0x40020800U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [1]  = (RW_ uint32_t* const)0x40020804U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [2]  = (RW_ uint32_t* const)0x40020808U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [3]  = (RW_ uint32_t* const)0x4002080CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [4]  = (RW_ uint32_t* const)0x40020810U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [5]  = (RW_ uint32_t* const)0x40020814U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [6]  = (RW_ uint32_t* const)0x40020818U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [7]  = (RW_ uint32_t* const)0x4002081CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [8]  = (RW_ uint32_t* const)0x40020820U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [9]  = (RW_ uint32_t* const)0x40020824U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [10] = (RW_ uint32_t* const)0x40020828U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [11] = (RW_ uint32_t* const)0x4002082CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [12] = (RW_ uint32_t* const)0x40020830U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [13] = (RW_ uint32_t* const)0x40020834U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [14] = (RW_ uint32_t* const)0x40020838U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [15] = (RW_ uint32_t* const)0x4002083CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
    };

    static RW_ uint32_t* const DMAMUX1_RGxCR_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40020900U,   /** @brief DMAMux - DMA request generator channel x control register */
      [1] = (RW_ uint32_t* const)0x40020904U,   /** @brief DMAMux - DMA request generator channel x control register */
      [2] = (RW_ uint32_t* const)0x40020908U,   /** @brief DMAMux - DMA request generator channel x control register */
      [3] = (RW_ uint32_t* const)0x4002090CU,   /** @brief DMAMux - DMA request generator channel x control register */
      [4] = (RW_ uint32_t* const)0x40020910U,   /** @brief DMAMux - DMA request generator channel x control register */
      [5] = (RW_ uint32_t* const)0x40020914U,   /** @brief DMAMux - DMA request generator channel x control register */
      [6] = (RW_ uint32_t* const)0x40020918U,   /** @brief DMAMux - DMA request generator channel x control register */
      [7] = (RW_ uint32_t* const)0x4002091CU,   /** @brief DMAMux - DMA request generator channel x control register */
    };

    /**** @subsection DMAMUX1 Register Reset Values ****/

    static const uint32_t DMAMUX1_RGSR_RST= 0x00000000U;   /** @brief RGSR register reset value. */
    static const uint32_t DMAMUX1_RGCFR_RST= 0x00000000U;   /** @brief RGCFR register reset value. */
    static const uint32_t DMAMUX1_CSR_RST= 0x00000000U;   /** @brief CSR register reset value. */
    static const uint32_t DMAMUX1_CFR_RST= 0x00000000U;   /** @brief CFR register reset value. */

    /**** @subsection Enumerated DMAMUX1 Register Reset Values ****/

    static const uint32_t DMAMUX1_CxCR_RST[16] = {
      [0]  = 0x00000000U,   /** @brief C0CR register reset value. */
      [1]  = 0x00000000U,   /** @brief C1CR register reset value. */
      [2]  = 0x00000000U,   /** @brief C2CR register reset value. */
      [3]  = 0x00000000U,   /** @brief C3CR register reset value. */
      [4]  = 0x00000000U,   /** @brief C4CR register reset value. */
      [5]  = 0x00000000U,   /** @brief C5CR register reset value. */
      [6]  = 0x00000000U,   /** @brief C6CR register reset value. */
      [7]  = 0x00000000U,   /** @brief C7CR register reset value. */
      [8]  = 0x00000000U,   /** @brief C8CR register reset value. */
      [9]  = 0x00000000U,   /** @brief C9CR register reset value. */
      [10] = 0x00000000U,   /** @brief C10CR register reset value. */
      [11] = 0x00000000U,   /** @brief C11CR register reset value. */
      [12] = 0x00000000U,   /** @brief C12CR register reset value. */
      [13] = 0x00000000U,   /** @brief C13CR register reset value. */
      [14] = 0x00000000U,   /** @brief C14CR register reset value. */
      [15] = 0x00000000U,   /** @brief C15CR register reset value. */
    };

    static const uint32_t DMAMUX1_RGxCR_RST[8] = {
      [0] = 0x00000000U,   /** @brief RG0CR register reset value. */
      [1] = 0x00000000U,   /** @brief RG1CR register reset value. */
      [2] = 0x00000000U,   /** @brief RG2CR register reset value. */
      [3] = 0x00000000U,   /** @brief RG3CR register reset value. */
      [4] = 0x00000000U,   /** @brief RG4CR register reset value. */
      [5] = 0x00000000U,   /** @brief RG5CR register reset value. */
      [6] = 0x00000000U,   /** @brief RG6CR register reset value. */
      [7] = 0x00000000U,   /** @brief RG7CR register reset value. */
    };

    /**** @subsection Enumerated DMAMUX1 Register Value Types ****/

    typedef uint32_t DMAMUX1_CxCR_t;    /** @brief CxCR register value type. */
    typedef uint32_t DMAMUX1_RGxCR_t;   /** @brief RGxCR register value type. */
    typedef uint32_t DMAMUX1_RGSR_t;    /** @brief RGSR register value type. */
    typedef uint32_t DMAMUX1_RGCFR_t;   /** @brief RGCFR register value type. */
    typedef uint32_t DMAMUX1_CSR_t;     /** @brief CSR register value type. */
    typedef uint32_t DMAMUX1_CFR_t;     /** @brief CFR register value type. */

    /**** @subsection Enumerated DMAMUX1 Register Pointer Types ****/

    typedef uint32_t* const DMAMUX1_CxCR_PTR_t;    /** @brief CxCR register pointer type. */
    typedef uint32_t* const DMAMUX1_RGxCR_PTR_t;   /** @brief RGxCR register pointer type. */
    typedef uint32_t* const DMAMUX1_RGSR_PTR_t;    /** @brief RGSR register pointer type. */
    typedef uint32_t* const DMAMUX1_RGCFR_PTR_t;   /** @brief RGCFR register pointer type. */
    typedef uint32_t* const DMAMUX1_CSR_PTR_t;     /** @brief CSR register pointer type. */
    typedef uint32_t* const DMAMUX1_CFR_PTR_t;     /** @brief CFR register pointer type. */

    /**** @subsection DMAMUX1 Register Field Masks ****/

    static const uint32_t DMAMUX1_CxCR_DMAREQ_ID_MASK   = 0x000000FFU;   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CxCR_SOIE_MASK        = 0x00000100U;   /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CxCR_EGE_MASK         = 0x00000200U;   /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CxCR_SE_MASK          = 0x00010000U;   /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CxCR_SPOL_MASK        = 0x00060000U;   /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CxCR_NBREQ_MASK       = 0x00F80000U;   /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CxCR_SYNC_ID_MASK     = 0x1F000000U;   /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_RGxCR_SIG_ID_MASK     = 0x0000001FU;   /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGxCR_OIE_MASK        = 0x00000100U;   /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGxCR_GE_MASK         = 0x00010000U;   /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGxCR_GPOL_MASK       = 0x00060000U;   /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGxCR_GNBREQ_MASK     = 0x00F80000U;   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGSR_OF_MASK          = 0x000000FFU;   /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const uint32_t DMAMUX1_RGCFR_COF_MASK        = 0x000000FFU;   /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const uint32_t DMAMUX1_CSR_SOF_MASK          = 0x0000FFFFU;   /** @brief Synchronization overrun event flag */
    static const uint32_t DMAMUX1_CFR_CSOF_MASK         = 0x0000FFFFU;   /** @brief Clear synchronization overrun event flag */

    /**** @subsection DMAMUX1 Register Field Positions ****/

    static const int32_t DMAMUX1_CxCR_DMAREQ_ID_POS   = 0;    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CxCR_SOIE_POS        = 8;    /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CxCR_EGE_POS         = 9;    /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CxCR_SE_POS          = 16;   /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CxCR_SPOL_POS        = 17;   /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CxCR_NBREQ_POS       = 19;   /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CxCR_SYNC_ID_POS     = 24;   /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_RGxCR_SIG_ID_POS     = 0;    /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_RGxCR_OIE_POS        = 8;    /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_RGxCR_GE_POS         = 16;   /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_RGxCR_GPOL_POS       = 17;   /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_RGxCR_GNBREQ_POS     = 19;   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_RGSR_OF_POS          = 0;    /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const int32_t DMAMUX1_RGCFR_COF_POS        = 0;    /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const int32_t DMAMUX1_CSR_SOF_POS          = 0;    /** @brief Synchronization overrun event flag */
    static const int32_t DMAMUX1_CFR_CSOF_POS         = 0;    /** @brief Clear synchronization overrun event flag */

    /**********************************************************************************************
     * @section CRC Register Information
     **********************************************************************************************/

    /**** @subsection CRC Register Pointers ****/

    static RW_ uint32_t* const CRC_DR_PTR     = (RW_ uint32_t* const)0x58024C00U;   /** @brief Data register */
    static RW_ uint32_t* const CRC_IDR_PTR    = (RW_ uint32_t* const)0x58024C04U;   /** @brief Independent data register */
    static RW_ uint32_t* const CRC_CR_PTR     = (RW_ uint32_t* const)0x58024C08U;   /** @brief Control register */
    static RW_ uint32_t* const CRC_INIT_PTR   = (RW_ uint32_t* const)0x58024C0CU;   /** @brief Initial CRC value */
    static RW_ uint32_t* const CRC_POL_PTR    = (RW_ uint32_t* const)0x58024C10U;   /** @brief CRC polynomial */

    /**** @subsection CRC Register Reset Values ****/

    static const uint32_t CRC_DR_RST     = 0xFFFFFFFFU;   /** @brief DR register reset value. */
    static const uint32_t CRC_IDR_RST    = 0x00000000U;   /** @brief IDR register reset value. */
    static const uint32_t CRC_CR_RST     = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t CRC_INIT_RST   = 0x00000000U;   /** @brief INIT register reset value. */
    static const uint32_t CRC_POL_RST    = 0x00000000U;   /** @brief POL register reset value. */

    /**** @subsection Enumerated CRC Register Value Types ****/

    typedef uint32_t CRC_DR_t;     /** @brief DR register value type. */
    typedef uint32_t CRC_IDR_t;    /** @brief IDR register value type. */
    typedef uint32_t CRC_CR_t;     /** @brief CR register value type. */
    typedef uint32_t CRC_INIT_t;   /** @brief INIT register value type. */
    typedef uint32_t CRC_POL_t;    /** @brief POL register value type. */

    /**** @subsection Enumerated CRC Register Pointer Types ****/

    typedef uint32_t* const CRC_DR_PTR_t;     /** @brief DR register pointer type. */
    typedef uint32_t* const CRC_IDR_PTR_t;    /** @brief IDR register pointer type. */
    typedef uint32_t* const CRC_CR_PTR_t;     /** @brief CR register pointer type. */
    typedef uint32_t* const CRC_INIT_PTR_t;   /** @brief INIT register pointer type. */
    typedef uint32_t* const CRC_POL_PTR_t;    /** @brief POL register pointer type. */

    /**** @subsection CRC Register Field Masks ****/

    static const uint32_t CRC_CR_RESET_MASK      = 0x00000001U;   /** @brief RESET bit */
    static const uint32_t CRC_CR_POLYSIZE_MASK   = 0x00000018U;   /** @brief Polynomial size */
    static const uint32_t CRC_CR_REV_IN_MASK     = 0x00000060U;   /** @brief Reverse input data */
    static const uint32_t CRC_CR_REV_OUT_MASK    = 0x00000080U;   /** @brief Reverse output data */

    /**** @subsection CRC Register Field Positions ****/

    static const int32_t CRC_CR_RESET_POS      = 0;   /** @brief RESET bit */
    static const int32_t CRC_CR_POLYSIZE_POS   = 3;   /** @brief Polynomial size */
    static const int32_t CRC_CR_REV_IN_POS     = 5;   /** @brief Reverse input data */
    static const int32_t CRC_CR_REV_OUT_POS    = 7;   /** @brief Reverse output data */

    /**********************************************************************************************
     * @section RCC Register Information
     **********************************************************************************************/

    /**** @subsection RCC Register Pointers ****/

    static RW_ uint32_t* const RCC_CR_PTR              = (RW_ uint32_t* const)0x58024400U;   /** @brief Clock control register */
    static RW_ uint32_t* const RCC_ICSCR_PTR           = (RW_ uint32_t* const)0x58024404U;   /** @brief RCC internal clock source calibration register */
    static RO_ uint32_t* const RCC_CRRCR_PTR           = (RO_ uint32_t* const)0x58024408U;   /** @brief RCC clock recovery RC register */
    static RW_ uint32_t* const RCC_CFGR_PTR            = (RW_ uint32_t* const)0x58024410U;   /** @brief RCC clock configuration register */
    static RW_ uint32_t* const RCC_D1CFGR_PTR          = (RW_ uint32_t* const)0x58024418U;   /** @brief RCC domain 1 clock configuration register */
    static RW_ uint32_t* const RCC_D2CFGR_PTR          = (RW_ uint32_t* const)0x5802441CU;   /** @brief RCC domain 2 clock configuration register */
    static RW_ uint32_t* const RCC_D3CFGR_PTR          = (RW_ uint32_t* const)0x58024420U;   /** @brief RCC domain 3 clock configuration register */
    static RW_ uint32_t* const RCC_PLLCKSELR_PTR       = (RW_ uint32_t* const)0x58024428U;   /** @brief RCC plls clock source selection register */
    static RW_ uint32_t* const RCC_PLLCFGR_PTR         = (RW_ uint32_t* const)0x5802442CU;   /** @brief RCC plls configuration register */
    static RW_ uint32_t* const RCC_D1CCIPR_PTR         = (RW_ uint32_t* const)0x5802444CU;   /** @brief RCC domain 1 kernel clock configuration register */
    static RW_ uint32_t* const RCC_D2CCIP1R_PTR        = (RW_ uint32_t* const)0x58024450U;   /** @brief RCC domain 2 kernel clock configuration register */
    static RW_ uint32_t* const RCC_D2CCIP2R_PTR        = (RW_ uint32_t* const)0x58024454U;   /** @brief RCC domain 2 kernel clock configuration register */
    static RW_ uint32_t* const RCC_D3CCIPR_PTR         = (RW_ uint32_t* const)0x58024458U;   /** @brief RCC domain 3 kernel clock configuration register */
    static RW_ uint32_t* const RCC_CIER_PTR            = (RW_ uint32_t* const)0x58024460U;   /** @brief RCC clock source interrupt enable register */
    static RW_ uint32_t* const RCC_CIFR_PTR            = (RW_ uint32_t* const)0x58024464U;   /** @brief RCC clock source interrupt flag register */
    static RW_ uint32_t* const RCC_CICR_PTR            = (RW_ uint32_t* const)0x58024468U;   /** @brief RCC clock source interrupt clear register */
    static RW_ uint32_t* const RCC_BDCR_PTR            = (RW_ uint32_t* const)0x58024470U;   /** @brief RCC backup domain control register */
    static RW_ uint32_t* const RCC_CSR_PTR             = (RW_ uint32_t* const)0x58024474U;   /** @brief RCC clock control and status register */
    static RW_ uint32_t* const RCC_AHB3RSTR_PTR        = (RW_ uint32_t* const)0x5802447CU;   /** @brief RCC AHB3 reset register */
    static RW_ uint32_t* const RCC_AHB1RSTR_PTR        = (RW_ uint32_t* const)0x58024480U;   /** @brief RCC AHB1 peripheral reset register */
    static RW_ uint32_t* const RCC_AHB2RSTR_PTR        = (RW_ uint32_t* const)0x58024484U;   /** @brief RCC AHB2 peripheral reset register */
    static RW_ uint32_t* const RCC_AHB4RSTR_PTR        = (RW_ uint32_t* const)0x58024488U;   /** @brief RCC AHB4 peripheral reset register */
    static RW_ uint32_t* const RCC_APB3RSTR_PTR        = (RW_ uint32_t* const)0x5802448CU;   /** @brief RCC APB3 peripheral reset register */
    static RW_ uint32_t* const RCC_APB1LRSTR_PTR       = (RW_ uint32_t* const)0x58024490U;   /** @brief RCC APB1 peripheral reset register */
    static RW_ uint32_t* const RCC_APB1HRSTR_PTR       = (RW_ uint32_t* const)0x58024494U;   /** @brief RCC APB1 peripheral reset register */
    static RW_ uint32_t* const RCC_APB2RSTR_PTR        = (RW_ uint32_t* const)0x58024498U;   /** @brief RCC APB2 peripheral reset register */
    static RW_ uint32_t* const RCC_APB4RSTR_PTR        = (RW_ uint32_t* const)0x5802449CU;   /** @brief RCC APB4 peripheral reset register */
    static RW_ uint32_t* const RCC_GCR_PTR             = (RW_ uint32_t* const)0x580244A0U;   /** @brief RCC global control register */
    static RW_ uint32_t* const RCC_D3AMR_PTR           = (RW_ uint32_t* const)0x580244A8U;   /** @brief RCC D3 autonomous mode register */
    static RW_ uint32_t* const RCC_RSR_PTR             = (RW_ uint32_t* const)0x580244D0U;   /** @brief RCC reset status register */
    static RW_ uint32_t* const RCC_C1_RSR_PTR          = (RW_ uint32_t* const)0x58024530U;   /** @brief RCC reset status register */
    static RW_ uint32_t* const RCC_C1_AHB3ENR_PTR      = (RW_ uint32_t* const)0x58024534U;   /** @brief RCC AHB3 clock register */
    static RW_ uint32_t* const RCC_AHB3ENR_PTR         = (RW_ uint32_t* const)0x580244D4U;   /** @brief RCC AHB3 clock register */
    static RW_ uint32_t* const RCC_AHB1ENR_PTR         = (RW_ uint32_t* const)0x580244D8U;   /** @brief RCC AHB1 clock register */
    static RW_ uint32_t* const RCC_C1_AHB1ENR_PTR      = (RW_ uint32_t* const)0x58024538U;   /** @brief RCC AHB1 clock register */
    static RW_ uint32_t* const RCC_C1_AHB2ENR_PTR      = (RW_ uint32_t* const)0x5802453CU;   /** @brief RCC AHB2 clock register */
    static RW_ uint32_t* const RCC_AHB2ENR_PTR         = (RW_ uint32_t* const)0x580244DCU;   /** @brief RCC AHB2 clock register */
    static RW_ uint32_t* const RCC_AHB4ENR_PTR         = (RW_ uint32_t* const)0x580244E0U;   /** @brief RCC AHB4 clock register */
    static RW_ uint32_t* const RCC_C1_AHB4ENR_PTR      = (RW_ uint32_t* const)0x58024540U;   /** @brief RCC AHB4 clock register */
    static RW_ uint32_t* const RCC_C1_APB3ENR_PTR      = (RW_ uint32_t* const)0x58024544U;   /** @brief RCC APB3 clock register */
    static RW_ uint32_t* const RCC_APB3ENR_PTR         = (RW_ uint32_t* const)0x580244E4U;   /** @brief RCC APB3 clock register */
    static RW_ uint32_t* const RCC_APB1LENR_PTR        = (RW_ uint32_t* const)0x580244E8U;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_C1_APB1LENR_PTR     = (RW_ uint32_t* const)0x58024548U;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_APB1HENR_PTR        = (RW_ uint32_t* const)0x580244ECU;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_C1_APB1HENR_PTR     = (RW_ uint32_t* const)0x5802454CU;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_C1_APB2ENR_PTR      = (RW_ uint32_t* const)0x58024550U;   /** @brief RCC APB2 clock register */
    static RW_ uint32_t* const RCC_APB2ENR_PTR         = (RW_ uint32_t* const)0x580244F0U;   /** @brief RCC APB2 clock register */
    static RW_ uint32_t* const RCC_APB4ENR_PTR         = (RW_ uint32_t* const)0x580244F4U;   /** @brief RCC APB4 clock register */
    static RW_ uint32_t* const RCC_C1_APB4ENR_PTR      = (RW_ uint32_t* const)0x58024554U;   /** @brief RCC APB4 clock register */
    static RW_ uint32_t* const RCC_C1_AHB3LPENR_PTR    = (RW_ uint32_t* const)0x5802455CU;   /** @brief RCC AHB3 sleep clock register */
    static RW_ uint32_t* const RCC_AHB3LPENR_PTR       = (RW_ uint32_t* const)0x580244FCU;   /** @brief RCC AHB3 sleep clock register */
    static RW_ uint32_t* const RCC_AHB1LPENR_PTR       = (RW_ uint32_t* const)0x58024500U;   /** @brief RCC AHB1 sleep clock register */
    static RW_ uint32_t* const RCC_C1_AHB1LPENR_PTR    = (RW_ uint32_t* const)0x58024560U;   /** @brief RCC AHB1 sleep clock register */
    static RW_ uint32_t* const RCC_C1_AHB2LPENR_PTR    = (RW_ uint32_t* const)0x58024564U;   /** @brief RCC AHB2 sleep clock register */
    static RW_ uint32_t* const RCC_AHB2LPENR_PTR       = (RW_ uint32_t* const)0x58024504U;   /** @brief RCC AHB2 sleep clock register */
    static RW_ uint32_t* const RCC_AHB4LPENR_PTR       = (RW_ uint32_t* const)0x58024508U;   /** @brief RCC AHB4 sleep clock register */
    static RW_ uint32_t* const RCC_C1_AHB4LPENR_PTR    = (RW_ uint32_t* const)0x58024568U;   /** @brief RCC AHB4 sleep clock register */
    static RW_ uint32_t* const RCC_C1_APB3LPENR_PTR    = (RW_ uint32_t* const)0x5802456CU;   /** @brief RCC APB3 sleep clock register */
    static RW_ uint32_t* const RCC_APB3LPENR_PTR       = (RW_ uint32_t* const)0x5802450CU;   /** @brief RCC APB3 sleep clock register */
    static RW_ uint32_t* const RCC_APB1LLPENR_PTR      = (RW_ uint32_t* const)0x58024510U;   /** @brief RCC APB1 low sleep clock register */
    static RW_ uint32_t* const RCC_C1_APB1LLPENR_PTR   = (RW_ uint32_t* const)0x58024570U;   /** @brief RCC APB1 low sleep clock register */
    static RW_ uint32_t* const RCC_C1_APB1HLPENR_PTR   = (RW_ uint32_t* const)0x58024574U;   /** @brief RCC APB1 high sleep clock register */
    static RW_ uint32_t* const RCC_APB1HLPENR_PTR      = (RW_ uint32_t* const)0x58024514U;   /** @brief RCC APB1 high sleep clock register */
    static RW_ uint32_t* const RCC_APB2LPENR_PTR       = (RW_ uint32_t* const)0x58024518U;   /** @brief RCC APB2 sleep clock register */
    static RW_ uint32_t* const RCC_C1_APB2LPENR_PTR    = (RW_ uint32_t* const)0x58024578U;   /** @brief RCC APB2 sleep clock register */
    static RW_ uint32_t* const RCC_C1_APB4LPENR_PTR    = (RW_ uint32_t* const)0x5802457CU;   /** @brief RCC APB4 sleep clock register */
    static RW_ uint32_t* const RCC_APB4LPENR_PTR       = (RW_ uint32_t* const)0x5802451CU;   /** @brief RCC APB4 sleep clock register */

    /**** @subsection Enumerated RCC Register Pointers ****/

    static RW_ uint32_t* const RCC_PLLxDIVR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x58024430U,   /** @brief RCC PLL1 dividers configuration register */
      [2] = (RW_ uint32_t* const)0x58024438U,   /** @brief RCC PLL2 dividers configuration register */
      [3] = (RW_ uint32_t* const)0x58024440U,   /** @brief RCC PLL3 dividers configuration register */
    };

    static RW_ uint32_t* const RCC_PLLxFRACR_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x58024434U,   /** @brief RCC PLL1 fractional divider register */
      [2] = (RW_ uint32_t* const)0x5802443CU,   /** @brief RCC PLL2 fractional divider register */
      [3] = (RW_ uint32_t* const)0x58024444U,   /** @brief RCC PLL3 fractional divider register */
    };

    /**** @subsection RCC Register Reset Values ****/

    static const uint32_t RCC_CR_RST              = 0x00000083U;   /** @brief CR register reset value. */
    static const uint32_t RCC_ICSCR_RST           = 0x40000000U;   /** @brief ICSCR register reset value. */
    static const uint32_t RCC_CRRCR_RST           = 0x00000000U;   /** @brief CRRCR register reset value. */
    static const uint32_t RCC_CFGR_RST            = 0x00000000U;   /** @brief CFGR register reset value. */
    static const uint32_t RCC_D1CFGR_RST          = 0x00000000U;   /** @brief D1CFGR register reset value. */
    static const uint32_t RCC_D2CFGR_RST          = 0x00000000U;   /** @brief D2CFGR register reset value. */
    static const uint32_t RCC_D3CFGR_RST          = 0x00000000U;   /** @brief D3CFGR register reset value. */
    static const uint32_t RCC_PLLCKSELR_RST       = 0x02020200U;   /** @brief PLLCKSELR register reset value. */
    static const uint32_t RCC_PLLCFGR_RST         = 0x01FF0000U;   /** @brief PLLCFGR register reset value. */
    static const uint32_t RCC_D1CCIPR_RST         = 0x00000000U;   /** @brief D1CCIPR register reset value. */
    static const uint32_t RCC_D2CCIP1R_RST        = 0x00000000U;   /** @brief D2CCIP1R register reset value. */
    static const uint32_t RCC_D2CCIP2R_RST        = 0x00000000U;   /** @brief D2CCIP2R register reset value. */
    static const uint32_t RCC_D3CCIPR_RST         = 0x00000000U;   /** @brief D3CCIPR register reset value. */
    static const uint32_t RCC_CIER_RST            = 0x00000000U;   /** @brief CIER register reset value. */
    static const uint32_t RCC_CIFR_RST            = 0x00000000U;   /** @brief CIFR register reset value. */
    static const uint32_t RCC_CICR_RST            = 0x00000000U;   /** @brief CICR register reset value. */
    static const uint32_t RCC_BDCR_RST            = 0x00000000U;   /** @brief BDCR register reset value. */
    static const uint32_t RCC_CSR_RST             = 0x00000000U;   /** @brief CSR register reset value. */
    static const uint32_t RCC_AHB3RSTR_RST        = 0x00000000U;   /** @brief AHB3RSTR register reset value. */
    static const uint32_t RCC_AHB1RSTR_RST        = 0x00000000U;   /** @brief AHB1RSTR register reset value. */
    static const uint32_t RCC_AHB2RSTR_RST        = 0x00000000U;   /** @brief AHB2RSTR register reset value. */
    static const uint32_t RCC_AHB4RSTR_RST        = 0x00000000U;   /** @brief AHB4RSTR register reset value. */
    static const uint32_t RCC_APB3RSTR_RST        = 0x00000000U;   /** @brief APB3RSTR register reset value. */
    static const uint32_t RCC_APB1LRSTR_RST       = 0x00000000U;   /** @brief APB1LRSTR register reset value. */
    static const uint32_t RCC_APB1HRSTR_RST       = 0x00000000U;   /** @brief APB1HRSTR register reset value. */
    static const uint32_t RCC_APB2RSTR_RST        = 0x00000000U;   /** @brief APB2RSTR register reset value. */
    static const uint32_t RCC_APB4RSTR_RST        = 0x00000000U;   /** @brief APB4RSTR register reset value. */
    static const uint32_t RCC_GCR_RST             = 0x00000000U;   /** @brief GCR register reset value. */
    static const uint32_t RCC_D3AMR_RST           = 0x00000000U;   /** @brief D3AMR register reset value. */
    static const uint32_t RCC_RSR_RST             = 0x00000000U;   /** @brief RSR register reset value. */
    static const uint32_t RCC_C1_RSR_RST          = 0x00000000U;   /** @brief C1_RSR register reset value. */
    static const uint32_t RCC_C1_AHB3ENR_RST      = 0x00000000U;   /** @brief C1_AHB3ENR register reset value. */
    static const uint32_t RCC_AHB3ENR_RST         = 0x00000000U;   /** @brief AHB3ENR register reset value. */
    static const uint32_t RCC_AHB1ENR_RST         = 0x00000000U;   /** @brief AHB1ENR register reset value. */
    static const uint32_t RCC_C1_AHB1ENR_RST      = 0x00000000U;   /** @brief C1_AHB1ENR register reset value. */
    static const uint32_t RCC_C1_AHB2ENR_RST      = 0x00000000U;   /** @brief C1_AHB2ENR register reset value. */
    static const uint32_t RCC_AHB2ENR_RST         = 0x00000000U;   /** @brief AHB2ENR register reset value. */
    static const uint32_t RCC_AHB4ENR_RST         = 0x00000000U;   /** @brief AHB4ENR register reset value. */
    static const uint32_t RCC_C1_AHB4ENR_RST      = 0x00000000U;   /** @brief C1_AHB4ENR register reset value. */
    static const uint32_t RCC_C1_APB3ENR_RST      = 0x00000000U;   /** @brief C1_APB3ENR register reset value. */
    static const uint32_t RCC_APB3ENR_RST         = 0x00000000U;   /** @brief APB3ENR register reset value. */
    static const uint32_t RCC_APB1LENR_RST        = 0x00000000U;   /** @brief APB1LENR register reset value. */
    static const uint32_t RCC_C1_APB1LENR_RST     = 0x00000000U;   /** @brief C1_APB1LENR register reset value. */
    static const uint32_t RCC_APB1HENR_RST        = 0x00000000U;   /** @brief APB1HENR register reset value. */
    static const uint32_t RCC_C1_APB1HENR_RST     = 0x00000000U;   /** @brief C1_APB1HENR register reset value. */
    static const uint32_t RCC_C1_APB2ENR_RST      = 0x00000000U;   /** @brief C1_APB2ENR register reset value. */
    static const uint32_t RCC_APB2ENR_RST         = 0x00000000U;   /** @brief APB2ENR register reset value. */
    static const uint32_t RCC_APB4ENR_RST         = 0x00000000U;   /** @brief APB4ENR register reset value. */
    static const uint32_t RCC_C1_APB4ENR_RST      = 0x00000000U;   /** @brief C1_APB4ENR register reset value. */
    static const uint32_t RCC_C1_AHB3LPENR_RST    = 0x00000000U;   /** @brief C1_AHB3LPENR register reset value. */
    static const uint32_t RCC_AHB3LPENR_RST       = 0x00000000U;   /** @brief AHB3LPENR register reset value. */
    static const uint32_t RCC_AHB1LPENR_RST       = 0x00000000U;   /** @brief AHB1LPENR register reset value. */
    static const uint32_t RCC_C1_AHB1LPENR_RST    = 0x00000000U;   /** @brief C1_AHB1LPENR register reset value. */
    static const uint32_t RCC_C1_AHB2LPENR_RST    = 0x00000000U;   /** @brief C1_AHB2LPENR register reset value. */
    static const uint32_t RCC_AHB2LPENR_RST       = 0x00000000U;   /** @brief AHB2LPENR register reset value. */
    static const uint32_t RCC_AHB4LPENR_RST       = 0x00000000U;   /** @brief AHB4LPENR register reset value. */
    static const uint32_t RCC_C1_AHB4LPENR_RST    = 0x00000000U;   /** @brief C1_AHB4LPENR register reset value. */
    static const uint32_t RCC_C1_APB3LPENR_RST    = 0x00000000U;   /** @brief C1_APB3LPENR register reset value. */
    static const uint32_t RCC_APB3LPENR_RST       = 0x00000000U;   /** @brief APB3LPENR register reset value. */
    static const uint32_t RCC_APB1LLPENR_RST      = 0x00000000U;   /** @brief APB1LLPENR register reset value. */
    static const uint32_t RCC_C1_APB1LLPENR_RST   = 0x00000000U;   /** @brief C1_APB1LLPENR register reset value. */
    static const uint32_t RCC_C1_APB1HLPENR_RST   = 0x00000000U;   /** @brief C1_APB1HLPENR register reset value. */
    static const uint32_t RCC_APB1HLPENR_RST      = 0x00000000U;   /** @brief APB1HLPENR register reset value. */
    static const uint32_t RCC_APB2LPENR_RST       = 0x00000000U;   /** @brief APB2LPENR register reset value. */
    static const uint32_t RCC_C1_APB2LPENR_RST    = 0x00000000U;   /** @brief C1_APB2LPENR register reset value. */
    static const uint32_t RCC_C1_APB4LPENR_RST    = 0x00000000U;   /** @brief C1_APB4LPENR register reset value. */
    static const uint32_t RCC_APB4LPENR_RST       = 0x00000000U;   /** @brief APB4LPENR register reset value. */

    /**** @subsection Enumerated RCC Register Reset Values ****/

    static const uint32_t RCC_PLLxDIVR_RST[4] = {
      [1] = 0x01010280U,   /** @brief PLL1DIVR register reset value. */
      [2] = 0x01010280U,   /** @brief PLL2DIVR register reset value. */
      [3] = 0x01010280U,   /** @brief PLL3DIVR register reset value. */
    };

    static const uint32_t RCC_PLLxFRACR_RST[4] = {
      [1] = 0x00000000U,   /** @brief PLL1FRACR register reset value. */
      [2] = 0x00000000U,   /** @brief PLL2FRACR register reset value. */
      [3] = 0x00000000U,   /** @brief PLL3FRACR register reset value. */
    };

    /**** @subsection Enumerated RCC Register Value Types ****/

    typedef uint32_t RCC_CR_t;              /** @brief CR register value type. */
    typedef uint32_t RCC_ICSCR_t;           /** @brief ICSCR register value type. */
    typedef uint32_t RCC_CRRCR_t;           /** @brief CRRCR register value type. */
    typedef uint32_t RCC_CFGR_t;            /** @brief CFGR register value type. */
    typedef uint32_t RCC_D1CFGR_t;          /** @brief D1CFGR register value type. */
    typedef uint32_t RCC_D2CFGR_t;          /** @brief D2CFGR register value type. */
    typedef uint32_t RCC_D3CFGR_t;          /** @brief D3CFGR register value type. */
    typedef uint32_t RCC_PLLCKSELR_t;       /** @brief PLLCKSELR register value type. */
    typedef uint32_t RCC_PLLCFGR_t;         /** @brief PLLCFGR register value type. */
    typedef uint32_t RCC_PLLxDIVR_t;        /** @brief PLLxDIVR register value type. */
    typedef uint32_t RCC_PLLxFRACR_t;       /** @brief PLLxFRACR register value type. */
    typedef uint32_t RCC_D1CCIPR_t;         /** @brief D1CCIPR register value type. */
    typedef uint32_t RCC_D2CCIP1R_t;        /** @brief D2CCIP1R register value type. */
    typedef uint32_t RCC_D2CCIP2R_t;        /** @brief D2CCIP2R register value type. */
    typedef uint32_t RCC_D3CCIPR_t;         /** @brief D3CCIPR register value type. */
    typedef uint32_t RCC_CIER_t;            /** @brief CIER register value type. */
    typedef uint32_t RCC_CIFR_t;            /** @brief CIFR register value type. */
    typedef uint32_t RCC_CICR_t;            /** @brief CICR register value type. */
    typedef uint32_t RCC_BDCR_t;            /** @brief BDCR register value type. */
    typedef uint32_t RCC_CSR_t;             /** @brief CSR register value type. */
    typedef uint32_t RCC_AHB3RSTR_t;        /** @brief AHB3RSTR register value type. */
    typedef uint32_t RCC_AHB1RSTR_t;        /** @brief AHB1RSTR register value type. */
    typedef uint32_t RCC_AHB2RSTR_t;        /** @brief AHB2RSTR register value type. */
    typedef uint32_t RCC_AHB4RSTR_t;        /** @brief AHB4RSTR register value type. */
    typedef uint32_t RCC_APB3RSTR_t;        /** @brief APB3RSTR register value type. */
    typedef uint32_t RCC_APB1LRSTR_t;       /** @brief APB1LRSTR register value type. */
    typedef uint32_t RCC_APB1HRSTR_t;       /** @brief APB1HRSTR register value type. */
    typedef uint32_t RCC_APB2RSTR_t;        /** @brief APB2RSTR register value type. */
    typedef uint32_t RCC_APB4RSTR_t;        /** @brief APB4RSTR register value type. */
    typedef uint32_t RCC_GCR_t;             /** @brief GCR register value type. */
    typedef uint32_t RCC_D3AMR_t;           /** @brief D3AMR register value type. */
    typedef uint32_t RCC_RSR_t;             /** @brief RSR register value type. */
    typedef uint32_t RCC_C1_RSR_t;          /** @brief C1_RSR register value type. */
    typedef uint32_t RCC_C1_AHB3ENR_t;      /** @brief C1_AHB3ENR register value type. */
    typedef uint32_t RCC_AHB3ENR_t;         /** @brief AHB3ENR register value type. */
    typedef uint32_t RCC_AHB1ENR_t;         /** @brief AHB1ENR register value type. */
    typedef uint32_t RCC_C1_AHB1ENR_t;      /** @brief C1_AHB1ENR register value type. */
    typedef uint32_t RCC_C1_AHB2ENR_t;      /** @brief C1_AHB2ENR register value type. */
    typedef uint32_t RCC_AHB2ENR_t;         /** @brief AHB2ENR register value type. */
    typedef uint32_t RCC_AHB4ENR_t;         /** @brief AHB4ENR register value type. */
    typedef uint32_t RCC_C1_AHB4ENR_t;      /** @brief C1_AHB4ENR register value type. */
    typedef uint32_t RCC_C1_APB3ENR_t;      /** @brief C1_APB3ENR register value type. */
    typedef uint32_t RCC_APB3ENR_t;         /** @brief APB3ENR register value type. */
    typedef uint32_t RCC_APB1LENR_t;        /** @brief APB1LENR register value type. */
    typedef uint32_t RCC_C1_APB1LENR_t;     /** @brief C1_APB1LENR register value type. */
    typedef uint32_t RCC_APB1HENR_t;        /** @brief APB1HENR register value type. */
    typedef uint32_t RCC_C1_APB1HENR_t;     /** @brief C1_APB1HENR register value type. */
    typedef uint32_t RCC_C1_APB2ENR_t;      /** @brief C1_APB2ENR register value type. */
    typedef uint32_t RCC_APB2ENR_t;         /** @brief APB2ENR register value type. */
    typedef uint32_t RCC_APB4ENR_t;         /** @brief APB4ENR register value type. */
    typedef uint32_t RCC_C1_APB4ENR_t;      /** @brief C1_APB4ENR register value type. */
    typedef uint32_t RCC_C1_AHB3LPENR_t;    /** @brief C1_AHB3LPENR register value type. */
    typedef uint32_t RCC_AHB3LPENR_t;       /** @brief AHB3LPENR register value type. */
    typedef uint32_t RCC_AHB1LPENR_t;       /** @brief AHB1LPENR register value type. */
    typedef uint32_t RCC_C1_AHB1LPENR_t;    /** @brief C1_AHB1LPENR register value type. */
    typedef uint32_t RCC_C1_AHB2LPENR_t;    /** @brief C1_AHB2LPENR register value type. */
    typedef uint32_t RCC_AHB2LPENR_t;       /** @brief AHB2LPENR register value type. */
    typedef uint32_t RCC_AHB4LPENR_t;       /** @brief AHB4LPENR register value type. */
    typedef uint32_t RCC_C1_AHB4LPENR_t;    /** @brief C1_AHB4LPENR register value type. */
    typedef uint32_t RCC_C1_APB3LPENR_t;    /** @brief C1_APB3LPENR register value type. */
    typedef uint32_t RCC_APB3LPENR_t;       /** @brief APB3LPENR register value type. */
    typedef uint32_t RCC_APB1LLPENR_t;      /** @brief APB1LLPENR register value type. */
    typedef uint32_t RCC_C1_APB1LLPENR_t;   /** @brief C1_APB1LLPENR register value type. */
    typedef uint32_t RCC_C1_APB1HLPENR_t;   /** @brief C1_APB1HLPENR register value type. */
    typedef uint32_t RCC_APB1HLPENR_t;      /** @brief APB1HLPENR register value type. */
    typedef uint32_t RCC_APB2LPENR_t;       /** @brief APB2LPENR register value type. */
    typedef uint32_t RCC_C1_APB2LPENR_t;    /** @brief C1_APB2LPENR register value type. */
    typedef uint32_t RCC_C1_APB4LPENR_t;    /** @brief C1_APB4LPENR register value type. */
    typedef uint32_t RCC_APB4LPENR_t;       /** @brief APB4LPENR register value type. */

    /**** @subsection Enumerated RCC Register Pointer Types ****/

    typedef uint32_t* const RCC_CR_PTR_t;              /** @brief CR register pointer type. */
    typedef uint32_t* const RCC_ICSCR_PTR_t;           /** @brief ICSCR register pointer type. */
    typedef uint32_t* const RCC_CRRCR_PTR_t;           /** @brief CRRCR register pointer type. */
    typedef uint32_t* const RCC_CFGR_PTR_t;            /** @brief CFGR register pointer type. */
    typedef uint32_t* const RCC_D1CFGR_PTR_t;          /** @brief D1CFGR register pointer type. */
    typedef uint32_t* const RCC_D2CFGR_PTR_t;          /** @brief D2CFGR register pointer type. */
    typedef uint32_t* const RCC_D3CFGR_PTR_t;          /** @brief D3CFGR register pointer type. */
    typedef uint32_t* const RCC_PLLCKSELR_PTR_t;       /** @brief PLLCKSELR register pointer type. */
    typedef uint32_t* const RCC_PLLCFGR_PTR_t;         /** @brief PLLCFGR register pointer type. */
    typedef uint32_t* const RCC_PLLxDIVR_PTR_t;        /** @brief PLLxDIVR register pointer type. */
    typedef uint32_t* const RCC_PLLxFRACR_PTR_t;       /** @brief PLLxFRACR register pointer type. */
    typedef uint32_t* const RCC_D1CCIPR_PTR_t;         /** @brief D1CCIPR register pointer type. */
    typedef uint32_t* const RCC_D2CCIP1R_PTR_t;        /** @brief D2CCIP1R register pointer type. */
    typedef uint32_t* const RCC_D2CCIP2R_PTR_t;        /** @brief D2CCIP2R register pointer type. */
    typedef uint32_t* const RCC_D3CCIPR_PTR_t;         /** @brief D3CCIPR register pointer type. */
    typedef uint32_t* const RCC_CIER_PTR_t;            /** @brief CIER register pointer type. */
    typedef uint32_t* const RCC_CIFR_PTR_t;            /** @brief CIFR register pointer type. */
    typedef uint32_t* const RCC_CICR_PTR_t;            /** @brief CICR register pointer type. */
    typedef uint32_t* const RCC_BDCR_PTR_t;            /** @brief BDCR register pointer type. */
    typedef uint32_t* const RCC_CSR_PTR_t;             /** @brief CSR register pointer type. */
    typedef uint32_t* const RCC_AHB3RSTR_PTR_t;        /** @brief AHB3RSTR register pointer type. */
    typedef uint32_t* const RCC_AHB1RSTR_PTR_t;        /** @brief AHB1RSTR register pointer type. */
    typedef uint32_t* const RCC_AHB2RSTR_PTR_t;        /** @brief AHB2RSTR register pointer type. */
    typedef uint32_t* const RCC_AHB4RSTR_PTR_t;        /** @brief AHB4RSTR register pointer type. */
    typedef uint32_t* const RCC_APB3RSTR_PTR_t;        /** @brief APB3RSTR register pointer type. */
    typedef uint32_t* const RCC_APB1LRSTR_PTR_t;       /** @brief APB1LRSTR register pointer type. */
    typedef uint32_t* const RCC_APB1HRSTR_PTR_t;       /** @brief APB1HRSTR register pointer type. */
    typedef uint32_t* const RCC_APB2RSTR_PTR_t;        /** @brief APB2RSTR register pointer type. */
    typedef uint32_t* const RCC_APB4RSTR_PTR_t;        /** @brief APB4RSTR register pointer type. */
    typedef uint32_t* const RCC_GCR_PTR_t;             /** @brief GCR register pointer type. */
    typedef uint32_t* const RCC_D3AMR_PTR_t;           /** @brief D3AMR register pointer type. */
    typedef uint32_t* const RCC_RSR_PTR_t;             /** @brief RSR register pointer type. */
    typedef uint32_t* const RCC_C1_RSR_PTR_t;          /** @brief C1_RSR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB3ENR_PTR_t;      /** @brief C1_AHB3ENR register pointer type. */
    typedef uint32_t* const RCC_AHB3ENR_PTR_t;         /** @brief AHB3ENR register pointer type. */
    typedef uint32_t* const RCC_AHB1ENR_PTR_t;         /** @brief AHB1ENR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB1ENR_PTR_t;      /** @brief C1_AHB1ENR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB2ENR_PTR_t;      /** @brief C1_AHB2ENR register pointer type. */
    typedef uint32_t* const RCC_AHB2ENR_PTR_t;         /** @brief AHB2ENR register pointer type. */
    typedef uint32_t* const RCC_AHB4ENR_PTR_t;         /** @brief AHB4ENR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB4ENR_PTR_t;      /** @brief C1_AHB4ENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB3ENR_PTR_t;      /** @brief C1_APB3ENR register pointer type. */
    typedef uint32_t* const RCC_APB3ENR_PTR_t;         /** @brief APB3ENR register pointer type. */
    typedef uint32_t* const RCC_APB1LENR_PTR_t;        /** @brief APB1LENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB1LENR_PTR_t;     /** @brief C1_APB1LENR register pointer type. */
    typedef uint32_t* const RCC_APB1HENR_PTR_t;        /** @brief APB1HENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB1HENR_PTR_t;     /** @brief C1_APB1HENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB2ENR_PTR_t;      /** @brief C1_APB2ENR register pointer type. */
    typedef uint32_t* const RCC_APB2ENR_PTR_t;         /** @brief APB2ENR register pointer type. */
    typedef uint32_t* const RCC_APB4ENR_PTR_t;         /** @brief APB4ENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB4ENR_PTR_t;      /** @brief C1_APB4ENR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB3LPENR_PTR_t;    /** @brief C1_AHB3LPENR register pointer type. */
    typedef uint32_t* const RCC_AHB3LPENR_PTR_t;       /** @brief AHB3LPENR register pointer type. */
    typedef uint32_t* const RCC_AHB1LPENR_PTR_t;       /** @brief AHB1LPENR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB1LPENR_PTR_t;    /** @brief C1_AHB1LPENR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB2LPENR_PTR_t;    /** @brief C1_AHB2LPENR register pointer type. */
    typedef uint32_t* const RCC_AHB2LPENR_PTR_t;       /** @brief AHB2LPENR register pointer type. */
    typedef uint32_t* const RCC_AHB4LPENR_PTR_t;       /** @brief AHB4LPENR register pointer type. */
    typedef uint32_t* const RCC_C1_AHB4LPENR_PTR_t;    /** @brief C1_AHB4LPENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB3LPENR_PTR_t;    /** @brief C1_APB3LPENR register pointer type. */
    typedef uint32_t* const RCC_APB3LPENR_PTR_t;       /** @brief APB3LPENR register pointer type. */
    typedef uint32_t* const RCC_APB1LLPENR_PTR_t;      /** @brief APB1LLPENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB1LLPENR_PTR_t;   /** @brief C1_APB1LLPENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB1HLPENR_PTR_t;   /** @brief C1_APB1HLPENR register pointer type. */
    typedef uint32_t* const RCC_APB1HLPENR_PTR_t;      /** @brief APB1HLPENR register pointer type. */
    typedef uint32_t* const RCC_APB2LPENR_PTR_t;       /** @brief APB2LPENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB2LPENR_PTR_t;    /** @brief C1_APB2LPENR register pointer type. */
    typedef uint32_t* const RCC_C1_APB4LPENR_PTR_t;    /** @brief C1_APB4LPENR register pointer type. */
    typedef uint32_t* const RCC_APB4LPENR_PTR_t;       /** @brief APB4LPENR register pointer type. */

    /**** @subsection RCC Register Field Masks ****/

    static const uint32_t RCC_CR_HSION_MASK                         = 0x00000001U;   /** @brief Internal high-speed clock enable */
    static const uint32_t RCC_CR_HSIKERON_MASK                      = 0x00000002U;   /** @brief High speed internal clock enable in stop mode */
    static const uint32_t RCC_CR_HSIRDY_MASK                        = 0x00000004U;   /** @brief HSI clock ready flag */
    static const uint32_t RCC_CR_HSIDIV_MASK                        = 0x00000018U;   /** @brief HSI clock divider */
    static const uint32_t RCC_CR_HSIDIVF_MASK                       = 0x00000020U;   /** @brief HSI divider flag */
    static const uint32_t RCC_CR_CSION_MASK                         = 0x00000080U;   /** @brief CSI clock enable */
    static const uint32_t RCC_CR_CSIRDY_MASK                        = 0x00000100U;   /** @brief CSI clock ready flag */
    static const uint32_t RCC_CR_CSIKERON_MASK                      = 0x00000200U;   /** @brief CSI clock enable in stop mode */
    static const uint32_t RCC_CR_RC48ON_MASK                        = 0x00001000U;   /** @brief RC48 clock enable */
    static const uint32_t RCC_CR_RC48RDY_MASK                       = 0x00002000U;   /** @brief RC48 clock ready flag */
    static const uint32_t RCC_CR_HSEON_MASK                         = 0x00010000U;   /** @brief HSE clock enable */
    static const uint32_t RCC_CR_HSERDY_MASK                        = 0x00020000U;   /** @brief HSE clock ready flag */
    static const uint32_t RCC_CR_HSEBYP_MASK                        = 0x00040000U;   /** @brief HSE clock bypass */
    static const uint32_t RCC_CR_HSECSSON_MASK                      = 0x00080000U;   /** @brief HSE clock security system enable */
    static const uint32_t RCC_ICSCR_HSICAL_MASK                     = 0x00000FFFU;   /** @brief HSI clock calibration */
    static const uint32_t RCC_ICSCR_HSITRIM_MASK                    = 0x0003F000U;   /** @brief HSI clock trimming */
    static const uint32_t RCC_ICSCR_CSICAL_MASK                     = 0x03FC0000U;   /** @brief CSI clock calibration */
    static const uint32_t RCC_ICSCR_CSITRIM_MASK                    = 0x7C000000U;   /** @brief CSI clock trimming */
    static const uint32_t RCC_CRRCR_RC48CAL_MASK                    = 0x000003FFU;   /** @brief Internal RC 48 mhz clock calibration */
    static const uint32_t RCC_CFGR_SW_MASK                          = 0x00000007U;   /** @brief System clock switch */
    static const uint32_t RCC_CFGR_SWS_MASK                         = 0x00000038U;   /** @brief System clock switch status */
    static const uint32_t RCC_CFGR_STOPWUCK_MASK                    = 0x00000040U;   /** @brief System clock selection after a wake up from system stop */
    static const uint32_t RCC_CFGR_STOPKERWUCK_MASK                 = 0x00000080U;   /** @brief Kernel clock selection after a wake up from system stop */
    static const uint32_t RCC_CFGR_RTCPRE_MASK                      = 0x00003F00U;   /** @brief HSE division factor for RTC clock */
    static const uint32_t RCC_CFGR_HRTIMSEL_MASK                    = 0x00004000U;   /** @brief High resolution timer clock prescaler selection */
    static const uint32_t RCC_CFGR_TIMPRE_MASK                      = 0x00008000U;   /** @brief Timers clocks prescaler selection */
    static const uint32_t RCC_D1CFGR_HPRE_MASK                      = 0x0000000FU;   /** @brief D1 domain AHB prescaler */
    static const uint32_t RCC_D1CFGR_D1PPRE_MASK                    = 0x00000070U;   /** @brief D1 domain APB3 prescaler */
    static const uint32_t RCC_D1CFGR_D1CPRE_MASK                    = 0x00000F00U;   /** @brief D1 domain core prescaler */
    static const uint32_t RCC_D3CFGR_D3PPRE_MASK                    = 0x00000070U;   /** @brief D3 domain APB4 prescaler */
    static const uint32_t RCC_PLLCKSELR_PLLSRC_MASK                 = 0x00000003U;   /** @brief DIVMx and plls clock source selection */
    static const uint32_t RCC_PLLxDIVR_DIVN1_MASK                   = 0x000001FFU;   /** @brief Multiplication factor for PLL1 VCO */
    static const uint32_t RCC_PLLxDIVR_DIVP1_MASK                   = 0x0000FE00U;   /** @brief PLL1 DIVP division factor */
    static const uint32_t RCC_PLLxDIVR_DIVQ1_MASK                   = 0x007F0000U;   /** @brief PLL1 DIVQ division factor */
    static const uint32_t RCC_PLLxDIVR_DIVR1_MASK                   = 0x7F000000U;   /** @brief PLL1 DIVR division factor */
    static const uint32_t RCC_PLLxFRACR_FRACN1_MASK                 = 0x0000FFF8U;   /** @brief Fractional part of the multiplication factor for PLL1 VCO */
    static const uint32_t RCC_D1CCIPR_FMCSRC_MASK                   = 0x00000003U;   /** @brief FMC kernel clock source selection */
    static const uint32_t RCC_D1CCIPR_QSPISRC_MASK                  = 0x00000030U;   /** @brief QUADSPI kernel clock source selection */
    static const uint32_t RCC_D1CCIPR_SDMMCSRC_MASK                 = 0x00010000U;   /** @brief SDMMC kernel clock source selection */
    static const uint32_t RCC_D1CCIPR_CKPERSRC_MASK                 = 0x30000000U;   /** @brief Per_ck clock source selection */
    static const uint32_t RCC_D2CCIP1R_SAI1SRC_MASK                 = 0x00000007U;   /** @brief SAI1 and DFSDM1 kernel aclk clock source selection */
    static const uint32_t RCC_D2CCIP1R_SAI23SRC_MASK                = 0x000001C0U;   /** @brief SAI2 and SAI3 kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SPI123SRC_MASK               = 0x00007000U;   /** @brief SPI/I2S1,2 and 3 kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SPI45SRC_MASK                = 0x00070000U;   /** @brief SPI4 and 5 kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SPDIFSRC_MASK                = 0x00300000U;   /** @brief SPDIFRX kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_DFSDM1SRC_MASK               = 0x01000000U;   /** @brief DFSDM1 kernel clk clock source selection */
    static const uint32_t RCC_D2CCIP1R_FDCANSRC_MASK                = 0x30000000U;   /** @brief FDCAN kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SWPSRC_MASK                  = 0x80000000U;   /** @brief SWPMI kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_USART234578SRC_MASK          = 0x00000007U;   /** @brief USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_USART16SRC_MASK              = 0x00000038U;   /** @brief USART1 and 6 kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_RNGSRC_MASK                  = 0x00000300U;   /** @brief RNG kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_I2C123SRC_MASK               = 0x00003000U;   /** @brief I2C1,2,3 kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_USBSRC_MASK                  = 0x00300000U;   /** @brief USBOTG 1 and 2 kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_CECSRC_MASK                  = 0x00C00000U;   /** @brief HDMI-CEC kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_LPTIM1SRC_MASK               = 0x70000000U;   /** @brief LPTIM1 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_LPUART1SRC_MASK               = 0x00000007U;   /** @brief LPUART1 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_I2C4SRC_MASK                  = 0x00000300U;   /** @brief I2C4 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_LPTIM2SRC_MASK                = 0x00001C00U;   /** @brief LPTIM2 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_LPTIM345SRC_MASK              = 0x0000E000U;   /** @brief LPTIM3,4,5 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_ADCSRC_MASK                   = 0x00030000U;   /** @brief SAR ADC kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_SAI4ASRC_MASK                 = 0x00E00000U;   /** @brief Sub-Block A of SAI4 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_SAI4BSRC_MASK                 = 0x07000000U;   /** @brief Sub-Block B of SAI4 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_SPI6SRC_MASK                  = 0x70000000U;   /** @brief SPI6 kernel clock source selection */
    static const uint32_t RCC_CIER_LSIRDYIE_MASK                    = 0x00000001U;   /** @brief LSI ready interrupt enable */
    static const uint32_t RCC_CIER_LSERDYIE_MASK                    = 0x00000002U;   /** @brief LSE ready interrupt enable */
    static const uint32_t RCC_CIER_HSIRDYIE_MASK                    = 0x00000004U;   /** @brief HSI ready interrupt enable */
    static const uint32_t RCC_CIER_HSERDYIE_MASK                    = 0x00000008U;   /** @brief HSE ready interrupt enable */
    static const uint32_t RCC_CIER_CSIRDYIE_MASK                    = 0x00000010U;   /** @brief CSI ready interrupt enable */
    static const uint32_t RCC_CIER_RC48RDYIE_MASK                   = 0x00000020U;   /** @brief RC48 ready interrupt enable */
    static const uint32_t RCC_CIER_LSECSSIE_MASK                    = 0x00000200U;   /** @brief LSE clock security system interrupt enable */
    static const uint32_t RCC_CIFR_LSIRDYF_MASK                     = 0x00000001U;   /** @brief LSI ready interrupt flag */
    static const uint32_t RCC_CIFR_LSERDYF_MASK                     = 0x00000002U;   /** @brief LSE ready interrupt flag */
    static const uint32_t RCC_CIFR_HSIRDYF_MASK                     = 0x00000004U;   /** @brief HSI ready interrupt flag */
    static const uint32_t RCC_CIFR_HSERDYF_MASK                     = 0x00000008U;   /** @brief HSE ready interrupt flag */
    static const uint32_t RCC_CIFR_CSIRDY_MASK                      = 0x00000010U;   /** @brief CSI ready interrupt flag */
    static const uint32_t RCC_CIFR_RC48RDYF_MASK                    = 0x00000020U;   /** @brief RC48 ready interrupt flag */
    static const uint32_t RCC_CIFR_LSECSSF_MASK                     = 0x00000200U;   /** @brief LSE clock security system interrupt flag */
    static const uint32_t RCC_CIFR_HSECSSF_MASK                     = 0x00000400U;   /** @brief HSE clock security system interrupt flag */
    static const uint32_t RCC_CICR_LSIRDYC_MASK                     = 0x00000001U;   /** @brief LSI ready interrupt clear */
    static const uint32_t RCC_CICR_LSERDYC_MASK                     = 0x00000002U;   /** @brief LSE ready interrupt clear */
    static const uint32_t RCC_CICR_HSIRDYC_MASK                     = 0x00000004U;   /** @brief HSI ready interrupt clear */
    static const uint32_t RCC_CICR_HSERDYC_MASK                     = 0x00000008U;   /** @brief HSE ready interrupt clear */
    static const uint32_t RCC_CICR_HSE_READY_INTERRUPT_CLEAR_MASK   = 0x00000010U;   /** @brief CSI ready interrupt clear */
    static const uint32_t RCC_CICR_RC48RDYC_MASK                    = 0x00000020U;   /** @brief RC48 ready interrupt clear */
    static const uint32_t RCC_CICR_LSECSSC_MASK                     = 0x00000200U;   /** @brief LSE clock security system interrupt clear */
    static const uint32_t RCC_CICR_HSECSSC_MASK                     = 0x00000400U;   /** @brief HSE clock security system interrupt clear */
    static const uint32_t RCC_BDCR_LSEON_MASK                       = 0x00000001U;   /** @brief LSE oscillator enabled */
    static const uint32_t RCC_BDCR_LSERDY_MASK                      = 0x00000002U;   /** @brief LSE oscillator ready */
    static const uint32_t RCC_BDCR_LSEBYP_MASK                      = 0x00000004U;   /** @brief LSE oscillator bypass */
    static const uint32_t RCC_BDCR_LSEDRV_MASK                      = 0x00000018U;   /** @brief LSE oscillator driving capability */
    static const uint32_t RCC_BDCR_LSECSSON_MASK                    = 0x00000020U;   /** @brief LSE clock security system enable */
    static const uint32_t RCC_BDCR_LSECSSD_MASK                     = 0x00000040U;   /** @brief LSE clock security system failure detection */
    static const uint32_t RCC_BDCR_RTCSRC_MASK                      = 0x00000300U;   /** @brief RTC clock source selection */
    static const uint32_t RCC_BDCR_RTCEN_MASK                       = 0x00008000U;   /** @brief RTC clock enable */
    static const uint32_t RCC_BDCR_VSWRST_MASK                      = 0x00010000U;   /** @brief VSwitch domain software reset */
    static const uint32_t RCC_CSR_LSION_MASK                        = 0x00000001U;   /** @brief LSI oscillator enable */
    static const uint32_t RCC_CSR_LSIRDY_MASK                       = 0x00000002U;   /** @brief LSI oscillator ready */
    static const uint32_t RCC_AHB3RSTR_MDMARST_MASK                 = 0x00000001U;   /** @brief MDMA block reset */
    static const uint32_t RCC_AHB3RSTR_DMA2DRST_MASK                = 0x00000010U;   /** @brief DMA2D block reset */
    static const uint32_t RCC_AHB3RSTR_JPGDECRST_MASK               = 0x00000020U;   /** @brief JPGDEC block reset */
    static const uint32_t RCC_AHB3RSTR_FMCRST_MASK                  = 0x00001000U;   /** @brief FMC block reset */
    static const uint32_t RCC_AHB3RSTR_QSPIRST_MASK                 = 0x00004000U;   /** @brief QUADSPI and QUADSPI delay block reset */
    static const uint32_t RCC_AHB3RSTR_SDMMC1RST_MASK               = 0x00010000U;   /** @brief SDMMC1 and SDMMC1 delay block reset */
    static const uint32_t RCC_AHB3RSTR_CPURST_MASK                  = 0x80000000U;   /** @brief CPU reset */
    static const uint32_t RCC_AHB1RSTR_ADC12RST_MASK                = 0x00000020U;   /** @brief ADC1&2 block reset */
    static const uint32_t RCC_AHB1RSTR_ETH1MACRST_MASK              = 0x00008000U;   /** @brief ETH1MAC block reset */
    static const uint32_t RCC_AHB2RSTR_CAMITFRST_MASK               = 0x00000001U;   /** @brief CAMITF block reset */
    static const uint32_t RCC_AHB2RSTR_CRYPTRST_MASK                = 0x00000010U;   /** @brief Cryptography block reset */
    static const uint32_t RCC_AHB2RSTR_HASHRST_MASK                 = 0x00000020U;   /** @brief Hash block reset */
    static const uint32_t RCC_AHB2RSTR_RNGRST_MASK                  = 0x00000040U;   /** @brief Random number generator block reset */
    static const uint32_t RCC_AHB2RSTR_SDMMC2RST_MASK               = 0x00000200U;   /** @brief SDMMC2 and SDMMC2 delay block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOARST_MASK                = 0x00000001U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOBRST_MASK                = 0x00000002U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOCRST_MASK                = 0x00000004U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIODRST_MASK                = 0x00000008U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOERST_MASK                = 0x00000010U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOFRST_MASK                = 0x00000020U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOGRST_MASK                = 0x00000040U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOHRST_MASK                = 0x00000080U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOIRST_MASK                = 0x00000100U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOJRST_MASK                = 0x00000200U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOKRST_MASK                = 0x00000400U;   /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_CRCRST_MASK                  = 0x00080000U;   /** @brief CRC block reset */
    static const uint32_t RCC_AHB4RSTR_BDMARST_MASK                 = 0x00200000U;   /** @brief BDMA block reset */
    static const uint32_t RCC_AHB4RSTR_ADC3RST_MASK                 = 0x01000000U;   /** @brief ADC3 block reset */
    static const uint32_t RCC_AHB4RSTR_HSEMRST_MASK                 = 0x02000000U;   /** @brief HSEM block reset */
    static const uint32_t RCC_APB3RSTR_LTDCRST_MASK                 = 0x00000008U;   /** @brief LTDC block reset */
    static const uint32_t RCC_APB1LRSTR_LPTIM1RST_MASK              = 0x00000200U;   /** @brief TIM block reset */
    static const uint32_t RCC_APB1LRSTR_SPDIFRXRST_MASK             = 0x00010000U;   /** @brief SPDIFRX block reset */
    static const uint32_t RCC_APB1LRSTR_HDMICECRST_MASK             = 0x08000000U;   /** @brief HDMI-CEC block reset */
    static const uint32_t RCC_APB1LRSTR_DAC12RST_MASK               = 0x20000000U;   /** @brief DAC1 and 2 blocks reset */
    static const uint32_t RCC_APB1HRSTR_CRSRST_MASK                 = 0x00000002U;   /** @brief Clock recovery system reset */
    static const uint32_t RCC_APB1HRSTR_SWPRST_MASK                 = 0x00000004U;   /** @brief SWPMI block reset */
    static const uint32_t RCC_APB1HRSTR_OPAMPRST_MASK               = 0x00000010U;   /** @brief OPAMP block reset */
    static const uint32_t RCC_APB1HRSTR_MDIOSRST_MASK               = 0x00000020U;   /** @brief MDIOS block reset */
    static const uint32_t RCC_APB1HRSTR_FDCANRST_MASK               = 0x00000100U;   /** @brief FDCAN block reset */
    static const uint32_t RCC_APB2RSTR_DFSDM1RST_MASK               = 0x10000000U;   /** @brief DFSDM1 block reset */
    static const uint32_t RCC_APB2RSTR_HRTIMRST_MASK                = 0x20000000U;   /** @brief HRTIM block reset */
    static const uint32_t RCC_APB4RSTR_SYSCFGRST_MASK               = 0x00000002U;   /** @brief SYSCFG block reset */
    static const uint32_t RCC_APB4RSTR_LPUART1RST_MASK              = 0x00000008U;   /** @brief LPUART1 block reset */
    static const uint32_t RCC_APB4RSTR_SPI6RST_MASK                 = 0x00000020U;   /** @brief SPI6 block reset */
    static const uint32_t RCC_APB4RSTR_I2C4RST_MASK                 = 0x00000080U;   /** @brief I2C4 block reset */
    static const uint32_t RCC_APB4RSTR_COMP12RST_MASK               = 0x00004000U;   /** @brief COMP12 blocks reset */
    static const uint32_t RCC_APB4RSTR_VREFRST_MASK                 = 0x00008000U;   /** @brief VREF block reset */
    static const uint32_t RCC_APB4RSTR_SAI4RST_MASK                 = 0x00200000U;   /** @brief SAI4 block reset */
    static const uint32_t RCC_GCR_WW1RSC_MASK                       = 0x00000001U;   /** @brief WWDG1 reset scope control */
    static const uint32_t RCC_D3AMR_BDMAAMEN_MASK                   = 0x00000001U;   /** @brief BDMA and DMAMUX autonomous mode enable */
    static const uint32_t RCC_D3AMR_LPUART1AMEN_MASK                = 0x00000008U;   /** @brief LPUART1 autonomous mode enable */
    static const uint32_t RCC_D3AMR_SPI6AMEN_MASK                   = 0x00000020U;   /** @brief SPI6 autonomous mode enable */
    static const uint32_t RCC_D3AMR_I2C4AMEN_MASK                   = 0x00000080U;   /** @brief I2C4 autonomous mode enable */
    static const uint32_t RCC_D3AMR_COMP12AMEN_MASK                 = 0x00004000U;   /** @brief COMP12 autonomous mode enable */
    static const uint32_t RCC_D3AMR_VREFAMEN_MASK                   = 0x00008000U;   /** @brief VREF autonomous mode enable */
    static const uint32_t RCC_D3AMR_RTCAMEN_MASK                    = 0x00010000U;   /** @brief RTC autonomous mode enable */
    static const uint32_t RCC_D3AMR_CRCAMEN_MASK                    = 0x00080000U;   /** @brief CRC autonomous mode enable */
    static const uint32_t RCC_D3AMR_SAI4AMEN_MASK                   = 0x00200000U;   /** @brief SAI4 autonomous mode enable */
    static const uint32_t RCC_D3AMR_ADC3AMEN_MASK                   = 0x01000000U;   /** @brief ADC3 autonomous mode enable */
    static const uint32_t RCC_D3AMR_BKPSRAMAMEN_MASK                = 0x10000000U;   /** @brief Backup RAM autonomous mode enable */
    static const uint32_t RCC_D3AMR_SRAM4AMEN_MASK                  = 0x20000000U;   /** @brief SRAM4 autonomous mode enable */
    static const uint32_t RCC_RSR_RMVF_MASK                         = 0x00010000U;   /** @brief Remove reset flag */
    static const uint32_t RCC_RSR_CPURSTF_MASK                      = 0x00020000U;   /** @brief CPU reset flag */
    static const uint32_t RCC_RSR_BORRSTF_MASK                      = 0x00200000U;   /** @brief BOR reset flag */
    static const uint32_t RCC_RSR_PINRSTF_MASK                      = 0x00400000U;   /** @brief Pin reset flag (NRST) */
    static const uint32_t RCC_RSR_PORRSTF_MASK                      = 0x00800000U;   /** @brief POR/PDR reset flag */
    static const uint32_t RCC_RSR_SFTRSTF_MASK                      = 0x01000000U;   /** @brief System reset from CPU reset flag */
    static const uint32_t RCC_RSR_IWDG1RSTF_MASK                    = 0x04000000U;   /** @brief Independent watchdog reset flag */
    static const uint32_t RCC_RSR_WWDG1RSTF_MASK                    = 0x10000000U;   /** @brief Window watchdog reset flag */
    static const uint32_t RCC_RSR_LPWRRSTF_MASK                     = 0x40000000U;   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const uint32_t RCC_C1_RSR_RMVF_MASK                      = 0x00010000U;   /** @brief Remove reset flag */
    static const uint32_t RCC_C1_RSR_CPURSTF_MASK                   = 0x00020000U;   /** @brief CPU reset flag */
    static const uint32_t RCC_C1_RSR_BORRSTF_MASK                   = 0x00200000U;   /** @brief BOR reset flag */
    static const uint32_t RCC_C1_RSR_PINRSTF_MASK                   = 0x00400000U;   /** @brief Pin reset flag (NRST) */
    static const uint32_t RCC_C1_RSR_PORRSTF_MASK                   = 0x00800000U;   /** @brief POR/PDR reset flag */
    static const uint32_t RCC_C1_RSR_SFTRSTF_MASK                   = 0x01000000U;   /** @brief System reset from CPU reset flag */
    static const uint32_t RCC_C1_RSR_IWDG1RSTF_MASK                 = 0x04000000U;   /** @brief Independent watchdog reset flag */
    static const uint32_t RCC_C1_RSR_WWDG1RSTF_MASK                 = 0x10000000U;   /** @brief Window watchdog reset flag */
    static const uint32_t RCC_C1_RSR_LPWRRSTF_MASK                  = 0x40000000U;   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const uint32_t RCC_C1_AHB3ENR_MDMAEN_MASK                = 0x00000001U;   /** @brief MDMA peripheral clock enable */
    static const uint32_t RCC_C1_AHB3ENR_DMA2DEN_MASK               = 0x00000010U;   /** @brief DMA2D peripheral clock enable */
    static const uint32_t RCC_C1_AHB3ENR_JPGDECEN_MASK              = 0x00000020U;   /** @brief JPGDEC peripheral clock enable */
    static const uint32_t RCC_C1_AHB3ENR_FMCEN_MASK                 = 0x00001000U;   /** @brief FMC peripheral clocks enable */
    static const uint32_t RCC_C1_AHB3ENR_QSPIEN_MASK                = 0x00004000U;   /** @brief QUADSPI and QUADSPI delay clock enable */
    static const uint32_t RCC_C1_AHB3ENR_SDMMC1EN_MASK              = 0x00010000U;   /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const uint32_t RCC_AHB3ENR_MDMAEN_MASK                   = 0x00000001U;   /** @brief MDMA peripheral clock enable */
    static const uint32_t RCC_AHB3ENR_DMA2DEN_MASK                  = 0x00000010U;   /** @brief DMA2D peripheral clock enable */
    static const uint32_t RCC_AHB3ENR_JPGDECEN_MASK                 = 0x00000020U;   /** @brief JPGDEC peripheral clock enable */
    static const uint32_t RCC_AHB3ENR_FMCEN_MASK                    = 0x00001000U;   /** @brief FMC peripheral clocks enable */
    static const uint32_t RCC_AHB3ENR_QSPIEN_MASK                   = 0x00004000U;   /** @brief QUADSPI and QUADSPI delay clock enable */
    static const uint32_t RCC_AHB3ENR_SDMMC1EN_MASK                 = 0x00010000U;   /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const uint32_t RCC_AHB1ENR_ADC12EN_MASK                  = 0x00000020U;   /** @brief ADC1/2 peripheral clocks enable */
    static const uint32_t RCC_AHB1ENR_ETH1MACEN_MASK                = 0x00008000U;   /** @brief Ethernet MAC bus interface clock enable */
    static const uint32_t RCC_AHB1ENR_ETH1TXEN_MASK                 = 0x00010000U;   /** @brief Ethernet transmission clock enable */
    static const uint32_t RCC_AHB1ENR_ETH1RXEN_MASK                 = 0x00020000U;   /** @brief Ethernet reception clock enable */
    static const uint32_t RCC_C1_AHB1ENR_ADC12EN_MASK               = 0x00000020U;   /** @brief ADC1/2 peripheral clocks enable */
    static const uint32_t RCC_C1_AHB1ENR_ETH1MACEN_MASK             = 0x00008000U;   /** @brief Ethernet MAC bus interface clock enable */
    static const uint32_t RCC_C1_AHB1ENR_ETH1TXEN_MASK              = 0x00010000U;   /** @brief Ethernet transmission clock enable */
    static const uint32_t RCC_C1_AHB1ENR_ETH1RXEN_MASK              = 0x00020000U;   /** @brief Ethernet reception clock enable */
    static const uint32_t RCC_C1_AHB2ENR_CAMITFEN_MASK              = 0x00000001U;   /** @brief CAMITF peripheral clock enable */
    static const uint32_t RCC_C1_AHB2ENR_CRYPTEN_MASK               = 0x00000010U;   /** @brief CRYPT peripheral clock enable */
    static const uint32_t RCC_C1_AHB2ENR_HASHEN_MASK                = 0x00000020U;   /** @brief HASH peripheral clock enable */
    static const uint32_t RCC_C1_AHB2ENR_RNGEN_MASK                 = 0x00000040U;   /** @brief RNG peripheral clocks enable */
    static const uint32_t RCC_C1_AHB2ENR_SDMMC2EN_MASK              = 0x00000200U;   /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const uint32_t RCC_AHB2ENR_CAMITFEN_MASK                 = 0x00000001U;   /** @brief CAMITF peripheral clock enable */
    static const uint32_t RCC_AHB2ENR_CRYPTEN_MASK                  = 0x00000010U;   /** @brief CRYPT peripheral clock enable */
    static const uint32_t RCC_AHB2ENR_HASHEN_MASK                   = 0x00000020U;   /** @brief HASH peripheral clock enable */
    static const uint32_t RCC_AHB2ENR_RNGEN_MASK                    = 0x00000040U;   /** @brief RNG peripheral clocks enable */
    static const uint32_t RCC_AHB2ENR_SDMMC2EN_MASK                 = 0x00000200U;   /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOAEN_MASK                  = 0x00000001U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOBEN_MASK                  = 0x00000002U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOCEN_MASK                  = 0x00000004U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIODEN_MASK                  = 0x00000008U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOEEN_MASK                  = 0x00000010U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOFEN_MASK                  = 0x00000020U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOGEN_MASK                  = 0x00000040U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOHEN_MASK                  = 0x00000080U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOIEN_MASK                  = 0x00000100U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOJEN_MASK                  = 0x00000200U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOKEN_MASK                  = 0x00000400U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_CRCEN_MASK                    = 0x00080000U;   /** @brief CRC peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_BDMAEN_MASK                   = 0x00200000U;   /** @brief BDMA and DMAMUX2 clock enable */
    static const uint32_t RCC_AHB4ENR_ADC3EN_MASK                   = 0x01000000U;   /** @brief ADC3 peripheral clocks enable */
    static const uint32_t RCC_AHB4ENR_HSEMEN_MASK                   = 0x02000000U;   /** @brief HSEM peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_BKPRAMEN_MASK                 = 0x10000000U;   /** @brief Backup RAM clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOAEN_MASK               = 0x00000001U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOBEN_MASK               = 0x00000002U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOCEN_MASK               = 0x00000004U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIODEN_MASK               = 0x00000008U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOEEN_MASK               = 0x00000010U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOFEN_MASK               = 0x00000020U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOGEN_MASK               = 0x00000040U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOHEN_MASK               = 0x00000080U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOIEN_MASK               = 0x00000100U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOJEN_MASK               = 0x00000200U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOKEN_MASK               = 0x00000400U;   /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_CRCEN_MASK                 = 0x00080000U;   /** @brief CRC peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_BDMAEN_MASK                = 0x00200000U;   /** @brief BDMA and DMAMUX2 clock enable */
    static const uint32_t RCC_C1_AHB4ENR_ADC3EN_MASK                = 0x01000000U;   /** @brief ADC3 peripheral clocks enable */
    static const uint32_t RCC_C1_AHB4ENR_HSEMEN_MASK                = 0x02000000U;   /** @brief HSEM peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_BKPRAMEN_MASK              = 0x10000000U;   /** @brief Backup RAM clock enable */
    static const uint32_t RCC_C1_APB3ENR_LTDCEN_MASK                = 0x00000008U;   /** @brief LTDC peripheral clock enable */
    static const uint32_t RCC_C1_APB3ENR_WWDG1EN_MASK               = 0x00000040U;   /** @brief WWDG1 clock enable */
    static const uint32_t RCC_APB3ENR_LTDCEN_MASK                   = 0x00000008U;   /** @brief LTDC peripheral clock enable */
    static const uint32_t RCC_APB3ENR_WWDG1EN_MASK                  = 0x00000040U;   /** @brief WWDG1 clock enable */
    static const uint32_t RCC_APB1LENR_LPTIM1EN_MASK                = 0x00000200U;   /** @brief LPTIM1 peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_SPDIFRXEN_MASK               = 0x00010000U;   /** @brief SPDIFRX peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_HDMICECEN_MASK               = 0x08000000U;   /** @brief HDMI-CEC peripheral clock enable */
    static const uint32_t RCC_APB1LENR_DAC12EN_MASK                 = 0x20000000U;   /** @brief DAC1&2 peripheral clock enable */
    static const uint32_t RCC_C1_APB1LENR_LPTIM1EN_MASK             = 0x00000200U;   /** @brief LPTIM1 peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_SPDIFRXEN_MASK            = 0x00010000U;   /** @brief SPDIFRX peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_HDMICECEN_MASK            = 0x08000000U;   /** @brief HDMI-CEC peripheral clock enable */
    static const uint32_t RCC_C1_APB1LENR_DAC12EN_MASK              = 0x20000000U;   /** @brief DAC1&2 peripheral clock enable */
    static const uint32_t RCC_APB1HENR_CRSEN_MASK                   = 0x00000002U;   /** @brief Clock recovery system peripheral clock enable */
    static const uint32_t RCC_APB1HENR_SWPEN_MASK                   = 0x00000004U;   /** @brief SWPMI peripheral clocks enable */
    static const uint32_t RCC_APB1HENR_OPAMPEN_MASK                 = 0x00000010U;   /** @brief OPAMP peripheral clock enable */
    static const uint32_t RCC_APB1HENR_MDIOSEN_MASK                 = 0x00000020U;   /** @brief MDIOS peripheral clock enable */
    static const uint32_t RCC_APB1HENR_FDCANEN_MASK                 = 0x00000100U;   /** @brief FDCAN peripheral clocks enable */
    static const uint32_t RCC_C1_APB1HENR_CRSEN_MASK                = 0x00000002U;   /** @brief Clock recovery system peripheral clock enable */
    static const uint32_t RCC_C1_APB1HENR_SWPEN_MASK                = 0x00000004U;   /** @brief SWPMI peripheral clocks enable */
    static const uint32_t RCC_C1_APB1HENR_OPAMPEN_MASK              = 0x00000010U;   /** @brief OPAMP peripheral clock enable */
    static const uint32_t RCC_C1_APB1HENR_MDIOSEN_MASK              = 0x00000020U;   /** @brief MDIOS peripheral clock enable */
    static const uint32_t RCC_C1_APB1HENR_FDCANEN_MASK              = 0x00000100U;   /** @brief FDCAN peripheral clocks enable */
    static const uint32_t RCC_C1_APB2ENR_DFSDM1EN_MASK              = 0x10000000U;   /** @brief DFSDM1 peripheral clocks enable */
    static const uint32_t RCC_C1_APB2ENR_HRTIMEN_MASK               = 0x20000000U;   /** @brief HRTIM peripheral clock enable */
    static const uint32_t RCC_APB2ENR_DFSDM1EN_MASK                 = 0x10000000U;   /** @brief DFSDM1 peripheral clocks enable */
    static const uint32_t RCC_APB2ENR_HRTIMEN_MASK                  = 0x20000000U;   /** @brief HRTIM peripheral clock enable */
    static const uint32_t RCC_APB4ENR_SYSCFGEN_MASK                 = 0x00000002U;   /** @brief SYSCFG peripheral clock enable */
    static const uint32_t RCC_APB4ENR_LPUART1EN_MASK                = 0x00000008U;   /** @brief LPUART1 peripheral clocks enable */
    static const uint32_t RCC_APB4ENR_SPI6EN_MASK                   = 0x00000020U;   /** @brief SPI6 peripheral clocks enable */
    static const uint32_t RCC_APB4ENR_I2C4EN_MASK                   = 0x00000080U;   /** @brief I2C4 peripheral clocks enable */
    static const uint32_t RCC_APB4ENR_COMP12EN_MASK                 = 0x00004000U;   /** @brief COMP1/2 peripheral clock enable */
    static const uint32_t RCC_APB4ENR_VREFEN_MASK                   = 0x00008000U;   /** @brief VREF peripheral clock enable */
    static const uint32_t RCC_APB4ENR_RTCAPBEN_MASK                 = 0x00010000U;   /** @brief RTC APB clock enable */
    static const uint32_t RCC_APB4ENR_SAI4EN_MASK                   = 0x00200000U;   /** @brief SAI4 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_SYSCFGEN_MASK              = 0x00000002U;   /** @brief SYSCFG peripheral clock enable */
    static const uint32_t RCC_C1_APB4ENR_LPUART1EN_MASK             = 0x00000008U;   /** @brief LPUART1 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_SPI6EN_MASK                = 0x00000020U;   /** @brief SPI6 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_I2C4EN_MASK                = 0x00000080U;   /** @brief I2C4 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_COMP12EN_MASK              = 0x00004000U;   /** @brief COMP1/2 peripheral clock enable */
    static const uint32_t RCC_C1_APB4ENR_VREFEN_MASK                = 0x00008000U;   /** @brief VREF peripheral clock enable */
    static const uint32_t RCC_C1_APB4ENR_RTCAPBEN_MASK              = 0x00010000U;   /** @brief RTC APB clock enable */
    static const uint32_t RCC_C1_APB4ENR_SAI4EN_MASK                = 0x00200000U;   /** @brief SAI4 peripheral clocks enable */
    static const uint32_t RCC_C1_AHB3LPENR_MDMALPEN_MASK            = 0x00000001U;   /** @brief MDMA clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_DMA2DLPEN_MASK           = 0x00000010U;   /** @brief DMA2D clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_JPGDECLPEN_MASK          = 0x00000020U;   /** @brief JPGDEC clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_FLITFLPEN_MASK           = 0x00000100U;   /** @brief FLITF clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_FMCLPEN_MASK             = 0x00001000U;   /** @brief FMC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_QSPILPEN_MASK            = 0x00004000U;   /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_SDMMC1LPEN_MASK          = 0x00010000U;   /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_D1DTCM1LPEN_MASK         = 0x10000000U;   /** @brief D1DTCM1 block clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_DTCM2LPEN_MASK           = 0x20000000U;   /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_ITCMLPEN_MASK            = 0x40000000U;   /** @brief D1ITCM block clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_AXISRAMLPEN_MASK         = 0x80000000U;   /** @brief AXISRAM block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_MDMALPEN_MASK               = 0x00000001U;   /** @brief MDMA clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_DMA2DLPEN_MASK              = 0x00000010U;   /** @brief DMA2D clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_JPGDECLPEN_MASK             = 0x00000020U;   /** @brief JPGDEC clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_FLITFLPEN_MASK              = 0x00000100U;   /** @brief FLITF clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_FMCLPEN_MASK                = 0x00001000U;   /** @brief FMC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_QSPILPEN_MASK               = 0x00004000U;   /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_SDMMC1LPEN_MASK             = 0x00010000U;   /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_D1DTCM1LPEN_MASK            = 0x10000000U;   /** @brief D1DTCM1 block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_DTCM2LPEN_MASK              = 0x20000000U;   /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_ITCMLPEN_MASK               = 0x40000000U;   /** @brief D1ITCM block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_AXISRAMLPEN_MASK            = 0x80000000U;   /** @brief AXISRAM block clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ADC12LPEN_MASK              = 0x00000020U;   /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ETH1MACLPEN_MASK            = 0x00008000U;   /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ETH1TXLPEN_MASK             = 0x00010000U;   /** @brief Ethernet transmission clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ETH1RXLPEN_MASK             = 0x00020000U;   /** @brief Ethernet reception clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ADC12LPEN_MASK           = 0x00000020U;   /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ETH1MACLPEN_MASK         = 0x00008000U;   /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ETH1TXLPEN_MASK          = 0x00010000U;   /** @brief Ethernet transmission clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ETH1RXLPEN_MASK          = 0x00020000U;   /** @brief Ethernet reception clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_CAMITFLPEN_MASK          = 0x00000001U;   /** @brief CAMITF peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_CRYPTLPEN_MASK           = 0x00000010U;   /** @brief CRYPT peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_HASHLPEN_MASK            = 0x00000020U;   /** @brief HASH peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_SDMMC2LPEN_MASK          = 0x00000200U;   /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_RNGLPEN_MASK             = 0x00000040U;   /** @brief RNG peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_CAMITFLPEN_MASK             = 0x00000001U;   /** @brief CAMITF peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_CRYPTLPEN_MASK              = 0x00000010U;   /** @brief CRYPT peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_HASHLPEN_MASK               = 0x00000020U;   /** @brief HASH peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_SDMMC2LPEN_MASK             = 0x00000200U;   /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_RNGLPEN_MASK                = 0x00000040U;   /** @brief RNG peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOALPEN_MASK              = 0x00000001U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOBLPEN_MASK              = 0x00000002U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOCLPEN_MASK              = 0x00000004U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIODLPEN_MASK              = 0x00000008U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOELPEN_MASK              = 0x00000010U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOFLPEN_MASK              = 0x00000020U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOGLPEN_MASK              = 0x00000040U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOHLPEN_MASK              = 0x00000080U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOILPEN_MASK              = 0x00000100U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOJLPEN_MASK              = 0x00000200U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOKLPEN_MASK              = 0x00000400U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_CRCLPEN_MASK                = 0x00080000U;   /** @brief CRC peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_BDMALPEN_MASK               = 0x00200000U;   /** @brief BDMA clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_ADC3LPEN_MASK               = 0x01000000U;   /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_BKPRAMLPEN_MASK             = 0x10000000U;   /** @brief Backup RAM clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_SRAM4LPEN_MASK              = 0x20000000U;   /** @brief SRAM4 clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOALPEN_MASK           = 0x00000001U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOBLPEN_MASK           = 0x00000002U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOCLPEN_MASK           = 0x00000004U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIODLPEN_MASK           = 0x00000008U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOELPEN_MASK           = 0x00000010U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOFLPEN_MASK           = 0x00000020U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOGLPEN_MASK           = 0x00000040U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOHLPEN_MASK           = 0x00000080U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOILPEN_MASK           = 0x00000100U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOJLPEN_MASK           = 0x00000200U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOKLPEN_MASK           = 0x00000400U;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_CRCLPEN_MASK             = 0x00080000U;   /** @brief CRC peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_BDMALPEN_MASK            = 0x00200000U;   /** @brief BDMA clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_ADC3LPEN_MASK            = 0x01000000U;   /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_BKPRAMLPEN_MASK          = 0x10000000U;   /** @brief Backup RAM clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_SRAM4LPEN_MASK           = 0x20000000U;   /** @brief SRAM4 clock enable during csleep mode */
    static const uint32_t RCC_C1_APB3LPENR_LTDCLPEN_MASK            = 0x00000008U;   /** @brief LTDC peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB3LPENR_WWDG1LPEN_MASK           = 0x00000040U;   /** @brief WWDG1 clock enable during csleep mode */
    static const uint32_t RCC_APB3LPENR_LTDCLPEN_MASK               = 0x00000008U;   /** @brief LTDC peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB3LPENR_WWDG1LPEN_MASK              = 0x00000040U;   /** @brief WWDG1 clock enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_LPTIM1LPEN_MASK            = 0x00000200U;   /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_SPDIFRXLPEN_MASK           = 0x00010000U;   /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_HDMICECLPEN_MASK           = 0x08000000U;   /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_DAC12LPEN_MASK             = 0x20000000U;   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_LPTIM1LPEN_MASK         = 0x00000200U;   /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_SPDIFRXLPEN_MASK        = 0x00010000U;   /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_HDMICECLPEN_MASK        = 0x08000000U;   /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_DAC12LPEN_MASK          = 0x20000000U;   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_CRSLPEN_MASK            = 0x00000002U;   /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_SWPLPEN_MASK            = 0x00000004U;   /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_OPAMPLPEN_MASK          = 0x00000010U;   /** @brief OPAMP peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_MDIOSLPEN_MASK          = 0x00000020U;   /** @brief MDIOS peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_FDCANLPEN_MASK          = 0x00000100U;   /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_CRSLPEN_MASK               = 0x00000002U;   /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_SWPLPEN_MASK               = 0x00000004U;   /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_OPAMPLPEN_MASK             = 0x00000010U;   /** @brief OPAMP peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_MDIOSLPEN_MASK             = 0x00000020U;   /** @brief MDIOS peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_FDCANLPEN_MASK             = 0x00000100U;   /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_DFSDM1LPEN_MASK             = 0x10000000U;   /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_HRTIMLPEN_MASK              = 0x20000000U;   /** @brief HRTIM peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_DFSDM1LPEN_MASK          = 0x10000000U;   /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_HRTIMLPEN_MASK           = 0x20000000U;   /** @brief HRTIM peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_SYSCFGLPEN_MASK          = 0x00000002U;   /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_LPUART1LPEN_MASK         = 0x00000008U;   /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_SPI6LPEN_MASK            = 0x00000020U;   /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_I2C4LPEN_MASK            = 0x00000080U;   /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_COMP12LPEN_MASK          = 0x00004000U;   /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_VREFLPEN_MASK            = 0x00008000U;   /** @brief VREF peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_RTCAPBLPEN_MASK          = 0x00010000U;   /** @brief RTC APB clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_SAI4LPEN_MASK            = 0x00200000U;   /** @brief SAI4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_SYSCFGLPEN_MASK             = 0x00000002U;   /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_LPUART1LPEN_MASK            = 0x00000008U;   /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_SPI6LPEN_MASK               = 0x00000020U;   /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_I2C4LPEN_MASK               = 0x00000080U;   /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_COMP12LPEN_MASK             = 0x00004000U;   /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_VREFLPEN_MASK               = 0x00008000U;   /** @brief VREF peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_RTCAPBLPEN_MASK             = 0x00010000U;   /** @brief RTC APB clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_SAI4LPEN_MASK               = 0x00200000U;   /** @brief SAI4 peripheral clocks enable during csleep mode */

    /**** @subsection Enumerated RCC Register Field Masks ****/

    static const uint32_t RCC_CR_DxCKRDY_MASK[3] = {
      [1] = 0x00004000U,   /** @brief D1 domain clocks ready flag */
      [2] = 0x00008000U,   /** @brief D2 domain clocks ready flag */
    };

    static const uint32_t RCC_CR_PLLxON_MASK[4] = {
      [1] = 0x01000000U,   /** @brief PLL1 enable */
      [2] = 0x04000000U,   /** @brief PLL2 enable */
      [3] = 0x10000000U,   /** @brief PLL3 enable */
    };

    static const uint32_t RCC_CR_PLLxRDY_MASK[4] = {
      [1] = 0x02000000U,   /** @brief PLL1 clock ready flag */
      [2] = 0x08000000U,   /** @brief PLL2 clock ready flag */
      [3] = 0x20000000U,   /** @brief PLL3 clock ready flag */
    };

    static const uint32_t RCC_CFGR_MCOxPRE_MASK[3] = {
      [1] = 0x003C0000U,   /** @brief MCO1 prescaler */
      [2] = 0x1E000000U,   /** @brief MCO2 prescaler */
    };

    static const uint32_t RCC_CFGR_MCOxSEL_MASK[3] = {
      [1] = 0x01C00000U,   /** @brief Micro-controller clock output 1 */
      [2] = 0xE0000000U,   /** @brief Micro-controller clock output 2 */
    };

    static const uint32_t RCC_D2CFGR_D2PPREx_MASK[3] = {
      [1] = 0x00000070U,   /** @brief D2 domain APB1 prescaler */
      [2] = 0x00000700U,   /** @brief D2 domain APB2 prescaler */
    };

    static const uint32_t RCC_PLLCKSELR_DIVMx_MASK[4] = {
      [1] = 0x000003F0U,   /** @brief Prescaler for PLL1 */
      [2] = 0x0003F000U,   /** @brief Prescaler for PLL2 */
      [3] = 0x03F00000U,   /** @brief Prescaler for PLL3 */
    };

    static const uint32_t RCC_PLLCFGR_PLLxFRACEN_MASK[4] = {
      [1] = 0x00000001U,   /** @brief PLL1 fractional latch enable */
      [2] = 0x00000010U,   /** @brief PLL2 fractional latch enable */
      [3] = 0x00000100U,   /** @brief PLL3 fractional latch enable */
    };

    static const uint32_t RCC_PLLCFGR_PLLxVCOSEL_MASK[4] = {
      [1] = 0x00000002U,   /** @brief PLL1 VCO selection */
      [2] = 0x00000020U,   /** @brief PLL2 VCO selection */
      [3] = 0x00000200U,   /** @brief PLL3 VCO selection */
    };

    static const uint32_t RCC_PLLCFGR_PLLxRGE_MASK[4] = {
      [1] = 0x0000000CU,   /** @brief PLL1 input frequency range */
      [2] = 0x000000C0U,   /** @brief PLL2 input frequency range */
      [3] = 0x00000C00U,   /** @brief PLL3 input frequency range */
    };

    static const uint32_t RCC_PLLCFGR_DIVPxEN_MASK[4] = {
      [1] = 0x00010000U,   /** @brief PLL1 DIVP divider output enable */
      [2] = 0x00080000U,   /** @brief PLL2 DIVP divider output enable */
      [3] = 0x00400000U,   /** @brief PLL3 DIVP divider output enable */
    };

    static const uint32_t RCC_PLLCFGR_DIVQxEN_MASK[4] = {
      [1] = 0x00020000U,   /** @brief PLL1 DIVQ divider output enable */
      [2] = 0x00100000U,   /** @brief PLL2 DIVQ divider output enable */
      [3] = 0x00800000U,   /** @brief PLL3 DIVQ divider output enable */
    };

    static const uint32_t RCC_PLLCFGR_DIVRxEN_MASK[4] = {
      [1] = 0x00040000U,   /** @brief PLL1 DIVR divider output enable */
      [2] = 0x00200000U,   /** @brief PLL2 DIVR divider output enable */
      [3] = 0x01000000U,   /** @brief PLL3 DIVR divider output enable */
    };

    static const uint32_t RCC_CIER_PLLxRDYIE_MASK[4] = {
      [1] = 0x00000040U,   /** @brief PLL1 ready interrupt enable */
      [2] = 0x00000080U,   /** @brief PLL2 ready interrupt enable */
      [3] = 0x00000100U,   /** @brief PLL3 ready interrupt enable */
    };

    static const uint32_t RCC_CIFR_PLLxRDYF_MASK[4] = {
      [1] = 0x00000040U,   /** @brief PLL1 ready interrupt flag */
      [2] = 0x00000080U,   /** @brief PLL2 ready interrupt flag */
      [3] = 0x00000100U,   /** @brief PLL3 ready interrupt flag */
    };

    static const uint32_t RCC_CICR_PLLxRDYC_MASK[4] = {
      [1] = 0x00000040U,   /** @brief PLL1 ready interrupt clear */
      [2] = 0x00000080U,   /** @brief PLL2 ready interrupt clear */
      [3] = 0x00000100U,   /** @brief PLL3 ready interrupt clear */
    };

    static const uint32_t RCC_AHB1RSTR_DMAxRST_MASK[3] = {
      [1] = 0x00000001U,   /** @brief DMA1 block reset */
      [2] = 0x00000002U,   /** @brief DMA2 block reset */
    };

    static const uint32_t RCC_AHB1RSTR_USBxOTGRST_MASK[3] = {
      [1] = 0x02000000U,   /** @brief USB1OTG block reset */
      [2] = 0x08000000U,   /** @brief USB2OTG block reset */
    };

    static const uint32_t RCC_APB1LRSTR_TIMxRST_MASK[15] = {
      [2]  = 0x00000001U,   /** @brief TIM block reset */
      [3]  = 0x00000002U,   /** @brief TIM block reset */
      [4]  = 0x00000004U,   /** @brief TIM block reset */
      [5]  = 0x00000008U,   /** @brief TIM block reset */
      [6]  = 0x00000010U,   /** @brief TIM block reset */
      [7]  = 0x00000020U,   /** @brief TIM block reset */
      [12] = 0x00000040U,   /** @brief TIM block reset */
      [13] = 0x00000080U,   /** @brief TIM block reset */
      [14] = 0x00000100U,   /** @brief TIM block reset */
    };

    static const uint32_t RCC_APB1LRSTR_SPIxRST_MASK[4] = {
      [2] = 0x00004000U,   /** @brief SPI2 block reset */
      [3] = 0x00008000U,   /** @brief SPI3 block reset */
    };

    static const uint32_t RCC_APB1LRSTR_USARTxRST_MASK[9] = {
      [2] = 0x00020000U,   /** @brief USART2 block reset */
      [3] = 0x00040000U,   /** @brief USART3 block reset */
      [7] = 0x40000000U,   /** @brief USART7 block reset */
      [8] = 0x80000000U,   /** @brief USART8 block reset */
    };

    static const uint32_t RCC_APB1LRSTR_UARTxRST_MASK[6] = {
      [4] = 0x00080000U,   /** @brief UART4 block reset */
      [5] = 0x00100000U,   /** @brief UART5 block reset */
    };

    static const uint32_t RCC_APB1LRSTR_I2CxRST_MASK[4] = {
      [1] = 0x00200000U,   /** @brief I2C1 block reset */
      [2] = 0x00400000U,   /** @brief I2C2 block reset */
      [3] = 0x00800000U,   /** @brief I2C3 block reset */
    };

    static const uint32_t RCC_APB2RSTR_SAIxRST_MASK[4] = {
      [1] = 0x00400000U,   /** @brief SAI1 block reset */
      [2] = 0x00800000U,   /** @brief SAI2 block reset */
      [3] = 0x01000000U,   /** @brief SAI3 block reset */
    };

    static const uint32_t RCC_APB4RSTR_LPTIMxRST_MASK[6] = {
      [2] = 0x00000200U,   /** @brief LPTIM2 block reset */
      [3] = 0x00000400U,   /** @brief LPTIM3 block reset */
      [4] = 0x00000800U,   /** @brief LPTIM4 block reset */
      [5] = 0x00001000U,   /** @brief LPTIM5 block reset */
    };

    static const uint32_t RCC_D3AMR_LPTIMxAMEN_MASK[6] = {
      [2] = 0x00000200U,   /** @brief LPTIM2 autonomous mode enable */
      [3] = 0x00000400U,   /** @brief LPTIM3 autonomous mode enable */
      [4] = 0x00000800U,   /** @brief LPTIM4 autonomous mode enable */
      [5] = 0x00001000U,   /** @brief LPTIM5 autonomous mode enable */
    };

    static const uint32_t RCC_RSR_DxRSTF_MASK[3] = {
      [1] = 0x00080000U,   /** @brief D1 domain power switch reset flag */
      [2] = 0x00100000U,   /** @brief D2 domain power switch reset flag */
    };

    static const uint32_t RCC_AHB1ENR_DMAxEN_MASK[3] = {
      [1] = 0x00000001U,   /** @brief DMA1 clock enable */
      [2] = 0x00000002U,   /** @brief DMA2 clock enable */
    };

    static const uint32_t RCC_AHB1ENR_USBxOTGEN_MASK[3] = {
      [1] = 0x02000000U,   /** @brief USB1OTG peripheral clocks enable */
      [2] = 0x08000000U,   /** @brief USB2OTG peripheral clocks enable */
    };

    static const uint32_t RCC_AHB1ENR_USBxULPIEN_MASK[3] = {
      [1] = 0x04000000U,   /** @brief USB_PHY1 clocks enable */
      [2] = 0x10000000U,   /** @brief USB_PHY2 clocks enable */
    };

    static const uint32_t RCC_C1_AHB2ENR_SRAMxEN_MASK[4] = {
      [1] = 0x20000000U,   /** @brief SRAM1 block enable */
      [2] = 0x40000000U,   /** @brief SRAM2 block enable */
      [3] = 0x80000000U,   /** @brief SRAM3 block enable */
    };

    static const uint32_t RCC_APB1LENR_TIMxEN_MASK[15] = {
      [2]  = 0x00000001U,   /** @brief TIM peripheral clock enable */
      [3]  = 0x00000002U,   /** @brief TIM peripheral clock enable */
      [4]  = 0x00000004U,   /** @brief TIM peripheral clock enable */
      [5]  = 0x00000008U,   /** @brief TIM peripheral clock enable */
      [6]  = 0x00000010U,   /** @brief TIM peripheral clock enable */
      [7]  = 0x00000020U,   /** @brief TIM peripheral clock enable */
      [12] = 0x00000040U,   /** @brief TIM peripheral clock enable */
      [13] = 0x00000080U,   /** @brief TIM peripheral clock enable */
      [14] = 0x00000100U,   /** @brief TIM peripheral clock enable */
    };

    static const uint32_t RCC_APB1LENR_SPIxEN_MASK[4] = {
      [2] = 0x00004000U,   /** @brief SPI2 peripheral clocks enable */
      [3] = 0x00008000U,   /** @brief SPI3 peripheral clocks enable */
    };

    static const uint32_t RCC_APB1LENR_USARTxEN_MASK[9] = {
      [2] = 0x00020000U,   /** @brief USART2 peripheral clocks enable */
      [3] = 0x00040000U,   /** @brief USART3 peripheral clocks enable */
      [7] = 0x40000000U,   /** @brief USART7 peripheral clocks enable */
      [8] = 0x80000000U,   /** @brief USART8 peripheral clocks enable */
    };

    static const uint32_t RCC_APB1LENR_UARTxEN_MASK[6] = {
      [4] = 0x00080000U,   /** @brief UART4 peripheral clocks enable */
      [5] = 0x00100000U,   /** @brief UART5 peripheral clocks enable */
    };

    static const uint32_t RCC_APB1LENR_I2CxEN_MASK[4] = {
      [1] = 0x00200000U,   /** @brief I2C1 peripheral clocks enable */
      [2] = 0x00400000U,   /** @brief I2C2 peripheral clocks enable */
      [3] = 0x00800000U,   /** @brief I2C3 peripheral clocks enable */
    };

    static const uint32_t RCC_C1_APB2ENR_SAIxEN_MASK[4] = {
      [1] = 0x00400000U,   /** @brief SAI1 peripheral clocks enable */
      [2] = 0x00800000U,   /** @brief SAI2 peripheral clocks enable */
      [3] = 0x01000000U,   /** @brief SAI3 peripheral clocks enable */
    };

    static const uint32_t RCC_APB4ENR_LPTIMxEN_MASK[6] = {
      [2] = 0x00000200U,   /** @brief LPTIM2 peripheral clocks enable */
      [3] = 0x00000400U,   /** @brief LPTIM3 peripheral clocks enable */
      [4] = 0x00000800U,   /** @brief LPTIM4 peripheral clocks enable */
      [5] = 0x00001000U,   /** @brief LPTIM5 peripheral clocks enable */
    };

    static const uint32_t RCC_AHB1LPENR_DMAxLPEN_MASK[3] = {
      [1] = 0x00000001U,   /** @brief DMA1 clock enable during csleep mode */
      [2] = 0x00000002U,   /** @brief DMA2 clock enable during csleep mode */
    };

    static const uint32_t RCC_AHB1LPENR_USBxOTGLPEN_MASK[3] = {
      [1] = 0x02000000U,   /** @brief USB1OTG peripheral clock enable during csleep mode */
      [2] = 0x08000000U,   /** @brief USB2OTG peripheral clock enable during csleep mode */
    };

    static const uint32_t RCC_AHB1LPENR_USBxULPILPEN_MASK[3] = {
      [1] = 0x04000000U,   /** @brief USB_PHY1 clock enable during csleep mode */
      [2] = 0x10000000U,   /** @brief USB_PHY2 clocks enable during csleep mode */
    };

    static const uint32_t RCC_C1_AHB2LPENR_SRAMxLPEN_MASK[4] = {
      [1] = 0x20000000U,   /** @brief SRAM1 clock enable during csleep mode */
      [2] = 0x40000000U,   /** @brief SRAM2 clock enable during csleep mode */
      [3] = 0x80000000U,   /** @brief SRAM3 clock enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_TIMxLPEN_MASK[15] = {
      [2]  = 0x00000001U,   /** @brief TIM2 peripheral clock enable during csleep mode */
      [3]  = 0x00000002U,   /** @brief TIM3 peripheral clock enable during csleep mode */
      [4]  = 0x00000004U,   /** @brief TIM4 peripheral clock enable during csleep mode */
      [5]  = 0x00000008U,   /** @brief TIM5 peripheral clock enable during csleep mode */
      [6]  = 0x00000010U,   /** @brief TIM6 peripheral clock enable during csleep mode */
      [7]  = 0x00000020U,   /** @brief TIM7 peripheral clock enable during csleep mode */
      [12] = 0x00000040U,   /** @brief TIM12 peripheral clock enable during csleep mode */
      [13] = 0x00000080U,   /** @brief TIM13 peripheral clock enable during csleep mode */
      [14] = 0x00000100U,   /** @brief TIM14 peripheral clock enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_SPIxLPEN_MASK[4] = {
      [2] = 0x00004000U,   /** @brief SPI2 peripheral clocks enable during csleep mode */
      [3] = 0x00008000U,   /** @brief SPI3 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_USARTxLPEN_MASK[9] = {
      [2] = 0x00020000U,   /** @brief USART2 peripheral clocks enable during csleep mode */
      [3] = 0x00040000U,   /** @brief USART3 peripheral clocks enable during csleep mode */
      [7] = 0x40000000U,   /** @brief USART7 peripheral clocks enable during csleep mode */
      [8] = 0x80000000U,   /** @brief USART8 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_UARTxLPEN_MASK[6] = {
      [4] = 0x00080000U,   /** @brief UART4 peripheral clocks enable during csleep mode */
      [5] = 0x00100000U,   /** @brief UART5 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_I2CxLPEN_MASK[4] = {
      [1] = 0x00200000U,   /** @brief I2C1 peripheral clocks enable during csleep mode */
      [2] = 0x00400000U,   /** @brief I2C2 peripheral clocks enable during csleep mode */
      [3] = 0x00800000U,   /** @brief I2C3 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_APB2LPENR_SAIxLPEN_MASK[4] = {
      [1] = 0x00400000U,   /** @brief SAI1 peripheral clocks enable during csleep mode */
      [2] = 0x00800000U,   /** @brief SAI2 peripheral clocks enable during csleep mode */
      [3] = 0x01000000U,   /** @brief SAI3 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_C1_APB4LPENR_LPTIMxLPEN_MASK[6] = {
      [2] = 0x00000200U,   /** @brief LPTIM2 peripheral clocks enable during csleep mode */
      [3] = 0x00000400U,   /** @brief LPTIM3 peripheral clocks enable during csleep mode */
      [4] = 0x00000800U,   /** @brief LPTIM4 peripheral clocks enable during csleep mode */
      [5] = 0x00001000U,   /** @brief LPTIM5 peripheral clocks enable during csleep mode */
    };

    /**** @subsection RCC Register Field Positions ****/

    static const int32_t RCC_CR_HSION_POS                         = 0;    /** @brief Internal high-speed clock enable */
    static const int32_t RCC_CR_HSIKERON_POS                      = 1;    /** @brief High speed internal clock enable in stop mode */
    static const int32_t RCC_CR_HSIRDY_POS                        = 2;    /** @brief HSI clock ready flag */
    static const int32_t RCC_CR_HSIDIV_POS                        = 3;    /** @brief HSI clock divider */
    static const int32_t RCC_CR_HSIDIVF_POS                       = 5;    /** @brief HSI divider flag */
    static const int32_t RCC_CR_CSION_POS                         = 7;    /** @brief CSI clock enable */
    static const int32_t RCC_CR_CSIRDY_POS                        = 8;    /** @brief CSI clock ready flag */
    static const int32_t RCC_CR_CSIKERON_POS                      = 9;    /** @brief CSI clock enable in stop mode */
    static const int32_t RCC_CR_RC48ON_POS                        = 12;   /** @brief RC48 clock enable */
    static const int32_t RCC_CR_RC48RDY_POS                       = 13;   /** @brief RC48 clock ready flag */
    static const int32_t RCC_CR_HSEON_POS                         = 16;   /** @brief HSE clock enable */
    static const int32_t RCC_CR_HSERDY_POS                        = 17;   /** @brief HSE clock ready flag */
    static const int32_t RCC_CR_HSEBYP_POS                        = 18;   /** @brief HSE clock bypass */
    static const int32_t RCC_CR_HSECSSON_POS                      = 19;   /** @brief HSE clock security system enable */
    static const int32_t RCC_ICSCR_HSICAL_POS                     = 0;    /** @brief HSI clock calibration */
    static const int32_t RCC_ICSCR_HSITRIM_POS                    = 12;   /** @brief HSI clock trimming */
    static const int32_t RCC_ICSCR_CSICAL_POS                     = 18;   /** @brief CSI clock calibration */
    static const int32_t RCC_ICSCR_CSITRIM_POS                    = 26;   /** @brief CSI clock trimming */
    static const int32_t RCC_CRRCR_RC48CAL_POS                    = 0;    /** @brief Internal RC 48 mhz clock calibration */
    static const int32_t RCC_CFGR_SW_POS                          = 0;    /** @brief System clock switch */
    static const int32_t RCC_CFGR_SWS_POS                         = 3;    /** @brief System clock switch status */
    static const int32_t RCC_CFGR_STOPWUCK_POS                    = 6;    /** @brief System clock selection after a wake up from system stop */
    static const int32_t RCC_CFGR_STOPKERWUCK_POS                 = 7;    /** @brief Kernel clock selection after a wake up from system stop */
    static const int32_t RCC_CFGR_RTCPRE_POS                      = 8;    /** @brief HSE division factor for RTC clock */
    static const int32_t RCC_CFGR_HRTIMSEL_POS                    = 14;   /** @brief High resolution timer clock prescaler selection */
    static const int32_t RCC_CFGR_TIMPRE_POS                      = 15;   /** @brief Timers clocks prescaler selection */
    static const int32_t RCC_D1CFGR_HPRE_POS                      = 0;    /** @brief D1 domain AHB prescaler */
    static const int32_t RCC_D1CFGR_D1PPRE_POS                    = 4;    /** @brief D1 domain APB3 prescaler */
    static const int32_t RCC_D1CFGR_D1CPRE_POS                    = 8;    /** @brief D1 domain core prescaler */
    static const int32_t RCC_D3CFGR_D3PPRE_POS                    = 4;    /** @brief D3 domain APB4 prescaler */
    static const int32_t RCC_PLLCKSELR_PLLSRC_POS                 = 0;    /** @brief DIVMx and plls clock source selection */
    static const int32_t RCC_PLLxDIVR_DIVN1_POS                   = 0;    /** @brief Multiplication factor for PLL1 VCO */
    static const int32_t RCC_PLLxDIVR_DIVP1_POS                   = 9;    /** @brief PLL1 DIVP division factor */
    static const int32_t RCC_PLLxDIVR_DIVQ1_POS                   = 16;   /** @brief PLL1 DIVQ division factor */
    static const int32_t RCC_PLLxDIVR_DIVR1_POS                   = 24;   /** @brief PLL1 DIVR division factor */
    static const int32_t RCC_PLLxFRACR_FRACN1_POS                 = 3;    /** @brief Fractional part of the multiplication factor for PLL1 VCO */
    static const int32_t RCC_D1CCIPR_FMCSRC_POS                   = 0;    /** @brief FMC kernel clock source selection */
    static const int32_t RCC_D1CCIPR_QSPISRC_POS                  = 4;    /** @brief QUADSPI kernel clock source selection */
    static const int32_t RCC_D1CCIPR_SDMMCSRC_POS                 = 16;   /** @brief SDMMC kernel clock source selection */
    static const int32_t RCC_D1CCIPR_CKPERSRC_POS                 = 28;   /** @brief Per_ck clock source selection */
    static const int32_t RCC_D2CCIP1R_SAI1SRC_POS                 = 0;    /** @brief SAI1 and DFSDM1 kernel aclk clock source selection */
    static const int32_t RCC_D2CCIP1R_SAI23SRC_POS                = 6;    /** @brief SAI2 and SAI3 kernel clock source selection */
    static const int32_t RCC_D2CCIP1R_SPI123SRC_POS               = 12;   /** @brief SPI/I2S1,2 and 3 kernel clock source selection */
    static const int32_t RCC_D2CCIP1R_SPI45SRC_POS                = 16;   /** @brief SPI4 and 5 kernel clock source selection */
    static const int32_t RCC_D2CCIP1R_SPDIFSRC_POS                = 20;   /** @brief SPDIFRX kernel clock source selection */
    static const int32_t RCC_D2CCIP1R_DFSDM1SRC_POS               = 24;   /** @brief DFSDM1 kernel clk clock source selection */
    static const int32_t RCC_D2CCIP1R_FDCANSRC_POS                = 28;   /** @brief FDCAN kernel clock source selection */
    static const int32_t RCC_D2CCIP1R_SWPSRC_POS                  = 31;   /** @brief SWPMI kernel clock source selection */
    static const int32_t RCC_D2CCIP2R_USART234578SRC_POS          = 0;    /** @brief USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection */
    static const int32_t RCC_D2CCIP2R_USART16SRC_POS              = 3;    /** @brief USART1 and 6 kernel clock source selection */
    static const int32_t RCC_D2CCIP2R_RNGSRC_POS                  = 8;    /** @brief RNG kernel clock source selection */
    static const int32_t RCC_D2CCIP2R_I2C123SRC_POS               = 12;   /** @brief I2C1,2,3 kernel clock source selection */
    static const int32_t RCC_D2CCIP2R_USBSRC_POS                  = 20;   /** @brief USBOTG 1 and 2 kernel clock source selection */
    static const int32_t RCC_D2CCIP2R_CECSRC_POS                  = 22;   /** @brief HDMI-CEC kernel clock source selection */
    static const int32_t RCC_D2CCIP2R_LPTIM1SRC_POS               = 28;   /** @brief LPTIM1 kernel clock source selection */
    static const int32_t RCC_D3CCIPR_LPUART1SRC_POS               = 0;    /** @brief LPUART1 kernel clock source selection */
    static const int32_t RCC_D3CCIPR_I2C4SRC_POS                  = 8;    /** @brief I2C4 kernel clock source selection */
    static const int32_t RCC_D3CCIPR_LPTIM2SRC_POS                = 10;   /** @brief LPTIM2 kernel clock source selection */
    static const int32_t RCC_D3CCIPR_LPTIM345SRC_POS              = 13;   /** @brief LPTIM3,4,5 kernel clock source selection */
    static const int32_t RCC_D3CCIPR_ADCSRC_POS                   = 16;   /** @brief SAR ADC kernel clock source selection */
    static const int32_t RCC_D3CCIPR_SAI4ASRC_POS                 = 21;   /** @brief Sub-Block A of SAI4 kernel clock source selection */
    static const int32_t RCC_D3CCIPR_SAI4BSRC_POS                 = 24;   /** @brief Sub-Block B of SAI4 kernel clock source selection */
    static const int32_t RCC_D3CCIPR_SPI6SRC_POS                  = 28;   /** @brief SPI6 kernel clock source selection */
    static const int32_t RCC_CIER_LSIRDYIE_POS                    = 0;    /** @brief LSI ready interrupt enable */
    static const int32_t RCC_CIER_LSERDYIE_POS                    = 1;    /** @brief LSE ready interrupt enable */
    static const int32_t RCC_CIER_HSIRDYIE_POS                    = 2;    /** @brief HSI ready interrupt enable */
    static const int32_t RCC_CIER_HSERDYIE_POS                    = 3;    /** @brief HSE ready interrupt enable */
    static const int32_t RCC_CIER_CSIRDYIE_POS                    = 4;    /** @brief CSI ready interrupt enable */
    static const int32_t RCC_CIER_RC48RDYIE_POS                   = 5;    /** @brief RC48 ready interrupt enable */
    static const int32_t RCC_CIER_LSECSSIE_POS                    = 9;    /** @brief LSE clock security system interrupt enable */
    static const int32_t RCC_CIFR_LSIRDYF_POS                     = 0;    /** @brief LSI ready interrupt flag */
    static const int32_t RCC_CIFR_LSERDYF_POS                     = 1;    /** @brief LSE ready interrupt flag */
    static const int32_t RCC_CIFR_HSIRDYF_POS                     = 2;    /** @brief HSI ready interrupt flag */
    static const int32_t RCC_CIFR_HSERDYF_POS                     = 3;    /** @brief HSE ready interrupt flag */
    static const int32_t RCC_CIFR_CSIRDY_POS                      = 4;    /** @brief CSI ready interrupt flag */
    static const int32_t RCC_CIFR_RC48RDYF_POS                    = 5;    /** @brief RC48 ready interrupt flag */
    static const int32_t RCC_CIFR_LSECSSF_POS                     = 9;    /** @brief LSE clock security system interrupt flag */
    static const int32_t RCC_CIFR_HSECSSF_POS                     = 10;   /** @brief HSE clock security system interrupt flag */
    static const int32_t RCC_CICR_LSIRDYC_POS                     = 0;    /** @brief LSI ready interrupt clear */
    static const int32_t RCC_CICR_LSERDYC_POS                     = 1;    /** @brief LSE ready interrupt clear */
    static const int32_t RCC_CICR_HSIRDYC_POS                     = 2;    /** @brief HSI ready interrupt clear */
    static const int32_t RCC_CICR_HSERDYC_POS                     = 3;    /** @brief HSE ready interrupt clear */
    static const int32_t RCC_CICR_HSE_READY_INTERRUPT_CLEAR_POS   = 4;    /** @brief CSI ready interrupt clear */
    static const int32_t RCC_CICR_RC48RDYC_POS                    = 5;    /** @brief RC48 ready interrupt clear */
    static const int32_t RCC_CICR_LSECSSC_POS                     = 9;    /** @brief LSE clock security system interrupt clear */
    static const int32_t RCC_CICR_HSECSSC_POS                     = 10;   /** @brief HSE clock security system interrupt clear */
    static const int32_t RCC_BDCR_LSEON_POS                       = 0;    /** @brief LSE oscillator enabled */
    static const int32_t RCC_BDCR_LSERDY_POS                      = 1;    /** @brief LSE oscillator ready */
    static const int32_t RCC_BDCR_LSEBYP_POS                      = 2;    /** @brief LSE oscillator bypass */
    static const int32_t RCC_BDCR_LSEDRV_POS                      = 3;    /** @brief LSE oscillator driving capability */
    static const int32_t RCC_BDCR_LSECSSON_POS                    = 5;    /** @brief LSE clock security system enable */
    static const int32_t RCC_BDCR_LSECSSD_POS                     = 6;    /** @brief LSE clock security system failure detection */
    static const int32_t RCC_BDCR_RTCSRC_POS                      = 8;    /** @brief RTC clock source selection */
    static const int32_t RCC_BDCR_RTCEN_POS                       = 15;   /** @brief RTC clock enable */
    static const int32_t RCC_BDCR_VSWRST_POS                      = 16;   /** @brief VSwitch domain software reset */
    static const int32_t RCC_CSR_LSION_POS                        = 0;    /** @brief LSI oscillator enable */
    static const int32_t RCC_CSR_LSIRDY_POS                       = 1;    /** @brief LSI oscillator ready */
    static const int32_t RCC_AHB3RSTR_MDMARST_POS                 = 0;    /** @brief MDMA block reset */
    static const int32_t RCC_AHB3RSTR_DMA2DRST_POS                = 4;    /** @brief DMA2D block reset */
    static const int32_t RCC_AHB3RSTR_JPGDECRST_POS               = 5;    /** @brief JPGDEC block reset */
    static const int32_t RCC_AHB3RSTR_FMCRST_POS                  = 12;   /** @brief FMC block reset */
    static const int32_t RCC_AHB3RSTR_QSPIRST_POS                 = 14;   /** @brief QUADSPI and QUADSPI delay block reset */
    static const int32_t RCC_AHB3RSTR_SDMMC1RST_POS               = 16;   /** @brief SDMMC1 and SDMMC1 delay block reset */
    static const int32_t RCC_AHB3RSTR_CPURST_POS                  = 31;   /** @brief CPU reset */
    static const int32_t RCC_AHB1RSTR_ADC12RST_POS                = 5;    /** @brief ADC1&2 block reset */
    static const int32_t RCC_AHB1RSTR_ETH1MACRST_POS              = 15;   /** @brief ETH1MAC block reset */
    static const int32_t RCC_AHB2RSTR_CAMITFRST_POS               = 0;    /** @brief CAMITF block reset */
    static const int32_t RCC_AHB2RSTR_CRYPTRST_POS                = 4;    /** @brief Cryptography block reset */
    static const int32_t RCC_AHB2RSTR_HASHRST_POS                 = 5;    /** @brief Hash block reset */
    static const int32_t RCC_AHB2RSTR_RNGRST_POS                  = 6;    /** @brief Random number generator block reset */
    static const int32_t RCC_AHB2RSTR_SDMMC2RST_POS               = 9;    /** @brief SDMMC2 and SDMMC2 delay block reset */
    static const int32_t RCC_AHB4RSTR_GPIOARST_POS                = 0;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOBRST_POS                = 1;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOCRST_POS                = 2;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIODRST_POS                = 3;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOERST_POS                = 4;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOFRST_POS                = 5;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOGRST_POS                = 6;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOHRST_POS                = 7;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOIRST_POS                = 8;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOJRST_POS                = 9;    /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_GPIOKRST_POS                = 10;   /** @brief GPIO block reset */
    static const int32_t RCC_AHB4RSTR_CRCRST_POS                  = 19;   /** @brief CRC block reset */
    static const int32_t RCC_AHB4RSTR_BDMARST_POS                 = 21;   /** @brief BDMA block reset */
    static const int32_t RCC_AHB4RSTR_ADC3RST_POS                 = 24;   /** @brief ADC3 block reset */
    static const int32_t RCC_AHB4RSTR_HSEMRST_POS                 = 25;   /** @brief HSEM block reset */
    static const int32_t RCC_APB3RSTR_LTDCRST_POS                 = 3;    /** @brief LTDC block reset */
    static const int32_t RCC_APB1LRSTR_LPTIM1RST_POS              = 9;    /** @brief TIM block reset */
    static const int32_t RCC_APB1LRSTR_SPDIFRXRST_POS             = 16;   /** @brief SPDIFRX block reset */
    static const int32_t RCC_APB1LRSTR_HDMICECRST_POS             = 27;   /** @brief HDMI-CEC block reset */
    static const int32_t RCC_APB1LRSTR_DAC12RST_POS               = 29;   /** @brief DAC1 and 2 blocks reset */
    static const int32_t RCC_APB1HRSTR_CRSRST_POS                 = 1;    /** @brief Clock recovery system reset */
    static const int32_t RCC_APB1HRSTR_SWPRST_POS                 = 2;    /** @brief SWPMI block reset */
    static const int32_t RCC_APB1HRSTR_OPAMPRST_POS               = 4;    /** @brief OPAMP block reset */
    static const int32_t RCC_APB1HRSTR_MDIOSRST_POS               = 5;    /** @brief MDIOS block reset */
    static const int32_t RCC_APB1HRSTR_FDCANRST_POS               = 8;    /** @brief FDCAN block reset */
    static const int32_t RCC_APB2RSTR_DFSDM1RST_POS               = 28;   /** @brief DFSDM1 block reset */
    static const int32_t RCC_APB2RSTR_HRTIMRST_POS                = 29;   /** @brief HRTIM block reset */
    static const int32_t RCC_APB4RSTR_SYSCFGRST_POS               = 1;    /** @brief SYSCFG block reset */
    static const int32_t RCC_APB4RSTR_LPUART1RST_POS              = 3;    /** @brief LPUART1 block reset */
    static const int32_t RCC_APB4RSTR_SPI6RST_POS                 = 5;    /** @brief SPI6 block reset */
    static const int32_t RCC_APB4RSTR_I2C4RST_POS                 = 7;    /** @brief I2C4 block reset */
    static const int32_t RCC_APB4RSTR_COMP12RST_POS               = 14;   /** @brief COMP12 blocks reset */
    static const int32_t RCC_APB4RSTR_VREFRST_POS                 = 15;   /** @brief VREF block reset */
    static const int32_t RCC_APB4RSTR_SAI4RST_POS                 = 21;   /** @brief SAI4 block reset */
    static const int32_t RCC_GCR_WW1RSC_POS                       = 0;    /** @brief WWDG1 reset scope control */
    static const int32_t RCC_D3AMR_BDMAAMEN_POS                   = 0;    /** @brief BDMA and DMAMUX autonomous mode enable */
    static const int32_t RCC_D3AMR_LPUART1AMEN_POS                = 3;    /** @brief LPUART1 autonomous mode enable */
    static const int32_t RCC_D3AMR_SPI6AMEN_POS                   = 5;    /** @brief SPI6 autonomous mode enable */
    static const int32_t RCC_D3AMR_I2C4AMEN_POS                   = 7;    /** @brief I2C4 autonomous mode enable */
    static const int32_t RCC_D3AMR_COMP12AMEN_POS                 = 14;   /** @brief COMP12 autonomous mode enable */
    static const int32_t RCC_D3AMR_VREFAMEN_POS                   = 15;   /** @brief VREF autonomous mode enable */
    static const int32_t RCC_D3AMR_RTCAMEN_POS                    = 16;   /** @brief RTC autonomous mode enable */
    static const int32_t RCC_D3AMR_CRCAMEN_POS                    = 19;   /** @brief CRC autonomous mode enable */
    static const int32_t RCC_D3AMR_SAI4AMEN_POS                   = 21;   /** @brief SAI4 autonomous mode enable */
    static const int32_t RCC_D3AMR_ADC3AMEN_POS                   = 24;   /** @brief ADC3 autonomous mode enable */
    static const int32_t RCC_D3AMR_BKPSRAMAMEN_POS                = 28;   /** @brief Backup RAM autonomous mode enable */
    static const int32_t RCC_D3AMR_SRAM4AMEN_POS                  = 29;   /** @brief SRAM4 autonomous mode enable */
    static const int32_t RCC_RSR_RMVF_POS                         = 16;   /** @brief Remove reset flag */
    static const int32_t RCC_RSR_CPURSTF_POS                      = 17;   /** @brief CPU reset flag */
    static const int32_t RCC_RSR_BORRSTF_POS                      = 21;   /** @brief BOR reset flag */
    static const int32_t RCC_RSR_PINRSTF_POS                      = 22;   /** @brief Pin reset flag (NRST) */
    static const int32_t RCC_RSR_PORRSTF_POS                      = 23;   /** @brief POR/PDR reset flag */
    static const int32_t RCC_RSR_SFTRSTF_POS                      = 24;   /** @brief System reset from CPU reset flag */
    static const int32_t RCC_RSR_IWDG1RSTF_POS                    = 26;   /** @brief Independent watchdog reset flag */
    static const int32_t RCC_RSR_WWDG1RSTF_POS                    = 28;   /** @brief Window watchdog reset flag */
    static const int32_t RCC_RSR_LPWRRSTF_POS                     = 30;   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const int32_t RCC_C1_RSR_RMVF_POS                      = 16;   /** @brief Remove reset flag */
    static const int32_t RCC_C1_RSR_CPURSTF_POS                   = 17;   /** @brief CPU reset flag */
    static const int32_t RCC_C1_RSR_BORRSTF_POS                   = 21;   /** @brief BOR reset flag */
    static const int32_t RCC_C1_RSR_PINRSTF_POS                   = 22;   /** @brief Pin reset flag (NRST) */
    static const int32_t RCC_C1_RSR_PORRSTF_POS                   = 23;   /** @brief POR/PDR reset flag */
    static const int32_t RCC_C1_RSR_SFTRSTF_POS                   = 24;   /** @brief System reset from CPU reset flag */
    static const int32_t RCC_C1_RSR_IWDG1RSTF_POS                 = 26;   /** @brief Independent watchdog reset flag */
    static const int32_t RCC_C1_RSR_WWDG1RSTF_POS                 = 28;   /** @brief Window watchdog reset flag */
    static const int32_t RCC_C1_RSR_LPWRRSTF_POS                  = 30;   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const int32_t RCC_C1_AHB3ENR_MDMAEN_POS                = 0;    /** @brief MDMA peripheral clock enable */
    static const int32_t RCC_C1_AHB3ENR_DMA2DEN_POS               = 4;    /** @brief DMA2D peripheral clock enable */
    static const int32_t RCC_C1_AHB3ENR_JPGDECEN_POS              = 5;    /** @brief JPGDEC peripheral clock enable */
    static const int32_t RCC_C1_AHB3ENR_FMCEN_POS                 = 12;   /** @brief FMC peripheral clocks enable */
    static const int32_t RCC_C1_AHB3ENR_QSPIEN_POS                = 14;   /** @brief QUADSPI and QUADSPI delay clock enable */
    static const int32_t RCC_C1_AHB3ENR_SDMMC1EN_POS              = 16;   /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const int32_t RCC_AHB3ENR_MDMAEN_POS                   = 0;    /** @brief MDMA peripheral clock enable */
    static const int32_t RCC_AHB3ENR_DMA2DEN_POS                  = 4;    /** @brief DMA2D peripheral clock enable */
    static const int32_t RCC_AHB3ENR_JPGDECEN_POS                 = 5;    /** @brief JPGDEC peripheral clock enable */
    static const int32_t RCC_AHB3ENR_FMCEN_POS                    = 12;   /** @brief FMC peripheral clocks enable */
    static const int32_t RCC_AHB3ENR_QSPIEN_POS                   = 14;   /** @brief QUADSPI and QUADSPI delay clock enable */
    static const int32_t RCC_AHB3ENR_SDMMC1EN_POS                 = 16;   /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const int32_t RCC_AHB1ENR_ADC12EN_POS                  = 5;    /** @brief ADC1/2 peripheral clocks enable */
    static const int32_t RCC_AHB1ENR_ETH1MACEN_POS                = 15;   /** @brief Ethernet MAC bus interface clock enable */
    static const int32_t RCC_AHB1ENR_ETH1TXEN_POS                 = 16;   /** @brief Ethernet transmission clock enable */
    static const int32_t RCC_AHB1ENR_ETH1RXEN_POS                 = 17;   /** @brief Ethernet reception clock enable */
    static const int32_t RCC_C1_AHB1ENR_ADC12EN_POS               = 5;    /** @brief ADC1/2 peripheral clocks enable */
    static const int32_t RCC_C1_AHB1ENR_ETH1MACEN_POS             = 15;   /** @brief Ethernet MAC bus interface clock enable */
    static const int32_t RCC_C1_AHB1ENR_ETH1TXEN_POS              = 16;   /** @brief Ethernet transmission clock enable */
    static const int32_t RCC_C1_AHB1ENR_ETH1RXEN_POS              = 17;   /** @brief Ethernet reception clock enable */
    static const int32_t RCC_C1_AHB2ENR_CAMITFEN_POS              = 0;    /** @brief CAMITF peripheral clock enable */
    static const int32_t RCC_C1_AHB2ENR_CRYPTEN_POS               = 4;    /** @brief CRYPT peripheral clock enable */
    static const int32_t RCC_C1_AHB2ENR_HASHEN_POS                = 5;    /** @brief HASH peripheral clock enable */
    static const int32_t RCC_C1_AHB2ENR_RNGEN_POS                 = 6;    /** @brief RNG peripheral clocks enable */
    static const int32_t RCC_C1_AHB2ENR_SDMMC2EN_POS              = 9;    /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const int32_t RCC_AHB2ENR_CAMITFEN_POS                 = 0;    /** @brief CAMITF peripheral clock enable */
    static const int32_t RCC_AHB2ENR_CRYPTEN_POS                  = 4;    /** @brief CRYPT peripheral clock enable */
    static const int32_t RCC_AHB2ENR_HASHEN_POS                   = 5;    /** @brief HASH peripheral clock enable */
    static const int32_t RCC_AHB2ENR_RNGEN_POS                    = 6;    /** @brief RNG peripheral clocks enable */
    static const int32_t RCC_AHB2ENR_SDMMC2EN_POS                 = 9;    /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const int32_t RCC_AHB4ENR_GPIOAEN_POS                  = 0;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOBEN_POS                  = 1;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOCEN_POS                  = 2;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIODEN_POS                  = 3;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOEEN_POS                  = 4;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOFEN_POS                  = 5;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOGEN_POS                  = 6;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOHEN_POS                  = 7;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOIEN_POS                  = 8;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOJEN_POS                  = 9;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_GPIOKEN_POS                  = 10;   /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_AHB4ENR_CRCEN_POS                    = 19;   /** @brief CRC peripheral clock enable */
    static const int32_t RCC_AHB4ENR_BDMAEN_POS                   = 21;   /** @brief BDMA and DMAMUX2 clock enable */
    static const int32_t RCC_AHB4ENR_ADC3EN_POS                   = 24;   /** @brief ADC3 peripheral clocks enable */
    static const int32_t RCC_AHB4ENR_HSEMEN_POS                   = 25;   /** @brief HSEM peripheral clock enable */
    static const int32_t RCC_AHB4ENR_BKPRAMEN_POS                 = 28;   /** @brief Backup RAM clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOAEN_POS               = 0;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOBEN_POS               = 1;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOCEN_POS               = 2;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIODEN_POS               = 3;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOEEN_POS               = 4;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOFEN_POS               = 5;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOGEN_POS               = 6;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOHEN_POS               = 7;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOIEN_POS               = 8;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOJEN_POS               = 9;    /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_GPIOKEN_POS               = 10;   /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_CRCEN_POS                 = 19;   /** @brief CRC peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_BDMAEN_POS                = 21;   /** @brief BDMA and DMAMUX2 clock enable */
    static const int32_t RCC_C1_AHB4ENR_ADC3EN_POS                = 24;   /** @brief ADC3 peripheral clocks enable */
    static const int32_t RCC_C1_AHB4ENR_HSEMEN_POS                = 25;   /** @brief HSEM peripheral clock enable */
    static const int32_t RCC_C1_AHB4ENR_BKPRAMEN_POS              = 28;   /** @brief Backup RAM clock enable */
    static const int32_t RCC_C1_APB3ENR_LTDCEN_POS                = 3;    /** @brief LTDC peripheral clock enable */
    static const int32_t RCC_C1_APB3ENR_WWDG1EN_POS               = 6;    /** @brief WWDG1 clock enable */
    static const int32_t RCC_APB3ENR_LTDCEN_POS                   = 3;    /** @brief LTDC peripheral clock enable */
    static const int32_t RCC_APB3ENR_WWDG1EN_POS                  = 6;    /** @brief WWDG1 clock enable */
    static const int32_t RCC_APB1LENR_LPTIM1EN_POS                = 9;    /** @brief LPTIM1 peripheral clocks enable */
    static const int32_t RCC_APB1LENR_SPDIFRXEN_POS               = 16;   /** @brief SPDIFRX peripheral clocks enable */
    static const int32_t RCC_APB1LENR_HDMICECEN_POS               = 27;   /** @brief HDMI-CEC peripheral clock enable */
    static const int32_t RCC_APB1LENR_DAC12EN_POS                 = 29;   /** @brief DAC1&2 peripheral clock enable */
    static const int32_t RCC_C1_APB1LENR_LPTIM1EN_POS             = 9;    /** @brief LPTIM1 peripheral clocks enable */
    static const int32_t RCC_C1_APB1LENR_SPDIFRXEN_POS            = 16;   /** @brief SPDIFRX peripheral clocks enable */
    static const int32_t RCC_C1_APB1LENR_HDMICECEN_POS            = 27;   /** @brief HDMI-CEC peripheral clock enable */
    static const int32_t RCC_C1_APB1LENR_DAC12EN_POS              = 29;   /** @brief DAC1&2 peripheral clock enable */
    static const int32_t RCC_APB1HENR_CRSEN_POS                   = 1;    /** @brief Clock recovery system peripheral clock enable */
    static const int32_t RCC_APB1HENR_SWPEN_POS                   = 2;    /** @brief SWPMI peripheral clocks enable */
    static const int32_t RCC_APB1HENR_OPAMPEN_POS                 = 4;    /** @brief OPAMP peripheral clock enable */
    static const int32_t RCC_APB1HENR_MDIOSEN_POS                 = 5;    /** @brief MDIOS peripheral clock enable */
    static const int32_t RCC_APB1HENR_FDCANEN_POS                 = 8;    /** @brief FDCAN peripheral clocks enable */
    static const int32_t RCC_C1_APB1HENR_CRSEN_POS                = 1;    /** @brief Clock recovery system peripheral clock enable */
    static const int32_t RCC_C1_APB1HENR_SWPEN_POS                = 2;    /** @brief SWPMI peripheral clocks enable */
    static const int32_t RCC_C1_APB1HENR_OPAMPEN_POS              = 4;    /** @brief OPAMP peripheral clock enable */
    static const int32_t RCC_C1_APB1HENR_MDIOSEN_POS              = 5;    /** @brief MDIOS peripheral clock enable */
    static const int32_t RCC_C1_APB1HENR_FDCANEN_POS              = 8;    /** @brief FDCAN peripheral clocks enable */
    static const int32_t RCC_C1_APB2ENR_DFSDM1EN_POS              = 28;   /** @brief DFSDM1 peripheral clocks enable */
    static const int32_t RCC_C1_APB2ENR_HRTIMEN_POS               = 29;   /** @brief HRTIM peripheral clock enable */
    static const int32_t RCC_APB2ENR_DFSDM1EN_POS                 = 28;   /** @brief DFSDM1 peripheral clocks enable */
    static const int32_t RCC_APB2ENR_HRTIMEN_POS                  = 29;   /** @brief HRTIM peripheral clock enable */
    static const int32_t RCC_APB4ENR_SYSCFGEN_POS                 = 1;    /** @brief SYSCFG peripheral clock enable */
    static const int32_t RCC_APB4ENR_LPUART1EN_POS                = 3;    /** @brief LPUART1 peripheral clocks enable */
    static const int32_t RCC_APB4ENR_SPI6EN_POS                   = 5;    /** @brief SPI6 peripheral clocks enable */
    static const int32_t RCC_APB4ENR_I2C4EN_POS                   = 7;    /** @brief I2C4 peripheral clocks enable */
    static const int32_t RCC_APB4ENR_COMP12EN_POS                 = 14;   /** @brief COMP1/2 peripheral clock enable */
    static const int32_t RCC_APB4ENR_VREFEN_POS                   = 15;   /** @brief VREF peripheral clock enable */
    static const int32_t RCC_APB4ENR_RTCAPBEN_POS                 = 16;   /** @brief RTC APB clock enable */
    static const int32_t RCC_APB4ENR_SAI4EN_POS                   = 21;   /** @brief SAI4 peripheral clocks enable */
    static const int32_t RCC_C1_APB4ENR_SYSCFGEN_POS              = 1;    /** @brief SYSCFG peripheral clock enable */
    static const int32_t RCC_C1_APB4ENR_LPUART1EN_POS             = 3;    /** @brief LPUART1 peripheral clocks enable */
    static const int32_t RCC_C1_APB4ENR_SPI6EN_POS                = 5;    /** @brief SPI6 peripheral clocks enable */
    static const int32_t RCC_C1_APB4ENR_I2C4EN_POS                = 7;    /** @brief I2C4 peripheral clocks enable */
    static const int32_t RCC_C1_APB4ENR_COMP12EN_POS              = 14;   /** @brief COMP1/2 peripheral clock enable */
    static const int32_t RCC_C1_APB4ENR_VREFEN_POS                = 15;   /** @brief VREF peripheral clock enable */
    static const int32_t RCC_C1_APB4ENR_RTCAPBEN_POS              = 16;   /** @brief RTC APB clock enable */
    static const int32_t RCC_C1_APB4ENR_SAI4EN_POS                = 21;   /** @brief SAI4 peripheral clocks enable */
    static const int32_t RCC_C1_AHB3LPENR_MDMALPEN_POS            = 0;    /** @brief MDMA clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_DMA2DLPEN_POS           = 4;    /** @brief DMA2D clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_JPGDECLPEN_POS          = 5;    /** @brief JPGDEC clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_FLITFLPEN_POS           = 8;    /** @brief FLITF clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_FMCLPEN_POS             = 12;   /** @brief FMC peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_QSPILPEN_POS            = 14;   /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_SDMMC1LPEN_POS          = 16;   /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_D1DTCM1LPEN_POS         = 28;   /** @brief D1DTCM1 block clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_DTCM2LPEN_POS           = 29;   /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_ITCMLPEN_POS            = 30;   /** @brief D1ITCM block clock enable during csleep mode */
    static const int32_t RCC_C1_AHB3LPENR_AXISRAMLPEN_POS         = 31;   /** @brief AXISRAM block clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_MDMALPEN_POS               = 0;    /** @brief MDMA clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_DMA2DLPEN_POS              = 4;    /** @brief DMA2D clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_JPGDECLPEN_POS             = 5;    /** @brief JPGDEC clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_FLITFLPEN_POS              = 8;    /** @brief FLITF clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_FMCLPEN_POS                = 12;   /** @brief FMC peripheral clocks enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_QSPILPEN_POS               = 14;   /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_SDMMC1LPEN_POS             = 16;   /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_D1DTCM1LPEN_POS            = 28;   /** @brief D1DTCM1 block clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_DTCM2LPEN_POS              = 29;   /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_ITCMLPEN_POS               = 30;   /** @brief D1ITCM block clock enable during csleep mode */
    static const int32_t RCC_AHB3LPENR_AXISRAMLPEN_POS            = 31;   /** @brief AXISRAM block clock enable during csleep mode */
    static const int32_t RCC_AHB1LPENR_ADC12LPEN_POS              = 5;    /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const int32_t RCC_AHB1LPENR_ETH1MACLPEN_POS            = 15;   /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const int32_t RCC_AHB1LPENR_ETH1TXLPEN_POS             = 16;   /** @brief Ethernet transmission clock enable during csleep mode */
    static const int32_t RCC_AHB1LPENR_ETH1RXLPEN_POS             = 17;   /** @brief Ethernet reception clock enable during csleep mode */
    static const int32_t RCC_C1_AHB1LPENR_ADC12LPEN_POS           = 5;    /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_AHB1LPENR_ETH1MACLPEN_POS         = 15;   /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const int32_t RCC_C1_AHB1LPENR_ETH1TXLPEN_POS          = 16;   /** @brief Ethernet transmission clock enable during csleep mode */
    static const int32_t RCC_C1_AHB1LPENR_ETH1RXLPEN_POS          = 17;   /** @brief Ethernet reception clock enable during csleep mode */
    static const int32_t RCC_C1_AHB2LPENR_CAMITFLPEN_POS          = 0;    /** @brief CAMITF peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB2LPENR_CRYPTLPEN_POS           = 4;    /** @brief CRYPT peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB2LPENR_HASHLPEN_POS            = 5;    /** @brief HASH peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB2LPENR_SDMMC2LPEN_POS          = 9;    /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const int32_t RCC_C1_AHB2LPENR_RNGLPEN_POS             = 6;    /** @brief RNG peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB2LPENR_CAMITFLPEN_POS             = 0;    /** @brief CAMITF peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB2LPENR_CRYPTLPEN_POS              = 4;    /** @brief CRYPT peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB2LPENR_HASHLPEN_POS               = 5;    /** @brief HASH peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB2LPENR_SDMMC2LPEN_POS             = 9;    /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const int32_t RCC_AHB2LPENR_RNGLPEN_POS                = 6;    /** @brief RNG peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOALPEN_POS              = 0;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOBLPEN_POS              = 1;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOCLPEN_POS              = 2;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIODLPEN_POS              = 3;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOELPEN_POS              = 4;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOFLPEN_POS              = 5;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOGLPEN_POS              = 6;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOHLPEN_POS              = 7;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOILPEN_POS              = 8;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOJLPEN_POS              = 9;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_GPIOKLPEN_POS              = 10;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_CRCLPEN_POS                = 19;   /** @brief CRC peripheral clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_BDMALPEN_POS               = 21;   /** @brief BDMA clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_ADC3LPEN_POS               = 24;   /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_BKPRAMLPEN_POS             = 28;   /** @brief Backup RAM clock enable during csleep mode */
    static const int32_t RCC_AHB4LPENR_SRAM4LPEN_POS              = 29;   /** @brief SRAM4 clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOALPEN_POS           = 0;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOBLPEN_POS           = 1;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOCLPEN_POS           = 2;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIODLPEN_POS           = 3;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOELPEN_POS           = 4;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOFLPEN_POS           = 5;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOGLPEN_POS           = 6;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOHLPEN_POS           = 7;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOILPEN_POS           = 8;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOJLPEN_POS           = 9;    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_GPIOKLPEN_POS           = 10;   /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_CRCLPEN_POS             = 19;   /** @brief CRC peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_BDMALPEN_POS            = 21;   /** @brief BDMA clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_ADC3LPEN_POS            = 24;   /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_BKPRAMLPEN_POS          = 28;   /** @brief Backup RAM clock enable during csleep mode */
    static const int32_t RCC_C1_AHB4LPENR_SRAM4LPEN_POS           = 29;   /** @brief SRAM4 clock enable during csleep mode */
    static const int32_t RCC_C1_APB3LPENR_LTDCLPEN_POS            = 3;    /** @brief LTDC peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB3LPENR_WWDG1LPEN_POS           = 6;    /** @brief WWDG1 clock enable during csleep mode */
    static const int32_t RCC_APB3LPENR_LTDCLPEN_POS               = 3;    /** @brief LTDC peripheral clock enable during csleep mode */
    static const int32_t RCC_APB3LPENR_WWDG1LPEN_POS              = 6;    /** @brief WWDG1 clock enable during csleep mode */
    static const int32_t RCC_APB1LLPENR_LPTIM1LPEN_POS            = 9;    /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB1LLPENR_SPDIFRXLPEN_POS           = 16;   /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB1LLPENR_HDMICECLPEN_POS           = 27;   /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB1LLPENR_DAC12LPEN_POS             = 29;   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB1LLPENR_LPTIM1LPEN_POS         = 9;    /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB1LLPENR_SPDIFRXLPEN_POS        = 16;   /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB1LLPENR_HDMICECLPEN_POS        = 27;   /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB1LLPENR_DAC12LPEN_POS          = 29;   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB1HLPENR_CRSLPEN_POS            = 1;    /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB1HLPENR_SWPLPEN_POS            = 2;    /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB1HLPENR_OPAMPLPEN_POS          = 4;    /** @brief OPAMP peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB1HLPENR_MDIOSLPEN_POS          = 5;    /** @brief MDIOS peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB1HLPENR_FDCANLPEN_POS          = 8;    /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB1HLPENR_CRSLPEN_POS               = 1;    /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const int32_t RCC_APB1HLPENR_SWPLPEN_POS               = 2;    /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB1HLPENR_OPAMPLPEN_POS             = 4;    /** @brief OPAMP peripheral clock enable during csleep mode */
    static const int32_t RCC_APB1HLPENR_MDIOSLPEN_POS             = 5;    /** @brief MDIOS peripheral clock enable during csleep mode */
    static const int32_t RCC_APB1HLPENR_FDCANLPEN_POS             = 8;    /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB2LPENR_DFSDM1LPEN_POS             = 28;   /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB2LPENR_HRTIMLPEN_POS              = 29;   /** @brief HRTIM peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB2LPENR_DFSDM1LPEN_POS          = 28;   /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB2LPENR_HRTIMLPEN_POS           = 29;   /** @brief HRTIM peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_SYSCFGLPEN_POS          = 1;    /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_LPUART1LPEN_POS         = 3;    /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_SPI6LPEN_POS            = 5;    /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_I2C4LPEN_POS            = 7;    /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_COMP12LPEN_POS          = 14;   /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_VREFLPEN_POS            = 15;   /** @brief VREF peripheral clock enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_RTCAPBLPEN_POS          = 16;   /** @brief RTC APB clock enable during csleep mode */
    static const int32_t RCC_C1_APB4LPENR_SAI4LPEN_POS            = 21;   /** @brief SAI4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SYSCFGLPEN_POS             = 1;    /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_LPUART1LPEN_POS            = 3;    /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPI6LPEN_POS               = 5;    /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_I2C4LPEN_POS               = 7;    /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_COMP12LPEN_POS             = 14;   /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_VREFLPEN_POS               = 15;   /** @brief VREF peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_RTCAPBLPEN_POS             = 16;   /** @brief RTC APB clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SAI4LPEN_POS               = 21;   /** @brief SAI4 peripheral clocks enable during csleep mode */

    /**** @subsection Enumerated RCC Register Field Positions ****/

    static const int32_t RCC_CR_DxCKRDY_POS[3] = {
      [1] = 14,   /** @brief D1 domain clocks ready flag */
      [2] = 15,   /** @brief D2 domain clocks ready flag */
    };

    static const int32_t RCC_CR_PLLxON_POS[4] = {
      [1] = 24,   /** @brief PLL1 enable */
      [2] = 26,   /** @brief PLL2 enable */
      [3] = 28,   /** @brief PLL3 enable */
    };

    static const int32_t RCC_CR_PLLxRDY_POS[4] = {
      [1] = 25,   /** @brief PLL1 clock ready flag */
      [2] = 27,   /** @brief PLL2 clock ready flag */
      [3] = 29,   /** @brief PLL3 clock ready flag */
    };

    static const int32_t RCC_CFGR_MCOxPRE_POS[3] = {
      [1] = 18,   /** @brief MCO1 prescaler */
      [2] = 25,   /** @brief MCO2 prescaler */
    };

    static const int32_t RCC_CFGR_MCOxSEL_POS[3] = {
      [1] = 22,   /** @brief Micro-controller clock output 1 */
      [2] = 29,   /** @brief Micro-controller clock output 2 */
    };

    static const int32_t RCC_D2CFGR_D2PPREx_POS[3] = {
      [1] = 4,   /** @brief D2 domain APB1 prescaler */
      [2] = 8,   /** @brief D2 domain APB2 prescaler */
    };

    static const int32_t RCC_PLLCKSELR_DIVMx_POS[4] = {
      [1] = 4,    /** @brief Prescaler for PLL1 */
      [2] = 12,   /** @brief Prescaler for PLL2 */
      [3] = 20,   /** @brief Prescaler for PLL3 */
    };

    static const int32_t RCC_PLLCFGR_PLLxFRACEN_POS[4] = {
      [1] = 0,   /** @brief PLL1 fractional latch enable */
      [2] = 4,   /** @brief PLL2 fractional latch enable */
      [3] = 8,   /** @brief PLL3 fractional latch enable */
    };

    static const int32_t RCC_PLLCFGR_PLLxVCOSEL_POS[4] = {
      [1] = 1,   /** @brief PLL1 VCO selection */
      [2] = 5,   /** @brief PLL2 VCO selection */
      [3] = 9,   /** @brief PLL3 VCO selection */
    };

    static const int32_t RCC_PLLCFGR_PLLxRGE_POS[4] = {
      [1] = 2,    /** @brief PLL1 input frequency range */
      [2] = 6,    /** @brief PLL2 input frequency range */
      [3] = 10,   /** @brief PLL3 input frequency range */
    };

    static const int32_t RCC_PLLCFGR_DIVPxEN_POS[4] = {
      [1] = 16,   /** @brief PLL1 DIVP divider output enable */
      [2] = 19,   /** @brief PLL2 DIVP divider output enable */
      [3] = 22,   /** @brief PLL3 DIVP divider output enable */
    };

    static const int32_t RCC_PLLCFGR_DIVQxEN_POS[4] = {
      [1] = 17,   /** @brief PLL1 DIVQ divider output enable */
      [2] = 20,   /** @brief PLL2 DIVQ divider output enable */
      [3] = 23,   /** @brief PLL3 DIVQ divider output enable */
    };

    static const int32_t RCC_PLLCFGR_DIVRxEN_POS[4] = {
      [1] = 18,   /** @brief PLL1 DIVR divider output enable */
      [2] = 21,   /** @brief PLL2 DIVR divider output enable */
      [3] = 24,   /** @brief PLL3 DIVR divider output enable */
    };

    static const int32_t RCC_CIER_PLLxRDYIE_POS[4] = {
      [1] = 6,   /** @brief PLL1 ready interrupt enable */
      [2] = 7,   /** @brief PLL2 ready interrupt enable */
      [3] = 8,   /** @brief PLL3 ready interrupt enable */
    };

    static const int32_t RCC_CIFR_PLLxRDYF_POS[4] = {
      [1] = 6,   /** @brief PLL1 ready interrupt flag */
      [2] = 7,   /** @brief PLL2 ready interrupt flag */
      [3] = 8,   /** @brief PLL3 ready interrupt flag */
    };

    static const int32_t RCC_CICR_PLLxRDYC_POS[4] = {
      [1] = 6,   /** @brief PLL1 ready interrupt clear */
      [2] = 7,   /** @brief PLL2 ready interrupt clear */
      [3] = 8,   /** @brief PLL3 ready interrupt clear */
    };

    static const int32_t RCC_AHB1RSTR_DMAxRST_POS[3] = {
      [1] = 0,   /** @brief DMA1 block reset */
      [2] = 1,   /** @brief DMA2 block reset */
    };

    static const int32_t RCC_AHB1RSTR_USBxOTGRST_POS[3] = {
      [1] = 25,   /** @brief USB1OTG block reset */
      [2] = 27,   /** @brief USB2OTG block reset */
    };

    static const int32_t RCC_APB1LRSTR_TIMxRST_POS[15] = {
      [2]  = 0,   /** @brief TIM block reset */
      [3]  = 1,   /** @brief TIM block reset */
      [4]  = 2,   /** @brief TIM block reset */
      [5]  = 3,   /** @brief TIM block reset */
      [6]  = 4,   /** @brief TIM block reset */
      [7]  = 5,   /** @brief TIM block reset */
      [12] = 6,   /** @brief TIM block reset */
      [13] = 7,   /** @brief TIM block reset */
      [14] = 8,   /** @brief TIM block reset */
    };

    static const int32_t RCC_APB1LRSTR_SPIxRST_POS[4] = {
      [2] = 14,   /** @brief SPI2 block reset */
      [3] = 15,   /** @brief SPI3 block reset */
    };

    static const int32_t RCC_APB1LRSTR_USARTxRST_POS[9] = {
      [2] = 17,   /** @brief USART2 block reset */
      [3] = 18,   /** @brief USART3 block reset */
      [7] = 30,   /** @brief USART7 block reset */
      [8] = 31,   /** @brief USART8 block reset */
    };

    static const int32_t RCC_APB1LRSTR_UARTxRST_POS[6] = {
      [4] = 19,   /** @brief UART4 block reset */
      [5] = 20,   /** @brief UART5 block reset */
    };

    static const int32_t RCC_APB1LRSTR_I2CxRST_POS[4] = {
      [1] = 21,   /** @brief I2C1 block reset */
      [2] = 22,   /** @brief I2C2 block reset */
      [3] = 23,   /** @brief I2C3 block reset */
    };

    static const int32_t RCC_APB2RSTR_SAIxRST_POS[4] = {
      [1] = 22,   /** @brief SAI1 block reset */
      [2] = 23,   /** @brief SAI2 block reset */
      [3] = 24,   /** @brief SAI3 block reset */
    };

    static const int32_t RCC_APB4RSTR_LPTIMxRST_POS[6] = {
      [2] = 9,    /** @brief LPTIM2 block reset */
      [3] = 10,   /** @brief LPTIM3 block reset */
      [4] = 11,   /** @brief LPTIM4 block reset */
      [5] = 12,   /** @brief LPTIM5 block reset */
    };

    static const int32_t RCC_D3AMR_LPTIMxAMEN_POS[6] = {
      [2] = 9,    /** @brief LPTIM2 autonomous mode enable */
      [3] = 10,   /** @brief LPTIM3 autonomous mode enable */
      [4] = 11,   /** @brief LPTIM4 autonomous mode enable */
      [5] = 12,   /** @brief LPTIM5 autonomous mode enable */
    };

    static const int32_t RCC_RSR_DxRSTF_POS[3] = {
      [1] = 19,   /** @brief D1 domain power switch reset flag */
      [2] = 20,   /** @brief D2 domain power switch reset flag */
    };

    static const int32_t RCC_AHB1ENR_DMAxEN_POS[3] = {
      [1] = 0,   /** @brief DMA1 clock enable */
      [2] = 1,   /** @brief DMA2 clock enable */
    };

    static const int32_t RCC_AHB1ENR_USBxOTGEN_POS[3] = {
      [1] = 25,   /** @brief USB1OTG peripheral clocks enable */
      [2] = 27,   /** @brief USB2OTG peripheral clocks enable */
    };

    static const int32_t RCC_AHB1ENR_USBxULPIEN_POS[3] = {
      [1] = 26,   /** @brief USB_PHY1 clocks enable */
      [2] = 28,   /** @brief USB_PHY2 clocks enable */
    };

    static const int32_t RCC_C1_AHB2ENR_SRAMxEN_POS[4] = {
      [1] = 29,   /** @brief SRAM1 block enable */
      [2] = 30,   /** @brief SRAM2 block enable */
      [3] = 31,   /** @brief SRAM3 block enable */
    };

    static const int32_t RCC_APB1LENR_TIMxEN_POS[15] = {
      [2]  = 0,   /** @brief TIM peripheral clock enable */
      [3]  = 1,   /** @brief TIM peripheral clock enable */
      [4]  = 2,   /** @brief TIM peripheral clock enable */
      [5]  = 3,   /** @brief TIM peripheral clock enable */
      [6]  = 4,   /** @brief TIM peripheral clock enable */
      [7]  = 5,   /** @brief TIM peripheral clock enable */
      [12] = 6,   /** @brief TIM peripheral clock enable */
      [13] = 7,   /** @brief TIM peripheral clock enable */
      [14] = 8,   /** @brief TIM peripheral clock enable */
    };

    static const int32_t RCC_APB1LENR_SPIxEN_POS[4] = {
      [2] = 14,   /** @brief SPI2 peripheral clocks enable */
      [3] = 15,   /** @brief SPI3 peripheral clocks enable */
    };

    static const int32_t RCC_APB1LENR_USARTxEN_POS[9] = {
      [2] = 17,   /** @brief USART2 peripheral clocks enable */
      [3] = 18,   /** @brief USART3 peripheral clocks enable */
      [7] = 30,   /** @brief USART7 peripheral clocks enable */
      [8] = 31,   /** @brief USART8 peripheral clocks enable */
    };

    static const int32_t RCC_APB1LENR_UARTxEN_POS[6] = {
      [4] = 19,   /** @brief UART4 peripheral clocks enable */
      [5] = 20,   /** @brief UART5 peripheral clocks enable */
    };

    static const int32_t RCC_APB1LENR_I2CxEN_POS[4] = {
      [1] = 21,   /** @brief I2C1 peripheral clocks enable */
      [2] = 22,   /** @brief I2C2 peripheral clocks enable */
      [3] = 23,   /** @brief I2C3 peripheral clocks enable */
    };

    static const int32_t RCC_C1_APB2ENR_SAIxEN_POS[4] = {
      [1] = 22,   /** @brief SAI1 peripheral clocks enable */
      [2] = 23,   /** @brief SAI2 peripheral clocks enable */
      [3] = 24,   /** @brief SAI3 peripheral clocks enable */
    };

    static const int32_t RCC_APB4ENR_LPTIMxEN_POS[6] = {
      [2] = 9,    /** @brief LPTIM2 peripheral clocks enable */
      [3] = 10,   /** @brief LPTIM3 peripheral clocks enable */
      [4] = 11,   /** @brief LPTIM4 peripheral clocks enable */
      [5] = 12,   /** @brief LPTIM5 peripheral clocks enable */
    };

    static const int32_t RCC_AHB1LPENR_DMAxLPEN_POS[3] = {
      [1] = 0,   /** @brief DMA1 clock enable during csleep mode */
      [2] = 1,   /** @brief DMA2 clock enable during csleep mode */
    };

    static const int32_t RCC_AHB1LPENR_USBxOTGLPEN_POS[3] = {
      [1] = 25,   /** @brief USB1OTG peripheral clock enable during csleep mode */
      [2] = 27,   /** @brief USB2OTG peripheral clock enable during csleep mode */
    };

    static const int32_t RCC_AHB1LPENR_USBxULPILPEN_POS[3] = {
      [1] = 26,   /** @brief USB_PHY1 clock enable during csleep mode */
      [2] = 28,   /** @brief USB_PHY2 clocks enable during csleep mode */
    };

    static const int32_t RCC_C1_AHB2LPENR_SRAMxLPEN_POS[4] = {
      [1] = 29,   /** @brief SRAM1 clock enable during csleep mode */
      [2] = 30,   /** @brief SRAM2 clock enable during csleep mode */
      [3] = 31,   /** @brief SRAM3 clock enable during csleep mode */
    };

    static const int32_t RCC_APB1LLPENR_TIMxLPEN_POS[15] = {
      [2]  = 0,   /** @brief TIM2 peripheral clock enable during csleep mode */
      [3]  = 1,   /** @brief TIM3 peripheral clock enable during csleep mode */
      [4]  = 2,   /** @brief TIM4 peripheral clock enable during csleep mode */
      [5]  = 3,   /** @brief TIM5 peripheral clock enable during csleep mode */
      [6]  = 4,   /** @brief TIM6 peripheral clock enable during csleep mode */
      [7]  = 5,   /** @brief TIM7 peripheral clock enable during csleep mode */
      [12] = 6,   /** @brief TIM12 peripheral clock enable during csleep mode */
      [13] = 7,   /** @brief TIM13 peripheral clock enable during csleep mode */
      [14] = 8,   /** @brief TIM14 peripheral clock enable during csleep mode */
    };

    static const int32_t RCC_APB1LLPENR_SPIxLPEN_POS[4] = {
      [2] = 14,   /** @brief SPI2 peripheral clocks enable during csleep mode */
      [3] = 15,   /** @brief SPI3 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB1LLPENR_USARTxLPEN_POS[9] = {
      [2] = 17,   /** @brief USART2 peripheral clocks enable during csleep mode */
      [3] = 18,   /** @brief USART3 peripheral clocks enable during csleep mode */
      [7] = 30,   /** @brief USART7 peripheral clocks enable during csleep mode */
      [8] = 31,   /** @brief USART8 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB1LLPENR_UARTxLPEN_POS[6] = {
      [4] = 19,   /** @brief UART4 peripheral clocks enable during csleep mode */
      [5] = 20,   /** @brief UART5 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB1LLPENR_I2CxLPEN_POS[4] = {
      [1] = 21,   /** @brief I2C1 peripheral clocks enable during csleep mode */
      [2] = 22,   /** @brief I2C2 peripheral clocks enable during csleep mode */
      [3] = 23,   /** @brief I2C3 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB2LPENR_SAIxLPEN_POS[4] = {
      [1] = 22,   /** @brief SAI1 peripheral clocks enable during csleep mode */
      [2] = 23,   /** @brief SAI2 peripheral clocks enable during csleep mode */
      [3] = 24,   /** @brief SAI3 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_C1_APB4LPENR_LPTIMxLPEN_POS[6] = {
      [2] = 9,    /** @brief LPTIM2 peripheral clocks enable during csleep mode */
      [3] = 10,   /** @brief LPTIM3 peripheral clocks enable during csleep mode */
      [4] = 11,   /** @brief LPTIM4 peripheral clocks enable during csleep mode */
      [5] = 12,   /** @brief LPTIM5 peripheral clocks enable during csleep mode */
    };

    /**********************************************************************************************
     * @section LPTIM1 Register Information
     **********************************************************************************************/

    /**** @subsection LPTIM1 Register Pointers ****/

    static RO_ uint32_t* const LPTIM1_ISR_PTR     = (RO_ uint32_t* const)0x40002400U;   /** @brief Interrupt and status register */
    static RW_ uint32_t* const LPTIM1_ICR_PTR     = (RW_ uint32_t* const)0x40002404U;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const LPTIM1_IER_PTR     = (RW_ uint32_t* const)0x40002408U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const LPTIM1_CFGR_PTR    = (RW_ uint32_t* const)0x4000240CU;   /** @brief Configuration register */
    static RW_ uint32_t* const LPTIM1_CR_PTR      = (RW_ uint32_t* const)0x40002410U;   /** @brief Control register */
    static RW_ uint32_t* const LPTIM1_CMP_PTR     = (RW_ uint32_t* const)0x40002414U;   /** @brief Compare register */
    static RW_ uint32_t* const LPTIM1_ARR_PTR     = (RW_ uint32_t* const)0x40002418U;   /** @brief Autoreload register */
    static RO_ uint32_t* const LPTIM1_CNT_PTR     = (RO_ uint32_t* const)0x4000241CU;   /** @brief Counter register */
    static RW_ uint32_t* const LPTIM1_CFGR2_PTR   = (RW_ uint32_t* const)0x40002424U;   /** @brief LPTIM configuration register 2 */

    /**** @subsection LPTIM1 Register Reset Values ****/

    static const uint32_t LPTIM1_ISR_RST     = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t LPTIM1_ICR_RST     = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t LPTIM1_IER_RST     = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t LPTIM1_CFGR_RST    = 0x00000000U;   /** @brief CFGR register reset value. */
    static const uint32_t LPTIM1_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t LPTIM1_CMP_RST     = 0x00000000U;   /** @brief CMP register reset value. */
    static const uint32_t LPTIM1_ARR_RST     = 0x00000001U;   /** @brief ARR register reset value. */
    static const uint32_t LPTIM1_CNT_RST     = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t LPTIM1_CFGR2_RST   = 0x00000000U;   /** @brief CFGR2 register reset value. */

    /**** @subsection Enumerated LPTIM1 Register Value Types ****/

    typedef uint32_t LPTIM1_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t LPTIM1_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t LPTIM1_IER_t;     /** @brief IER register value type. */
    typedef uint32_t LPTIM1_CFGR_t;    /** @brief CFGR register value type. */
    typedef uint32_t LPTIM1_CR_t;      /** @brief CR register value type. */
    typedef uint32_t LPTIM1_CMP_t;     /** @brief CMP register value type. */
    typedef uint32_t LPTIM1_ARR_t;     /** @brief ARR register value type. */
    typedef uint32_t LPTIM1_CNT_t;     /** @brief CNT register value type. */
    typedef uint32_t LPTIM1_CFGR2_t;   /** @brief CFGR2 register value type. */

    /**** @subsection Enumerated LPTIM1 Register Pointer Types ****/

    typedef uint32_t* const LPTIM1_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const LPTIM1_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const LPTIM1_IER_PTR_t;     /** @brief IER register pointer type. */
    typedef uint32_t* const LPTIM1_CFGR_PTR_t;    /** @brief CFGR register pointer type. */
    typedef uint32_t* const LPTIM1_CR_PTR_t;      /** @brief CR register pointer type. */
    typedef uint32_t* const LPTIM1_CMP_PTR_t;     /** @brief CMP register pointer type. */
    typedef uint32_t* const LPTIM1_ARR_PTR_t;     /** @brief ARR register pointer type. */
    typedef uint32_t* const LPTIM1_CNT_PTR_t;     /** @brief CNT register pointer type. */
    typedef uint32_t* const LPTIM1_CFGR2_PTR_t;   /** @brief CFGR2 register pointer type. */

    /**** @subsection LPTIM1 Register Field Masks ****/

    static const uint32_t LPTIM1_ISR_DOWN_MASK         = 0x00000040U;   /** @brief Counter direction change up to down */
    static const uint32_t LPTIM1_ISR_UP_MASK           = 0x00000020U;   /** @brief Counter direction change down to up */
    static const uint32_t LPTIM1_ISR_ARROK_MASK        = 0x00000010U;   /** @brief Autoreload register update OK */
    static const uint32_t LPTIM1_ISR_CMPOK_MASK        = 0x00000008U;   /** @brief Compare register update OK */
    static const uint32_t LPTIM1_ISR_EXTTRIG_MASK      = 0x00000004U;   /** @brief External trigger edge event */
    static const uint32_t LPTIM1_ISR_ARRM_MASK         = 0x00000002U;   /** @brief Autoreload match */
    static const uint32_t LPTIM1_ISR_CMPM_MASK         = 0x00000001U;   /** @brief Compare match */
    static const uint32_t LPTIM1_ICR_DOWNCF_MASK       = 0x00000040U;   /** @brief Direction change to down clear flag */
    static const uint32_t LPTIM1_ICR_UPCF_MASK         = 0x00000020U;   /** @brief Direction change to UP clear flag */
    static const uint32_t LPTIM1_ICR_ARROKCF_MASK      = 0x00000010U;   /** @brief Autoreload register update OK clear flag */
    static const uint32_t LPTIM1_ICR_CMPOKCF_MASK      = 0x00000008U;   /** @brief Compare register update OK clear flag */
    static const uint32_t LPTIM1_ICR_EXTTRIGCF_MASK    = 0x00000004U;   /** @brief External trigger valid edge clear flag */
    static const uint32_t LPTIM1_ICR_ARRMCF_MASK       = 0x00000002U;   /** @brief Autoreload match clear flag */
    static const uint32_t LPTIM1_ICR_CMPMCF_MASK       = 0x00000001U;   /** @brief Compare match clear flag */
    static const uint32_t LPTIM1_IER_DOWNIE_MASK       = 0x00000040U;   /** @brief Direction change to down interrupt enable */
    static const uint32_t LPTIM1_IER_UPIE_MASK         = 0x00000020U;   /** @brief Direction change to UP interrupt enable */
    static const uint32_t LPTIM1_IER_ARROKIE_MASK      = 0x00000010U;   /** @brief Autoreload register update OK interrupt enable */
    static const uint32_t LPTIM1_IER_CMPOKIE_MASK      = 0x00000008U;   /** @brief Compare register update OK interrupt enable */
    static const uint32_t LPTIM1_IER_EXTTRIGIE_MASK    = 0x00000004U;   /** @brief External trigger valid edge interrupt enable */
    static const uint32_t LPTIM1_IER_ARRMIE_MASK       = 0x00000002U;   /** @brief Autoreload match interrupt enable */
    static const uint32_t LPTIM1_IER_CMPMIE_MASK       = 0x00000001U;   /** @brief Compare match interrupt enable */
    static const uint32_t LPTIM1_CFGR_ENC_MASK         = 0x01000000U;   /** @brief Encoder mode enable */
    static const uint32_t LPTIM1_CFGR_COUNTMODE_MASK   = 0x00800000U;   /** @brief Counter mode enabled */
    static const uint32_t LPTIM1_CFGR_PRELOAD_MASK     = 0x00400000U;   /** @brief Registers update mode */
    static const uint32_t LPTIM1_CFGR_WAVPOL_MASK      = 0x00200000U;   /** @brief Waveform shape polarity */
    static const uint32_t LPTIM1_CFGR_WAVE_MASK        = 0x00100000U;   /** @brief Waveform shape */
    static const uint32_t LPTIM1_CFGR_TIMOUT_MASK      = 0x00080000U;   /** @brief Timeout enable */
    static const uint32_t LPTIM1_CFGR_TRIGEN_MASK      = 0x00060000U;   /** @brief Trigger enable and polarity */
    static const uint32_t LPTIM1_CFGR_TRIGSEL_MASK     = 0x0000E000U;   /** @brief Trigger selector */
    static const uint32_t LPTIM1_CFGR_PRESC_MASK       = 0x00000E00U;   /** @brief Clock prescaler */
    static const uint32_t LPTIM1_CFGR_TRGFLT_MASK      = 0x000000C0U;   /** @brief Configurable digital filter for trigger */
    static const uint32_t LPTIM1_CFGR_CKFLT_MASK       = 0x00000018U;   /** @brief Configurable digital filter for external clock */
    static const uint32_t LPTIM1_CFGR_CKPOL_MASK       = 0x00000006U;   /** @brief Clock polarity */
    static const uint32_t LPTIM1_CFGR_CKSEL_MASK       = 0x00000001U;   /** @brief Clock selector */
    static const uint32_t LPTIM1_CR_ENABLE_MASK        = 0x00000001U;   /** @brief LPTIM enable */
    static const uint32_t LPTIM1_CR_SNGSTRT_MASK       = 0x00000002U;   /** @brief LPTIM start in single mode */
    static const uint32_t LPTIM1_CR_CNTSTRT_MASK       = 0x00000004U;   /** @brief Timer start in continuous mode */
    static const uint32_t LPTIM1_CR_COUNTRST_MASK      = 0x00000008U;   /** @brief Counter reset */
    static const uint32_t LPTIM1_CR_RSTARE_MASK        = 0x00000010U;   /** @brief Reset after read enable */
    static const uint32_t LPTIM1_CMP_CMP_MASK          = 0x0000FFFFU;   /** @brief Compare value */
    static const uint32_t LPTIM1_ARR_ARR_MASK          = 0x0000FFFFU;   /** @brief Auto reload value */
    static const uint32_t LPTIM1_CNT_CNT_MASK          = 0x0000FFFFU;   /** @brief Counter value */

    /**** @subsection Enumerated LPTIM1 Register Field Masks ****/

    static const uint32_t LPTIM1_CFGR2_INxSEL_MASK[3] = {
      [1] = 0x00000003U,   /** @brief LPTIM input 1 selection */
      [2] = 0x00000030U,   /** @brief LPTIM input 2 selection */
    };

    /**** @subsection LPTIM1 Register Field Positions ****/

    static const int32_t LPTIM1_ISR_DOWN_POS         = 6;    /** @brief Counter direction change up to down */
    static const int32_t LPTIM1_ISR_UP_POS           = 5;    /** @brief Counter direction change down to up */
    static const int32_t LPTIM1_ISR_ARROK_POS        = 4;    /** @brief Autoreload register update OK */
    static const int32_t LPTIM1_ISR_CMPOK_POS        = 3;    /** @brief Compare register update OK */
    static const int32_t LPTIM1_ISR_EXTTRIG_POS      = 2;    /** @brief External trigger edge event */
    static const int32_t LPTIM1_ISR_ARRM_POS         = 1;    /** @brief Autoreload match */
    static const int32_t LPTIM1_ISR_CMPM_POS         = 0;    /** @brief Compare match */
    static const int32_t LPTIM1_ICR_DOWNCF_POS       = 6;    /** @brief Direction change to down clear flag */
    static const int32_t LPTIM1_ICR_UPCF_POS         = 5;    /** @brief Direction change to UP clear flag */
    static const int32_t LPTIM1_ICR_ARROKCF_POS      = 4;    /** @brief Autoreload register update OK clear flag */
    static const int32_t LPTIM1_ICR_CMPOKCF_POS      = 3;    /** @brief Compare register update OK clear flag */
    static const int32_t LPTIM1_ICR_EXTTRIGCF_POS    = 2;    /** @brief External trigger valid edge clear flag */
    static const int32_t LPTIM1_ICR_ARRMCF_POS       = 1;    /** @brief Autoreload match clear flag */
    static const int32_t LPTIM1_ICR_CMPMCF_POS       = 0;    /** @brief Compare match clear flag */
    static const int32_t LPTIM1_IER_DOWNIE_POS       = 6;    /** @brief Direction change to down interrupt enable */
    static const int32_t LPTIM1_IER_UPIE_POS         = 5;    /** @brief Direction change to UP interrupt enable */
    static const int32_t LPTIM1_IER_ARROKIE_POS      = 4;    /** @brief Autoreload register update OK interrupt enable */
    static const int32_t LPTIM1_IER_CMPOKIE_POS      = 3;    /** @brief Compare register update OK interrupt enable */
    static const int32_t LPTIM1_IER_EXTTRIGIE_POS    = 2;    /** @brief External trigger valid edge interrupt enable */
    static const int32_t LPTIM1_IER_ARRMIE_POS       = 1;    /** @brief Autoreload match interrupt enable */
    static const int32_t LPTIM1_IER_CMPMIE_POS       = 0;    /** @brief Compare match interrupt enable */
    static const int32_t LPTIM1_CFGR_ENC_POS         = 24;   /** @brief Encoder mode enable */
    static const int32_t LPTIM1_CFGR_COUNTMODE_POS   = 23;   /** @brief Counter mode enabled */
    static const int32_t LPTIM1_CFGR_PRELOAD_POS     = 22;   /** @brief Registers update mode */
    static const int32_t LPTIM1_CFGR_WAVPOL_POS      = 21;   /** @brief Waveform shape polarity */
    static const int32_t LPTIM1_CFGR_WAVE_POS        = 20;   /** @brief Waveform shape */
    static const int32_t LPTIM1_CFGR_TIMOUT_POS      = 19;   /** @brief Timeout enable */
    static const int32_t LPTIM1_CFGR_TRIGEN_POS      = 17;   /** @brief Trigger enable and polarity */
    static const int32_t LPTIM1_CFGR_TRIGSEL_POS     = 13;   /** @brief Trigger selector */
    static const int32_t LPTIM1_CFGR_PRESC_POS       = 9;    /** @brief Clock prescaler */
    static const int32_t LPTIM1_CFGR_TRGFLT_POS      = 6;    /** @brief Configurable digital filter for trigger */
    static const int32_t LPTIM1_CFGR_CKFLT_POS       = 3;    /** @brief Configurable digital filter for external clock */
    static const int32_t LPTIM1_CFGR_CKPOL_POS       = 1;    /** @brief Clock polarity */
    static const int32_t LPTIM1_CFGR_CKSEL_POS       = 0;    /** @brief Clock selector */
    static const int32_t LPTIM1_CR_ENABLE_POS        = 0;    /** @brief LPTIM enable */
    static const int32_t LPTIM1_CR_SNGSTRT_POS       = 1;    /** @brief LPTIM start in single mode */
    static const int32_t LPTIM1_CR_CNTSTRT_POS       = 2;    /** @brief Timer start in continuous mode */
    static const int32_t LPTIM1_CR_COUNTRST_POS      = 3;    /** @brief Counter reset */
    static const int32_t LPTIM1_CR_RSTARE_POS        = 4;    /** @brief Reset after read enable */
    static const int32_t LPTIM1_CMP_CMP_POS          = 0;    /** @brief Compare value */
    static const int32_t LPTIM1_ARR_ARR_POS          = 0;    /** @brief Auto reload value */
    static const int32_t LPTIM1_CNT_CNT_POS          = 0;    /** @brief Counter value */

    /**** @subsection Enumerated LPTIM1 Register Field Positions ****/

    static const int32_t LPTIM1_CFGR2_INxSEL_POS[3] = {
      [1] = 0,   /** @brief LPTIM input 1 selection */
      [2] = 4,   /** @brief LPTIM input 2 selection */
    };

    /**********************************************************************************************
     * @section LPTIM2 Register Information
     **********************************************************************************************/

    /**** @subsection LPTIM2 Register Pointers ****/

    static RO_ uint32_t* const LPTIM2_ISR_PTR     = (RO_ uint32_t* const)0x58002400U;   /** @brief Interrupt and status register */
    static RW_ uint32_t* const LPTIM2_ICR_PTR     = (RW_ uint32_t* const)0x58002404U;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const LPTIM2_IER_PTR     = (RW_ uint32_t* const)0x58002408U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const LPTIM2_CFGR_PTR    = (RW_ uint32_t* const)0x5800240CU;   /** @brief Configuration register */
    static RW_ uint32_t* const LPTIM2_CR_PTR      = (RW_ uint32_t* const)0x58002410U;   /** @brief Control register */
    static RW_ uint32_t* const LPTIM2_CMP_PTR     = (RW_ uint32_t* const)0x58002414U;   /** @brief Compare register */
    static RW_ uint32_t* const LPTIM2_ARR_PTR     = (RW_ uint32_t* const)0x58002418U;   /** @brief Autoreload register */
    static RO_ uint32_t* const LPTIM2_CNT_PTR     = (RO_ uint32_t* const)0x5800241CU;   /** @brief Counter register */
    static RW_ uint32_t* const LPTIM2_CFGR2_PTR   = (RW_ uint32_t* const)0x58002424U;   /** @brief LPTIM configuration register 2 */

    /**** @subsection LPTIM2 Register Reset Values ****/

    static const uint32_t LPTIM2_ISR_RST     = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t LPTIM2_ICR_RST     = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t LPTIM2_IER_RST     = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t LPTIM2_CFGR_RST    = 0x00000000U;   /** @brief CFGR register reset value. */
    static const uint32_t LPTIM2_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t LPTIM2_CMP_RST     = 0x00000000U;   /** @brief CMP register reset value. */
    static const uint32_t LPTIM2_ARR_RST     = 0x00000001U;   /** @brief ARR register reset value. */
    static const uint32_t LPTIM2_CNT_RST     = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t LPTIM2_CFGR2_RST   = 0x00000000U;   /** @brief CFGR2 register reset value. */

    /**** @subsection Enumerated LPTIM2 Register Value Types ****/

    typedef uint32_t LPTIM2_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t LPTIM2_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t LPTIM2_IER_t;     /** @brief IER register value type. */
    typedef uint32_t LPTIM2_CFGR_t;    /** @brief CFGR register value type. */
    typedef uint32_t LPTIM2_CR_t;      /** @brief CR register value type. */
    typedef uint32_t LPTIM2_CMP_t;     /** @brief CMP register value type. */
    typedef uint32_t LPTIM2_ARR_t;     /** @brief ARR register value type. */
    typedef uint32_t LPTIM2_CNT_t;     /** @brief CNT register value type. */
    typedef uint32_t LPTIM2_CFGR2_t;   /** @brief CFGR2 register value type. */

    /**** @subsection Enumerated LPTIM2 Register Pointer Types ****/

    typedef uint32_t* const LPTIM2_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const LPTIM2_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const LPTIM2_IER_PTR_t;     /** @brief IER register pointer type. */
    typedef uint32_t* const LPTIM2_CFGR_PTR_t;    /** @brief CFGR register pointer type. */
    typedef uint32_t* const LPTIM2_CR_PTR_t;      /** @brief CR register pointer type. */
    typedef uint32_t* const LPTIM2_CMP_PTR_t;     /** @brief CMP register pointer type. */
    typedef uint32_t* const LPTIM2_ARR_PTR_t;     /** @brief ARR register pointer type. */
    typedef uint32_t* const LPTIM2_CNT_PTR_t;     /** @brief CNT register pointer type. */
    typedef uint32_t* const LPTIM2_CFGR2_PTR_t;   /** @brief CFGR2 register pointer type. */

    /**** @subsection LPTIM2 Register Field Masks ****/

    static const uint32_t LPTIM2_ISR_DOWN_MASK         = 0x00000040U;   /** @brief Counter direction change up to down */
    static const uint32_t LPTIM2_ISR_UP_MASK           = 0x00000020U;   /** @brief Counter direction change down to up */
    static const uint32_t LPTIM2_ISR_ARROK_MASK        = 0x00000010U;   /** @brief Autoreload register update OK */
    static const uint32_t LPTIM2_ISR_CMPOK_MASK        = 0x00000008U;   /** @brief Compare register update OK */
    static const uint32_t LPTIM2_ISR_EXTTRIG_MASK      = 0x00000004U;   /** @brief External trigger edge event */
    static const uint32_t LPTIM2_ISR_ARRM_MASK         = 0x00000002U;   /** @brief Autoreload match */
    static const uint32_t LPTIM2_ISR_CMPM_MASK         = 0x00000001U;   /** @brief Compare match */
    static const uint32_t LPTIM2_ICR_DOWNCF_MASK       = 0x00000040U;   /** @brief Direction change to down clear flag */
    static const uint32_t LPTIM2_ICR_UPCF_MASK         = 0x00000020U;   /** @brief Direction change to UP clear flag */
    static const uint32_t LPTIM2_ICR_ARROKCF_MASK      = 0x00000010U;   /** @brief Autoreload register update OK clear flag */
    static const uint32_t LPTIM2_ICR_CMPOKCF_MASK      = 0x00000008U;   /** @brief Compare register update OK clear flag */
    static const uint32_t LPTIM2_ICR_EXTTRIGCF_MASK    = 0x00000004U;   /** @brief External trigger valid edge clear flag */
    static const uint32_t LPTIM2_ICR_ARRMCF_MASK       = 0x00000002U;   /** @brief Autoreload match clear flag */
    static const uint32_t LPTIM2_ICR_CMPMCF_MASK       = 0x00000001U;   /** @brief Compare match clear flag */
    static const uint32_t LPTIM2_IER_DOWNIE_MASK       = 0x00000040U;   /** @brief Direction change to down interrupt enable */
    static const uint32_t LPTIM2_IER_UPIE_MASK         = 0x00000020U;   /** @brief Direction change to UP interrupt enable */
    static const uint32_t LPTIM2_IER_ARROKIE_MASK      = 0x00000010U;   /** @brief Autoreload register update OK interrupt enable */
    static const uint32_t LPTIM2_IER_CMPOKIE_MASK      = 0x00000008U;   /** @brief Compare register update OK interrupt enable */
    static const uint32_t LPTIM2_IER_EXTTRIGIE_MASK    = 0x00000004U;   /** @brief External trigger valid edge interrupt enable */
    static const uint32_t LPTIM2_IER_ARRMIE_MASK       = 0x00000002U;   /** @brief Autoreload match interrupt enable */
    static const uint32_t LPTIM2_IER_CMPMIE_MASK       = 0x00000001U;   /** @brief Compare match interrupt enable */
    static const uint32_t LPTIM2_CFGR_ENC_MASK         = 0x01000000U;   /** @brief Encoder mode enable */
    static const uint32_t LPTIM2_CFGR_COUNTMODE_MASK   = 0x00800000U;   /** @brief Counter mode enabled */
    static const uint32_t LPTIM2_CFGR_PRELOAD_MASK     = 0x00400000U;   /** @brief Registers update mode */
    static const uint32_t LPTIM2_CFGR_WAVPOL_MASK      = 0x00200000U;   /** @brief Waveform shape polarity */
    static const uint32_t LPTIM2_CFGR_WAVE_MASK        = 0x00100000U;   /** @brief Waveform shape */
    static const uint32_t LPTIM2_CFGR_TIMOUT_MASK      = 0x00080000U;   /** @brief Timeout enable */
    static const uint32_t LPTIM2_CFGR_TRIGEN_MASK      = 0x00060000U;   /** @brief Trigger enable and polarity */
    static const uint32_t LPTIM2_CFGR_TRIGSEL_MASK     = 0x0000E000U;   /** @brief Trigger selector */
    static const uint32_t LPTIM2_CFGR_PRESC_MASK       = 0x00000E00U;   /** @brief Clock prescaler */
    static const uint32_t LPTIM2_CFGR_TRGFLT_MASK      = 0x000000C0U;   /** @brief Configurable digital filter for trigger */
    static const uint32_t LPTIM2_CFGR_CKFLT_MASK       = 0x00000018U;   /** @brief Configurable digital filter for external clock */
    static const uint32_t LPTIM2_CFGR_CKPOL_MASK       = 0x00000006U;   /** @brief Clock polarity */
    static const uint32_t LPTIM2_CFGR_CKSEL_MASK       = 0x00000001U;   /** @brief Clock selector */
    static const uint32_t LPTIM2_CR_ENABLE_MASK        = 0x00000001U;   /** @brief LPTIM enable */
    static const uint32_t LPTIM2_CR_SNGSTRT_MASK       = 0x00000002U;   /** @brief LPTIM start in single mode */
    static const uint32_t LPTIM2_CR_CNTSTRT_MASK       = 0x00000004U;   /** @brief Timer start in continuous mode */
    static const uint32_t LPTIM2_CR_COUNTRST_MASK      = 0x00000008U;   /** @brief Counter reset */
    static const uint32_t LPTIM2_CR_RSTARE_MASK        = 0x00000010U;   /** @brief Reset after read enable */
    static const uint32_t LPTIM2_CMP_CMP_MASK          = 0x0000FFFFU;   /** @brief Compare value */
    static const uint32_t LPTIM2_ARR_ARR_MASK          = 0x0000FFFFU;   /** @brief Auto reload value */
    static const uint32_t LPTIM2_CNT_CNT_MASK          = 0x0000FFFFU;   /** @brief Counter value */

    /**** @subsection Enumerated LPTIM2 Register Field Masks ****/

    static const uint32_t LPTIM2_CFGR2_INxSEL_MASK[3] = {
      [1] = 0x00000003U,   /** @brief LPTIM input 1 selection */
      [2] = 0x00000030U,   /** @brief LPTIM input 2 selection */
    };

    /**** @subsection LPTIM2 Register Field Positions ****/

    static const int32_t LPTIM2_ISR_DOWN_POS         = 6;    /** @brief Counter direction change up to down */
    static const int32_t LPTIM2_ISR_UP_POS           = 5;    /** @brief Counter direction change down to up */
    static const int32_t LPTIM2_ISR_ARROK_POS        = 4;    /** @brief Autoreload register update OK */
    static const int32_t LPTIM2_ISR_CMPOK_POS        = 3;    /** @brief Compare register update OK */
    static const int32_t LPTIM2_ISR_EXTTRIG_POS      = 2;    /** @brief External trigger edge event */
    static const int32_t LPTIM2_ISR_ARRM_POS         = 1;    /** @brief Autoreload match */
    static const int32_t LPTIM2_ISR_CMPM_POS         = 0;    /** @brief Compare match */
    static const int32_t LPTIM2_ICR_DOWNCF_POS       = 6;    /** @brief Direction change to down clear flag */
    static const int32_t LPTIM2_ICR_UPCF_POS         = 5;    /** @brief Direction change to UP clear flag */
    static const int32_t LPTIM2_ICR_ARROKCF_POS      = 4;    /** @brief Autoreload register update OK clear flag */
    static const int32_t LPTIM2_ICR_CMPOKCF_POS      = 3;    /** @brief Compare register update OK clear flag */
    static const int32_t LPTIM2_ICR_EXTTRIGCF_POS    = 2;    /** @brief External trigger valid edge clear flag */
    static const int32_t LPTIM2_ICR_ARRMCF_POS       = 1;    /** @brief Autoreload match clear flag */
    static const int32_t LPTIM2_ICR_CMPMCF_POS       = 0;    /** @brief Compare match clear flag */
    static const int32_t LPTIM2_IER_DOWNIE_POS       = 6;    /** @brief Direction change to down interrupt enable */
    static const int32_t LPTIM2_IER_UPIE_POS         = 5;    /** @brief Direction change to UP interrupt enable */
    static const int32_t LPTIM2_IER_ARROKIE_POS      = 4;    /** @brief Autoreload register update OK interrupt enable */
    static const int32_t LPTIM2_IER_CMPOKIE_POS      = 3;    /** @brief Compare register update OK interrupt enable */
    static const int32_t LPTIM2_IER_EXTTRIGIE_POS    = 2;    /** @brief External trigger valid edge interrupt enable */
    static const int32_t LPTIM2_IER_ARRMIE_POS       = 1;    /** @brief Autoreload match interrupt enable */
    static const int32_t LPTIM2_IER_CMPMIE_POS       = 0;    /** @brief Compare match interrupt enable */
    static const int32_t LPTIM2_CFGR_ENC_POS         = 24;   /** @brief Encoder mode enable */
    static const int32_t LPTIM2_CFGR_COUNTMODE_POS   = 23;   /** @brief Counter mode enabled */
    static const int32_t LPTIM2_CFGR_PRELOAD_POS     = 22;   /** @brief Registers update mode */
    static const int32_t LPTIM2_CFGR_WAVPOL_POS      = 21;   /** @brief Waveform shape polarity */
    static const int32_t LPTIM2_CFGR_WAVE_POS        = 20;   /** @brief Waveform shape */
    static const int32_t LPTIM2_CFGR_TIMOUT_POS      = 19;   /** @brief Timeout enable */
    static const int32_t LPTIM2_CFGR_TRIGEN_POS      = 17;   /** @brief Trigger enable and polarity */
    static const int32_t LPTIM2_CFGR_TRIGSEL_POS     = 13;   /** @brief Trigger selector */
    static const int32_t LPTIM2_CFGR_PRESC_POS       = 9;    /** @brief Clock prescaler */
    static const int32_t LPTIM2_CFGR_TRGFLT_POS      = 6;    /** @brief Configurable digital filter for trigger */
    static const int32_t LPTIM2_CFGR_CKFLT_POS       = 3;    /** @brief Configurable digital filter for external clock */
    static const int32_t LPTIM2_CFGR_CKPOL_POS       = 1;    /** @brief Clock polarity */
    static const int32_t LPTIM2_CFGR_CKSEL_POS       = 0;    /** @brief Clock selector */
    static const int32_t LPTIM2_CR_ENABLE_POS        = 0;    /** @brief LPTIM enable */
    static const int32_t LPTIM2_CR_SNGSTRT_POS       = 1;    /** @brief LPTIM start in single mode */
    static const int32_t LPTIM2_CR_CNTSTRT_POS       = 2;    /** @brief Timer start in continuous mode */
    static const int32_t LPTIM2_CR_COUNTRST_POS      = 3;    /** @brief Counter reset */
    static const int32_t LPTIM2_CR_RSTARE_POS        = 4;    /** @brief Reset after read enable */
    static const int32_t LPTIM2_CMP_CMP_POS          = 0;    /** @brief Compare value */
    static const int32_t LPTIM2_ARR_ARR_POS          = 0;    /** @brief Auto reload value */
    static const int32_t LPTIM2_CNT_CNT_POS          = 0;    /** @brief Counter value */

    /**** @subsection Enumerated LPTIM2 Register Field Positions ****/

    static const int32_t LPTIM2_CFGR2_INxSEL_POS[3] = {
      [1] = 0,   /** @brief LPTIM input 1 selection */
      [2] = 4,   /** @brief LPTIM input 2 selection */
    };

    /**********************************************************************************************
     * @section LPTIM3 Register Information
     **********************************************************************************************/

    /**** @subsection LPTIM3 Register Pointers ****/

    static RO_ uint32_t* const LPTIM3_ISR_PTR     = (RO_ uint32_t* const)0x58002800U;   /** @brief Interrupt and status register */
    static RW_ uint32_t* const LPTIM3_ICR_PTR     = (RW_ uint32_t* const)0x58002804U;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const LPTIM3_IER_PTR     = (RW_ uint32_t* const)0x58002808U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const LPTIM3_CFGR_PTR    = (RW_ uint32_t* const)0x5800280CU;   /** @brief Configuration register */
    static RW_ uint32_t* const LPTIM3_CR_PTR      = (RW_ uint32_t* const)0x58002810U;   /** @brief Control register */
    static RW_ uint32_t* const LPTIM3_CMP_PTR     = (RW_ uint32_t* const)0x58002814U;   /** @brief Compare register */
    static RW_ uint32_t* const LPTIM3_ARR_PTR     = (RW_ uint32_t* const)0x58002818U;   /** @brief Autoreload register */
    static RO_ uint32_t* const LPTIM3_CNT_PTR     = (RO_ uint32_t* const)0x5800281CU;   /** @brief Counter register */
    static RW_ uint32_t* const LPTIM3_CFGR2_PTR   = (RW_ uint32_t* const)0x58002824U;   /** @brief LPTIM configuration register 2 */

    /**** @subsection LPTIM3 Register Reset Values ****/

    static const uint32_t LPTIM3_ISR_RST     = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t LPTIM3_ICR_RST     = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t LPTIM3_IER_RST     = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t LPTIM3_CFGR_RST    = 0x00000000U;   /** @brief CFGR register reset value. */
    static const uint32_t LPTIM3_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t LPTIM3_CMP_RST     = 0x00000000U;   /** @brief CMP register reset value. */
    static const uint32_t LPTIM3_ARR_RST     = 0x00000001U;   /** @brief ARR register reset value. */
    static const uint32_t LPTIM3_CNT_RST     = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t LPTIM3_CFGR2_RST   = 0x00000000U;   /** @brief CFGR2 register reset value. */

    /**** @subsection Enumerated LPTIM3 Register Value Types ****/

    typedef uint32_t LPTIM3_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t LPTIM3_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t LPTIM3_IER_t;     /** @brief IER register value type. */
    typedef uint32_t LPTIM3_CFGR_t;    /** @brief CFGR register value type. */
    typedef uint32_t LPTIM3_CR_t;      /** @brief CR register value type. */
    typedef uint32_t LPTIM3_CMP_t;     /** @brief CMP register value type. */
    typedef uint32_t LPTIM3_ARR_t;     /** @brief ARR register value type. */
    typedef uint32_t LPTIM3_CNT_t;     /** @brief CNT register value type. */
    typedef uint32_t LPTIM3_CFGR2_t;   /** @brief CFGR2 register value type. */

    /**** @subsection Enumerated LPTIM3 Register Pointer Types ****/

    typedef uint32_t* const LPTIM3_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const LPTIM3_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const LPTIM3_IER_PTR_t;     /** @brief IER register pointer type. */
    typedef uint32_t* const LPTIM3_CFGR_PTR_t;    /** @brief CFGR register pointer type. */
    typedef uint32_t* const LPTIM3_CR_PTR_t;      /** @brief CR register pointer type. */
    typedef uint32_t* const LPTIM3_CMP_PTR_t;     /** @brief CMP register pointer type. */
    typedef uint32_t* const LPTIM3_ARR_PTR_t;     /** @brief ARR register pointer type. */
    typedef uint32_t* const LPTIM3_CNT_PTR_t;     /** @brief CNT register pointer type. */
    typedef uint32_t* const LPTIM3_CFGR2_PTR_t;   /** @brief CFGR2 register pointer type. */

    /**** @subsection LPTIM3 Register Field Masks ****/

    static const uint32_t LPTIM3_ISR_DOWN_MASK         = 0x00000040U;   /** @brief Counter direction change up to down */
    static const uint32_t LPTIM3_ISR_UP_MASK           = 0x00000020U;   /** @brief Counter direction change down to up */
    static const uint32_t LPTIM3_ISR_ARROK_MASK        = 0x00000010U;   /** @brief Autoreload register update OK */
    static const uint32_t LPTIM3_ISR_CMPOK_MASK        = 0x00000008U;   /** @brief Compare register update OK */
    static const uint32_t LPTIM3_ISR_EXTTRIG_MASK      = 0x00000004U;   /** @brief External trigger edge event */
    static const uint32_t LPTIM3_ISR_ARRM_MASK         = 0x00000002U;   /** @brief Autoreload match */
    static const uint32_t LPTIM3_ISR_CMPM_MASK         = 0x00000001U;   /** @brief Compare match */
    static const uint32_t LPTIM3_ICR_DOWNCF_MASK       = 0x00000040U;   /** @brief Direction change to down clear flag */
    static const uint32_t LPTIM3_ICR_UPCF_MASK         = 0x00000020U;   /** @brief Direction change to UP clear flag */
    static const uint32_t LPTIM3_ICR_ARROKCF_MASK      = 0x00000010U;   /** @brief Autoreload register update OK clear flag */
    static const uint32_t LPTIM3_ICR_CMPOKCF_MASK      = 0x00000008U;   /** @brief Compare register update OK clear flag */
    static const uint32_t LPTIM3_ICR_EXTTRIGCF_MASK    = 0x00000004U;   /** @brief External trigger valid edge clear flag */
    static const uint32_t LPTIM3_ICR_ARRMCF_MASK       = 0x00000002U;   /** @brief Autoreload match clear flag */
    static const uint32_t LPTIM3_ICR_CMPMCF_MASK       = 0x00000001U;   /** @brief Compare match clear flag */
    static const uint32_t LPTIM3_IER_DOWNIE_MASK       = 0x00000040U;   /** @brief Direction change to down interrupt enable */
    static const uint32_t LPTIM3_IER_UPIE_MASK         = 0x00000020U;   /** @brief Direction change to UP interrupt enable */
    static const uint32_t LPTIM3_IER_ARROKIE_MASK      = 0x00000010U;   /** @brief Autoreload register update OK interrupt enable */
    static const uint32_t LPTIM3_IER_CMPOKIE_MASK      = 0x00000008U;   /** @brief Compare register update OK interrupt enable */
    static const uint32_t LPTIM3_IER_EXTTRIGIE_MASK    = 0x00000004U;   /** @brief External trigger valid edge interrupt enable */
    static const uint32_t LPTIM3_IER_ARRMIE_MASK       = 0x00000002U;   /** @brief Autoreload match interrupt enable */
    static const uint32_t LPTIM3_IER_CMPMIE_MASK       = 0x00000001U;   /** @brief Compare match interrupt enable */
    static const uint32_t LPTIM3_CFGR_ENC_MASK         = 0x01000000U;   /** @brief Encoder mode enable */
    static const uint32_t LPTIM3_CFGR_COUNTMODE_MASK   = 0x00800000U;   /** @brief Counter mode enabled */
    static const uint32_t LPTIM3_CFGR_PRELOAD_MASK     = 0x00400000U;   /** @brief Registers update mode */
    static const uint32_t LPTIM3_CFGR_WAVPOL_MASK      = 0x00200000U;   /** @brief Waveform shape polarity */
    static const uint32_t LPTIM3_CFGR_WAVE_MASK        = 0x00100000U;   /** @brief Waveform shape */
    static const uint32_t LPTIM3_CFGR_TIMOUT_MASK      = 0x00080000U;   /** @brief Timeout enable */
    static const uint32_t LPTIM3_CFGR_TRIGEN_MASK      = 0x00060000U;   /** @brief Trigger enable and polarity */
    static const uint32_t LPTIM3_CFGR_TRIGSEL_MASK     = 0x0000E000U;   /** @brief Trigger selector */
    static const uint32_t LPTIM3_CFGR_PRESC_MASK       = 0x00000E00U;   /** @brief Clock prescaler */
    static const uint32_t LPTIM3_CFGR_TRGFLT_MASK      = 0x000000C0U;   /** @brief Configurable digital filter for trigger */
    static const uint32_t LPTIM3_CFGR_CKFLT_MASK       = 0x00000018U;   /** @brief Configurable digital filter for external clock */
    static const uint32_t LPTIM3_CFGR_CKPOL_MASK       = 0x00000006U;   /** @brief Clock polarity */
    static const uint32_t LPTIM3_CFGR_CKSEL_MASK       = 0x00000001U;   /** @brief Clock selector */
    static const uint32_t LPTIM3_CR_ENABLE_MASK        = 0x00000001U;   /** @brief LPTIM enable */
    static const uint32_t LPTIM3_CR_SNGSTRT_MASK       = 0x00000002U;   /** @brief LPTIM start in single mode */
    static const uint32_t LPTIM3_CR_CNTSTRT_MASK       = 0x00000004U;   /** @brief Timer start in continuous mode */
    static const uint32_t LPTIM3_CR_COUNTRST_MASK      = 0x00000008U;   /** @brief Counter reset */
    static const uint32_t LPTIM3_CR_RSTARE_MASK        = 0x00000010U;   /** @brief Reset after read enable */
    static const uint32_t LPTIM3_CMP_CMP_MASK          = 0x0000FFFFU;   /** @brief Compare value */
    static const uint32_t LPTIM3_ARR_ARR_MASK          = 0x0000FFFFU;   /** @brief Auto reload value */
    static const uint32_t LPTIM3_CNT_CNT_MASK          = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t LPTIM3_CFGR2_IN1SEL_MASK     = 0x00000003U;   /** @brief LPTIM input 1 selection */

    /**** @subsection LPTIM3 Register Field Positions ****/

    static const int32_t LPTIM3_ISR_DOWN_POS         = 6;    /** @brief Counter direction change up to down */
    static const int32_t LPTIM3_ISR_UP_POS           = 5;    /** @brief Counter direction change down to up */
    static const int32_t LPTIM3_ISR_ARROK_POS        = 4;    /** @brief Autoreload register update OK */
    static const int32_t LPTIM3_ISR_CMPOK_POS        = 3;    /** @brief Compare register update OK */
    static const int32_t LPTIM3_ISR_EXTTRIG_POS      = 2;    /** @brief External trigger edge event */
    static const int32_t LPTIM3_ISR_ARRM_POS         = 1;    /** @brief Autoreload match */
    static const int32_t LPTIM3_ISR_CMPM_POS         = 0;    /** @brief Compare match */
    static const int32_t LPTIM3_ICR_DOWNCF_POS       = 6;    /** @brief Direction change to down clear flag */
    static const int32_t LPTIM3_ICR_UPCF_POS         = 5;    /** @brief Direction change to UP clear flag */
    static const int32_t LPTIM3_ICR_ARROKCF_POS      = 4;    /** @brief Autoreload register update OK clear flag */
    static const int32_t LPTIM3_ICR_CMPOKCF_POS      = 3;    /** @brief Compare register update OK clear flag */
    static const int32_t LPTIM3_ICR_EXTTRIGCF_POS    = 2;    /** @brief External trigger valid edge clear flag */
    static const int32_t LPTIM3_ICR_ARRMCF_POS       = 1;    /** @brief Autoreload match clear flag */
    static const int32_t LPTIM3_ICR_CMPMCF_POS       = 0;    /** @brief Compare match clear flag */
    static const int32_t LPTIM3_IER_DOWNIE_POS       = 6;    /** @brief Direction change to down interrupt enable */
    static const int32_t LPTIM3_IER_UPIE_POS         = 5;    /** @brief Direction change to UP interrupt enable */
    static const int32_t LPTIM3_IER_ARROKIE_POS      = 4;    /** @brief Autoreload register update OK interrupt enable */
    static const int32_t LPTIM3_IER_CMPOKIE_POS      = 3;    /** @brief Compare register update OK interrupt enable */
    static const int32_t LPTIM3_IER_EXTTRIGIE_POS    = 2;    /** @brief External trigger valid edge interrupt enable */
    static const int32_t LPTIM3_IER_ARRMIE_POS       = 1;    /** @brief Autoreload match interrupt enable */
    static const int32_t LPTIM3_IER_CMPMIE_POS       = 0;    /** @brief Compare match interrupt enable */
    static const int32_t LPTIM3_CFGR_ENC_POS         = 24;   /** @brief Encoder mode enable */
    static const int32_t LPTIM3_CFGR_COUNTMODE_POS   = 23;   /** @brief Counter mode enabled */
    static const int32_t LPTIM3_CFGR_PRELOAD_POS     = 22;   /** @brief Registers update mode */
    static const int32_t LPTIM3_CFGR_WAVPOL_POS      = 21;   /** @brief Waveform shape polarity */
    static const int32_t LPTIM3_CFGR_WAVE_POS        = 20;   /** @brief Waveform shape */
    static const int32_t LPTIM3_CFGR_TIMOUT_POS      = 19;   /** @brief Timeout enable */
    static const int32_t LPTIM3_CFGR_TRIGEN_POS      = 17;   /** @brief Trigger enable and polarity */
    static const int32_t LPTIM3_CFGR_TRIGSEL_POS     = 13;   /** @brief Trigger selector */
    static const int32_t LPTIM3_CFGR_PRESC_POS       = 9;    /** @brief Clock prescaler */
    static const int32_t LPTIM3_CFGR_TRGFLT_POS      = 6;    /** @brief Configurable digital filter for trigger */
    static const int32_t LPTIM3_CFGR_CKFLT_POS       = 3;    /** @brief Configurable digital filter for external clock */
    static const int32_t LPTIM3_CFGR_CKPOL_POS       = 1;    /** @brief Clock polarity */
    static const int32_t LPTIM3_CFGR_CKSEL_POS       = 0;    /** @brief Clock selector */
    static const int32_t LPTIM3_CR_ENABLE_POS        = 0;    /** @brief LPTIM enable */
    static const int32_t LPTIM3_CR_SNGSTRT_POS       = 1;    /** @brief LPTIM start in single mode */
    static const int32_t LPTIM3_CR_CNTSTRT_POS       = 2;    /** @brief Timer start in continuous mode */
    static const int32_t LPTIM3_CR_COUNTRST_POS      = 3;    /** @brief Counter reset */
    static const int32_t LPTIM3_CR_RSTARE_POS        = 4;    /** @brief Reset after read enable */
    static const int32_t LPTIM3_CMP_CMP_POS          = 0;    /** @brief Compare value */
    static const int32_t LPTIM3_ARR_ARR_POS          = 0;    /** @brief Auto reload value */
    static const int32_t LPTIM3_CNT_CNT_POS          = 0;    /** @brief Counter value */
    static const int32_t LPTIM3_CFGR2_IN1SEL_POS     = 0;    /** @brief LPTIM input 1 selection */

    /**********************************************************************************************
     * @section LPTIM4 Register Information
     **********************************************************************************************/

    /**** @subsection LPTIM4 Register Pointers ****/

    static RO_ uint32_t* const LPTIM4_ISR_PTR     = (RO_ uint32_t* const)0x58002C00U;   /** @brief Interrupt and status register */
    static RW_ uint32_t* const LPTIM4_ICR_PTR     = (RW_ uint32_t* const)0x58002C04U;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const LPTIM4_IER_PTR     = (RW_ uint32_t* const)0x58002C08U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const LPTIM4_CFGR_PTR    = (RW_ uint32_t* const)0x58002C0CU;   /** @brief Configuration register */
    static RW_ uint32_t* const LPTIM4_CR_PTR      = (RW_ uint32_t* const)0x58002C10U;   /** @brief Control register */
    static RW_ uint32_t* const LPTIM4_CMP_PTR     = (RW_ uint32_t* const)0x58002C14U;   /** @brief Compare register */
    static RW_ uint32_t* const LPTIM4_ARR_PTR     = (RW_ uint32_t* const)0x58002C18U;   /** @brief Autoreload register */
    static RO_ uint32_t* const LPTIM4_CNT_PTR     = (RO_ uint32_t* const)0x58002C1CU;   /** @brief Counter register */
    static RW_ uint32_t* const LPTIM4_CFGR2_PTR   = (RW_ uint32_t* const)0x58002C24U;   /** @brief LPTIM configuration register 2 */

    /**** @subsection LPTIM4 Register Reset Values ****/

    static const uint32_t LPTIM4_ISR_RST     = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t LPTIM4_ICR_RST     = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t LPTIM4_IER_RST     = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t LPTIM4_CFGR_RST    = 0x00000000U;   /** @brief CFGR register reset value. */
    static const uint32_t LPTIM4_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t LPTIM4_CMP_RST     = 0x00000000U;   /** @brief CMP register reset value. */
    static const uint32_t LPTIM4_ARR_RST     = 0x00000001U;   /** @brief ARR register reset value. */
    static const uint32_t LPTIM4_CNT_RST     = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t LPTIM4_CFGR2_RST   = 0x00000000U;   /** @brief CFGR2 register reset value. */

    /**** @subsection Enumerated LPTIM4 Register Value Types ****/

    typedef uint32_t LPTIM4_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t LPTIM4_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t LPTIM4_IER_t;     /** @brief IER register value type. */
    typedef uint32_t LPTIM4_CFGR_t;    /** @brief CFGR register value type. */
    typedef uint32_t LPTIM4_CR_t;      /** @brief CR register value type. */
    typedef uint32_t LPTIM4_CMP_t;     /** @brief CMP register value type. */
    typedef uint32_t LPTIM4_ARR_t;     /** @brief ARR register value type. */
    typedef uint32_t LPTIM4_CNT_t;     /** @brief CNT register value type. */
    typedef uint32_t LPTIM4_CFGR2_t;   /** @brief CFGR2 register value type. */

    /**** @subsection Enumerated LPTIM4 Register Pointer Types ****/

    typedef uint32_t* const LPTIM4_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const LPTIM4_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const LPTIM4_IER_PTR_t;     /** @brief IER register pointer type. */
    typedef uint32_t* const LPTIM4_CFGR_PTR_t;    /** @brief CFGR register pointer type. */
    typedef uint32_t* const LPTIM4_CR_PTR_t;      /** @brief CR register pointer type. */
    typedef uint32_t* const LPTIM4_CMP_PTR_t;     /** @brief CMP register pointer type. */
    typedef uint32_t* const LPTIM4_ARR_PTR_t;     /** @brief ARR register pointer type. */
    typedef uint32_t* const LPTIM4_CNT_PTR_t;     /** @brief CNT register pointer type. */
    typedef uint32_t* const LPTIM4_CFGR2_PTR_t;   /** @brief CFGR2 register pointer type. */

    /**** @subsection LPTIM4 Register Field Masks ****/

    static const uint32_t LPTIM4_ISR_DOWN_MASK         = 0x00000040U;   /** @brief Counter direction change up to down */
    static const uint32_t LPTIM4_ISR_UP_MASK           = 0x00000020U;   /** @brief Counter direction change down to up */
    static const uint32_t LPTIM4_ISR_ARROK_MASK        = 0x00000010U;   /** @brief Autoreload register update OK */
    static const uint32_t LPTIM4_ISR_CMPOK_MASK        = 0x00000008U;   /** @brief Compare register update OK */
    static const uint32_t LPTIM4_ISR_EXTTRIG_MASK      = 0x00000004U;   /** @brief External trigger edge event */
    static const uint32_t LPTIM4_ISR_ARRM_MASK         = 0x00000002U;   /** @brief Autoreload match */
    static const uint32_t LPTIM4_ISR_CMPM_MASK         = 0x00000001U;   /** @brief Compare match */
    static const uint32_t LPTIM4_ICR_DOWNCF_MASK       = 0x00000040U;   /** @brief Direction change to down clear flag */
    static const uint32_t LPTIM4_ICR_UPCF_MASK         = 0x00000020U;   /** @brief Direction change to UP clear flag */
    static const uint32_t LPTIM4_ICR_ARROKCF_MASK      = 0x00000010U;   /** @brief Autoreload register update OK clear flag */
    static const uint32_t LPTIM4_ICR_CMPOKCF_MASK      = 0x00000008U;   /** @brief Compare register update OK clear flag */
    static const uint32_t LPTIM4_ICR_EXTTRIGCF_MASK    = 0x00000004U;   /** @brief External trigger valid edge clear flag */
    static const uint32_t LPTIM4_ICR_ARRMCF_MASK       = 0x00000002U;   /** @brief Autoreload match clear flag */
    static const uint32_t LPTIM4_ICR_CMPMCF_MASK       = 0x00000001U;   /** @brief Compare match clear flag */
    static const uint32_t LPTIM4_IER_DOWNIE_MASK       = 0x00000040U;   /** @brief Direction change to down interrupt enable */
    static const uint32_t LPTIM4_IER_UPIE_MASK         = 0x00000020U;   /** @brief Direction change to UP interrupt enable */
    static const uint32_t LPTIM4_IER_ARROKIE_MASK      = 0x00000010U;   /** @brief Autoreload register update OK interrupt enable */
    static const uint32_t LPTIM4_IER_CMPOKIE_MASK      = 0x00000008U;   /** @brief Compare register update OK interrupt enable */
    static const uint32_t LPTIM4_IER_EXTTRIGIE_MASK    = 0x00000004U;   /** @brief External trigger valid edge interrupt enable */
    static const uint32_t LPTIM4_IER_ARRMIE_MASK       = 0x00000002U;   /** @brief Autoreload match interrupt enable */
    static const uint32_t LPTIM4_IER_CMPMIE_MASK       = 0x00000001U;   /** @brief Compare match interrupt enable */
    static const uint32_t LPTIM4_CFGR_ENC_MASK         = 0x01000000U;   /** @brief Encoder mode enable */
    static const uint32_t LPTIM4_CFGR_COUNTMODE_MASK   = 0x00800000U;   /** @brief Counter mode enabled */
    static const uint32_t LPTIM4_CFGR_PRELOAD_MASK     = 0x00400000U;   /** @brief Registers update mode */
    static const uint32_t LPTIM4_CFGR_WAVPOL_MASK      = 0x00200000U;   /** @brief Waveform shape polarity */
    static const uint32_t LPTIM4_CFGR_WAVE_MASK        = 0x00100000U;   /** @brief Waveform shape */
    static const uint32_t LPTIM4_CFGR_TIMOUT_MASK      = 0x00080000U;   /** @brief Timeout enable */
    static const uint32_t LPTIM4_CFGR_TRIGEN_MASK      = 0x00060000U;   /** @brief Trigger enable and polarity */
    static const uint32_t LPTIM4_CFGR_TRIGSEL_MASK     = 0x0000E000U;   /** @brief Trigger selector */
    static const uint32_t LPTIM4_CFGR_PRESC_MASK       = 0x00000E00U;   /** @brief Clock prescaler */
    static const uint32_t LPTIM4_CFGR_TRGFLT_MASK      = 0x000000C0U;   /** @brief Configurable digital filter for trigger */
    static const uint32_t LPTIM4_CFGR_CKFLT_MASK       = 0x00000018U;   /** @brief Configurable digital filter for external clock */
    static const uint32_t LPTIM4_CFGR_CKPOL_MASK       = 0x00000006U;   /** @brief Clock polarity */
    static const uint32_t LPTIM4_CFGR_CKSEL_MASK       = 0x00000001U;   /** @brief Clock selector */
    static const uint32_t LPTIM4_CR_ENABLE_MASK        = 0x00000001U;   /** @brief LPTIM enable */
    static const uint32_t LPTIM4_CR_SNGSTRT_MASK       = 0x00000002U;   /** @brief LPTIM start in single mode */
    static const uint32_t LPTIM4_CR_CNTSTRT_MASK       = 0x00000004U;   /** @brief Timer start in continuous mode */
    static const uint32_t LPTIM4_CR_COUNTRST_MASK      = 0x00000008U;   /** @brief Counter reset */
    static const uint32_t LPTIM4_CR_RSTARE_MASK        = 0x00000010U;   /** @brief Reset after read enable */
    static const uint32_t LPTIM4_CMP_CMP_MASK          = 0x0000FFFFU;   /** @brief Compare value */
    static const uint32_t LPTIM4_ARR_ARR_MASK          = 0x0000FFFFU;   /** @brief Auto reload value */
    static const uint32_t LPTIM4_CNT_CNT_MASK          = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t LPTIM4_CFGR2_IN1SEL_MASK     = 0x00000003U;   /** @brief LPTIM input 1 selection */

    /**** @subsection LPTIM4 Register Field Positions ****/

    static const int32_t LPTIM4_ISR_DOWN_POS         = 6;    /** @brief Counter direction change up to down */
    static const int32_t LPTIM4_ISR_UP_POS           = 5;    /** @brief Counter direction change down to up */
    static const int32_t LPTIM4_ISR_ARROK_POS        = 4;    /** @brief Autoreload register update OK */
    static const int32_t LPTIM4_ISR_CMPOK_POS        = 3;    /** @brief Compare register update OK */
    static const int32_t LPTIM4_ISR_EXTTRIG_POS      = 2;    /** @brief External trigger edge event */
    static const int32_t LPTIM4_ISR_ARRM_POS         = 1;    /** @brief Autoreload match */
    static const int32_t LPTIM4_ISR_CMPM_POS         = 0;    /** @brief Compare match */
    static const int32_t LPTIM4_ICR_DOWNCF_POS       = 6;    /** @brief Direction change to down clear flag */
    static const int32_t LPTIM4_ICR_UPCF_POS         = 5;    /** @brief Direction change to UP clear flag */
    static const int32_t LPTIM4_ICR_ARROKCF_POS      = 4;    /** @brief Autoreload register update OK clear flag */
    static const int32_t LPTIM4_ICR_CMPOKCF_POS      = 3;    /** @brief Compare register update OK clear flag */
    static const int32_t LPTIM4_ICR_EXTTRIGCF_POS    = 2;    /** @brief External trigger valid edge clear flag */
    static const int32_t LPTIM4_ICR_ARRMCF_POS       = 1;    /** @brief Autoreload match clear flag */
    static const int32_t LPTIM4_ICR_CMPMCF_POS       = 0;    /** @brief Compare match clear flag */
    static const int32_t LPTIM4_IER_DOWNIE_POS       = 6;    /** @brief Direction change to down interrupt enable */
    static const int32_t LPTIM4_IER_UPIE_POS         = 5;    /** @brief Direction change to UP interrupt enable */
    static const int32_t LPTIM4_IER_ARROKIE_POS      = 4;    /** @brief Autoreload register update OK interrupt enable */
    static const int32_t LPTIM4_IER_CMPOKIE_POS      = 3;    /** @brief Compare register update OK interrupt enable */
    static const int32_t LPTIM4_IER_EXTTRIGIE_POS    = 2;    /** @brief External trigger valid edge interrupt enable */
    static const int32_t LPTIM4_IER_ARRMIE_POS       = 1;    /** @brief Autoreload match interrupt enable */
    static const int32_t LPTIM4_IER_CMPMIE_POS       = 0;    /** @brief Compare match interrupt enable */
    static const int32_t LPTIM4_CFGR_ENC_POS         = 24;   /** @brief Encoder mode enable */
    static const int32_t LPTIM4_CFGR_COUNTMODE_POS   = 23;   /** @brief Counter mode enabled */
    static const int32_t LPTIM4_CFGR_PRELOAD_POS     = 22;   /** @brief Registers update mode */
    static const int32_t LPTIM4_CFGR_WAVPOL_POS      = 21;   /** @brief Waveform shape polarity */
    static const int32_t LPTIM4_CFGR_WAVE_POS        = 20;   /** @brief Waveform shape */
    static const int32_t LPTIM4_CFGR_TIMOUT_POS      = 19;   /** @brief Timeout enable */
    static const int32_t LPTIM4_CFGR_TRIGEN_POS      = 17;   /** @brief Trigger enable and polarity */
    static const int32_t LPTIM4_CFGR_TRIGSEL_POS     = 13;   /** @brief Trigger selector */
    static const int32_t LPTIM4_CFGR_PRESC_POS       = 9;    /** @brief Clock prescaler */
    static const int32_t LPTIM4_CFGR_TRGFLT_POS      = 6;    /** @brief Configurable digital filter for trigger */
    static const int32_t LPTIM4_CFGR_CKFLT_POS       = 3;    /** @brief Configurable digital filter for external clock */
    static const int32_t LPTIM4_CFGR_CKPOL_POS       = 1;    /** @brief Clock polarity */
    static const int32_t LPTIM4_CFGR_CKSEL_POS       = 0;    /** @brief Clock selector */
    static const int32_t LPTIM4_CR_ENABLE_POS        = 0;    /** @brief LPTIM enable */
    static const int32_t LPTIM4_CR_SNGSTRT_POS       = 1;    /** @brief LPTIM start in single mode */
    static const int32_t LPTIM4_CR_CNTSTRT_POS       = 2;    /** @brief Timer start in continuous mode */
    static const int32_t LPTIM4_CR_COUNTRST_POS      = 3;    /** @brief Counter reset */
    static const int32_t LPTIM4_CR_RSTARE_POS        = 4;    /** @brief Reset after read enable */
    static const int32_t LPTIM4_CMP_CMP_POS          = 0;    /** @brief Compare value */
    static const int32_t LPTIM4_ARR_ARR_POS          = 0;    /** @brief Auto reload value */
    static const int32_t LPTIM4_CNT_CNT_POS          = 0;    /** @brief Counter value */
    static const int32_t LPTIM4_CFGR2_IN1SEL_POS     = 0;    /** @brief LPTIM input 1 selection */

    /**********************************************************************************************
     * @section LPTIM5 Register Information
     **********************************************************************************************/

    /**** @subsection LPTIM5 Register Pointers ****/

    static RO_ uint32_t* const LPTIM5_ISR_PTR     = (RO_ uint32_t* const)0x58003000U;   /** @brief Interrupt and status register */
    static RW_ uint32_t* const LPTIM5_ICR_PTR     = (RW_ uint32_t* const)0x58003004U;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const LPTIM5_IER_PTR     = (RW_ uint32_t* const)0x58003008U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const LPTIM5_CFGR_PTR    = (RW_ uint32_t* const)0x5800300CU;   /** @brief Configuration register */
    static RW_ uint32_t* const LPTIM5_CR_PTR      = (RW_ uint32_t* const)0x58003010U;   /** @brief Control register */
    static RW_ uint32_t* const LPTIM5_CMP_PTR     = (RW_ uint32_t* const)0x58003014U;   /** @brief Compare register */
    static RW_ uint32_t* const LPTIM5_ARR_PTR     = (RW_ uint32_t* const)0x58003018U;   /** @brief Autoreload register */
    static RO_ uint32_t* const LPTIM5_CNT_PTR     = (RO_ uint32_t* const)0x5800301CU;   /** @brief Counter register */
    static RW_ uint32_t* const LPTIM5_CFGR2_PTR   = (RW_ uint32_t* const)0x58003024U;   /** @brief LPTIM configuration register 2 */

    /**** @subsection LPTIM5 Register Reset Values ****/

    static const uint32_t LPTIM5_ISR_RST     = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t LPTIM5_ICR_RST     = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t LPTIM5_IER_RST     = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t LPTIM5_CFGR_RST    = 0x00000000U;   /** @brief CFGR register reset value. */
    static const uint32_t LPTIM5_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t LPTIM5_CMP_RST     = 0x00000000U;   /** @brief CMP register reset value. */
    static const uint32_t LPTIM5_ARR_RST     = 0x00000001U;   /** @brief ARR register reset value. */
    static const uint32_t LPTIM5_CNT_RST     = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t LPTIM5_CFGR2_RST   = 0x00000000U;   /** @brief CFGR2 register reset value. */

    /**** @subsection Enumerated LPTIM5 Register Value Types ****/

    typedef uint32_t LPTIM5_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t LPTIM5_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t LPTIM5_IER_t;     /** @brief IER register value type. */
    typedef uint32_t LPTIM5_CFGR_t;    /** @brief CFGR register value type. */
    typedef uint32_t LPTIM5_CR_t;      /** @brief CR register value type. */
    typedef uint32_t LPTIM5_CMP_t;     /** @brief CMP register value type. */
    typedef uint32_t LPTIM5_ARR_t;     /** @brief ARR register value type. */
    typedef uint32_t LPTIM5_CNT_t;     /** @brief CNT register value type. */
    typedef uint32_t LPTIM5_CFGR2_t;   /** @brief CFGR2 register value type. */

    /**** @subsection Enumerated LPTIM5 Register Pointer Types ****/

    typedef uint32_t* const LPTIM5_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const LPTIM5_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const LPTIM5_IER_PTR_t;     /** @brief IER register pointer type. */
    typedef uint32_t* const LPTIM5_CFGR_PTR_t;    /** @brief CFGR register pointer type. */
    typedef uint32_t* const LPTIM5_CR_PTR_t;      /** @brief CR register pointer type. */
    typedef uint32_t* const LPTIM5_CMP_PTR_t;     /** @brief CMP register pointer type. */
    typedef uint32_t* const LPTIM5_ARR_PTR_t;     /** @brief ARR register pointer type. */
    typedef uint32_t* const LPTIM5_CNT_PTR_t;     /** @brief CNT register pointer type. */
    typedef uint32_t* const LPTIM5_CFGR2_PTR_t;   /** @brief CFGR2 register pointer type. */

    /**** @subsection LPTIM5 Register Field Masks ****/

    static const uint32_t LPTIM5_ISR_DOWN_MASK         = 0x00000040U;   /** @brief Counter direction change up to down */
    static const uint32_t LPTIM5_ISR_UP_MASK           = 0x00000020U;   /** @brief Counter direction change down to up */
    static const uint32_t LPTIM5_ISR_ARROK_MASK        = 0x00000010U;   /** @brief Autoreload register update OK */
    static const uint32_t LPTIM5_ISR_CMPOK_MASK        = 0x00000008U;   /** @brief Compare register update OK */
    static const uint32_t LPTIM5_ISR_EXTTRIG_MASK      = 0x00000004U;   /** @brief External trigger edge event */
    static const uint32_t LPTIM5_ISR_ARRM_MASK         = 0x00000002U;   /** @brief Autoreload match */
    static const uint32_t LPTIM5_ISR_CMPM_MASK         = 0x00000001U;   /** @brief Compare match */
    static const uint32_t LPTIM5_ICR_DOWNCF_MASK       = 0x00000040U;   /** @brief Direction change to down clear flag */
    static const uint32_t LPTIM5_ICR_UPCF_MASK         = 0x00000020U;   /** @brief Direction change to UP clear flag */
    static const uint32_t LPTIM5_ICR_ARROKCF_MASK      = 0x00000010U;   /** @brief Autoreload register update OK clear flag */
    static const uint32_t LPTIM5_ICR_CMPOKCF_MASK      = 0x00000008U;   /** @brief Compare register update OK clear flag */
    static const uint32_t LPTIM5_ICR_EXTTRIGCF_MASK    = 0x00000004U;   /** @brief External trigger valid edge clear flag */
    static const uint32_t LPTIM5_ICR_ARRMCF_MASK       = 0x00000002U;   /** @brief Autoreload match clear flag */
    static const uint32_t LPTIM5_ICR_CMPMCF_MASK       = 0x00000001U;   /** @brief Compare match clear flag */
    static const uint32_t LPTIM5_IER_DOWNIE_MASK       = 0x00000040U;   /** @brief Direction change to down interrupt enable */
    static const uint32_t LPTIM5_IER_UPIE_MASK         = 0x00000020U;   /** @brief Direction change to UP interrupt enable */
    static const uint32_t LPTIM5_IER_ARROKIE_MASK      = 0x00000010U;   /** @brief Autoreload register update OK interrupt enable */
    static const uint32_t LPTIM5_IER_CMPOKIE_MASK      = 0x00000008U;   /** @brief Compare register update OK interrupt enable */
    static const uint32_t LPTIM5_IER_EXTTRIGIE_MASK    = 0x00000004U;   /** @brief External trigger valid edge interrupt enable */
    static const uint32_t LPTIM5_IER_ARRMIE_MASK       = 0x00000002U;   /** @brief Autoreload match interrupt enable */
    static const uint32_t LPTIM5_IER_CMPMIE_MASK       = 0x00000001U;   /** @brief Compare match interrupt enable */
    static const uint32_t LPTIM5_CFGR_ENC_MASK         = 0x01000000U;   /** @brief Encoder mode enable */
    static const uint32_t LPTIM5_CFGR_COUNTMODE_MASK   = 0x00800000U;   /** @brief Counter mode enabled */
    static const uint32_t LPTIM5_CFGR_PRELOAD_MASK     = 0x00400000U;   /** @brief Registers update mode */
    static const uint32_t LPTIM5_CFGR_WAVPOL_MASK      = 0x00200000U;   /** @brief Waveform shape polarity */
    static const uint32_t LPTIM5_CFGR_WAVE_MASK        = 0x00100000U;   /** @brief Waveform shape */
    static const uint32_t LPTIM5_CFGR_TIMOUT_MASK      = 0x00080000U;   /** @brief Timeout enable */
    static const uint32_t LPTIM5_CFGR_TRIGEN_MASK      = 0x00060000U;   /** @brief Trigger enable and polarity */
    static const uint32_t LPTIM5_CFGR_TRIGSEL_MASK     = 0x0000E000U;   /** @brief Trigger selector */
    static const uint32_t LPTIM5_CFGR_PRESC_MASK       = 0x00000E00U;   /** @brief Clock prescaler */
    static const uint32_t LPTIM5_CFGR_TRGFLT_MASK      = 0x000000C0U;   /** @brief Configurable digital filter for trigger */
    static const uint32_t LPTIM5_CFGR_CKFLT_MASK       = 0x00000018U;   /** @brief Configurable digital filter for external clock */
    static const uint32_t LPTIM5_CFGR_CKPOL_MASK       = 0x00000006U;   /** @brief Clock polarity */
    static const uint32_t LPTIM5_CFGR_CKSEL_MASK       = 0x00000001U;   /** @brief Clock selector */
    static const uint32_t LPTIM5_CR_ENABLE_MASK        = 0x00000001U;   /** @brief LPTIM enable */
    static const uint32_t LPTIM5_CR_SNGSTRT_MASK       = 0x00000002U;   /** @brief LPTIM start in single mode */
    static const uint32_t LPTIM5_CR_CNTSTRT_MASK       = 0x00000004U;   /** @brief Timer start in continuous mode */
    static const uint32_t LPTIM5_CR_COUNTRST_MASK      = 0x00000008U;   /** @brief Counter reset */
    static const uint32_t LPTIM5_CR_RSTARE_MASK        = 0x00000010U;   /** @brief Reset after read enable */
    static const uint32_t LPTIM5_CMP_CMP_MASK          = 0x0000FFFFU;   /** @brief Compare value */
    static const uint32_t LPTIM5_ARR_ARR_MASK          = 0x0000FFFFU;   /** @brief Auto reload value */
    static const uint32_t LPTIM5_CNT_CNT_MASK          = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t LPTIM5_CFGR2_IN1SEL_MASK     = 0x00000003U;   /** @brief LPTIM input 1 selection */

    /**** @subsection LPTIM5 Register Field Positions ****/

    static const int32_t LPTIM5_ISR_DOWN_POS         = 6;    /** @brief Counter direction change up to down */
    static const int32_t LPTIM5_ISR_UP_POS           = 5;    /** @brief Counter direction change down to up */
    static const int32_t LPTIM5_ISR_ARROK_POS        = 4;    /** @brief Autoreload register update OK */
    static const int32_t LPTIM5_ISR_CMPOK_POS        = 3;    /** @brief Compare register update OK */
    static const int32_t LPTIM5_ISR_EXTTRIG_POS      = 2;    /** @brief External trigger edge event */
    static const int32_t LPTIM5_ISR_ARRM_POS         = 1;    /** @brief Autoreload match */
    static const int32_t LPTIM5_ISR_CMPM_POS         = 0;    /** @brief Compare match */
    static const int32_t LPTIM5_ICR_DOWNCF_POS       = 6;    /** @brief Direction change to down clear flag */
    static const int32_t LPTIM5_ICR_UPCF_POS         = 5;    /** @brief Direction change to UP clear flag */
    static const int32_t LPTIM5_ICR_ARROKCF_POS      = 4;    /** @brief Autoreload register update OK clear flag */
    static const int32_t LPTIM5_ICR_CMPOKCF_POS      = 3;    /** @brief Compare register update OK clear flag */
    static const int32_t LPTIM5_ICR_EXTTRIGCF_POS    = 2;    /** @brief External trigger valid edge clear flag */
    static const int32_t LPTIM5_ICR_ARRMCF_POS       = 1;    /** @brief Autoreload match clear flag */
    static const int32_t LPTIM5_ICR_CMPMCF_POS       = 0;    /** @brief Compare match clear flag */
    static const int32_t LPTIM5_IER_DOWNIE_POS       = 6;    /** @brief Direction change to down interrupt enable */
    static const int32_t LPTIM5_IER_UPIE_POS         = 5;    /** @brief Direction change to UP interrupt enable */
    static const int32_t LPTIM5_IER_ARROKIE_POS      = 4;    /** @brief Autoreload register update OK interrupt enable */
    static const int32_t LPTIM5_IER_CMPOKIE_POS      = 3;    /** @brief Compare register update OK interrupt enable */
    static const int32_t LPTIM5_IER_EXTTRIGIE_POS    = 2;    /** @brief External trigger valid edge interrupt enable */
    static const int32_t LPTIM5_IER_ARRMIE_POS       = 1;    /** @brief Autoreload match interrupt enable */
    static const int32_t LPTIM5_IER_CMPMIE_POS       = 0;    /** @brief Compare match interrupt enable */
    static const int32_t LPTIM5_CFGR_ENC_POS         = 24;   /** @brief Encoder mode enable */
    static const int32_t LPTIM5_CFGR_COUNTMODE_POS   = 23;   /** @brief Counter mode enabled */
    static const int32_t LPTIM5_CFGR_PRELOAD_POS     = 22;   /** @brief Registers update mode */
    static const int32_t LPTIM5_CFGR_WAVPOL_POS      = 21;   /** @brief Waveform shape polarity */
    static const int32_t LPTIM5_CFGR_WAVE_POS        = 20;   /** @brief Waveform shape */
    static const int32_t LPTIM5_CFGR_TIMOUT_POS      = 19;   /** @brief Timeout enable */
    static const int32_t LPTIM5_CFGR_TRIGEN_POS      = 17;   /** @brief Trigger enable and polarity */
    static const int32_t LPTIM5_CFGR_TRIGSEL_POS     = 13;   /** @brief Trigger selector */
    static const int32_t LPTIM5_CFGR_PRESC_POS       = 9;    /** @brief Clock prescaler */
    static const int32_t LPTIM5_CFGR_TRGFLT_POS      = 6;    /** @brief Configurable digital filter for trigger */
    static const int32_t LPTIM5_CFGR_CKFLT_POS       = 3;    /** @brief Configurable digital filter for external clock */
    static const int32_t LPTIM5_CFGR_CKPOL_POS       = 1;    /** @brief Clock polarity */
    static const int32_t LPTIM5_CFGR_CKSEL_POS       = 0;    /** @brief Clock selector */
    static const int32_t LPTIM5_CR_ENABLE_POS        = 0;    /** @brief LPTIM enable */
    static const int32_t LPTIM5_CR_SNGSTRT_POS       = 1;    /** @brief LPTIM start in single mode */
    static const int32_t LPTIM5_CR_CNTSTRT_POS       = 2;    /** @brief Timer start in continuous mode */
    static const int32_t LPTIM5_CR_COUNTRST_POS      = 3;    /** @brief Counter reset */
    static const int32_t LPTIM5_CR_RSTARE_POS        = 4;    /** @brief Reset after read enable */
    static const int32_t LPTIM5_CMP_CMP_POS          = 0;    /** @brief Compare value */
    static const int32_t LPTIM5_ARR_ARR_POS          = 0;    /** @brief Auto reload value */
    static const int32_t LPTIM5_CNT_CNT_POS          = 0;    /** @brief Counter value */
    static const int32_t LPTIM5_CFGR2_IN1SEL_POS     = 0;    /** @brief LPTIM input 1 selection */

    /**********************************************************************************************
     * @section LPUART1 Register Information
     **********************************************************************************************/

    /**** @subsection LPUART1 Register Pointers ****/

    static RW_ uint32_t* const LPUART1_CR1_PTR     = (RW_ uint32_t* const)0x58000C00U;   /** @brief Control register 1 */
    static RW_ uint32_t* const LPUART1_CR2_PTR     = (RW_ uint32_t* const)0x58000C04U;   /** @brief Control register 2 */
    static RW_ uint32_t* const LPUART1_CR3_PTR     = (RW_ uint32_t* const)0x58000C08U;   /** @brief Control register 3 */
    static RW_ uint32_t* const LPUART1_BRR_PTR     = (RW_ uint32_t* const)0x58000C0CU;   /** @brief Baud rate register */
    static RW_ uint32_t* const LPUART1_GTPR_PTR    = (RW_ uint32_t* const)0x58000C10U;   /** @brief Guard time and prescaler register */
    static RW_ uint32_t* const LPUART1_RTOR_PTR    = (RW_ uint32_t* const)0x58000C14U;   /** @brief Receiver timeout register */
    static RW_ uint32_t* const LPUART1_RQR_PTR     = (RW_ uint32_t* const)0x58000C18U;   /** @brief Request register */
    static RO_ uint32_t* const LPUART1_ISR_PTR     = (RO_ uint32_t* const)0x58000C1CU;   /** @brief Interrupt & status register */
    static RW_ uint32_t* const LPUART1_ICR_PTR     = (RW_ uint32_t* const)0x58000C20U;   /** @brief Interrupt flag clear register */
    static RO_ uint32_t* const LPUART1_RDR_PTR     = (RO_ uint32_t* const)0x58000C24U;   /** @brief Receive data register */
    static RW_ uint32_t* const LPUART1_TDR_PTR     = (RW_ uint32_t* const)0x58000C28U;   /** @brief Transmit data register */
    static RW_ uint32_t* const LPUART1_PRESC_PTR   = (RW_ uint32_t* const)0x58000C2CU;   /** @brief Prescaler register */

    /**** @subsection LPUART1 Register Reset Values ****/

    static const uint32_t LPUART1_CR1_RST     = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t LPUART1_CR2_RST     = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t LPUART1_CR3_RST     = 0x00000000U;   /** @brief CR3 register reset value. */
    static const uint32_t LPUART1_BRR_RST     = 0x00000000U;   /** @brief BRR register reset value. */
    static const uint32_t LPUART1_GTPR_RST    = 0x00000000U;   /** @brief GTPR register reset value. */
    static const uint32_t LPUART1_RTOR_RST    = 0x00000000U;   /** @brief RTOR register reset value. */
    static const uint32_t LPUART1_RQR_RST     = 0x00000000U;   /** @brief RQR register reset value. */
    static const uint32_t LPUART1_ISR_RST     = 0x000000C0U;   /** @brief ISR register reset value. */
    static const uint32_t LPUART1_ICR_RST     = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t LPUART1_RDR_RST     = 0x00000000U;   /** @brief RDR register reset value. */
    static const uint32_t LPUART1_TDR_RST     = 0x00000000U;   /** @brief TDR register reset value. */
    static const uint32_t LPUART1_PRESC_RST   = 0x00000000U;   /** @brief PRESC register reset value. */

    /**** @subsection Enumerated LPUART1 Register Value Types ****/

    typedef uint32_t LPUART1_CR1_t;     /** @brief CR1 register value type. */
    typedef uint32_t LPUART1_CR2_t;     /** @brief CR2 register value type. */
    typedef uint32_t LPUART1_CR3_t;     /** @brief CR3 register value type. */
    typedef uint32_t LPUART1_BRR_t;     /** @brief BRR register value type. */
    typedef uint32_t LPUART1_GTPR_t;    /** @brief GTPR register value type. */
    typedef uint32_t LPUART1_RTOR_t;    /** @brief RTOR register value type. */
    typedef uint32_t LPUART1_RQR_t;     /** @brief RQR register value type. */
    typedef uint32_t LPUART1_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t LPUART1_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t LPUART1_RDR_t;     /** @brief RDR register value type. */
    typedef uint32_t LPUART1_TDR_t;     /** @brief TDR register value type. */
    typedef uint32_t LPUART1_PRESC_t;   /** @brief PRESC register value type. */

    /**** @subsection Enumerated LPUART1 Register Pointer Types ****/

    typedef uint32_t* const LPUART1_CR1_PTR_t;     /** @brief CR1 register pointer type. */
    typedef uint32_t* const LPUART1_CR2_PTR_t;     /** @brief CR2 register pointer type. */
    typedef uint32_t* const LPUART1_CR3_PTR_t;     /** @brief CR3 register pointer type. */
    typedef uint32_t* const LPUART1_BRR_PTR_t;     /** @brief BRR register pointer type. */
    typedef uint32_t* const LPUART1_GTPR_PTR_t;    /** @brief GTPR register pointer type. */
    typedef uint32_t* const LPUART1_RTOR_PTR_t;    /** @brief RTOR register pointer type. */
    typedef uint32_t* const LPUART1_RQR_PTR_t;     /** @brief RQR register pointer type. */
    typedef uint32_t* const LPUART1_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const LPUART1_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const LPUART1_RDR_PTR_t;     /** @brief RDR register pointer type. */
    typedef uint32_t* const LPUART1_TDR_PTR_t;     /** @brief TDR register pointer type. */
    typedef uint32_t* const LPUART1_PRESC_PTR_t;   /** @brief PRESC register pointer type. */

    /**** @subsection LPUART1 Register Field Masks ****/

    static const uint32_t LPUART1_CR1_RXFFIE_MASK        = 0x80000000U;   /** @brief RXFIFO full interrupt enable */
    static const uint32_t LPUART1_CR1_TXFEIE_MASK        = 0x40000000U;   /** @brief TXFIFO empty interrupt enable */
    static const uint32_t LPUART1_CR1_FIFOEN_MASK        = 0x20000000U;   /** @brief FIFO mode enable */
    static const uint32_t LPUART1_CR1_DEAT_MASK          = 0x03E00000U;   /** @brief Driver enable assertion time */
    static const uint32_t LPUART1_CR1_DEDT_MASK          = 0x001F0000U;   /** @brief Driver enable deassertion time */
    static const uint32_t LPUART1_CR1_CMIE_MASK          = 0x00004000U;   /** @brief Character match interrupt enable */
    static const uint32_t LPUART1_CR1_MME_MASK           = 0x00002000U;   /** @brief Mute mode enable */
    static const uint32_t LPUART1_CR1_WAKE_MASK          = 0x00000800U;   /** @brief Receiver wakeup method */
    static const uint32_t LPUART1_CR1_PCE_MASK           = 0x00000400U;   /** @brief Parity control enable */
    static const uint32_t LPUART1_CR1_PS_MASK            = 0x00000200U;   /** @brief Parity selection */
    static const uint32_t LPUART1_CR1_PEIE_MASK          = 0x00000100U;   /** @brief PE interrupt enable */
    static const uint32_t LPUART1_CR1_TXEIE_MASK         = 0x00000080U;   /** @brief Interrupt enable */
    static const uint32_t LPUART1_CR1_TCIE_MASK          = 0x00000040U;   /** @brief Transmission complete interrupt enable */
    static const uint32_t LPUART1_CR1_RXNEIE_MASK        = 0x00000020U;   /** @brief RXNE interrupt enable */
    static const uint32_t LPUART1_CR1_IDLEIE_MASK        = 0x00000010U;   /** @brief IDLE interrupt enable */
    static const uint32_t LPUART1_CR1_TE_MASK            = 0x00000008U;   /** @brief Transmitter enable */
    static const uint32_t LPUART1_CR1_RE_MASK            = 0x00000004U;   /** @brief Receiver enable */
    static const uint32_t LPUART1_CR1_UESM_MASK          = 0x00000002U;   /** @brief USART enable in stop mode */
    static const uint32_t LPUART1_CR1_UE_MASK            = 0x00000001U;   /** @brief USART enable */
    static const uint32_t LPUART1_CR2_ADD_MASK           = 0xFF000000U;   /** @brief Address of the USART node */
    static const uint32_t LPUART1_CR2_MSBFIRST_MASK      = 0x00080000U;   /** @brief Most significant bit first */
    static const uint32_t LPUART1_CR2_DATAINV_MASK       = 0x00040000U;   /** @brief Binary data inversion */
    static const uint32_t LPUART1_CR2_TXINV_MASK         = 0x00020000U;   /** @brief TX pin active level inversion */
    static const uint32_t LPUART1_CR2_RXINV_MASK         = 0x00010000U;   /** @brief RX pin active level inversion */
    static const uint32_t LPUART1_CR2_SWAP_MASK          = 0x00008000U;   /** @brief Swap TX/RX pins */
    static const uint32_t LPUART1_CR2_STOP_MASK          = 0x00003000U;   /** @brief STOP bits */
    static const uint32_t LPUART1_CR2_ADDM7_MASK         = 0x00000010U;   /** @brief 7-bit address detection/4-bit address detection */
    static const uint32_t LPUART1_CR3_TXFTCFG_MASK       = 0xE0000000U;   /** @brief TXFIFO threshold configuration */
    static const uint32_t LPUART1_CR3_RXFTIE_MASK        = 0x10000000U;   /** @brief RXFIFO threshold interrupt enable */
    static const uint32_t LPUART1_CR3_RXFTCFG_MASK       = 0x0E000000U;   /** @brief Receive FIFO threshold configuration */
    static const uint32_t LPUART1_CR3_TXFTIE_MASK        = 0x00800000U;   /** @brief TXFIFO threshold interrupt enable */
    static const uint32_t LPUART1_CR3_WUFIE_MASK         = 0x00400000U;   /** @brief Wakeup from stop mode interrupt enable */
    static const uint32_t LPUART1_CR3_WUS_MASK           = 0x00300000U;   /** @brief Wakeup from stop mode interrupt flag selection */
    static const uint32_t LPUART1_CR3_DEP_MASK           = 0x00008000U;   /** @brief Driver enable polarity selection */
    static const uint32_t LPUART1_CR3_DEM_MASK           = 0x00004000U;   /** @brief Driver enable mode */
    static const uint32_t LPUART1_CR3_DDRE_MASK          = 0x00002000U;   /** @brief DMA disable on reception error */
    static const uint32_t LPUART1_CR3_OVRDIS_MASK        = 0x00001000U;   /** @brief Overrun disable */
    static const uint32_t LPUART1_CR3_CTSIE_MASK         = 0x00000400U;   /** @brief CTS interrupt enable */
    static const uint32_t LPUART1_CR3_CTSE_MASK          = 0x00000200U;   /** @brief CTS enable */
    static const uint32_t LPUART1_CR3_RTSE_MASK          = 0x00000100U;   /** @brief RTS enable */
    static const uint32_t LPUART1_CR3_DMAT_MASK          = 0x00000080U;   /** @brief DMA enable transmitter */
    static const uint32_t LPUART1_CR3_DMAR_MASK          = 0x00000040U;   /** @brief DMA enable receiver */
    static const uint32_t LPUART1_CR3_HDSEL_MASK         = 0x00000008U;   /** @brief Half-duplex selection */
    static const uint32_t LPUART1_CR3_EIE_MASK           = 0x00000001U;   /** @brief Error interrupt enable */
    static const uint32_t LPUART1_BRR_BRR_MASK           = 0x000FFFFFU;   /** @brief BRR */
    static const uint32_t LPUART1_GTPR_GT_MASK           = 0x0000FF00U;   /** @brief Guard time value */
    static const uint32_t LPUART1_GTPR_PSC_MASK          = 0x000000FFU;   /** @brief Prescaler value */
    static const uint32_t LPUART1_RTOR_BLEN_MASK         = 0xFF000000U;   /** @brief Block length */
    static const uint32_t LPUART1_RTOR_RTO_MASK          = 0x00FFFFFFU;   /** @brief Receiver timeout value */
    static const uint32_t LPUART1_RQR_TXFRQ_MASK         = 0x00000010U;   /** @brief Transmit data flush request */
    static const uint32_t LPUART1_RQR_RXFRQ_MASK         = 0x00000008U;   /** @brief Receive data flush request */
    static const uint32_t LPUART1_RQR_MMRQ_MASK          = 0x00000004U;   /** @brief Mute mode request */
    static const uint32_t LPUART1_RQR_SBKRQ_MASK         = 0x00000002U;   /** @brief Send break request */
    static const uint32_t LPUART1_RQR_ABRRQ_MASK         = 0x00000001U;   /** @brief Auto baud rate request */
    static const uint32_t LPUART1_ISR_TXFT_MASK          = 0x08000000U;   /** @brief TXFIFO threshold flag */
    static const uint32_t LPUART1_ISR_RXFT_MASK          = 0x04000000U;   /** @brief RXFIFO threshold flag */
    static const uint32_t LPUART1_ISR_RXFF_MASK          = 0x01000000U;   /** @brief RXFIFO full */
    static const uint32_t LPUART1_ISR_TXFE_MASK          = 0x00800000U;   /** @brief TXFIFO empty */
    static const uint32_t LPUART1_ISR_REACK_MASK         = 0x00400000U;   /** @brief REACK */
    static const uint32_t LPUART1_ISR_TEACK_MASK         = 0x00200000U;   /** @brief TEACK */
    static const uint32_t LPUART1_ISR_WUF_MASK           = 0x00100000U;   /** @brief WUF */
    static const uint32_t LPUART1_ISR_RWU_MASK           = 0x00080000U;   /** @brief RWU */
    static const uint32_t LPUART1_ISR_SBKF_MASK          = 0x00040000U;   /** @brief SBKF */
    static const uint32_t LPUART1_ISR_CMF_MASK           = 0x00020000U;   /** @brief CMF */
    static const uint32_t LPUART1_ISR_BUSY_MASK          = 0x00010000U;   /** @brief BUSY */
    static const uint32_t LPUART1_ISR_CTS_MASK           = 0x00000400U;   /** @brief CTS */
    static const uint32_t LPUART1_ISR_CTSIF_MASK         = 0x00000200U;   /** @brief CTSIF */
    static const uint32_t LPUART1_ISR_TXE_MASK           = 0x00000080U;   /** @brief TXE */
    static const uint32_t LPUART1_ISR_TC_MASK            = 0x00000040U;   /** @brief TC */
    static const uint32_t LPUART1_ISR_RXNE_MASK          = 0x00000020U;   /** @brief RXNE */
    static const uint32_t LPUART1_ISR_IDLE_MASK          = 0x00000010U;   /** @brief IDLE */
    static const uint32_t LPUART1_ISR_ORE_MASK           = 0x00000008U;   /** @brief ORE */
    static const uint32_t LPUART1_ISR_NE_MASK            = 0x00000004U;   /** @brief NE */
    static const uint32_t LPUART1_ISR_FE_MASK            = 0x00000002U;   /** @brief FE */
    static const uint32_t LPUART1_ISR_PE_MASK            = 0x00000001U;   /** @brief PE */
    static const uint32_t LPUART1_ICR_WUCF_MASK          = 0x00100000U;   /** @brief Wakeup from stop mode clear flag */
    static const uint32_t LPUART1_ICR_CMCF_MASK          = 0x00020000U;   /** @brief Character match clear flag */
    static const uint32_t LPUART1_ICR_CTSCF_MASK         = 0x00000200U;   /** @brief CTS clear flag */
    static const uint32_t LPUART1_ICR_TCCF_MASK          = 0x00000040U;   /** @brief Transmission complete clear flag */
    static const uint32_t LPUART1_ICR_IDLECF_MASK        = 0x00000010U;   /** @brief Idle line detected clear flag */
    static const uint32_t LPUART1_ICR_ORECF_MASK         = 0x00000008U;   /** @brief Overrun error clear flag */
    static const uint32_t LPUART1_ICR_NCF_MASK           = 0x00000004U;   /** @brief Noise detected clear flag */
    static const uint32_t LPUART1_ICR_FECF_MASK          = 0x00000002U;   /** @brief Framing error clear flag */
    static const uint32_t LPUART1_ICR_PECF_MASK          = 0x00000001U;   /** @brief Parity error clear flag */
    static const uint32_t LPUART1_RDR_RDR_MASK           = 0x000001FFU;   /** @brief Receive data value */
    static const uint32_t LPUART1_TDR_TDR_MASK           = 0x000001FFU;   /** @brief Transmit data value */
    static const uint32_t LPUART1_PRESC_PRESCALER_MASK   = 0x0000000FU;   /** @brief Clock prescaler */

    /**** @subsection Enumerated LPUART1 Register Field Masks ****/

    static const uint32_t LPUART1_CR1_Mx_MASK[2] = {
      [0] = 0x00001000U,   /** @brief Word length */
      [1] = 0x10000000U,   /** @brief Word length */
    };

    /**** @subsection LPUART1 Register Field Positions ****/

    static const int32_t LPUART1_CR1_RXFFIE_POS        = 31;   /** @brief RXFIFO full interrupt enable */
    static const int32_t LPUART1_CR1_TXFEIE_POS        = 30;   /** @brief TXFIFO empty interrupt enable */
    static const int32_t LPUART1_CR1_FIFOEN_POS        = 29;   /** @brief FIFO mode enable */
    static const int32_t LPUART1_CR1_DEAT_POS          = 21;   /** @brief Driver enable assertion time */
    static const int32_t LPUART1_CR1_DEDT_POS          = 16;   /** @brief Driver enable deassertion time */
    static const int32_t LPUART1_CR1_CMIE_POS          = 14;   /** @brief Character match interrupt enable */
    static const int32_t LPUART1_CR1_MME_POS           = 13;   /** @brief Mute mode enable */
    static const int32_t LPUART1_CR1_WAKE_POS          = 11;   /** @brief Receiver wakeup method */
    static const int32_t LPUART1_CR1_PCE_POS           = 10;   /** @brief Parity control enable */
    static const int32_t LPUART1_CR1_PS_POS            = 9;    /** @brief Parity selection */
    static const int32_t LPUART1_CR1_PEIE_POS          = 8;    /** @brief PE interrupt enable */
    static const int32_t LPUART1_CR1_TXEIE_POS         = 7;    /** @brief Interrupt enable */
    static const int32_t LPUART1_CR1_TCIE_POS          = 6;    /** @brief Transmission complete interrupt enable */
    static const int32_t LPUART1_CR1_RXNEIE_POS        = 5;    /** @brief RXNE interrupt enable */
    static const int32_t LPUART1_CR1_IDLEIE_POS        = 4;    /** @brief IDLE interrupt enable */
    static const int32_t LPUART1_CR1_TE_POS            = 3;    /** @brief Transmitter enable */
    static const int32_t LPUART1_CR1_RE_POS            = 2;    /** @brief Receiver enable */
    static const int32_t LPUART1_CR1_UESM_POS          = 1;    /** @brief USART enable in stop mode */
    static const int32_t LPUART1_CR1_UE_POS            = 0;    /** @brief USART enable */
    static const int32_t LPUART1_CR2_ADD_POS           = 24;   /** @brief Address of the USART node */
    static const int32_t LPUART1_CR2_MSBFIRST_POS      = 19;   /** @brief Most significant bit first */
    static const int32_t LPUART1_CR2_DATAINV_POS       = 18;   /** @brief Binary data inversion */
    static const int32_t LPUART1_CR2_TXINV_POS         = 17;   /** @brief TX pin active level inversion */
    static const int32_t LPUART1_CR2_RXINV_POS         = 16;   /** @brief RX pin active level inversion */
    static const int32_t LPUART1_CR2_SWAP_POS          = 15;   /** @brief Swap TX/RX pins */
    static const int32_t LPUART1_CR2_STOP_POS          = 12;   /** @brief STOP bits */
    static const int32_t LPUART1_CR2_ADDM7_POS         = 4;    /** @brief 7-bit address detection/4-bit address detection */
    static const int32_t LPUART1_CR3_TXFTCFG_POS       = 29;   /** @brief TXFIFO threshold configuration */
    static const int32_t LPUART1_CR3_RXFTIE_POS        = 28;   /** @brief RXFIFO threshold interrupt enable */
    static const int32_t LPUART1_CR3_RXFTCFG_POS       = 25;   /** @brief Receive FIFO threshold configuration */
    static const int32_t LPUART1_CR3_TXFTIE_POS        = 23;   /** @brief TXFIFO threshold interrupt enable */
    static const int32_t LPUART1_CR3_WUFIE_POS         = 22;   /** @brief Wakeup from stop mode interrupt enable */
    static const int32_t LPUART1_CR3_WUS_POS           = 20;   /** @brief Wakeup from stop mode interrupt flag selection */
    static const int32_t LPUART1_CR3_DEP_POS           = 15;   /** @brief Driver enable polarity selection */
    static const int32_t LPUART1_CR3_DEM_POS           = 14;   /** @brief Driver enable mode */
    static const int32_t LPUART1_CR3_DDRE_POS          = 13;   /** @brief DMA disable on reception error */
    static const int32_t LPUART1_CR3_OVRDIS_POS        = 12;   /** @brief Overrun disable */
    static const int32_t LPUART1_CR3_CTSIE_POS         = 10;   /** @brief CTS interrupt enable */
    static const int32_t LPUART1_CR3_CTSE_POS          = 9;    /** @brief CTS enable */
    static const int32_t LPUART1_CR3_RTSE_POS          = 8;    /** @brief RTS enable */
    static const int32_t LPUART1_CR3_DMAT_POS          = 7;    /** @brief DMA enable transmitter */
    static const int32_t LPUART1_CR3_DMAR_POS          = 6;    /** @brief DMA enable receiver */
    static const int32_t LPUART1_CR3_HDSEL_POS         = 3;    /** @brief Half-duplex selection */
    static const int32_t LPUART1_CR3_EIE_POS           = 0;    /** @brief Error interrupt enable */
    static const int32_t LPUART1_BRR_BRR_POS           = 0;    /** @brief BRR */
    static const int32_t LPUART1_GTPR_GT_POS           = 8;    /** @brief Guard time value */
    static const int32_t LPUART1_GTPR_PSC_POS          = 0;    /** @brief Prescaler value */
    static const int32_t LPUART1_RTOR_BLEN_POS         = 24;   /** @brief Block length */
    static const int32_t LPUART1_RTOR_RTO_POS          = 0;    /** @brief Receiver timeout value */
    static const int32_t LPUART1_RQR_TXFRQ_POS         = 4;    /** @brief Transmit data flush request */
    static const int32_t LPUART1_RQR_RXFRQ_POS         = 3;    /** @brief Receive data flush request */
    static const int32_t LPUART1_RQR_MMRQ_POS          = 2;    /** @brief Mute mode request */
    static const int32_t LPUART1_RQR_SBKRQ_POS         = 1;    /** @brief Send break request */
    static const int32_t LPUART1_RQR_ABRRQ_POS         = 0;    /** @brief Auto baud rate request */
    static const int32_t LPUART1_ISR_TXFT_POS          = 27;   /** @brief TXFIFO threshold flag */
    static const int32_t LPUART1_ISR_RXFT_POS          = 26;   /** @brief RXFIFO threshold flag */
    static const int32_t LPUART1_ISR_RXFF_POS          = 24;   /** @brief RXFIFO full */
    static const int32_t LPUART1_ISR_TXFE_POS          = 23;   /** @brief TXFIFO empty */
    static const int32_t LPUART1_ISR_REACK_POS         = 22;   /** @brief REACK */
    static const int32_t LPUART1_ISR_TEACK_POS         = 21;   /** @brief TEACK */
    static const int32_t LPUART1_ISR_WUF_POS           = 20;   /** @brief WUF */
    static const int32_t LPUART1_ISR_RWU_POS           = 19;   /** @brief RWU */
    static const int32_t LPUART1_ISR_SBKF_POS          = 18;   /** @brief SBKF */
    static const int32_t LPUART1_ISR_CMF_POS           = 17;   /** @brief CMF */
    static const int32_t LPUART1_ISR_BUSY_POS          = 16;   /** @brief BUSY */
    static const int32_t LPUART1_ISR_CTS_POS           = 10;   /** @brief CTS */
    static const int32_t LPUART1_ISR_CTSIF_POS         = 9;    /** @brief CTSIF */
    static const int32_t LPUART1_ISR_TXE_POS           = 7;    /** @brief TXE */
    static const int32_t LPUART1_ISR_TC_POS            = 6;    /** @brief TC */
    static const int32_t LPUART1_ISR_RXNE_POS          = 5;    /** @brief RXNE */
    static const int32_t LPUART1_ISR_IDLE_POS          = 4;    /** @brief IDLE */
    static const int32_t LPUART1_ISR_ORE_POS           = 3;    /** @brief ORE */
    static const int32_t LPUART1_ISR_NE_POS            = 2;    /** @brief NE */
    static const int32_t LPUART1_ISR_FE_POS            = 1;    /** @brief FE */
    static const int32_t LPUART1_ISR_PE_POS            = 0;    /** @brief PE */
    static const int32_t LPUART1_ICR_WUCF_POS          = 20;   /** @brief Wakeup from stop mode clear flag */
    static const int32_t LPUART1_ICR_CMCF_POS          = 17;   /** @brief Character match clear flag */
    static const int32_t LPUART1_ICR_CTSCF_POS         = 9;    /** @brief CTS clear flag */
    static const int32_t LPUART1_ICR_TCCF_POS          = 6;    /** @brief Transmission complete clear flag */
    static const int32_t LPUART1_ICR_IDLECF_POS        = 4;    /** @brief Idle line detected clear flag */
    static const int32_t LPUART1_ICR_ORECF_POS         = 3;    /** @brief Overrun error clear flag */
    static const int32_t LPUART1_ICR_NCF_POS           = 2;    /** @brief Noise detected clear flag */
    static const int32_t LPUART1_ICR_FECF_POS          = 1;    /** @brief Framing error clear flag */
    static const int32_t LPUART1_ICR_PECF_POS          = 0;    /** @brief Parity error clear flag */
    static const int32_t LPUART1_RDR_RDR_POS           = 0;    /** @brief Receive data value */
    static const int32_t LPUART1_TDR_TDR_POS           = 0;    /** @brief Transmit data value */
    static const int32_t LPUART1_PRESC_PRESCALER_POS   = 0;    /** @brief Clock prescaler */

    /**** @subsection Enumerated LPUART1 Register Field Positions ****/

    static const int32_t LPUART1_CR1_Mx_POS[2] = {
      [0] = 12,   /** @brief Word length */
      [1] = 28,   /** @brief Word length */
    };

    /**********************************************************************************************
     * @section SYSCFG Register Information
     **********************************************************************************************/

    /**** @subsection SYSCFG Register Pointers ****/

    static RW_ uint32_t* const SYSCFG_PMCR_PTR      = (RW_ uint32_t* const)0x58000404U;   /** @brief Peripheral mode configuration register */
    static RW_ uint32_t* const SYSCFG_EXTICR1_PTR   = (RW_ uint32_t* const)0x58000408U;   /** @brief External interrupt configuration register 1 */
    static RW_ uint32_t* const SYSCFG_EXTICR2_PTR   = (RW_ uint32_t* const)0x5800040CU;   /** @brief External interrupt configuration register 2 */
    static RW_ uint32_t* const SYSCFG_EXTICR3_PTR   = (RW_ uint32_t* const)0x58000410U;   /** @brief External interrupt configuration register 3 */
    static RW_ uint32_t* const SYSCFG_EXTICR4_PTR   = (RW_ uint32_t* const)0x58000414U;   /** @brief External interrupt configuration register 4 */
    static RW_ uint32_t* const SYSCFG_CCCSR_PTR     = (RW_ uint32_t* const)0x58000420U;   /** @brief Compensation cell control/status register */
    static RO_ uint32_t* const SYSCFG_CCVR_PTR      = (RO_ uint32_t* const)0x58000424U;   /** @brief SYSCFG compensation cell value register */
    static RW_ uint32_t* const SYSCFG_CCCR_PTR      = (RW_ uint32_t* const)0x58000428U;   /** @brief SYSCFG compensation cell code register */
    static RO_ uint32_t* const SYSCFG_PKGR_PTR      = (RO_ uint32_t* const)0x58000524U;   /** @brief SYSCFG package register */
    static RO_ uint32_t* const SYSCFG_UR0_PTR       = (RO_ uint32_t* const)0x58000700U;   /** @brief SYSCFG user register 0 */
    static RW_ uint32_t* const SYSCFG_UR2_PTR       = (RW_ uint32_t* const)0x58000708U;   /** @brief SYSCFG user register 2 */
    static RW_ uint32_t* const SYSCFG_UR3_PTR       = (RW_ uint32_t* const)0x5800070CU;   /** @brief SYSCFG user register 3 */
    static RO_ uint32_t* const SYSCFG_UR4_PTR       = (RO_ uint32_t* const)0x58000710U;   /** @brief SYSCFG user register 4 */
    static RO_ uint32_t* const SYSCFG_UR5_PTR       = (RO_ uint32_t* const)0x58000714U;   /** @brief SYSCFG user register 5 */
    static RO_ uint32_t* const SYSCFG_UR6_PTR       = (RO_ uint32_t* const)0x58000718U;   /** @brief SYSCFG user register 6 */
    static RO_ uint32_t* const SYSCFG_UR7_PTR       = (RO_ uint32_t* const)0x5800071CU;   /** @brief SYSCFG user register 7 */
    static RO_ uint32_t* const SYSCFG_UR8_PTR       = (RO_ uint32_t* const)0x58000720U;   /** @brief SYSCFG user register 8 */
    static RO_ uint32_t* const SYSCFG_UR9_PTR       = (RO_ uint32_t* const)0x58000724U;   /** @brief SYSCFG user register 9 */
    static RO_ uint32_t* const SYSCFG_UR10_PTR      = (RO_ uint32_t* const)0x58000728U;   /** @brief SYSCFG user register 10 */
    static RO_ uint32_t* const SYSCFG_UR11_PTR      = (RO_ uint32_t* const)0x5800072CU;   /** @brief SYSCFG user register 11 */
    static RO_ uint32_t* const SYSCFG_UR12_PTR      = (RO_ uint32_t* const)0x58000730U;   /** @brief SYSCFG user register 12 */
    static RO_ uint32_t* const SYSCFG_UR13_PTR      = (RO_ uint32_t* const)0x58000734U;   /** @brief SYSCFG user register 13 */
    static RW_ uint32_t* const SYSCFG_UR14_PTR      = (RW_ uint32_t* const)0x58000738U;   /** @brief SYSCFG user register 14 */
    static RO_ uint32_t* const SYSCFG_UR15_PTR      = (RO_ uint32_t* const)0x5800073CU;   /** @brief SYSCFG user register 15 */
    static RO_ uint32_t* const SYSCFG_UR16_PTR      = (RO_ uint32_t* const)0x58000740U;   /** @brief SYSCFG user register 16 */
    static RO_ uint32_t* const SYSCFG_UR17_PTR      = (RO_ uint32_t* const)0x58000744U;   /** @brief SYSCFG user register 17 */

    /**** @subsection SYSCFG Register Reset Values ****/

    static const uint32_t SYSCFG_PMCR_RST      = 0x00000000U;   /** @brief PMCR register reset value. */
    static const uint32_t SYSCFG_EXTICR1_RST   = 0x00000000U;   /** @brief EXTICR1 register reset value. */
    static const uint32_t SYSCFG_EXTICR2_RST   = 0x00000000U;   /** @brief EXTICR2 register reset value. */
    static const uint32_t SYSCFG_EXTICR3_RST   = 0x00000000U;   /** @brief EXTICR3 register reset value. */
    static const uint32_t SYSCFG_EXTICR4_RST   = 0x00000000U;   /** @brief EXTICR4 register reset value. */
    static const uint32_t SYSCFG_CCCSR_RST     = 0x00000000U;   /** @brief CCCSR register reset value. */
    static const uint32_t SYSCFG_CCVR_RST      = 0x00000000U;   /** @brief CCVR register reset value. */
    static const uint32_t SYSCFG_CCCR_RST      = 0x00000000U;   /** @brief CCCR register reset value. */
    static const uint32_t SYSCFG_PKGR_RST      = 0x00000000U;   /** @brief PKGR register reset value. */
    static const uint32_t SYSCFG_UR0_RST       = 0x00000000U;   /** @brief UR0 register reset value. */
    static const uint32_t SYSCFG_UR2_RST       = 0x00000000U;   /** @brief UR2 register reset value. */
    static const uint32_t SYSCFG_UR3_RST       = 0x00000000U;   /** @brief UR3 register reset value. */
    static const uint32_t SYSCFG_UR4_RST       = 0x00000000U;   /** @brief UR4 register reset value. */
    static const uint32_t SYSCFG_UR5_RST       = 0x00000000U;   /** @brief UR5 register reset value. */
    static const uint32_t SYSCFG_UR6_RST       = 0x00000000U;   /** @brief UR6 register reset value. */
    static const uint32_t SYSCFG_UR7_RST       = 0x00000000U;   /** @brief UR7 register reset value. */
    static const uint32_t SYSCFG_UR8_RST       = 0x00000000U;   /** @brief UR8 register reset value. */
    static const uint32_t SYSCFG_UR9_RST       = 0x00000000U;   /** @brief UR9 register reset value. */
    static const uint32_t SYSCFG_UR10_RST      = 0x00000000U;   /** @brief UR10 register reset value. */
    static const uint32_t SYSCFG_UR11_RST      = 0x00000000U;   /** @brief UR11 register reset value. */
    static const uint32_t SYSCFG_UR12_RST      = 0x00000000U;   /** @brief UR12 register reset value. */
    static const uint32_t SYSCFG_UR13_RST      = 0x00000000U;   /** @brief UR13 register reset value. */
    static const uint32_t SYSCFG_UR14_RST      = 0x00000000U;   /** @brief UR14 register reset value. */
    static const uint32_t SYSCFG_UR15_RST      = 0x00000000U;   /** @brief UR15 register reset value. */
    static const uint32_t SYSCFG_UR16_RST      = 0x00000000U;   /** @brief UR16 register reset value. */
    static const uint32_t SYSCFG_UR17_RST      = 0x00000000U;   /** @brief UR17 register reset value. */

    /**** @subsection Enumerated SYSCFG Register Value Types ****/

    typedef uint32_t SYSCFG_PMCR_t;      /** @brief PMCR register value type. */
    typedef uint32_t SYSCFG_EXTICR1_t;   /** @brief EXTICR1 register value type. */
    typedef uint32_t SYSCFG_EXTICR2_t;   /** @brief EXTICR2 register value type. */
    typedef uint32_t SYSCFG_EXTICR3_t;   /** @brief EXTICR3 register value type. */
    typedef uint32_t SYSCFG_EXTICR4_t;   /** @brief EXTICR4 register value type. */
    typedef uint32_t SYSCFG_CCCSR_t;     /** @brief CCCSR register value type. */
    typedef uint32_t SYSCFG_CCVR_t;      /** @brief CCVR register value type. */
    typedef uint32_t SYSCFG_CCCR_t;      /** @brief CCCR register value type. */
    typedef uint32_t SYSCFG_PKGR_t;      /** @brief PKGR register value type. */
    typedef uint32_t SYSCFG_UR0_t;       /** @brief UR0 register value type. */
    typedef uint32_t SYSCFG_UR2_t;       /** @brief UR2 register value type. */
    typedef uint32_t SYSCFG_UR3_t;       /** @brief UR3 register value type. */
    typedef uint32_t SYSCFG_UR4_t;       /** @brief UR4 register value type. */
    typedef uint32_t SYSCFG_UR5_t;       /** @brief UR5 register value type. */
    typedef uint32_t SYSCFG_UR6_t;       /** @brief UR6 register value type. */
    typedef uint32_t SYSCFG_UR7_t;       /** @brief UR7 register value type. */
    typedef uint32_t SYSCFG_UR8_t;       /** @brief UR8 register value type. */
    typedef uint32_t SYSCFG_UR9_t;       /** @brief UR9 register value type. */
    typedef uint32_t SYSCFG_UR10_t;      /** @brief UR10 register value type. */
    typedef uint32_t SYSCFG_UR11_t;      /** @brief UR11 register value type. */
    typedef uint32_t SYSCFG_UR12_t;      /** @brief UR12 register value type. */
    typedef uint32_t SYSCFG_UR13_t;      /** @brief UR13 register value type. */
    typedef uint32_t SYSCFG_UR14_t;      /** @brief UR14 register value type. */
    typedef uint32_t SYSCFG_UR15_t;      /** @brief UR15 register value type. */
    typedef uint32_t SYSCFG_UR16_t;      /** @brief UR16 register value type. */
    typedef uint32_t SYSCFG_UR17_t;      /** @brief UR17 register value type. */

    /**** @subsection Enumerated SYSCFG Register Pointer Types ****/

    typedef uint32_t* const SYSCFG_PMCR_PTR_t;      /** @brief PMCR register pointer type. */
    typedef uint32_t* const SYSCFG_EXTICR1_PTR_t;   /** @brief EXTICR1 register pointer type. */
    typedef uint32_t* const SYSCFG_EXTICR2_PTR_t;   /** @brief EXTICR2 register pointer type. */
    typedef uint32_t* const SYSCFG_EXTICR3_PTR_t;   /** @brief EXTICR3 register pointer type. */
    typedef uint32_t* const SYSCFG_EXTICR4_PTR_t;   /** @brief EXTICR4 register pointer type. */
    typedef uint32_t* const SYSCFG_CCCSR_PTR_t;     /** @brief CCCSR register pointer type. */
    typedef uint32_t* const SYSCFG_CCVR_PTR_t;      /** @brief CCVR register pointer type. */
    typedef uint32_t* const SYSCFG_CCCR_PTR_t;      /** @brief CCCR register pointer type. */
    typedef uint32_t* const SYSCFG_PKGR_PTR_t;      /** @brief PKGR register pointer type. */
    typedef uint32_t* const SYSCFG_UR0_PTR_t;       /** @brief UR0 register pointer type. */
    typedef uint32_t* const SYSCFG_UR2_PTR_t;       /** @brief UR2 register pointer type. */
    typedef uint32_t* const SYSCFG_UR3_PTR_t;       /** @brief UR3 register pointer type. */
    typedef uint32_t* const SYSCFG_UR4_PTR_t;       /** @brief UR4 register pointer type. */
    typedef uint32_t* const SYSCFG_UR5_PTR_t;       /** @brief UR5 register pointer type. */
    typedef uint32_t* const SYSCFG_UR6_PTR_t;       /** @brief UR6 register pointer type. */
    typedef uint32_t* const SYSCFG_UR7_PTR_t;       /** @brief UR7 register pointer type. */
    typedef uint32_t* const SYSCFG_UR8_PTR_t;       /** @brief UR8 register pointer type. */
    typedef uint32_t* const SYSCFG_UR9_PTR_t;       /** @brief UR9 register pointer type. */
    typedef uint32_t* const SYSCFG_UR10_PTR_t;      /** @brief UR10 register pointer type. */
    typedef uint32_t* const SYSCFG_UR11_PTR_t;      /** @brief UR11 register pointer type. */
    typedef uint32_t* const SYSCFG_UR12_PTR_t;      /** @brief UR12 register pointer type. */
    typedef uint32_t* const SYSCFG_UR13_PTR_t;      /** @brief UR13 register pointer type. */
    typedef uint32_t* const SYSCFG_UR14_PTR_t;      /** @brief UR14 register pointer type. */
    typedef uint32_t* const SYSCFG_UR15_PTR_t;      /** @brief UR15 register pointer type. */
    typedef uint32_t* const SYSCFG_UR16_PTR_t;      /** @brief UR16 register pointer type. */
    typedef uint32_t* const SYSCFG_UR17_PTR_t;      /** @brief UR17 register pointer type. */

    /**** @subsection SYSCFG Register Field Masks ****/

    static const uint32_t SYSCFG_PMCR_BOOSTE_MASK      = 0x00000100U;   /** @brief Booster enable */
    static const uint32_t SYSCFG_PMCR_EPIS_MASK        = 0x00E00000U;   /** @brief Ethernet PHY interface selection */
    static const uint32_t SYSCFG_CCCSR_EN_MASK         = 0x00000001U;   /** @brief Enable */
    static const uint32_t SYSCFG_CCCSR_CS_MASK         = 0x00000002U;   /** @brief Code selection */
    static const uint32_t SYSCFG_CCCSR_READY_MASK      = 0x00000100U;   /** @brief Compensation cell ready flag */
    static const uint32_t SYSCFG_CCCSR_HSLV_MASK       = 0x00010000U;   /** @brief High-speed at low-voltage */
    static const uint32_t SYSCFG_CCVR_NCV_MASK         = 0x0000000FU;   /** @brief NMOS compensation value */
    static const uint32_t SYSCFG_CCVR_PCV_MASK         = 0x000000F0U;   /** @brief PMOS compensation value */
    static const uint32_t SYSCFG_CCCR_NCC_MASK         = 0x0000000FU;   /** @brief NMOS compensation code */
    static const uint32_t SYSCFG_CCCR_PCC_MASK         = 0x000000F0U;   /** @brief PMOS compensation code */
    static const uint32_t SYSCFG_PKGR_PKG_MASK         = 0x0000000FU;   /** @brief Package */
    static const uint32_t SYSCFG_UR0_BKS_MASK          = 0x00000001U;   /** @brief Bank swap */
    static const uint32_t SYSCFG_UR0_RDP_MASK          = 0x00FF0000U;   /** @brief Readout protection */
    static const uint32_t SYSCFG_UR2_BORH_MASK         = 0x00000003U;   /** @brief BOR_LVL brownout reset threshold level */
    static const uint32_t SYSCFG_UR2_BOOT_ADD0_MASK    = 0xFFFF0000U;   /** @brief Boot address 0 */
    static const uint32_t SYSCFG_UR3_BOOT_ADD1_MASK    = 0xFFFF0000U;   /** @brief Boot address 1 */
    static const uint32_t SYSCFG_UR4_MEPAD_1_MASK      = 0x00010000U;   /** @brief Mass erase protected area disabled for bank 1 */
    static const uint32_t SYSCFG_UR5_MESAD_1_MASK      = 0x00000001U;   /** @brief Mass erase secured area disabled for bank 1 */
    static const uint32_t SYSCFG_UR5_WRPN_1_MASK       = 0x00FF0000U;   /** @brief Write protection for flash bank 1 */
    static const uint32_t SYSCFG_UR6_PA_BEG_1_MASK     = 0x00000FFFU;   /** @brief Protected area start address for bank 1 */
    static const uint32_t SYSCFG_UR6_PA_END_1_MASK     = 0x0FFF0000U;   /** @brief Protected area end address for bank 1 */
    static const uint32_t SYSCFG_UR7_SA_BEG_1_MASK     = 0x00000FFFU;   /** @brief Secured area start address for bank 1 */
    static const uint32_t SYSCFG_UR7_SA_END_1_MASK     = 0x0FFF0000U;   /** @brief Secured area end address for bank 1 */
    static const uint32_t SYSCFG_UR8_MEPAD_2_MASK      = 0x00000001U;   /** @brief Mass erase protected area disabled for bank 2 */
    static const uint32_t SYSCFG_UR8_MESAD_2_MASK      = 0x00010000U;   /** @brief Mass erase secured area disabled for bank 2 */
    static const uint32_t SYSCFG_UR9_WRPN_2_MASK       = 0x000000FFU;   /** @brief Write protection for flash bank 2 */
    static const uint32_t SYSCFG_UR9_PA_BEG_2_MASK     = 0x0FFF0000U;   /** @brief Protected area start address for bank 2 */
    static const uint32_t SYSCFG_UR10_PA_END_2_MASK    = 0x00000FFFU;   /** @brief Protected area end address for bank 2 */
    static const uint32_t SYSCFG_UR10_SA_BEG_2_MASK    = 0x0FFF0000U;   /** @brief Secured area start address for bank 2 */
    static const uint32_t SYSCFG_UR11_SA_END_2_MASK    = 0x00000FFFU;   /** @brief Secured area end address for bank 2 */
    static const uint32_t SYSCFG_UR11_IWDG1M_MASK      = 0x00010000U;   /** @brief Independent watchdog 1 mode */
    static const uint32_t SYSCFG_UR12_SECURE_MASK      = 0x00010000U;   /** @brief Secure mode */
    static const uint32_t SYSCFG_UR13_SDRS_MASK        = 0x00000003U;   /** @brief Secured DTCM RAM size */
    static const uint32_t SYSCFG_UR13_D1SBRST_MASK     = 0x00010000U;   /** @brief D1 standby reset */
    static const uint32_t SYSCFG_UR14_D1STPRST_MASK    = 0x00000001U;   /** @brief D1 stop reset */
    static const uint32_t SYSCFG_UR15_FZIWDGSTB_MASK   = 0x00010000U;   /** @brief Freeze independent watchdog in standby mode */
    static const uint32_t SYSCFG_UR16_FZIWDGSTP_MASK   = 0x00000001U;   /** @brief Freeze independent watchdog in stop mode */
    static const uint32_t SYSCFG_UR16_PKP_MASK         = 0x00010000U;   /** @brief Private key programmed */
    static const uint32_t SYSCFG_UR17_IO_HSLV_MASK     = 0x00000001U;   /** @brief I/O high speed / low voltage */

    /**** @subsection Enumerated SYSCFG Register Field Masks ****/

    static const uint32_t SYSCFG_PMCR_I2CxFMP_MASK[5] = {
      [1] = 0x00000001U,   /** @brief I2C1 fm+ */
      [2] = 0x00000002U,   /** @brief I2C2 fm+ */
      [3] = 0x00000004U,   /** @brief I2C3 fm+ */
      [4] = 0x00000008U,   /** @brief I2C4 fm+ */
    };

    static const uint32_t SYSCFG_PMCR_PBxFMP_MASK[10] = {
      [6]  = 0x00000010U,   /** @brief PB(6) fm+ */
      [7]  = 0x00000020U,   /** @brief PB(7) fast mode plus */
      [8]  = 0x00000040U,   /** @brief PB(8) fast mode plus */
      [9]  = 0x00000080U,   /** @brief PB(9) fm+ */
    };

    static const uint32_t SYSCFG_PMCR_PAxSO_MASK[2] = {
      [0] = 0x01000000U,   /** @brief PA0 switch open */
      [1] = 0x02000000U,   /** @brief PA1 switch open */
    };

    static const uint32_t SYSCFG_PMCR_PCxSO_MASK[4] = {
      [2] = 0x04000000U,   /** @brief PC2 switch open */
      [3] = 0x08000000U,   /** @brief PC3 switch open */
    };

    static const uint32_t SYSCFG_EXTICR1_EXTIx_MASK[4] = {
      [0] = 0x0000000FU,   /** @brief EXTI x configuration (x = 0 to 3) */
      [1] = 0x000000F0U,   /** @brief EXTI x configuration (x = 0 to 3) */
      [2] = 0x00000F00U,   /** @brief EXTI x configuration (x = 0 to 3) */
      [3] = 0x0000F000U,   /** @brief EXTI x configuration (x = 0 to 3) */
    };

    static const uint32_t SYSCFG_EXTICR3_EXTI1x_MASK[2] = {
      [0] = 0x00000F00U,   /** @brief EXTI10 */
    };

    /**** @subsection SYSCFG Register Field Positions ****/

    static const int32_t SYSCFG_PMCR_BOOSTE_POS      = 8;    /** @brief Booster enable */
    static const int32_t SYSCFG_PMCR_EPIS_POS        = 21;   /** @brief Ethernet PHY interface selection */
    static const int32_t SYSCFG_CCCSR_EN_POS         = 0;    /** @brief Enable */
    static const int32_t SYSCFG_CCCSR_CS_POS         = 1;    /** @brief Code selection */
    static const int32_t SYSCFG_CCCSR_READY_POS      = 8;    /** @brief Compensation cell ready flag */
    static const int32_t SYSCFG_CCCSR_HSLV_POS       = 16;   /** @brief High-speed at low-voltage */
    static const int32_t SYSCFG_CCVR_NCV_POS         = 0;    /** @brief NMOS compensation value */
    static const int32_t SYSCFG_CCVR_PCV_POS         = 4;    /** @brief PMOS compensation value */
    static const int32_t SYSCFG_CCCR_NCC_POS         = 0;    /** @brief NMOS compensation code */
    static const int32_t SYSCFG_CCCR_PCC_POS         = 4;    /** @brief PMOS compensation code */
    static const int32_t SYSCFG_PKGR_PKG_POS         = 0;    /** @brief Package */
    static const int32_t SYSCFG_UR0_BKS_POS          = 0;    /** @brief Bank swap */
    static const int32_t SYSCFG_UR0_RDP_POS          = 16;   /** @brief Readout protection */
    static const int32_t SYSCFG_UR2_BORH_POS         = 0;    /** @brief BOR_LVL brownout reset threshold level */
    static const int32_t SYSCFG_UR2_BOOT_ADD0_POS    = 16;   /** @brief Boot address 0 */
    static const int32_t SYSCFG_UR3_BOOT_ADD1_POS    = 16;   /** @brief Boot address 1 */
    static const int32_t SYSCFG_UR4_MEPAD_1_POS      = 16;   /** @brief Mass erase protected area disabled for bank 1 */
    static const int32_t SYSCFG_UR5_MESAD_1_POS      = 0;    /** @brief Mass erase secured area disabled for bank 1 */
    static const int32_t SYSCFG_UR5_WRPN_1_POS       = 16;   /** @brief Write protection for flash bank 1 */
    static const int32_t SYSCFG_UR6_PA_BEG_1_POS     = 0;    /** @brief Protected area start address for bank 1 */
    static const int32_t SYSCFG_UR6_PA_END_1_POS     = 16;   /** @brief Protected area end address for bank 1 */
    static const int32_t SYSCFG_UR7_SA_BEG_1_POS     = 0;    /** @brief Secured area start address for bank 1 */
    static const int32_t SYSCFG_UR7_SA_END_1_POS     = 16;   /** @brief Secured area end address for bank 1 */
    static const int32_t SYSCFG_UR8_MEPAD_2_POS      = 0;    /** @brief Mass erase protected area disabled for bank 2 */
    static const int32_t SYSCFG_UR8_MESAD_2_POS      = 16;   /** @brief Mass erase secured area disabled for bank 2 */
    static const int32_t SYSCFG_UR9_WRPN_2_POS       = 0;    /** @brief Write protection for flash bank 2 */
    static const int32_t SYSCFG_UR9_PA_BEG_2_POS     = 16;   /** @brief Protected area start address for bank 2 */
    static const int32_t SYSCFG_UR10_PA_END_2_POS    = 0;    /** @brief Protected area end address for bank 2 */
    static const int32_t SYSCFG_UR10_SA_BEG_2_POS    = 16;   /** @brief Secured area start address for bank 2 */
    static const int32_t SYSCFG_UR11_SA_END_2_POS    = 0;    /** @brief Secured area end address for bank 2 */
    static const int32_t SYSCFG_UR11_IWDG1M_POS      = 16;   /** @brief Independent watchdog 1 mode */
    static const int32_t SYSCFG_UR12_SECURE_POS      = 16;   /** @brief Secure mode */
    static const int32_t SYSCFG_UR13_SDRS_POS        = 0;    /** @brief Secured DTCM RAM size */
    static const int32_t SYSCFG_UR13_D1SBRST_POS     = 16;   /** @brief D1 standby reset */
    static const int32_t SYSCFG_UR14_D1STPRST_POS    = 0;    /** @brief D1 stop reset */
    static const int32_t SYSCFG_UR15_FZIWDGSTB_POS   = 16;   /** @brief Freeze independent watchdog in standby mode */
    static const int32_t SYSCFG_UR16_FZIWDGSTP_POS   = 0;    /** @brief Freeze independent watchdog in stop mode */
    static const int32_t SYSCFG_UR16_PKP_POS         = 16;   /** @brief Private key programmed */
    static const int32_t SYSCFG_UR17_IO_HSLV_POS     = 0;    /** @brief I/O high speed / low voltage */

    /**** @subsection Enumerated SYSCFG Register Field Positions ****/

    static const int32_t SYSCFG_PMCR_I2CxFMP_POS[5] = {
      [1] = 0,   /** @brief I2C1 fm+ */
      [2] = 1,   /** @brief I2C2 fm+ */
      [3] = 2,   /** @brief I2C3 fm+ */
      [4] = 3,   /** @brief I2C4 fm+ */
    };

    static const int32_t SYSCFG_PMCR_PBxFMP_POS[10] = {
      [6]  = 4,   /** @brief PB(6) fm+ */
      [7]  = 5,   /** @brief PB(7) fast mode plus */
      [8]  = 6,   /** @brief PB(8) fast mode plus */
      [9]  = 7,   /** @brief PB(9) fm+ */
    };

    static const int32_t SYSCFG_PMCR_PAxSO_POS[2] = {
      [0] = 24,   /** @brief PA0 switch open */
      [1] = 25,   /** @brief PA1 switch open */
    };

    static const int32_t SYSCFG_PMCR_PCxSO_POS[4] = {
      [2] = 26,   /** @brief PC2 switch open */
      [3] = 27,   /** @brief PC3 switch open */
    };

    static const int32_t SYSCFG_EXTICR1_EXTIx_POS[4] = {
      [0] = 0,    /** @brief EXTI x configuration (x = 0 to 3) */
      [1] = 4,    /** @brief EXTI x configuration (x = 0 to 3) */
      [2] = 8,    /** @brief EXTI x configuration (x = 0 to 3) */
      [3] = 12,   /** @brief EXTI x configuration (x = 0 to 3) */
    };

    static const int32_t SYSCFG_EXTICR3_EXTI1x_POS[2] = {
      [0] = 8,   /** @brief EXTI10 */
    };

    /**********************************************************************************************
     * @section EXTI Register Information
     **********************************************************************************************/

    /**** @subsection EXTI Register Pointers ****/

    static RW_ uint32_t* const EXTI_RTSR1_PTR     = (RW_ uint32_t* const)0x58000000U;   /** @brief EXTI rising trigger selection register */
    static RW_ uint32_t* const EXTI_FTSR1_PTR     = (RW_ uint32_t* const)0x58000004U;   /** @brief EXTI falling trigger selection register */
    static RW_ uint32_t* const EXTI_SWIER1_PTR    = (RW_ uint32_t* const)0x58000008U;   /** @brief EXTI software interrupt event register */
    static RW_ uint32_t* const EXTI_D3PMR1_PTR    = (RW_ uint32_t* const)0x5800000CU;   /** @brief EXTI D3 pending mask register */
    static RW_ uint32_t* const EXTI_D3PCR1L_PTR   = (RW_ uint32_t* const)0x58000010U;   /** @brief EXTI D3 pending clear selection register low */
    static RW_ uint32_t* const EXTI_D3PCR1H_PTR   = (RW_ uint32_t* const)0x58000014U;   /** @brief EXTI D3 pending clear selection register high */
    static RW_ uint32_t* const EXTI_RTSR2_PTR     = (RW_ uint32_t* const)0x58000020U;   /** @brief EXTI rising trigger selection register */
    static RW_ uint32_t* const EXTI_FTSR2_PTR     = (RW_ uint32_t* const)0x58000024U;   /** @brief EXTI falling trigger selection register */
    static RW_ uint32_t* const EXTI_SWIER2_PTR    = (RW_ uint32_t* const)0x58000028U;   /** @brief EXTI software interrupt event register */
    static RW_ uint32_t* const EXTI_D3PMR2_PTR    = (RW_ uint32_t* const)0x5800002CU;   /** @brief EXTI D3 pending mask register */
    static RW_ uint32_t* const EXTI_D3PCR2L_PTR   = (RW_ uint32_t* const)0x58000030U;   /** @brief EXTI D3 pending clear selection register low */
    static RW_ uint32_t* const EXTI_D3PCR2H_PTR   = (RW_ uint32_t* const)0x58000034U;   /** @brief EXTI D3 pending clear selection register high */
    static RW_ uint32_t* const EXTI_RTSR3_PTR     = (RW_ uint32_t* const)0x58000040U;   /** @brief EXTI rising trigger selection register */
    static RW_ uint32_t* const EXTI_FTSR3_PTR     = (RW_ uint32_t* const)0x58000044U;   /** @brief EXTI falling trigger selection register */
    static RW_ uint32_t* const EXTI_SWIER3_PTR    = (RW_ uint32_t* const)0x58000048U;   /** @brief EXTI software interrupt event register */
    static RW_ uint32_t* const EXTI_D3PMR3_PTR    = (RW_ uint32_t* const)0x5800004CU;   /** @brief EXTI D3 pending mask register */
    static RW_ uint32_t* const EXTI_D3PCR3H_PTR   = (RW_ uint32_t* const)0x58000054U;   /** @brief EXTI D3 pending clear selection register high */
    static RW_ uint32_t* const EXTI_CPUIMR1_PTR   = (RW_ uint32_t* const)0x58000080U;   /** @brief EXTI interrupt mask register */
    static RW_ uint32_t* const EXTI_CPUEMR1_PTR   = (RW_ uint32_t* const)0x58000084U;   /** @brief EXTI event mask register */
    static RW_ uint32_t* const EXTI_CPUPR1_PTR    = (RW_ uint32_t* const)0x58000088U;   /** @brief EXTI pending register */
    static RW_ uint32_t* const EXTI_CPUIMR2_PTR   = (RW_ uint32_t* const)0x58000090U;   /** @brief EXTI interrupt mask register */
    static RW_ uint32_t* const EXTI_CPUEMR2_PTR   = (RW_ uint32_t* const)0x58000094U;   /** @brief EXTI event mask register */
    static RO_ uint32_t* const EXTI_CPUPR2_PTR    = (RO_ uint32_t* const)0x58000098U;   /** @brief EXTI pending register */
    static RO_ uint32_t* const EXTI_CPUIMR3_PTR   = (RO_ uint32_t* const)0x580000A0U;   /** @brief EXTI interrupt mask register */
    static RO_ uint32_t* const EXTI_CPUEMR3_PTR   = (RO_ uint32_t* const)0x580000A4U;   /** @brief EXTI event mask register */
    static RO_ uint32_t* const EXTI_CPUPR3_PTR    = (RO_ uint32_t* const)0x580000A8U;   /** @brief EXTI pending register */

    /**** @subsection EXTI Register Reset Values ****/

    static const uint32_t EXTI_RTSR1_RST     = 0x00000000U;   /** @brief RTSR1 register reset value. */
    static const uint32_t EXTI_FTSR1_RST     = 0x00000000U;   /** @brief FTSR1 register reset value. */
    static const uint32_t EXTI_SWIER1_RST    = 0x00000000U;   /** @brief SWIER1 register reset value. */
    static const uint32_t EXTI_D3PMR1_RST    = 0x00000000U;   /** @brief D3PMR1 register reset value. */
    static const uint32_t EXTI_D3PCR1L_RST   = 0x00000000U;   /** @brief D3PCR1L register reset value. */
    static const uint32_t EXTI_D3PCR1H_RST   = 0x00000000U;   /** @brief D3PCR1H register reset value. */
    static const uint32_t EXTI_RTSR2_RST     = 0x00000000U;   /** @brief RTSR2 register reset value. */
    static const uint32_t EXTI_FTSR2_RST     = 0x00000000U;   /** @brief FTSR2 register reset value. */
    static const uint32_t EXTI_SWIER2_RST    = 0x00000000U;   /** @brief SWIER2 register reset value. */
    static const uint32_t EXTI_D3PMR2_RST    = 0x00000000U;   /** @brief D3PMR2 register reset value. */
    static const uint32_t EXTI_D3PCR2L_RST   = 0x00000000U;   /** @brief D3PCR2L register reset value. */
    static const uint32_t EXTI_D3PCR2H_RST   = 0x00000000U;   /** @brief D3PCR2H register reset value. */
    static const uint32_t EXTI_RTSR3_RST     = 0x00000000U;   /** @brief RTSR3 register reset value. */
    static const uint32_t EXTI_FTSR3_RST     = 0x00000000U;   /** @brief FTSR3 register reset value. */
    static const uint32_t EXTI_SWIER3_RST    = 0x00000000U;   /** @brief SWIER3 register reset value. */
    static const uint32_t EXTI_D3PMR3_RST    = 0x00000000U;   /** @brief D3PMR3 register reset value. */
    static const uint32_t EXTI_D3PCR3H_RST   = 0x00000000U;   /** @brief D3PCR3H register reset value. */
    static const uint32_t EXTI_CPUIMR1_RST   = 0xFFC00000U;   /** @brief CPUIMR1 register reset value. */
    static const uint32_t EXTI_CPUEMR1_RST   = 0x00000000U;   /** @brief CPUEMR1 register reset value. */
    static const uint32_t EXTI_CPUPR1_RST    = 0x00000000U;   /** @brief CPUPR1 register reset value. */
    static const uint32_t EXTI_CPUIMR2_RST   = 0x00000000U;   /** @brief CPUIMR2 register reset value. */
    static const uint32_t EXTI_CPUEMR2_RST   = 0x00000000U;   /** @brief CPUEMR2 register reset value. */
    static const uint32_t EXTI_CPUPR2_RST    = 0x00000000U;   /** @brief CPUPR2 register reset value. */
    static const uint32_t EXTI_CPUIMR3_RST   = 0x00000000U;   /** @brief CPUIMR3 register reset value. */
    static const uint32_t EXTI_CPUEMR3_RST   = 0x00000000U;   /** @brief CPUEMR3 register reset value. */
    static const uint32_t EXTI_CPUPR3_RST    = 0x00000000U;   /** @brief CPUPR3 register reset value. */

    /**** @subsection Enumerated EXTI Register Value Types ****/

    typedef uint32_t EXTI_RTSR1_t;     /** @brief RTSR1 register value type. */
    typedef uint32_t EXTI_FTSR1_t;     /** @brief FTSR1 register value type. */
    typedef uint32_t EXTI_SWIER1_t;    /** @brief SWIER1 register value type. */
    typedef uint32_t EXTI_D3PMR1_t;    /** @brief D3PMR1 register value type. */
    typedef uint32_t EXTI_D3PCR1L_t;   /** @brief D3PCR1L register value type. */
    typedef uint32_t EXTI_D3PCR1H_t;   /** @brief D3PCR1H register value type. */
    typedef uint32_t EXTI_RTSR2_t;     /** @brief RTSR2 register value type. */
    typedef uint32_t EXTI_FTSR2_t;     /** @brief FTSR2 register value type. */
    typedef uint32_t EXTI_SWIER2_t;    /** @brief SWIER2 register value type. */
    typedef uint32_t EXTI_D3PMR2_t;    /** @brief D3PMR2 register value type. */
    typedef uint32_t EXTI_D3PCR2L_t;   /** @brief D3PCR2L register value type. */
    typedef uint32_t EXTI_D3PCR2H_t;   /** @brief D3PCR2H register value type. */
    typedef uint32_t EXTI_RTSR3_t;     /** @brief RTSR3 register value type. */
    typedef uint32_t EXTI_FTSR3_t;     /** @brief FTSR3 register value type. */
    typedef uint32_t EXTI_SWIER3_t;    /** @brief SWIER3 register value type. */
    typedef uint32_t EXTI_D3PMR3_t;    /** @brief D3PMR3 register value type. */
    typedef uint32_t EXTI_D3PCR3H_t;   /** @brief D3PCR3H register value type. */
    typedef uint32_t EXTI_CPUIMR1_t;   /** @brief CPUIMR1 register value type. */
    typedef uint32_t EXTI_CPUEMR1_t;   /** @brief CPUEMR1 register value type. */
    typedef uint32_t EXTI_CPUPR1_t;    /** @brief CPUPR1 register value type. */
    typedef uint32_t EXTI_CPUIMR2_t;   /** @brief CPUIMR2 register value type. */
    typedef uint32_t EXTI_CPUEMR2_t;   /** @brief CPUEMR2 register value type. */
    typedef uint32_t EXTI_CPUPR2_t;    /** @brief CPUPR2 register value type. */
    typedef uint32_t EXTI_CPUIMR3_t;   /** @brief CPUIMR3 register value type. */
    typedef uint32_t EXTI_CPUEMR3_t;   /** @brief CPUEMR3 register value type. */
    typedef uint32_t EXTI_CPUPR3_t;    /** @brief CPUPR3 register value type. */

    /**** @subsection Enumerated EXTI Register Pointer Types ****/

    typedef uint32_t* const EXTI_RTSR1_PTR_t;     /** @brief RTSR1 register pointer type. */
    typedef uint32_t* const EXTI_FTSR1_PTR_t;     /** @brief FTSR1 register pointer type. */
    typedef uint32_t* const EXTI_SWIER1_PTR_t;    /** @brief SWIER1 register pointer type. */
    typedef uint32_t* const EXTI_D3PMR1_PTR_t;    /** @brief D3PMR1 register pointer type. */
    typedef uint32_t* const EXTI_D3PCR1L_PTR_t;   /** @brief D3PCR1L register pointer type. */
    typedef uint32_t* const EXTI_D3PCR1H_PTR_t;   /** @brief D3PCR1H register pointer type. */
    typedef uint32_t* const EXTI_RTSR2_PTR_t;     /** @brief RTSR2 register pointer type. */
    typedef uint32_t* const EXTI_FTSR2_PTR_t;     /** @brief FTSR2 register pointer type. */
    typedef uint32_t* const EXTI_SWIER2_PTR_t;    /** @brief SWIER2 register pointer type. */
    typedef uint32_t* const EXTI_D3PMR2_PTR_t;    /** @brief D3PMR2 register pointer type. */
    typedef uint32_t* const EXTI_D3PCR2L_PTR_t;   /** @brief D3PCR2L register pointer type. */
    typedef uint32_t* const EXTI_D3PCR2H_PTR_t;   /** @brief D3PCR2H register pointer type. */
    typedef uint32_t* const EXTI_RTSR3_PTR_t;     /** @brief RTSR3 register pointer type. */
    typedef uint32_t* const EXTI_FTSR3_PTR_t;     /** @brief FTSR3 register pointer type. */
    typedef uint32_t* const EXTI_SWIER3_PTR_t;    /** @brief SWIER3 register pointer type. */
    typedef uint32_t* const EXTI_D3PMR3_PTR_t;    /** @brief D3PMR3 register pointer type. */
    typedef uint32_t* const EXTI_D3PCR3H_PTR_t;   /** @brief D3PCR3H register pointer type. */
    typedef uint32_t* const EXTI_CPUIMR1_PTR_t;   /** @brief CPUIMR1 register pointer type. */
    typedef uint32_t* const EXTI_CPUEMR1_PTR_t;   /** @brief CPUEMR1 register pointer type. */
    typedef uint32_t* const EXTI_CPUPR1_PTR_t;    /** @brief CPUPR1 register pointer type. */
    typedef uint32_t* const EXTI_CPUIMR2_PTR_t;   /** @brief CPUIMR2 register pointer type. */
    typedef uint32_t* const EXTI_CPUEMR2_PTR_t;   /** @brief CPUEMR2 register pointer type. */
    typedef uint32_t* const EXTI_CPUPR2_PTR_t;    /** @brief CPUPR2 register pointer type. */
    typedef uint32_t* const EXTI_CPUIMR3_PTR_t;   /** @brief CPUIMR3 register pointer type. */
    typedef uint32_t* const EXTI_CPUEMR3_PTR_t;   /** @brief CPUEMR3 register pointer type. */
    typedef uint32_t* const EXTI_CPUPR3_PTR_t;    /** @brief CPUPR3 register pointer type. */

    /**** @subsection EXTI Register Field Masks ****/

    static const uint32_t EXTI_D3PMR3_MR88_MASK     = 0x01000000U;   /** @brief D3 pending mask on event input x+64 */
    static const uint32_t EXTI_D3PCR3H_PCS88_MASK   = 0x000C0000U;   /** @brief D3 pending request clear input signal selection on event input x= truncate N+160/2 */

    /**** @subsection Enumerated EXTI Register Field Masks ****/

    static const uint32_t EXTI_RTSR1_TRx_MASK[22] = {
      [0]  = 0x00000001U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const uint32_t EXTI_SWIER1_SWIERx_MASK[22] = {
      [0]  = 0x00000001U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const uint32_t EXTI_D3PMR1_MRx_MASK[26] = {
      [0]  = 0x00000001U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
      [25] = 0x02000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const uint32_t EXTI_D3PCR1L_PCSx_MASK[16] = {
      [0]  = 0x00000003U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [1]  = 0x0000000CU,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [2]  = 0x00000030U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [3]  = 0x000000C0U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [4]  = 0x00000300U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [5]  = 0x00000C00U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [6]  = 0x00003000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [7]  = 0x0000C000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [8]  = 0x00030000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [9]  = 0x000C0000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [10] = 0x00300000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [11] = 0x00C00000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [12] = 0x03000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [13] = 0x0C000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [14] = 0x30000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [15] = 0xC0000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    };

    static const uint32_t EXTI_D3PMR2_MR3x_MASK[6] = {
      [5] = 0x00000008U,   /** @brief D3 pending mask on event input x+32 */
    };

    static const uint32_t EXTI_D3PCR2L_PCS3x_MASK[6] = {
      [4] = 0x00000030U,   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+64)/2) */
    };

    static const uint32_t EXTI_D3PCR2H_PCS4x_MASK[10] = {
      [9]  = 0x0000000CU,   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
    };

    static const uint32_t EXTI_RTSR3_TR8x_MASK[7] = {
      [2] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      [4] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      [5] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      [6] = 0x00400000U,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
    };

    static const uint32_t EXTI_SWIER3_SWIER8x_MASK[7] = {
      [2] = 0x00040000U,   /** @brief Software interrupt on line x+64 */
      [4] = 0x00100000U,   /** @brief Software interrupt on line x+64 */
      [5] = 0x00200000U,   /** @brief Software interrupt on line x+64 */
      [6] = 0x00400000U,   /** @brief Software interrupt on line x+64 */
    };

    static const uint32_t EXTI_CPUPR1_PRx_MASK[22] = {
      [0]  = 0x00000001U,   /** @brief CPU event mask on event input x */
      [1]  = 0x00000002U,   /** @brief CPU event mask on event input x */
      [2]  = 0x00000004U,   /** @brief CPU event mask on event input x */
      [3]  = 0x00000008U,   /** @brief CPU event mask on event input x */
      [4]  = 0x00000010U,   /** @brief CPU event mask on event input x */
      [5]  = 0x00000020U,   /** @brief CPU event mask on event input x */
      [6]  = 0x00000040U,   /** @brief CPU event mask on event input x */
      [7]  = 0x00000080U,   /** @brief CPU event mask on event input x */
      [8]  = 0x00000100U,   /** @brief CPU event mask on event input x */
      [9]  = 0x00000200U,   /** @brief CPU event mask on event input x */
      [10] = 0x00000400U,   /** @brief CPU event mask on event input x */
      [11] = 0x00000800U,   /** @brief CPU event mask on event input x */
      [12] = 0x00001000U,   /** @brief CPU event mask on event input x */
      [13] = 0x00002000U,   /** @brief CPU event mask on event input x */
      [14] = 0x00004000U,   /** @brief CPU event mask on event input x */
      [15] = 0x00008000U,   /** @brief CPU event mask on event input x */
      [16] = 0x00010000U,   /** @brief CPU event mask on event input x */
      [17] = 0x00020000U,   /** @brief CPU event mask on event input x */
      [18] = 0x00040000U,   /** @brief CPU event mask on event input x */
      [19] = 0x00080000U,   /** @brief CPU event mask on event input x */
      [20] = 0x00100000U,   /** @brief CPU event mask on event input x */
      [21] = 0x00200000U,   /** @brief CPU event mask on event input x */
    };

    static const uint32_t EXTI_CPUIMR3_MR6x_MASK[10] = {
      [5]  = 0x00000002U,   /** @brief CPU interrupt mask on direct event input x+64 */
      [6]  = 0x00000004U,   /** @brief CPU interrupt mask on direct event input x+64 */
      [7]  = 0x00000008U,   /** @brief CPU interrupt mask on direct event input x+64 */
      [8]  = 0x00000010U,   /** @brief CPU interrupt mask on direct event input x+64 */
      [9]  = 0x00000020U,   /** @brief CPU interrupt mask on direct event input x+64 */
    };

    static const uint32_t EXTI_CPUPR3_PR8x_MASK[7] = {
      [2] = 0x00040000U,   /** @brief Configurable event inputs x+64 pending bit */
      [4] = 0x00100000U,   /** @brief Configurable event inputs x+64 pending bit */
      [5] = 0x00200000U,   /** @brief Configurable event inputs x+64 pending bit */
      [6] = 0x00400000U,   /** @brief Configurable event inputs x+64 pending bit */
    };

    /**** @subsection EXTI Register Field Positions ****/

    static const int32_t EXTI_D3PMR3_MR88_POS     = 24;   /** @brief D3 pending mask on event input x+64 */
    static const int32_t EXTI_D3PCR3H_PCS88_POS   = 18;   /** @brief D3 pending request clear input signal selection on event input x= truncate N+160/2 */

    /**** @subsection Enumerated EXTI Register Field Positions ****/

    static const int32_t EXTI_RTSR1_TRx_POS[22] = {
      [0]  = 0,    /** @brief Rising trigger event configuration bit of configurable event input */
      [1]  = 1,    /** @brief Rising trigger event configuration bit of configurable event input */
      [2]  = 2,    /** @brief Rising trigger event configuration bit of configurable event input */
      [3]  = 3,    /** @brief Rising trigger event configuration bit of configurable event input */
      [4]  = 4,    /** @brief Rising trigger event configuration bit of configurable event input */
      [5]  = 5,    /** @brief Rising trigger event configuration bit of configurable event input */
      [6]  = 6,    /** @brief Rising trigger event configuration bit of configurable event input */
      [7]  = 7,    /** @brief Rising trigger event configuration bit of configurable event input */
      [8]  = 8,    /** @brief Rising trigger event configuration bit of configurable event input */
      [9]  = 9,    /** @brief Rising trigger event configuration bit of configurable event input */
      [10] = 10,   /** @brief Rising trigger event configuration bit of configurable event input */
      [11] = 11,   /** @brief Rising trigger event configuration bit of configurable event input */
      [12] = 12,   /** @brief Rising trigger event configuration bit of configurable event input */
      [13] = 13,   /** @brief Rising trigger event configuration bit of configurable event input */
      [14] = 14,   /** @brief Rising trigger event configuration bit of configurable event input */
      [15] = 15,   /** @brief Rising trigger event configuration bit of configurable event input */
      [16] = 16,   /** @brief Rising trigger event configuration bit of configurable event input */
      [17] = 17,   /** @brief Rising trigger event configuration bit of configurable event input */
      [18] = 18,   /** @brief Rising trigger event configuration bit of configurable event input */
      [19] = 19,   /** @brief Rising trigger event configuration bit of configurable event input */
      [20] = 20,   /** @brief Rising trigger event configuration bit of configurable event input */
      [21] = 21,   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const int32_t EXTI_SWIER1_SWIERx_POS[22] = {
      [0]  = 0,    /** @brief Rising trigger event configuration bit of configurable event input */
      [1]  = 1,    /** @brief Rising trigger event configuration bit of configurable event input */
      [2]  = 2,    /** @brief Rising trigger event configuration bit of configurable event input */
      [3]  = 3,    /** @brief Rising trigger event configuration bit of configurable event input */
      [4]  = 4,    /** @brief Rising trigger event configuration bit of configurable event input */
      [5]  = 5,    /** @brief Rising trigger event configuration bit of configurable event input */
      [6]  = 6,    /** @brief Rising trigger event configuration bit of configurable event input */
      [7]  = 7,    /** @brief Rising trigger event configuration bit of configurable event input */
      [8]  = 8,    /** @brief Rising trigger event configuration bit of configurable event input */
      [9]  = 9,    /** @brief Rising trigger event configuration bit of configurable event input */
      [10] = 10,   /** @brief Rising trigger event configuration bit of configurable event input */
      [11] = 11,   /** @brief Rising trigger event configuration bit of configurable event input */
      [12] = 12,   /** @brief Rising trigger event configuration bit of configurable event input */
      [13] = 13,   /** @brief Rising trigger event configuration bit of configurable event input */
      [14] = 14,   /** @brief Rising trigger event configuration bit of configurable event input */
      [15] = 15,   /** @brief Rising trigger event configuration bit of configurable event input */
      [16] = 16,   /** @brief Rising trigger event configuration bit of configurable event input */
      [17] = 17,   /** @brief Rising trigger event configuration bit of configurable event input */
      [18] = 18,   /** @brief Rising trigger event configuration bit of configurable event input */
      [19] = 19,   /** @brief Rising trigger event configuration bit of configurable event input */
      [20] = 20,   /** @brief Rising trigger event configuration bit of configurable event input */
      [21] = 21,   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const int32_t EXTI_D3PMR1_MRx_POS[26] = {
      [0]  = 0,    /** @brief Rising trigger event configuration bit of configurable event input */
      [1]  = 1,    /** @brief Rising trigger event configuration bit of configurable event input */
      [2]  = 2,    /** @brief Rising trigger event configuration bit of configurable event input */
      [3]  = 3,    /** @brief Rising trigger event configuration bit of configurable event input */
      [4]  = 4,    /** @brief Rising trigger event configuration bit of configurable event input */
      [5]  = 5,    /** @brief Rising trigger event configuration bit of configurable event input */
      [6]  = 6,    /** @brief Rising trigger event configuration bit of configurable event input */
      [7]  = 7,    /** @brief Rising trigger event configuration bit of configurable event input */
      [8]  = 8,    /** @brief Rising trigger event configuration bit of configurable event input */
      [9]  = 9,    /** @brief Rising trigger event configuration bit of configurable event input */
      [10] = 10,   /** @brief Rising trigger event configuration bit of configurable event input */
      [11] = 11,   /** @brief Rising trigger event configuration bit of configurable event input */
      [12] = 12,   /** @brief Rising trigger event configuration bit of configurable event input */
      [13] = 13,   /** @brief Rising trigger event configuration bit of configurable event input */
      [14] = 14,   /** @brief Rising trigger event configuration bit of configurable event input */
      [15] = 15,   /** @brief Rising trigger event configuration bit of configurable event input */
      [19] = 19,   /** @brief Rising trigger event configuration bit of configurable event input */
      [20] = 20,   /** @brief Rising trigger event configuration bit of configurable event input */
      [21] = 21,   /** @brief Rising trigger event configuration bit of configurable event input */
      [25] = 25,   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const int32_t EXTI_D3PCR1L_PCSx_POS[16] = {
      [0]  = 0,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [1]  = 2,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [2]  = 4,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [3]  = 6,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [4]  = 8,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [5]  = 10,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [6]  = 12,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [7]  = 14,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [8]  = 16,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [9]  = 18,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [10] = 20,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [11] = 22,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [12] = 24,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [13] = 26,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [14] = 28,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      [15] = 30,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    };

    static const int32_t EXTI_D3PMR2_MR3x_POS[6] = {
      [5] = 3,   /** @brief D3 pending mask on event input x+32 */
    };

    static const int32_t EXTI_D3PCR2L_PCS3x_POS[6] = {
      [4] = 4,   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+64)/2) */
    };

    static const int32_t EXTI_D3PCR2H_PCS4x_POS[10] = {
      [9]  = 2,   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
    };

    static const int32_t EXTI_RTSR3_TR8x_POS[7] = {
      [2] = 18,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      [4] = 20,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      [5] = 21,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      [6] = 22,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
    };

    static const int32_t EXTI_SWIER3_SWIER8x_POS[7] = {
      [2] = 18,   /** @brief Software interrupt on line x+64 */
      [4] = 20,   /** @brief Software interrupt on line x+64 */
      [5] = 21,   /** @brief Software interrupt on line x+64 */
      [6] = 22,   /** @brief Software interrupt on line x+64 */
    };

    static const int32_t EXTI_CPUPR1_PRx_POS[22] = {
      [0]  = 0,    /** @brief CPU event mask on event input x */
      [1]  = 1,    /** @brief CPU event mask on event input x */
      [2]  = 2,    /** @brief CPU event mask on event input x */
      [3]  = 3,    /** @brief CPU event mask on event input x */
      [4]  = 4,    /** @brief CPU event mask on event input x */
      [5]  = 5,    /** @brief CPU event mask on event input x */
      [6]  = 6,    /** @brief CPU event mask on event input x */
      [7]  = 7,    /** @brief CPU event mask on event input x */
      [8]  = 8,    /** @brief CPU event mask on event input x */
      [9]  = 9,    /** @brief CPU event mask on event input x */
      [10] = 10,   /** @brief CPU event mask on event input x */
      [11] = 11,   /** @brief CPU event mask on event input x */
      [12] = 12,   /** @brief CPU event mask on event input x */
      [13] = 13,   /** @brief CPU event mask on event input x */
      [14] = 14,   /** @brief CPU event mask on event input x */
      [15] = 15,   /** @brief CPU event mask on event input x */
      [16] = 16,   /** @brief CPU event mask on event input x */
      [17] = 17,   /** @brief CPU event mask on event input x */
      [18] = 18,   /** @brief CPU event mask on event input x */
      [19] = 19,   /** @brief CPU event mask on event input x */
      [20] = 20,   /** @brief CPU event mask on event input x */
      [21] = 21,   /** @brief CPU event mask on event input x */
    };

    static const int32_t EXTI_CPUIMR3_MR6x_POS[10] = {
      [5]  = 1,   /** @brief CPU interrupt mask on direct event input x+64 */
      [6]  = 2,   /** @brief CPU interrupt mask on direct event input x+64 */
      [7]  = 3,   /** @brief CPU interrupt mask on direct event input x+64 */
      [8]  = 4,   /** @brief CPU interrupt mask on direct event input x+64 */
      [9]  = 5,   /** @brief CPU interrupt mask on direct event input x+64 */
    };

    static const int32_t EXTI_CPUPR3_PR8x_POS[7] = {
      [2] = 18,   /** @brief Configurable event inputs x+64 pending bit */
      [4] = 20,   /** @brief Configurable event inputs x+64 pending bit */
      [5] = 21,   /** @brief Configurable event inputs x+64 pending bit */
      [6] = 22,   /** @brief Configurable event inputs x+64 pending bit */
    };

    /**********************************************************************************************
     * @section DELAY_BLOCK_SDMMCx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated DELAY_BLOCK_SDMMCx Register Pointers ****/

    static RW_ uint32_t* const DELAY_BLOCK_SDMMCx_CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52008000U,   /** @brief DLYB control register */
      [2] = (RW_ uint32_t* const)0x48022800U,   /** @brief DLYB control register */
    };

    static RW_ uint32_t* const DELAY_BLOCK_SDMMCx_CFGR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52008004U,   /** @brief DLYB configuration register */
      [2] = (RW_ uint32_t* const)0x48022804U,   /** @brief DLYB configuration register */
    };

    /**** @subsection Enumerated DELAY_BLOCK_SDMMCx Register Reset Values ****/

    static const uint32_t DELAY_BLOCK_SDMMCx_CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CR register reset value */
      [2] = 0x00000000U,   /** @brief CR register reset value */
    };

    static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CFGR register reset value */
      [2] = 0x00000000U,   /** @brief CFGR register reset value */
    };

    /**** @subsection Enumerated DELAY_BLOCK_SDMMCx Register Value Types ****/

    typedef uint32_t DELAY_BLOCK_SDMMCx_CR_t;     /** @brief CR register value type. */
    typedef uint32_t DELAY_BLOCK_SDMMCx_CFGR_t;   /** @brief CFGR register value type. */

    /**** @subsection Enumerated DELAY_BLOCK_SDMMCx Register Pointer Types ****/

    typedef uint32_t* const DELAY_BLOCK_SDMMCx_CR_PTR_t;     /** @brief CR register pointer type. */
    typedef uint32_t* const DELAY_BLOCK_SDMMCx_CFGR_PTR_t;   /** @brief CFGR register pointer type. */

    /**** @subsection DELAY_BLOCK_SDMMCx Register Field Masks ****/

    static const uint32_t DELAY_BLOCK_SDMMCx_CR_DEN_MASK      = 0x00000001U;   /** @brief Delay block enable bit */
    static const uint32_t DELAY_BLOCK_SDMMCx_CR_SEN_MASK      = 0x00000002U;   /** @brief Sampler length enable bit */
    static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_SEL_MASK    = 0x0000000FU;   /** @brief Select the phase for the output clock */
    static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_UNIT_MASK   = 0x00007F00U;   /** @brief Delay defines the delay of a unit delay cell */
    static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_LNG_MASK    = 0x0FFF0000U;   /** @brief Delay line length value */
    static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_LNGF_MASK   = 0x80000000U;   /** @brief Length valid flag */

    /**** @subsection DELAY_BLOCK_SDMMCx Register Field Positions ****/

    static const int32_t DELAY_BLOCK_SDMMCx_CR_DEN_POS      = 0;    /** @brief Delay block enable bit */
    static const int32_t DELAY_BLOCK_SDMMCx_CR_SEN_POS      = 1;    /** @brief Sampler length enable bit */
    static const int32_t DELAY_BLOCK_SDMMCx_CFGR_SEL_POS    = 0;    /** @brief Select the phase for the output clock */
    static const int32_t DELAY_BLOCK_SDMMCx_CFGR_UNIT_POS   = 8;    /** @brief Delay defines the delay of a unit delay cell */
    static const int32_t DELAY_BLOCK_SDMMCx_CFGR_LNG_POS    = 16;   /** @brief Delay line length value */
    static const int32_t DELAY_BLOCK_SDMMCx_CFGR_LNGF_POS   = 31;   /** @brief Length valid flag */

    /**********************************************************************************************
     * @section DELAY_BLOCK_QUADSPI Register Information
     **********************************************************************************************/

    /**** @subsection DELAY_BLOCK_QUADSPI Register Pointers ****/

    static RW_ uint32_t* const DELAY_BLOCK_QUADSPI_CR_PTR     = (RW_ uint32_t* const)0x52006000U;   /** @brief DLYB control register */
    static RW_ uint32_t* const DELAY_BLOCK_QUADSPI_CFGR_PTR   = (RW_ uint32_t* const)0x52006004U;   /** @brief DLYB configuration register */

    /**** @subsection DELAY_BLOCK_QUADSPI Register Reset Values ****/

    static const uint32_t DELAY_BLOCK_QUADSPI_CR_RST     = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_RST   = 0x00000000U;   /** @brief CFGR register reset value. */

    /**** @subsection Enumerated DELAY_BLOCK_QUADSPI Register Value Types ****/

    typedef uint32_t DELAY_BLOCK_QUADSPI_CR_t;     /** @brief CR register value type. */
    typedef uint32_t DELAY_BLOCK_QUADSPI_CFGR_t;   /** @brief CFGR register value type. */

    /**** @subsection Enumerated DELAY_BLOCK_QUADSPI Register Pointer Types ****/

    typedef uint32_t* const DELAY_BLOCK_QUADSPI_CR_PTR_t;     /** @brief CR register pointer type. */
    typedef uint32_t* const DELAY_BLOCK_QUADSPI_CFGR_PTR_t;   /** @brief CFGR register pointer type. */

    /**** @subsection DELAY_BLOCK_QUADSPI Register Field Masks ****/

    static const uint32_t DELAY_BLOCK_QUADSPI_CR_DEN_MASK      = 0x00000001U;   /** @brief Delay block enable bit */
    static const uint32_t DELAY_BLOCK_QUADSPI_CR_SEN_MASK      = 0x00000002U;   /** @brief Sampler length enable bit */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_SEL_MASK    = 0x0000000FU;   /** @brief Select the phase for the output clock */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_UNIT_MASK   = 0x00007F00U;   /** @brief Delay defines the delay of a unit delay cell */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_LNG_MASK    = 0x0FFF0000U;   /** @brief Delay line length value */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF_MASK   = 0x80000000U;   /** @brief Length valid flag */

    /**** @subsection DELAY_BLOCK_QUADSPI Register Field Positions ****/

    static const int32_t DELAY_BLOCK_QUADSPI_CR_DEN_POS      = 0;    /** @brief Delay block enable bit */
    static const int32_t DELAY_BLOCK_QUADSPI_CR_SEN_POS      = 1;    /** @brief Sampler length enable bit */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_SEL_POS    = 0;    /** @brief Select the phase for the output clock */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_UNIT_POS   = 8;    /** @brief Delay defines the delay of a unit delay cell */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_LNG_POS    = 16;   /** @brief Delay line length value */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF_POS   = 31;   /** @brief Length valid flag */

    /**********************************************************************************************
     * @section FLASH Register Information
     **********************************************************************************************/

    /**** @subsection FLASH Register Pointers ****/

    static RW_ uint32_t* const FLASH_ACR_PTR          = (RW_ uint32_t* const)0x52002000U;   /** @brief Access control register */
    static RW_ uint32_t* const FLASH_ACR__PTR         = (RW_ uint32_t* const)0x52002100U;   /** @brief Access control register */
    static RW_ uint32_t* const FLASH_KEYR1_PTR        = (RW_ uint32_t* const)0x52002004U;   /** @brief FLASH key register for bank 1 */
    static RW_ uint32_t* const FLASH_OPTKEYR_PTR      = (RW_ uint32_t* const)0x52002008U;   /** @brief FLASH option key register */
    static RW_ uint32_t* const FLASH_OPTKEYR__PTR     = (RW_ uint32_t* const)0x52002108U;   /** @brief FLASH option key register */
    static RW_ uint32_t* const FLASH_SR1_PTR          = (RW_ uint32_t* const)0x52002010U;   /** @brief FLASH status register for bank 1 */
    static RW_ uint32_t* const FLASH_OPTCR_PTR        = (RW_ uint32_t* const)0x52002018U;   /** @brief FLASH option control register */
    static RW_ uint32_t* const FLASH_OPTCR__PTR       = (RW_ uint32_t* const)0x52002118U;   /** @brief FLASH option control register */
    static RW_ uint32_t* const FLASH_OPTSR_CUR__PTR   = (RW_ uint32_t* const)0x5200211CU;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTSR_CUR_PTR    = (RW_ uint32_t* const)0x5200201CU;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTSR_PRG_PTR    = (RW_ uint32_t* const)0x52002020U;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTSR_PRG__PTR   = (RW_ uint32_t* const)0x52002120U;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTCCR__PTR      = (RW_ uint32_t* const)0x52002124U;   /** @brief FLASH option clear control register */
    static RW_ uint32_t* const FLASH_OPTCCR_PTR       = (RW_ uint32_t* const)0x52002024U;   /** @brief FLASH option clear control register */
    static RO_ uint32_t* const FLASH_BOOT_CURR_PTR    = (RO_ uint32_t* const)0x52002040U;   /** @brief FLASH register with boot address */
    static RO_ uint32_t* const FLASH_BOOT_PRGR_PTR    = (RO_ uint32_t* const)0x52002044U;   /** @brief FLASH register with boot address */
    static RW_ uint32_t* const FLASH_CRCDATAR_PTR     = (RW_ uint32_t* const)0x5200205CU;   /** @brief FLASH CRC data register */
    static RO_ uint32_t* const FLASH_KEYR2_PTR        = (RO_ uint32_t* const)0x52002104U;   /** @brief FLASH key register for bank 2 */
    static RW_ uint32_t* const FLASH_SR2_PTR          = (RW_ uint32_t* const)0x52002110U;   /** @brief FLASH status register for bank 2 */

    /**** @subsection Enumerated FLASH Register Pointers ****/

    static RW_ uint32_t* const FLASH_CRx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5200200CU,   /** @brief FLASH control register for bank 1 */
      [2] = (RW_ uint32_t* const)0x5200210CU,   /** @brief FLASH control register for bank 2 */
    };

    static RW_ uint32_t* const FLASH_CCRx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52002014U,   /** @brief FLASH clear control register for bank 1 */
      [2] = (RW_ uint32_t* const)0x52002114U,   /** @brief FLASH clear control register for bank 2 */
    };

    static RO_ uint32_t* const FLASH_PRAR_CURx_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x52002028U,   /** @brief FLASH protection address for bank 1 */
      [2] = (RO_ uint32_t* const)0x52002128U,   /** @brief FLASH protection address for bank 1 */
    };

    static RW_ uint32_t* const FLASH_PRAR_PRGx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5200202CU,   /** @brief FLASH protection address for bank 1 */
      [2] = (RW_ uint32_t* const)0x5200202CU,   /** @brief FLASH protection address for bank 2 */
    };

    static RW_ uint32_t* const FLASH_SCAR_CURx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52002030U,   /** @brief FLASH secure address for bank 1 */
      [2] = (RW_ uint32_t* const)0x52002130U,   /** @brief FLASH secure address for bank 2 */
    };

    static RW_ uint32_t* const FLASH_SCAR_PRGx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52002034U,   /** @brief FLASH secure address for bank 1 */
      [2] = (RW_ uint32_t* const)0x52002134U,   /** @brief FLASH secure address for bank 2 */
    };

    static RO_ uint32_t* const FLASH_WPSN_CURxR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x52002038U,   /** @brief FLASH write sector protection for bank 1 */
      [2] = (RO_ uint32_t* const)0x52002138U,   /** @brief FLASH write sector protection for bank 2 */
    };

    static RW_ uint32_t* const FLASH_WPSN_PRGxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5200203CU,   /** @brief FLASH write sector protection for bank 1 */
      [2] = (RW_ uint32_t* const)0x5200213CU,   /** @brief FLASH write sector protection for bank 2 */
    };

    static RW_ uint32_t* const FLASH_CRCCRx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52002050U,   /** @brief FLASH CRC control register for bank 1 */
      [2] = (RW_ uint32_t* const)0x52002150U,   /** @brief FLASH CRC control register for bank 1 */
    };

    static RW_ uint32_t* const FLASH_CRCSADDxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52002054U,   /** @brief FLASH CRC start address register for bank 1 */
      [2] = (RW_ uint32_t* const)0x52002154U,   /** @brief FLASH CRC start address register for bank 2 */
    };

    static RW_ uint32_t* const FLASH_CRCEADDxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x52002058U,   /** @brief FLASH CRC end address register for bank 1 */
      [2] = (RW_ uint32_t* const)0x52002158U,   /** @brief FLASH CRC end address register for bank 2 */
    };

    static RO_ uint32_t* const FLASH_ECC_FAxR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x52002060U,   /** @brief FLASH ECC fail address for bank 1 */
      [2] = (RO_ uint32_t* const)0x52002160U,   /** @brief FLASH ECC fail address for bank 2 */
    };

    /**** @subsection FLASH Register Reset Values ****/

    static const uint32_t FLASH_ACR_RST          = 0x00000600U;   /** @brief ACR register reset value. */
    static const uint32_t FLASH_ACR__RST         = 0x00000000U;   /** @brief ACR_ register reset value. */
    static const uint32_t FLASH_KEYR1_RST        = 0x00000000U;   /** @brief KEYR1 register reset value. */
    static const uint32_t FLASH_OPTKEYR_RST      = 0x00000000U;   /** @brief OPTKEYR register reset value. */
    static const uint32_t FLASH_OPTKEYR__RST     = 0x00000000U;   /** @brief OPTKEYR_ register reset value. */
    static const uint32_t FLASH_SR1_RST          = 0x00000000U;   /** @brief SR1 register reset value. */
    static const uint32_t FLASH_OPTCR_RST        = 0x00000000U;   /** @brief OPTCR register reset value. */
    static const uint32_t FLASH_OPTCR__RST       = 0x00000000U;   /** @brief OPTCR_ register reset value. */
    static const uint32_t FLASH_OPTSR_CUR__RST   = 0x00000000U;   /** @brief OPTSR_CUR_ register reset value. */
    static const uint32_t FLASH_OPTSR_CUR_RST    = 0x00000000U;   /** @brief OPTSR_CUR register reset value. */
    static const uint32_t FLASH_OPTSR_PRG_RST    = 0x00000000U;   /** @brief OPTSR_PRG register reset value. */
    static const uint32_t FLASH_OPTSR_PRG__RST   = 0x00000000U;   /** @brief OPTSR_PRG_ register reset value. */
    static const uint32_t FLASH_OPTCCR__RST      = 0x00000000U;   /** @brief OPTCCR_ register reset value. */
    static const uint32_t FLASH_OPTCCR_RST       = 0x00000000U;   /** @brief OPTCCR register reset value. */
    static const uint32_t FLASH_BOOT_CURR_RST    = 0x00000000U;   /** @brief BOOT_CURR register reset value. */
    static const uint32_t FLASH_BOOT_PRGR_RST    = 0x00000000U;   /** @brief BOOT_PRGR register reset value. */
    static const uint32_t FLASH_CRCDATAR_RST     = 0x00000000U;   /** @brief CRCDATAR register reset value. */
    static const uint32_t FLASH_KEYR2_RST        = 0x00000000U;   /** @brief KEYR2 register reset value. */
    static const uint32_t FLASH_SR2_RST          = 0x00000000U;   /** @brief SR2 register reset value. */

    /**** @subsection Enumerated FLASH Register Reset Values ****/

    static const uint32_t FLASH_CRx_RST[3] = {
      [1] = 0x00000000U,   /** @brief CR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CR2 register reset value. */
    };

    static const uint32_t FLASH_CCRx_RST[3] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
    };

    static const uint32_t FLASH_PRAR_CURx_RST[3] = {
      [1] = 0x00000000U,   /** @brief PRAR_CUR1 register reset value. */
      [2] = 0x00000000U,   /** @brief PRAR_CUR2 register reset value. */
    };

    static const uint32_t FLASH_PRAR_PRGx_RST[3] = {
      [1] = 0x00000000U,   /** @brief PRAR_PRG1 register reset value. */
      [2] = 0x00000000U,   /** @brief PRAR_PRG2 register reset value. */
    };

    static const uint32_t FLASH_SCAR_CURx_RST[3] = {
      [1] = 0x00000000U,   /** @brief SCAR_CUR1 register reset value. */
      [2] = 0x00000000U,   /** @brief SCAR_CUR2 register reset value. */
    };

    static const uint32_t FLASH_SCAR_PRGx_RST[3] = {
      [1] = 0x00000000U,   /** @brief SCAR_PRG1 register reset value. */
      [2] = 0x00000000U,   /** @brief SCAR_PRG2 register reset value. */
    };

    static const uint32_t FLASH_WPSN_CURxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief WPSN_CUR1R register reset value. */
      [2] = 0x00000000U,   /** @brief WPSN_CUR2R register reset value. */
    };

    static const uint32_t FLASH_WPSN_PRGxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief WPSN_PRG1R register reset value. */
      [2] = 0x00000000U,   /** @brief WPSN_PRG2R register reset value. */
    };

    static const uint32_t FLASH_CRCCRx_RST[3] = {
      [1] = 0x00000000U,   /** @brief CRCCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CRCCR2 register reset value. */
    };

    static const uint32_t FLASH_CRCSADDxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CRCSADD1R register reset value. */
      [2] = 0x00000000U,   /** @brief CRCSADD2R register reset value. */
    };

    static const uint32_t FLASH_CRCEADDxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CRCEADD1R register reset value. */
      [2] = 0x00000000U,   /** @brief CRCEADD2R register reset value. */
    };

    static const uint32_t FLASH_ECC_FAxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief ECC_FA1R register reset value. */
      [2] = 0x00000000U,   /** @brief ECC_FA2R register reset value. */
    };

    /**** @subsection Enumerated FLASH Register Value Types ****/

    typedef uint32_t FLASH_ACR_t;          /** @brief ACR register value type. */
    typedef uint32_t FLASH_ACR__t;         /** @brief ACR_ register value type. */
    typedef uint32_t FLASH_KEYR1_t;        /** @brief KEYR1 register value type. */
    typedef uint32_t FLASH_OPTKEYR_t;      /** @brief OPTKEYR register value type. */
    typedef uint32_t FLASH_OPTKEYR__t;     /** @brief OPTKEYR_ register value type. */
    typedef uint32_t FLASH_CRx_t;          /** @brief CRx register value type. */
    typedef uint32_t FLASH_SR1_t;          /** @brief SR1 register value type. */
    typedef uint32_t FLASH_CCRx_t;         /** @brief CCRx register value type. */
    typedef uint32_t FLASH_OPTCR_t;        /** @brief OPTCR register value type. */
    typedef uint32_t FLASH_OPTCR__t;       /** @brief OPTCR_ register value type. */
    typedef uint32_t FLASH_OPTSR_CUR__t;   /** @brief OPTSR_CUR_ register value type. */
    typedef uint32_t FLASH_OPTSR_CUR_t;    /** @brief OPTSR_CUR register value type. */
    typedef uint32_t FLASH_OPTSR_PRG_t;    /** @brief OPTSR_PRG register value type. */
    typedef uint32_t FLASH_OPTSR_PRG__t;   /** @brief OPTSR_PRG_ register value type. */
    typedef uint32_t FLASH_OPTCCR__t;      /** @brief OPTCCR_ register value type. */
    typedef uint32_t FLASH_OPTCCR_t;       /** @brief OPTCCR register value type. */
    typedef uint32_t FLASH_PRAR_CURx_t;    /** @brief PRAR_CURx register value type. */
    typedef uint32_t FLASH_PRAR_PRGx_t;    /** @brief PRAR_PRGx register value type. */
    typedef uint32_t FLASH_SCAR_CURx_t;    /** @brief SCAR_CURx register value type. */
    typedef uint32_t FLASH_SCAR_PRGx_t;    /** @brief SCAR_PRGx register value type. */
    typedef uint32_t FLASH_WPSN_CURxR_t;   /** @brief WPSN_CURxR register value type. */
    typedef uint32_t FLASH_WPSN_PRGxR_t;   /** @brief WPSN_PRGxR register value type. */
    typedef uint32_t FLASH_BOOT_CURR_t;    /** @brief BOOT_CURR register value type. */
    typedef uint32_t FLASH_BOOT_PRGR_t;    /** @brief BOOT_PRGR register value type. */
    typedef uint32_t FLASH_CRCCRx_t;       /** @brief CRCCRx register value type. */
    typedef uint32_t FLASH_CRCSADDxR_t;    /** @brief CRCSADDxR register value type. */
    typedef uint32_t FLASH_CRCEADDxR_t;    /** @brief CRCEADDxR register value type. */
    typedef uint32_t FLASH_CRCDATAR_t;     /** @brief CRCDATAR register value type. */
    typedef uint32_t FLASH_ECC_FAxR_t;     /** @brief ECC_FAxR register value type. */
    typedef uint32_t FLASH_KEYR2_t;        /** @brief KEYR2 register value type. */
    typedef uint32_t FLASH_SR2_t;          /** @brief SR2 register value type. */

    /**** @subsection Enumerated FLASH Register Pointer Types ****/

    typedef uint32_t* const FLASH_ACR_PTR_t;          /** @brief ACR register pointer type. */
    typedef uint32_t* const FLASH_ACR__PTR_t;         /** @brief ACR_ register pointer type. */
    typedef uint32_t* const FLASH_KEYR1_PTR_t;        /** @brief KEYR1 register pointer type. */
    typedef uint32_t* const FLASH_OPTKEYR_PTR_t;      /** @brief OPTKEYR register pointer type. */
    typedef uint32_t* const FLASH_OPTKEYR__PTR_t;     /** @brief OPTKEYR_ register pointer type. */
    typedef uint32_t* const FLASH_CRx_PTR_t;          /** @brief CRx register pointer type. */
    typedef uint32_t* const FLASH_SR1_PTR_t;          /** @brief SR1 register pointer type. */
    typedef uint32_t* const FLASH_CCRx_PTR_t;         /** @brief CCRx register pointer type. */
    typedef uint32_t* const FLASH_OPTCR_PTR_t;        /** @brief OPTCR register pointer type. */
    typedef uint32_t* const FLASH_OPTCR__PTR_t;       /** @brief OPTCR_ register pointer type. */
    typedef uint32_t* const FLASH_OPTSR_CUR__PTR_t;   /** @brief OPTSR_CUR_ register pointer type. */
    typedef uint32_t* const FLASH_OPTSR_CUR_PTR_t;    /** @brief OPTSR_CUR register pointer type. */
    typedef uint32_t* const FLASH_OPTSR_PRG_PTR_t;    /** @brief OPTSR_PRG register pointer type. */
    typedef uint32_t* const FLASH_OPTSR_PRG__PTR_t;   /** @brief OPTSR_PRG_ register pointer type. */
    typedef uint32_t* const FLASH_OPTCCR__PTR_t;      /** @brief OPTCCR_ register pointer type. */
    typedef uint32_t* const FLASH_OPTCCR_PTR_t;       /** @brief OPTCCR register pointer type. */
    typedef uint32_t* const FLASH_PRAR_CURx_PTR_t;    /** @brief PRAR_CURx register pointer type. */
    typedef uint32_t* const FLASH_PRAR_PRGx_PTR_t;    /** @brief PRAR_PRGx register pointer type. */
    typedef uint32_t* const FLASH_SCAR_CURx_PTR_t;    /** @brief SCAR_CURx register pointer type. */
    typedef uint32_t* const FLASH_SCAR_PRGx_PTR_t;    /** @brief SCAR_PRGx register pointer type. */
    typedef uint32_t* const FLASH_WPSN_CURxR_PTR_t;   /** @brief WPSN_CURxR register pointer type. */
    typedef uint32_t* const FLASH_WPSN_PRGxR_PTR_t;   /** @brief WPSN_PRGxR register pointer type. */
    typedef uint32_t* const FLASH_BOOT_CURR_PTR_t;    /** @brief BOOT_CURR register pointer type. */
    typedef uint32_t* const FLASH_BOOT_PRGR_PTR_t;    /** @brief BOOT_PRGR register pointer type. */
    typedef uint32_t* const FLASH_CRCCRx_PTR_t;       /** @brief CRCCRx register pointer type. */
    typedef uint32_t* const FLASH_CRCSADDxR_PTR_t;    /** @brief CRCSADDxR register pointer type. */
    typedef uint32_t* const FLASH_CRCEADDxR_PTR_t;    /** @brief CRCEADDxR register pointer type. */
    typedef uint32_t* const FLASH_CRCDATAR_PTR_t;     /** @brief CRCDATAR register pointer type. */
    typedef uint32_t* const FLASH_ECC_FAxR_PTR_t;     /** @brief ECC_FAxR register pointer type. */
    typedef uint32_t* const FLASH_KEYR2_PTR_t;        /** @brief KEYR2 register pointer type. */
    typedef uint32_t* const FLASH_SR2_PTR_t;          /** @brief SR2 register pointer type. */

    /**** @subsection FLASH Register Field Masks ****/

    static const uint32_t FLASH_ACR_LATENCY_MASK                  = 0x00000007U;   /** @brief Read latency */
    static const uint32_t FLASH_ACR_WRHIGHFREQ_MASK               = 0x00000030U;   /** @brief Flash signal delay */
    static const uint32_t FLASH_ACR__LATENCY_MASK                 = 0x00000007U;   /** @brief Read latency */
    static const uint32_t FLASH_ACR__WRHIGHFREQ_MASK              = 0x00000030U;   /** @brief Flash signal delay */
    static const uint32_t FLASH_CRx_LOCK1_MASK                    = 0x00000001U;   /** @brief Bank 1 configuration lock bit */
    static const uint32_t FLASH_CRx_PG1_MASK                      = 0x00000002U;   /** @brief Bank 1 program enable bit */
    static const uint32_t FLASH_CRx_SER1_MASK                     = 0x00000004U;   /** @brief Bank 1 sector erase request */
    static const uint32_t FLASH_CRx_BER1_MASK                     = 0x00000008U;   /** @brief Bank 1 erase request */
    static const uint32_t FLASH_CRx_PSIZE1_MASK                   = 0x00000030U;   /** @brief Bank 1 program size */
    static const uint32_t FLASH_CRx_FW1_MASK                      = 0x00000040U;   /** @brief Bank 1 write forcing control bit */
    static const uint32_t FLASH_CRx_START1_MASK                   = 0x00000080U;   /** @brief Bank 1 bank or sector erase start control bit */
    static const uint32_t FLASH_CRx_SNB1_MASK                     = 0x00000700U;   /** @brief Bank 1 sector erase selection number */
    static const uint32_t FLASH_CRx_CRC_EN_MASK                   = 0x00008000U;   /** @brief Bank 1 CRC control bit */
    static const uint32_t FLASH_CRx_EOPIE1_MASK                   = 0x00010000U;   /** @brief Bank 1 end-of-program interrupt control bit */
    static const uint32_t FLASH_CRx_WRPERRIE1_MASK                = 0x00020000U;   /** @brief Bank 1 write protection error interrupt enable bit */
    static const uint32_t FLASH_CRx_PGSERRIE1_MASK                = 0x00040000U;   /** @brief Bank 1 programming sequence error interrupt enable bit */
    static const uint32_t FLASH_CRx_STRBERRIE1_MASK               = 0x00080000U;   /** @brief Bank 1 strobe error interrupt enable bit */
    static const uint32_t FLASH_CRx_INCERRIE1_MASK                = 0x00200000U;   /** @brief Bank 1 inconsistency error interrupt enable bit */
    static const uint32_t FLASH_CRx_OPERRIE1_MASK                 = 0x00400000U;   /** @brief Bank 1 write/erase error interrupt enable bit */
    static const uint32_t FLASH_CRx_RDPERRIE1_MASK                = 0x00800000U;   /** @brief Bank 1 read protection error interrupt enable bit */
    static const uint32_t FLASH_CRx_RDSERRIE1_MASK                = 0x01000000U;   /** @brief Bank 1 secure error interrupt enable bit */
    static const uint32_t FLASH_CRx_SNECCERRIE1_MASK              = 0x02000000U;   /** @brief Bank 1 ECC single correction error interrupt enable bit */
    static const uint32_t FLASH_CRx_DBECCERRIE1_MASK              = 0x04000000U;   /** @brief Bank 1 ECC double detection error interrupt enable bit */
    static const uint32_t FLASH_CRx_CRCENDIE1_MASK                = 0x08000000U;   /** @brief Bank 1 end of CRC calculation interrupt enable bit */
    static const uint32_t FLASH_SR1_BSY1_MASK                     = 0x00000001U;   /** @brief Bank 1 ongoing program flag */
    static const uint32_t FLASH_SR1_WBNE1_MASK                    = 0x00000002U;   /** @brief Bank 1 write buffer not empty flag */
    static const uint32_t FLASH_SR1_QW1_MASK                      = 0x00000004U;   /** @brief Bank 1 wait queue flag */
    static const uint32_t FLASH_SR1_CRC_BUSY1_MASK                = 0x00000008U;   /** @brief Bank 1 CRC busy flag */
    static const uint32_t FLASH_SR1_EOP1_MASK                     = 0x00010000U;   /** @brief Bank 1 end-of-program flag */
    static const uint32_t FLASH_SR1_WRPERR1_MASK                  = 0x00020000U;   /** @brief Bank 1 write protection error flag */
    static const uint32_t FLASH_SR1_PGSERR1_MASK                  = 0x00040000U;   /** @brief Bank 1 programming sequence error flag */
    static const uint32_t FLASH_SR1_STRBERR1_MASK                 = 0x00080000U;   /** @brief Bank 1 strobe error flag */
    static const uint32_t FLASH_SR1_INCERR1_MASK                  = 0x00200000U;   /** @brief Bank 1 inconsistency error flag */
    static const uint32_t FLASH_SR1_OPERR1_MASK                   = 0x00400000U;   /** @brief Bank 1 write/erase error flag */
    static const uint32_t FLASH_SR1_RDPERR1_MASK                  = 0x00800000U;   /** @brief Bank 1 read protection error flag */
    static const uint32_t FLASH_SR1_RDSERR1_MASK                  = 0x01000000U;   /** @brief Bank 1 secure error flag */
    static const uint32_t FLASH_SR1_SNECCERR11_MASK               = 0x02000000U;   /** @brief Bank 1 single correction error flag */
    static const uint32_t FLASH_SR1_DBECCERR1_MASK                = 0x04000000U;   /** @brief Bank 1 ECC double detection error flag */
    static const uint32_t FLASH_SR1_CRCEND1_MASK                  = 0x08000000U;   /** @brief Bank 1 crc-complete flag */
    static const uint32_t FLASH_CCRx_CLR_EOP1_MASK                = 0x00010000U;   /** @brief Bank 1 EOP1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_WRPERR1_MASK             = 0x00020000U;   /** @brief Bank 1 WRPERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_PGSERR1_MASK             = 0x00040000U;   /** @brief Bank 1 PGSERR1 flag clear bi */
    static const uint32_t FLASH_CCRx_CLR_STRBERR1_MASK            = 0x00080000U;   /** @brief Bank 1 STRBERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_INCERR1_MASK             = 0x00200000U;   /** @brief Bank 1 INCERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_OPERR1_MASK              = 0x00400000U;   /** @brief Bank 1 OPERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_RDPERR1_MASK             = 0x00800000U;   /** @brief Bank 1 RDPERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_RDSERR1_MASK             = 0x01000000U;   /** @brief Bank 1 RDSERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_SNECCERR1_MASK           = 0x02000000U;   /** @brief Bank 1 SNECCERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_DBECCERR1_MASK           = 0x04000000U;   /** @brief Bank 1 DBECCERR1 flag clear bit */
    static const uint32_t FLASH_CCRx_CLR_CRCEND1_MASK             = 0x08000000U;   /** @brief Bank 1 CRCEND1 flag clear bit */
    static const uint32_t FLASH_OPTCR_OPTLOCK_MASK                = 0x00000001U;   /** @brief FLASH_OPTCR lock option configuration bit */
    static const uint32_t FLASH_OPTCR_OPTSTART_MASK               = 0x00000002U;   /** @brief Option byte start change option configuration bit */
    static const uint32_t FLASH_OPTCR_MER_MASK                    = 0x00000010U;   /** @brief Flash mass erase enable bit */
    static const uint32_t FLASH_OPTCR_OPTCHANGEERRIE_MASK         = 0x40000000U;   /** @brief Option byte change error interrupt enable bit */
    static const uint32_t FLASH_OPTCR_SWAP_BANK_MASK              = 0x80000000U;   /** @brief Bank swapping configuration bit */
    static const uint32_t FLASH_OPTCR__OPTLOCK_MASK               = 0x00000001U;   /** @brief FLASH_OPTCR lock option configuration bit */
    static const uint32_t FLASH_OPTCR__OPTSTART_MASK              = 0x00000002U;   /** @brief Option byte start change option configuration bit */
    static const uint32_t FLASH_OPTCR__MER_MASK                   = 0x00000010U;   /** @brief Flash mass erase enable bit */
    static const uint32_t FLASH_OPTCR__OPTCHANGEERRIE_MASK        = 0x40000000U;   /** @brief Option byte change error interrupt enable bit */
    static const uint32_t FLASH_OPTCR__SWAP_BANK_MASK             = 0x80000000U;   /** @brief Bank swapping configuration bit */
    static const uint32_t FLASH_OPTSR_CUR__OPT_BUSY_MASK          = 0x00000001U;   /** @brief Option byte change ongoing flag */
    static const uint32_t FLASH_OPTSR_CUR__BOR_LEV_MASK           = 0x0000000CU;   /** @brief Brownout level option status bit */
    static const uint32_t FLASH_OPTSR_CUR__IWDG1_HW_MASK          = 0x00000010U;   /** @brief IWDG1 control option status bit */
    static const uint32_t FLASH_OPTSR_CUR__NRST_STOP_D1_MASK      = 0x00000040U;   /** @brief D1 dstop entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR__NRST_STBY_D1_MASK      = 0x00000080U;   /** @brief D1 dstandby entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR__RDP_MASK               = 0x0000FF00U;   /** @brief Readout protection level option status byte */
    static const uint32_t FLASH_OPTSR_CUR__FZ_IWDG_STOP_MASK      = 0x00020000U;   /** @brief IWDG stop mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR__FZ_IWDG_SDBY_MASK      = 0x00040000U;   /** @brief IWDG standby mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR__ST_RAM_SIZE_MASK       = 0x00180000U;   /** @brief DTCM RAM size option status */
    static const uint32_t FLASH_OPTSR_CUR__SECURITY_MASK          = 0x00200000U;   /** @brief Security enable option status bit */
    static const uint32_t FLASH_OPTSR_CUR__RSS1_MASK              = 0x04000000U;   /** @brief User option bit 1 */
    static const uint32_t FLASH_OPTSR_CUR__PERSO_OK_MASK          = 0x10000000U;   /** @brief Device personalization status bit */
    static const uint32_t FLASH_OPTSR_CUR__IO_HSLV_MASK           = 0x20000000U;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_CUR__OPTCHANGEERR_MASK      = 0x40000000U;   /** @brief Option byte change error flag */
    static const uint32_t FLASH_OPTSR_CUR__SWAP_BANK_OPT_MASK     = 0x80000000U;   /** @brief Bank swapping option status bit */
    static const uint32_t FLASH_OPTSR_CUR_OPT_BUSY_MASK           = 0x00000001U;   /** @brief Option byte change ongoing flag */
    static const uint32_t FLASH_OPTSR_CUR_BOR_LEV_MASK            = 0x0000000CU;   /** @brief Brownout level option status bit */
    static const uint32_t FLASH_OPTSR_CUR_IWDG1_HW_MASK           = 0x00000010U;   /** @brief IWDG1 control option status bit */
    static const uint32_t FLASH_OPTSR_CUR_NRST_STOP_D1_MASK       = 0x00000040U;   /** @brief D1 dstop entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR_NRST_STBY_D1_MASK       = 0x00000080U;   /** @brief D1 dstandby entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR_RDP_MASK                = 0x0000FF00U;   /** @brief Readout protection level option status byte */
    static const uint32_t FLASH_OPTSR_CUR_FZ_IWDG_STOP_MASK       = 0x00020000U;   /** @brief IWDG stop mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR_FZ_IWDG_SDBY_MASK       = 0x00040000U;   /** @brief IWDG standby mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR_ST_RAM_SIZE_MASK        = 0x00180000U;   /** @brief DTCM RAM size option status */
    static const uint32_t FLASH_OPTSR_CUR_SECURITY_MASK           = 0x00200000U;   /** @brief Security enable option status bit */
    static const uint32_t FLASH_OPTSR_CUR_RSS1_MASK               = 0x04000000U;   /** @brief User option bit 1 */
    static const uint32_t FLASH_OPTSR_CUR_PERSO_OK_MASK           = 0x10000000U;   /** @brief Device personalization status bit */
    static const uint32_t FLASH_OPTSR_CUR_IO_HSLV_MASK            = 0x20000000U;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_CUR_OPTCHANGEERR_MASK       = 0x40000000U;   /** @brief Option byte change error flag */
    static const uint32_t FLASH_OPTSR_CUR_SWAP_BANK_OPT_MASK      = 0x80000000U;   /** @brief Bank swapping option status bit */
    static const uint32_t FLASH_OPTSR_PRG_BOR_LEV_MASK            = 0x0000000CU;   /** @brief BOR reset level option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG_IWDG1_HW_MASK           = 0x00000010U;   /** @brief IWDG1 option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_NRST_STOP_D1_MASK       = 0x00000040U;   /** @brief Option byte erase after D1 dstop option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_NRST_STBY_D1_MASK       = 0x00000080U;   /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_RDP_MASK                = 0x0000FF00U;   /** @brief Readout protection level option configuration byte */
    static const uint32_t FLASH_OPTSR_PRG_FZ_IWDG_STOP_MASK       = 0x00020000U;   /** @brief IWDG stop mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_FZ_IWDG_SDBY_MASK       = 0x00040000U;   /** @brief IWDG standby mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_ST_RAM_SIZE_MASK        = 0x00180000U;   /** @brief DTCM size select option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG_SECURITY_MASK           = 0x00200000U;   /** @brief Security option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_IO_HSLV_MASK            = 0x20000000U;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_PRG_SWAP_BANK_OPT_MASK      = 0x80000000U;   /** @brief Bank swapping option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__BOR_LEV_MASK           = 0x0000000CU;   /** @brief BOR reset level option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG__IWDG1_HW_MASK          = 0x00000010U;   /** @brief IWDG1 option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__NRST_STOP_D1_MASK      = 0x00000040U;   /** @brief Option byte erase after D1 dstop option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__NRST_STBY_D1_MASK      = 0x00000080U;   /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__RDP_MASK               = 0x0000FF00U;   /** @brief Readout protection level option configuration byte */
    static const uint32_t FLASH_OPTSR_PRG__FZ_IWDG_STOP_MASK      = 0x00020000U;   /** @brief IWDG stop mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__FZ_IWDG_SDBY_MASK      = 0x00040000U;   /** @brief IWDG standby mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__ST_RAM_SIZE_MASK       = 0x00180000U;   /** @brief DTCM size select option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG__SECURITY_MASK          = 0x00200000U;   /** @brief Security option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__IO_HSLV_MASK           = 0x20000000U;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_PRG__SWAP_BANK_OPT_MASK     = 0x80000000U;   /** @brief Bank swapping option configuration bit */
    static const uint32_t FLASH_OPTCCR__CLR_OPTCHANGEERR_MASK     = 0x40000000U;   /** @brief OPTCHANGEERR reset bit */
    static const uint32_t FLASH_OPTCCR_CLR_OPTCHANGEERR_MASK      = 0x40000000U;   /** @brief OPTCHANGEERR reset bit */
    static const uint32_t FLASH_PRAR_CURx_PROT_AREA_START1_MASK   = 0x00000FFFU;   /** @brief Bank 1 lowest PCROP protected address */
    static const uint32_t FLASH_PRAR_CURx_PROT_AREA_END1_MASK     = 0x0FFF0000U;   /** @brief Bank 1 highest PCROP protected address */
    static const uint32_t FLASH_PRAR_CURx_DMEP1_MASK              = 0x80000000U;   /** @brief Bank 1 PCROP protected erase enable option status bit */
    static const uint32_t FLASH_PRAR_PRGx_PROT_AREA_START1_MASK   = 0x00000FFFU;   /** @brief Bank 1 lowest PCROP protected address configuration */
    static const uint32_t FLASH_PRAR_PRGx_PROT_AREA_END1_MASK     = 0x0FFF0000U;   /** @brief Bank 1 highest PCROP protected address configuration */
    static const uint32_t FLASH_PRAR_PRGx_DMEP1_MASK              = 0x80000000U;   /** @brief Bank 1 PCROP protected erase enable option configuration bit */
    static const uint32_t FLASH_SCAR_CURx_SEC_AREA_START1_MASK    = 0x00000FFFU;   /** @brief Bank 1 lowest secure protected address */
    static const uint32_t FLASH_SCAR_CURx_SEC_AREA_END1_MASK      = 0x0FFF0000U;   /** @brief Bank 1 highest secure protected address */
    static const uint32_t FLASH_SCAR_CURx_DMES1_MASK              = 0x80000000U;   /** @brief Bank 1 secure protected erase enable option status bit */
    static const uint32_t FLASH_SCAR_PRGx_SEC_AREA_START1_MASK    = 0x00000FFFU;   /** @brief Bank 1 lowest secure protected address configuration */
    static const uint32_t FLASH_SCAR_PRGx_SEC_AREA_END1_MASK      = 0x0FFF0000U;   /** @brief Bank 1 highest secure protected address configuration */
    static const uint32_t FLASH_SCAR_PRGx_DMES1_MASK              = 0x80000000U;   /** @brief Bank 1 secure protected erase enable option configuration bit */
    static const uint32_t FLASH_WPSN_CURxR_WRPSN1_MASK            = 0x000000FFU;   /** @brief Bank 1 sector write protection option status byte */
    static const uint32_t FLASH_WPSN_PRGxR_WRPSN1_MASK            = 0x000000FFU;   /** @brief Bank 1 sector write protection configuration byte */
    static const uint32_t FLASH_CRCCRx_CRC_SECT_MASK              = 0x00000007U;   /** @brief Bank 1 CRC sector number */
    static const uint32_t FLASH_CRCCRx_ALL_BANK_MASK              = 0x00000080U;   /** @brief Bank 1 CRC select bit */
    static const uint32_t FLASH_CRCCRx_CRC_BY_SECT_MASK           = 0x00000100U;   /** @brief Bank 1 CRC sector mode select bit */
    static const uint32_t FLASH_CRCCRx_ADD_SECT_MASK              = 0x00000200U;   /** @brief Bank 1 CRC sector select bit */
    static const uint32_t FLASH_CRCCRx_CLEAN_SECT_MASK            = 0x00000400U;   /** @brief Bank 1 CRC sector list clear bit */
    static const uint32_t FLASH_CRCCRx_START_CRC_MASK             = 0x00010000U;   /** @brief Bank 1 CRC start bit */
    static const uint32_t FLASH_CRCCRx_CLEAN_CRC_MASK             = 0x00020000U;   /** @brief Bank 1 CRC clear bit */
    static const uint32_t FLASH_CRCCRx_CRC_BURST_MASK             = 0x00300000U;   /** @brief Bank 1 CRC burst size */
    static const uint32_t FLASH_ECC_FAxR_FAIL_ECC_ADDR1_MASK      = 0x00007FFFU;   /** @brief Bank 1 ECC error address */
    static const uint32_t FLASH_SR2_BSY2_MASK                     = 0x00000001U;   /** @brief Bank 2 ongoing program flag */
    static const uint32_t FLASH_SR2_WBNE2_MASK                    = 0x00000002U;   /** @brief Bank 2 write buffer not empty flag */
    static const uint32_t FLASH_SR2_QW2_MASK                      = 0x00000004U;   /** @brief Bank 2 wait queue flag */
    static const uint32_t FLASH_SR2_CRC_BUSY2_MASK                = 0x00000008U;   /** @brief Bank 2 CRC busy flag */
    static const uint32_t FLASH_SR2_EOP2_MASK                     = 0x00010000U;   /** @brief Bank 2 end-of-program flag */
    static const uint32_t FLASH_SR2_WRPERR2_MASK                  = 0x00020000U;   /** @brief Bank 2 write protection error flag */
    static const uint32_t FLASH_SR2_PGSERR2_MASK                  = 0x00040000U;   /** @brief Bank 2 programming sequence error flag */
    static const uint32_t FLASH_SR2_STRBERR2_MASK                 = 0x00080000U;   /** @brief Bank 2 strobe error flag */
    static const uint32_t FLASH_SR2_INCERR2_MASK                  = 0x00200000U;   /** @brief Bank 2 inconsistency error flag */
    static const uint32_t FLASH_SR2_OPERR2_MASK                   = 0x00400000U;   /** @brief Bank 2 write/erase error flag */
    static const uint32_t FLASH_SR2_RDPERR2_MASK                  = 0x00800000U;   /** @brief Bank 2 read protection error flag */
    static const uint32_t FLASH_SR2_RDSERR2_MASK                  = 0x01000000U;   /** @brief Bank 2 secure error flag */
    static const uint32_t FLASH_SR2_SNECCERR2_MASK                = 0x02000000U;   /** @brief Bank 2 single correction error flag */
    static const uint32_t FLASH_SR2_DBECCERR2_MASK                = 0x04000000U;   /** @brief Bank 2 ECC double detection error flag */
    static const uint32_t FLASH_SR2_CRCEND2_MASK                  = 0x08000000U;   /** @brief Bank 2 crc-complete flag */

    /**** @subsection Enumerated FLASH Register Field Masks ****/

    static const uint32_t FLASH_OPTSR_PRG_RSSx_MASK[3] = {
      [1] = 0x04000000U,   /** @brief User option configuration bit 1 */
      [2] = 0x08000000U,   /** @brief User option configuration bit 2 */
    };

    static const uint32_t FLASH_BOOT_CURR_BOOT_ADDx_MASK[2] = {
      [0] = 0x0000FFFFU,   /** @brief Boot address 0 */
      [1] = 0xFFFF0000U,   /** @brief Boot address 1 */
    };

    /**** @subsection FLASH Register Field Positions ****/

    static const int32_t FLASH_ACR_LATENCY_POS                  = 0;    /** @brief Read latency */
    static const int32_t FLASH_ACR_WRHIGHFREQ_POS               = 4;    /** @brief Flash signal delay */
    static const int32_t FLASH_ACR__LATENCY_POS                 = 0;    /** @brief Read latency */
    static const int32_t FLASH_ACR__WRHIGHFREQ_POS              = 4;    /** @brief Flash signal delay */
    static const int32_t FLASH_CRx_LOCK1_POS                    = 0;    /** @brief Bank 1 configuration lock bit */
    static const int32_t FLASH_CRx_PG1_POS                      = 1;    /** @brief Bank 1 program enable bit */
    static const int32_t FLASH_CRx_SER1_POS                     = 2;    /** @brief Bank 1 sector erase request */
    static const int32_t FLASH_CRx_BER1_POS                     = 3;    /** @brief Bank 1 erase request */
    static const int32_t FLASH_CRx_PSIZE1_POS                   = 4;    /** @brief Bank 1 program size */
    static const int32_t FLASH_CRx_FW1_POS                      = 6;    /** @brief Bank 1 write forcing control bit */
    static const int32_t FLASH_CRx_START1_POS                   = 7;    /** @brief Bank 1 bank or sector erase start control bit */
    static const int32_t FLASH_CRx_SNB1_POS                     = 8;    /** @brief Bank 1 sector erase selection number */
    static const int32_t FLASH_CRx_CRC_EN_POS                   = 15;   /** @brief Bank 1 CRC control bit */
    static const int32_t FLASH_CRx_EOPIE1_POS                   = 16;   /** @brief Bank 1 end-of-program interrupt control bit */
    static const int32_t FLASH_CRx_WRPERRIE1_POS                = 17;   /** @brief Bank 1 write protection error interrupt enable bit */
    static const int32_t FLASH_CRx_PGSERRIE1_POS                = 18;   /** @brief Bank 1 programming sequence error interrupt enable bit */
    static const int32_t FLASH_CRx_STRBERRIE1_POS               = 19;   /** @brief Bank 1 strobe error interrupt enable bit */
    static const int32_t FLASH_CRx_INCERRIE1_POS                = 21;   /** @brief Bank 1 inconsistency error interrupt enable bit */
    static const int32_t FLASH_CRx_OPERRIE1_POS                 = 22;   /** @brief Bank 1 write/erase error interrupt enable bit */
    static const int32_t FLASH_CRx_RDPERRIE1_POS                = 23;   /** @brief Bank 1 read protection error interrupt enable bit */
    static const int32_t FLASH_CRx_RDSERRIE1_POS                = 24;   /** @brief Bank 1 secure error interrupt enable bit */
    static const int32_t FLASH_CRx_SNECCERRIE1_POS              = 25;   /** @brief Bank 1 ECC single correction error interrupt enable bit */
    static const int32_t FLASH_CRx_DBECCERRIE1_POS              = 26;   /** @brief Bank 1 ECC double detection error interrupt enable bit */
    static const int32_t FLASH_CRx_CRCENDIE1_POS                = 27;   /** @brief Bank 1 end of CRC calculation interrupt enable bit */
    static const int32_t FLASH_SR1_BSY1_POS                     = 0;    /** @brief Bank 1 ongoing program flag */
    static const int32_t FLASH_SR1_WBNE1_POS                    = 1;    /** @brief Bank 1 write buffer not empty flag */
    static const int32_t FLASH_SR1_QW1_POS                      = 2;    /** @brief Bank 1 wait queue flag */
    static const int32_t FLASH_SR1_CRC_BUSY1_POS                = 3;    /** @brief Bank 1 CRC busy flag */
    static const int32_t FLASH_SR1_EOP1_POS                     = 16;   /** @brief Bank 1 end-of-program flag */
    static const int32_t FLASH_SR1_WRPERR1_POS                  = 17;   /** @brief Bank 1 write protection error flag */
    static const int32_t FLASH_SR1_PGSERR1_POS                  = 18;   /** @brief Bank 1 programming sequence error flag */
    static const int32_t FLASH_SR1_STRBERR1_POS                 = 19;   /** @brief Bank 1 strobe error flag */
    static const int32_t FLASH_SR1_INCERR1_POS                  = 21;   /** @brief Bank 1 inconsistency error flag */
    static const int32_t FLASH_SR1_OPERR1_POS                   = 22;   /** @brief Bank 1 write/erase error flag */
    static const int32_t FLASH_SR1_RDPERR1_POS                  = 23;   /** @brief Bank 1 read protection error flag */
    static const int32_t FLASH_SR1_RDSERR1_POS                  = 24;   /** @brief Bank 1 secure error flag */
    static const int32_t FLASH_SR1_SNECCERR11_POS               = 25;   /** @brief Bank 1 single correction error flag */
    static const int32_t FLASH_SR1_DBECCERR1_POS                = 26;   /** @brief Bank 1 ECC double detection error flag */
    static const int32_t FLASH_SR1_CRCEND1_POS                  = 27;   /** @brief Bank 1 crc-complete flag */
    static const int32_t FLASH_CCRx_CLR_EOP1_POS                = 16;   /** @brief Bank 1 EOP1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_WRPERR1_POS             = 17;   /** @brief Bank 1 WRPERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_PGSERR1_POS             = 18;   /** @brief Bank 1 PGSERR1 flag clear bi */
    static const int32_t FLASH_CCRx_CLR_STRBERR1_POS            = 19;   /** @brief Bank 1 STRBERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_INCERR1_POS             = 21;   /** @brief Bank 1 INCERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_OPERR1_POS              = 22;   /** @brief Bank 1 OPERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_RDPERR1_POS             = 23;   /** @brief Bank 1 RDPERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_RDSERR1_POS             = 24;   /** @brief Bank 1 RDSERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_SNECCERR1_POS           = 25;   /** @brief Bank 1 SNECCERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_DBECCERR1_POS           = 26;   /** @brief Bank 1 DBECCERR1 flag clear bit */
    static const int32_t FLASH_CCRx_CLR_CRCEND1_POS             = 27;   /** @brief Bank 1 CRCEND1 flag clear bit */
    static const int32_t FLASH_OPTCR_OPTLOCK_POS                = 0;    /** @brief FLASH_OPTCR lock option configuration bit */
    static const int32_t FLASH_OPTCR_OPTSTART_POS               = 1;    /** @brief Option byte start change option configuration bit */
    static const int32_t FLASH_OPTCR_MER_POS                    = 4;    /** @brief Flash mass erase enable bit */
    static const int32_t FLASH_OPTCR_OPTCHANGEERRIE_POS         = 30;   /** @brief Option byte change error interrupt enable bit */
    static const int32_t FLASH_OPTCR_SWAP_BANK_POS              = 31;   /** @brief Bank swapping configuration bit */
    static const int32_t FLASH_OPTCR__OPTLOCK_POS               = 0;    /** @brief FLASH_OPTCR lock option configuration bit */
    static const int32_t FLASH_OPTCR__OPTSTART_POS              = 1;    /** @brief Option byte start change option configuration bit */
    static const int32_t FLASH_OPTCR__MER_POS                   = 4;    /** @brief Flash mass erase enable bit */
    static const int32_t FLASH_OPTCR__OPTCHANGEERRIE_POS        = 30;   /** @brief Option byte change error interrupt enable bit */
    static const int32_t FLASH_OPTCR__SWAP_BANK_POS             = 31;   /** @brief Bank swapping configuration bit */
    static const int32_t FLASH_OPTSR_CUR__OPT_BUSY_POS          = 0;    /** @brief Option byte change ongoing flag */
    static const int32_t FLASH_OPTSR_CUR__BOR_LEV_POS           = 2;    /** @brief Brownout level option status bit */
    static const int32_t FLASH_OPTSR_CUR__IWDG1_HW_POS          = 4;    /** @brief IWDG1 control option status bit */
    static const int32_t FLASH_OPTSR_CUR__NRST_STOP_D1_POS      = 6;    /** @brief D1 dstop entry reset option status bit */
    static const int32_t FLASH_OPTSR_CUR__NRST_STBY_D1_POS      = 7;    /** @brief D1 dstandby entry reset option status bit */
    static const int32_t FLASH_OPTSR_CUR__RDP_POS               = 8;    /** @brief Readout protection level option status byte */
    static const int32_t FLASH_OPTSR_CUR__FZ_IWDG_STOP_POS      = 17;   /** @brief IWDG stop mode freeze option status bit */
    static const int32_t FLASH_OPTSR_CUR__FZ_IWDG_SDBY_POS      = 18;   /** @brief IWDG standby mode freeze option status bit */
    static const int32_t FLASH_OPTSR_CUR__ST_RAM_SIZE_POS       = 19;   /** @brief DTCM RAM size option status */
    static const int32_t FLASH_OPTSR_CUR__SECURITY_POS          = 21;   /** @brief Security enable option status bit */
    static const int32_t FLASH_OPTSR_CUR__RSS1_POS              = 26;   /** @brief User option bit 1 */
    static const int32_t FLASH_OPTSR_CUR__PERSO_OK_POS          = 28;   /** @brief Device personalization status bit */
    static const int32_t FLASH_OPTSR_CUR__IO_HSLV_POS           = 29;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_OPTSR_CUR__OPTCHANGEERR_POS      = 30;   /** @brief Option byte change error flag */
    static const int32_t FLASH_OPTSR_CUR__SWAP_BANK_OPT_POS     = 31;   /** @brief Bank swapping option status bit */
    static const int32_t FLASH_OPTSR_CUR_OPT_BUSY_POS           = 0;    /** @brief Option byte change ongoing flag */
    static const int32_t FLASH_OPTSR_CUR_BOR_LEV_POS            = 2;    /** @brief Brownout level option status bit */
    static const int32_t FLASH_OPTSR_CUR_IWDG1_HW_POS           = 4;    /** @brief IWDG1 control option status bit */
    static const int32_t FLASH_OPTSR_CUR_NRST_STOP_D1_POS       = 6;    /** @brief D1 dstop entry reset option status bit */
    static const int32_t FLASH_OPTSR_CUR_NRST_STBY_D1_POS       = 7;    /** @brief D1 dstandby entry reset option status bit */
    static const int32_t FLASH_OPTSR_CUR_RDP_POS                = 8;    /** @brief Readout protection level option status byte */
    static const int32_t FLASH_OPTSR_CUR_FZ_IWDG_STOP_POS       = 17;   /** @brief IWDG stop mode freeze option status bit */
    static const int32_t FLASH_OPTSR_CUR_FZ_IWDG_SDBY_POS       = 18;   /** @brief IWDG standby mode freeze option status bit */
    static const int32_t FLASH_OPTSR_CUR_ST_RAM_SIZE_POS        = 19;   /** @brief DTCM RAM size option status */
    static const int32_t FLASH_OPTSR_CUR_SECURITY_POS           = 21;   /** @brief Security enable option status bit */
    static const int32_t FLASH_OPTSR_CUR_RSS1_POS               = 26;   /** @brief User option bit 1 */
    static const int32_t FLASH_OPTSR_CUR_PERSO_OK_POS           = 28;   /** @brief Device personalization status bit */
    static const int32_t FLASH_OPTSR_CUR_IO_HSLV_POS            = 29;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_OPTSR_CUR_OPTCHANGEERR_POS       = 30;   /** @brief Option byte change error flag */
    static const int32_t FLASH_OPTSR_CUR_SWAP_BANK_OPT_POS      = 31;   /** @brief Bank swapping option status bit */
    static const int32_t FLASH_OPTSR_PRG_BOR_LEV_POS            = 2;    /** @brief BOR reset level option configuration bits */
    static const int32_t FLASH_OPTSR_PRG_IWDG1_HW_POS           = 4;    /** @brief IWDG1 option configuration bit */
    static const int32_t FLASH_OPTSR_PRG_NRST_STOP_D1_POS       = 6;    /** @brief Option byte erase after D1 dstop option configuration bit */
    static const int32_t FLASH_OPTSR_PRG_NRST_STBY_D1_POS       = 7;    /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const int32_t FLASH_OPTSR_PRG_RDP_POS                = 8;    /** @brief Readout protection level option configuration byte */
    static const int32_t FLASH_OPTSR_PRG_FZ_IWDG_STOP_POS       = 17;   /** @brief IWDG stop mode freeze option configuration bit */
    static const int32_t FLASH_OPTSR_PRG_FZ_IWDG_SDBY_POS       = 18;   /** @brief IWDG standby mode freeze option configuration bit */
    static const int32_t FLASH_OPTSR_PRG_ST_RAM_SIZE_POS        = 19;   /** @brief DTCM size select option configuration bits */
    static const int32_t FLASH_OPTSR_PRG_SECURITY_POS           = 21;   /** @brief Security option configuration bit */
    static const int32_t FLASH_OPTSR_PRG_IO_HSLV_POS            = 29;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_OPTSR_PRG_SWAP_BANK_OPT_POS      = 31;   /** @brief Bank swapping option configuration bit */
    static const int32_t FLASH_OPTSR_PRG__BOR_LEV_POS           = 2;    /** @brief BOR reset level option configuration bits */
    static const int32_t FLASH_OPTSR_PRG__IWDG1_HW_POS          = 4;    /** @brief IWDG1 option configuration bit */
    static const int32_t FLASH_OPTSR_PRG__NRST_STOP_D1_POS      = 6;    /** @brief Option byte erase after D1 dstop option configuration bit */
    static const int32_t FLASH_OPTSR_PRG__NRST_STBY_D1_POS      = 7;    /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const int32_t FLASH_OPTSR_PRG__RDP_POS               = 8;    /** @brief Readout protection level option configuration byte */
    static const int32_t FLASH_OPTSR_PRG__FZ_IWDG_STOP_POS      = 17;   /** @brief IWDG stop mode freeze option configuration bit */
    static const int32_t FLASH_OPTSR_PRG__FZ_IWDG_SDBY_POS      = 18;   /** @brief IWDG standby mode freeze option configuration bit */
    static const int32_t FLASH_OPTSR_PRG__ST_RAM_SIZE_POS       = 19;   /** @brief DTCM size select option configuration bits */
    static const int32_t FLASH_OPTSR_PRG__SECURITY_POS          = 21;   /** @brief Security option configuration bit */
    static const int32_t FLASH_OPTSR_PRG__IO_HSLV_POS           = 29;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_OPTSR_PRG__SWAP_BANK_OPT_POS     = 31;   /** @brief Bank swapping option configuration bit */
    static const int32_t FLASH_OPTCCR__CLR_OPTCHANGEERR_POS     = 30;   /** @brief OPTCHANGEERR reset bit */
    static const int32_t FLASH_OPTCCR_CLR_OPTCHANGEERR_POS      = 30;   /** @brief OPTCHANGEERR reset bit */
    static const int32_t FLASH_PRAR_CURx_PROT_AREA_START1_POS   = 0;    /** @brief Bank 1 lowest PCROP protected address */
    static const int32_t FLASH_PRAR_CURx_PROT_AREA_END1_POS     = 16;   /** @brief Bank 1 highest PCROP protected address */
    static const int32_t FLASH_PRAR_CURx_DMEP1_POS              = 31;   /** @brief Bank 1 PCROP protected erase enable option status bit */
    static const int32_t FLASH_PRAR_PRGx_PROT_AREA_START1_POS   = 0;    /** @brief Bank 1 lowest PCROP protected address configuration */
    static const int32_t FLASH_PRAR_PRGx_PROT_AREA_END1_POS     = 16;   /** @brief Bank 1 highest PCROP protected address configuration */
    static const int32_t FLASH_PRAR_PRGx_DMEP1_POS              = 31;   /** @brief Bank 1 PCROP protected erase enable option configuration bit */
    static const int32_t FLASH_SCAR_CURx_SEC_AREA_START1_POS    = 0;    /** @brief Bank 1 lowest secure protected address */
    static const int32_t FLASH_SCAR_CURx_SEC_AREA_END1_POS      = 16;   /** @brief Bank 1 highest secure protected address */
    static const int32_t FLASH_SCAR_CURx_DMES1_POS              = 31;   /** @brief Bank 1 secure protected erase enable option status bit */
    static const int32_t FLASH_SCAR_PRGx_SEC_AREA_START1_POS    = 0;    /** @brief Bank 1 lowest secure protected address configuration */
    static const int32_t FLASH_SCAR_PRGx_SEC_AREA_END1_POS      = 16;   /** @brief Bank 1 highest secure protected address configuration */
    static const int32_t FLASH_SCAR_PRGx_DMES1_POS              = 31;   /** @brief Bank 1 secure protected erase enable option configuration bit */
    static const int32_t FLASH_WPSN_CURxR_WRPSN1_POS            = 0;    /** @brief Bank 1 sector write protection option status byte */
    static const int32_t FLASH_WPSN_PRGxR_WRPSN1_POS            = 0;    /** @brief Bank 1 sector write protection configuration byte */
    static const int32_t FLASH_CRCCRx_CRC_SECT_POS              = 0;    /** @brief Bank 1 CRC sector number */
    static const int32_t FLASH_CRCCRx_ALL_BANK_POS              = 7;    /** @brief Bank 1 CRC select bit */
    static const int32_t FLASH_CRCCRx_CRC_BY_SECT_POS           = 8;    /** @brief Bank 1 CRC sector mode select bit */
    static const int32_t FLASH_CRCCRx_ADD_SECT_POS              = 9;    /** @brief Bank 1 CRC sector select bit */
    static const int32_t FLASH_CRCCRx_CLEAN_SECT_POS            = 10;   /** @brief Bank 1 CRC sector list clear bit */
    static const int32_t FLASH_CRCCRx_START_CRC_POS             = 16;   /** @brief Bank 1 CRC start bit */
    static const int32_t FLASH_CRCCRx_CLEAN_CRC_POS             = 17;   /** @brief Bank 1 CRC clear bit */
    static const int32_t FLASH_CRCCRx_CRC_BURST_POS             = 20;   /** @brief Bank 1 CRC burst size */
    static const int32_t FLASH_ECC_FAxR_FAIL_ECC_ADDR1_POS      = 0;    /** @brief Bank 1 ECC error address */
    static const int32_t FLASH_SR2_BSY2_POS                     = 0;    /** @brief Bank 2 ongoing program flag */
    static const int32_t FLASH_SR2_WBNE2_POS                    = 1;    /** @brief Bank 2 write buffer not empty flag */
    static const int32_t FLASH_SR2_QW2_POS                      = 2;    /** @brief Bank 2 wait queue flag */
    static const int32_t FLASH_SR2_CRC_BUSY2_POS                = 3;    /** @brief Bank 2 CRC busy flag */
    static const int32_t FLASH_SR2_EOP2_POS                     = 16;   /** @brief Bank 2 end-of-program flag */
    static const int32_t FLASH_SR2_WRPERR2_POS                  = 17;   /** @brief Bank 2 write protection error flag */
    static const int32_t FLASH_SR2_PGSERR2_POS                  = 18;   /** @brief Bank 2 programming sequence error flag */
    static const int32_t FLASH_SR2_STRBERR2_POS                 = 19;   /** @brief Bank 2 strobe error flag */
    static const int32_t FLASH_SR2_INCERR2_POS                  = 21;   /** @brief Bank 2 inconsistency error flag */
    static const int32_t FLASH_SR2_OPERR2_POS                   = 22;   /** @brief Bank 2 write/erase error flag */
    static const int32_t FLASH_SR2_RDPERR2_POS                  = 23;   /** @brief Bank 2 read protection error flag */
    static const int32_t FLASH_SR2_RDSERR2_POS                  = 24;   /** @brief Bank 2 secure error flag */
    static const int32_t FLASH_SR2_SNECCERR2_POS                = 25;   /** @brief Bank 2 single correction error flag */
    static const int32_t FLASH_SR2_DBECCERR2_POS                = 26;   /** @brief Bank 2 ECC double detection error flag */
    static const int32_t FLASH_SR2_CRCEND2_POS                  = 27;   /** @brief Bank 2 crc-complete flag */

    /**** @subsection Enumerated FLASH Register Field Positions ****/

    static const int32_t FLASH_OPTSR_PRG_RSSx_POS[3] = {
      [1] = 26,   /** @brief User option configuration bit 1 */
      [2] = 27,   /** @brief User option configuration bit 2 */
    };

    static const int32_t FLASH_BOOT_CURR_BOOT_ADDx_POS[2] = {
      [0] = 0,    /** @brief Boot address 0 */
      [1] = 16,   /** @brief Boot address 1 */
    };

    /**********************************************************************************************
     * @section AXI Register Information
     **********************************************************************************************/

    /**** @subsection AXI Register Pointers ****/

    static RO_ uint32_t* const AXI_AXI_PERIPH_ID_4_PTR   = (RO_ uint32_t* const)0x51001FD0U;   /** @brief AXI interconnect - peripheral ID4 register */
    static RO_ uint32_t* const AXI_AXI_PERIPH_ID_0_PTR   = (RO_ uint32_t* const)0x51001FE0U;   /** @brief AXI interconnect - peripheral ID0 register */
    static RO_ uint32_t* const AXI_AXI_PERIPH_ID_1_PTR   = (RO_ uint32_t* const)0x51001FE4U;   /** @brief AXI interconnect - peripheral ID1 register */
    static RO_ uint32_t* const AXI_AXI_PERIPH_ID_2_PTR   = (RO_ uint32_t* const)0x51001FE8U;   /** @brief AXI interconnect - peripheral ID2 register */
    static RO_ uint32_t* const AXI_AXI_PERIPH_ID_3_PTR   = (RO_ uint32_t* const)0x51001FECU;   /** @brief AXI interconnect - peripheral ID3 register */
    static RO_ uint32_t* const AXI_AXI_COMP_ID_0_PTR     = (RO_ uint32_t* const)0x51001FF0U;   /** @brief AXI interconnect - component ID0 register */
    static RO_ uint32_t* const AXI_AXI_COMP_ID_1_PTR     = (RO_ uint32_t* const)0x51001FF4U;   /** @brief AXI interconnect - component ID1 register */
    static RO_ uint32_t* const AXI_AXI_COMP_ID_2_PTR     = (RO_ uint32_t* const)0x51001FF8U;   /** @brief AXI interconnect - component ID2 register */
    static RO_ uint32_t* const AXI_AXI_COMP_ID_3_PTR     = (RO_ uint32_t* const)0x51001FFCU;   /** @brief AXI interconnect - component ID3 register */

    /**** @subsection Enumerated AXI Register Pointers ****/

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_ISS_BM_PTR[8] = {
      [1] = (RW_ uint32_t* const)0x51002008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [2] = (RW_ uint32_t* const)0x51003008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [3] = (RW_ uint32_t* const)0x51004008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [4] = (RW_ uint32_t* const)0x51005008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [5] = (RW_ uint32_t* const)0x51006008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [6] = (RW_ uint32_t* const)0x51007008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [7] = (RW_ uint32_t* const)0x5100800CU,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    };

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD2_PTR[8] = {
      [1] = (RW_ uint32_t* const)0x51002024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      [2] = (RW_ uint32_t* const)0x51003024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      [7] = (RW_ uint32_t* const)0x51008024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
    };

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_LB_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x5100202CU,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [2] = (RW_ uint32_t* const)0x5100302CU,   /** @brief AXI interconnect - TARG x long burst functionality modification */
    };

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_PTR[8] = {
      [1] = (RW_ uint32_t* const)0x51002108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [2] = (RW_ uint32_t* const)0x51003108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [7] = (RW_ uint32_t* const)0x51008108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD2_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x51042024U,   /** @brief AXI interconnect - INI x functionality modification 2 register */
      [3] = (RW_ uint32_t* const)0x51044024U,   /** @brief AXI interconnect - INI x functionality modification 2 register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD_AHB_PTR[4] = {
      [1] = (RW_ uint32_t* const)0x51042028U,   /** @brief AXI interconnect - INI x AHB functionality modification register */
      [3] = (RW_ uint32_t* const)0x51044028U,   /** @brief AXI interconnect - INI x AHB functionality modification register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_READ_QOS_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x51042100U,   /** @brief AXI interconnect - INI x read qos register */
      [2] = (RW_ uint32_t* const)0x51043100U,   /** @brief AXI interconnect - INI x read qos register */
      [3] = (RW_ uint32_t* const)0x51044100U,   /** @brief AXI interconnect - INI x read qos register */
      [4] = (RW_ uint32_t* const)0x51045100U,   /** @brief AXI interconnect - INI x read qos register */
      [5] = (RW_ uint32_t* const)0x51046100U,   /** @brief AXI interconnect - INI x read qos register */
      [6] = (RW_ uint32_t* const)0x51047100U,   /** @brief AXI interconnect - INI x read qos register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_WRITE_QOS_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x51042104U,   /** @brief AXI interconnect - INI x write qos register */
      [2] = (RW_ uint32_t* const)0x51043104U,   /** @brief AXI interconnect - INI x write qos register */
      [3] = (RW_ uint32_t* const)0x51044104U,   /** @brief AXI interconnect - INI x write qos register */
      [4] = (RW_ uint32_t* const)0x51045104U,   /** @brief AXI interconnect - INI x write qos register */
      [5] = (RW_ uint32_t* const)0x51046104U,   /** @brief AXI interconnect - INI x write qos register */
      [6] = (RW_ uint32_t* const)0x51047104U,   /** @brief AXI interconnect - INI x write qos register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x51042108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [2] = (RW_ uint32_t* const)0x51043108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [3] = (RW_ uint32_t* const)0x51044108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [4] = (RW_ uint32_t* const)0x51045108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [5] = (RW_ uint32_t* const)0x51046108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [6] = (RW_ uint32_t* const)0x51047108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
    };

    /**** @subsection AXI Register Reset Values ****/

    static const uint32_t AXI_AXI_PERIPH_ID_4_RST   = 0x00000004U;   /** @brief AXI_PERIPH_ID_4 register reset value. */
    static const uint32_t AXI_AXI_PERIPH_ID_0_RST   = 0x00000004U;   /** @brief AXI_PERIPH_ID_0 register reset value. */
    static const uint32_t AXI_AXI_PERIPH_ID_1_RST   = 0x00000004U;   /** @brief AXI_PERIPH_ID_1 register reset value. */
    static const uint32_t AXI_AXI_PERIPH_ID_2_RST   = 0x00000004U;   /** @brief AXI_PERIPH_ID_2 register reset value. */
    static const uint32_t AXI_AXI_PERIPH_ID_3_RST   = 0x00000004U;   /** @brief AXI_PERIPH_ID_3 register reset value. */
    static const uint32_t AXI_AXI_COMP_ID_0_RST     = 0x00000004U;   /** @brief AXI_COMP_ID_0 register reset value. */
    static const uint32_t AXI_AXI_COMP_ID_1_RST     = 0x00000004U;   /** @brief AXI_COMP_ID_1 register reset value. */
    static const uint32_t AXI_AXI_COMP_ID_2_RST     = 0x00000004U;   /** @brief AXI_COMP_ID_2 register reset value. */
    static const uint32_t AXI_AXI_COMP_ID_3_RST     = 0x00000004U;   /** @brief AXI_COMP_ID_3 register reset value. */

    /**** @subsection Enumerated AXI Register Reset Values ****/

    static const uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_RST[8] = {
      [1] = 0x00000004U,   /** @brief AXI_TARG1_FN_MOD_ISS_BM register reset value. */
      [2] = 0x00000004U,   /** @brief AXI_TARG2_FN_MOD_ISS_BM register reset value. */
      [3] = 0x00000004U,   /** @brief AXI_TARG3_FN_MOD_ISS_BM register reset value. */
      [4] = 0x00000004U,   /** @brief AXI_TARG4_FN_MOD_ISS_BM register reset value. */
      [5] = 0x00000004U,   /** @brief AXI_TARG5_FN_MOD_ISS_BM register reset value. */
      [6] = 0x00000004U,   /** @brief AXI_TARG6_FN_MOD_ISS_BM register reset value. */
      [7] = 0x00000004U,   /** @brief AXI_TARG7_FN_MOD_ISS_BM register reset value. */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD2_RST[8] = {
      [1] = 0x00000004U,   /** @brief AXI_TARG1_FN_MOD2 register reset value. */
      [2] = 0x00000004U,   /** @brief AXI_TARG2_FN_MOD2 register reset value. */
      [7] = 0x00000004U,   /** @brief AXI_TARG7_FN_MOD2 register reset value. */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_LB_RST[3] = {
      [1] = 0x00000004U,   /** @brief AXI_TARG1_FN_MOD_LB register reset value. */
      [2] = 0x00000004U,   /** @brief AXI_TARG2_FN_MOD_LB register reset value. */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_RST[8] = {
      [1] = 0x00000004U,   /** @brief AXI_TARG1_FN_MOD register reset value. */
      [2] = 0x00000004U,   /** @brief AXI_TARG2_FN_MOD register reset value. */
      [7] = 0x00000004U,   /** @brief AXI_TARG7_FN_MOD register reset value. */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD2_RST[4] = {
      [1] = 0x00000004U,   /** @brief AXI_INI1_FN_MOD2 register reset value. */
      [3] = 0x00000004U,   /** @brief AXI_INI3_FN_MOD2 register reset value. */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD_AHB_RST[4] = {
      [1] = 0x00000004U,   /** @brief AXI_INI1_FN_MOD_AHB register reset value. */
      [3] = 0x00000004U,   /** @brief AXI_INI3_FN_MOD_AHB register reset value. */
    };

    static const uint32_t AXI_AXI_INIx_READ_QOS_RST[7] = {
      [1] = 0x00000004U,   /** @brief AXI_INI1_READ_QOS register reset value. */
      [2] = 0x00000004U,   /** @brief AXI_INI2_READ_QOS register reset value. */
      [3] = 0x00000004U,   /** @brief AXI_INI3_READ_QOS register reset value. */
      [4] = 0x00000004U,   /** @brief AXI_INI4_READ_QOS register reset value. */
      [5] = 0x00000004U,   /** @brief AXI_INI5_READ_QOS register reset value. */
      [6] = 0x00000004U,   /** @brief AXI_INI6_READ_QOS register reset value. */
    };

    static const uint32_t AXI_AXI_INIx_WRITE_QOS_RST[7] = {
      [1] = 0x00000004U,   /** @brief AXI_INI1_WRITE_QOS register reset value. */
      [2] = 0x00000004U,   /** @brief AXI_INI2_WRITE_QOS register reset value. */
      [3] = 0x00000004U,   /** @brief AXI_INI3_WRITE_QOS register reset value. */
      [4] = 0x00000004U,   /** @brief AXI_INI4_WRITE_QOS register reset value. */
      [5] = 0x00000004U,   /** @brief AXI_INI5_WRITE_QOS register reset value. */
      [6] = 0x00000004U,   /** @brief AXI_INI6_WRITE_QOS register reset value. */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD_RST[7] = {
      [1] = 0x00000004U,   /** @brief AXI_INI1_FN_MOD register reset value. */
      [2] = 0x00000004U,   /** @brief AXI_INI2_FN_MOD register reset value. */
      [3] = 0x00000004U,   /** @brief AXI_INI3_FN_MOD register reset value. */
      [4] = 0x00000004U,   /** @brief AXI_INI4_FN_MOD register reset value. */
      [5] = 0x00000004U,   /** @brief AXI_INI5_FN_MOD register reset value. */
      [6] = 0x00000004U,   /** @brief AXI_INI6_FN_MOD register reset value. */
    };

    /**** @subsection Enumerated AXI Register Value Types ****/

    typedef uint32_t AXI_AXI_PERIPH_ID_4_t;           /** @brief AXI_PERIPH_ID_4 register value type. */
    typedef uint32_t AXI_AXI_PERIPH_ID_0_t;           /** @brief AXI_PERIPH_ID_0 register value type. */
    typedef uint32_t AXI_AXI_PERIPH_ID_1_t;           /** @brief AXI_PERIPH_ID_1 register value type. */
    typedef uint32_t AXI_AXI_PERIPH_ID_2_t;           /** @brief AXI_PERIPH_ID_2 register value type. */
    typedef uint32_t AXI_AXI_PERIPH_ID_3_t;           /** @brief AXI_PERIPH_ID_3 register value type. */
    typedef uint32_t AXI_AXI_COMP_ID_0_t;             /** @brief AXI_COMP_ID_0 register value type. */
    typedef uint32_t AXI_AXI_COMP_ID_1_t;             /** @brief AXI_COMP_ID_1 register value type. */
    typedef uint32_t AXI_AXI_COMP_ID_2_t;             /** @brief AXI_COMP_ID_2 register value type. */
    typedef uint32_t AXI_AXI_COMP_ID_3_t;             /** @brief AXI_COMP_ID_3 register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_t;   /** @brief AXI_TARGx_FN_MOD_ISS_BM register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD2_t;         /** @brief AXI_TARGx_FN_MOD2 register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD_LB_t;       /** @brief AXI_TARGx_FN_MOD_LB register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD_t;          /** @brief AXI_TARGx_FN_MOD register value type. */
    typedef uint32_t AXI_AXI_INIx_FN_MOD2_t;          /** @brief AXI_INIx_FN_MOD2 register value type. */
    typedef uint32_t AXI_AXI_INIx_FN_MOD_AHB_t;       /** @brief AXI_INIx_FN_MOD_AHB register value type. */
    typedef uint32_t AXI_AXI_INIx_READ_QOS_t;         /** @brief AXI_INIx_READ_QOS register value type. */
    typedef uint32_t AXI_AXI_INIx_WRITE_QOS_t;        /** @brief AXI_INIx_WRITE_QOS register value type. */
    typedef uint32_t AXI_AXI_INIx_FN_MOD_t;           /** @brief AXI_INIx_FN_MOD register value type. */

    /**** @subsection Enumerated AXI Register Pointer Types ****/

    typedef uint32_t* const AXI_AXI_PERIPH_ID_4_PTR_t;           /** @brief AXI_PERIPH_ID_4 register pointer type. */
    typedef uint32_t* const AXI_AXI_PERIPH_ID_0_PTR_t;           /** @brief AXI_PERIPH_ID_0 register pointer type. */
    typedef uint32_t* const AXI_AXI_PERIPH_ID_1_PTR_t;           /** @brief AXI_PERIPH_ID_1 register pointer type. */
    typedef uint32_t* const AXI_AXI_PERIPH_ID_2_PTR_t;           /** @brief AXI_PERIPH_ID_2 register pointer type. */
    typedef uint32_t* const AXI_AXI_PERIPH_ID_3_PTR_t;           /** @brief AXI_PERIPH_ID_3 register pointer type. */
    typedef uint32_t* const AXI_AXI_COMP_ID_0_PTR_t;             /** @brief AXI_COMP_ID_0 register pointer type. */
    typedef uint32_t* const AXI_AXI_COMP_ID_1_PTR_t;             /** @brief AXI_COMP_ID_1 register pointer type. */
    typedef uint32_t* const AXI_AXI_COMP_ID_2_PTR_t;             /** @brief AXI_COMP_ID_2 register pointer type. */
    typedef uint32_t* const AXI_AXI_COMP_ID_3_PTR_t;             /** @brief AXI_COMP_ID_3 register pointer type. */
    typedef uint32_t* const AXI_AXI_TARGx_FN_MOD_ISS_BM_PTR_t;   /** @brief AXI_TARGx_FN_MOD_ISS_BM register pointer type. */
    typedef uint32_t* const AXI_AXI_TARGx_FN_MOD2_PTR_t;         /** @brief AXI_TARGx_FN_MOD2 register pointer type. */
    typedef uint32_t* const AXI_AXI_TARGx_FN_MOD_LB_PTR_t;       /** @brief AXI_TARGx_FN_MOD_LB register pointer type. */
    typedef uint32_t* const AXI_AXI_TARGx_FN_MOD_PTR_t;          /** @brief AXI_TARGx_FN_MOD register pointer type. */
    typedef uint32_t* const AXI_AXI_INIx_FN_MOD2_PTR_t;          /** @brief AXI_INIx_FN_MOD2 register pointer type. */
    typedef uint32_t* const AXI_AXI_INIx_FN_MOD_AHB_PTR_t;       /** @brief AXI_INIx_FN_MOD_AHB register pointer type. */
    typedef uint32_t* const AXI_AXI_INIx_READ_QOS_PTR_t;         /** @brief AXI_INIx_READ_QOS register pointer type. */
    typedef uint32_t* const AXI_AXI_INIx_WRITE_QOS_PTR_t;        /** @brief AXI_INIx_WRITE_QOS register pointer type. */
    typedef uint32_t* const AXI_AXI_INIx_FN_MOD_PTR_t;           /** @brief AXI_INIx_FN_MOD register pointer type. */

    /**** @subsection AXI Register Field Masks ****/

    static const uint32_t AXI_AXI_PERIPH_ID_4_JEP106CON_MASK                    = 0x0000000FU;   /** @brief JEP106 continuation code */
    static const uint32_t AXI_AXI_PERIPH_ID_4_KCOUNT4_MASK                      = 0x000000F0U;   /** @brief Register file size */
    static const uint32_t AXI_AXI_PERIPH_ID_0_PARTNUM_MASK                      = 0x000000FFU;   /** @brief Peripheral part number bits 0 to 7 */
    static const uint32_t AXI_AXI_PERIPH_ID_1_PARTNUM_MASK                      = 0x0000000FU;   /** @brief Peripheral part number bits 8 to 11 */
    static const uint32_t AXI_AXI_PERIPH_ID_1_JEP106I_MASK                      = 0x000000F0U;   /** @brief JEP106 identity bits 0 to 3 */
    static const uint32_t AXI_AXI_PERIPH_ID_2_JEP106ID_MASK                     = 0x00000007U;   /** @brief JEP106 identity bits 4 to 6 */
    static const uint32_t AXI_AXI_PERIPH_ID_2_JEDEC_MASK                        = 0x00000008U;   /** @brief JEP106 code flag */
    static const uint32_t AXI_AXI_PERIPH_ID_2_REVISION_MASK                     = 0x000000F0U;   /** @brief Peripheral revision number */
    static const uint32_t AXI_AXI_PERIPH_ID_3_CUST_MOD_NUM_MASK                 = 0x0000000FU;   /** @brief Customer modification */
    static const uint32_t AXI_AXI_PERIPH_ID_3_REV_AND_MASK                      = 0x000000F0U;   /** @brief Customer version */
    static const uint32_t AXI_AXI_COMP_ID_0_PREAMBLE_MASK                       = 0x000000FFU;   /** @brief Preamble bits 0 to 7 */
    static const uint32_t AXI_AXI_COMP_ID_1_PREAMBLE_MASK                       = 0x0000000FU;   /** @brief Preamble bits 8 to 11 */
    static const uint32_t AXI_AXI_COMP_ID_1_CLASS_MASK                          = 0x000000F0U;   /** @brief Component class */
    static const uint32_t AXI_AXI_COMP_ID_2_PREAMBLE_MASK                       = 0x000000FFU;   /** @brief Preamble bits 12 to 19 */
    static const uint32_t AXI_AXI_COMP_ID_3_PREAMBLE_MASK                       = 0x000000FFU;   /** @brief Preamble bits 20 to 27 */
    static const uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK    = 0x00000001U;   /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK   = 0x00000002U;   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_AXI_TARGx_FN_MOD2_BYPASS_MERGE_MASK               = 0x00000001U;   /** @brief Disable packing of beats to match the output data width */
    static const uint32_t AXI_AXI_TARGx_FN_MOD_LB_FN_MOD_LB_MASK                = 0x00000001U;   /** @brief Controls burst breaking of long bursts */
    static const uint32_t AXI_AXI_TARGx_FN_MOD_READ_ISS_OVERRIDE_MASK           = 0x00000001U;   /** @brief Override AMIB read issuing capability */
    static const uint32_t AXI_AXI_TARGx_FN_MOD_WRITE_ISS_OVERRIDE_MASK          = 0x00000002U;   /** @brief Override AMIB write issuing capability */
    static const uint32_t AXI_AXI_INIx_FN_MOD2_BYPASS_MERGE_MASK                = 0x00000001U;   /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
    static const uint32_t AXI_AXI_INIx_FN_MOD_AHB_RD_INC_OVERRIDE_MASK          = 0x00000001U;   /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
    static const uint32_t AXI_AXI_INIx_FN_MOD_AHB_WR_INC_OVERRIDE_MASK          = 0x00000002U;   /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
    static const uint32_t AXI_AXI_INIx_READ_QOS_AR_QOS_MASK                     = 0x0000000FU;   /** @brief Read channel qos setting */
    static const uint32_t AXI_AXI_INIx_WRITE_QOS_AW_QOS_MASK                    = 0x0000000FU;   /** @brief Write channel qos setting */
    static const uint32_t AXI_AXI_INIx_FN_MOD_READ_ISS_OVERRIDE_MASK            = 0x00000001U;   /** @brief Override ASIB read issuing capability */
    static const uint32_t AXI_AXI_INIx_FN_MOD_WRITE_ISS_OVERRIDE_MASK           = 0x00000002U;   /** @brief Override ASIB write issuing capability */

    /**** @subsection AXI Register Field Positions ****/

    static const int32_t AXI_AXI_PERIPH_ID_4_JEP106CON_POS                    = 0;   /** @brief JEP106 continuation code */
    static const int32_t AXI_AXI_PERIPH_ID_4_KCOUNT4_POS                      = 4;   /** @brief Register file size */
    static const int32_t AXI_AXI_PERIPH_ID_0_PARTNUM_POS                      = 0;   /** @brief Peripheral part number bits 0 to 7 */
    static const int32_t AXI_AXI_PERIPH_ID_1_PARTNUM_POS                      = 0;   /** @brief Peripheral part number bits 8 to 11 */
    static const int32_t AXI_AXI_PERIPH_ID_1_JEP106I_POS                      = 4;   /** @brief JEP106 identity bits 0 to 3 */
    static const int32_t AXI_AXI_PERIPH_ID_2_JEP106ID_POS                     = 0;   /** @brief JEP106 identity bits 4 to 6 */
    static const int32_t AXI_AXI_PERIPH_ID_2_JEDEC_POS                        = 3;   /** @brief JEP106 code flag */
    static const int32_t AXI_AXI_PERIPH_ID_2_REVISION_POS                     = 4;   /** @brief Peripheral revision number */
    static const int32_t AXI_AXI_PERIPH_ID_3_CUST_MOD_NUM_POS                 = 0;   /** @brief Customer modification */
    static const int32_t AXI_AXI_PERIPH_ID_3_REV_AND_POS                      = 4;   /** @brief Customer version */
    static const int32_t AXI_AXI_COMP_ID_0_PREAMBLE_POS                       = 0;   /** @brief Preamble bits 0 to 7 */
    static const int32_t AXI_AXI_COMP_ID_1_PREAMBLE_POS                       = 0;   /** @brief Preamble bits 8 to 11 */
    static const int32_t AXI_AXI_COMP_ID_1_CLASS_POS                          = 4;   /** @brief Component class */
    static const int32_t AXI_AXI_COMP_ID_2_PREAMBLE_POS                       = 0;   /** @brief Preamble bits 12 to 19 */
    static const int32_t AXI_AXI_COMP_ID_3_PREAMBLE_POS                       = 0;   /** @brief Preamble bits 20 to 27 */
    static const int32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_POS    = 0;   /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_POS   = 1;   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_AXI_TARGx_FN_MOD2_BYPASS_MERGE_POS               = 0;   /** @brief Disable packing of beats to match the output data width */
    static const int32_t AXI_AXI_TARGx_FN_MOD_LB_FN_MOD_LB_POS                = 0;   /** @brief Controls burst breaking of long bursts */
    static const int32_t AXI_AXI_TARGx_FN_MOD_READ_ISS_OVERRIDE_POS           = 0;   /** @brief Override AMIB read issuing capability */
    static const int32_t AXI_AXI_TARGx_FN_MOD_WRITE_ISS_OVERRIDE_POS          = 1;   /** @brief Override AMIB write issuing capability */
    static const int32_t AXI_AXI_INIx_FN_MOD2_BYPASS_MERGE_POS                = 0;   /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
    static const int32_t AXI_AXI_INIx_FN_MOD_AHB_RD_INC_OVERRIDE_POS          = 0;   /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
    static const int32_t AXI_AXI_INIx_FN_MOD_AHB_WR_INC_OVERRIDE_POS          = 1;   /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
    static const int32_t AXI_AXI_INIx_READ_QOS_AR_QOS_POS                     = 0;   /** @brief Read channel qos setting */
    static const int32_t AXI_AXI_INIx_WRITE_QOS_AW_QOS_POS                    = 0;   /** @brief Write channel qos setting */
    static const int32_t AXI_AXI_INIx_FN_MOD_READ_ISS_OVERRIDE_POS            = 0;   /** @brief Override ASIB read issuing capability */
    static const int32_t AXI_AXI_INIx_FN_MOD_WRITE_ISS_OVERRIDE_POS           = 1;   /** @brief Override ASIB write issuing capability */

    /**********************************************************************************************
     * @section HASH Register Information
     **********************************************************************************************/

    /**** @subsection HASH Register Pointers ****/

    static RW_ uint32_t* const HASH_CR_PTR    = (RW_ uint32_t* const)0x48021400U;   /** @brief Control register */
    static RW_ uint32_t* const HASH_DIN_PTR   = (RW_ uint32_t* const)0x48021404U;   /** @brief Data input register */
    static RW_ uint32_t* const HASH_STR_PTR   = (RW_ uint32_t* const)0x48021408U;   /** @brief Start register */
    static RW_ uint32_t* const HASH_IMR_PTR   = (RW_ uint32_t* const)0x48021420U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const HASH_SR_PTR    = (RW_ uint32_t* const)0x48021424U;   /** @brief Status register */

    /**** @subsection Enumerated HASH Register Pointers ****/

    static RO_ uint32_t* const HASH_HRx_PTR[5] = {
      [0] = (RO_ uint32_t* const)0x4802140CU,   /** @brief Digest registers */
      [1] = (RO_ uint32_t* const)0x48021410U,   /** @brief Digest registers */
      [2] = (RO_ uint32_t* const)0x48021414U,   /** @brief Digest registers */
      [3] = (RO_ uint32_t* const)0x48021418U,   /** @brief Digest registers */
      [4] = (RO_ uint32_t* const)0x4802141CU,   /** @brief Digest registers */
    };

    static RW_ uint32_t* const HASH_CSRx_PTR[54] = {
      [0]  = (RW_ uint32_t* const)0x480214F8U,   /** @brief Context swap registers */
      [1]  = (RW_ uint32_t* const)0x480214FCU,   /** @brief Context swap registers */
      [2]  = (RW_ uint32_t* const)0x48021500U,   /** @brief Context swap registers */
      [3]  = (RW_ uint32_t* const)0x48021504U,   /** @brief Context swap registers */
      [4]  = (RW_ uint32_t* const)0x48021508U,   /** @brief Context swap registers */
      [5]  = (RW_ uint32_t* const)0x4802150CU,   /** @brief Context swap registers */
      [6]  = (RW_ uint32_t* const)0x48021510U,   /** @brief Context swap registers */
      [7]  = (RW_ uint32_t* const)0x48021514U,   /** @brief Context swap registers */
      [8]  = (RW_ uint32_t* const)0x48021518U,   /** @brief Context swap registers */
      [9]  = (RW_ uint32_t* const)0x4802151CU,   /** @brief Context swap registers */
      [10] = (RW_ uint32_t* const)0x48021520U,   /** @brief Context swap registers */
      [11] = (RW_ uint32_t* const)0x48021524U,   /** @brief Context swap registers */
      [12] = (RW_ uint32_t* const)0x48021528U,   /** @brief Context swap registers */
      [13] = (RW_ uint32_t* const)0x4802152CU,   /** @brief Context swap registers */
      [14] = (RW_ uint32_t* const)0x48021530U,   /** @brief Context swap registers */
      [15] = (RW_ uint32_t* const)0x48021534U,   /** @brief Context swap registers */
      [16] = (RW_ uint32_t* const)0x48021538U,   /** @brief Context swap registers */
      [17] = (RW_ uint32_t* const)0x4802153CU,   /** @brief Context swap registers */
      [18] = (RW_ uint32_t* const)0x48021540U,   /** @brief Context swap registers */
      [19] = (RW_ uint32_t* const)0x48021544U,   /** @brief Context swap registers */
      [20] = (RW_ uint32_t* const)0x48021548U,   /** @brief Context swap registers */
      [21] = (RW_ uint32_t* const)0x4802154CU,   /** @brief Context swap registers */
      [22] = (RW_ uint32_t* const)0x48021550U,   /** @brief Context swap registers */
      [23] = (RW_ uint32_t* const)0x48021554U,   /** @brief Context swap registers */
      [24] = (RW_ uint32_t* const)0x48021558U,   /** @brief Context swap registers */
      [25] = (RW_ uint32_t* const)0x4802155CU,   /** @brief Context swap registers */
      [26] = (RW_ uint32_t* const)0x48021560U,   /** @brief Context swap registers */
      [27] = (RW_ uint32_t* const)0x48021564U,   /** @brief Context swap registers */
      [28] = (RW_ uint32_t* const)0x48021568U,   /** @brief Context swap registers */
      [29] = (RW_ uint32_t* const)0x4802156CU,   /** @brief Context swap registers */
      [30] = (RW_ uint32_t* const)0x48021570U,   /** @brief Context swap registers */
      [31] = (RW_ uint32_t* const)0x48021574U,   /** @brief Context swap registers */
      [32] = (RW_ uint32_t* const)0x48021578U,   /** @brief Context swap registers */
      [33] = (RW_ uint32_t* const)0x4802157CU,   /** @brief Context swap registers */
      [34] = (RW_ uint32_t* const)0x48021580U,   /** @brief Context swap registers */
      [35] = (RW_ uint32_t* const)0x48021584U,   /** @brief Context swap registers */
      [36] = (RW_ uint32_t* const)0x48021588U,   /** @brief Context swap registers */
      [37] = (RW_ uint32_t* const)0x4802158CU,   /** @brief Context swap registers */
      [38] = (RW_ uint32_t* const)0x48021590U,   /** @brief Context swap registers */
      [39] = (RW_ uint32_t* const)0x48021594U,   /** @brief Context swap registers */
      [40] = (RW_ uint32_t* const)0x48021598U,   /** @brief Context swap registers */
      [41] = (RW_ uint32_t* const)0x4802159CU,   /** @brief Context swap registers */
      [42] = (RW_ uint32_t* const)0x480215A0U,   /** @brief Context swap registers */
      [43] = (RW_ uint32_t* const)0x480215A4U,   /** @brief Context swap registers */
      [44] = (RW_ uint32_t* const)0x480215A8U,   /** @brief Context swap registers */
      [45] = (RW_ uint32_t* const)0x480215ACU,   /** @brief Context swap registers */
      [46] = (RW_ uint32_t* const)0x480215B0U,   /** @brief Context swap registers */
      [47] = (RW_ uint32_t* const)0x480215B4U,   /** @brief Context swap registers */
      [48] = (RW_ uint32_t* const)0x480215B8U,   /** @brief Context swap registers */
      [49] = (RW_ uint32_t* const)0x480215BCU,   /** @brief Context swap registers */
      [50] = (RW_ uint32_t* const)0x480215C0U,   /** @brief Context swap registers */
      [51] = (RW_ uint32_t* const)0x480215C4U,   /** @brief Context swap registers */
      [52] = (RW_ uint32_t* const)0x480215C8U,   /** @brief Context swap registers */
      [53] = (RW_ uint32_t* const)0x480215CCU,   /** @brief Context swap registers */
    };

    static RO_ uint32_t* const HASH_HASH_HRx_PTR[8] = {
      [0] = (RO_ uint32_t* const)0x48021710U,   /** @brief HASH digest register */
      [1] = (RO_ uint32_t* const)0x48021714U,   /** @brief Read-only */
      [2] = (RO_ uint32_t* const)0x48021718U,   /** @brief Read-only */
      [3] = (RO_ uint32_t* const)0x4802171CU,   /** @brief Read-only */
      [4] = (RO_ uint32_t* const)0x48021720U,   /** @brief Read-only */
      [5] = (RO_ uint32_t* const)0x48021724U,   /** @brief Read-only */
      [6] = (RO_ uint32_t* const)0x48021728U,   /** @brief Read-only */
      [7] = (RO_ uint32_t* const)0x4802172CU,   /** @brief Read-only */
    };

    /**** @subsection HASH Register Reset Values ****/

    static const uint32_t HASH_CR_RST    = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t HASH_DIN_RST   = 0x00000000U;   /** @brief DIN register reset value. */
    static const uint32_t HASH_STR_RST   = 0x00000000U;   /** @brief STR register reset value. */
    static const uint32_t HASH_IMR_RST   = 0x00000000U;   /** @brief IMR register reset value. */
    static const uint32_t HASH_SR_RST    = 0x00000001U;   /** @brief SR register reset value. */

    /**** @subsection Enumerated HASH Register Reset Values ****/

    static const uint32_t HASH_HRx_RST[5] = {
      [0] = 0x00000000U,   /** @brief HR0 register reset value. */
      [1] = 0x00000000U,   /** @brief HR1 register reset value. */
      [2] = 0x00000000U,   /** @brief HR2 register reset value. */
      [3] = 0x00000000U,   /** @brief HR3 register reset value. */
      [4] = 0x00000000U,   /** @brief HR4 register reset value. */
    };

    static const uint32_t HASH_CSRx_RST[54] = {
      [0]  = 0x00000000U,   /** @brief CSR0 register reset value. */
      [1]  = 0x00000000U,   /** @brief CSR1 register reset value. */
      [2]  = 0x00000000U,   /** @brief CSR2 register reset value. */
      [3]  = 0x00000000U,   /** @brief CSR3 register reset value. */
      [4]  = 0x00000000U,   /** @brief CSR4 register reset value. */
      [5]  = 0x00000000U,   /** @brief CSR5 register reset value. */
      [6]  = 0x00000000U,   /** @brief CSR6 register reset value. */
      [7]  = 0x00000000U,   /** @brief CSR7 register reset value. */
      [8]  = 0x00000000U,   /** @brief CSR8 register reset value. */
      [9]  = 0x00000000U,   /** @brief CSR9 register reset value. */
      [10] = 0x00000000U,   /** @brief CSR10 register reset value. */
      [11] = 0x00000000U,   /** @brief CSR11 register reset value. */
      [12] = 0x00000000U,   /** @brief CSR12 register reset value. */
      [13] = 0x00000000U,   /** @brief CSR13 register reset value. */
      [14] = 0x00000000U,   /** @brief CSR14 register reset value. */
      [15] = 0x00000000U,   /** @brief CSR15 register reset value. */
      [16] = 0x00000000U,   /** @brief CSR16 register reset value. */
      [17] = 0x00000000U,   /** @brief CSR17 register reset value. */
      [18] = 0x00000000U,   /** @brief CSR18 register reset value. */
      [19] = 0x00000000U,   /** @brief CSR19 register reset value. */
      [20] = 0x00000000U,   /** @brief CSR20 register reset value. */
      [21] = 0x00000000U,   /** @brief CSR21 register reset value. */
      [22] = 0x00000000U,   /** @brief CSR22 register reset value. */
      [23] = 0x00000000U,   /** @brief CSR23 register reset value. */
      [24] = 0x00000000U,   /** @brief CSR24 register reset value. */
      [25] = 0x00000000U,   /** @brief CSR25 register reset value. */
      [26] = 0x00000000U,   /** @brief CSR26 register reset value. */
      [27] = 0x00000000U,   /** @brief CSR27 register reset value. */
      [28] = 0x00000000U,   /** @brief CSR28 register reset value. */
      [29] = 0x00000000U,   /** @brief CSR29 register reset value. */
      [30] = 0x00000000U,   /** @brief CSR30 register reset value. */
      [31] = 0x00000000U,   /** @brief CSR31 register reset value. */
      [32] = 0x00000000U,   /** @brief CSR32 register reset value. */
      [33] = 0x00000000U,   /** @brief CSR33 register reset value. */
      [34] = 0x00000000U,   /** @brief CSR34 register reset value. */
      [35] = 0x00000000U,   /** @brief CSR35 register reset value. */
      [36] = 0x00000000U,   /** @brief CSR36 register reset value. */
      [37] = 0x00000000U,   /** @brief CSR37 register reset value. */
      [38] = 0x00000000U,   /** @brief CSR38 register reset value. */
      [39] = 0x00000000U,   /** @brief CSR39 register reset value. */
      [40] = 0x00000000U,   /** @brief CSR40 register reset value. */
      [41] = 0x00000000U,   /** @brief CSR41 register reset value. */
      [42] = 0x00000000U,   /** @brief CSR42 register reset value. */
      [43] = 0x00000000U,   /** @brief CSR43 register reset value. */
      [44] = 0x00000000U,   /** @brief CSR44 register reset value. */
      [45] = 0x00000000U,   /** @brief CSR45 register reset value. */
      [46] = 0x00000000U,   /** @brief CSR46 register reset value. */
      [47] = 0x00000000U,   /** @brief CSR47 register reset value. */
      [48] = 0x00000000U,   /** @brief CSR48 register reset value. */
      [49] = 0x00000000U,   /** @brief CSR49 register reset value. */
      [50] = 0x00000000U,   /** @brief CSR50 register reset value. */
      [51] = 0x00000000U,   /** @brief CSR51 register reset value. */
      [52] = 0x00000000U,   /** @brief CSR52 register reset value. */
      [53] = 0x00000000U,   /** @brief CSR53 register reset value. */
    };

    static const uint32_t HASH_HASH_HRx_RST[8] = {
      [0] = 0x00000000U,   /** @brief HASH_HR0 register reset value. */
      [1] = 0x00000000U,   /** @brief HASH_HR1 register reset value. */
      [2] = 0x00000000U,   /** @brief HASH_HR2 register reset value. */
      [3] = 0x00000000U,   /** @brief HASH_HR3 register reset value. */
      [4] = 0x00000000U,   /** @brief HASH_HR4 register reset value. */
      [5] = 0x00000000U,   /** @brief HASH_HR5 register reset value. */
      [6] = 0x00000000U,   /** @brief HASH_HR6 register reset value. */
      [7] = 0x00000000U,   /** @brief HASH_HR7 register reset value. */
    };

    /**** @subsection Enumerated HASH Register Value Types ****/

    typedef uint32_t HASH_CR_t;         /** @brief CR register value type. */
    typedef uint32_t HASH_DIN_t;        /** @brief DIN register value type. */
    typedef uint32_t HASH_STR_t;        /** @brief STR register value type. */
    typedef uint32_t HASH_HRx_t;        /** @brief HRx register value type. */
    typedef uint32_t HASH_IMR_t;        /** @brief IMR register value type. */
    typedef uint32_t HASH_SR_t;         /** @brief SR register value type. */
    typedef uint32_t HASH_CSRx_t;       /** @brief CSRx register value type. */
    typedef uint32_t HASH_HASH_HRx_t;   /** @brief HASH_HRx register value type. */

    /**** @subsection Enumerated HASH Register Pointer Types ****/

    typedef uint32_t* const HASH_CR_PTR_t;         /** @brief CR register pointer type. */
    typedef uint32_t* const HASH_DIN_PTR_t;        /** @brief DIN register pointer type. */
    typedef uint32_t* const HASH_STR_PTR_t;        /** @brief STR register pointer type. */
    typedef uint32_t* const HASH_HRx_PTR_t;        /** @brief HRx register pointer type. */
    typedef uint32_t* const HASH_IMR_PTR_t;        /** @brief IMR register pointer type. */
    typedef uint32_t* const HASH_SR_PTR_t;         /** @brief SR register pointer type. */
    typedef uint32_t* const HASH_CSRx_PTR_t;       /** @brief CSRx register pointer type. */
    typedef uint32_t* const HASH_HASH_HRx_PTR_t;   /** @brief HASH_HRx register pointer type. */

    /**** @subsection HASH Register Field Masks ****/

    static const uint32_t HASH_CR_INIT_MASK       = 0x00000004U;   /** @brief Initialize message digest calculation */
    static const uint32_t HASH_CR_DMAE_MASK       = 0x00000008U;   /** @brief DMA enable */
    static const uint32_t HASH_CR_DATATYPE_MASK   = 0x00000030U;   /** @brief Data type selection */
    static const uint32_t HASH_CR_MODE_MASK       = 0x00000040U;   /** @brief Mode selection */
    static const uint32_t HASH_CR_NBW_MASK        = 0x00000F00U;   /** @brief Number of words already pushed */
    static const uint32_t HASH_CR_DINNE_MASK      = 0x00001000U;   /** @brief DIN not empty */
    static const uint32_t HASH_CR_MDMAT_MASK      = 0x00002000U;   /** @brief Multiple DMA transfers */
    static const uint32_t HASH_CR_LKEY_MASK       = 0x00010000U;   /** @brief Long key selection */
    static const uint32_t HASH_STR_DCAL_MASK      = 0x00000100U;   /** @brief Digest calculation */
    static const uint32_t HASH_STR_NBLW_MASK      = 0x0000001FU;   /** @brief Number of valid bits in the last word of the message */
    static const uint32_t HASH_IMR_DCIE_MASK      = 0x00000002U;   /** @brief Digest calculation completion interrupt enable */
    static const uint32_t HASH_IMR_DINIE_MASK     = 0x00000001U;   /** @brief Data input interrupt enable */
    static const uint32_t HASH_SR_BUSY_MASK       = 0x00000008U;   /** @brief Busy bit */
    static const uint32_t HASH_SR_DMAS_MASK       = 0x00000004U;   /** @brief DMA status */
    static const uint32_t HASH_SR_DCIS_MASK       = 0x00000002U;   /** @brief Digest calculation completion interrupt status */
    static const uint32_t HASH_SR_DINIS_MASK      = 0x00000001U;   /** @brief Data input interrupt status */

    /**** @subsection Enumerated HASH Register Field Masks ****/

    static const uint32_t HASH_CR_ALGOx_MASK[2] = {
      [0] = 0x00000080U,   /** @brief Algorithm selection */
      [1] = 0x00040000U,   /** @brief ALGO */
    };

    /**** @subsection HASH Register Field Positions ****/

    static const int32_t HASH_CR_INIT_POS       = 2;    /** @brief Initialize message digest calculation */
    static const int32_t HASH_CR_DMAE_POS       = 3;    /** @brief DMA enable */
    static const int32_t HASH_CR_DATATYPE_POS   = 4;    /** @brief Data type selection */
    static const int32_t HASH_CR_MODE_POS       = 6;    /** @brief Mode selection */
    static const int32_t HASH_CR_NBW_POS        = 8;    /** @brief Number of words already pushed */
    static const int32_t HASH_CR_DINNE_POS      = 12;   /** @brief DIN not empty */
    static const int32_t HASH_CR_MDMAT_POS      = 13;   /** @brief Multiple DMA transfers */
    static const int32_t HASH_CR_LKEY_POS       = 16;   /** @brief Long key selection */
    static const int32_t HASH_STR_DCAL_POS      = 8;    /** @brief Digest calculation */
    static const int32_t HASH_STR_NBLW_POS      = 0;    /** @brief Number of valid bits in the last word of the message */
    static const int32_t HASH_IMR_DCIE_POS      = 1;    /** @brief Digest calculation completion interrupt enable */
    static const int32_t HASH_IMR_DINIE_POS     = 0;    /** @brief Data input interrupt enable */
    static const int32_t HASH_SR_BUSY_POS       = 3;    /** @brief Busy bit */
    static const int32_t HASH_SR_DMAS_POS       = 2;    /** @brief DMA status */
    static const int32_t HASH_SR_DCIS_POS       = 1;    /** @brief Digest calculation completion interrupt status */
    static const int32_t HASH_SR_DINIS_POS      = 0;    /** @brief Data input interrupt status */

    /**** @subsection Enumerated HASH Register Field Positions ****/

    static const int32_t HASH_CR_ALGOx_POS[2] = {
      [0] = 7,    /** @brief Algorithm selection */
      [1] = 18,   /** @brief ALGO */
    };

    /**********************************************************************************************
     * @section CRYP Register Information
     **********************************************************************************************/

    /**** @subsection CRYP Register Pointers ****/

    static RW_ uint32_t* const CRYP_CR_PTR      = (RW_ uint32_t* const)0x48021000U;   /** @brief Control register */
    static RO_ uint32_t* const CRYP_SR_PTR      = (RO_ uint32_t* const)0x48021004U;   /** @brief Status register */
    static RW_ uint32_t* const CRYP_DIN_PTR     = (RW_ uint32_t* const)0x48021008U;   /** @brief Data input register */
    static RO_ uint32_t* const CRYP_DOUT_PTR    = (RO_ uint32_t* const)0x4802100CU;   /** @brief Data output register */
    static RW_ uint32_t* const CRYP_DMACR_PTR   = (RW_ uint32_t* const)0x48021010U;   /** @brief DMA control register */
    static RW_ uint32_t* const CRYP_IMSCR_PTR   = (RW_ uint32_t* const)0x48021014U;   /** @brief Interrupt mask set/clear register */
    static RO_ uint32_t* const CRYP_RISR_PTR    = (RO_ uint32_t* const)0x48021018U;   /** @brief Raw interrupt status register */
    static RO_ uint32_t* const CRYP_MISR_PTR    = (RO_ uint32_t* const)0x4802101CU;   /** @brief Masked interrupt status register */
    static RW_ uint32_t* const CRYP_K0LR_PTR    = (RW_ uint32_t* const)0x48021020U;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_K0RR_PTR    = (RW_ uint32_t* const)0x48021024U;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_K1LR_PTR    = (RW_ uint32_t* const)0x48021028U;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_K1RR_PTR    = (RW_ uint32_t* const)0x4802102CU;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_K2LR_PTR    = (RW_ uint32_t* const)0x48021030U;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_K2RR_PTR    = (RW_ uint32_t* const)0x48021034U;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_K3LR_PTR    = (RW_ uint32_t* const)0x48021038U;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_K3RR_PTR    = (RW_ uint32_t* const)0x4802103CU;   /** @brief Key registers */
    static RW_ uint32_t* const CRYP_IV0LR_PTR   = (RW_ uint32_t* const)0x48021040U;   /** @brief Initialization vector registers */
    static RW_ uint32_t* const CRYP_IV0RR_PTR   = (RW_ uint32_t* const)0x48021044U;   /** @brief Initialization vector registers */
    static RW_ uint32_t* const CRYP_IV1LR_PTR   = (RW_ uint32_t* const)0x48021048U;   /** @brief Initialization vector registers */
    static RW_ uint32_t* const CRYP_IV1RR_PTR   = (RW_ uint32_t* const)0x4802104CU;   /** @brief Initialization vector registers */

    /**** @subsection Enumerated CRYP Register Pointers ****/

    static RW_ uint32_t* const CRYP_CSGCMCCMxR_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x48021050U,   /** @brief Context swap register */
      [1] = (RW_ uint32_t* const)0x48021054U,   /** @brief Context swap register */
      [2] = (RW_ uint32_t* const)0x48021058U,   /** @brief Context swap register */
      [3] = (RW_ uint32_t* const)0x4802105CU,   /** @brief Context swap register */
      [4] = (RW_ uint32_t* const)0x48021060U,   /** @brief Context swap register */
      [5] = (RW_ uint32_t* const)0x48021064U,   /** @brief Context swap register */
      [6] = (RW_ uint32_t* const)0x48021068U,   /** @brief Context swap register */
      [7] = (RW_ uint32_t* const)0x4802106CU,   /** @brief Context swap register */
    };

    static RW_ uint32_t* const CRYP_CSGCMxR_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x48021070U,   /** @brief Context swap register */
      [1] = (RW_ uint32_t* const)0x48021074U,   /** @brief Context swap register */
      [2] = (RW_ uint32_t* const)0x48021078U,   /** @brief Context swap register */
      [3] = (RW_ uint32_t* const)0x4802107CU,   /** @brief Context swap register */
      [4] = (RW_ uint32_t* const)0x48021080U,   /** @brief Context swap register */
      [5] = (RW_ uint32_t* const)0x48021084U,   /** @brief Context swap register */
      [6] = (RW_ uint32_t* const)0x48021088U,   /** @brief Context swap register */
      [7] = (RW_ uint32_t* const)0x4802108CU,   /** @brief Context swap register */
    };

    /**** @subsection CRYP Register Reset Values ****/

    static const uint32_t CRYP_CR_RST      = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t CRYP_SR_RST      = 0x00000003U;   /** @brief SR register reset value. */
    static const uint32_t CRYP_DIN_RST     = 0x00000000U;   /** @brief DIN register reset value. */
    static const uint32_t CRYP_DOUT_RST    = 0x00000000U;   /** @brief DOUT register reset value. */
    static const uint32_t CRYP_DMACR_RST   = 0x00000000U;   /** @brief DMACR register reset value. */
    static const uint32_t CRYP_IMSCR_RST   = 0x00000000U;   /** @brief IMSCR register reset value. */
    static const uint32_t CRYP_RISR_RST    = 0x00000001U;   /** @brief RISR register reset value. */
    static const uint32_t CRYP_MISR_RST    = 0x00000000U;   /** @brief MISR register reset value. */
    static const uint32_t CRYP_K0LR_RST    = 0x00000000U;   /** @brief K0LR register reset value. */
    static const uint32_t CRYP_K0RR_RST    = 0x00000000U;   /** @brief K0RR register reset value. */
    static const uint32_t CRYP_K1LR_RST    = 0x00000000U;   /** @brief K1LR register reset value. */
    static const uint32_t CRYP_K1RR_RST    = 0x00000000U;   /** @brief K1RR register reset value. */
    static const uint32_t CRYP_K2LR_RST    = 0x00000000U;   /** @brief K2LR register reset value. */
    static const uint32_t CRYP_K2RR_RST    = 0x00000000U;   /** @brief K2RR register reset value. */
    static const uint32_t CRYP_K3LR_RST    = 0x00000000U;   /** @brief K3LR register reset value. */
    static const uint32_t CRYP_K3RR_RST    = 0x00000000U;   /** @brief K3RR register reset value. */
    static const uint32_t CRYP_IV0LR_RST   = 0x00000000U;   /** @brief IV0LR register reset value. */
    static const uint32_t CRYP_IV0RR_RST   = 0x00000000U;   /** @brief IV0RR register reset value. */
    static const uint32_t CRYP_IV1LR_RST   = 0x00000000U;   /** @brief IV1LR register reset value. */
    static const uint32_t CRYP_IV1RR_RST   = 0x00000000U;   /** @brief IV1RR register reset value. */

    /**** @subsection Enumerated CRYP Register Reset Values ****/

    static const uint32_t CRYP_CSGCMCCMxR_RST[8] = {
      [0] = 0x00000000U,   /** @brief CSGCMCCM0R register reset value. */
      [1] = 0x00000000U,   /** @brief CSGCMCCM1R register reset value. */
      [2] = 0x00000000U,   /** @brief CSGCMCCM2R register reset value. */
      [3] = 0x00000000U,   /** @brief CSGCMCCM3R register reset value. */
      [4] = 0x00000000U,   /** @brief CSGCMCCM4R register reset value. */
      [5] = 0x00000000U,   /** @brief CSGCMCCM5R register reset value. */
      [6] = 0x00000000U,   /** @brief CSGCMCCM6R register reset value. */
      [7] = 0x00000000U,   /** @brief CSGCMCCM7R register reset value. */
    };

    static const uint32_t CRYP_CSGCMxR_RST[8] = {
      [0] = 0x00000000U,   /** @brief CSGCM0R register reset value. */
      [1] = 0x00000000U,   /** @brief CSGCM1R register reset value. */
      [2] = 0x00000000U,   /** @brief CSGCM2R register reset value. */
      [3] = 0x00000000U,   /** @brief CSGCM3R register reset value. */
      [4] = 0x00000000U,   /** @brief CSGCM4R register reset value. */
      [5] = 0x00000000U,   /** @brief CSGCM5R register reset value. */
      [6] = 0x00000000U,   /** @brief CSGCM6R register reset value. */
      [7] = 0x00000000U,   /** @brief CSGCM7R register reset value. */
    };

    /**** @subsection Enumerated CRYP Register Value Types ****/

    typedef uint32_t CRYP_CR_t;           /** @brief CR register value type. */
    typedef uint32_t CRYP_SR_t;           /** @brief SR register value type. */
    typedef uint32_t CRYP_DIN_t;          /** @brief DIN register value type. */
    typedef uint32_t CRYP_DOUT_t;         /** @brief DOUT register value type. */
    typedef uint32_t CRYP_DMACR_t;        /** @brief DMACR register value type. */
    typedef uint32_t CRYP_IMSCR_t;        /** @brief IMSCR register value type. */
    typedef uint32_t CRYP_RISR_t;         /** @brief RISR register value type. */
    typedef uint32_t CRYP_MISR_t;         /** @brief MISR register value type. */
    typedef uint32_t CRYP_K0LR_t;         /** @brief K0LR register value type. */
    typedef uint32_t CRYP_K0RR_t;         /** @brief K0RR register value type. */
    typedef uint32_t CRYP_K1LR_t;         /** @brief K1LR register value type. */
    typedef uint32_t CRYP_K1RR_t;         /** @brief K1RR register value type. */
    typedef uint32_t CRYP_K2LR_t;         /** @brief K2LR register value type. */
    typedef uint32_t CRYP_K2RR_t;         /** @brief K2RR register value type. */
    typedef uint32_t CRYP_K3LR_t;         /** @brief K3LR register value type. */
    typedef uint32_t CRYP_K3RR_t;         /** @brief K3RR register value type. */
    typedef uint32_t CRYP_IV0LR_t;        /** @brief IV0LR register value type. */
    typedef uint32_t CRYP_IV0RR_t;        /** @brief IV0RR register value type. */
    typedef uint32_t CRYP_IV1LR_t;        /** @brief IV1LR register value type. */
    typedef uint32_t CRYP_IV1RR_t;        /** @brief IV1RR register value type. */
    typedef uint32_t CRYP_CSGCMCCMxR_t;   /** @brief CSGCMCCMxR register value type. */
    typedef uint32_t CRYP_CSGCMxR_t;      /** @brief CSGCMxR register value type. */

    /**** @subsection Enumerated CRYP Register Pointer Types ****/

    typedef uint32_t* const CRYP_CR_PTR_t;           /** @brief CR register pointer type. */
    typedef uint32_t* const CRYP_SR_PTR_t;           /** @brief SR register pointer type. */
    typedef uint32_t* const CRYP_DIN_PTR_t;          /** @brief DIN register pointer type. */
    typedef uint32_t* const CRYP_DOUT_PTR_t;         /** @brief DOUT register pointer type. */
    typedef uint32_t* const CRYP_DMACR_PTR_t;        /** @brief DMACR register pointer type. */
    typedef uint32_t* const CRYP_IMSCR_PTR_t;        /** @brief IMSCR register pointer type. */
    typedef uint32_t* const CRYP_RISR_PTR_t;         /** @brief RISR register pointer type. */
    typedef uint32_t* const CRYP_MISR_PTR_t;         /** @brief MISR register pointer type. */
    typedef uint32_t* const CRYP_K0LR_PTR_t;         /** @brief K0LR register pointer type. */
    typedef uint32_t* const CRYP_K0RR_PTR_t;         /** @brief K0RR register pointer type. */
    typedef uint32_t* const CRYP_K1LR_PTR_t;         /** @brief K1LR register pointer type. */
    typedef uint32_t* const CRYP_K1RR_PTR_t;         /** @brief K1RR register pointer type. */
    typedef uint32_t* const CRYP_K2LR_PTR_t;         /** @brief K2LR register pointer type. */
    typedef uint32_t* const CRYP_K2RR_PTR_t;         /** @brief K2RR register pointer type. */
    typedef uint32_t* const CRYP_K3LR_PTR_t;         /** @brief K3LR register pointer type. */
    typedef uint32_t* const CRYP_K3RR_PTR_t;         /** @brief K3RR register pointer type. */
    typedef uint32_t* const CRYP_IV0LR_PTR_t;        /** @brief IV0LR register pointer type. */
    typedef uint32_t* const CRYP_IV0RR_PTR_t;        /** @brief IV0RR register pointer type. */
    typedef uint32_t* const CRYP_IV1LR_PTR_t;        /** @brief IV1LR register pointer type. */
    typedef uint32_t* const CRYP_IV1RR_PTR_t;        /** @brief IV1RR register pointer type. */
    typedef uint32_t* const CRYP_CSGCMCCMxR_PTR_t;   /** @brief CSGCMCCMxR register pointer type. */
    typedef uint32_t* const CRYP_CSGCMxR_PTR_t;      /** @brief CSGCMxR register pointer type. */

    /**** @subsection CRYP Register Field Masks ****/

    static const uint32_t CRYP_CR_ALGODIR_MASK     = 0x00000004U;   /** @brief Algorithm direction */
    static const uint32_t CRYP_CR_DATATYPE_MASK    = 0x000000C0U;   /** @brief Data type selection */
    static const uint32_t CRYP_CR_KEYSIZE_MASK     = 0x00000300U;   /** @brief Key size selection (AES mode only) */
    static const uint32_t CRYP_CR_FFLUSH_MASK      = 0x00004000U;   /** @brief FIFO flush */
    static const uint32_t CRYP_CR_CRYPEN_MASK      = 0x00008000U;   /** @brief Cryptographic processor enable */
    static const uint32_t CRYP_CR_GCM_CCMPH_MASK   = 0x00030000U;   /** @brief GCM_CCMPH */
    static const uint32_t CRYP_SR_BUSY_MASK        = 0x00000010U;   /** @brief Busy bit */
    static const uint32_t CRYP_SR_OFFU_MASK        = 0x00000008U;   /** @brief Output FIFO full */
    static const uint32_t CRYP_SR_OFNE_MASK        = 0x00000004U;   /** @brief Output FIFO not empty */
    static const uint32_t CRYP_SR_IFNF_MASK        = 0x00000002U;   /** @brief Input FIFO not full */
    static const uint32_t CRYP_SR_IFEM_MASK        = 0x00000001U;   /** @brief Input FIFO empty */
    static const uint32_t CRYP_DMACR_DOEN_MASK     = 0x00000002U;   /** @brief DMA output enable */
    static const uint32_t CRYP_DMACR_DIEN_MASK     = 0x00000001U;   /** @brief DMA input enable */
    static const uint32_t CRYP_IMSCR_OUTIM_MASK    = 0x00000002U;   /** @brief Output FIFO service interrupt mask */
    static const uint32_t CRYP_IMSCR_INIM_MASK     = 0x00000001U;   /** @brief Input FIFO service interrupt mask */
    static const uint32_t CRYP_RISR_OUTRIS_MASK    = 0x00000002U;   /** @brief Output FIFO service raw interrupt status */
    static const uint32_t CRYP_RISR_INRIS_MASK     = 0x00000001U;   /** @brief Input FIFO service raw interrupt status */
    static const uint32_t CRYP_MISR_OUTMIS_MASK    = 0x00000002U;   /** @brief Output FIFO service masked interrupt status */
    static const uint32_t CRYP_MISR_INMIS_MASK     = 0x00000001U;   /** @brief Input FIFO service masked interrupt status */

    /**** @subsection Enumerated CRYP Register Field Masks ****/

    static const uint32_t CRYP_CR_ALGOMODEx_MASK[4] = {
      [0] = 0x00000038U,   /** @brief Algorithm mode */
      [3] = 0x00080000U,   /** @brief ALGOMODE */
    };

    static const uint32_t CRYP_K0LR_B2x_MASK[56] = {
      [24] = 0x00000001U,   /** @brief B224 */
      [30] = 0x00000040U,   /** @brief B230 */
      [31] = 0x00000080U,   /** @brief B231 */
      [32] = 0x00000100U,   /** @brief B232 */
      [33] = 0x00000200U,   /** @brief B233 */
      [34] = 0x00000400U,   /** @brief B234 */
      [35] = 0x00000800U,   /** @brief B235 */
      [36] = 0x00001000U,   /** @brief B236 */
      [37] = 0x00002000U,   /** @brief B237 */
      [38] = 0x00004000U,   /** @brief B238 */
      [39] = 0x00008000U,   /** @brief B239 */
      [40] = 0x00010000U,   /** @brief B240 */
      [41] = 0x00020000U,   /** @brief B241 */
      [42] = 0x00040000U,   /** @brief B242 */
      [43] = 0x00080000U,   /** @brief B243 */
      [44] = 0x00100000U,   /** @brief B244 */
      [45] = 0x00200000U,   /** @brief B245 */
      [46] = 0x00400000U,   /** @brief B246 */
      [47] = 0x00800000U,   /** @brief B247 */
      [48] = 0x01000000U,   /** @brief B248 */
      [49] = 0x02000000U,   /** @brief B249 */
      [50] = 0x04000000U,   /** @brief B250 */
      [51] = 0x08000000U,   /** @brief B251 */
      [52] = 0x10000000U,   /** @brief B252 */
      [53] = 0x20000000U,   /** @brief B253 */
      [54] = 0x40000000U,   /** @brief B254 */
      [55] = 0x80000000U,   /** @brief B255 */
    };

    static const uint32_t CRYP_K0LR_B22x_MASK[10] = {
      [5]  = 0x00000002U,   /** @brief B225 */
      [6]  = 0x00000004U,   /** @brief B226 */
      [7]  = 0x00000008U,   /** @brief B227 */
      [8]  = 0x00000010U,   /** @brief B228 */
      [9]  = 0x00000020U,   /** @brief B229 */
    };

    static const uint32_t CRYP_K0RR_B19x_MASK[10] = {
      [2]  = 0x00000001U,   /** @brief B192 */
      [3]  = 0x00000002U,   /** @brief B193 */
      [4]  = 0x00000004U,   /** @brief B194 */
      [5]  = 0x00000008U,   /** @brief B195 */
      [6]  = 0x00000010U,   /** @brief B196 */
      [7]  = 0x00000020U,   /** @brief B197 */
      [8]  = 0x00000040U,   /** @brief B198 */
      [9]  = 0x00000080U,   /** @brief B199 */
    };

    static const uint32_t CRYP_K0RR_B20x_MASK[10] = {
      [1]  = 0x00000200U,   /** @brief B201 */
      [2]  = 0x00000400U,   /** @brief B202 */
      [3]  = 0x00000800U,   /** @brief B203 */
      [4]  = 0x00001000U,   /** @brief B204 */
      [5]  = 0x00002000U,   /** @brief B205 */
      [6]  = 0x00004000U,   /** @brief B206 */
      [7]  = 0x00008000U,   /** @brief B207 */
      [8]  = 0x00010000U,   /** @brief B208 */
      [9]  = 0x00020000U,   /** @brief B209 */
    };

    static const uint32_t CRYP_K1LR_B1x_MASK[92] = {
      [60] = 0x00000001U,   /** @brief B160 */
      [70] = 0x00000400U,   /** @brief B170 */
      [71] = 0x00000800U,   /** @brief B171 */
      [72] = 0x00001000U,   /** @brief B172 */
      [73] = 0x00002000U,   /** @brief B173 */
      [74] = 0x00004000U,   /** @brief B174 */
      [75] = 0x00008000U,   /** @brief B175 */
      [76] = 0x00010000U,   /** @brief B176 */
      [77] = 0x00020000U,   /** @brief B177 */
      [78] = 0x00040000U,   /** @brief B178 */
      [79] = 0x00080000U,   /** @brief B179 */
      [80] = 0x00100000U,   /** @brief B180 */
      [81] = 0x00200000U,   /** @brief B181 */
      [82] = 0x00400000U,   /** @brief B182 */
      [83] = 0x00800000U,   /** @brief B183 */
      [84] = 0x01000000U,   /** @brief B184 */
      [85] = 0x02000000U,   /** @brief B185 */
      [86] = 0x04000000U,   /** @brief B186 */
      [87] = 0x08000000U,   /** @brief B187 */
      [88] = 0x10000000U,   /** @brief B188 */
      [89] = 0x20000000U,   /** @brief B189 */
      [90] = 0x40000000U,   /** @brief B190 */
      [91] = 0x80000000U,   /** @brief B191 */
    };

    static const uint32_t CRYP_K1LR_B16x_MASK[10] = {
      [1]  = 0x00000002U,   /** @brief B161 */
      [2]  = 0x00000004U,   /** @brief B162 */
      [3]  = 0x00000008U,   /** @brief B163 */
      [4]  = 0x00000010U,   /** @brief B164 */
      [5]  = 0x00000020U,   /** @brief B165 */
      [6]  = 0x00000040U,   /** @brief B166 */
      [7]  = 0x00000080U,   /** @brief B167 */
      [8]  = 0x00000100U,   /** @brief B168 */
      [9]  = 0x00000200U,   /** @brief B169 */
    };

    static const uint32_t CRYP_K1RR_B12x_MASK[10] = {
      [9]  = 0x00000002U,   /** @brief B129 */
    };

    static const uint32_t CRYP_K2LR_B9x_MASK[10] = {
      [6]  = 0x00000001U,   /** @brief B96 */
      [7]  = 0x00000002U,   /** @brief B97 */
      [8]  = 0x00000004U,   /** @brief B98 */
      [9]  = 0x00000008U,   /** @brief B99 */
    };

    static const uint32_t CRYP_K2LR_B10x_MASK[10] = {
      [1]  = 0x00000020U,   /** @brief B101 */
      [2]  = 0x00000040U,   /** @brief B102 */
      [3]  = 0x00000080U,   /** @brief B103 */
      [4]  = 0x00000100U,   /** @brief B104 */
      [5]  = 0x00000200U,   /** @brief B105 */
      [6]  = 0x00000400U,   /** @brief B106 */
      [7]  = 0x00000800U,   /** @brief B107 */
      [8]  = 0x00001000U,   /** @brief B108 */
      [9]  = 0x00002000U,   /** @brief B109 */
    };

    static const uint32_t CRYP_K2RR_Bx_MASK[96] = {
      [64] = 0x00000001U,   /** @brief B64 */
      [70] = 0x00000040U,   /** @brief B70 */
      [71] = 0x00000080U,   /** @brief B71 */
      [72] = 0x00000100U,   /** @brief B72 */
      [73] = 0x00000200U,   /** @brief B73 */
      [74] = 0x00000400U,   /** @brief B74 */
      [75] = 0x00000800U,   /** @brief B75 */
      [76] = 0x00001000U,   /** @brief B76 */
      [77] = 0x00002000U,   /** @brief B77 */
      [78] = 0x00004000U,   /** @brief B78 */
      [79] = 0x00008000U,   /** @brief B79 */
      [80] = 0x00010000U,   /** @brief B80 */
      [81] = 0x00020000U,   /** @brief B81 */
      [82] = 0x00040000U,   /** @brief B82 */
      [83] = 0x00080000U,   /** @brief B83 */
      [84] = 0x00100000U,   /** @brief B84 */
      [85] = 0x00200000U,   /** @brief B85 */
      [86] = 0x00400000U,   /** @brief B86 */
      [87] = 0x00800000U,   /** @brief B87 */
      [88] = 0x01000000U,   /** @brief B88 */
      [89] = 0x02000000U,   /** @brief B89 */
      [90] = 0x04000000U,   /** @brief B90 */
      [91] = 0x08000000U,   /** @brief B91 */
      [92] = 0x10000000U,   /** @brief B92 */
      [93] = 0x20000000U,   /** @brief B93 */
      [94] = 0x40000000U,   /** @brief B94 */
      [95] = 0x80000000U,   /** @brief B95 */
    };

    static const uint32_t CRYP_K2RR_B6x_MASK[10] = {
      [5]  = 0x00000002U,   /** @brief B65 */
      [6]  = 0x00000004U,   /** @brief B66 */
      [7]  = 0x00000008U,   /** @brief B67 */
      [8]  = 0x00000010U,   /** @brief B68 */
      [9]  = 0x00000020U,   /** @brief B69 */
    };

    static const uint32_t CRYP_K3LR_B3x_MASK[10] = {
      [3]  = 0x00000002U,   /** @brief B33 */
      [4]  = 0x00000004U,   /** @brief B34 */
      [5]  = 0x00000008U,   /** @brief B35 */
      [6]  = 0x00000010U,   /** @brief B36 */
      [7]  = 0x00000020U,   /** @brief B37 */
      [8]  = 0x00000040U,   /** @brief B38 */
      [9]  = 0x00000080U,   /** @brief B39 */
    };

    static const uint32_t CRYP_IV0LR_IVx_MASK[32] = {
      [0]  = 0x80000000U,   /** @brief IV0 */
      [1]  = 0x40000000U,   /** @brief IV1 */
      [2]  = 0x20000000U,   /** @brief IV2 */
      [3]  = 0x10000000U,   /** @brief IV3 */
      [4]  = 0x08000000U,   /** @brief IV4 */
      [5]  = 0x04000000U,   /** @brief IV5 */
      [6]  = 0x02000000U,   /** @brief IV6 */
      [7]  = 0x01000000U,   /** @brief IV7 */
      [8]  = 0x00800000U,   /** @brief IV8 */
      [9]  = 0x00400000U,   /** @brief IV9 */
      [10] = 0x00200000U,   /** @brief IV10 */
      [11] = 0x00100000U,   /** @brief IV11 */
      [12] = 0x00080000U,   /** @brief IV12 */
      [13] = 0x00040000U,   /** @brief IV13 */
      [14] = 0x00020000U,   /** @brief IV14 */
      [15] = 0x00010000U,   /** @brief IV15 */
      [16] = 0x00008000U,   /** @brief IV16 */
      [17] = 0x00004000U,   /** @brief IV17 */
      [18] = 0x00002000U,   /** @brief IV18 */
      [19] = 0x00001000U,   /** @brief IV19 */
      [20] = 0x00000800U,   /** @brief IV20 */
      [21] = 0x00000400U,   /** @brief IV21 */
      [22] = 0x00000200U,   /** @brief IV22 */
      [23] = 0x00000100U,   /** @brief IV23 */
      [24] = 0x00000080U,   /** @brief IV24 */
      [25] = 0x00000040U,   /** @brief IV25 */
      [26] = 0x00000020U,   /** @brief IV26 */
      [27] = 0x00000010U,   /** @brief IV27 */
      [28] = 0x00000008U,   /** @brief IV28 */
      [29] = 0x00000004U,   /** @brief IV29 */
      [31] = 0x00000001U,   /** @brief IV31 */
    };

    static const uint32_t CRYP_IV0LR_IV3x_MASK[2] = {
      [0] = 0x00000002U,   /** @brief IV30 */
    };

    static const uint32_t CRYP_IV0RR_IV6x_MASK[4] = {
      [0] = 0x00000008U,   /** @brief IV60 */
      [1] = 0x00000004U,   /** @brief IV61 */
      [2] = 0x00000002U,   /** @brief IV62 */
    };

    static const uint32_t CRYP_IV1LR_IV9x_MASK[6] = {
      [0] = 0x00000020U,   /** @brief IV90 */
      [1] = 0x00000010U,   /** @brief IV91 */
      [2] = 0x00000008U,   /** @brief IV92 */
      [3] = 0x00000004U,   /** @brief IV93 */
      [4] = 0x00000002U,   /** @brief IV94 */
    };

    static const uint32_t CRYP_IV1RR_IV1x_MASK[28] = {
      [0]  = 0x08000000U,   /** @brief IV100 */
      [1]  = 0x04000000U,   /** @brief IV101 */
      [2]  = 0x02000000U,   /** @brief IV102 */
      [3]  = 0x01000000U,   /** @brief IV103 */
      [4]  = 0x00800000U,   /** @brief IV104 */
      [5]  = 0x00400000U,   /** @brief IV105 */
      [6]  = 0x00200000U,   /** @brief IV106 */
      [7]  = 0x00100000U,   /** @brief IV107 */
      [8]  = 0x00080000U,   /** @brief IV108 */
      [9]  = 0x00040000U,   /** @brief IV109 */
      [10] = 0x00020000U,   /** @brief IV110 */
      [11] = 0x00010000U,   /** @brief IV111 */
      [12] = 0x00008000U,   /** @brief IV112 */
      [13] = 0x00004000U,   /** @brief IV113 */
      [14] = 0x00002000U,   /** @brief IV114 */
      [15] = 0x00001000U,   /** @brief IV115 */
      [16] = 0x00000800U,   /** @brief IV116 */
      [17] = 0x00000400U,   /** @brief IV117 */
      [18] = 0x00000200U,   /** @brief IV118 */
      [19] = 0x00000100U,   /** @brief IV119 */
      [27] = 0x00000001U,   /** @brief IV127 */
    };

    static const uint32_t CRYP_IV1RR_IV12x_MASK[8] = {
      [0] = 0x00000080U,   /** @brief IV120 */
      [1] = 0x00000040U,   /** @brief IV121 */
      [2] = 0x00000020U,   /** @brief IV122 */
      [3] = 0x00000010U,   /** @brief IV123 */
      [4] = 0x00000008U,   /** @brief IV124 */
      [5] = 0x00000004U,   /** @brief IV125 */
      [6] = 0x00000002U,   /** @brief IV126 */
    };

    /**** @subsection CRYP Register Field Positions ****/

    static const int32_t CRYP_CR_ALGODIR_POS     = 2;    /** @brief Algorithm direction */
    static const int32_t CRYP_CR_DATATYPE_POS    = 6;    /** @brief Data type selection */
    static const int32_t CRYP_CR_KEYSIZE_POS     = 8;    /** @brief Key size selection (AES mode only) */
    static const int32_t CRYP_CR_FFLUSH_POS      = 14;   /** @brief FIFO flush */
    static const int32_t CRYP_CR_CRYPEN_POS      = 15;   /** @brief Cryptographic processor enable */
    static const int32_t CRYP_CR_GCM_CCMPH_POS   = 16;   /** @brief GCM_CCMPH */
    static const int32_t CRYP_SR_BUSY_POS        = 4;    /** @brief Busy bit */
    static const int32_t CRYP_SR_OFFU_POS        = 3;    /** @brief Output FIFO full */
    static const int32_t CRYP_SR_OFNE_POS        = 2;    /** @brief Output FIFO not empty */
    static const int32_t CRYP_SR_IFNF_POS        = 1;    /** @brief Input FIFO not full */
    static const int32_t CRYP_SR_IFEM_POS        = 0;    /** @brief Input FIFO empty */
    static const int32_t CRYP_DMACR_DOEN_POS     = 1;    /** @brief DMA output enable */
    static const int32_t CRYP_DMACR_DIEN_POS     = 0;    /** @brief DMA input enable */
    static const int32_t CRYP_IMSCR_OUTIM_POS    = 1;    /** @brief Output FIFO service interrupt mask */
    static const int32_t CRYP_IMSCR_INIM_POS     = 0;    /** @brief Input FIFO service interrupt mask */
    static const int32_t CRYP_RISR_OUTRIS_POS    = 1;    /** @brief Output FIFO service raw interrupt status */
    static const int32_t CRYP_RISR_INRIS_POS     = 0;    /** @brief Input FIFO service raw interrupt status */
    static const int32_t CRYP_MISR_OUTMIS_POS    = 1;    /** @brief Output FIFO service masked interrupt status */
    static const int32_t CRYP_MISR_INMIS_POS     = 0;    /** @brief Input FIFO service masked interrupt status */

    /**** @subsection Enumerated CRYP Register Field Positions ****/

    static const int32_t CRYP_CR_ALGOMODEx_POS[4] = {
      [0] = 3,    /** @brief Algorithm mode */
      [3] = 19,   /** @brief ALGOMODE */
    };

    static const int32_t CRYP_K0LR_B2x_POS[56] = {
      [24] = 0,    /** @brief B224 */
      [30] = 6,    /** @brief B230 */
      [31] = 7,    /** @brief B231 */
      [32] = 8,    /** @brief B232 */
      [33] = 9,    /** @brief B233 */
      [34] = 10,   /** @brief B234 */
      [35] = 11,   /** @brief B235 */
      [36] = 12,   /** @brief B236 */
      [37] = 13,   /** @brief B237 */
      [38] = 14,   /** @brief B238 */
      [39] = 15,   /** @brief B239 */
      [40] = 16,   /** @brief B240 */
      [41] = 17,   /** @brief B241 */
      [42] = 18,   /** @brief B242 */
      [43] = 19,   /** @brief B243 */
      [44] = 20,   /** @brief B244 */
      [45] = 21,   /** @brief B245 */
      [46] = 22,   /** @brief B246 */
      [47] = 23,   /** @brief B247 */
      [48] = 24,   /** @brief B248 */
      [49] = 25,   /** @brief B249 */
      [50] = 26,   /** @brief B250 */
      [51] = 27,   /** @brief B251 */
      [52] = 28,   /** @brief B252 */
      [53] = 29,   /** @brief B253 */
      [54] = 30,   /** @brief B254 */
      [55] = 31,   /** @brief B255 */
    };

    static const int32_t CRYP_K0LR_B22x_POS[10] = {
      [5]  = 1,   /** @brief B225 */
      [6]  = 2,   /** @brief B226 */
      [7]  = 3,   /** @brief B227 */
      [8]  = 4,   /** @brief B228 */
      [9]  = 5,   /** @brief B229 */
    };

    static const int32_t CRYP_K0RR_B19x_POS[10] = {
      [2]  = 0,   /** @brief B192 */
      [3]  = 1,   /** @brief B193 */
      [4]  = 2,   /** @brief B194 */
      [5]  = 3,   /** @brief B195 */
      [6]  = 4,   /** @brief B196 */
      [7]  = 5,   /** @brief B197 */
      [8]  = 6,   /** @brief B198 */
      [9]  = 7,   /** @brief B199 */
    };

    static const int32_t CRYP_K0RR_B20x_POS[10] = {
      [1]  = 9,    /** @brief B201 */
      [2]  = 10,   /** @brief B202 */
      [3]  = 11,   /** @brief B203 */
      [4]  = 12,   /** @brief B204 */
      [5]  = 13,   /** @brief B205 */
      [6]  = 14,   /** @brief B206 */
      [7]  = 15,   /** @brief B207 */
      [8]  = 16,   /** @brief B208 */
      [9]  = 17,   /** @brief B209 */
    };

    static const int32_t CRYP_K1LR_B1x_POS[92] = {
      [60] = 0,    /** @brief B160 */
      [70] = 10,   /** @brief B170 */
      [71] = 11,   /** @brief B171 */
      [72] = 12,   /** @brief B172 */
      [73] = 13,   /** @brief B173 */
      [74] = 14,   /** @brief B174 */
      [75] = 15,   /** @brief B175 */
      [76] = 16,   /** @brief B176 */
      [77] = 17,   /** @brief B177 */
      [78] = 18,   /** @brief B178 */
      [79] = 19,   /** @brief B179 */
      [80] = 20,   /** @brief B180 */
      [81] = 21,   /** @brief B181 */
      [82] = 22,   /** @brief B182 */
      [83] = 23,   /** @brief B183 */
      [84] = 24,   /** @brief B184 */
      [85] = 25,   /** @brief B185 */
      [86] = 26,   /** @brief B186 */
      [87] = 27,   /** @brief B187 */
      [88] = 28,   /** @brief B188 */
      [89] = 29,   /** @brief B189 */
      [90] = 30,   /** @brief B190 */
      [91] = 31,   /** @brief B191 */
    };

    static const int32_t CRYP_K1LR_B16x_POS[10] = {
      [1]  = 1,   /** @brief B161 */
      [2]  = 2,   /** @brief B162 */
      [3]  = 3,   /** @brief B163 */
      [4]  = 4,   /** @brief B164 */
      [5]  = 5,   /** @brief B165 */
      [6]  = 6,   /** @brief B166 */
      [7]  = 7,   /** @brief B167 */
      [8]  = 8,   /** @brief B168 */
      [9]  = 9,   /** @brief B169 */
    };

    static const int32_t CRYP_K1RR_B12x_POS[10] = {
      [9]  = 1,   /** @brief B129 */
    };

    static const int32_t CRYP_K2LR_B9x_POS[10] = {
      [6]  = 0,   /** @brief B96 */
      [7]  = 1,   /** @brief B97 */
      [8]  = 2,   /** @brief B98 */
      [9]  = 3,   /** @brief B99 */
    };

    static const int32_t CRYP_K2LR_B10x_POS[10] = {
      [1]  = 5,    /** @brief B101 */
      [2]  = 6,    /** @brief B102 */
      [3]  = 7,    /** @brief B103 */
      [4]  = 8,    /** @brief B104 */
      [5]  = 9,    /** @brief B105 */
      [6]  = 10,   /** @brief B106 */
      [7]  = 11,   /** @brief B107 */
      [8]  = 12,   /** @brief B108 */
      [9]  = 13,   /** @brief B109 */
    };

    static const int32_t CRYP_K2RR_Bx_POS[96] = {
      [64] = 0,    /** @brief B64 */
      [70] = 6,    /** @brief B70 */
      [71] = 7,    /** @brief B71 */
      [72] = 8,    /** @brief B72 */
      [73] = 9,    /** @brief B73 */
      [74] = 10,   /** @brief B74 */
      [75] = 11,   /** @brief B75 */
      [76] = 12,   /** @brief B76 */
      [77] = 13,   /** @brief B77 */
      [78] = 14,   /** @brief B78 */
      [79] = 15,   /** @brief B79 */
      [80] = 16,   /** @brief B80 */
      [81] = 17,   /** @brief B81 */
      [82] = 18,   /** @brief B82 */
      [83] = 19,   /** @brief B83 */
      [84] = 20,   /** @brief B84 */
      [85] = 21,   /** @brief B85 */
      [86] = 22,   /** @brief B86 */
      [87] = 23,   /** @brief B87 */
      [88] = 24,   /** @brief B88 */
      [89] = 25,   /** @brief B89 */
      [90] = 26,   /** @brief B90 */
      [91] = 27,   /** @brief B91 */
      [92] = 28,   /** @brief B92 */
      [93] = 29,   /** @brief B93 */
      [94] = 30,   /** @brief B94 */
      [95] = 31,   /** @brief B95 */
    };

    static const int32_t CRYP_K2RR_B6x_POS[10] = {
      [5]  = 1,   /** @brief B65 */
      [6]  = 2,   /** @brief B66 */
      [7]  = 3,   /** @brief B67 */
      [8]  = 4,   /** @brief B68 */
      [9]  = 5,   /** @brief B69 */
    };

    static const int32_t CRYP_K3LR_B3x_POS[10] = {
      [3]  = 1,   /** @brief B33 */
      [4]  = 2,   /** @brief B34 */
      [5]  = 3,   /** @brief B35 */
      [6]  = 4,   /** @brief B36 */
      [7]  = 5,   /** @brief B37 */
      [8]  = 6,   /** @brief B38 */
      [9]  = 7,   /** @brief B39 */
    };

    static const int32_t CRYP_IV0LR_IVx_POS[32] = {
      [0]  = 31,   /** @brief IV0 */
      [1]  = 30,   /** @brief IV1 */
      [2]  = 29,   /** @brief IV2 */
      [3]  = 28,   /** @brief IV3 */
      [4]  = 27,   /** @brief IV4 */
      [5]  = 26,   /** @brief IV5 */
      [6]  = 25,   /** @brief IV6 */
      [7]  = 24,   /** @brief IV7 */
      [8]  = 23,   /** @brief IV8 */
      [9]  = 22,   /** @brief IV9 */
      [10] = 21,   /** @brief IV10 */
      [11] = 20,   /** @brief IV11 */
      [12] = 19,   /** @brief IV12 */
      [13] = 18,   /** @brief IV13 */
      [14] = 17,   /** @brief IV14 */
      [15] = 16,   /** @brief IV15 */
      [16] = 15,   /** @brief IV16 */
      [17] = 14,   /** @brief IV17 */
      [18] = 13,   /** @brief IV18 */
      [19] = 12,   /** @brief IV19 */
      [20] = 11,   /** @brief IV20 */
      [21] = 10,   /** @brief IV21 */
      [22] = 9,    /** @brief IV22 */
      [23] = 8,    /** @brief IV23 */
      [24] = 7,    /** @brief IV24 */
      [25] = 6,    /** @brief IV25 */
      [26] = 5,    /** @brief IV26 */
      [27] = 4,    /** @brief IV27 */
      [28] = 3,    /** @brief IV28 */
      [29] = 2,    /** @brief IV29 */
      [31] = 0,    /** @brief IV31 */
    };

    static const int32_t CRYP_IV0LR_IV3x_POS[2] = {
      [0] = 1,   /** @brief IV30 */
    };

    static const int32_t CRYP_IV0RR_IV6x_POS[4] = {
      [0] = 3,   /** @brief IV60 */
      [1] = 2,   /** @brief IV61 */
      [2] = 1,   /** @brief IV62 */
    };

    static const int32_t CRYP_IV1LR_IV9x_POS[6] = {
      [0] = 5,   /** @brief IV90 */
      [1] = 4,   /** @brief IV91 */
      [2] = 3,   /** @brief IV92 */
      [3] = 2,   /** @brief IV93 */
      [4] = 1,   /** @brief IV94 */
    };

    static const int32_t CRYP_IV1RR_IV1x_POS[28] = {
      [0]  = 27,   /** @brief IV100 */
      [1]  = 26,   /** @brief IV101 */
      [2]  = 25,   /** @brief IV102 */
      [3]  = 24,   /** @brief IV103 */
      [4]  = 23,   /** @brief IV104 */
      [5]  = 22,   /** @brief IV105 */
      [6]  = 21,   /** @brief IV106 */
      [7]  = 20,   /** @brief IV107 */
      [8]  = 19,   /** @brief IV108 */
      [9]  = 18,   /** @brief IV109 */
      [10] = 17,   /** @brief IV110 */
      [11] = 16,   /** @brief IV111 */
      [12] = 15,   /** @brief IV112 */
      [13] = 14,   /** @brief IV113 */
      [14] = 13,   /** @brief IV114 */
      [15] = 12,   /** @brief IV115 */
      [16] = 11,   /** @brief IV116 */
      [17] = 10,   /** @brief IV117 */
      [18] = 9,    /** @brief IV118 */
      [19] = 8,    /** @brief IV119 */
      [27] = 0,    /** @brief IV127 */
    };

    static const int32_t CRYP_IV1RR_IV12x_POS[8] = {
      [0] = 7,   /** @brief IV120 */
      [1] = 6,   /** @brief IV121 */
      [2] = 5,   /** @brief IV122 */
      [3] = 4,   /** @brief IV123 */
      [4] = 3,   /** @brief IV124 */
      [5] = 2,   /** @brief IV125 */
      [6] = 1,   /** @brief IV126 */
    };

    /**********************************************************************************************
     * @section DCMI Register Information
     **********************************************************************************************/

    /**** @subsection DCMI Register Pointers ****/

    static RW_ uint32_t* const DCMI_CR_PTR       = (RW_ uint32_t* const)0x48020000U;   /** @brief Control register 1 */
    static RO_ uint32_t* const DCMI_SR_PTR       = (RO_ uint32_t* const)0x48020004U;   /** @brief Status register */
    static RO_ uint32_t* const DCMI_RIS_PTR      = (RO_ uint32_t* const)0x48020008U;   /** @brief Raw interrupt status register */
    static RW_ uint32_t* const DCMI_IER_PTR      = (RW_ uint32_t* const)0x4802000CU;   /** @brief Interrupt enable register */
    static RO_ uint32_t* const DCMI_MIS_PTR      = (RO_ uint32_t* const)0x48020010U;   /** @brief Masked interrupt status register */
    static RW_ uint32_t* const DCMI_ICR_PTR      = (RW_ uint32_t* const)0x48020014U;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const DCMI_ESCR_PTR     = (RW_ uint32_t* const)0x48020018U;   /** @brief Embedded synchronization code register */
    static RW_ uint32_t* const DCMI_ESUR_PTR     = (RW_ uint32_t* const)0x4802001CU;   /** @brief Embedded synchronization unmask register */
    static RW_ uint32_t* const DCMI_CWSTRT_PTR   = (RW_ uint32_t* const)0x48020020U;   /** @brief Crop window start */
    static RW_ uint32_t* const DCMI_CWSIZE_PTR   = (RW_ uint32_t* const)0x48020024U;   /** @brief Crop window size */
    static RO_ uint32_t* const DCMI_DR_PTR       = (RO_ uint32_t* const)0x48020028U;   /** @brief Data register */

    /**** @subsection DCMI Register Reset Values ****/

    static const uint32_t DCMI_CR_RST       = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t DCMI_SR_RST       = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t DCMI_RIS_RST      = 0x00000000U;   /** @brief RIS register reset value. */
    static const uint32_t DCMI_IER_RST      = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t DCMI_MIS_RST      = 0x00000000U;   /** @brief MIS register reset value. */
    static const uint32_t DCMI_ICR_RST      = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t DCMI_ESCR_RST     = 0x00000000U;   /** @brief ESCR register reset value. */
    static const uint32_t DCMI_ESUR_RST     = 0x00000000U;   /** @brief ESUR register reset value. */
    static const uint32_t DCMI_CWSTRT_RST   = 0x00000000U;   /** @brief CWSTRT register reset value. */
    static const uint32_t DCMI_CWSIZE_RST   = 0x00000000U;   /** @brief CWSIZE register reset value. */
    static const uint32_t DCMI_DR_RST       = 0x00000000U;   /** @brief DR register reset value. */

    /**** @subsection Enumerated DCMI Register Value Types ****/

    typedef uint32_t DCMI_CR_t;       /** @brief CR register value type. */
    typedef uint32_t DCMI_SR_t;       /** @brief SR register value type. */
    typedef uint32_t DCMI_RIS_t;      /** @brief RIS register value type. */
    typedef uint32_t DCMI_IER_t;      /** @brief IER register value type. */
    typedef uint32_t DCMI_MIS_t;      /** @brief MIS register value type. */
    typedef uint32_t DCMI_ICR_t;      /** @brief ICR register value type. */
    typedef uint32_t DCMI_ESCR_t;     /** @brief ESCR register value type. */
    typedef uint32_t DCMI_ESUR_t;     /** @brief ESUR register value type. */
    typedef uint32_t DCMI_CWSTRT_t;   /** @brief CWSTRT register value type. */
    typedef uint32_t DCMI_CWSIZE_t;   /** @brief CWSIZE register value type. */
    typedef uint32_t DCMI_DR_t;       /** @brief DR register value type. */

    /**** @subsection Enumerated DCMI Register Pointer Types ****/

    typedef uint32_t* const DCMI_CR_PTR_t;       /** @brief CR register pointer type. */
    typedef uint32_t* const DCMI_SR_PTR_t;       /** @brief SR register pointer type. */
    typedef uint32_t* const DCMI_RIS_PTR_t;      /** @brief RIS register pointer type. */
    typedef uint32_t* const DCMI_IER_PTR_t;      /** @brief IER register pointer type. */
    typedef uint32_t* const DCMI_MIS_PTR_t;      /** @brief MIS register pointer type. */
    typedef uint32_t* const DCMI_ICR_PTR_t;      /** @brief ICR register pointer type. */
    typedef uint32_t* const DCMI_ESCR_PTR_t;     /** @brief ESCR register pointer type. */
    typedef uint32_t* const DCMI_ESUR_PTR_t;     /** @brief ESUR register pointer type. */
    typedef uint32_t* const DCMI_CWSTRT_PTR_t;   /** @brief CWSTRT register pointer type. */
    typedef uint32_t* const DCMI_CWSIZE_PTR_t;   /** @brief CWSIZE register pointer type. */
    typedef uint32_t* const DCMI_DR_PTR_t;       /** @brief DR register pointer type. */

    /**** @subsection DCMI Register Field Masks ****/

    static const uint32_t DCMI_CR_OELS_MASK          = 0x00100000U;   /** @brief Odd/Even line select (line select start) */
    static const uint32_t DCMI_CR_LSM_MASK           = 0x00080000U;   /** @brief Line select mode */
    static const uint32_t DCMI_CR_OEBS_MASK          = 0x00040000U;   /** @brief Odd/Even byte select (byte select start) */
    static const uint32_t DCMI_CR_BSM_MASK           = 0x00030000U;   /** @brief Byte select mode */
    static const uint32_t DCMI_CR_ENABLE_MASK        = 0x00004000U;   /** @brief DCMI enable */
    static const uint32_t DCMI_CR_EDM_MASK           = 0x00000C00U;   /** @brief Extended data mode */
    static const uint32_t DCMI_CR_FCRC_MASK          = 0x00000300U;   /** @brief Frame capture rate control */
    static const uint32_t DCMI_CR_VSPOL_MASK         = 0x00000080U;   /** @brief Vertical synchronization polarity */
    static const uint32_t DCMI_CR_HSPOL_MASK         = 0x00000040U;   /** @brief Horizontal synchronization polarity */
    static const uint32_t DCMI_CR_PCKPOL_MASK        = 0x00000020U;   /** @brief Pixel clock polarity */
    static const uint32_t DCMI_CR_ESS_MASK           = 0x00000010U;   /** @brief Embedded synchronization select */
    static const uint32_t DCMI_CR_JPEG_MASK          = 0x00000008U;   /** @brief JPEG format */
    static const uint32_t DCMI_CR_CROP_MASK          = 0x00000004U;   /** @brief Crop feature */
    static const uint32_t DCMI_CR_CM_MASK            = 0x00000002U;   /** @brief Capture mode */
    static const uint32_t DCMI_CR_CAPTURE_MASK       = 0x00000001U;   /** @brief Capture enable */
    static const uint32_t DCMI_SR_FNE_MASK           = 0x00000004U;   /** @brief FIFO not empty */
    static const uint32_t DCMI_SR_VSYNC_MASK         = 0x00000002U;   /** @brief VSYNC */
    static const uint32_t DCMI_SR_HSYNC_MASK         = 0x00000001U;   /** @brief HSYNC */
    static const uint32_t DCMI_RIS_LINE_RIS_MASK     = 0x00000010U;   /** @brief Line raw interrupt status */
    static const uint32_t DCMI_RIS_VSYNC_RIS_MASK    = 0x00000008U;   /** @brief VSYNC raw interrupt status */
    static const uint32_t DCMI_RIS_ERR_RIS_MASK      = 0x00000004U;   /** @brief Synchronization error raw interrupt status */
    static const uint32_t DCMI_RIS_OVR_RIS_MASK      = 0x00000002U;   /** @brief Overrun raw interrupt status */
    static const uint32_t DCMI_RIS_FRAME_RIS_MASK    = 0x00000001U;   /** @brief Capture complete raw interrupt status */
    static const uint32_t DCMI_IER_LINE_IE_MASK      = 0x00000010U;   /** @brief Line interrupt enable */
    static const uint32_t DCMI_IER_VSYNC_IE_MASK     = 0x00000008U;   /** @brief VSYNC interrupt enable */
    static const uint32_t DCMI_IER_ERR_IE_MASK       = 0x00000004U;   /** @brief Synchronization error interrupt enable */
    static const uint32_t DCMI_IER_OVR_IE_MASK       = 0x00000002U;   /** @brief Overrun interrupt enable */
    static const uint32_t DCMI_IER_FRAME_IE_MASK     = 0x00000001U;   /** @brief Capture complete interrupt enable */
    static const uint32_t DCMI_MIS_LINE_MIS_MASK     = 0x00000010U;   /** @brief Line masked interrupt status */
    static const uint32_t DCMI_MIS_VSYNC_MIS_MASK    = 0x00000008U;   /** @brief VSYNC masked interrupt status */
    static const uint32_t DCMI_MIS_ERR_MIS_MASK      = 0x00000004U;   /** @brief Synchronization error masked interrupt status */
    static const uint32_t DCMI_MIS_OVR_MIS_MASK      = 0x00000002U;   /** @brief Overrun masked interrupt status */
    static const uint32_t DCMI_MIS_FRAME_MIS_MASK    = 0x00000001U;   /** @brief Capture complete masked interrupt status */
    static const uint32_t DCMI_ICR_LINE_ISC_MASK     = 0x00000010U;   /** @brief Line interrupt status clear */
    static const uint32_t DCMI_ICR_VSYNC_ISC_MASK    = 0x00000008U;   /** @brief Vertical synch interrupt status clear */
    static const uint32_t DCMI_ICR_ERR_ISC_MASK      = 0x00000004U;   /** @brief Synchronization error interrupt status clear */
    static const uint32_t DCMI_ICR_OVR_ISC_MASK      = 0x00000002U;   /** @brief Overrun interrupt status clear */
    static const uint32_t DCMI_ICR_FRAME_ISC_MASK    = 0x00000001U;   /** @brief Capture complete interrupt status clear */
    static const uint32_t DCMI_ESCR_FEC_MASK         = 0xFF000000U;   /** @brief Frame end delimiter code */
    static const uint32_t DCMI_ESCR_LEC_MASK         = 0x00FF0000U;   /** @brief Line end delimiter code */
    static const uint32_t DCMI_ESCR_LSC_MASK         = 0x0000FF00U;   /** @brief Line start delimiter code */
    static const uint32_t DCMI_ESCR_FSC_MASK         = 0x000000FFU;   /** @brief Frame start delimiter code */
    static const uint32_t DCMI_ESUR_FEU_MASK         = 0xFF000000U;   /** @brief Frame end delimiter unmask */
    static const uint32_t DCMI_ESUR_LEU_MASK         = 0x00FF0000U;   /** @brief Line end delimiter unmask */
    static const uint32_t DCMI_ESUR_LSU_MASK         = 0x0000FF00U;   /** @brief Line start delimiter unmask */
    static const uint32_t DCMI_ESUR_FSU_MASK         = 0x000000FFU;   /** @brief Frame start delimiter unmask */
    static const uint32_t DCMI_CWSTRT_VST_MASK       = 0x1FFF0000U;   /** @brief Vertical start line count */
    static const uint32_t DCMI_CWSTRT_HOFFCNT_MASK   = 0x00003FFFU;   /** @brief Horizontal offset count */
    static const uint32_t DCMI_CWSIZE_VLINE_MASK     = 0x3FFF0000U;   /** @brief Vertical line count */
    static const uint32_t DCMI_CWSIZE_CAPCNT_MASK    = 0x00003FFFU;   /** @brief Capture count */

    /**** @subsection Enumerated DCMI Register Field Masks ****/

    static const uint32_t DCMI_DR_BYTEx_MASK[4] = {
      [0] = 0x000000FFU,   /** @brief Data byte 0 */
      [1] = 0x0000FF00U,   /** @brief Data byte 1 */
      [2] = 0x00FF0000U,   /** @brief Data byte 2 */
      [3] = 0xFF000000U,   /** @brief Data byte 3 */
    };

    /**** @subsection DCMI Register Field Positions ****/

    static const int32_t DCMI_CR_OELS_POS          = 20;   /** @brief Odd/Even line select (line select start) */
    static const int32_t DCMI_CR_LSM_POS           = 19;   /** @brief Line select mode */
    static const int32_t DCMI_CR_OEBS_POS          = 18;   /** @brief Odd/Even byte select (byte select start) */
    static const int32_t DCMI_CR_BSM_POS           = 16;   /** @brief Byte select mode */
    static const int32_t DCMI_CR_ENABLE_POS        = 14;   /** @brief DCMI enable */
    static const int32_t DCMI_CR_EDM_POS           = 10;   /** @brief Extended data mode */
    static const int32_t DCMI_CR_FCRC_POS          = 8;    /** @brief Frame capture rate control */
    static const int32_t DCMI_CR_VSPOL_POS         = 7;    /** @brief Vertical synchronization polarity */
    static const int32_t DCMI_CR_HSPOL_POS         = 6;    /** @brief Horizontal synchronization polarity */
    static const int32_t DCMI_CR_PCKPOL_POS        = 5;    /** @brief Pixel clock polarity */
    static const int32_t DCMI_CR_ESS_POS           = 4;    /** @brief Embedded synchronization select */
    static const int32_t DCMI_CR_JPEG_POS          = 3;    /** @brief JPEG format */
    static const int32_t DCMI_CR_CROP_POS          = 2;    /** @brief Crop feature */
    static const int32_t DCMI_CR_CM_POS            = 1;    /** @brief Capture mode */
    static const int32_t DCMI_CR_CAPTURE_POS       = 0;    /** @brief Capture enable */
    static const int32_t DCMI_SR_FNE_POS           = 2;    /** @brief FIFO not empty */
    static const int32_t DCMI_SR_VSYNC_POS         = 1;    /** @brief VSYNC */
    static const int32_t DCMI_SR_HSYNC_POS         = 0;    /** @brief HSYNC */
    static const int32_t DCMI_RIS_LINE_RIS_POS     = 4;    /** @brief Line raw interrupt status */
    static const int32_t DCMI_RIS_VSYNC_RIS_POS    = 3;    /** @brief VSYNC raw interrupt status */
    static const int32_t DCMI_RIS_ERR_RIS_POS      = 2;    /** @brief Synchronization error raw interrupt status */
    static const int32_t DCMI_RIS_OVR_RIS_POS      = 1;    /** @brief Overrun raw interrupt status */
    static const int32_t DCMI_RIS_FRAME_RIS_POS    = 0;    /** @brief Capture complete raw interrupt status */
    static const int32_t DCMI_IER_LINE_IE_POS      = 4;    /** @brief Line interrupt enable */
    static const int32_t DCMI_IER_VSYNC_IE_POS     = 3;    /** @brief VSYNC interrupt enable */
    static const int32_t DCMI_IER_ERR_IE_POS       = 2;    /** @brief Synchronization error interrupt enable */
    static const int32_t DCMI_IER_OVR_IE_POS       = 1;    /** @brief Overrun interrupt enable */
    static const int32_t DCMI_IER_FRAME_IE_POS     = 0;    /** @brief Capture complete interrupt enable */
    static const int32_t DCMI_MIS_LINE_MIS_POS     = 4;    /** @brief Line masked interrupt status */
    static const int32_t DCMI_MIS_VSYNC_MIS_POS    = 3;    /** @brief VSYNC masked interrupt status */
    static const int32_t DCMI_MIS_ERR_MIS_POS      = 2;    /** @brief Synchronization error masked interrupt status */
    static const int32_t DCMI_MIS_OVR_MIS_POS      = 1;    /** @brief Overrun masked interrupt status */
    static const int32_t DCMI_MIS_FRAME_MIS_POS    = 0;    /** @brief Capture complete masked interrupt status */
    static const int32_t DCMI_ICR_LINE_ISC_POS     = 4;    /** @brief Line interrupt status clear */
    static const int32_t DCMI_ICR_VSYNC_ISC_POS    = 3;    /** @brief Vertical synch interrupt status clear */
    static const int32_t DCMI_ICR_ERR_ISC_POS      = 2;    /** @brief Synchronization error interrupt status clear */
    static const int32_t DCMI_ICR_OVR_ISC_POS      = 1;    /** @brief Overrun interrupt status clear */
    static const int32_t DCMI_ICR_FRAME_ISC_POS    = 0;    /** @brief Capture complete interrupt status clear */
    static const int32_t DCMI_ESCR_FEC_POS         = 24;   /** @brief Frame end delimiter code */
    static const int32_t DCMI_ESCR_LEC_POS         = 16;   /** @brief Line end delimiter code */
    static const int32_t DCMI_ESCR_LSC_POS         = 8;    /** @brief Line start delimiter code */
    static const int32_t DCMI_ESCR_FSC_POS         = 0;    /** @brief Frame start delimiter code */
    static const int32_t DCMI_ESUR_FEU_POS         = 24;   /** @brief Frame end delimiter unmask */
    static const int32_t DCMI_ESUR_LEU_POS         = 16;   /** @brief Line end delimiter unmask */
    static const int32_t DCMI_ESUR_LSU_POS         = 8;    /** @brief Line start delimiter unmask */
    static const int32_t DCMI_ESUR_FSU_POS         = 0;    /** @brief Frame start delimiter unmask */
    static const int32_t DCMI_CWSTRT_VST_POS       = 16;   /** @brief Vertical start line count */
    static const int32_t DCMI_CWSTRT_HOFFCNT_POS   = 0;    /** @brief Horizontal offset count */
    static const int32_t DCMI_CWSIZE_VLINE_POS     = 16;   /** @brief Vertical line count */
    static const int32_t DCMI_CWSIZE_CAPCNT_POS    = 0;    /** @brief Capture count */

    /**** @subsection Enumerated DCMI Register Field Positions ****/

    static const int32_t DCMI_DR_BYTEx_POS[4] = {
      [0] = 0,    /** @brief Data byte 0 */
      [1] = 8,    /** @brief Data byte 1 */
      [2] = 16,   /** @brief Data byte 2 */
      [3] = 24,   /** @brief Data byte 3 */
    };

    /**********************************************************************************************
     * @section OTG1_HS_GLOBAL Register Information
     **********************************************************************************************/

    /**** @subsection OTG1_HS_GLOBAL Register Pointers ****/

    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_PTR           = (RW_ uint32_t* const)0x40040000U;   /** @brief OTG_HS control and status register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GOTGINT_PTR           = (RW_ uint32_t* const)0x40040004U;   /** @brief OTG_HS interrupt register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_PTR           = (RW_ uint32_t* const)0x40040008U;   /** @brief OTG_HS AHB configuration register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PTR           = (RW_ uint32_t* const)0x4004000CU;   /** @brief OTG_HS USB configuration register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_PTR           = (RW_ uint32_t* const)0x40040010U;   /** @brief OTG_HS reset register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PTR           = (RW_ uint32_t* const)0x40040014U;   /** @brief OTG_HS core interrupt register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PTR           = (RW_ uint32_t* const)0x40040018U;   /** @brief OTG_HS interrupt mask register */
    static RO_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PTR      = (RO_ uint32_t* const)0x4004001CU;   /** @brief OTG_HS receive status debug read register (host mode) */
    static RO_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PTR      = (RO_ uint32_t* const)0x40040020U;   /** @brief OTG_HS status read and pop register (host mode) */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_PTR           = (RW_ uint32_t* const)0x40040024U;   /** @brief OTG_HS receive FIFO size register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_PTR    = (RW_ uint32_t* const)0x40040028U;   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_PTR   = (RW_ uint32_t* const)0x40040028U;   /** @brief Endpoint 0 transmit FIFO size (peripheral mode) */
    static RO_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_PTR          = (RO_ uint32_t* const)0x4004002CU;   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GCCFG_PTR             = (RW_ uint32_t* const)0x40040038U;   /** @brief OTG_HS general core configuration register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_CID_PTR               = (RW_ uint32_t* const)0x4004003CU;   /** @brief OTG_HS core ID register */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTR          = (RW_ uint32_t* const)0x40040100U;   /** @brief OTG_HS host periodic transmit FIFO size register */
    static RO_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PTR    = (RO_ uint32_t* const)0x4004001CU;   /** @brief OTG_HS receive status debug read register (peripheral mode mode) */
    static RO_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PTR    = (RO_ uint32_t* const)0x40040020U;   /** @brief OTG_HS status read and pop register (peripheral mode) */
    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_PTR           = (RW_ uint32_t* const)0x40040054U;   /** @brief OTG core LPM configuration register */

    /**** @subsection Enumerated OTG1_HS_GLOBAL Register Pointers ****/

    static RW_ uint32_t* const OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_PTR[8] = {
      [1] = (RW_ uint32_t* const)0x40040104U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [2] = (RW_ uint32_t* const)0x40040108U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [3] = (RW_ uint32_t* const)0x4004011CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [4] = (RW_ uint32_t* const)0x40040120U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [5] = (RW_ uint32_t* const)0x40040124U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [6] = (RW_ uint32_t* const)0x40040128U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [7] = (RW_ uint32_t* const)0x4004012CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
    };

    /**** @subsection OTG1_HS_GLOBAL Register Reset Values ****/

    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_RST           = 0x00000800U;   /** @brief OTG_HS_GOTGCTL register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_RST           = 0x00000000U;   /** @brief OTG_HS_GOTGINT register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_RST           = 0x00000000U;   /** @brief OTG_HS_GAHBCFG register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_RST           = 0x00000A00U;   /** @brief OTG_HS_GUSBCFG register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_RST           = 0x20000000U;   /** @brief OTG_HS_GRSTCTL register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_RST           = 0x04000020U;   /** @brief OTG_HS_GINTSTS register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RST           = 0x00000000U;   /** @brief OTG_HS_GINTMSK register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_RST      = 0x00000000U;   /** @brief OTG_HS_GRXSTSR_HOST register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_RST      = 0x00000000U;   /** @brief OTG_HS_GRXSTSP_HOST register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_RST           = 0x00000200U;   /** @brief OTG_HS_GRXFSIZ register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_RST    = 0x00000200U;   /** @brief OTG_HS_HNPTXFSIZ_HOST register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_RST   = 0x00000200U;   /** @brief OTG_HS_DIEPTXF0_DEVICE register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_RST          = 0x00080200U;   /** @brief OTG_HS_GNPTXSTS register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_RST             = 0x00000000U;   /** @brief OTG_HS_GCCFG register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_CID_RST               = 0x00001200U;   /** @brief OTG_HS_CID register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_RST          = 0x02000600U;   /** @brief OTG_HS_HPTXFSIZ register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_RST    = 0x00000000U;   /** @brief OTG_HS_GRXSTSR_DEVICE register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_RST    = 0x00000000U;   /** @brief OTG_HS_GRXSTSP_DEVICE register reset value. */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_RST           = 0x00000000U;   /** @brief OTG_HS_GLPMCFG register reset value. */

    /**** @subsection Enumerated OTG1_HS_GLOBAL Register Reset Values ****/

    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_RST[8] = {
      [1] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF1 register reset value. */
      [2] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF2 register reset value. */
      [3] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF3 register reset value. */
      [4] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF4 register reset value. */
      [5] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF5 register reset value. */
      [6] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF6 register reset value. */
      [7] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF7 register reset value. */
    };

    /**** @subsection Enumerated OTG1_HS_GLOBAL Register Value Types ****/

    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_t;           /** @brief OTG_HS_GOTGCTL register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_t;           /** @brief OTG_HS_GOTGINT register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_t;           /** @brief OTG_HS_GAHBCFG register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_t;           /** @brief OTG_HS_GUSBCFG register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_t;           /** @brief OTG_HS_GRSTCTL register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_t;           /** @brief OTG_HS_GINTSTS register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_t;           /** @brief OTG_HS_GINTMSK register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_t;      /** @brief OTG_HS_GRXSTSR_HOST register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_t;      /** @brief OTG_HS_GRXSTSP_HOST register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_t;           /** @brief OTG_HS_GRXFSIZ register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_t;    /** @brief OTG_HS_HNPTXFSIZ_HOST register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_t;   /** @brief OTG_HS_DIEPTXF0_DEVICE register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_t;          /** @brief OTG_HS_GNPTXSTS register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_t;             /** @brief OTG_HS_GCCFG register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_CID_t;               /** @brief OTG_HS_CID register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_t;          /** @brief OTG_HS_HPTXFSIZ register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_t;          /** @brief OTG_HS_DIEPTXFx register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_t;    /** @brief OTG_HS_GRXSTSR_DEVICE register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_t;    /** @brief OTG_HS_GRXSTSP_DEVICE register value type. */
    typedef uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_t;           /** @brief OTG_HS_GLPMCFG register value type. */

    /**** @subsection Enumerated OTG1_HS_GLOBAL Register Pointer Types ****/

    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_PTR_t;           /** @brief OTG_HS_GOTGCTL register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GOTGINT_PTR_t;           /** @brief OTG_HS_GOTGINT register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_PTR_t;           /** @brief OTG_HS_GAHBCFG register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PTR_t;           /** @brief OTG_HS_GUSBCFG register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_PTR_t;           /** @brief OTG_HS_GRSTCTL register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PTR_t;           /** @brief OTG_HS_GINTSTS register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PTR_t;           /** @brief OTG_HS_GINTMSK register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PTR_t;      /** @brief OTG_HS_GRXSTSR_HOST register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PTR_t;      /** @brief OTG_HS_GRXSTSP_HOST register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_PTR_t;           /** @brief OTG_HS_GRXFSIZ register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_PTR_t;    /** @brief OTG_HS_HNPTXFSIZ_HOST register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_PTR_t;   /** @brief OTG_HS_DIEPTXF0_DEVICE register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_PTR_t;          /** @brief OTG_HS_GNPTXSTS register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GCCFG_PTR_t;             /** @brief OTG_HS_GCCFG register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_CID_PTR_t;               /** @brief OTG_HS_CID register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTR_t;          /** @brief OTG_HS_HPTXFSIZ register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_PTR_t;          /** @brief OTG_HS_DIEPTXFx register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PTR_t;    /** @brief OTG_HS_GRXSTSR_DEVICE register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PTR_t;    /** @brief OTG_HS_GRXSTSP_DEVICE register pointer type. */
    typedef uint32_t* const OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_PTR_t;           /** @brief OTG_HS_GLPMCFG register pointer type. */

    /**** @subsection OTG1_HS_GLOBAL Register Field Masks ****/

    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS_MASK              = 0x00000001U;   /** @brief Session request success */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ_MASK                 = 0x00000002U;   /** @brief Session request */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS_MASK              = 0x00000100U;   /** @brief Host negotiation success */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ_MASK               = 0x00000200U;   /** @brief HNP request */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN_MASK             = 0x00000400U;   /** @brief Host set HNP enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN_MASK              = 0x00000800U;   /** @brief Device HNP enabled */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS_MASK              = 0x00010000U;   /** @brief Connector ID status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT_MASK                = 0x00020000U;   /** @brief Long/short debounce time */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD_MASK               = 0x00040000U;   /** @brief A-session valid */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD_MASK               = 0x00080000U;   /** @brief B-session valid */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN_MASK                = 0x00001000U;   /** @brief Embedded host enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SEDET_MASK               = 0x00000004U;   /** @brief Session end detected */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG_MASK             = 0x00000100U;   /** @brief Session request success status change */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG_MASK             = 0x00000200U;   /** @brief Host negotiation success status change */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET_MASK              = 0x00020000U;   /** @brief Host negotiation detected */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG_MASK             = 0x00040000U;   /** @brief A-device timeout change */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE_MASK              = 0x00080000U;   /** @brief Debounce done */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG_MASK              = 0x00100000U;   /** @brief ID input pin changed */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_GINT_MASK                = 0x00000001U;   /** @brief Global interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_MASK             = 0x0000001EU;   /** @brief Burst length/type */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN_MASK               = 0x00000020U;   /** @brief DMA enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL_MASK             = 0x00000080U;   /** @brief TxFIFO empty level */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL_MASK            = 0x00000100U;   /** @brief Periodic txfifo empty level */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_MASK               = 0x00000007U;   /** @brief FS timeout calibration */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL_MASK              = 0x00000040U;   /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP_MASK              = 0x00000100U;   /** @brief SRP-capable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP_MASK              = 0x00000200U;   /** @brief HNP-capable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_MASK                = 0x00003C00U;   /** @brief USB turnaround time */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS_MASK             = 0x00008000U;   /** @brief PHY low-power clock select */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS_MASK            = 0x00020000U;   /** @brief ULPI FS/LS select */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR_MASK              = 0x00040000U;   /** @brief ULPI auto-resume */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM_MASK             = 0x00080000U;   /** @brief ULPI clock suspendm */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD_MASK          = 0x00100000U;   /** @brief ULPI external VBUS drive */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI_MASK          = 0x00200000U;   /** @brief ULPI external VBUS indicator */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS_MASK               = 0x00400000U;   /** @brief TermSel dline pulsing selection */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI_MASK                = 0x00800000U;   /** @brief Indicator complement */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI_MASK                = 0x01000000U;   /** @brief Indicator pass through */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD_MASK             = 0x02000000U;   /** @brief ULPI interface protect disable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD_MASK               = 0x20000000U;   /** @brief Forced host mode */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD_MASK               = 0x40000000U;   /** @brief Forced peripheral mode */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST_MASK               = 0x00000001U;   /** @brief Core soft reset */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST_MASK               = 0x00000002U;   /** @brief HCLK soft reset */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST_MASK               = 0x00000004U;   /** @brief Host frame counter reset */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH_MASK             = 0x00000010U;   /** @brief RxFIFO flush */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH_MASK             = 0x00000020U;   /** @brief TxFIFO flush */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_MASK              = 0x000007C0U;   /** @brief TxFIFO number */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL_MASK              = 0x80000000U;   /** @brief AHB master idle */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ_MASK              = 0x40000000U;   /** @brief DMA request signal enabled for USB OTG HS */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CMOD_MASK                = 0x00000001U;   /** @brief Current mode of operation */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_MMIS_MASK                = 0x00000002U;   /** @brief Mode mismatch interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT_MASK              = 0x00000004U;   /** @brief OTG interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SOF_MASK                 = 0x00000008U;   /** @brief Start of frame */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL_MASK              = 0x00000010U;   /** @brief RxFIFO nonempty */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE_MASK              = 0x00000020U;   /** @brief Nonperiodic txfifo empty */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF_MASK            = 0x00000040U;   /** @brief Global IN nonperiodic NAK effective */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF_MASK          = 0x00000080U;   /** @brief Global OUT NAK effective */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP_MASK               = 0x00000400U;   /** @brief Early suspend */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP_MASK             = 0x00000800U;   /** @brief USB suspend */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBRST_MASK              = 0x00001000U;   /** @brief USB reset */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE_MASK             = 0x00002000U;   /** @brief Enumeration done */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP_MASK             = 0x00004000U;   /** @brief Isochronous OUT packet dropped interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_EOPF_MASK                = 0x00008000U;   /** @brief End of periodic frame interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT_MASK              = 0x00040000U;   /** @brief IN endpoint interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT_MASK              = 0x00080000U;   /** @brief OUT endpoint interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR_MASK            = 0x00100000U;   /** @brief Incomplete isochronous IN transfer */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_MASK   = 0x00200000U;   /** @brief Incomplete periodic transfer */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP_MASK           = 0x00400000U;   /** @brief Data fetch suspended */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT_MASK             = 0x01000000U;   /** @brief Host port interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HCINT_MASK               = 0x02000000U;   /** @brief Host channels interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE_MASK               = 0x04000000U;   /** @brief Periodic txfifo empty */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG_MASK             = 0x10000000U;   /** @brief Connector ID status change */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT_MASK             = 0x20000000U;   /** @brief Disconnect detected interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT_MASK              = 0x40000000U;   /** @brief Session request/new session detected interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT_MASK              = 0x80000000U;   /** @brief Resume/remote wakeup detected interrupt */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_MMISM_MASK               = 0x00000002U;   /** @brief Mode mismatch interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT_MASK              = 0x00000004U;   /** @brief OTG interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SOFM_MASK                = 0x00000008U;   /** @brief Start of frame mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM_MASK             = 0x00000010U;   /** @brief Receive FIFO nonempty mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM_MASK             = 0x00000020U;   /** @brief Nonperiodic txfifo empty mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM_MASK           = 0x00000040U;   /** @brief Global nonperiodic IN NAK effective mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM_MASK           = 0x00000080U;   /** @brief Global OUT NAK effective mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM_MASK              = 0x00000400U;   /** @brief Early suspend mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM_MASK            = 0x00000800U;   /** @brief USB suspend mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBRST_MASK              = 0x00001000U;   /** @brief USB reset mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM_MASK            = 0x00002000U;   /** @brief Enumeration done mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM_MASK            = 0x00004000U;   /** @brief Isochronous OUT packet dropped interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM_MASK               = 0x00008000U;   /** @brief End of periodic frame interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT_MASK              = 0x00040000U;   /** @brief IN endpoints interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT_MASK              = 0x00080000U;   /** @brief OUT endpoints interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM_MASK           = 0x00100000U;   /** @brief Incomplete isochronous IN transfer mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_MASK     = 0x00200000U;   /** @brief Incomplete periodic transfer mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM_MASK              = 0x00400000U;   /** @brief Data fetch suspended mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM_MASK               = 0x01000000U;   /** @brief Host port interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_HCIM_MASK                = 0x02000000U;   /** @brief Host channels interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM_MASK              = 0x04000000U;   /** @brief Periodic txfifo empty mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM_MASK            = 0x10000000U;   /** @brief Connector ID status change mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT_MASK             = 0x20000000U;   /** @brief Disconnect detected interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM_MASK               = 0x40000000U;   /** @brief Session request/new session detected interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_WUIM_MASK                = 0x80000000U;   /** @brief Resume/remote wakeup detected interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE_MASK               = 0x00800000U;   /** @brief Reset detected interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM_MASK             = 0x08000000U;   /** @brief LPM interrupt mask */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM_MASK          = 0x0000000FU;   /** @brief Channel number */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT_MASK           = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID_MASK           = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS_MASK         = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM_MASK          = 0x0000000FU;   /** @brief Channel number */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT_MASK           = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID_MASK           = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS_MASK         = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_MASK                = 0x0000FFFFU;   /** @brief RxFIFO depth */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA_MASK      = 0x0000FFFFU;   /** @brief Nonperiodic transmit RAM start address */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD_MASK       = 0xFFFF0000U;   /** @brief Nonperiodic txfifo depth */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FSA_MASK      = 0x0000FFFFU;   /** @brief Endpoint 0 transmit RAM start address */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD_MASK       = 0xFFFF0000U;   /** @brief Endpoint 0 txfifo depth */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_MASK           = 0x0000FFFFU;   /** @brief Nonperiodic txfifo space available */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_MASK           = 0x00FF0000U;   /** @brief Nonperiodic transmit request queue space available */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_MASK           = 0x7F000000U;   /** @brief Top of the nonperiodic transmit request queue */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN_MASK                = 0x00010000U;   /** @brief Power down */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_BCDEN_MASK                 = 0x00020000U;   /** @brief Battery charging detector (BCD) enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDEN_MASK                 = 0x00040000U;   /** @brief Data contact detection (DCD) mode enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDEN_MASK                  = 0x00080000U;   /** @brief Primary detection (PD) mode enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDEN_MASK                  = 0x00100000U;   /** @brief Secondary detection (SD) mode enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_VBDEN_MASK                 = 0x00200000U;   /** @brief USB VBUS detection enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDET_MASK                 = 0x00000001U;   /** @brief Data contact detection (DCD) status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDET_MASK                  = 0x00000002U;   /** @brief Primary detection (PD) status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDET_MASK                  = 0x00000004U;   /** @brief Secondary detection (SD) status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PS2DET_MASK                = 0x00000008U;   /** @brief DM pull-up detection status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_MASK              = 0x0000FFFFU;   /** @brief Host periodic txfifo start address */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_MASK              = 0xFFFF0000U;   /** @brief Host periodic txfifo depth */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXSA_MASK           = 0x0000FFFFU;   /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD_MASK           = 0xFFFF0000U;   /** @brief IN endpoint txfifo depth */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_EPNUM_MASK        = 0x0000000FU;   /** @brief Endpoint number */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_BCNT_MASK         = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_DPID_MASK         = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PKTSTS_MASK       = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM_MASK       = 0x01E00000U;   /** @brief Frame number */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_EPNUM_MASK        = 0x0000000FU;   /** @brief Endpoint number */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_BCNT_MASK         = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_DPID_MASK         = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PKTSTS_MASK       = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM_MASK       = 0x01E00000U;   /** @brief Frame number */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN_MASK               = 0x00000001U;   /** @brief LPM support enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK_MASK              = 0x00000002U;   /** @brief LPM token acknowledge enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_MASK                = 0x0000003CU;   /** @brief Best effort service latency */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE_MASK             = 0x00000040U;   /** @brief BRemoteWake value */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN_MASK              = 0x00000080U;   /** @brief L1 shallow sleep enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_MASK            = 0x00000F00U;   /** @brief BESL threshold */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN_MASK              = 0x00001000U;   /** @brief L1 deep sleep enable */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_MASK              = 0x00006000U;   /** @brief LPM response */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS_MASK              = 0x00008000U;   /** @brief Port sleep status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK_MASK             = 0x00010000U;   /** @brief Sleep state resume OK */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_MASK            = 0x001E0000U;   /** @brief LPM channel index */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_MASK             = 0x00E00000U;   /** @brief LPM retry count */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM_MASK              = 0x01000000U;   /** @brief Send LPM transaction */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_MASK          = 0x0E000000U;   /** @brief LPM retry count status */
    static const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL_MASK              = 0x10000000U;   /** @brief Enable best effort service latency */

    /**** @subsection OTG1_HS_GLOBAL Register Field Positions ****/

    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS_POS              = 0;    /** @brief Session request success */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ_POS                 = 1;    /** @brief Session request */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS_POS              = 8;    /** @brief Host negotiation success */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ_POS               = 9;    /** @brief HNP request */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN_POS             = 10;   /** @brief Host set HNP enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN_POS              = 11;   /** @brief Device HNP enabled */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS_POS              = 16;   /** @brief Connector ID status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT_POS                = 17;   /** @brief Long/short debounce time */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD_POS               = 18;   /** @brief A-session valid */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD_POS               = 19;   /** @brief B-session valid */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN_POS                = 12;   /** @brief Embedded host enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SEDET_POS               = 2;    /** @brief Session end detected */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG_POS             = 8;    /** @brief Session request success status change */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG_POS             = 9;    /** @brief Host negotiation success status change */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET_POS              = 17;   /** @brief Host negotiation detected */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG_POS             = 18;   /** @brief A-device timeout change */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE_POS              = 19;   /** @brief Debounce done */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG_POS              = 20;   /** @brief ID input pin changed */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_GINT_POS                = 0;    /** @brief Global interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_POS             = 1;    /** @brief Burst length/type */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN_POS               = 5;    /** @brief DMA enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL_POS             = 7;    /** @brief TxFIFO empty level */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL_POS            = 8;    /** @brief Periodic txfifo empty level */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_POS               = 0;    /** @brief FS timeout calibration */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL_POS              = 6;    /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP_POS              = 8;    /** @brief SRP-capable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP_POS              = 9;    /** @brief HNP-capable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_POS                = 10;   /** @brief USB turnaround time */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS_POS             = 15;   /** @brief PHY low-power clock select */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS_POS            = 17;   /** @brief ULPI FS/LS select */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR_POS              = 18;   /** @brief ULPI auto-resume */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM_POS             = 19;   /** @brief ULPI clock suspendm */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD_POS          = 20;   /** @brief ULPI external VBUS drive */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI_POS          = 21;   /** @brief ULPI external VBUS indicator */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS_POS               = 22;   /** @brief TermSel dline pulsing selection */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI_POS                = 23;   /** @brief Indicator complement */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI_POS                = 24;   /** @brief Indicator pass through */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD_POS             = 25;   /** @brief ULPI interface protect disable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD_POS               = 29;   /** @brief Forced host mode */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD_POS               = 30;   /** @brief Forced peripheral mode */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST_POS               = 0;    /** @brief Core soft reset */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST_POS               = 1;    /** @brief HCLK soft reset */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST_POS               = 2;    /** @brief Host frame counter reset */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH_POS             = 4;    /** @brief RxFIFO flush */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH_POS             = 5;    /** @brief TxFIFO flush */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_POS              = 6;    /** @brief TxFIFO number */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL_POS              = 31;   /** @brief AHB master idle */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ_POS              = 30;   /** @brief DMA request signal enabled for USB OTG HS */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CMOD_POS                = 0;    /** @brief Current mode of operation */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_MMIS_POS                = 1;    /** @brief Mode mismatch interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT_POS              = 2;    /** @brief OTG interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SOF_POS                 = 3;    /** @brief Start of frame */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL_POS              = 4;    /** @brief RxFIFO nonempty */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE_POS              = 5;    /** @brief Nonperiodic txfifo empty */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF_POS            = 6;    /** @brief Global IN nonperiodic NAK effective */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF_POS          = 7;    /** @brief Global OUT NAK effective */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP_POS               = 10;   /** @brief Early suspend */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP_POS             = 11;   /** @brief USB suspend */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBRST_POS              = 12;   /** @brief USB reset */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE_POS             = 13;   /** @brief Enumeration done */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP_POS             = 14;   /** @brief Isochronous OUT packet dropped interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_EOPF_POS                = 15;   /** @brief End of periodic frame interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT_POS              = 18;   /** @brief IN endpoint interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT_POS              = 19;   /** @brief OUT endpoint interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR_POS            = 20;   /** @brief Incomplete isochronous IN transfer */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_POS   = 21;   /** @brief Incomplete periodic transfer */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP_POS           = 22;   /** @brief Data fetch suspended */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT_POS             = 24;   /** @brief Host port interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HCINT_POS               = 25;   /** @brief Host channels interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE_POS               = 26;   /** @brief Periodic txfifo empty */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG_POS             = 28;   /** @brief Connector ID status change */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT_POS             = 29;   /** @brief Disconnect detected interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT_POS              = 30;   /** @brief Session request/new session detected interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT_POS              = 31;   /** @brief Resume/remote wakeup detected interrupt */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_MMISM_POS               = 1;    /** @brief Mode mismatch interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT_POS              = 2;    /** @brief OTG interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SOFM_POS                = 3;    /** @brief Start of frame mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM_POS             = 4;    /** @brief Receive FIFO nonempty mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM_POS             = 5;    /** @brief Nonperiodic txfifo empty mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM_POS           = 6;    /** @brief Global nonperiodic IN NAK effective mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM_POS           = 7;    /** @brief Global OUT NAK effective mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM_POS              = 10;   /** @brief Early suspend mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM_POS            = 11;   /** @brief USB suspend mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBRST_POS              = 12;   /** @brief USB reset mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM_POS            = 13;   /** @brief Enumeration done mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM_POS            = 14;   /** @brief Isochronous OUT packet dropped interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM_POS               = 15;   /** @brief End of periodic frame interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT_POS              = 18;   /** @brief IN endpoints interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT_POS              = 19;   /** @brief OUT endpoints interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM_POS           = 20;   /** @brief Incomplete isochronous IN transfer mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_POS     = 21;   /** @brief Incomplete periodic transfer mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM_POS              = 22;   /** @brief Data fetch suspended mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM_POS               = 24;   /** @brief Host port interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_HCIM_POS                = 25;   /** @brief Host channels interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM_POS              = 26;   /** @brief Periodic txfifo empty mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM_POS            = 28;   /** @brief Connector ID status change mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT_POS             = 29;   /** @brief Disconnect detected interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM_POS               = 30;   /** @brief Session request/new session detected interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_WUIM_POS                = 31;   /** @brief Resume/remote wakeup detected interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE_POS               = 23;   /** @brief Reset detected interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM_POS             = 27;   /** @brief LPM interrupt mask */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM_POS          = 0;    /** @brief Channel number */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT_POS           = 4;    /** @brief Byte count */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID_POS           = 15;   /** @brief Data PID */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS_POS         = 17;   /** @brief Packet status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM_POS          = 0;    /** @brief Channel number */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT_POS           = 4;    /** @brief Byte count */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID_POS           = 15;   /** @brief Data PID */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS_POS         = 17;   /** @brief Packet status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_POS                = 0;    /** @brief RxFIFO depth */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA_POS      = 0;    /** @brief Nonperiodic transmit RAM start address */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD_POS       = 16;   /** @brief Nonperiodic txfifo depth */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FSA_POS      = 0;    /** @brief Endpoint 0 transmit RAM start address */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD_POS       = 16;   /** @brief Endpoint 0 txfifo depth */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_POS           = 0;    /** @brief Nonperiodic txfifo space available */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_POS           = 16;   /** @brief Nonperiodic transmit request queue space available */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_POS           = 24;   /** @brief Top of the nonperiodic transmit request queue */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN_POS                = 16;   /** @brief Power down */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_BCDEN_POS                 = 17;   /** @brief Battery charging detector (BCD) enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDEN_POS                 = 18;   /** @brief Data contact detection (DCD) mode enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDEN_POS                  = 19;   /** @brief Primary detection (PD) mode enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDEN_POS                  = 20;   /** @brief Secondary detection (SD) mode enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_VBDEN_POS                 = 21;   /** @brief USB VBUS detection enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDET_POS                 = 0;    /** @brief Data contact detection (DCD) status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDET_POS                  = 1;    /** @brief Primary detection (PD) status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDET_POS                  = 2;    /** @brief Secondary detection (SD) status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PS2DET_POS                = 3;    /** @brief DM pull-up detection status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_POS              = 0;    /** @brief Host periodic txfifo start address */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_POS              = 16;   /** @brief Host periodic txfifo depth */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXSA_POS           = 0;    /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD_POS           = 16;   /** @brief IN endpoint txfifo depth */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_EPNUM_POS        = 0;    /** @brief Endpoint number */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_BCNT_POS         = 4;    /** @brief Byte count */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_DPID_POS         = 15;   /** @brief Data PID */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PKTSTS_POS       = 17;   /** @brief Packet status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM_POS       = 21;   /** @brief Frame number */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_EPNUM_POS        = 0;    /** @brief Endpoint number */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_BCNT_POS         = 4;    /** @brief Byte count */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_DPID_POS         = 15;   /** @brief Data PID */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PKTSTS_POS       = 17;   /** @brief Packet status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM_POS       = 21;   /** @brief Frame number */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN_POS               = 0;    /** @brief LPM support enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK_POS              = 1;    /** @brief LPM token acknowledge enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_POS                = 2;    /** @brief Best effort service latency */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE_POS             = 6;    /** @brief BRemoteWake value */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN_POS              = 7;    /** @brief L1 shallow sleep enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_POS            = 8;    /** @brief BESL threshold */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN_POS              = 12;   /** @brief L1 deep sleep enable */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_POS              = 13;   /** @brief LPM response */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS_POS              = 15;   /** @brief Port sleep status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK_POS             = 16;   /** @brief Sleep state resume OK */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_POS            = 17;   /** @brief LPM channel index */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_POS             = 21;   /** @brief LPM retry count */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM_POS              = 24;   /** @brief Send LPM transaction */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_POS          = 25;   /** @brief LPM retry count status */
    static const int32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL_POS              = 28;   /** @brief Enable best effort service latency */

    /**********************************************************************************************
     * @section OTG2_HS_GLOBAL Register Information
     **********************************************************************************************/

    /**** @subsection OTG2_HS_GLOBAL Register Pointers ****/

    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_PTR           = (RW_ uint32_t* const)0x40080000U;   /** @brief OTG_HS control and status register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GOTGINT_PTR           = (RW_ uint32_t* const)0x40080004U;   /** @brief OTG_HS interrupt register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_PTR           = (RW_ uint32_t* const)0x40080008U;   /** @brief OTG_HS AHB configuration register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PTR           = (RW_ uint32_t* const)0x4008000CU;   /** @brief OTG_HS USB configuration register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_PTR           = (RW_ uint32_t* const)0x40080010U;   /** @brief OTG_HS reset register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PTR           = (RW_ uint32_t* const)0x40080014U;   /** @brief OTG_HS core interrupt register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PTR           = (RW_ uint32_t* const)0x40080018U;   /** @brief OTG_HS interrupt mask register */
    static RO_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PTR      = (RO_ uint32_t* const)0x4008001CU;   /** @brief OTG_HS receive status debug read register (host mode) */
    static RO_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PTR      = (RO_ uint32_t* const)0x40080020U;   /** @brief OTG_HS status read and pop register (host mode) */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_PTR           = (RW_ uint32_t* const)0x40080024U;   /** @brief OTG_HS receive FIFO size register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_PTR    = (RW_ uint32_t* const)0x40080028U;   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_PTR   = (RW_ uint32_t* const)0x40080028U;   /** @brief Endpoint 0 transmit FIFO size (peripheral mode) */
    static RO_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_PTR          = (RO_ uint32_t* const)0x4008002CU;   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GCCFG_PTR             = (RW_ uint32_t* const)0x40080038U;   /** @brief OTG_HS general core configuration register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_CID_PTR               = (RW_ uint32_t* const)0x4008003CU;   /** @brief OTG_HS core ID register */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTR          = (RW_ uint32_t* const)0x40080100U;   /** @brief OTG_HS host periodic transmit FIFO size register */
    static RO_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PTR    = (RO_ uint32_t* const)0x4008001CU;   /** @brief OTG_HS receive status debug read register (peripheral mode mode) */
    static RO_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PTR    = (RO_ uint32_t* const)0x40080020U;   /** @brief OTG_HS status read and pop register (peripheral mode) */
    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_PTR           = (RW_ uint32_t* const)0x40080054U;   /** @brief OTG core LPM configuration register */

    /**** @subsection Enumerated OTG2_HS_GLOBAL Register Pointers ****/

    static RW_ uint32_t* const OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_PTR[8] = {
      [1] = (RW_ uint32_t* const)0x40080104U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [2] = (RW_ uint32_t* const)0x40080108U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [3] = (RW_ uint32_t* const)0x4008011CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [4] = (RW_ uint32_t* const)0x40080120U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [5] = (RW_ uint32_t* const)0x40080124U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [6] = (RW_ uint32_t* const)0x40080128U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [7] = (RW_ uint32_t* const)0x4008012CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
    };

    /**** @subsection OTG2_HS_GLOBAL Register Reset Values ****/

    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_RST           = 0x00000800U;   /** @brief OTG_HS_GOTGCTL register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_RST           = 0x00000000U;   /** @brief OTG_HS_GOTGINT register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_RST           = 0x00000000U;   /** @brief OTG_HS_GAHBCFG register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_RST           = 0x00000A00U;   /** @brief OTG_HS_GUSBCFG register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_RST           = 0x20000000U;   /** @brief OTG_HS_GRSTCTL register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_RST           = 0x04000020U;   /** @brief OTG_HS_GINTSTS register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RST           = 0x00000000U;   /** @brief OTG_HS_GINTMSK register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_RST      = 0x00000000U;   /** @brief OTG_HS_GRXSTSR_HOST register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_RST      = 0x00000000U;   /** @brief OTG_HS_GRXSTSP_HOST register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_RST           = 0x00000200U;   /** @brief OTG_HS_GRXFSIZ register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_RST    = 0x00000200U;   /** @brief OTG_HS_HNPTXFSIZ_HOST register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_RST   = 0x00000200U;   /** @brief OTG_HS_DIEPTXF0_DEVICE register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_RST          = 0x00080200U;   /** @brief OTG_HS_GNPTXSTS register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_RST             = 0x00000000U;   /** @brief OTG_HS_GCCFG register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_CID_RST               = 0x00001200U;   /** @brief OTG_HS_CID register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_RST          = 0x02000600U;   /** @brief OTG_HS_HPTXFSIZ register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_RST    = 0x00000000U;   /** @brief OTG_HS_GRXSTSR_DEVICE register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_RST    = 0x00000000U;   /** @brief OTG_HS_GRXSTSP_DEVICE register reset value. */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_RST           = 0x00000000U;   /** @brief OTG_HS_GLPMCFG register reset value. */

    /**** @subsection Enumerated OTG2_HS_GLOBAL Register Reset Values ****/

    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_RST[8] = {
      [1] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF1 register reset value. */
      [2] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF2 register reset value. */
      [3] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF3 register reset value. */
      [4] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF4 register reset value. */
      [5] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF5 register reset value. */
      [6] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF6 register reset value. */
      [7] = 0x02000400U,   /** @brief OTG_HS_DIEPTXF7 register reset value. */
    };

    /**** @subsection Enumerated OTG2_HS_GLOBAL Register Value Types ****/

    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_t;           /** @brief OTG_HS_GOTGCTL register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_t;           /** @brief OTG_HS_GOTGINT register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_t;           /** @brief OTG_HS_GAHBCFG register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_t;           /** @brief OTG_HS_GUSBCFG register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_t;           /** @brief OTG_HS_GRSTCTL register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_t;           /** @brief OTG_HS_GINTSTS register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_t;           /** @brief OTG_HS_GINTMSK register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_t;      /** @brief OTG_HS_GRXSTSR_HOST register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_t;      /** @brief OTG_HS_GRXSTSP_HOST register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_t;           /** @brief OTG_HS_GRXFSIZ register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_t;    /** @brief OTG_HS_HNPTXFSIZ_HOST register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_t;   /** @brief OTG_HS_DIEPTXF0_DEVICE register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_t;          /** @brief OTG_HS_GNPTXSTS register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_t;             /** @brief OTG_HS_GCCFG register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_CID_t;               /** @brief OTG_HS_CID register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_t;          /** @brief OTG_HS_HPTXFSIZ register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_t;          /** @brief OTG_HS_DIEPTXFx register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_t;    /** @brief OTG_HS_GRXSTSR_DEVICE register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_t;    /** @brief OTG_HS_GRXSTSP_DEVICE register value type. */
    typedef uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_t;           /** @brief OTG_HS_GLPMCFG register value type. */

    /**** @subsection Enumerated OTG2_HS_GLOBAL Register Pointer Types ****/

    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_PTR_t;           /** @brief OTG_HS_GOTGCTL register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GOTGINT_PTR_t;           /** @brief OTG_HS_GOTGINT register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_PTR_t;           /** @brief OTG_HS_GAHBCFG register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PTR_t;           /** @brief OTG_HS_GUSBCFG register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_PTR_t;           /** @brief OTG_HS_GRSTCTL register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PTR_t;           /** @brief OTG_HS_GINTSTS register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PTR_t;           /** @brief OTG_HS_GINTMSK register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PTR_t;      /** @brief OTG_HS_GRXSTSR_HOST register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PTR_t;      /** @brief OTG_HS_GRXSTSP_HOST register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_PTR_t;           /** @brief OTG_HS_GRXFSIZ register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_PTR_t;    /** @brief OTG_HS_HNPTXFSIZ_HOST register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_PTR_t;   /** @brief OTG_HS_DIEPTXF0_DEVICE register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_PTR_t;          /** @brief OTG_HS_GNPTXSTS register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GCCFG_PTR_t;             /** @brief OTG_HS_GCCFG register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_CID_PTR_t;               /** @brief OTG_HS_CID register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTR_t;          /** @brief OTG_HS_HPTXFSIZ register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_PTR_t;          /** @brief OTG_HS_DIEPTXFx register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PTR_t;    /** @brief OTG_HS_GRXSTSR_DEVICE register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PTR_t;    /** @brief OTG_HS_GRXSTSP_DEVICE register pointer type. */
    typedef uint32_t* const OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_PTR_t;           /** @brief OTG_HS_GLPMCFG register pointer type. */

    /**** @subsection OTG2_HS_GLOBAL Register Field Masks ****/

    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS_MASK              = 0x00000001U;   /** @brief Session request success */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ_MASK                 = 0x00000002U;   /** @brief Session request */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS_MASK              = 0x00000100U;   /** @brief Host negotiation success */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ_MASK               = 0x00000200U;   /** @brief HNP request */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN_MASK             = 0x00000400U;   /** @brief Host set HNP enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN_MASK              = 0x00000800U;   /** @brief Device HNP enabled */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS_MASK              = 0x00010000U;   /** @brief Connector ID status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT_MASK                = 0x00020000U;   /** @brief Long/short debounce time */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD_MASK               = 0x00040000U;   /** @brief A-session valid */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD_MASK               = 0x00080000U;   /** @brief B-session valid */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN_MASK                = 0x00001000U;   /** @brief Embedded host enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SEDET_MASK               = 0x00000004U;   /** @brief Session end detected */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG_MASK             = 0x00000100U;   /** @brief Session request success status change */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG_MASK             = 0x00000200U;   /** @brief Host negotiation success status change */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET_MASK              = 0x00020000U;   /** @brief Host negotiation detected */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG_MASK             = 0x00040000U;   /** @brief A-device timeout change */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE_MASK              = 0x00080000U;   /** @brief Debounce done */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG_MASK              = 0x00100000U;   /** @brief ID input pin changed */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_GINT_MASK                = 0x00000001U;   /** @brief Global interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_MASK             = 0x0000001EU;   /** @brief Burst length/type */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN_MASK               = 0x00000020U;   /** @brief DMA enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL_MASK             = 0x00000080U;   /** @brief TxFIFO empty level */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL_MASK            = 0x00000100U;   /** @brief Periodic txfifo empty level */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_MASK               = 0x00000007U;   /** @brief FS timeout calibration */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL_MASK              = 0x00000040U;   /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP_MASK              = 0x00000100U;   /** @brief SRP-capable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP_MASK              = 0x00000200U;   /** @brief HNP-capable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_MASK                = 0x00003C00U;   /** @brief USB turnaround time */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS_MASK             = 0x00008000U;   /** @brief PHY low-power clock select */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS_MASK            = 0x00020000U;   /** @brief ULPI FS/LS select */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR_MASK              = 0x00040000U;   /** @brief ULPI auto-resume */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM_MASK             = 0x00080000U;   /** @brief ULPI clock suspendm */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD_MASK          = 0x00100000U;   /** @brief ULPI external VBUS drive */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI_MASK          = 0x00200000U;   /** @brief ULPI external VBUS indicator */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS_MASK               = 0x00400000U;   /** @brief TermSel dline pulsing selection */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI_MASK                = 0x00800000U;   /** @brief Indicator complement */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI_MASK                = 0x01000000U;   /** @brief Indicator pass through */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD_MASK             = 0x02000000U;   /** @brief ULPI interface protect disable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD_MASK               = 0x20000000U;   /** @brief Forced host mode */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD_MASK               = 0x40000000U;   /** @brief Forced peripheral mode */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST_MASK               = 0x00000001U;   /** @brief Core soft reset */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST_MASK               = 0x00000002U;   /** @brief HCLK soft reset */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST_MASK               = 0x00000004U;   /** @brief Host frame counter reset */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH_MASK             = 0x00000010U;   /** @brief RxFIFO flush */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH_MASK             = 0x00000020U;   /** @brief TxFIFO flush */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_MASK              = 0x000007C0U;   /** @brief TxFIFO number */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL_MASK              = 0x80000000U;   /** @brief AHB master idle */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ_MASK              = 0x40000000U;   /** @brief DMA request signal enabled for USB OTG HS */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CMOD_MASK                = 0x00000001U;   /** @brief Current mode of operation */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_MMIS_MASK                = 0x00000002U;   /** @brief Mode mismatch interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT_MASK              = 0x00000004U;   /** @brief OTG interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SOF_MASK                 = 0x00000008U;   /** @brief Start of frame */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL_MASK              = 0x00000010U;   /** @brief RxFIFO nonempty */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE_MASK              = 0x00000020U;   /** @brief Nonperiodic txfifo empty */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF_MASK            = 0x00000040U;   /** @brief Global IN nonperiodic NAK effective */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF_MASK          = 0x00000080U;   /** @brief Global OUT NAK effective */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP_MASK               = 0x00000400U;   /** @brief Early suspend */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP_MASK             = 0x00000800U;   /** @brief USB suspend */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBRST_MASK              = 0x00001000U;   /** @brief USB reset */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE_MASK             = 0x00002000U;   /** @brief Enumeration done */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP_MASK             = 0x00004000U;   /** @brief Isochronous OUT packet dropped interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_EOPF_MASK                = 0x00008000U;   /** @brief End of periodic frame interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT_MASK              = 0x00040000U;   /** @brief IN endpoint interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT_MASK              = 0x00080000U;   /** @brief OUT endpoint interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR_MASK            = 0x00100000U;   /** @brief Incomplete isochronous IN transfer */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_MASK   = 0x00200000U;   /** @brief Incomplete periodic transfer */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP_MASK           = 0x00400000U;   /** @brief Data fetch suspended */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT_MASK             = 0x01000000U;   /** @brief Host port interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HCINT_MASK               = 0x02000000U;   /** @brief Host channels interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE_MASK               = 0x04000000U;   /** @brief Periodic txfifo empty */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG_MASK             = 0x10000000U;   /** @brief Connector ID status change */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT_MASK             = 0x20000000U;   /** @brief Disconnect detected interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT_MASK              = 0x40000000U;   /** @brief Session request/new session detected interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT_MASK              = 0x80000000U;   /** @brief Resume/remote wakeup detected interrupt */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_MMISM_MASK               = 0x00000002U;   /** @brief Mode mismatch interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT_MASK              = 0x00000004U;   /** @brief OTG interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SOFM_MASK                = 0x00000008U;   /** @brief Start of frame mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM_MASK             = 0x00000010U;   /** @brief Receive FIFO nonempty mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM_MASK             = 0x00000020U;   /** @brief Nonperiodic txfifo empty mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM_MASK           = 0x00000040U;   /** @brief Global nonperiodic IN NAK effective mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM_MASK           = 0x00000080U;   /** @brief Global OUT NAK effective mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM_MASK              = 0x00000400U;   /** @brief Early suspend mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM_MASK            = 0x00000800U;   /** @brief USB suspend mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBRST_MASK              = 0x00001000U;   /** @brief USB reset mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM_MASK            = 0x00002000U;   /** @brief Enumeration done mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM_MASK            = 0x00004000U;   /** @brief Isochronous OUT packet dropped interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM_MASK               = 0x00008000U;   /** @brief End of periodic frame interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT_MASK              = 0x00040000U;   /** @brief IN endpoints interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT_MASK              = 0x00080000U;   /** @brief OUT endpoints interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM_MASK           = 0x00100000U;   /** @brief Incomplete isochronous IN transfer mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_MASK     = 0x00200000U;   /** @brief Incomplete periodic transfer mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM_MASK              = 0x00400000U;   /** @brief Data fetch suspended mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM_MASK               = 0x01000000U;   /** @brief Host port interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_HCIM_MASK                = 0x02000000U;   /** @brief Host channels interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM_MASK              = 0x04000000U;   /** @brief Periodic txfifo empty mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM_MASK            = 0x10000000U;   /** @brief Connector ID status change mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT_MASK             = 0x20000000U;   /** @brief Disconnect detected interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM_MASK               = 0x40000000U;   /** @brief Session request/new session detected interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_WUIM_MASK                = 0x80000000U;   /** @brief Resume/remote wakeup detected interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE_MASK               = 0x00800000U;   /** @brief Reset detected interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM_MASK             = 0x08000000U;   /** @brief LPM interrupt mask */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM_MASK          = 0x0000000FU;   /** @brief Channel number */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT_MASK           = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID_MASK           = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS_MASK         = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM_MASK          = 0x0000000FU;   /** @brief Channel number */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT_MASK           = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID_MASK           = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS_MASK         = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_MASK                = 0x0000FFFFU;   /** @brief RxFIFO depth */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA_MASK      = 0x0000FFFFU;   /** @brief Nonperiodic transmit RAM start address */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD_MASK       = 0xFFFF0000U;   /** @brief Nonperiodic txfifo depth */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FSA_MASK      = 0x0000FFFFU;   /** @brief Endpoint 0 transmit RAM start address */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD_MASK       = 0xFFFF0000U;   /** @brief Endpoint 0 txfifo depth */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_MASK           = 0x0000FFFFU;   /** @brief Nonperiodic txfifo space available */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_MASK           = 0x00FF0000U;   /** @brief Nonperiodic transmit request queue space available */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_MASK           = 0x7F000000U;   /** @brief Top of the nonperiodic transmit request queue */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN_MASK                = 0x00010000U;   /** @brief Power down */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_BCDEN_MASK                 = 0x00020000U;   /** @brief Battery charging detector (BCD) enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDEN_MASK                 = 0x00040000U;   /** @brief Data contact detection (DCD) mode enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDEN_MASK                  = 0x00080000U;   /** @brief Primary detection (PD) mode enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDEN_MASK                  = 0x00100000U;   /** @brief Secondary detection (SD) mode enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_VBDEN_MASK                 = 0x00200000U;   /** @brief USB VBUS detection enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDET_MASK                 = 0x00000001U;   /** @brief Data contact detection (DCD) status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDET_MASK                  = 0x00000002U;   /** @brief Primary detection (PD) status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDET_MASK                  = 0x00000004U;   /** @brief Secondary detection (SD) status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PS2DET_MASK                = 0x00000008U;   /** @brief DM pull-up detection status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_MASK              = 0x0000FFFFU;   /** @brief Host periodic txfifo start address */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_MASK              = 0xFFFF0000U;   /** @brief Host periodic txfifo depth */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXSA_MASK           = 0x0000FFFFU;   /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD_MASK           = 0xFFFF0000U;   /** @brief IN endpoint txfifo depth */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_EPNUM_MASK        = 0x0000000FU;   /** @brief Endpoint number */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_BCNT_MASK         = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_DPID_MASK         = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PKTSTS_MASK       = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM_MASK       = 0x01E00000U;   /** @brief Frame number */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_EPNUM_MASK        = 0x0000000FU;   /** @brief Endpoint number */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_BCNT_MASK         = 0x00007FF0U;   /** @brief Byte count */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_DPID_MASK         = 0x00018000U;   /** @brief Data PID */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PKTSTS_MASK       = 0x001E0000U;   /** @brief Packet status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM_MASK       = 0x01E00000U;   /** @brief Frame number */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN_MASK               = 0x00000001U;   /** @brief LPM support enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK_MASK              = 0x00000002U;   /** @brief LPM token acknowledge enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_MASK                = 0x0000003CU;   /** @brief Best effort service latency */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE_MASK             = 0x00000040U;   /** @brief BRemoteWake value */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN_MASK              = 0x00000080U;   /** @brief L1 shallow sleep enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_MASK            = 0x00000F00U;   /** @brief BESL threshold */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN_MASK              = 0x00001000U;   /** @brief L1 deep sleep enable */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_MASK              = 0x00006000U;   /** @brief LPM response */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS_MASK              = 0x00008000U;   /** @brief Port sleep status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK_MASK             = 0x00010000U;   /** @brief Sleep state resume OK */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_MASK            = 0x001E0000U;   /** @brief LPM channel index */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_MASK             = 0x00E00000U;   /** @brief LPM retry count */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM_MASK              = 0x01000000U;   /** @brief Send LPM transaction */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_MASK          = 0x0E000000U;   /** @brief LPM retry count status */
    static const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL_MASK              = 0x10000000U;   /** @brief Enable best effort service latency */

    /**** @subsection OTG2_HS_GLOBAL Register Field Positions ****/

    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS_POS              = 0;    /** @brief Session request success */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ_POS                 = 1;    /** @brief Session request */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS_POS              = 8;    /** @brief Host negotiation success */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ_POS               = 9;    /** @brief HNP request */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN_POS             = 10;   /** @brief Host set HNP enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN_POS              = 11;   /** @brief Device HNP enabled */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS_POS              = 16;   /** @brief Connector ID status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT_POS                = 17;   /** @brief Long/short debounce time */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD_POS               = 18;   /** @brief A-session valid */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD_POS               = 19;   /** @brief B-session valid */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN_POS                = 12;   /** @brief Embedded host enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SEDET_POS               = 2;    /** @brief Session end detected */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG_POS             = 8;    /** @brief Session request success status change */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG_POS             = 9;    /** @brief Host negotiation success status change */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET_POS              = 17;   /** @brief Host negotiation detected */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG_POS             = 18;   /** @brief A-device timeout change */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE_POS              = 19;   /** @brief Debounce done */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG_POS              = 20;   /** @brief ID input pin changed */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_GINT_POS                = 0;    /** @brief Global interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_POS             = 1;    /** @brief Burst length/type */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN_POS               = 5;    /** @brief DMA enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL_POS             = 7;    /** @brief TxFIFO empty level */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL_POS            = 8;    /** @brief Periodic txfifo empty level */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_POS               = 0;    /** @brief FS timeout calibration */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL_POS              = 6;    /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP_POS              = 8;    /** @brief SRP-capable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP_POS              = 9;    /** @brief HNP-capable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_POS                = 10;   /** @brief USB turnaround time */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS_POS             = 15;   /** @brief PHY low-power clock select */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS_POS            = 17;   /** @brief ULPI FS/LS select */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR_POS              = 18;   /** @brief ULPI auto-resume */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM_POS             = 19;   /** @brief ULPI clock suspendm */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD_POS          = 20;   /** @brief ULPI external VBUS drive */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI_POS          = 21;   /** @brief ULPI external VBUS indicator */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS_POS               = 22;   /** @brief TermSel dline pulsing selection */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI_POS                = 23;   /** @brief Indicator complement */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI_POS                = 24;   /** @brief Indicator pass through */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD_POS             = 25;   /** @brief ULPI interface protect disable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD_POS               = 29;   /** @brief Forced host mode */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD_POS               = 30;   /** @brief Forced peripheral mode */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST_POS               = 0;    /** @brief Core soft reset */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST_POS               = 1;    /** @brief HCLK soft reset */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST_POS               = 2;    /** @brief Host frame counter reset */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH_POS             = 4;    /** @brief RxFIFO flush */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH_POS             = 5;    /** @brief TxFIFO flush */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_POS              = 6;    /** @brief TxFIFO number */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL_POS              = 31;   /** @brief AHB master idle */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ_POS              = 30;   /** @brief DMA request signal enabled for USB OTG HS */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CMOD_POS                = 0;    /** @brief Current mode of operation */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_MMIS_POS                = 1;    /** @brief Mode mismatch interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT_POS              = 2;    /** @brief OTG interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SOF_POS                 = 3;    /** @brief Start of frame */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL_POS              = 4;    /** @brief RxFIFO nonempty */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE_POS              = 5;    /** @brief Nonperiodic txfifo empty */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF_POS            = 6;    /** @brief Global IN nonperiodic NAK effective */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF_POS          = 7;    /** @brief Global OUT NAK effective */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP_POS               = 10;   /** @brief Early suspend */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP_POS             = 11;   /** @brief USB suspend */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBRST_POS              = 12;   /** @brief USB reset */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE_POS             = 13;   /** @brief Enumeration done */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP_POS             = 14;   /** @brief Isochronous OUT packet dropped interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_EOPF_POS                = 15;   /** @brief End of periodic frame interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT_POS              = 18;   /** @brief IN endpoint interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT_POS              = 19;   /** @brief OUT endpoint interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR_POS            = 20;   /** @brief Incomplete isochronous IN transfer */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_POS   = 21;   /** @brief Incomplete periodic transfer */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP_POS           = 22;   /** @brief Data fetch suspended */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT_POS             = 24;   /** @brief Host port interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HCINT_POS               = 25;   /** @brief Host channels interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE_POS               = 26;   /** @brief Periodic txfifo empty */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG_POS             = 28;   /** @brief Connector ID status change */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT_POS             = 29;   /** @brief Disconnect detected interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT_POS              = 30;   /** @brief Session request/new session detected interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT_POS              = 31;   /** @brief Resume/remote wakeup detected interrupt */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_MMISM_POS               = 1;    /** @brief Mode mismatch interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT_POS              = 2;    /** @brief OTG interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SOFM_POS                = 3;    /** @brief Start of frame mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM_POS             = 4;    /** @brief Receive FIFO nonempty mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM_POS             = 5;    /** @brief Nonperiodic txfifo empty mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM_POS           = 6;    /** @brief Global nonperiodic IN NAK effective mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM_POS           = 7;    /** @brief Global OUT NAK effective mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM_POS              = 10;   /** @brief Early suspend mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM_POS            = 11;   /** @brief USB suspend mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBRST_POS              = 12;   /** @brief USB reset mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM_POS            = 13;   /** @brief Enumeration done mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM_POS            = 14;   /** @brief Isochronous OUT packet dropped interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM_POS               = 15;   /** @brief End of periodic frame interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT_POS              = 18;   /** @brief IN endpoints interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT_POS              = 19;   /** @brief OUT endpoints interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM_POS           = 20;   /** @brief Incomplete isochronous IN transfer mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_POS     = 21;   /** @brief Incomplete periodic transfer mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM_POS              = 22;   /** @brief Data fetch suspended mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM_POS               = 24;   /** @brief Host port interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_HCIM_POS                = 25;   /** @brief Host channels interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM_POS              = 26;   /** @brief Periodic txfifo empty mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM_POS            = 28;   /** @brief Connector ID status change mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT_POS             = 29;   /** @brief Disconnect detected interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM_POS               = 30;   /** @brief Session request/new session detected interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_WUIM_POS                = 31;   /** @brief Resume/remote wakeup detected interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE_POS               = 23;   /** @brief Reset detected interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM_POS             = 27;   /** @brief LPM interrupt mask */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM_POS          = 0;    /** @brief Channel number */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT_POS           = 4;    /** @brief Byte count */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID_POS           = 15;   /** @brief Data PID */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS_POS         = 17;   /** @brief Packet status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM_POS          = 0;    /** @brief Channel number */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT_POS           = 4;    /** @brief Byte count */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID_POS           = 15;   /** @brief Data PID */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS_POS         = 17;   /** @brief Packet status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_POS                = 0;    /** @brief RxFIFO depth */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA_POS      = 0;    /** @brief Nonperiodic transmit RAM start address */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD_POS       = 16;   /** @brief Nonperiodic txfifo depth */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FSA_POS      = 0;    /** @brief Endpoint 0 transmit RAM start address */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD_POS       = 16;   /** @brief Endpoint 0 txfifo depth */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_POS           = 0;    /** @brief Nonperiodic txfifo space available */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_POS           = 16;   /** @brief Nonperiodic transmit request queue space available */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_POS           = 24;   /** @brief Top of the nonperiodic transmit request queue */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN_POS                = 16;   /** @brief Power down */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_BCDEN_POS                 = 17;   /** @brief Battery charging detector (BCD) enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDEN_POS                 = 18;   /** @brief Data contact detection (DCD) mode enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDEN_POS                  = 19;   /** @brief Primary detection (PD) mode enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDEN_POS                  = 20;   /** @brief Secondary detection (SD) mode enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_VBDEN_POS                 = 21;   /** @brief USB VBUS detection enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDET_POS                 = 0;    /** @brief Data contact detection (DCD) status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDET_POS                  = 1;    /** @brief Primary detection (PD) status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDET_POS                  = 2;    /** @brief Secondary detection (SD) status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PS2DET_POS                = 3;    /** @brief DM pull-up detection status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_POS              = 0;    /** @brief Host periodic txfifo start address */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_POS              = 16;   /** @brief Host periodic txfifo depth */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXSA_POS           = 0;    /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD_POS           = 16;   /** @brief IN endpoint txfifo depth */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_EPNUM_POS        = 0;    /** @brief Endpoint number */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_BCNT_POS         = 4;    /** @brief Byte count */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_DPID_POS         = 15;   /** @brief Data PID */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PKTSTS_POS       = 17;   /** @brief Packet status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM_POS       = 21;   /** @brief Frame number */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_EPNUM_POS        = 0;    /** @brief Endpoint number */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_BCNT_POS         = 4;    /** @brief Byte count */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_DPID_POS         = 15;   /** @brief Data PID */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PKTSTS_POS       = 17;   /** @brief Packet status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM_POS       = 21;   /** @brief Frame number */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN_POS               = 0;    /** @brief LPM support enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK_POS              = 1;    /** @brief LPM token acknowledge enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_POS                = 2;    /** @brief Best effort service latency */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE_POS             = 6;    /** @brief BRemoteWake value */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN_POS              = 7;    /** @brief L1 shallow sleep enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_POS            = 8;    /** @brief BESL threshold */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN_POS              = 12;   /** @brief L1 deep sleep enable */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_POS              = 13;   /** @brief LPM response */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS_POS              = 15;   /** @brief Port sleep status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK_POS             = 16;   /** @brief Sleep state resume OK */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_POS            = 17;   /** @brief LPM channel index */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_POS             = 21;   /** @brief LPM retry count */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM_POS              = 24;   /** @brief Send LPM transaction */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_POS          = 25;   /** @brief LPM retry count status */
    static const int32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL_POS              = 28;   /** @brief Enable best effort service latency */

    /**********************************************************************************************
     * @section OTGx_HS_HOST Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated OTGx_HS_HOST Register Pointers ****/

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCFG_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40040400U,   /** @brief OTG_HS host configuration register */
      [2] = (RW_ uint32_t* const)0x40080400U,   /** @brief OTG_HS host configuration register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HFIR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40040404U,   /** @brief OTG_HS host frame interval register */
      [2] = (RW_ uint32_t* const)0x40080404U,   /** @brief OTG_HS host frame interval register */
    };

    static RO_ uint32_t* const OTGx_HS_HOST_OTG_HS_HFNUM_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x40040408U,   /** @brief OTG_HS host frame number/frame time remaining register */
      [2] = (RO_ uint32_t* const)0x40080408U,   /** @brief OTG_HS host frame number/frame time remaining register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HPTXSTS_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40040410U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
      [2] = (RW_ uint32_t* const)0x40080410U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
    };

    static RO_ uint32_t* const OTGx_HS_HOST_OTG_HS_HAINT_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x40040414U,   /** @brief OTG_HS host all channels interrupt register */
      [2] = (RO_ uint32_t* const)0x40080414U,   /** @brief OTG_HS host all channels interrupt register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HAINTMSK_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40040418U,   /** @brief OTG_HS host all channels interrupt mask register */
      [2] = (RW_ uint32_t* const)0x40080418U,   /** @brief OTG_HS host all channels interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HPRT_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40040440U,   /** @brief OTG_HS host port control and status register */
      [2] = (RW_ uint32_t* const)0x40080440U,   /** @brief OTG_HS host port control and status register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCCHARx_PTR[3][16] = {
      [0] = {
        [0]  = (RW_ uint32_t* const)0x40040500U,   /** @brief OTG_HS host channel-0 characteristics register */
        [1]  = (RW_ uint32_t* const)0x40040520U,   /** @brief OTG_HS host channel-1 characteristics register */
        [2]  = (RW_ uint32_t* const)0x40040540U,   /** @brief OTG_HS host channel-2 characteristics register */
        [3]  = (RW_ uint32_t* const)0x40040560U,   /** @brief OTG_HS host channel-3 characteristics register */
        [4]  = (RW_ uint32_t* const)0x40040580U,   /** @brief OTG_HS host channel-4 characteristics register */
        [5]  = (RW_ uint32_t* const)0x400405A0U,   /** @brief OTG_HS host channel-5 characteristics register */
        [6]  = (RW_ uint32_t* const)0x400405C0U,   /** @brief OTG_HS host channel-6 characteristics register */
        [7]  = (RW_ uint32_t* const)0x400405E0U,   /** @brief OTG_HS host channel-7 characteristics register */
        [8]  = (RW_ uint32_t* const)0x40040600U,   /** @brief OTG_HS host channel-8 characteristics register */
        [9]  = (RW_ uint32_t* const)0x40040620U,   /** @brief OTG_HS host channel-9 characteristics register */
        [10] = (RW_ uint32_t* const)0x40040640U,   /** @brief OTG_HS host channel-10 characteristics register */
        [11] = (RW_ uint32_t* const)0x40040660U,   /** @brief OTG_HS host channel-11 characteristics register */
        [12] = (RW_ uint32_t* const)0x40040678U,   /** @brief OTG_HS host channel-12 characteristics register */
        [13] = (RW_ uint32_t* const)0x40040690U,   /** @brief OTG_HS host channel-13 characteristics register */
        [14] = (RW_ uint32_t* const)0x400406A8U,   /** @brief OTG_HS host channel-14 characteristics register */
        [15] = (RW_ uint32_t* const)0x400406C0U,   /** @brief OTG_HS host channel-15 characteristics register */
      },
      [1] = {
        [0]  = (RW_ uint32_t* const)0x40080500U,   /** @brief OTG_HS host channel-0 characteristics register */
        [1]  = (RW_ uint32_t* const)0x40080520U,   /** @brief OTG_HS host channel-1 characteristics register */
        [2]  = (RW_ uint32_t* const)0x40080540U,   /** @brief OTG_HS host channel-2 characteristics register */
        [3]  = (RW_ uint32_t* const)0x40080560U,   /** @brief OTG_HS host channel-3 characteristics register */
        [4]  = (RW_ uint32_t* const)0x40080580U,   /** @brief OTG_HS host channel-4 characteristics register */
        [5]  = (RW_ uint32_t* const)0x400805A0U,   /** @brief OTG_HS host channel-5 characteristics register */
        [6]  = (RW_ uint32_t* const)0x400805C0U,   /** @brief OTG_HS host channel-6 characteristics register */
        [7]  = (RW_ uint32_t* const)0x400805E0U,   /** @brief OTG_HS host channel-7 characteristics register */
        [8]  = (RW_ uint32_t* const)0x40080600U,   /** @brief OTG_HS host channel-8 characteristics register */
        [9]  = (RW_ uint32_t* const)0x40080620U,   /** @brief OTG_HS host channel-9 characteristics register */
        [10] = (RW_ uint32_t* const)0x40080640U,   /** @brief OTG_HS host channel-10 characteristics register */
        [11] = (RW_ uint32_t* const)0x40080660U,   /** @brief OTG_HS host channel-11 characteristics register */
        [12] = (RW_ uint32_t* const)0x40080678U,   /** @brief OTG_HS host channel-12 characteristics register */
        [13] = (RW_ uint32_t* const)0x40080690U,   /** @brief OTG_HS host channel-13 characteristics register */
        [14] = (RW_ uint32_t* const)0x400806A8U,   /** @brief OTG_HS host channel-14 characteristics register */
        [15] = (RW_ uint32_t* const)0x400806C0U,   /** @brief OTG_HS host channel-15 characteristics register */
      },
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCSPLTx_PTR[3][16] = {
      [0] = {
        [0]  = (RW_ uint32_t* const)0x40040504U,   /** @brief OTG_HS host channel-0 split control register */
        [1]  = (RW_ uint32_t* const)0x40040524U,   /** @brief OTG_HS host channel-1 split control register */
        [2]  = (RW_ uint32_t* const)0x40040544U,   /** @brief OTG_HS host channel-2 split control register */
        [3]  = (RW_ uint32_t* const)0x40040564U,   /** @brief OTG_HS host channel-3 split control register */
        [4]  = (RW_ uint32_t* const)0x40040584U,   /** @brief OTG_HS host channel-4 split control register */
        [5]  = (RW_ uint32_t* const)0x400405A4U,   /** @brief OTG_HS host channel-5 split control register */
        [6]  = (RW_ uint32_t* const)0x400405C4U,   /** @brief OTG_HS host channel-6 split control register */
        [7]  = (RW_ uint32_t* const)0x400405E4U,   /** @brief OTG_HS host channel-7 split control register */
        [8]  = (RW_ uint32_t* const)0x40040604U,   /** @brief OTG_HS host channel-8 split control register */
        [9]  = (RW_ uint32_t* const)0x40040624U,   /** @brief OTG_HS host channel-9 split control register */
        [10] = (RW_ uint32_t* const)0x40040644U,   /** @brief OTG_HS host channel-10 split control register */
        [11] = (RW_ uint32_t* const)0x40040664U,   /** @brief OTG_HS host channel-11 split control register */
        [12] = (RW_ uint32_t* const)0x4004067CU,   /** @brief OTG_HS host channel-12 split control register */
        [13] = (RW_ uint32_t* const)0x40040694U,   /** @brief OTG_HS host channel-13 split control register */
        [14] = (RW_ uint32_t* const)0x400406ACU,   /** @brief OTG_HS host channel-14 split control register */
        [15] = (RW_ uint32_t* const)0x400406C4U,   /** @brief OTG_HS host channel-15 split control register */
      },
      [1] = {
        [0]  = (RW_ uint32_t* const)0x40080504U,   /** @brief OTG_HS host channel-0 split control register */
        [1]  = (RW_ uint32_t* const)0x40080524U,   /** @brief OTG_HS host channel-1 split control register */
        [2]  = (RW_ uint32_t* const)0x40080544U,   /** @brief OTG_HS host channel-2 split control register */
        [3]  = (RW_ uint32_t* const)0x40080564U,   /** @brief OTG_HS host channel-3 split control register */
        [4]  = (RW_ uint32_t* const)0x40080584U,   /** @brief OTG_HS host channel-4 split control register */
        [5]  = (RW_ uint32_t* const)0x400805A4U,   /** @brief OTG_HS host channel-5 split control register */
        [6]  = (RW_ uint32_t* const)0x400805C4U,   /** @brief OTG_HS host channel-6 split control register */
        [7]  = (RW_ uint32_t* const)0x400805E4U,   /** @brief OTG_HS host channel-7 split control register */
        [8]  = (RW_ uint32_t* const)0x40080604U,   /** @brief OTG_HS host channel-8 split control register */
        [9]  = (RW_ uint32_t* const)0x40080624U,   /** @brief OTG_HS host channel-9 split control register */
        [10] = (RW_ uint32_t* const)0x40080644U,   /** @brief OTG_HS host channel-10 split control register */
        [11] = (RW_ uint32_t* const)0x40080664U,   /** @brief OTG_HS host channel-11 split control register */
        [12] = (RW_ uint32_t* const)0x4008067CU,   /** @brief OTG_HS host channel-12 split control register */
        [13] = (RW_ uint32_t* const)0x40080694U,   /** @brief OTG_HS host channel-13 split control register */
        [14] = (RW_ uint32_t* const)0x400806ACU,   /** @brief OTG_HS host channel-14 split control register */
        [15] = (RW_ uint32_t* const)0x400806C4U,   /** @brief OTG_HS host channel-15 split control register */
      },
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTx_PTR[3][16] = {
      [0] = {
        [0]  = (RW_ uint32_t* const)0x40040508U,   /** @brief OTG_HS host channel-11 interrupt register */
        [1]  = (RW_ uint32_t* const)0x40040528U,   /** @brief OTG_HS host channel-1 interrupt register */
        [2]  = (RW_ uint32_t* const)0x40040548U,   /** @brief OTG_HS host channel-2 interrupt register */
        [3]  = (RW_ uint32_t* const)0x40040568U,   /** @brief OTG_HS host channel-3 interrupt register */
        [4]  = (RW_ uint32_t* const)0x40040588U,   /** @brief OTG_HS host channel-4 interrupt register */
        [5]  = (RW_ uint32_t* const)0x400405A8U,   /** @brief OTG_HS host channel-5 interrupt register */
        [6]  = (RW_ uint32_t* const)0x400405C8U,   /** @brief OTG_HS host channel-6 interrupt register */
        [7]  = (RW_ uint32_t* const)0x400405E8U,   /** @brief OTG_HS host channel-7 interrupt register */
        [8]  = (RW_ uint32_t* const)0x40040608U,   /** @brief OTG_HS host channel-8 interrupt register */
        [9]  = (RW_ uint32_t* const)0x40040628U,   /** @brief OTG_HS host channel-9 interrupt register */
        [10] = (RW_ uint32_t* const)0x40040648U,   /** @brief OTG_HS host channel-10 interrupt register */
        [11] = (RW_ uint32_t* const)0x40040668U,   /** @brief OTG_HS host channel-11 interrupt register */
        [12] = (RW_ uint32_t* const)0x40040680U,   /** @brief OTG_HS host channel-12 interrupt register */
        [13] = (RW_ uint32_t* const)0x40040698U,   /** @brief OTG_HS host channel-13 interrupt register */
        [14] = (RW_ uint32_t* const)0x400406B0U,   /** @brief OTG_HS host channel-14 interrupt register */
        [15] = (RW_ uint32_t* const)0x400406C8U,   /** @brief OTG_HS host channel-15 interrupt register */
      },
      [1] = {
        [0]  = (RW_ uint32_t* const)0x40080508U,   /** @brief OTG_HS host channel-11 interrupt register */
        [1]  = (RW_ uint32_t* const)0x40080528U,   /** @brief OTG_HS host channel-1 interrupt register */
        [2]  = (RW_ uint32_t* const)0x40080548U,   /** @brief OTG_HS host channel-2 interrupt register */
        [3]  = (RW_ uint32_t* const)0x40080568U,   /** @brief OTG_HS host channel-3 interrupt register */
        [4]  = (RW_ uint32_t* const)0x40080588U,   /** @brief OTG_HS host channel-4 interrupt register */
        [5]  = (RW_ uint32_t* const)0x400805A8U,   /** @brief OTG_HS host channel-5 interrupt register */
        [6]  = (RW_ uint32_t* const)0x400805C8U,   /** @brief OTG_HS host channel-6 interrupt register */
        [7]  = (RW_ uint32_t* const)0x400805E8U,   /** @brief OTG_HS host channel-7 interrupt register */
        [8]  = (RW_ uint32_t* const)0x40080608U,   /** @brief OTG_HS host channel-8 interrupt register */
        [9]  = (RW_ uint32_t* const)0x40080628U,   /** @brief OTG_HS host channel-9 interrupt register */
        [10] = (RW_ uint32_t* const)0x40080648U,   /** @brief OTG_HS host channel-10 interrupt register */
        [11] = (RW_ uint32_t* const)0x40080668U,   /** @brief OTG_HS host channel-11 interrupt register */
        [12] = (RW_ uint32_t* const)0x40080680U,   /** @brief OTG_HS host channel-12 interrupt register */
        [13] = (RW_ uint32_t* const)0x40080698U,   /** @brief OTG_HS host channel-13 interrupt register */
        [14] = (RW_ uint32_t* const)0x400806B0U,   /** @brief OTG_HS host channel-14 interrupt register */
        [15] = (RW_ uint32_t* const)0x400806C8U,   /** @brief OTG_HS host channel-15 interrupt register */
      },
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK0_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004050CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008050CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK1_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004052CU,   /** @brief OTG_HS host channel-1 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008052CU,   /** @brief OTG_HS host channel-1 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK2_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004054CU,   /** @brief OTG_HS host channel-2 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008054CU,   /** @brief OTG_HS host channel-2 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK3_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004056CU,   /** @brief OTG_HS host channel-3 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008056CU,   /** @brief OTG_HS host channel-3 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK4_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004058CU,   /** @brief OTG_HS host channel-4 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008058CU,   /** @brief OTG_HS host channel-4 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK5_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400405ACU,   /** @brief OTG_HS host channel-5 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x400805ACU,   /** @brief OTG_HS host channel-5 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK6_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400405CCU,   /** @brief OTG_HS host channel-6 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x400805CCU,   /** @brief OTG_HS host channel-6 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK7_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400405ECU,   /** @brief OTG_HS host channel-7 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x400805ECU,   /** @brief OTG_HS host channel-7 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK8_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004060CU,   /** @brief OTG_HS host channel-8 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008060CU,   /** @brief OTG_HS host channel-8 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK9_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004062CU,   /** @brief OTG_HS host channel-9 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008062CU,   /** @brief OTG_HS host channel-9 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK10_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004064CU,   /** @brief OTG_HS host channel-10 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008064CU,   /** @brief OTG_HS host channel-10 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK11_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004066CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008066CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCTSIZx_PTR[3][16] = {
      [0] = {
        [0]  = (RW_ uint32_t* const)0x40040510U,   /** @brief OTG_HS host channel-11 transfer size register */
        [1]  = (RW_ uint32_t* const)0x40040530U,   /** @brief OTG_HS host channel-1 transfer size register */
        [2]  = (RW_ uint32_t* const)0x40040550U,   /** @brief OTG_HS host channel-2 transfer size register */
        [3]  = (RW_ uint32_t* const)0x40040570U,   /** @brief OTG_HS host channel-3 transfer size register */
        [4]  = (RW_ uint32_t* const)0x40040590U,   /** @brief OTG_HS host channel-4 transfer size register */
        [5]  = (RW_ uint32_t* const)0x400405B0U,   /** @brief OTG_HS host channel-5 transfer size register */
        [6]  = (RW_ uint32_t* const)0x400405D0U,   /** @brief OTG_HS host channel-6 transfer size register */
        [7]  = (RW_ uint32_t* const)0x400405F0U,   /** @brief OTG_HS host channel-7 transfer size register */
        [8]  = (RW_ uint32_t* const)0x40040610U,   /** @brief OTG_HS host channel-8 transfer size register */
        [9]  = (RW_ uint32_t* const)0x40040630U,   /** @brief OTG_HS host channel-9 transfer size register */
        [10] = (RW_ uint32_t* const)0x40040650U,   /** @brief OTG_HS host channel-10 transfer size register */
        [11] = (RW_ uint32_t* const)0x40040670U,   /** @brief OTG_HS host channel-11 transfer size register */
        [12] = (RW_ uint32_t* const)0x40040688U,   /** @brief OTG_HS host channel-12 transfer size register */
        [13] = (RW_ uint32_t* const)0x400406A0U,   /** @brief OTG_HS host channel-13 transfer size register */
        [14] = (RW_ uint32_t* const)0x400406B8U,   /** @brief OTG_HS host channel-14 transfer size register */
        [15] = (RW_ uint32_t* const)0x400406D0U,   /** @brief OTG_HS host channel-15 transfer size register */
      },
      [1] = {
        [0]  = (RW_ uint32_t* const)0x40080510U,   /** @brief OTG_HS host channel-11 transfer size register */
        [1]  = (RW_ uint32_t* const)0x40080530U,   /** @brief OTG_HS host channel-1 transfer size register */
        [2]  = (RW_ uint32_t* const)0x40080550U,   /** @brief OTG_HS host channel-2 transfer size register */
        [3]  = (RW_ uint32_t* const)0x40080570U,   /** @brief OTG_HS host channel-3 transfer size register */
        [4]  = (RW_ uint32_t* const)0x40080590U,   /** @brief OTG_HS host channel-4 transfer size register */
        [5]  = (RW_ uint32_t* const)0x400805B0U,   /** @brief OTG_HS host channel-5 transfer size register */
        [6]  = (RW_ uint32_t* const)0x400805D0U,   /** @brief OTG_HS host channel-6 transfer size register */
        [7]  = (RW_ uint32_t* const)0x400805F0U,   /** @brief OTG_HS host channel-7 transfer size register */
        [8]  = (RW_ uint32_t* const)0x40080610U,   /** @brief OTG_HS host channel-8 transfer size register */
        [9]  = (RW_ uint32_t* const)0x40080630U,   /** @brief OTG_HS host channel-9 transfer size register */
        [10] = (RW_ uint32_t* const)0x40080650U,   /** @brief OTG_HS host channel-10 transfer size register */
        [11] = (RW_ uint32_t* const)0x40080670U,   /** @brief OTG_HS host channel-11 transfer size register */
        [12] = (RW_ uint32_t* const)0x40080688U,   /** @brief OTG_HS host channel-12 transfer size register */
        [13] = (RW_ uint32_t* const)0x400806A0U,   /** @brief OTG_HS host channel-13 transfer size register */
        [14] = (RW_ uint32_t* const)0x400806B8U,   /** @brief OTG_HS host channel-14 transfer size register */
        [15] = (RW_ uint32_t* const)0x400806D0U,   /** @brief OTG_HS host channel-15 transfer size register */
      },
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCDMAx_PTR[3][16] = {
      [0] = {
        [0]  = (RW_ uint32_t* const)0x40040514U,   /** @brief OTG_HS host channel-0 DMA address register */
        [1]  = (RW_ uint32_t* const)0x40040534U,   /** @brief OTG_HS host channel-1 DMA address register */
        [2]  = (RW_ uint32_t* const)0x40040554U,   /** @brief OTG_HS host channel-2 DMA address register */
        [3]  = (RW_ uint32_t* const)0x40040574U,   /** @brief OTG_HS host channel-3 DMA address register */
        [4]  = (RW_ uint32_t* const)0x40040594U,   /** @brief OTG_HS host channel-4 DMA address register */
        [5]  = (RW_ uint32_t* const)0x400405B4U,   /** @brief OTG_HS host channel-5 DMA address register */
        [6]  = (RW_ uint32_t* const)0x400405D4U,   /** @brief OTG_HS host channel-6 DMA address register */
        [7]  = (RW_ uint32_t* const)0x400405F4U,   /** @brief OTG_HS host channel-7 DMA address register */
        [8]  = (RW_ uint32_t* const)0x40040614U,   /** @brief OTG_HS host channel-8 DMA address register */
        [9]  = (RW_ uint32_t* const)0x40040634U,   /** @brief OTG_HS host channel-9 DMA address register */
        [10] = (RW_ uint32_t* const)0x40040654U,   /** @brief OTG_HS host channel-10 DMA address register */
        [11] = (RW_ uint32_t* const)0x40040674U,   /** @brief OTG_HS host channel-11 DMA address register */
        [12] = (RW_ uint32_t* const)0x4004068CU,   /** @brief OTG_HS host channel-12 DMA address register */
        [13] = (RW_ uint32_t* const)0x400406A4U,   /** @brief OTG_HS host channel-13 DMA address register */
        [14] = (RW_ uint32_t* const)0x400406BCU,   /** @brief OTG_HS host channel-14 DMA address register */
        [15] = (RW_ uint32_t* const)0x400406D4U,   /** @brief OTG_HS host channel-15 DMA address register */
      },
      [1] = {
        [0]  = (RW_ uint32_t* const)0x40080514U,   /** @brief OTG_HS host channel-0 DMA address register */
        [1]  = (RW_ uint32_t* const)0x40080534U,   /** @brief OTG_HS host channel-1 DMA address register */
        [2]  = (RW_ uint32_t* const)0x40080554U,   /** @brief OTG_HS host channel-2 DMA address register */
        [3]  = (RW_ uint32_t* const)0x40080574U,   /** @brief OTG_HS host channel-3 DMA address register */
        [4]  = (RW_ uint32_t* const)0x40080594U,   /** @brief OTG_HS host channel-4 DMA address register */
        [5]  = (RW_ uint32_t* const)0x400805B4U,   /** @brief OTG_HS host channel-5 DMA address register */
        [6]  = (RW_ uint32_t* const)0x400805D4U,   /** @brief OTG_HS host channel-6 DMA address register */
        [7]  = (RW_ uint32_t* const)0x400805F4U,   /** @brief OTG_HS host channel-7 DMA address register */
        [8]  = (RW_ uint32_t* const)0x40080614U,   /** @brief OTG_HS host channel-8 DMA address register */
        [9]  = (RW_ uint32_t* const)0x40080634U,   /** @brief OTG_HS host channel-9 DMA address register */
        [10] = (RW_ uint32_t* const)0x40080654U,   /** @brief OTG_HS host channel-10 DMA address register */
        [11] = (RW_ uint32_t* const)0x40080674U,   /** @brief OTG_HS host channel-11 DMA address register */
        [12] = (RW_ uint32_t* const)0x4008068CU,   /** @brief OTG_HS host channel-12 DMA address register */
        [13] = (RW_ uint32_t* const)0x400806A4U,   /** @brief OTG_HS host channel-13 DMA address register */
        [14] = (RW_ uint32_t* const)0x400806BCU,   /** @brief OTG_HS host channel-14 DMA address register */
        [15] = (RW_ uint32_t* const)0x400806D4U,   /** @brief OTG_HS host channel-15 DMA address register */
      },
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK12_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40040684U,   /** @brief OTG_HS host channel-12 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x40080684U,   /** @brief OTG_HS host channel-12 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK13_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4004069CU,   /** @brief OTG_HS host channel-13 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x4008069CU,   /** @brief OTG_HS host channel-13 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK14_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400406B4U,   /** @brief OTG_HS host channel-14 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x400806B4U,   /** @brief OTG_HS host channel-14 interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK15_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400406CCU,   /** @brief OTG_HS host channel-15 interrupt mask register */
      [2] = (RW_ uint32_t* const)0x400806CCU,   /** @brief OTG_HS host channel-15 interrupt mask register */
    };

    /**** @subsection Enumerated OTGx_HS_HOST Register Reset Values ****/

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCFG_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCFG register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCFG register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HFIR_RST[3] = {
      [1] = 0x0000EA60U,   /** @brief OTG_HS_HFIR register reset value */
      [2] = 0x0000EA60U,   /** @brief OTG_HS_HFIR register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_RST[3] = {
      [1] = 0x00003FFFU,   /** @brief OTG_HS_HFNUM register reset value */
      [2] = 0x00003FFFU,   /** @brief OTG_HS_HFNUM register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_RST[3] = {
      [1] = 0x00080100U,   /** @brief OTG_HS_HPTXSTS register reset value */
      [2] = 0x00080100U,   /** @brief OTG_HS_HPTXSTS register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINT_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HAINT register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HAINT register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HAINTMSK register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HAINTMSK register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HPRT register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HPRT register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_RST[3][16] = {
      [0] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCCHAR10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCCHAR11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCCHAR12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCCHAR13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCCHAR14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCCHAR15 register reset value. */
      },
      [1] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCCHAR9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCCHAR10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCCHAR11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCCHAR12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCCHAR13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCCHAR14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCCHAR15 register reset value. */
      },
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_RST[3][16] = {
      [0] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCSPLT10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCSPLT11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCSPLT12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCSPLT13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCSPLT14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCSPLT15 register reset value. */
      },
      [1] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCSPLT9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCSPLT10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCSPLT11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCSPLT12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCSPLT13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCSPLT14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCSPLT15 register reset value. */
      },
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_RST[3][16] = {
      [0] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCINT0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCINT1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCINT2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCINT3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCINT4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCINT5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCINT6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCINT7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCINT8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCINT9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCINT10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCINT11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCINT12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCINT13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCINT14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCINT15 register reset value. */
      },
      [1] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCINT0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCINT1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCINT2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCINT3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCINT4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCINT5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCINT6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCINT7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCINT8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCINT9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCINT10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCINT11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCINT12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCINT13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCINT14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCINT15 register reset value. */
      },
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK0 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK0 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK1 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK1 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK2 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK2 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK3 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK3 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK4 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK4 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK5 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK5 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK6 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK6 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK7 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK7 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK8 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK8 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK9 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK9 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK10 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK10 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK11 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK11 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_RST[3][16] = {
      [0] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ15 register reset value. */
      },
      [1] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCTSIZ9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCTSIZ15 register reset value. */
      },
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCDMAx_RST[3][16] = {
      [0] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCDMA0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCDMA1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCDMA2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCDMA3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCDMA4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCDMA5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCDMA6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCDMA7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCDMA8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCDMA9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCDMA10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCDMA11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCDMA12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCDMA13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCDMA14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCDMA15 register reset value. */
      },
      [1] = {
        [0]  = 0x00000000U,   /** @brief OTG_HS_HCDMA0 register reset value. */
        [1]  = 0x00000000U,   /** @brief OTG_HS_HCDMA1 register reset value. */
        [2]  = 0x00000000U,   /** @brief OTG_HS_HCDMA2 register reset value. */
        [3]  = 0x00000000U,   /** @brief OTG_HS_HCDMA3 register reset value. */
        [4]  = 0x00000000U,   /** @brief OTG_HS_HCDMA4 register reset value. */
        [5]  = 0x00000000U,   /** @brief OTG_HS_HCDMA5 register reset value. */
        [6]  = 0x00000000U,   /** @brief OTG_HS_HCDMA6 register reset value. */
        [7]  = 0x00000000U,   /** @brief OTG_HS_HCDMA7 register reset value. */
        [8]  = 0x00000000U,   /** @brief OTG_HS_HCDMA8 register reset value. */
        [9]  = 0x00000000U,   /** @brief OTG_HS_HCDMA9 register reset value. */
        [10] = 0x00000000U,   /** @brief OTG_HS_HCDMA10 register reset value. */
        [11] = 0x00000000U,   /** @brief OTG_HS_HCDMA11 register reset value. */
        [12] = 0x00000000U,   /** @brief OTG_HS_HCDMA12 register reset value. */
        [13] = 0x00000000U,   /** @brief OTG_HS_HCDMA13 register reset value. */
        [14] = 0x00000000U,   /** @brief OTG_HS_HCDMA14 register reset value. */
        [15] = 0x00000000U,   /** @brief OTG_HS_HCDMA15 register reset value. */
      },
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK12 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK12 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK13 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK13 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK14 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK14 register reset value */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK15 register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_HCINTMSK15 register reset value */
    };

    /**** @subsection Enumerated OTGx_HS_HOST Register Value Types ****/

    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCFG_t;         /** @brief OTG_HS_HCFG register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HFIR_t;         /** @brief OTG_HS_HFIR register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_t;        /** @brief OTG_HS_HFNUM register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_t;      /** @brief OTG_HS_HPTXSTS register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HAINT_t;        /** @brief OTG_HS_HAINT register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_t;     /** @brief OTG_HS_HAINTMSK register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HPRT_t;         /** @brief OTG_HS_HPRT register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_t;      /** @brief OTG_HS_HCCHARx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_t;      /** @brief OTG_HS_HCSPLTx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_t;       /** @brief OTG_HS_HCINTx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_t;    /** @brief OTG_HS_HCINTMSK0 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_t;    /** @brief OTG_HS_HCINTMSK1 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_t;    /** @brief OTG_HS_HCINTMSK2 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_t;    /** @brief OTG_HS_HCINTMSK3 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_t;    /** @brief OTG_HS_HCINTMSK4 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_t;    /** @brief OTG_HS_HCINTMSK5 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_t;    /** @brief OTG_HS_HCINTMSK6 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_t;    /** @brief OTG_HS_HCINTMSK7 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_t;    /** @brief OTG_HS_HCINTMSK8 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_t;    /** @brief OTG_HS_HCINTMSK9 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_t;   /** @brief OTG_HS_HCINTMSK10 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_t;   /** @brief OTG_HS_HCINTMSK11 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_t;      /** @brief OTG_HS_HCTSIZx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCDMAx_t;       /** @brief OTG_HS_HCDMAx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_t;   /** @brief OTG_HS_HCINTMSK12 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_t;   /** @brief OTG_HS_HCINTMSK13 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_t;   /** @brief OTG_HS_HCINTMSK14 register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_t;   /** @brief OTG_HS_HCINTMSK15 register value type. */

    /**** @subsection Enumerated OTGx_HS_HOST Register Pointer Types ****/

    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCFG_PTR_t;         /** @brief OTG_HS_HCFG register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HFIR_PTR_t;         /** @brief OTG_HS_HFIR register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HFNUM_PTR_t;        /** @brief OTG_HS_HFNUM register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HPTXSTS_PTR_t;      /** @brief OTG_HS_HPTXSTS register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HAINT_PTR_t;        /** @brief OTG_HS_HAINT register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HAINTMSK_PTR_t;     /** @brief OTG_HS_HAINTMSK register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HPRT_PTR_t;         /** @brief OTG_HS_HPRT register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCCHARx_PTR_t;      /** @brief OTG_HS_HCCHARx register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCSPLTx_PTR_t;      /** @brief OTG_HS_HCSPLTx register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTx_PTR_t;       /** @brief OTG_HS_HCINTx register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK0_PTR_t;    /** @brief OTG_HS_HCINTMSK0 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK1_PTR_t;    /** @brief OTG_HS_HCINTMSK1 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK2_PTR_t;    /** @brief OTG_HS_HCINTMSK2 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK3_PTR_t;    /** @brief OTG_HS_HCINTMSK3 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK4_PTR_t;    /** @brief OTG_HS_HCINTMSK4 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK5_PTR_t;    /** @brief OTG_HS_HCINTMSK5 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK6_PTR_t;    /** @brief OTG_HS_HCINTMSK6 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK7_PTR_t;    /** @brief OTG_HS_HCINTMSK7 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK8_PTR_t;    /** @brief OTG_HS_HCINTMSK8 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK9_PTR_t;    /** @brief OTG_HS_HCINTMSK9 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK10_PTR_t;   /** @brief OTG_HS_HCINTMSK10 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK11_PTR_t;   /** @brief OTG_HS_HCINTMSK11 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCTSIZx_PTR_t;      /** @brief OTG_HS_HCTSIZx register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCDMAx_PTR_t;       /** @brief OTG_HS_HCDMAx register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK12_PTR_t;   /** @brief OTG_HS_HCINTMSK12 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK13_PTR_t;   /** @brief OTG_HS_HCINTMSK13 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK14_PTR_t;   /** @brief OTG_HS_HCINTMSK14 register pointer type. */
    typedef uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSK15_PTR_t;   /** @brief OTG_HS_HCINTMSK15 register pointer type. */

    /**** @subsection OTGx_HS_HOST Register Field Masks ****/

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSPCS_MASK        = 0x00000003U;   /** @brief FS/LS PHY clock select */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSS_MASK          = 0x00000004U;   /** @brief FS- and ls-only support */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HFIR_FRIVL_MASK          = 0x0000FFFFU;   /** @brief Frame interval */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_FRNUM_MASK         = 0x0000FFFFU;   /** @brief Frame number */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_FTREM_MASK         = 0xFFFF0000U;   /** @brief Frame time remaining */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL_MASK    = 0x0000FFFFU;   /** @brief Periodic transmit data FIFO space available */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV_MASK     = 0x00FF0000U;   /** @brief Periodic transmit request queue space available */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP_MASK     = 0xFF000000U;   /** @brief Top of the periodic transmit request queue */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINT_HAINT_MASK         = 0x0000FFFFU;   /** @brief Channel interrupts */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_HAINTM_MASK     = 0x0000FFFFU;   /** @brief Channel interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PCSTS_MASK          = 0x00000001U;   /** @brief Port connect status */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PCDET_MASK          = 0x00000002U;   /** @brief Port connect detected */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PENA_MASK           = 0x00000004U;   /** @brief Port enable */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PENCHNG_MASK        = 0x00000008U;   /** @brief Port enable/disable change */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_POCA_MASK           = 0x00000010U;   /** @brief Port overcurrent active */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_POCCHNG_MASK        = 0x00000020U;   /** @brief Port overcurrent change */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PRES_MASK           = 0x00000040U;   /** @brief Port resume */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PSUSP_MASK          = 0x00000080U;   /** @brief Port suspend */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PRST_MASK           = 0x00000100U;   /** @brief Port reset */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PLSTS_MASK          = 0x00000C00U;   /** @brief Port line status */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PPWR_MASK           = 0x00001000U;   /** @brief Port power */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PTCTL_MASK          = 0x0001E000U;   /** @brief Port test control */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PSPD_MASK           = 0x00060000U;   /** @brief Port speed */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MPSIZ_MASK       = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPNUM_MASK       = 0x00007800U;   /** @brief Endpoint number */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPDIR_MASK       = 0x00008000U;   /** @brief Endpoint direction */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_LSDEV_MASK       = 0x00020000U;   /** @brief Low-speed device */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPTYP_MASK       = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MC_MASK          = 0x00300000U;   /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_DAD_MASK         = 0x1FC00000U;   /** @brief Device address */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_ODDFRM_MASK      = 0x20000000U;   /** @brief Odd frame */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHDIS_MASK       = 0x40000000U;   /** @brief Channel disable */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHENA_MASK       = 0x80000000U;   /** @brief Channel enable */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_PRTADDR_MASK     = 0x0000007FU;   /** @brief Port address */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_HUBADDR_MASK     = 0x00003F80U;   /** @brief Hub address */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_XACTPOS_MASK     = 0x0000C000U;   /** @brief XACTPOS */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_COMPLSPLT_MASK   = 0x00010000U;   /** @brief Do complete split */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_SPLITEN_MASK     = 0x80000000U;   /** @brief Split enable */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_XFRC_MASK         = 0x00000001U;   /** @brief Transfer completed */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_CHH_MASK          = 0x00000002U;   /** @brief Channel halted */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_AHBERR_MASK       = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_STALL_MASK        = 0x00000008U;   /** @brief STALL response received interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_NAK_MASK          = 0x00000010U;   /** @brief NAK response received interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_ACK_MASK          = 0x00000020U;   /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_NYET_MASK         = 0x00000040U;   /** @brief Response received interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_TXERR_MASK        = 0x00000080U;   /** @brief Transaction error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_BBERR_MASK        = 0x00000100U;   /** @brief Babble error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_FRMOR_MASK        = 0x00000200U;   /** @brief Frame overrun */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_DTERR_MASK        = 0x00000400U;   /** @brief Data toggle error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_XFRCM_MASK     = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_CHHM_MASK      = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_AHBERR_MASK    = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_STALLM_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_NAKM_MASK      = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_ACKM_MASK      = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_NYET_MASK      = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_TXERRM_MASK    = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_BBERRM_MASK    = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_FRMORM_MASK    = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_DTERRM_MASK    = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_XFRCM_MASK    = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_CHHM_MASK     = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_AHBERR_MASK   = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_STALLM_MASK   = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_NAKM_MASK     = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_ACKM_MASK     = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_NYET_MASK     = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_TXERRM_MASK   = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_BBERRM_MASK   = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_FRMORM_MASK   = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_DTERRM_MASK   = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_XFRCM_MASK    = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_CHHM_MASK     = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_AHBERR_MASK   = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_STALLM_MASK   = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_NAKM_MASK     = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_ACKM_MASK     = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_NYET_MASK     = 0x00000040U;   /** @brief Response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_TXERRM_MASK   = 0x00000080U;   /** @brief Transaction error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_BBERRM_MASK   = 0x00000100U;   /** @brief Babble error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_FRMORM_MASK   = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_DTERRM_MASK   = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_XFRSIZ_MASK      = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_PKTCNT_MASK      = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_DPID_MASK        = 0x60000000U;   /** @brief Data PID */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_XFRCM_MASK    = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_CHHM_MASK     = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_AHBERR_MASK   = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_STALLM_MASK   = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_NAKM_MASK     = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_ACKM_MASK     = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_NYET_MASK     = 0x00000040U;   /** @brief Response received interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_TXERRM_MASK   = 0x00000080U;   /** @brief Transaction error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_BBERRM_MASK   = 0x00000100U;   /** @brief Babble error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_FRMORM_MASK   = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_DTERRM_MASK   = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_XFRCM_MASK    = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_CHHM_MASK     = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_AHBERR_MASK   = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_STALLM_MASK   = 0x00000008U;   /** @brief STALLM response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_NAKM_MASK     = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_ACKM_MASK     = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_NYET_MASK     = 0x00000040U;   /** @brief Response received interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_TXERRM_MASK   = 0x00000080U;   /** @brief Transaction error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_BBERRM_MASK   = 0x00000100U;   /** @brief Babble error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_FRMORM_MASK   = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_DTERRM_MASK   = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_XFRCM_MASK    = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_CHHM_MASK     = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_AHBERR_MASK   = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_STALLM_MASK   = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_NAKM_MASK     = 0x00000010U;   /** @brief NAKM response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_ACKM_MASK     = 0x00000020U;   /** @brief ACKM response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_NYET_MASK     = 0x00000040U;   /** @brief Response received interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_TXERRM_MASK   = 0x00000080U;   /** @brief Transaction error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_BBERRM_MASK   = 0x00000100U;   /** @brief Babble error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_FRMORM_MASK   = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_DTERRM_MASK   = 0x00000400U;   /** @brief Data toggle error mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_XFRCM_MASK    = 0x00000001U;   /** @brief Transfer completed mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_CHHM_MASK     = 0x00000002U;   /** @brief Channel halted mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_AHBERR_MASK   = 0x00000004U;   /** @brief AHB error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_STALL_MASK    = 0x00000008U;   /** @brief STALL response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_NAKM_MASK     = 0x00000010U;   /** @brief NAK response received interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_ACKM_MASK     = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_NYET_MASK     = 0x00000040U;   /** @brief Response received interrupt */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_TXERRM_MASK   = 0x00000080U;   /** @brief Transaction error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_BBERRM_MASK   = 0x00000100U;   /** @brief Babble error */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_FRMORM_MASK   = 0x00000200U;   /** @brief Frame overrun mask */
    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_DTERRM_MASK   = 0x00000400U;   /** @brief Data toggle error mask */

    /**** @subsection OTGx_HS_HOST Register Field Positions ****/

    static const int32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSPCS_POS        = 0;    /** @brief FS/LS PHY clock select */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSS_POS          = 2;    /** @brief FS- and ls-only support */
    static const int32_t OTGx_HS_HOST_OTG_HS_HFIR_FRIVL_POS          = 0;    /** @brief Frame interval */
    static const int32_t OTGx_HS_HOST_OTG_HS_HFNUM_FRNUM_POS         = 0;    /** @brief Frame number */
    static const int32_t OTGx_HS_HOST_OTG_HS_HFNUM_FTREM_POS         = 16;   /** @brief Frame time remaining */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL_POS    = 0;    /** @brief Periodic transmit data FIFO space available */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV_POS     = 16;   /** @brief Periodic transmit request queue space available */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP_POS     = 24;   /** @brief Top of the periodic transmit request queue */
    static const int32_t OTGx_HS_HOST_OTG_HS_HAINT_HAINT_POS         = 0;    /** @brief Channel interrupts */
    static const int32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_HAINTM_POS     = 0;    /** @brief Channel interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PCSTS_POS          = 0;    /** @brief Port connect status */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PCDET_POS          = 1;    /** @brief Port connect detected */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PENA_POS           = 2;    /** @brief Port enable */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PENCHNG_POS        = 3;    /** @brief Port enable/disable change */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_POCA_POS           = 4;    /** @brief Port overcurrent active */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_POCCHNG_POS        = 5;    /** @brief Port overcurrent change */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PRES_POS           = 6;    /** @brief Port resume */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PSUSP_POS          = 7;    /** @brief Port suspend */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PRST_POS           = 8;    /** @brief Port reset */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PLSTS_POS          = 10;   /** @brief Port line status */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PPWR_POS           = 12;   /** @brief Port power */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PTCTL_POS          = 13;   /** @brief Port test control */
    static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PSPD_POS           = 17;   /** @brief Port speed */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MPSIZ_POS       = 0;    /** @brief Maximum packet size */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPNUM_POS       = 11;   /** @brief Endpoint number */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPDIR_POS       = 15;   /** @brief Endpoint direction */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_LSDEV_POS       = 17;   /** @brief Low-speed device */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPTYP_POS       = 18;   /** @brief Endpoint type */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MC_POS          = 20;   /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_DAD_POS         = 22;   /** @brief Device address */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_ODDFRM_POS      = 29;   /** @brief Odd frame */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHDIS_POS       = 30;   /** @brief Channel disable */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHENA_POS       = 31;   /** @brief Channel enable */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_PRTADDR_POS     = 0;    /** @brief Port address */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_HUBADDR_POS     = 7;    /** @brief Hub address */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_XACTPOS_POS     = 14;   /** @brief XACTPOS */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_COMPLSPLT_POS   = 16;   /** @brief Do complete split */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_SPLITEN_POS     = 31;   /** @brief Split enable */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_XFRC_POS         = 0;    /** @brief Transfer completed */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_CHH_POS          = 1;    /** @brief Channel halted */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_AHBERR_POS       = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_STALL_POS        = 3;    /** @brief STALL response received interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_NAK_POS          = 4;    /** @brief NAK response received interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_ACK_POS          = 5;    /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_NYET_POS         = 6;    /** @brief Response received interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_TXERR_POS        = 7;    /** @brief Transaction error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_BBERR_POS        = 8;    /** @brief Babble error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_FRMOR_POS        = 9;    /** @brief Frame overrun */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_DTERR_POS        = 10;   /** @brief Data toggle error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK0_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK1_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK2_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK3_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK4_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK5_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK6_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK7_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK8_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_XFRCM_POS     = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_CHHM_POS      = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_AHBERR_POS    = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_STALLM_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_NAKM_POS      = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_ACKM_POS      = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_NYET_POS      = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_TXERRM_POS    = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_BBERRM_POS    = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_FRMORM_POS    = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK9_DTERRM_POS    = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_XFRCM_POS    = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_CHHM_POS     = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_AHBERR_POS   = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_STALLM_POS   = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_NAKM_POS     = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_ACKM_POS     = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_NYET_POS     = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_TXERRM_POS   = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_BBERRM_POS   = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_FRMORM_POS   = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK10_DTERRM_POS   = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_XFRCM_POS    = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_CHHM_POS     = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_AHBERR_POS   = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_STALLM_POS   = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_NAKM_POS     = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_ACKM_POS     = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_NYET_POS     = 6;    /** @brief Response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_TXERRM_POS   = 7;    /** @brief Transaction error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_BBERRM_POS   = 8;    /** @brief Babble error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_FRMORM_POS   = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK11_DTERRM_POS   = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_XFRSIZ_POS      = 0;    /** @brief Transfer size */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_PKTCNT_POS      = 19;   /** @brief Packet count */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_DPID_POS        = 29;   /** @brief Data PID */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_XFRCM_POS    = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_CHHM_POS     = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_AHBERR_POS   = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_STALLM_POS   = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_NAKM_POS     = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_ACKM_POS     = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_NYET_POS     = 6;    /** @brief Response received interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_TXERRM_POS   = 7;    /** @brief Transaction error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_BBERRM_POS   = 8;    /** @brief Babble error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_FRMORM_POS   = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK12_DTERRM_POS   = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_XFRCM_POS    = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_CHHM_POS     = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_AHBERR_POS   = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_STALLM_POS   = 3;    /** @brief STALLM response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_NAKM_POS     = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_ACKM_POS     = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_NYET_POS     = 6;    /** @brief Response received interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_TXERRM_POS   = 7;    /** @brief Transaction error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_BBERRM_POS   = 8;    /** @brief Babble error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_FRMORM_POS   = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK13_DTERRM_POS   = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_XFRCM_POS    = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_CHHM_POS     = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_AHBERR_POS   = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_STALLM_POS   = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_NAKM_POS     = 4;    /** @brief NAKM response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_ACKM_POS     = 5;    /** @brief ACKM response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_NYET_POS     = 6;    /** @brief Response received interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_TXERRM_POS   = 7;    /** @brief Transaction error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_BBERRM_POS   = 8;    /** @brief Babble error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_FRMORM_POS   = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK14_DTERRM_POS   = 10;   /** @brief Data toggle error mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_XFRCM_POS    = 0;    /** @brief Transfer completed mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_CHHM_POS     = 1;    /** @brief Channel halted mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_AHBERR_POS   = 2;    /** @brief AHB error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_STALL_POS    = 3;    /** @brief STALL response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_NAKM_POS     = 4;    /** @brief NAK response received interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_ACKM_POS     = 5;    /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_NYET_POS     = 6;    /** @brief Response received interrupt */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_TXERRM_POS   = 7;    /** @brief Transaction error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_BBERRM_POS   = 8;    /** @brief Babble error */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_FRMORM_POS   = 9;    /** @brief Frame overrun mask */
    static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSK15_DTERRM_POS   = 10;   /** @brief Data toggle error mask */

    /**********************************************************************************************
     * @section OTG1_HS_DEVICE Register Information
     **********************************************************************************************/

    /**** @subsection OTG1_HS_DEVICE Register Pointers ****/

    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DCFG_PTR          = (RW_ uint32_t* const)0x40040800U;   /** @brief OTG_HS device configuration register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DCTL_PTR          = (RW_ uint32_t* const)0x40040804U;   /** @brief OTG_HS device control register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DSTS_PTR          = (RO_ uint32_t* const)0x40040808U;   /** @brief OTG_HS device status register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPMSK_PTR       = (RW_ uint32_t* const)0x40040810U;   /** @brief OTG_HS device IN endpoint common interrupt mask register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPMSK_PTR       = (RW_ uint32_t* const)0x40040814U;   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DAINT_PTR         = (RO_ uint32_t* const)0x40040818U;   /** @brief OTG_HS device all endpoints interrupt register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DAINTMSK_PTR      = (RW_ uint32_t* const)0x4004081CU;   /** @brief OTG_HS all endpoints interrupt mask register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_PTR      = (RW_ uint32_t* const)0x40040828U;   /** @brief OTG_HS device VBUS discharge time register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_PTR    = (RW_ uint32_t* const)0x4004082CU;   /** @brief OTG_HS device VBUS pulsing time register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTHRCTL_PTR       = (RW_ uint32_t* const)0x40040830U;   /** @brief OTG_HS device threshold control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_PTR    = (RW_ uint32_t* const)0x40040834U;   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DEACHINT_PTR      = (RW_ uint32_t* const)0x40040838U;   /** @brief OTG_HS device each endpoint interrupt register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_PTR   = (RW_ uint32_t* const)0x4004083CU;   /** @brief OTG_HS device each endpoint interrupt register mask */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PTR     = (RW_ uint32_t* const)0x40040910U;   /** @brief OTG_HS device IN endpoint 0 transfer size register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_PTR      = (RO_ uint32_t* const)0x40040918U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_PTR      = (RO_ uint32_t* const)0x40040938U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_PTR      = (RO_ uint32_t* const)0x40040958U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_PTR      = (RO_ uint32_t* const)0x40040978U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_PTR      = (RO_ uint32_t* const)0x40040998U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_PTR      = (RO_ uint32_t* const)0x400409B8U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PTR     = (RW_ uint32_t* const)0x40040930U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PTR     = (RW_ uint32_t* const)0x40040950U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PTR     = (RW_ uint32_t* const)0x40040970U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PTR     = (RW_ uint32_t* const)0x40040990U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PTR     = (RW_ uint32_t* const)0x400409B0U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_PTR      = (RW_ uint32_t* const)0x40040B00U;   /** @brief OTG_HS device control OUT endpoint 0 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_PTR      = (RW_ uint32_t* const)0x40040B20U;   /** @brief OTG device endpoint-1 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_PTR      = (RW_ uint32_t* const)0x40040B40U;   /** @brief OTG device endpoint-2 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_PTR      = (RW_ uint32_t* const)0x40040B60U;   /** @brief OTG device endpoint-3 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_PTR     = (RW_ uint32_t* const)0x40040B10U;   /** @brief OTG_HS device endpoint-0 transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PTR     = (RW_ uint32_t* const)0x40040B30U;   /** @brief OTG_HS device endpoint-1 transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PTR     = (RW_ uint32_t* const)0x40040B50U;   /** @brief OTG_HS device endpoint-2 transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PTR     = (RW_ uint32_t* const)0x40040B70U;   /** @brief OTG_HS device endpoint-3 transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PTR     = (RW_ uint32_t* const)0x40040B90U;   /** @brief OTG_HS device endpoint-4 transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_PTR     = (RW_ uint32_t* const)0x400409A0U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_PTR      = (RW_ uint32_t* const)0x400409A4U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PTR     = (RW_ uint32_t* const)0x400409A8U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_PTR      = (RW_ uint32_t* const)0x400409ACU;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_PTR      = (RW_ uint32_t* const)0x40040B80U;   /** @brief OTG device endpoint-4 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_PTR      = (RW_ uint32_t* const)0x40040BA0U;   /** @brief OTG device endpoint-5 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_PTR      = (RW_ uint32_t* const)0x40040BC0U;   /** @brief OTG device endpoint-6 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_PTR      = (RW_ uint32_t* const)0x40040BE0U;   /** @brief OTG device endpoint-7 control register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PTR     = (RW_ uint32_t* const)0x40040BB0U;   /** @brief OTG_HS device endpoint-5 transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PTR     = (RW_ uint32_t* const)0x40040BD0U;   /** @brief OTG_HS device endpoint-6 transfer size register */
    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PTR     = (RW_ uint32_t* const)0x40040BF0U;   /** @brief OTG_HS device endpoint-7 transfer size register */

    /**** @subsection Enumerated OTG1_HS_DEVICE Register Pointers ****/

    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40040900U,   /** @brief OTG device endpoint-0 control register */
      [1] = (RW_ uint32_t* const)0x40040920U,   /** @brief OTG device endpoint-1 control register */
      [2] = (RW_ uint32_t* const)0x40040940U,   /** @brief OTG device endpoint-2 control register */
      [3] = (RW_ uint32_t* const)0x40040960U,   /** @brief OTG device endpoint-3 control register */
      [4] = (RW_ uint32_t* const)0x40040980U,   /** @brief OTG device endpoint-4 control register */
      [5] = (RW_ uint32_t* const)0x400409A0U,   /** @brief OTG device endpoint-5 control register */
      [6] = (RW_ uint32_t* const)0x400409C0U,   /** @brief OTG device endpoint-6 control register */
      [7] = (RW_ uint32_t* const)0x400409E0U,   /** @brief OTG device endpoint-7 control register */
    };

    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPINTx_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40040908U,   /** @brief OTG device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40040928U,   /** @brief OTG device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40040948U,   /** @brief OTG device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40040968U,   /** @brief OTG device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40040988U,   /** @brief OTG device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x400409A8U,   /** @brief OTG device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x400409C8U,   /** @brief OTG device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x400409E8U,   /** @brief OTG device endpoint-7 interrupt register */
    };

    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPDMAx_PTR[6] = {
      [1] = (RW_ uint32_t* const)0x40040914U,   /** @brief OTG_HS device endpoint-1 DMA address register */
      [2] = (RW_ uint32_t* const)0x40040934U,   /** @brief OTG_HS device endpoint-2 DMA address register */
      [3] = (RW_ uint32_t* const)0x40040954U,   /** @brief OTG_HS device endpoint-3 DMA address register */
      [4] = (RW_ uint32_t* const)0x40040974U,   /** @brief OTG_HS device endpoint-4 DMA address register */
      [5] = (RW_ uint32_t* const)0x40040994U,   /** @brief OTG_HS device endpoint-5 DMA address register */
    };

    static RW_ uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPINTx_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40040B08U,   /** @brief OTG_HS device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40040B28U,   /** @brief OTG_HS device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40040B48U,   /** @brief OTG_HS device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40040B68U,   /** @brief OTG_HS device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40040B88U,   /** @brief OTG_HS device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x40040BA8U,   /** @brief OTG_HS device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x40040BC8U,   /** @brief OTG_HS device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x40040BE8U,   /** @brief OTG_HS device endpoint-7 interrupt register */
    };

    /**** @subsection OTG1_HS_DEVICE Register Reset Values ****/

    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_RST          = 0x02200000U;   /** @brief OTG_HS_DCFG register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_RST          = 0x00000000U;   /** @brief OTG_HS_DCTL register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_RST          = 0x00000010U;   /** @brief OTG_HS_DSTS register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_RST       = 0x00000000U;   /** @brief OTG_HS_DIEPMSK register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_RST       = 0x00000000U;   /** @brief OTG_HS_DOEPMSK register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DAINT_RST         = 0x00000000U;   /** @brief OTG_HS_DAINT register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_RST      = 0x00000000U;   /** @brief OTG_HS_DAINTMSK register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_RST      = 0x000017D7U;   /** @brief OTG_HS_DVBUSDIS register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_RST    = 0x000005B8U;   /** @brief OTG_HS_DVBUSPULSE register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RST       = 0x00000000U;   /** @brief OTG_HS_DTHRCTL register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_RST    = 0x00000000U;   /** @brief OTG_HS_DIEPEMPMSK register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_RST      = 0x00000000U;   /** @brief OTG_HS_DEACHINT register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_RST   = 0x00000000U;   /** @brief OTG_HS_DEACHINTMSK register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ0 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS0 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS1 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS2 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS3 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS4 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS5 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ1 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ2 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ3 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ4 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ5 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_RST      = 0x00008000U;   /** @brief OTG_HS_DOEPCTL0 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL1 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL2 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL3 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ0 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ1 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ2 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ3 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ4 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ6 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS6 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ7 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS7 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL4 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL5 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL6 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL7 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ5 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ6 register reset value. */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ7 register reset value. */

    /**** @subsection Enumerated OTG1_HS_DEVICE Register Reset Values ****/

    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_RST[8] = {
      [0] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL0 register reset value. */
      [1] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL5 register reset value. */
      [6] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL6 register reset value. */
      [7] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL7 register reset value. */
    };

    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_RST[8] = {
      [0] = 0x00000080U,   /** @brief OTG_HS_DIEPINT0 register reset value. */
      [1] = 0x00000000U,   /** @brief OTG_HS_DIEPINT1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DIEPINT2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DIEPINT3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DIEPINT4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DIEPINT5 register reset value. */
      [6] = 0x00000000U,   /** @brief OTG_HS_DIEPINT6 register reset value. */
      [7] = 0x00000000U,   /** @brief OTG_HS_DIEPINT7 register reset value. */
    };

    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPDMAx_RST[6] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA5 register reset value. */
    };

    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_RST[8] = {
      [0] = 0x00000080U,   /** @brief OTG_HS_DOEPINT0 register reset value. */
      [1] = 0x00000000U,   /** @brief OTG_HS_DOEPINT1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DOEPINT2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DOEPINT3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DOEPINT4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DOEPINT5 register reset value. */
      [6] = 0x00000000U,   /** @brief OTG_HS_DOEPINT6 register reset value. */
      [7] = 0x00000000U,   /** @brief OTG_HS_DOEPINT7 register reset value. */
    };

    /**** @subsection Enumerated OTG1_HS_DEVICE Register Value Types ****/

    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_t;          /** @brief OTG_HS_DCFG register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_t;          /** @brief OTG_HS_DCTL register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_t;          /** @brief OTG_HS_DSTS register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_t;       /** @brief OTG_HS_DIEPMSK register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_t;       /** @brief OTG_HS_DOEPMSK register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DAINT_t;         /** @brief OTG_HS_DAINT register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_t;      /** @brief OTG_HS_DAINTMSK register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_t;      /** @brief OTG_HS_DVBUSDIS register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_t;    /** @brief OTG_HS_DVBUSPULSE register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_t;       /** @brief OTG_HS_DTHRCTL register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_t;    /** @brief OTG_HS_DIEPEMPMSK register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_t;      /** @brief OTG_HS_DEACHINT register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_t;   /** @brief OTG_HS_DEACHINTMSK register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_t;      /** @brief OTG_HS_DIEPCTLx register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_t;      /** @brief OTG_HS_DIEPINTx register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_t;     /** @brief OTG_HS_DIEPTSIZ0 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPDMAx_t;      /** @brief OTG_HS_DIEPDMAx register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_t;      /** @brief OTG_HS_DTXFSTS0 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_t;      /** @brief OTG_HS_DTXFSTS1 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_t;      /** @brief OTG_HS_DTXFSTS2 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_t;      /** @brief OTG_HS_DTXFSTS3 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_t;      /** @brief OTG_HS_DTXFSTS4 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_t;      /** @brief OTG_HS_DTXFSTS5 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_t;     /** @brief OTG_HS_DIEPTSIZ1 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_t;     /** @brief OTG_HS_DIEPTSIZ2 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_t;     /** @brief OTG_HS_DIEPTSIZ3 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_t;     /** @brief OTG_HS_DIEPTSIZ4 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_t;     /** @brief OTG_HS_DIEPTSIZ5 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_t;      /** @brief OTG_HS_DOEPCTL0 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_t;      /** @brief OTG_HS_DOEPCTL1 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_t;      /** @brief OTG_HS_DOEPCTL2 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_t;      /** @brief OTG_HS_DOEPCTL3 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_t;      /** @brief OTG_HS_DOEPINTx register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_t;     /** @brief OTG_HS_DOEPTSIZ0 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_t;     /** @brief OTG_HS_DOEPTSIZ1 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_t;     /** @brief OTG_HS_DOEPTSIZ2 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_t;     /** @brief OTG_HS_DOEPTSIZ3 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_t;     /** @brief OTG_HS_DOEPTSIZ4 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_t;     /** @brief OTG_HS_DIEPTSIZ6 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_t;      /** @brief OTG_HS_DTXFSTS6 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_t;     /** @brief OTG_HS_DIEPTSIZ7 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_t;      /** @brief OTG_HS_DTXFSTS7 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_t;      /** @brief OTG_HS_DOEPCTL4 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_t;      /** @brief OTG_HS_DOEPCTL5 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_t;      /** @brief OTG_HS_DOEPCTL6 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_t;      /** @brief OTG_HS_DOEPCTL7 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_t;     /** @brief OTG_HS_DOEPTSIZ5 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_t;     /** @brief OTG_HS_DOEPTSIZ6 register value type. */
    typedef uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_t;     /** @brief OTG_HS_DOEPTSIZ7 register value type. */

    /**** @subsection Enumerated OTG1_HS_DEVICE Register Pointer Types ****/

    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DCFG_PTR_t;          /** @brief OTG_HS_DCFG register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DCTL_PTR_t;          /** @brief OTG_HS_DCTL register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DSTS_PTR_t;          /** @brief OTG_HS_DSTS register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPMSK_PTR_t;       /** @brief OTG_HS_DIEPMSK register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPMSK_PTR_t;       /** @brief OTG_HS_DOEPMSK register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DAINT_PTR_t;         /** @brief OTG_HS_DAINT register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DAINTMSK_PTR_t;      /** @brief OTG_HS_DAINTMSK register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_PTR_t;      /** @brief OTG_HS_DVBUSDIS register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_PTR_t;    /** @brief OTG_HS_DVBUSPULSE register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTHRCTL_PTR_t;       /** @brief OTG_HS_DTHRCTL register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_PTR_t;    /** @brief OTG_HS_DIEPEMPMSK register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DEACHINT_PTR_t;      /** @brief OTG_HS_DEACHINT register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_PTR_t;   /** @brief OTG_HS_DEACHINTMSK register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_PTR_t;      /** @brief OTG_HS_DIEPCTLx register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPINTx_PTR_t;      /** @brief OTG_HS_DIEPINTx register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PTR_t;     /** @brief OTG_HS_DIEPTSIZ0 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPDMAx_PTR_t;      /** @brief OTG_HS_DIEPDMAx register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_PTR_t;      /** @brief OTG_HS_DTXFSTS0 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_PTR_t;      /** @brief OTG_HS_DTXFSTS1 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_PTR_t;      /** @brief OTG_HS_DTXFSTS2 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_PTR_t;      /** @brief OTG_HS_DTXFSTS3 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_PTR_t;      /** @brief OTG_HS_DTXFSTS4 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_PTR_t;      /** @brief OTG_HS_DTXFSTS5 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PTR_t;     /** @brief OTG_HS_DIEPTSIZ1 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PTR_t;     /** @brief OTG_HS_DIEPTSIZ2 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PTR_t;     /** @brief OTG_HS_DIEPTSIZ3 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PTR_t;     /** @brief OTG_HS_DIEPTSIZ4 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PTR_t;     /** @brief OTG_HS_DIEPTSIZ5 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_PTR_t;      /** @brief OTG_HS_DOEPCTL0 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_PTR_t;      /** @brief OTG_HS_DOEPCTL1 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_PTR_t;      /** @brief OTG_HS_DOEPCTL2 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_PTR_t;      /** @brief OTG_HS_DOEPCTL3 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPINTx_PTR_t;      /** @brief OTG_HS_DOEPINTx register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_PTR_t;     /** @brief OTG_HS_DOEPTSIZ0 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PTR_t;     /** @brief OTG_HS_DOEPTSIZ1 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PTR_t;     /** @brief OTG_HS_DOEPTSIZ2 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PTR_t;     /** @brief OTG_HS_DOEPTSIZ3 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PTR_t;     /** @brief OTG_HS_DOEPTSIZ4 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_PTR_t;     /** @brief OTG_HS_DIEPTSIZ6 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_PTR_t;      /** @brief OTG_HS_DTXFSTS6 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PTR_t;     /** @brief OTG_HS_DIEPTSIZ7 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_PTR_t;      /** @brief OTG_HS_DTXFSTS7 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_PTR_t;      /** @brief OTG_HS_DOEPCTL4 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_PTR_t;      /** @brief OTG_HS_DOEPCTL5 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_PTR_t;      /** @brief OTG_HS_DOEPCTL6 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_PTR_t;      /** @brief OTG_HS_DOEPCTL7 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PTR_t;     /** @brief OTG_HS_DOEPTSIZ5 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PTR_t;     /** @brief OTG_HS_DOEPTSIZ6 register pointer type. */
    typedef uint32_t* const OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PTR_t;     /** @brief OTG_HS_DOEPTSIZ7 register pointer type. */

    /**** @subsection OTG1_HS_DEVICE Register Field Masks ****/

    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD_MASK                  = 0x00000003U;   /** @brief Device speed */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK_MASK              = 0x00000004U;   /** @brief Nonzero-length status OUT handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_DAD_MASK                   = 0x000007F0U;   /** @brief Device address */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL_MASK                 = 0x00001800U;   /** @brief Periodic (micro)frame interval */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_MASK             = 0x03000000U;   /** @brief Periodic scheduling interval */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_RWUSIG_MASK                = 0x00000001U;   /** @brief Remote wakeup signaling */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SDIS_MASK                  = 0x00000002U;   /** @brief Soft disconnect */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_GINSTS_MASK                = 0x00000004U;   /** @brief Global IN NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_GONSTS_MASK                = 0x00000008U;   /** @brief Global OUT NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL_MASK                  = 0x00000070U;   /** @brief Test control */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SGINAK_MASK                = 0x00000080U;   /** @brief Set global IN NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_CGINAK_MASK                = 0x00000100U;   /** @brief Clear global IN NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SGONAK_MASK                = 0x00000200U;   /** @brief Set global OUT NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_CGONAK_MASK                = 0x00000400U;   /** @brief Clear global OUT NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_POPRGDNE_MASK              = 0x00000800U;   /** @brief Power-on programming done */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_SUSPSTS_MASK               = 0x00000001U;   /** @brief Suspend status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_MASK               = 0x00000006U;   /** @brief Enumerated speed */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_EERR_MASK                  = 0x00000008U;   /** @brief Erratic error */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_FNSOF_MASK                 = 0x003FFF00U;   /** @brief Frame number of the received SOF */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_EPDM_MASK               = 0x00000002U;   /** @brief Endpoint disabled interrupt mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TOM_MASK                = 0x00000008U;   /** @brief Timeout condition mask (nonisochronous endpoints) */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK_MASK          = 0x00000010U;   /** @brief IN token received when txfifo empty mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM_MASK            = 0x00000020U;   /** @brief IN token received with EP mismatch mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM_MASK            = 0x00000040U;   /** @brief IN endpoint NAK effective mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM_MASK             = 0x00000100U;   /** @brief FIFO underrun mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_BIM_MASK                = 0x00000200U;   /** @brief BNA interrupt mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_EPDM_MASK               = 0x00000002U;   /** @brief Endpoint disabled interrupt mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_STUPM_MASK              = 0x00000008U;   /** @brief SETUP phase done mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM_MASK             = 0x00000010U;   /** @brief OUT token received when endpoint disabled mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP_MASK            = 0x00000040U;   /** @brief Back-to-back SETUP packets received mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OPEM_MASK               = 0x00000100U;   /** @brief OUT packet error mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_BOIM_MASK               = 0x00000200U;   /** @brief BNA interrupt mask */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DAINT_IEPINT_MASK               = 0x0000FFFFU;   /** @brief IN endpoint interrupt bits */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DAINT_OEPINT_MASK               = 0xFFFF0000U;   /** @brief OUT endpoint interrupt bits */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_MASK              = 0x0000FFFFU;   /** @brief IN EP interrupt mask bits */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_MASK              = 0xFFFF0000U;   /** @brief OUT EP interrupt mask bits */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_MASK            = 0x0000FFFFU;   /** @brief Device VBUS discharge time */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_MASK          = 0x00000FFFU;   /** @brief Device VBUS pulsing time */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN_MASK        = 0x00000001U;   /** @brief Nonisochronous IN endpoints threshold enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN_MASK           = 0x00000002U;   /** @brief ISO IN endpoint threshold enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_MASK           = 0x000007FCU;   /** @brief Transmit threshold length */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN_MASK            = 0x00010000U;   /** @brief Receive threshold enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_MASK           = 0x03FE0000U;   /** @brief Receive threshold length */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN_MASK              = 0x08000000U;   /** @brief Arbiter parking enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_MASK       = 0x0000FFFFU;   /** @brief IN EP tx FIFO empty interrupt mask bits */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT_MASK           = 0x00000002U;   /** @brief IN endpoint 1interrupt bit */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT_MASK           = 0x00020000U;   /** @brief OUT endpoint 1 interrupt bit */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM_MASK       = 0x00000002U;   /** @brief IN endpoint 1 interrupt mask bit */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM_MASK       = 0x00020000U;   /** @brief OUT endpoint 1 interrupt mask bit */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even/odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_TXFNUM_MASK            = 0x03C00000U;   /** @brief TxFIFO number */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_XFRC_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_EPDISD_MASK            = 0x00000002U;   /** @brief Endpoint disabled interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_TOC_MASK               = 0x00000008U;   /** @brief Timeout condition */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_ITTXFE_MASK            = 0x00000010U;   /** @brief IN token received when txfifo is empty */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_INEPNE_MASK            = 0x00000040U;   /** @brief IN endpoint NAK effective */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_TXFE_MASK              = 0x00000080U;   /** @brief Transmit FIFO empty */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_TXFIFOUDRN_MASK        = 0x00000100U;   /** @brief Transmit fifo underrun */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_BNA_MASK               = 0x00000200U;   /** @brief Buffer not available interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_PKTDRPSTS_MASK         = 0x00000800U;   /** @brief Packet dropped status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_BERR_MASK              = 0x00001000U;   /** @brief Babble error interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_NAK_MASK               = 0x00002000U;   /** @brief NAK interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ_MASK           = 0x0000007FU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT_MASK           = 0x00180000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ_MASK             = 0x00000003U;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_XFRC_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_EPDISD_MASK            = 0x00000002U;   /** @brief Endpoint disabled interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_STUP_MASK              = 0x00000008U;   /** @brief SETUP phase done */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_OTEPDIS_MASK           = 0x00000010U;   /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_B2BSTUP_MASK           = 0x00000040U;   /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_NYET_MASK              = 0x00004000U;   /** @brief NYET interrupt */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ_MASK           = 0x0000007FU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT_MASK           = 0x00080000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT_MASK          = 0x60000000U;   /** @brief SETUP packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */

    /**** @subsection OTG1_HS_DEVICE Register Field Positions ****/

    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD_POS                  = 0;    /** @brief Device speed */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK_POS              = 2;    /** @brief Nonzero-length status OUT handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCFG_DAD_POS                   = 4;    /** @brief Device address */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL_POS                 = 11;   /** @brief Periodic (micro)frame interval */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_POS             = 24;   /** @brief Periodic scheduling interval */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_RWUSIG_POS                = 0;    /** @brief Remote wakeup signaling */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SDIS_POS                  = 1;    /** @brief Soft disconnect */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_GINSTS_POS                = 2;    /** @brief Global IN NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_GONSTS_POS                = 3;    /** @brief Global OUT NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL_POS                  = 4;    /** @brief Test control */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SGINAK_POS                = 7;    /** @brief Set global IN NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_CGINAK_POS                = 8;    /** @brief Clear global IN NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SGONAK_POS                = 9;    /** @brief Set global OUT NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_CGONAK_POS                = 10;   /** @brief Clear global OUT NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DCTL_POPRGDNE_POS              = 11;   /** @brief Power-on programming done */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DSTS_SUSPSTS_POS               = 0;    /** @brief Suspend status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_POS               = 1;    /** @brief Enumerated speed */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DSTS_EERR_POS                  = 3;    /** @brief Erratic error */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DSTS_FNSOF_POS                 = 8;    /** @brief Frame number of the received SOF */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM_POS              = 0;    /** @brief Transfer completed interrupt mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_EPDM_POS               = 1;    /** @brief Endpoint disabled interrupt mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TOM_POS                = 3;    /** @brief Timeout condition mask (nonisochronous endpoints) */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK_POS          = 4;    /** @brief IN token received when txfifo empty mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM_POS            = 5;    /** @brief IN token received with EP mismatch mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM_POS            = 6;    /** @brief IN endpoint NAK effective mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM_POS             = 8;    /** @brief FIFO underrun mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_BIM_POS                = 9;    /** @brief BNA interrupt mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM_POS              = 0;    /** @brief Transfer completed interrupt mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_EPDM_POS               = 1;    /** @brief Endpoint disabled interrupt mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_STUPM_POS              = 3;    /** @brief SETUP phase done mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM_POS             = 4;    /** @brief OUT token received when endpoint disabled mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP_POS            = 6;    /** @brief Back-to-back SETUP packets received mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OPEM_POS               = 8;    /** @brief OUT packet error mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_BOIM_POS               = 9;    /** @brief BNA interrupt mask */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DAINT_IEPINT_POS               = 0;    /** @brief IN endpoint interrupt bits */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DAINT_OEPINT_POS               = 16;   /** @brief OUT endpoint interrupt bits */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_POS              = 0;    /** @brief IN EP interrupt mask bits */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_POS              = 16;   /** @brief OUT EP interrupt mask bits */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_POS            = 0;    /** @brief Device VBUS discharge time */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_POS          = 0;    /** @brief Device VBUS pulsing time */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN_POS        = 0;    /** @brief Nonisochronous IN endpoints threshold enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN_POS           = 1;    /** @brief ISO IN endpoint threshold enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_POS           = 2;    /** @brief Transmit threshold length */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN_POS            = 16;   /** @brief Receive threshold enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_POS           = 17;   /** @brief Receive threshold length */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN_POS              = 27;   /** @brief Arbiter parking enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_POS       = 0;    /** @brief IN EP tx FIFO empty interrupt mask bits */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT_POS           = 1;    /** @brief IN endpoint 1interrupt bit */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT_POS           = 17;   /** @brief OUT endpoint 1 interrupt bit */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM_POS       = 1;    /** @brief IN endpoint 1 interrupt mask bit */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM_POS       = 17;   /** @brief OUT endpoint 1 interrupt mask bit */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EONUM_DPID_POS        = 16;   /** @brief Even/odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_TXFNUM_POS            = 22;   /** @brief TxFIFO number */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_XFRC_POS              = 0;    /** @brief Transfer completed interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_EPDISD_POS            = 1;    /** @brief Endpoint disabled interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_TOC_POS               = 3;    /** @brief Timeout condition */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_ITTXFE_POS            = 4;    /** @brief IN token received when txfifo is empty */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_INEPNE_POS            = 6;    /** @brief IN endpoint NAK effective */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_TXFE_POS              = 7;    /** @brief Transmit FIFO empty */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_TXFIFOUDRN_POS        = 8;    /** @brief Transmit fifo underrun */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_BNA_POS               = 9;    /** @brief Buffer not available interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_PKTDRPSTS_POS         = 11;   /** @brief Packet dropped status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_BERR_POS              = 12;   /** @brief Babble error interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPINTx_NAK_POS               = 13;   /** @brief NAK interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_XFRC_POS              = 0;    /** @brief Transfer completed interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_EPDISD_POS            = 1;    /** @brief Endpoint disabled interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_STUP_POS              = 3;    /** @brief SETUP phase done */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_OTEPDIS_POS           = 4;    /** @brief OUT token received when endpoint disabled */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_B2BSTUP_POS           = 6;    /** @brief Back-to-back SETUP packets received */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPINTx_NYET_POS              = 14;   /** @brief NYET interrupt */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT_POS          = 29;   /** @brief SETUP packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */

    /**********************************************************************************************
     * @section OTG2_HS_DEVICE Register Information
     **********************************************************************************************/

    /**** @subsection OTG2_HS_DEVICE Register Pointers ****/

    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DCFG_PTR          = (RW_ uint32_t* const)0x40080800U;   /** @brief OTG_HS device configuration register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DCTL_PTR          = (RW_ uint32_t* const)0x40080804U;   /** @brief OTG_HS device control register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DSTS_PTR          = (RO_ uint32_t* const)0x40080808U;   /** @brief OTG_HS device status register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPMSK_PTR       = (RW_ uint32_t* const)0x40080810U;   /** @brief OTG_HS device IN endpoint common interrupt mask register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPMSK_PTR       = (RW_ uint32_t* const)0x40080814U;   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DAINT_PTR         = (RO_ uint32_t* const)0x40080818U;   /** @brief OTG_HS device all endpoints interrupt register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DAINTMSK_PTR      = (RW_ uint32_t* const)0x4008081CU;   /** @brief OTG_HS all endpoints interrupt mask register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_PTR      = (RW_ uint32_t* const)0x40080828U;   /** @brief OTG_HS device VBUS discharge time register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_PTR    = (RW_ uint32_t* const)0x4008082CU;   /** @brief OTG_HS device VBUS pulsing time register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTHRCTL_PTR       = (RW_ uint32_t* const)0x40080830U;   /** @brief OTG_HS device threshold control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_PTR    = (RW_ uint32_t* const)0x40080834U;   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DEACHINT_PTR      = (RW_ uint32_t* const)0x40080838U;   /** @brief OTG_HS device each endpoint interrupt register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_PTR   = (RW_ uint32_t* const)0x4008083CU;   /** @brief OTG_HS device each endpoint interrupt register mask */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_PTR     = (RW_ uint32_t* const)0x40080910U;   /** @brief OTG_HS device IN endpoint 0 transfer size register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_PTR      = (RO_ uint32_t* const)0x40080918U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_PTR      = (RO_ uint32_t* const)0x40080938U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_PTR      = (RO_ uint32_t* const)0x40080958U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_PTR      = (RO_ uint32_t* const)0x40080978U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_PTR      = (RO_ uint32_t* const)0x40080998U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RO_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_PTR      = (RO_ uint32_t* const)0x400809B8U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_PTR     = (RW_ uint32_t* const)0x40080930U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_PTR     = (RW_ uint32_t* const)0x40080950U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_PTR     = (RW_ uint32_t* const)0x40080970U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_PTR     = (RW_ uint32_t* const)0x40080990U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_PTR     = (RW_ uint32_t* const)0x400809B0U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_PTR      = (RW_ uint32_t* const)0x40080B00U;   /** @brief OTG_HS device control OUT endpoint 0 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_PTR      = (RW_ uint32_t* const)0x40080B20U;   /** @brief OTG device endpoint-1 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_PTR      = (RW_ uint32_t* const)0x40080B40U;   /** @brief OTG device endpoint-2 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_PTR      = (RW_ uint32_t* const)0x40080B60U;   /** @brief OTG device endpoint-3 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_PTR     = (RW_ uint32_t* const)0x40080B10U;   /** @brief OTG_HS device endpoint-0 transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_PTR     = (RW_ uint32_t* const)0x40080B30U;   /** @brief OTG_HS device endpoint-1 transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_PTR     = (RW_ uint32_t* const)0x40080B50U;   /** @brief OTG_HS device endpoint-2 transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_PTR     = (RW_ uint32_t* const)0x40080B70U;   /** @brief OTG_HS device endpoint-3 transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_PTR     = (RW_ uint32_t* const)0x40080B90U;   /** @brief OTG_HS device endpoint-4 transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_PTR     = (RW_ uint32_t* const)0x400809A0U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_PTR      = (RW_ uint32_t* const)0x400809A4U;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_PTR     = (RW_ uint32_t* const)0x400809A8U;   /** @brief OTG_HS device endpoint transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_PTR      = (RW_ uint32_t* const)0x400809ACU;   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_PTR      = (RW_ uint32_t* const)0x40080B80U;   /** @brief OTG device endpoint-4 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_PTR      = (RW_ uint32_t* const)0x40080BA0U;   /** @brief OTG device endpoint-5 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_PTR      = (RW_ uint32_t* const)0x40080BC0U;   /** @brief OTG device endpoint-6 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_PTR      = (RW_ uint32_t* const)0x40080BE0U;   /** @brief OTG device endpoint-7 control register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_PTR     = (RW_ uint32_t* const)0x40080BB0U;   /** @brief OTG_HS device endpoint-5 transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_PTR     = (RW_ uint32_t* const)0x40080BD0U;   /** @brief OTG_HS device endpoint-6 transfer size register */
    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_PTR     = (RW_ uint32_t* const)0x40080BF0U;   /** @brief OTG_HS device endpoint-7 transfer size register */

    /**** @subsection Enumerated OTG2_HS_DEVICE Register Pointers ****/

    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40080900U,   /** @brief OTG device endpoint-0 control register */
      [1] = (RW_ uint32_t* const)0x40080920U,   /** @brief OTG device endpoint-1 control register */
      [2] = (RW_ uint32_t* const)0x40080940U,   /** @brief OTG device endpoint-2 control register */
      [3] = (RW_ uint32_t* const)0x40080960U,   /** @brief OTG device endpoint-3 control register */
      [4] = (RW_ uint32_t* const)0x40080980U,   /** @brief OTG device endpoint-4 control register */
      [5] = (RW_ uint32_t* const)0x400809A0U,   /** @brief OTG device endpoint-5 control register */
      [6] = (RW_ uint32_t* const)0x400809C0U,   /** @brief OTG device endpoint-6 control register */
      [7] = (RW_ uint32_t* const)0x400809E0U,   /** @brief OTG device endpoint-7 control register */
    };

    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPINTx_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40080908U,   /** @brief OTG device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40080928U,   /** @brief OTG device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40080948U,   /** @brief OTG device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40080968U,   /** @brief OTG device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40080988U,   /** @brief OTG device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x400809A8U,   /** @brief OTG device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x400809C8U,   /** @brief OTG device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x400809E8U,   /** @brief OTG device endpoint-7 interrupt register */
    };

    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPDMAx_PTR[6] = {
      [1] = (RW_ uint32_t* const)0x40080914U,   /** @brief OTG_HS device endpoint-1 DMA address register */
      [2] = (RW_ uint32_t* const)0x40080934U,   /** @brief OTG_HS device endpoint-2 DMA address register */
      [3] = (RW_ uint32_t* const)0x40080954U,   /** @brief OTG_HS device endpoint-3 DMA address register */
      [4] = (RW_ uint32_t* const)0x40080974U,   /** @brief OTG_HS device endpoint-4 DMA address register */
      [5] = (RW_ uint32_t* const)0x40080994U,   /** @brief OTG_HS device endpoint-5 DMA address register */
    };

    static RW_ uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPINTx_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40080B08U,   /** @brief OTG_HS device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40080B28U,   /** @brief OTG_HS device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40080B48U,   /** @brief OTG_HS device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40080B68U,   /** @brief OTG_HS device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40080B88U,   /** @brief OTG_HS device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x40080BA8U,   /** @brief OTG_HS device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x40080BC8U,   /** @brief OTG_HS device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x40080BE8U,   /** @brief OTG_HS device endpoint-7 interrupt register */
    };

    /**** @subsection OTG2_HS_DEVICE Register Reset Values ****/

    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_RST          = 0x02200000U;   /** @brief OTG_HS_DCFG register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_RST          = 0x00000000U;   /** @brief OTG_HS_DCTL register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_RST          = 0x00000010U;   /** @brief OTG_HS_DSTS register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_RST       = 0x00000000U;   /** @brief OTG_HS_DIEPMSK register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_RST       = 0x00000000U;   /** @brief OTG_HS_DOEPMSK register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DAINT_RST         = 0x00000000U;   /** @brief OTG_HS_DAINT register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_RST      = 0x00000000U;   /** @brief OTG_HS_DAINTMSK register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_RST      = 0x000017D7U;   /** @brief OTG_HS_DVBUSDIS register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_RST    = 0x000005B8U;   /** @brief OTG_HS_DVBUSPULSE register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RST       = 0x00000000U;   /** @brief OTG_HS_DTHRCTL register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_RST    = 0x00000000U;   /** @brief OTG_HS_DIEPEMPMSK register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_RST      = 0x00000000U;   /** @brief OTG_HS_DEACHINT register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_RST   = 0x00000000U;   /** @brief OTG_HS_DEACHINTMSK register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ0 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS0 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS1 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS2 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS3 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS4 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS5 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ1 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ2 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ3 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ4 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ5 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_RST      = 0x00008000U;   /** @brief OTG_HS_DOEPCTL0 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL1 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL2 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL3 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ0 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ1 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ2 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ3 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ4 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ6 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS6 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_RST     = 0x00000000U;   /** @brief OTG_HS_DIEPTSIZ7 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_RST      = 0x00000000U;   /** @brief OTG_HS_DTXFSTS7 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL4 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL5 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL6 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_RST      = 0x00000000U;   /** @brief OTG_HS_DOEPCTL7 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ5 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ6 register reset value. */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_RST     = 0x00000000U;   /** @brief OTG_HS_DOEPTSIZ7 register reset value. */

    /**** @subsection Enumerated OTG2_HS_DEVICE Register Reset Values ****/

    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_RST[8] = {
      [0] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL0 register reset value. */
      [1] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL5 register reset value. */
      [6] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL6 register reset value. */
      [7] = 0x00000000U,   /** @brief OTG_HS_DIEPCTL7 register reset value. */
    };

    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_RST[8] = {
      [0] = 0x00000080U,   /** @brief OTG_HS_DIEPINT0 register reset value. */
      [1] = 0x00000000U,   /** @brief OTG_HS_DIEPINT1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DIEPINT2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DIEPINT3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DIEPINT4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DIEPINT5 register reset value. */
      [6] = 0x00000000U,   /** @brief OTG_HS_DIEPINT6 register reset value. */
      [7] = 0x00000000U,   /** @brief OTG_HS_DIEPINT7 register reset value. */
    };

    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPDMAx_RST[6] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DIEPDMA5 register reset value. */
    };

    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_RST[8] = {
      [0] = 0x00000080U,   /** @brief OTG_HS_DOEPINT0 register reset value. */
      [1] = 0x00000000U,   /** @brief OTG_HS_DOEPINT1 register reset value. */
      [2] = 0x00000000U,   /** @brief OTG_HS_DOEPINT2 register reset value. */
      [3] = 0x00000000U,   /** @brief OTG_HS_DOEPINT3 register reset value. */
      [4] = 0x00000000U,   /** @brief OTG_HS_DOEPINT4 register reset value. */
      [5] = 0x00000000U,   /** @brief OTG_HS_DOEPINT5 register reset value. */
      [6] = 0x00000000U,   /** @brief OTG_HS_DOEPINT6 register reset value. */
      [7] = 0x00000000U,   /** @brief OTG_HS_DOEPINT7 register reset value. */
    };

    /**** @subsection Enumerated OTG2_HS_DEVICE Register Value Types ****/

    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_t;          /** @brief OTG_HS_DCFG register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_t;          /** @brief OTG_HS_DCTL register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_t;          /** @brief OTG_HS_DSTS register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_t;       /** @brief OTG_HS_DIEPMSK register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_t;       /** @brief OTG_HS_DOEPMSK register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DAINT_t;         /** @brief OTG_HS_DAINT register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_t;      /** @brief OTG_HS_DAINTMSK register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_t;      /** @brief OTG_HS_DVBUSDIS register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_t;    /** @brief OTG_HS_DVBUSPULSE register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_t;       /** @brief OTG_HS_DTHRCTL register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_t;    /** @brief OTG_HS_DIEPEMPMSK register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_t;      /** @brief OTG_HS_DEACHINT register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_t;   /** @brief OTG_HS_DEACHINTMSK register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_t;      /** @brief OTG_HS_DIEPCTLx register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_t;      /** @brief OTG_HS_DIEPINTx register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_t;     /** @brief OTG_HS_DIEPTSIZ0 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPDMAx_t;      /** @brief OTG_HS_DIEPDMAx register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_t;      /** @brief OTG_HS_DTXFSTS0 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_t;      /** @brief OTG_HS_DTXFSTS1 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_t;      /** @brief OTG_HS_DTXFSTS2 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_t;      /** @brief OTG_HS_DTXFSTS3 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_t;      /** @brief OTG_HS_DTXFSTS4 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_t;      /** @brief OTG_HS_DTXFSTS5 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_t;     /** @brief OTG_HS_DIEPTSIZ1 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_t;     /** @brief OTG_HS_DIEPTSIZ2 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_t;     /** @brief OTG_HS_DIEPTSIZ3 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_t;     /** @brief OTG_HS_DIEPTSIZ4 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_t;     /** @brief OTG_HS_DIEPTSIZ5 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_t;      /** @brief OTG_HS_DOEPCTL0 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_t;      /** @brief OTG_HS_DOEPCTL1 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_t;      /** @brief OTG_HS_DOEPCTL2 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_t;      /** @brief OTG_HS_DOEPCTL3 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_t;      /** @brief OTG_HS_DOEPINTx register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_t;     /** @brief OTG_HS_DOEPTSIZ0 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_t;     /** @brief OTG_HS_DOEPTSIZ1 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_t;     /** @brief OTG_HS_DOEPTSIZ2 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_t;     /** @brief OTG_HS_DOEPTSIZ3 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_t;     /** @brief OTG_HS_DOEPTSIZ4 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_t;     /** @brief OTG_HS_DIEPTSIZ6 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_t;      /** @brief OTG_HS_DTXFSTS6 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_t;     /** @brief OTG_HS_DIEPTSIZ7 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_t;      /** @brief OTG_HS_DTXFSTS7 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_t;      /** @brief OTG_HS_DOEPCTL4 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_t;      /** @brief OTG_HS_DOEPCTL5 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_t;      /** @brief OTG_HS_DOEPCTL6 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_t;      /** @brief OTG_HS_DOEPCTL7 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_t;     /** @brief OTG_HS_DOEPTSIZ5 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_t;     /** @brief OTG_HS_DOEPTSIZ6 register value type. */
    typedef uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_t;     /** @brief OTG_HS_DOEPTSIZ7 register value type. */

    /**** @subsection Enumerated OTG2_HS_DEVICE Register Pointer Types ****/

    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DCFG_PTR_t;          /** @brief OTG_HS_DCFG register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DCTL_PTR_t;          /** @brief OTG_HS_DCTL register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DSTS_PTR_t;          /** @brief OTG_HS_DSTS register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPMSK_PTR_t;       /** @brief OTG_HS_DIEPMSK register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPMSK_PTR_t;       /** @brief OTG_HS_DOEPMSK register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DAINT_PTR_t;         /** @brief OTG_HS_DAINT register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DAINTMSK_PTR_t;      /** @brief OTG_HS_DAINTMSK register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_PTR_t;      /** @brief OTG_HS_DVBUSDIS register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_PTR_t;    /** @brief OTG_HS_DVBUSPULSE register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTHRCTL_PTR_t;       /** @brief OTG_HS_DTHRCTL register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_PTR_t;    /** @brief OTG_HS_DIEPEMPMSK register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DEACHINT_PTR_t;      /** @brief OTG_HS_DEACHINT register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_PTR_t;   /** @brief OTG_HS_DEACHINTMSK register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_PTR_t;      /** @brief OTG_HS_DIEPCTLx register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPINTx_PTR_t;      /** @brief OTG_HS_DIEPINTx register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_PTR_t;     /** @brief OTG_HS_DIEPTSIZ0 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPDMAx_PTR_t;      /** @brief OTG_HS_DIEPDMAx register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_PTR_t;      /** @brief OTG_HS_DTXFSTS0 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_PTR_t;      /** @brief OTG_HS_DTXFSTS1 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_PTR_t;      /** @brief OTG_HS_DTXFSTS2 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_PTR_t;      /** @brief OTG_HS_DTXFSTS3 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_PTR_t;      /** @brief OTG_HS_DTXFSTS4 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_PTR_t;      /** @brief OTG_HS_DTXFSTS5 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_PTR_t;     /** @brief OTG_HS_DIEPTSIZ1 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_PTR_t;     /** @brief OTG_HS_DIEPTSIZ2 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_PTR_t;     /** @brief OTG_HS_DIEPTSIZ3 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_PTR_t;     /** @brief OTG_HS_DIEPTSIZ4 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_PTR_t;     /** @brief OTG_HS_DIEPTSIZ5 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_PTR_t;      /** @brief OTG_HS_DOEPCTL0 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_PTR_t;      /** @brief OTG_HS_DOEPCTL1 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_PTR_t;      /** @brief OTG_HS_DOEPCTL2 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_PTR_t;      /** @brief OTG_HS_DOEPCTL3 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPINTx_PTR_t;      /** @brief OTG_HS_DOEPINTx register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_PTR_t;     /** @brief OTG_HS_DOEPTSIZ0 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_PTR_t;     /** @brief OTG_HS_DOEPTSIZ1 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_PTR_t;     /** @brief OTG_HS_DOEPTSIZ2 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_PTR_t;     /** @brief OTG_HS_DOEPTSIZ3 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_PTR_t;     /** @brief OTG_HS_DOEPTSIZ4 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_PTR_t;     /** @brief OTG_HS_DIEPTSIZ6 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_PTR_t;      /** @brief OTG_HS_DTXFSTS6 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_PTR_t;     /** @brief OTG_HS_DIEPTSIZ7 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_PTR_t;      /** @brief OTG_HS_DTXFSTS7 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_PTR_t;      /** @brief OTG_HS_DOEPCTL4 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_PTR_t;      /** @brief OTG_HS_DOEPCTL5 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_PTR_t;      /** @brief OTG_HS_DOEPCTL6 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_PTR_t;      /** @brief OTG_HS_DOEPCTL7 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_PTR_t;     /** @brief OTG_HS_DOEPTSIZ5 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_PTR_t;     /** @brief OTG_HS_DOEPTSIZ6 register pointer type. */
    typedef uint32_t* const OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_PTR_t;     /** @brief OTG_HS_DOEPTSIZ7 register pointer type. */

    /**** @subsection OTG2_HS_DEVICE Register Field Masks ****/

    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_DSPD_MASK                  = 0x00000003U;   /** @brief Device speed */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK_MASK              = 0x00000004U;   /** @brief Nonzero-length status OUT handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_DAD_MASK                   = 0x000007F0U;   /** @brief Device address */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_PFIVL_MASK                 = 0x00001800U;   /** @brief Periodic (micro)frame interval */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_MASK             = 0x03000000U;   /** @brief Periodic scheduling interval */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_RWUSIG_MASK                = 0x00000001U;   /** @brief Remote wakeup signaling */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SDIS_MASK                  = 0x00000002U;   /** @brief Soft disconnect */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_GINSTS_MASK                = 0x00000004U;   /** @brief Global IN NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_GONSTS_MASK                = 0x00000008U;   /** @brief Global OUT NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_TCTL_MASK                  = 0x00000070U;   /** @brief Test control */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SGINAK_MASK                = 0x00000080U;   /** @brief Set global IN NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_CGINAK_MASK                = 0x00000100U;   /** @brief Clear global IN NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SGONAK_MASK                = 0x00000200U;   /** @brief Set global OUT NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_CGONAK_MASK                = 0x00000400U;   /** @brief Clear global OUT NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_POPRGDNE_MASK              = 0x00000800U;   /** @brief Power-on programming done */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_SUSPSTS_MASK               = 0x00000001U;   /** @brief Suspend status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_MASK               = 0x00000006U;   /** @brief Enumerated speed */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_EERR_MASK                  = 0x00000008U;   /** @brief Erratic error */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_FNSOF_MASK                 = 0x003FFF00U;   /** @brief Frame number of the received SOF */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_EPDM_MASK               = 0x00000002U;   /** @brief Endpoint disabled interrupt mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TOM_MASK                = 0x00000008U;   /** @brief Timeout condition mask (nonisochronous endpoints) */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK_MASK          = 0x00000010U;   /** @brief IN token received when txfifo empty mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM_MASK            = 0x00000020U;   /** @brief IN token received with EP mismatch mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM_MASK            = 0x00000040U;   /** @brief IN endpoint NAK effective mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM_MASK             = 0x00000100U;   /** @brief FIFO underrun mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_BIM_MASK                = 0x00000200U;   /** @brief BNA interrupt mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_EPDM_MASK               = 0x00000002U;   /** @brief Endpoint disabled interrupt mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_STUPM_MASK              = 0x00000008U;   /** @brief SETUP phase done mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM_MASK             = 0x00000010U;   /** @brief OUT token received when endpoint disabled mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP_MASK            = 0x00000040U;   /** @brief Back-to-back SETUP packets received mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OPEM_MASK               = 0x00000100U;   /** @brief OUT packet error mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_BOIM_MASK               = 0x00000200U;   /** @brief BNA interrupt mask */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DAINT_IEPINT_MASK               = 0x0000FFFFU;   /** @brief IN endpoint interrupt bits */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DAINT_OEPINT_MASK               = 0xFFFF0000U;   /** @brief OUT endpoint interrupt bits */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_MASK              = 0x0000FFFFU;   /** @brief IN EP interrupt mask bits */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_MASK              = 0xFFFF0000U;   /** @brief OUT EP interrupt mask bits */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_MASK            = 0x0000FFFFU;   /** @brief Device VBUS discharge time */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_MASK          = 0x00000FFFU;   /** @brief Device VBUS pulsing time */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN_MASK        = 0x00000001U;   /** @brief Nonisochronous IN endpoints threshold enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN_MASK           = 0x00000002U;   /** @brief ISO IN endpoint threshold enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_MASK           = 0x000007FCU;   /** @brief Transmit threshold length */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN_MASK            = 0x00010000U;   /** @brief Receive threshold enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_MASK           = 0x03FE0000U;   /** @brief Receive threshold length */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN_MASK              = 0x08000000U;   /** @brief Arbiter parking enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_MASK       = 0x0000FFFFU;   /** @brief IN EP tx FIFO empty interrupt mask bits */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT_MASK           = 0x00000002U;   /** @brief IN endpoint 1interrupt bit */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT_MASK           = 0x00020000U;   /** @brief OUT endpoint 1 interrupt bit */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM_MASK       = 0x00000002U;   /** @brief IN endpoint 1 interrupt mask bit */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM_MASK       = 0x00020000U;   /** @brief OUT endpoint 1 interrupt mask bit */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even/odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_TXFNUM_MASK            = 0x03C00000U;   /** @brief TxFIFO number */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_XFRC_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_EPDISD_MASK            = 0x00000002U;   /** @brief Endpoint disabled interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_TOC_MASK               = 0x00000008U;   /** @brief Timeout condition */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_ITTXFE_MASK            = 0x00000010U;   /** @brief IN token received when txfifo is empty */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_INEPNE_MASK            = 0x00000040U;   /** @brief IN endpoint NAK effective */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_TXFE_MASK              = 0x00000080U;   /** @brief Transmit FIFO empty */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_TXFIFOUDRN_MASK        = 0x00000100U;   /** @brief Transmit fifo underrun */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_BNA_MASK               = 0x00000200U;   /** @brief Buffer not available interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_PKTDRPSTS_MASK         = 0x00000800U;   /** @brief Packet dropped status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_BERR_MASK              = 0x00001000U;   /** @brief Babble error interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_NAK_MASK               = 0x00002000U;   /** @brief NAK interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ_MASK           = 0x0000007FU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT_MASK           = 0x00180000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ_MASK             = 0x00000003U;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_XFRC_MASK              = 0x00000001U;   /** @brief Transfer completed interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_EPDISD_MASK            = 0x00000002U;   /** @brief Endpoint disabled interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_STUP_MASK              = 0x00000008U;   /** @brief SETUP phase done */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_OTEPDIS_MASK           = 0x00000010U;   /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_B2BSTUP_MASK           = 0x00000040U;   /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_NYET_MASK              = 0x00004000U;   /** @brief NYET interrupt */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ_MASK           = 0x0000007FU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT_MASK           = 0x00080000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT_MASK          = 0x60000000U;   /** @brief SETUP packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT_MASK             = 0x60000000U;   /** @brief Multi count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV_MASK         = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ_MASK             = 0x000007FFU;   /** @brief Maximum packet size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP_MASK            = 0x00008000U;   /** @brief USB active endpoint */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID_MASK        = 0x00010000U;   /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS_MASK            = 0x00020000U;   /** @brief NAK status */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP_MASK             = 0x000C0000U;   /** @brief Endpoint type */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM_MASK              = 0x00100000U;   /** @brief Snoop mode */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_STALL_MASK             = 0x00200000U;   /** @brief STALL handshake */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK_MASK              = 0x04000000U;   /** @brief Clear NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK_MASK              = 0x08000000U;   /** @brief Set NAK */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM_MASK    = 0x10000000U;   /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM_MASK           = 0x20000000U;   /** @brief Set odd frame */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS_MASK             = 0x40000000U;   /** @brief Endpoint disable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA_MASK             = 0x80000000U;   /** @brief Endpoint enable */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ_MASK           = 0x0007FFFFU;   /** @brief Transfer size */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT_MASK           = 0x1FF80000U;   /** @brief Packet count */
    static const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_MASK   = 0x60000000U;   /** @brief Received data PID/SETUP packet count */

    /**** @subsection OTG2_HS_DEVICE Register Field Positions ****/

    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCFG_DSPD_POS                  = 0;    /** @brief Device speed */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK_POS              = 2;    /** @brief Nonzero-length status OUT handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCFG_DAD_POS                   = 4;    /** @brief Device address */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCFG_PFIVL_POS                 = 11;   /** @brief Periodic (micro)frame interval */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_POS             = 24;   /** @brief Periodic scheduling interval */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_RWUSIG_POS                = 0;    /** @brief Remote wakeup signaling */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SDIS_POS                  = 1;    /** @brief Soft disconnect */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_GINSTS_POS                = 2;    /** @brief Global IN NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_GONSTS_POS                = 3;    /** @brief Global OUT NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_TCTL_POS                  = 4;    /** @brief Test control */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SGINAK_POS                = 7;    /** @brief Set global IN NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_CGINAK_POS                = 8;    /** @brief Clear global IN NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SGONAK_POS                = 9;    /** @brief Set global OUT NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_CGONAK_POS                = 10;   /** @brief Clear global OUT NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DCTL_POPRGDNE_POS              = 11;   /** @brief Power-on programming done */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DSTS_SUSPSTS_POS               = 0;    /** @brief Suspend status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_POS               = 1;    /** @brief Enumerated speed */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DSTS_EERR_POS                  = 3;    /** @brief Erratic error */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DSTS_FNSOF_POS                 = 8;    /** @brief Frame number of the received SOF */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM_POS              = 0;    /** @brief Transfer completed interrupt mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_EPDM_POS               = 1;    /** @brief Endpoint disabled interrupt mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TOM_POS                = 3;    /** @brief Timeout condition mask (nonisochronous endpoints) */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK_POS          = 4;    /** @brief IN token received when txfifo empty mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM_POS            = 5;    /** @brief IN token received with EP mismatch mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM_POS            = 6;    /** @brief IN endpoint NAK effective mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM_POS             = 8;    /** @brief FIFO underrun mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_BIM_POS                = 9;    /** @brief BNA interrupt mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM_POS              = 0;    /** @brief Transfer completed interrupt mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_EPDM_POS               = 1;    /** @brief Endpoint disabled interrupt mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_STUPM_POS              = 3;    /** @brief SETUP phase done mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM_POS             = 4;    /** @brief OUT token received when endpoint disabled mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP_POS            = 6;    /** @brief Back-to-back SETUP packets received mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OPEM_POS               = 8;    /** @brief OUT packet error mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_BOIM_POS               = 9;    /** @brief BNA interrupt mask */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DAINT_IEPINT_POS               = 0;    /** @brief IN endpoint interrupt bits */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DAINT_OEPINT_POS               = 16;   /** @brief OUT endpoint interrupt bits */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_POS              = 0;    /** @brief IN EP interrupt mask bits */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_POS              = 16;   /** @brief OUT EP interrupt mask bits */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_POS            = 0;    /** @brief Device VBUS discharge time */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_POS          = 0;    /** @brief Device VBUS pulsing time */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN_POS        = 0;    /** @brief Nonisochronous IN endpoints threshold enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN_POS           = 1;    /** @brief ISO IN endpoint threshold enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_POS           = 2;    /** @brief Transmit threshold length */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN_POS            = 16;   /** @brief Receive threshold enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_POS           = 17;   /** @brief Receive threshold length */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN_POS              = 27;   /** @brief Arbiter parking enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_POS       = 0;    /** @brief IN EP tx FIFO empty interrupt mask bits */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT_POS           = 1;    /** @brief IN endpoint 1interrupt bit */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT_POS           = 17;   /** @brief OUT endpoint 1 interrupt bit */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM_POS       = 1;    /** @brief IN endpoint 1 interrupt mask bit */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM_POS       = 17;   /** @brief OUT endpoint 1 interrupt mask bit */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EONUM_DPID_POS        = 16;   /** @brief Even/odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_TXFNUM_POS            = 22;   /** @brief TxFIFO number */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_XFRC_POS              = 0;    /** @brief Transfer completed interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_EPDISD_POS            = 1;    /** @brief Endpoint disabled interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_TOC_POS               = 3;    /** @brief Timeout condition */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_ITTXFE_POS            = 4;    /** @brief IN token received when txfifo is empty */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_INEPNE_POS            = 6;    /** @brief IN endpoint NAK effective */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_TXFE_POS              = 7;    /** @brief Transmit FIFO empty */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_TXFIFOUDRN_POS        = 8;    /** @brief Transmit fifo underrun */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_BNA_POS               = 9;    /** @brief Buffer not available interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_PKTDRPSTS_POS         = 11;   /** @brief Packet dropped status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_BERR_POS              = 12;   /** @brief Babble error interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPINTx_NAK_POS               = 13;   /** @brief NAK interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_XFRC_POS              = 0;    /** @brief Transfer completed interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_EPDISD_POS            = 1;    /** @brief Endpoint disabled interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_STUP_POS              = 3;    /** @brief SETUP phase done */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_OTEPDIS_POS           = 4;    /** @brief OUT token received when endpoint disabled */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_B2BSTUP_POS           = 6;    /** @brief Back-to-back SETUP packets received */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPINTx_NYET_POS              = 14;   /** @brief NYET interrupt */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT_POS          = 29;   /** @brief SETUP packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT_POS             = 29;   /** @brief Multi count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV_POS         = 0;    /** @brief IN endpoint txfifo space avail */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ_POS             = 0;    /** @brief Maximum packet size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP_POS            = 15;   /** @brief USB active endpoint */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID_POS        = 16;   /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS_POS            = 17;   /** @brief NAK status */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP_POS             = 18;   /** @brief Endpoint type */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM_POS              = 20;   /** @brief Snoop mode */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_STALL_POS             = 21;   /** @brief STALL handshake */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK_POS              = 26;   /** @brief Clear NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK_POS              = 27;   /** @brief Set NAK */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM_POS    = 28;   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM_POS           = 29;   /** @brief Set odd frame */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS_POS             = 30;   /** @brief Endpoint disable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA_POS             = 31;   /** @brief Endpoint enable */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ_POS           = 0;    /** @brief Transfer size */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT_POS           = 19;   /** @brief Packet count */
    static const int32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT_POS   = 29;   /** @brief Received data PID/SETUP packet count */

    /**********************************************************************************************
     * @section OTGx_HS_PWRCLK Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated OTGx_HS_PWRCLK Register Pointers ****/

    static RW_ uint32_t* const OTGx_HS_PWRCLK_OTG_HS_PCGCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40040E00U,   /** @brief Power and clock gating control register */
      [2] = (RW_ uint32_t* const)0x40080E00U,   /** @brief Power and clock gating control register */
    };

    /**** @subsection Enumerated OTGx_HS_PWRCLK Register Reset Values ****/

    static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief OTG_HS_PCGCR register reset value */
      [2] = 0x00000000U,   /** @brief OTG_HS_PCGCR register reset value */
    };

    /**** @subsection Enumerated OTGx_HS_PWRCLK Register Value Types ****/

    typedef uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_t;   /** @brief OTG_HS_PCGCR register value type. */

    /**** @subsection Enumerated OTGx_HS_PWRCLK Register Pointer Types ****/

    typedef uint32_t* const OTGx_HS_PWRCLK_OTG_HS_PCGCR_PTR_t;   /** @brief OTG_HS_PCGCR register pointer type. */

    /**** @subsection OTGx_HS_PWRCLK Register Field Masks ****/

    static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK_MASK    = 0x00000001U;   /** @brief Stop PHY clock */
    static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK_MASK   = 0x00000002U;   /** @brief Gate HCLK */
    static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP_MASK    = 0x00000010U;   /** @brief PHY suspended */

    /**** @subsection OTGx_HS_PWRCLK Register Field Positions ****/

    static const int32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK_POS    = 0;   /** @brief Stop PHY clock */
    static const int32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK_POS   = 1;   /** @brief Gate HCLK */
    static const int32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP_POS    = 4;   /** @brief PHY suspended */

    /**********************************************************************************************
     * @section ETHERNET_MAC Register Information
     **********************************************************************************************/

    /**** @subsection ETHERNET_MAC Register Pointers ****/

    static RW_ uint32_t* const ETHERNET_MAC_DMAMR_PTR                                = (RW_ uint32_t* const)0x40029000U;   /** @brief DMA mode register */
    static RW_ uint32_t* const ETHERNET_MAC_DMASBMR_PTR                              = (RW_ uint32_t* const)0x40029004U;   /** @brief System bus mode register */
    static RO_ uint32_t* const ETHERNET_MAC_DMAISR_PTR                               = (RO_ uint32_t* const)0x40029008U;   /** @brief Interrupt status register */
    static RO_ uint32_t* const ETHERNET_MAC_DMADSR_PTR                               = (RO_ uint32_t* const)0x4002900CU;   /** @brief Debug status register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACCR_PTR                               = (RW_ uint32_t* const)0x40029100U;   /** @brief Channel control register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXCR_PTR                             = (RW_ uint32_t* const)0x40029104U;   /** @brief Channel transmit control register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXCR_PTR                             = (RW_ uint32_t* const)0x40029108U;   /** @brief Channel receive control register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXDLAR_PTR                           = (RW_ uint32_t* const)0x40029114U;   /** @brief Channel tx descriptor list address register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXDLAR_PTR                           = (RW_ uint32_t* const)0x4002911CU;   /** @brief Channel rx descriptor list address register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXDTPR_PTR                           = (RW_ uint32_t* const)0x40029120U;   /** @brief Channel tx descriptor tail pointer register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXDTPR_PTR                           = (RW_ uint32_t* const)0x40029128U;   /** @brief Channel rx descriptor tail pointer register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXRLR_PTR                            = (RW_ uint32_t* const)0x4002912CU;   /** @brief Channel tx descriptor ring length register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXRLR_PTR                            = (RW_ uint32_t* const)0x40029130U;   /** @brief Channel rx descriptor ring length register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACIER_PTR                              = (RW_ uint32_t* const)0x40029134U;   /** @brief Channel interrupt enable register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXIWTR_PTR                           = (RW_ uint32_t* const)0x40029138U;   /** @brief Channel rx interrupt watchdog timer register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCATXDR_PTR                           = (RO_ uint32_t* const)0x40029144U;   /** @brief Channel current application transmit descriptor register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCARXDR_PTR                           = (RO_ uint32_t* const)0x4002914CU;   /** @brief Channel current application receive descriptor register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCATXBR_PTR                           = (RO_ uint32_t* const)0x40029154U;   /** @brief Channel current application transmit buffer register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCARXBR_PTR                           = (RO_ uint32_t* const)0x4002915CU;   /** @brief Channel current application receive buffer register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACSR_PTR                               = (RW_ uint32_t* const)0x40029160U;   /** @brief Channel status register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACMFCR_PTR                             = (RO_ uint32_t* const)0x4002916CU;   /** @brief Channel missed frame count register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLOMR_PTR                               = (RW_ uint32_t* const)0x40028C00U;   /** @brief Operating mode register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLISR_PTR                               = (RO_ uint32_t* const)0x40028C20U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLTXQOMR_PTR                            = (RW_ uint32_t* const)0x40028D00U;   /** @brief Tx queue operating mode register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLTXQUR_PTR                             = (RO_ uint32_t* const)0x40028D04U;   /** @brief Tx queue underflow register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLTXQDR_PTR                             = (RO_ uint32_t* const)0x40028D08U;   /** @brief Tx queue debug register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLQICSR_PTR                             = (RW_ uint32_t* const)0x40028D2CU;   /** @brief Queue interrupt control status register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLRXQOMR_PTR                            = (RW_ uint32_t* const)0x40028D30U;   /** @brief Rx queue operating mode register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLRXQMPOCR_PTR                          = (RO_ uint32_t* const)0x40028D34U;   /** @brief Rx queue missed packet and overflow counter register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLRXQDR_PTR                             = (RO_ uint32_t* const)0x40028D38U;   /** @brief Rx queue debug register */
    static RW_ uint32_t* const ETHERNET_MAC_MACCR_PTR                                = (RW_ uint32_t* const)0x40028000U;   /** @brief Operating mode configuration register */
    static RW_ uint32_t* const ETHERNET_MAC_MACECR_PTR                               = (RW_ uint32_t* const)0x40028004U;   /** @brief Extended operating mode configuration register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPFR_PTR                               = (RW_ uint32_t* const)0x40028008U;   /** @brief Packet filtering control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACWTR_PTR                               = (RW_ uint32_t* const)0x4002800CU;   /** @brief Watchdog timeout register */
    static RW_ uint32_t* const ETHERNET_MAC_MACHT0R_PTR                              = (RW_ uint32_t* const)0x40028010U;   /** @brief Hash table 0 register */
    static RW_ uint32_t* const ETHERNET_MAC_MACHT1R_PTR                              = (RW_ uint32_t* const)0x40028014U;   /** @brief Hash table 1 register */
    static RW_ uint32_t* const ETHERNET_MAC_MACVTR_PTR                               = (RW_ uint32_t* const)0x40028050U;   /** @brief VLAN tag register */
    static RW_ uint32_t* const ETHERNET_MAC_MACVHTR_PTR                              = (RW_ uint32_t* const)0x40028058U;   /** @brief VLAN hash table register */
    static RW_ uint32_t* const ETHERNET_MAC_MACVIR_PTR                               = (RW_ uint32_t* const)0x40028060U;   /** @brief VLAN inclusion register */
    static RW_ uint32_t* const ETHERNET_MAC_MACIVIR_PTR                              = (RW_ uint32_t* const)0x40028064U;   /** @brief Inner VLAN inclusion register */
    static RW_ uint32_t* const ETHERNET_MAC_MACQTXFCR_PTR                            = (RW_ uint32_t* const)0x40028070U;   /** @brief Tx queue flow control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACRXFCR_PTR                             = (RW_ uint32_t* const)0x40028090U;   /** @brief Rx flow control register */
    static RO_ uint32_t* const ETHERNET_MAC_MACISR_PTR                               = (RO_ uint32_t* const)0x400280B0U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACIER_PTR                               = (RW_ uint32_t* const)0x400280B4U;   /** @brief Interrupt enable register */
    static RO_ uint32_t* const ETHERNET_MAC_MACRXTXSR_PTR                            = (RO_ uint32_t* const)0x400280B8U;   /** @brief Rx tx status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPCSR_PTR                              = (RW_ uint32_t* const)0x400280C0U;   /** @brief PMT control status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACRWKPFR_PTR                            = (RW_ uint32_t* const)0x400280C4U;   /** @brief Remove wakeup packet filter register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLCSR_PTR                              = (RW_ uint32_t* const)0x400280D0U;   /** @brief LPI control status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLTCR_PTR                              = (RW_ uint32_t* const)0x400280D4U;   /** @brief LPI timers control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLETR_PTR                              = (RW_ uint32_t* const)0x400280D8U;   /** @brief LPI entry timer register */
    static RW_ uint32_t* const ETHERNET_MAC_MAC1USTCR_PTR                            = (RW_ uint32_t* const)0x400280DCU;   /** @brief 1-microsecond-tick counter register */
    static RO_ uint32_t* const ETHERNET_MAC_MACVR_PTR                                = (RO_ uint32_t* const)0x40028110U;   /** @brief Version register */
    static RO_ uint32_t* const ETHERNET_MAC_MACHWF1R_PTR                             = (RO_ uint32_t* const)0x40028120U;   /** @brief HW feature 1 register */
    static RO_ uint32_t* const ETHERNET_MAC_MACHWF2R_PTR                             = (RO_ uint32_t* const)0x40028124U;   /** @brief HW feature 2 register */
    static RW_ uint32_t* const ETHERNET_MAC_MACMDIOAR_PTR                            = (RW_ uint32_t* const)0x40028200U;   /** @brief MDIO address register */
    static RW_ uint32_t* const ETHERNET_MAC_MACMDIODR_PTR                            = (RW_ uint32_t* const)0x40028204U;   /** @brief MDIO data register */
    static RW_ uint32_t* const ETHERNET_MAC_MACARPAR_PTR                             = (RW_ uint32_t* const)0x40028AE0U;   /** @brief ARP address register */
    static RW_ uint32_t* const ETHERNET_MAC_MACA0HR_PTR                              = (RW_ uint32_t* const)0x40028300U;   /** @brief Address 0 high register */
    static RW_ uint32_t* const ETHERNET_MAC_MACA1HR_PTR                              = (RW_ uint32_t* const)0x40028308U;   /** @brief Address 1 high register */
    static RW_ uint32_t* const ETHERNET_MAC_MACA2HR_PTR                              = (RW_ uint32_t* const)0x40028310U;   /** @brief Address 2 high register */
    static RW_ uint32_t* const ETHERNET_MAC_MACA3HR_PTR                              = (RW_ uint32_t* const)0x40028318U;   /** @brief Address 3 high register */
    static RW_ uint32_t* const ETHERNET_MAC_MMC_CONTROL_PTR                          = (RW_ uint32_t* const)0x40028700U;   /** @brief MMC control register */
    static RO_ uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_PTR                     = (RO_ uint32_t* const)0x40028704U;   /** @brief MMC rx interrupt register */
    static RO_ uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_PTR                     = (RO_ uint32_t* const)0x40028708U;   /** @brief MMC tx interrupt register */
    static RW_ uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_PTR                = (RW_ uint32_t* const)0x4002870CU;   /** @brief MMC rx interrupt mask register */
    static RW_ uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_PTR                = (RW_ uint32_t* const)0x40028710U;   /** @brief MMC tx interrupt mask register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_PTR     = (RO_ uint32_t* const)0x4002874CU;   /** @brief Tx single collision good packets register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_PTR   = (RO_ uint32_t* const)0x40028750U;   /** @brief Tx multiple collision good packets register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_PACKET_COUNT_GOOD_PTR                 = (RO_ uint32_t* const)0x40028768U;   /** @brief Tx packet count good register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_CRC_ERROR_PACKETS_PTR                 = (RO_ uint32_t* const)0x40028794U;   /** @brief Rx CRC error packets register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_PTR           = (RO_ uint32_t* const)0x40028798U;   /** @brief Rx alignment error packets register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_PTR              = (RO_ uint32_t* const)0x400287C4U;   /** @brief Rx unicast packets good register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_LPI_USEC_CNTR_PTR                     = (RO_ uint32_t* const)0x400287ECU;   /** @brief Tx LPI microsecond timer register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_LPI_TRAN_CNTR_PTR                     = (RO_ uint32_t* const)0x400287F0U;   /** @brief Tx LPI transition counter register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_LPI_USEC_CNTR_PTR                     = (RO_ uint32_t* const)0x400287F4U;   /** @brief Rx LPI microsecond counter register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_LPI_TRAN_CNTR_PTR                     = (RO_ uint32_t* const)0x400287F8U;   /** @brief Rx LPI transition counter register */
    static RO_ uint32_t* const ETHERNET_MAC_MACDR_PTR                                = (RO_ uint32_t* const)0x40028114U;   /** @brief Debug register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSCR_PTR                              = (RW_ uint32_t* const)0x40028B00U;   /** @brief Timestamp control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSSIR_PTR                              = (RW_ uint32_t* const)0x40028B04U;   /** @brief Sub-second increment register */
    static RO_ uint32_t* const ETHERNET_MAC_MACSTSR_PTR                              = (RO_ uint32_t* const)0x40028B08U;   /** @brief System time seconds register */
    static RO_ uint32_t* const ETHERNET_MAC_MACSTNR_PTR                              = (RO_ uint32_t* const)0x40028B0CU;   /** @brief System time nanoseconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSTSUR_PTR                             = (RW_ uint32_t* const)0x40028B10U;   /** @brief System time seconds update register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSTNUR_PTR                             = (RW_ uint32_t* const)0x40028B14U;   /** @brief System time nanoseconds update register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSAR_PTR                              = (RW_ uint32_t* const)0x40028B18U;   /** @brief Timestamp addend register */
    static RO_ uint32_t* const ETHERNET_MAC_MACTSSR_PTR                              = (RO_ uint32_t* const)0x40028B20U;   /** @brief Timestamp status register */
    static RO_ uint32_t* const ETHERNET_MAC_MACTXTSSNR_PTR                           = (RO_ uint32_t* const)0x40028B30U;   /** @brief Tx timestamp status nanoseconds register */
    static RO_ uint32_t* const ETHERNET_MAC_MACTXTSSSR_PTR                           = (RO_ uint32_t* const)0x40028B34U;   /** @brief Tx timestamp status seconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACACR_PTR                               = (RW_ uint32_t* const)0x40028B40U;   /** @brief Auxiliary control register */
    static RO_ uint32_t* const ETHERNET_MAC_MACATSNR_PTR                             = (RO_ uint32_t* const)0x40028B48U;   /** @brief Auxiliary timestamp nanoseconds register */
    static RO_ uint32_t* const ETHERNET_MAC_MACATSSR_PTR                             = (RO_ uint32_t* const)0x40028B4CU;   /** @brief Auxiliary timestamp seconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSIACR_PTR                            = (RW_ uint32_t* const)0x40028B50U;   /** @brief Timestamp ingress asymmetric correction register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSEACR_PTR                            = (RW_ uint32_t* const)0x40028B54U;   /** @brief Timestamp egress asymmetric correction register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSICNR_PTR                            = (RW_ uint32_t* const)0x40028B58U;   /** @brief Timestamp ingress correction nanosecond register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSECNR_PTR                            = (RW_ uint32_t* const)0x40028B5CU;   /** @brief Timestamp egress correction nanosecond register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSCR_PTR                             = (RW_ uint32_t* const)0x40028B70U;   /** @brief PPS control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSTTSR_PTR                           = (RW_ uint32_t* const)0x40028B80U;   /** @brief PPS target time seconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSTTNR_PTR                           = (RW_ uint32_t* const)0x40028B84U;   /** @brief PPS target time nanoseconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSIR_PTR                             = (RW_ uint32_t* const)0x40028B88U;   /** @brief PPS interval register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSWR_PTR                             = (RW_ uint32_t* const)0x40028B8CU;   /** @brief PPS width register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPOCR_PTR                              = (RW_ uint32_t* const)0x40028BC0U;   /** @brief PTP offload control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSPI0R_PTR                             = (RW_ uint32_t* const)0x40028BC4U;   /** @brief PTP source port identity 0 register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSPI1R_PTR                             = (RW_ uint32_t* const)0x40028BC8U;   /** @brief PTP source port identity 1 register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSPI2R_PTR                             = (RW_ uint32_t* const)0x40028BCCU;   /** @brief PTP source port identity 2 register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLMIR_PTR                              = (RW_ uint32_t* const)0x40028BD0U;   /** @brief Log message interval register */

    /**** @subsection Enumerated ETHERNET_MAC Register Pointers ****/

    static RW_ uint32_t* const ETHERNET_MAC_MACAxLR_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x40028304U,   /** @brief Address 0 low register */
      [1] = (RW_ uint32_t* const)0x4002830CU,   /** @brief Address 1 low register */
      [2] = (RW_ uint32_t* const)0x40028314U,   /** @brief Address 2 low register */
      [3] = (RW_ uint32_t* const)0x4002831CU,   /** @brief Address 3 low register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL3L4CxR_PTR[2] = {
      [0] = (RW_ uint32_t* const)0x40028900U,   /** @brief L3 and L4 control 0 register */
      [1] = (RW_ uint32_t* const)0x40028930U,   /** @brief L3 and L4 control 1 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL4AxR_PTR[2] = {
      [0] = (RW_ uint32_t* const)0x40028904U,   /** @brief Layer4 address filter 0 register */
      [1] = (RW_ uint32_t* const)0x40028934U,   /** @brief Layer 4 address filter 1 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL3AxR_PTR[32] = {
      [0]  = (RW_ uint32_t* const)0x40028910U,   /** @brief MACL3A00R */
      [10] = (RW_ uint32_t* const)0x40028914U,   /** @brief Layer3 address 1 filter 0 register */
      [11] = (RW_ uint32_t* const)0x40028944U,   /** @brief Layer3 address 1 filter 1 register */
      [21] = (RW_ uint32_t* const)0x40028948U,   /** @brief Layer3 address 2 filter 1 register */
      [31] = (RW_ uint32_t* const)0x4002894CU,   /** @brief Layer3 address 3 filter 1 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL3Ax_PTR[31] = {
      [20] = (RW_ uint32_t* const)0x40028918U,   /** @brief Layer3 address 2 filter 0 register */
      [30] = (RW_ uint32_t* const)0x4002891CU,   /** @brief Layer3 address 3 filter 0 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL3A0xR_PTR[2] = {
      [1] = (RW_ uint32_t* const)0x40028940U,   /** @brief Layer3 address 0 filter 1 register */
    };

    /**** @subsection ETHERNET_MAC Register Reset Values ****/

    static const uint32_t ETHERNET_MAC_DMAMR_RST                                = 0x00000000U;   /** @brief DMAMR register reset value. */
    static const uint32_t ETHERNET_MAC_DMASBMR_RST                              = 0x01010000U;   /** @brief DMASBMR register reset value. */
    static const uint32_t ETHERNET_MAC_DMAISR_RST                               = 0x00000000U;   /** @brief DMAISR register reset value. */
    static const uint32_t ETHERNET_MAC_DMADSR_RST                               = 0x00000000U;   /** @brief DMADSR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACCR_RST                               = 0x00000000U;   /** @brief DMACCR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACTXCR_RST                             = 0x00000000U;   /** @brief DMACTXCR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RST                             = 0x00000000U;   /** @brief DMACRXCR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACTXDLAR_RST                           = 0x00000000U;   /** @brief DMACTXDLAR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACRXDLAR_RST                           = 0x00000000U;   /** @brief DMACRXDLAR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACTXDTPR_RST                           = 0x00000000U;   /** @brief DMACTXDTPR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACRXDTPR_RST                           = 0x00000000U;   /** @brief DMACRXDTPR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACTXRLR_RST                            = 0x00000000U;   /** @brief DMACTXRLR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACRXRLR_RST                            = 0x00000000U;   /** @brief DMACRXRLR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACIER_RST                              = 0x00000000U;   /** @brief DMACIER register reset value. */
    static const uint32_t ETHERNET_MAC_DMACRXIWTR_RST                           = 0x00000000U;   /** @brief DMACRXIWTR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACCATXDR_RST                           = 0x00000000U;   /** @brief DMACCATXDR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACCARXDR_RST                           = 0x00000000U;   /** @brief DMACCARXDR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACCATXBR_RST                           = 0x00000000U;   /** @brief DMACCATXBR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACCARXBR_RST                           = 0x00000000U;   /** @brief DMACCARXBR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACSR_RST                               = 0x00000000U;   /** @brief DMACSR register reset value. */
    static const uint32_t ETHERNET_MAC_DMACMFCR_RST                             = 0x00000000U;   /** @brief DMACMFCR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLOMR_RST                               = 0x00000000U;   /** @brief MTLOMR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLISR_RST                               = 0x00000000U;   /** @brief MTLISR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_RST                            = 0x00070008U;   /** @brief MTLTXQOMR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLTXQUR_RST                             = 0x00000000U;   /** @brief MTLTXQUR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_RST                             = 0x00000000U;   /** @brief MTLTXQDR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLQICSR_RST                             = 0x00000000U;   /** @brief MTLQICSR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RST                            = 0x00700000U;   /** @brief MTLRXQOMR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_RST                          = 0x00000000U;   /** @brief MTLRXQMPOCR register reset value. */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RST                             = 0x00000000U;   /** @brief MTLRXQDR register reset value. */
    static const uint32_t ETHERNET_MAC_MACCR_RST                                = 0x00000000U;   /** @brief MACCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACECR_RST                               = 0x00000000U;   /** @brief MACECR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPFR_RST                               = 0x00000000U;   /** @brief MACPFR register reset value. */
    static const uint32_t ETHERNET_MAC_MACWTR_RST                               = 0x00000000U;   /** @brief MACWTR register reset value. */
    static const uint32_t ETHERNET_MAC_MACHT0R_RST                              = 0x00000000U;   /** @brief MACHT0R register reset value. */
    static const uint32_t ETHERNET_MAC_MACHT1R_RST                              = 0x00000000U;   /** @brief MACHT1R register reset value. */
    static const uint32_t ETHERNET_MAC_MACVTR_RST                               = 0x00000000U;   /** @brief MACVTR register reset value. */
    static const uint32_t ETHERNET_MAC_MACVHTR_RST                              = 0x00000000U;   /** @brief MACVHTR register reset value. */
    static const uint32_t ETHERNET_MAC_MACVIR_RST                               = 0x00000000U;   /** @brief MACVIR register reset value. */
    static const uint32_t ETHERNET_MAC_MACIVIR_RST                              = 0x00000000U;   /** @brief MACIVIR register reset value. */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_RST                            = 0x00000000U;   /** @brief MACQTXFCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACRXFCR_RST                             = 0x00000000U;   /** @brief MACRXFCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACISR_RST                               = 0x00000000U;   /** @brief MACISR register reset value. */
    static const uint32_t ETHERNET_MAC_MACIER_RST                               = 0x00000000U;   /** @brief MACIER register reset value. */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_RST                            = 0x00000000U;   /** @brief MACRXTXSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPCSR_RST                              = 0x00000000U;   /** @brief MACPCSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACRWKPFR_RST                            = 0x00000000U;   /** @brief MACRWKPFR register reset value. */
    static const uint32_t ETHERNET_MAC_MACLCSR_RST                              = 0x00000000U;   /** @brief MACLCSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACLTCR_RST                              = 0x03E80000U;   /** @brief MACLTCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACLETR_RST                              = 0x00000000U;   /** @brief MACLETR register reset value. */
    static const uint32_t ETHERNET_MAC_MAC1USTCR_RST                            = 0x00000000U;   /** @brief MAC1USTCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACVR_RST                                = 0x00003041U;   /** @brief MACVR register reset value. */
    static const uint32_t ETHERNET_MAC_MACHWF1R_RST                             = 0x11841904U;   /** @brief MACHWF1R register reset value. */
    static const uint32_t ETHERNET_MAC_MACHWF2R_RST                             = 0x41000000U;   /** @brief MACHWF2R register reset value. */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_RST                            = 0x00000000U;   /** @brief MACMDIOAR register reset value. */
    static const uint32_t ETHERNET_MAC_MACMDIODR_RST                            = 0x00000000U;   /** @brief MACMDIODR register reset value. */
    static const uint32_t ETHERNET_MAC_MACARPAR_RST                             = 0x00000000U;   /** @brief MACARPAR register reset value. */
    static const uint32_t ETHERNET_MAC_MACA0HR_RST                              = 0x8000FFFFU;   /** @brief MACA0HR register reset value. */
    static const uint32_t ETHERNET_MAC_MACA1HR_RST                              = 0x0000FFFFU;   /** @brief MACA1HR register reset value. */
    static const uint32_t ETHERNET_MAC_MACA2HR_RST                              = 0x0000FFFFU;   /** @brief MACA2HR register reset value. */
    static const uint32_t ETHERNET_MAC_MACA3HR_RST                              = 0x0000FFFFU;   /** @brief MACA3HR register reset value. */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_RST                          = 0x00000000U;   /** @brief MMC_CONTROL register reset value. */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RST                     = 0x00000000U;   /** @brief MMC_RX_INTERRUPT register reset value. */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_RST                     = 0x00000000U;   /** @brief MMC_TX_INTERRUPT register reset value. */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RST                = 0x00000000U;   /** @brief MMC_RX_INTERRUPT_MASK register reset value. */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_RST                = 0x00000000U;   /** @brief MMC_TX_INTERRUPT_MASK register reset value. */
    static const uint32_t ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_RST     = 0x00000000U;   /** @brief TX_SINGLE_COLLISION_GOOD_PACKETS register reset value. */
    static const uint32_t ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_RST   = 0x00000000U;   /** @brief TX_MULTIPLE_COLLISION_GOOD_PACKETS register reset value. */
    static const uint32_t ETHERNET_MAC_TX_PACKET_COUNT_GOOD_RST                 = 0x00000000U;   /** @brief TX_PACKET_COUNT_GOOD register reset value. */
    static const uint32_t ETHERNET_MAC_RX_CRC_ERROR_PACKETS_RST                 = 0x00000000U;   /** @brief RX_CRC_ERROR_PACKETS register reset value. */
    static const uint32_t ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_RST           = 0x00000000U;   /** @brief RX_ALIGNMENT_ERROR_PACKETS register reset value. */
    static const uint32_t ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_RST              = 0x00000000U;   /** @brief RX_UNICAST_PACKETS_GOOD register reset value. */
    static const uint32_t ETHERNET_MAC_TX_LPI_USEC_CNTR_RST                     = 0x00000000U;   /** @brief TX_LPI_USEC_CNTR register reset value. */
    static const uint32_t ETHERNET_MAC_TX_LPI_TRAN_CNTR_RST                     = 0x00000000U;   /** @brief TX_LPI_TRAN_CNTR register reset value. */
    static const uint32_t ETHERNET_MAC_RX_LPI_USEC_CNTR_RST                     = 0x00000000U;   /** @brief RX_LPI_USEC_CNTR register reset value. */
    static const uint32_t ETHERNET_MAC_RX_LPI_TRAN_CNTR_RST                     = 0x00000000U;   /** @brief RX_LPI_TRAN_CNTR register reset value. */
    static const uint32_t ETHERNET_MAC_MACDR_RST                                = 0x00000000U;   /** @brief MACDR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTSCR_RST                              = 0x00000200U;   /** @brief MACTSCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACSSIR_RST                              = 0x00000000U;   /** @brief MACSSIR register reset value. */
    static const uint32_t ETHERNET_MAC_MACSTSR_RST                              = 0x00000000U;   /** @brief MACSTSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACSTNR_RST                              = 0x00000000U;   /** @brief MACSTNR register reset value. */
    static const uint32_t ETHERNET_MAC_MACSTSUR_RST                             = 0x00000000U;   /** @brief MACSTSUR register reset value. */
    static const uint32_t ETHERNET_MAC_MACSTNUR_RST                             = 0x00000000U;   /** @brief MACSTNUR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTSAR_RST                              = 0x00000000U;   /** @brief MACTSAR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTSSR_RST                              = 0x00000000U;   /** @brief MACTSSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTXTSSNR_RST                           = 0x00000000U;   /** @brief MACTXTSSNR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTXTSSSR_RST                           = 0x00000000U;   /** @brief MACTXTSSSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACACR_RST                               = 0x00000000U;   /** @brief MACACR register reset value. */
    static const uint32_t ETHERNET_MAC_MACATSNR_RST                             = 0x00000000U;   /** @brief MACATSNR register reset value. */
    static const uint32_t ETHERNET_MAC_MACATSSR_RST                             = 0x00000000U;   /** @brief MACATSSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTSIACR_RST                            = 0x00000000U;   /** @brief MACTSIACR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTSEACR_RST                            = 0x00000000U;   /** @brief MACTSEACR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTSICNR_RST                            = 0x00000000U;   /** @brief MACTSICNR register reset value. */
    static const uint32_t ETHERNET_MAC_MACTSECNR_RST                            = 0x00000000U;   /** @brief MACTSECNR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPPSCR_RST                             = 0x00000000U;   /** @brief MACPPSCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPPSTTSR_RST                           = 0x00000000U;   /** @brief MACPPSTTSR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPPSTTNR_RST                           = 0x00000000U;   /** @brief MACPPSTTNR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPPSIR_RST                             = 0x00000000U;   /** @brief MACPPSIR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPPSWR_RST                             = 0x00000000U;   /** @brief MACPPSWR register reset value. */
    static const uint32_t ETHERNET_MAC_MACPOCR_RST                              = 0x00000000U;   /** @brief MACPOCR register reset value. */
    static const uint32_t ETHERNET_MAC_MACSPI0R_RST                             = 0x00000000U;   /** @brief MACSPI0R register reset value. */
    static const uint32_t ETHERNET_MAC_MACSPI1R_RST                             = 0x00000000U;   /** @brief MACSPI1R register reset value. */
    static const uint32_t ETHERNET_MAC_MACSPI2R_RST                             = 0x00000000U;   /** @brief MACSPI2R register reset value. */
    static const uint32_t ETHERNET_MAC_MACLMIR_RST                              = 0x00000000U;   /** @brief MACLMIR register reset value. */

    /**** @subsection Enumerated ETHERNET_MAC Register Reset Values ****/

    static const uint32_t ETHERNET_MAC_MACAxLR_RST[4] = {
      [0] = 0xFFFFFFFFU,   /** @brief MACA0LR register reset value. */
      [1] = 0xFFFFFFFFU,   /** @brief MACA1LR register reset value. */
      [2] = 0xFFFFFFFFU,   /** @brief MACA2LR register reset value. */
      [3] = 0xFFFFFFFFU,   /** @brief MACA3LR register reset value. */
    };

    static const uint32_t ETHERNET_MAC_MACL3L4CxR_RST[2] = {
      [0] = 0x00000000U,   /** @brief MACL3L4C0R register reset value. */
      [1] = 0x00000000U,   /** @brief MACL3L4C1R register reset value. */
    };

    static const uint32_t ETHERNET_MAC_MACL4AxR_RST[2] = {
      [0] = 0x00000000U,   /** @brief MACL4A0R register reset value. */
      [1] = 0x00000000U,   /** @brief MACL4A1R register reset value. */
    };

    static const uint32_t ETHERNET_MAC_MACL3AxR_RST[32] = {
      [0]  = 0x00000000U,   /** @brief MACL3A00R register reset value. */
      [10] = 0x00000000U,   /** @brief MACL3A10R register reset value. */
      [11] = 0x00000000U,   /** @brief MACL3A11R register reset value. */
      [21] = 0x00000000U,   /** @brief MACL3A21R register reset value. */
      [31] = 0x00000000U,   /** @brief MACL3A31R register reset value. */
    };

    static const uint32_t ETHERNET_MAC_MACL3Ax_RST[31] = {
      [20] = 0x00000000U,   /** @brief MACL3A20 register reset value. */
      [30] = 0x00000000U,   /** @brief MACL3A30 register reset value. */
    };

    static const uint32_t ETHERNET_MAC_MACL3A0xR_RST[2] = {
      [1] = 0x00000000U,   /** @brief MACL3A01R register reset value. */
    };

    /**** @subsection Enumerated ETHERNET_MAC Register Value Types ****/

    typedef uint32_t ETHERNET_MAC_DMAMR_t;                                /** @brief DMAMR register value type. */
    typedef uint32_t ETHERNET_MAC_DMASBMR_t;                              /** @brief DMASBMR register value type. */
    typedef uint32_t ETHERNET_MAC_DMAISR_t;                               /** @brief DMAISR register value type. */
    typedef uint32_t ETHERNET_MAC_DMADSR_t;                               /** @brief DMADSR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCR_t;                               /** @brief DMACCR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXCR_t;                             /** @brief DMACTXCR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXCR_t;                             /** @brief DMACRXCR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXDLAR_t;                           /** @brief DMACTXDLAR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXDLAR_t;                           /** @brief DMACRXDLAR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXDTPR_t;                           /** @brief DMACTXDTPR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXDTPR_t;                           /** @brief DMACRXDTPR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXRLR_t;                            /** @brief DMACTXRLR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXRLR_t;                            /** @brief DMACRXRLR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACIER_t;                              /** @brief DMACIER register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXIWTR_t;                           /** @brief DMACRXIWTR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCATXDR_t;                           /** @brief DMACCATXDR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCARXDR_t;                           /** @brief DMACCARXDR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCATXBR_t;                           /** @brief DMACCATXBR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCARXBR_t;                           /** @brief DMACCARXBR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACSR_t;                               /** @brief DMACSR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACMFCR_t;                             /** @brief DMACMFCR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLOMR_t;                               /** @brief MTLOMR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLISR_t;                               /** @brief MTLISR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLTXQOMR_t;                            /** @brief MTLTXQOMR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLTXQUR_t;                             /** @brief MTLTXQUR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLTXQDR_t;                             /** @brief MTLTXQDR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLQICSR_t;                             /** @brief MTLQICSR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLRXQOMR_t;                            /** @brief MTLRXQOMR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLRXQMPOCR_t;                          /** @brief MTLRXQMPOCR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLRXQDR_t;                             /** @brief MTLRXQDR register value type. */
    typedef uint32_t ETHERNET_MAC_MACCR_t;                                /** @brief MACCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACECR_t;                               /** @brief MACECR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPFR_t;                               /** @brief MACPFR register value type. */
    typedef uint32_t ETHERNET_MAC_MACWTR_t;                               /** @brief MACWTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACHT0R_t;                              /** @brief MACHT0R register value type. */
    typedef uint32_t ETHERNET_MAC_MACHT1R_t;                              /** @brief MACHT1R register value type. */
    typedef uint32_t ETHERNET_MAC_MACVTR_t;                               /** @brief MACVTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACVHTR_t;                              /** @brief MACVHTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACVIR_t;                               /** @brief MACVIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACIVIR_t;                              /** @brief MACIVIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACQTXFCR_t;                            /** @brief MACQTXFCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACRXFCR_t;                             /** @brief MACRXFCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACISR_t;                               /** @brief MACISR register value type. */
    typedef uint32_t ETHERNET_MAC_MACIER_t;                               /** @brief MACIER register value type. */
    typedef uint32_t ETHERNET_MAC_MACRXTXSR_t;                            /** @brief MACRXTXSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPCSR_t;                              /** @brief MACPCSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACRWKPFR_t;                            /** @brief MACRWKPFR register value type. */
    typedef uint32_t ETHERNET_MAC_MACLCSR_t;                              /** @brief MACLCSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACLTCR_t;                              /** @brief MACLTCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACLETR_t;                              /** @brief MACLETR register value type. */
    typedef uint32_t ETHERNET_MAC_MAC1USTCR_t;                            /** @brief MAC1USTCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACVR_t;                                /** @brief MACVR register value type. */
    typedef uint32_t ETHERNET_MAC_MACHWF1R_t;                             /** @brief MACHWF1R register value type. */
    typedef uint32_t ETHERNET_MAC_MACHWF2R_t;                             /** @brief MACHWF2R register value type. */
    typedef uint32_t ETHERNET_MAC_MACMDIOAR_t;                            /** @brief MACMDIOAR register value type. */
    typedef uint32_t ETHERNET_MAC_MACMDIODR_t;                            /** @brief MACMDIODR register value type. */
    typedef uint32_t ETHERNET_MAC_MACARPAR_t;                             /** @brief MACARPAR register value type. */
    typedef uint32_t ETHERNET_MAC_MACA0HR_t;                              /** @brief MACA0HR register value type. */
    typedef uint32_t ETHERNET_MAC_MACAxLR_t;                              /** @brief MACAxLR register value type. */
    typedef uint32_t ETHERNET_MAC_MACA1HR_t;                              /** @brief MACA1HR register value type. */
    typedef uint32_t ETHERNET_MAC_MACA2HR_t;                              /** @brief MACA2HR register value type. */
    typedef uint32_t ETHERNET_MAC_MACA3HR_t;                              /** @brief MACA3HR register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_CONTROL_t;                          /** @brief MMC_CONTROL register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_t;                     /** @brief MMC_RX_INTERRUPT register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_t;                     /** @brief MMC_TX_INTERRUPT register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_t;                /** @brief MMC_RX_INTERRUPT_MASK register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_t;                /** @brief MMC_TX_INTERRUPT_MASK register value type. */
    typedef uint32_t ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_t;     /** @brief TX_SINGLE_COLLISION_GOOD_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_t;   /** @brief TX_MULTIPLE_COLLISION_GOOD_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_TX_PACKET_COUNT_GOOD_t;                 /** @brief TX_PACKET_COUNT_GOOD register value type. */
    typedef uint32_t ETHERNET_MAC_RX_CRC_ERROR_PACKETS_t;                 /** @brief RX_CRC_ERROR_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_t;           /** @brief RX_ALIGNMENT_ERROR_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_t;              /** @brief RX_UNICAST_PACKETS_GOOD register value type. */
    typedef uint32_t ETHERNET_MAC_TX_LPI_USEC_CNTR_t;                     /** @brief TX_LPI_USEC_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_TX_LPI_TRAN_CNTR_t;                     /** @brief TX_LPI_TRAN_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_RX_LPI_USEC_CNTR_t;                     /** @brief RX_LPI_USEC_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_RX_LPI_TRAN_CNTR_t;                     /** @brief RX_LPI_TRAN_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL3L4CxR_t;                           /** @brief MACL3L4CxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL4AxR_t;                             /** @brief MACL4AxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACDR_t;                                /** @brief MACDR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL3AxR_t;                             /** @brief MACL3AxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL3Ax_t;                              /** @brief MACL3Ax register value type. */
    typedef uint32_t ETHERNET_MAC_MACL3A0xR_t;                            /** @brief MACL3A0xR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSCR_t;                              /** @brief MACTSCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSSIR_t;                              /** @brief MACSSIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTSR_t;                              /** @brief MACSTSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTNR_t;                              /** @brief MACSTNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTSUR_t;                             /** @brief MACSTSUR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTNUR_t;                             /** @brief MACSTNUR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSAR_t;                              /** @brief MACTSAR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSSR_t;                              /** @brief MACTSSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTXTSSNR_t;                           /** @brief MACTXTSSNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTXTSSSR_t;                           /** @brief MACTXTSSSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACACR_t;                               /** @brief MACACR register value type. */
    typedef uint32_t ETHERNET_MAC_MACATSNR_t;                             /** @brief MACATSNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACATSSR_t;                             /** @brief MACATSSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSIACR_t;                            /** @brief MACTSIACR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSEACR_t;                            /** @brief MACTSEACR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSICNR_t;                            /** @brief MACTSICNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSECNR_t;                            /** @brief MACTSECNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSCR_t;                             /** @brief MACPPSCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSTTSR_t;                           /** @brief MACPPSTTSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSTTNR_t;                           /** @brief MACPPSTTNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSIR_t;                             /** @brief MACPPSIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSWR_t;                             /** @brief MACPPSWR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPOCR_t;                              /** @brief MACPOCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSPI0R_t;                             /** @brief MACSPI0R register value type. */
    typedef uint32_t ETHERNET_MAC_MACSPI1R_t;                             /** @brief MACSPI1R register value type. */
    typedef uint32_t ETHERNET_MAC_MACSPI2R_t;                             /** @brief MACSPI2R register value type. */
    typedef uint32_t ETHERNET_MAC_MACLMIR_t;                              /** @brief MACLMIR register value type. */

    /**** @subsection Enumerated ETHERNET_MAC Register Pointer Types ****/

    typedef uint32_t* const ETHERNET_MAC_DMAMR_PTR_t;                                /** @brief DMAMR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMASBMR_PTR_t;                              /** @brief DMASBMR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMAISR_PTR_t;                               /** @brief DMAISR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMADSR_PTR_t;                               /** @brief DMADSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACCR_PTR_t;                               /** @brief DMACCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACTXCR_PTR_t;                             /** @brief DMACTXCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACRXCR_PTR_t;                             /** @brief DMACRXCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACTXDLAR_PTR_t;                           /** @brief DMACTXDLAR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACRXDLAR_PTR_t;                           /** @brief DMACRXDLAR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACTXDTPR_PTR_t;                           /** @brief DMACTXDTPR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACRXDTPR_PTR_t;                           /** @brief DMACRXDTPR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACTXRLR_PTR_t;                            /** @brief DMACTXRLR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACRXRLR_PTR_t;                            /** @brief DMACRXRLR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACIER_PTR_t;                              /** @brief DMACIER register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACRXIWTR_PTR_t;                           /** @brief DMACRXIWTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACCATXDR_PTR_t;                           /** @brief DMACCATXDR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACCARXDR_PTR_t;                           /** @brief DMACCARXDR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACCATXBR_PTR_t;                           /** @brief DMACCATXBR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACCARXBR_PTR_t;                           /** @brief DMACCARXBR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACSR_PTR_t;                               /** @brief DMACSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_DMACMFCR_PTR_t;                             /** @brief DMACMFCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLOMR_PTR_t;                               /** @brief MTLOMR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLISR_PTR_t;                               /** @brief MTLISR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLTXQOMR_PTR_t;                            /** @brief MTLTXQOMR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLTXQUR_PTR_t;                             /** @brief MTLTXQUR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLTXQDR_PTR_t;                             /** @brief MTLTXQDR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLQICSR_PTR_t;                             /** @brief MTLQICSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLRXQOMR_PTR_t;                            /** @brief MTLRXQOMR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLRXQMPOCR_PTR_t;                          /** @brief MTLRXQMPOCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MTLRXQDR_PTR_t;                             /** @brief MTLRXQDR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACCR_PTR_t;                                /** @brief MACCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACECR_PTR_t;                               /** @brief MACECR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPFR_PTR_t;                               /** @brief MACPFR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACWTR_PTR_t;                               /** @brief MACWTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACHT0R_PTR_t;                              /** @brief MACHT0R register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACHT1R_PTR_t;                              /** @brief MACHT1R register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACVTR_PTR_t;                               /** @brief MACVTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACVHTR_PTR_t;                              /** @brief MACVHTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACVIR_PTR_t;                               /** @brief MACVIR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACIVIR_PTR_t;                              /** @brief MACIVIR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACQTXFCR_PTR_t;                            /** @brief MACQTXFCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACRXFCR_PTR_t;                             /** @brief MACRXFCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACISR_PTR_t;                               /** @brief MACISR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACIER_PTR_t;                               /** @brief MACIER register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACRXTXSR_PTR_t;                            /** @brief MACRXTXSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPCSR_PTR_t;                              /** @brief MACPCSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACRWKPFR_PTR_t;                            /** @brief MACRWKPFR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACLCSR_PTR_t;                              /** @brief MACLCSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACLTCR_PTR_t;                              /** @brief MACLTCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACLETR_PTR_t;                              /** @brief MACLETR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MAC1USTCR_PTR_t;                            /** @brief MAC1USTCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACVR_PTR_t;                                /** @brief MACVR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACHWF1R_PTR_t;                             /** @brief MACHWF1R register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACHWF2R_PTR_t;                             /** @brief MACHWF2R register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACMDIOAR_PTR_t;                            /** @brief MACMDIOAR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACMDIODR_PTR_t;                            /** @brief MACMDIODR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACARPAR_PTR_t;                             /** @brief MACARPAR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACA0HR_PTR_t;                              /** @brief MACA0HR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACAxLR_PTR_t;                              /** @brief MACAxLR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACA1HR_PTR_t;                              /** @brief MACA1HR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACA2HR_PTR_t;                              /** @brief MACA2HR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACA3HR_PTR_t;                              /** @brief MACA3HR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MMC_CONTROL_PTR_t;                          /** @brief MMC_CONTROL register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_PTR_t;                     /** @brief MMC_RX_INTERRUPT register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_PTR_t;                     /** @brief MMC_TX_INTERRUPT register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_PTR_t;                /** @brief MMC_RX_INTERRUPT_MASK register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_PTR_t;                /** @brief MMC_TX_INTERRUPT_MASK register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_PTR_t;     /** @brief TX_SINGLE_COLLISION_GOOD_PACKETS register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_PTR_t;   /** @brief TX_MULTIPLE_COLLISION_GOOD_PACKETS register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_TX_PACKET_COUNT_GOOD_PTR_t;                 /** @brief TX_PACKET_COUNT_GOOD register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_RX_CRC_ERROR_PACKETS_PTR_t;                 /** @brief RX_CRC_ERROR_PACKETS register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_PTR_t;           /** @brief RX_ALIGNMENT_ERROR_PACKETS register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_PTR_t;              /** @brief RX_UNICAST_PACKETS_GOOD register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_TX_LPI_USEC_CNTR_PTR_t;                     /** @brief TX_LPI_USEC_CNTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_TX_LPI_TRAN_CNTR_PTR_t;                     /** @brief TX_LPI_TRAN_CNTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_RX_LPI_USEC_CNTR_PTR_t;                     /** @brief RX_LPI_USEC_CNTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_RX_LPI_TRAN_CNTR_PTR_t;                     /** @brief RX_LPI_TRAN_CNTR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACL3L4CxR_PTR_t;                           /** @brief MACL3L4CxR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACL4AxR_PTR_t;                             /** @brief MACL4AxR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACDR_PTR_t;                                /** @brief MACDR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACL3AxR_PTR_t;                             /** @brief MACL3AxR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACL3Ax_PTR_t;                              /** @brief MACL3Ax register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACL3A0xR_PTR_t;                            /** @brief MACL3A0xR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTSCR_PTR_t;                              /** @brief MACTSCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSSIR_PTR_t;                              /** @brief MACSSIR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSTSR_PTR_t;                              /** @brief MACSTSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSTNR_PTR_t;                              /** @brief MACSTNR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSTSUR_PTR_t;                             /** @brief MACSTSUR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSTNUR_PTR_t;                             /** @brief MACSTNUR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTSAR_PTR_t;                              /** @brief MACTSAR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTSSR_PTR_t;                              /** @brief MACTSSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTXTSSNR_PTR_t;                           /** @brief MACTXTSSNR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTXTSSSR_PTR_t;                           /** @brief MACTXTSSSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACACR_PTR_t;                               /** @brief MACACR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACATSNR_PTR_t;                             /** @brief MACATSNR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACATSSR_PTR_t;                             /** @brief MACATSSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTSIACR_PTR_t;                            /** @brief MACTSIACR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTSEACR_PTR_t;                            /** @brief MACTSEACR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTSICNR_PTR_t;                            /** @brief MACTSICNR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACTSECNR_PTR_t;                            /** @brief MACTSECNR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPPSCR_PTR_t;                             /** @brief MACPPSCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPPSTTSR_PTR_t;                           /** @brief MACPPSTTSR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPPSTTNR_PTR_t;                           /** @brief MACPPSTTNR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPPSIR_PTR_t;                             /** @brief MACPPSIR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPPSWR_PTR_t;                             /** @brief MACPPSWR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACPOCR_PTR_t;                              /** @brief MACPOCR register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSPI0R_PTR_t;                             /** @brief MACSPI0R register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSPI1R_PTR_t;                             /** @brief MACSPI1R register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACSPI2R_PTR_t;                             /** @brief MACSPI2R register pointer type. */
    typedef uint32_t* const ETHERNET_MAC_MACLMIR_PTR_t;                              /** @brief MACLMIR register pointer type. */

    /**** @subsection ETHERNET_MAC Register Field Masks ****/

    static const uint32_t ETHERNET_MAC_DMAMR_SWR_MASK                           = 0x00000001U;   /** @brief Software reset */
    static const uint32_t ETHERNET_MAC_DMAMR_DA_MASK                            = 0x00000002U;   /** @brief DMA tx or rx arbitration scheme */
    static const uint32_t ETHERNET_MAC_DMAMR_TXPR_MASK                          = 0x00000800U;   /** @brief Transmit priority */
    static const uint32_t ETHERNET_MAC_DMAMR_PR_MASK                            = 0x00007000U;   /** @brief Priority ratio */
    static const uint32_t ETHERNET_MAC_DMAMR_INTM_MASK                          = 0x00010000U;   /** @brief Interrupt mode */
    static const uint32_t ETHERNET_MAC_DMASBMR_FB_MASK                          = 0x00000001U;   /** @brief Fixed burst length */
    static const uint32_t ETHERNET_MAC_DMASBMR_AAL_MASK                         = 0x00001000U;   /** @brief Address-Aligned beats */
    static const uint32_t ETHERNET_MAC_DMASBMR_MB_MASK                          = 0x00004000U;   /** @brief Mixed burst */
    static const uint32_t ETHERNET_MAC_DMASBMR_RB_MASK                          = 0x00008000U;   /** @brief Rebuild incrx burst */
    static const uint32_t ETHERNET_MAC_DMAISR_DC0IS_MASK                        = 0x00000001U;   /** @brief DMA channel interrupt status */
    static const uint32_t ETHERNET_MAC_DMAISR_MTLIS_MASK                        = 0x00010000U;   /** @brief MTL interrupt status */
    static const uint32_t ETHERNET_MAC_DMAISR_MACIS_MASK                        = 0x00020000U;   /** @brief MAC interrupt status */
    static const uint32_t ETHERNET_MAC_DMADSR_AXWHSTS_MASK                      = 0x00000001U;   /** @brief AHB master write channel */
    static const uint32_t ETHERNET_MAC_DMADSR_RPS0_MASK                         = 0x00000F00U;   /** @brief DMA channel receive process state */
    static const uint32_t ETHERNET_MAC_DMADSR_TPS0_MASK                         = 0x0000F000U;   /** @brief DMA channel transmit process state */
    static const uint32_t ETHERNET_MAC_DMACCR_MSS_MASK                          = 0x00003FFFU;   /** @brief Maximum segment size */
    static const uint32_t ETHERNET_MAC_DMACCR_PBLX8_MASK                        = 0x00010000U;   /** @brief 8xPBL mode */
    static const uint32_t ETHERNET_MAC_DMACCR_DSL_MASK                          = 0x001C0000U;   /** @brief Descriptor skip length */
    static const uint32_t ETHERNET_MAC_DMACTXCR_ST_MASK                         = 0x00000001U;   /** @brief Start or stop transmission command */
    static const uint32_t ETHERNET_MAC_DMACTXCR_OSF_MASK                        = 0x00000010U;   /** @brief Operate on second packet */
    static const uint32_t ETHERNET_MAC_DMACTXCR_TSE_MASK                        = 0x00001000U;   /** @brief TCP segmentation enabled */
    static const uint32_t ETHERNET_MAC_DMACTXCR_TXPBL_MASK                      = 0x003F0000U;   /** @brief Transmit programmable burst length */
    static const uint32_t ETHERNET_MAC_DMACRXCR_SR_MASK                         = 0x00000001U;   /** @brief Start or stop receive command */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RBSZ_MASK                       = 0x00007FFEU;   /** @brief Receive buffer size */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RXPBL_MASK                      = 0x003F0000U;   /** @brief RXPBL */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RPF_MASK                        = 0x80000000U;   /** @brief DMA rx channel packet flush */
    static const uint32_t ETHERNET_MAC_DMACTXDLAR_TDESLA_MASK                   = 0xFFFFFFFCU;   /** @brief Start of transmit list */
    static const uint32_t ETHERNET_MAC_DMACRXDLAR_RDESLA_MASK                   = 0xFFFFFFFCU;   /** @brief Start of receive list */
    static const uint32_t ETHERNET_MAC_DMACTXDTPR_TDT_MASK                      = 0xFFFFFFFCU;   /** @brief Transmit descriptor tail pointer */
    static const uint32_t ETHERNET_MAC_DMACRXDTPR_RDT_MASK                      = 0xFFFFFFFCU;   /** @brief Receive descriptor tail pointer */
    static const uint32_t ETHERNET_MAC_DMACTXRLR_TDRL_MASK                      = 0x000003FFU;   /** @brief Transmit descriptor ring length */
    static const uint32_t ETHERNET_MAC_DMACRXRLR_RDRL_MASK                      = 0x000003FFU;   /** @brief Receive descriptor ring length */
    static const uint32_t ETHERNET_MAC_DMACIER_TIE_MASK                         = 0x00000001U;   /** @brief Transmit interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_TXSE_MASK                        = 0x00000002U;   /** @brief Transmit stopped enable */
    static const uint32_t ETHERNET_MAC_DMACIER_TBUE_MASK                        = 0x00000004U;   /** @brief Transmit buffer unavailable enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RIE_MASK                         = 0x00000040U;   /** @brief Receive interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RBUE_MASK                        = 0x00000080U;   /** @brief Receive buffer unavailable enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RSE_MASK                         = 0x00000100U;   /** @brief Receive stopped enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RWTE_MASK                        = 0x00000200U;   /** @brief Receive watchdog timeout enable */
    static const uint32_t ETHERNET_MAC_DMACIER_ETIE_MASK                        = 0x00000400U;   /** @brief Early transmit interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_ERIE_MASK                        = 0x00000800U;   /** @brief Early receive interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_FBEE_MASK                        = 0x00001000U;   /** @brief Fatal bus error enable */
    static const uint32_t ETHERNET_MAC_DMACIER_CDEE_MASK                        = 0x00002000U;   /** @brief Context descriptor error enable */
    static const uint32_t ETHERNET_MAC_DMACIER_AIE_MASK                         = 0x00004000U;   /** @brief Abnormal interrupt summary enable */
    static const uint32_t ETHERNET_MAC_DMACIER_NIE_MASK                         = 0x00008000U;   /** @brief Normal interrupt summary enable */
    static const uint32_t ETHERNET_MAC_DMACRXIWTR_RWT_MASK                      = 0x000000FFU;   /** @brief Receive interrupt watchdog timer count */
    static const uint32_t ETHERNET_MAC_DMACSR_TI_MASK                           = 0x00000001U;   /** @brief Transmit interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_TPS_MASK                          = 0x00000002U;   /** @brief Transmit process stopped */
    static const uint32_t ETHERNET_MAC_DMACSR_TBU_MASK                          = 0x00000004U;   /** @brief Transmit buffer unavailable */
    static const uint32_t ETHERNET_MAC_DMACSR_RI_MASK                           = 0x00000040U;   /** @brief Receive interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_RBU_MASK                          = 0x00000080U;   /** @brief Receive buffer unavailable */
    static const uint32_t ETHERNET_MAC_DMACSR_RPS_MASK                          = 0x00000100U;   /** @brief Receive process stopped */
    static const uint32_t ETHERNET_MAC_DMACSR_RWT_MASK                          = 0x00000200U;   /** @brief Receive watchdog timeout */
    static const uint32_t ETHERNET_MAC_DMACSR_ET_MASK                           = 0x00000400U;   /** @brief Early transmit interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_ER_MASK                           = 0x00000800U;   /** @brief Early receive interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_FBE_MASK                          = 0x00001000U;   /** @brief Fatal bus error */
    static const uint32_t ETHERNET_MAC_DMACSR_CDE_MASK                          = 0x00002000U;   /** @brief Context descriptor error */
    static const uint32_t ETHERNET_MAC_DMACSR_AIS_MASK                          = 0x00004000U;   /** @brief Abnormal interrupt summary */
    static const uint32_t ETHERNET_MAC_DMACSR_NIS_MASK                          = 0x00008000U;   /** @brief Normal interrupt summary */
    static const uint32_t ETHERNET_MAC_DMACSR_TEB_MASK                          = 0x00070000U;   /** @brief Tx DMA error bits */
    static const uint32_t ETHERNET_MAC_DMACSR_REB_MASK                          = 0x00380000U;   /** @brief Rx DMA error bits */
    static const uint32_t ETHERNET_MAC_DMACMFCR_MFC_MASK                        = 0x000007FFU;   /** @brief Dropped packet counters */
    static const uint32_t ETHERNET_MAC_DMACMFCR_MFCO_MASK                       = 0x00008000U;   /** @brief Overflow status of the MFC counter */
    static const uint32_t ETHERNET_MAC_MTLOMR_DTXSTS_MASK                       = 0x00000002U;   /** @brief DTXSTS */
    static const uint32_t ETHERNET_MAC_MTLOMR_CNTPRST_MASK                      = 0x00000100U;   /** @brief CNTPRST */
    static const uint32_t ETHERNET_MAC_MTLOMR_CNTCLR_MASK                       = 0x00000200U;   /** @brief CNTCLR */
    static const uint32_t ETHERNET_MAC_MTLISR_Q0IS_MASK                         = 0x00000001U;   /** @brief Queue interrupt status */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_FTQ_MASK                       = 0x00000001U;   /** @brief Flush transmit queue */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TSF_MASK                       = 0x00000002U;   /** @brief Transmit store and forward */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TXQEN_MASK                     = 0x0000000CU;   /** @brief Transmit queue enable */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TTC_MASK                       = 0x00000070U;   /** @brief Transmit threshold control */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TQS_MASK                       = 0x01FF0000U;   /** @brief Transmit queue size */
    static const uint32_t ETHERNET_MAC_MTLTXQUR_UFFRMCNT_MASK                   = 0x000007FFU;   /** @brief Underflow packet counter */
    static const uint32_t ETHERNET_MAC_MTLTXQUR_UFCNTOVF_MASK                   = 0x00000800U;   /** @brief UFCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TXQPAUSED_MASK                  = 0x00000001U;   /** @brief TXQPAUSED */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TRCSTS_MASK                     = 0x00000006U;   /** @brief TRCSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TWCSTS_MASK                     = 0x00000008U;   /** @brief TWCSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TXQSTS_MASK                     = 0x00000010U;   /** @brief TXQSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TXSTSFSTS_MASK                  = 0x00000020U;   /** @brief TXSTSFSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_PTXQ_MASK                       = 0x00070000U;   /** @brief PTXQ */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_STXSTSF_MASK                    = 0x00700000U;   /** @brief STXSTSF */
    static const uint32_t ETHERNET_MAC_MTLQICSR_TXUNFIS_MASK                    = 0x00000001U;   /** @brief TXUNFIS */
    static const uint32_t ETHERNET_MAC_MTLQICSR_TXUIE_MASK                      = 0x00000100U;   /** @brief TXUIE */
    static const uint32_t ETHERNET_MAC_MTLQICSR_RXOVFIS_MASK                    = 0x00010000U;   /** @brief RXOVFIS */
    static const uint32_t ETHERNET_MAC_MTLQICSR_RXOIE_MASK                      = 0x01000000U;   /** @brief RXOIE */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RTC_MASK                       = 0x00000003U;   /** @brief RTC */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_FUP_MASK                       = 0x00000008U;   /** @brief FUP */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_FEP_MASK                       = 0x00000010U;   /** @brief FEP */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RSF_MASK                       = 0x00000020U;   /** @brief RSF */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_DIS_TCP_EF_MASK                = 0x00000040U;   /** @brief DIS_TCP_EF */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_EHFC_MASK                      = 0x00000080U;   /** @brief EHFC */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RFA_MASK                       = 0x00000700U;   /** @brief RFA */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RFD_MASK                       = 0x0001C000U;   /** @brief RFD */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RQS_MASK                       = 0x00700000U;   /** @brief RQS */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT_MASK               = 0x000007FFU;   /** @brief OVFPKTCNT */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_OVFCNTOVF_MASK               = 0x00000800U;   /** @brief OVFCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT_MASK               = 0x07FF0000U;   /** @brief MISPKTCNT */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF_MASK               = 0x08000000U;   /** @brief MISCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RWCSTS_MASK                     = 0x00000001U;   /** @brief RWCSTS */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RRCSTS_MASK                     = 0x00000006U;   /** @brief RRCSTS */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RXQSTS_MASK                     = 0x00000030U;   /** @brief RXQSTS */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_PRXQ_MASK                       = 0x3FFF0000U;   /** @brief PRXQ */
    static const uint32_t ETHERNET_MAC_MACCR_RE_MASK                            = 0x00000001U;   /** @brief Receiver enable */
    static const uint32_t ETHERNET_MAC_MACCR_TE_MASK                            = 0x00000002U;   /** @brief TE */
    static const uint32_t ETHERNET_MAC_MACCR_PRELEN_MASK                        = 0x0000000CU;   /** @brief PRELEN */
    static const uint32_t ETHERNET_MAC_MACCR_DC_MASK                            = 0x00000010U;   /** @brief DC */
    static const uint32_t ETHERNET_MAC_MACCR_BL_MASK                            = 0x00000060U;   /** @brief BL */
    static const uint32_t ETHERNET_MAC_MACCR_DR_MASK                            = 0x00000100U;   /** @brief DR */
    static const uint32_t ETHERNET_MAC_MACCR_DCRS_MASK                          = 0x00000200U;   /** @brief DCRS */
    static const uint32_t ETHERNET_MAC_MACCR_DO_MASK                            = 0x00000400U;   /** @brief DO */
    static const uint32_t ETHERNET_MAC_MACCR_ECRSFD_MASK                        = 0x00000800U;   /** @brief ECRSFD */
    static const uint32_t ETHERNET_MAC_MACCR_LM_MASK                            = 0x00001000U;   /** @brief LM */
    static const uint32_t ETHERNET_MAC_MACCR_DM_MASK                            = 0x00002000U;   /** @brief DM */
    static const uint32_t ETHERNET_MAC_MACCR_FES_MASK                           = 0x00004000U;   /** @brief FES */
    static const uint32_t ETHERNET_MAC_MACCR_JE_MASK                            = 0x00010000U;   /** @brief JE */
    static const uint32_t ETHERNET_MAC_MACCR_JD_MASK                            = 0x00020000U;   /** @brief JD */
    static const uint32_t ETHERNET_MAC_MACCR_WD_MASK                            = 0x00080000U;   /** @brief WD */
    static const uint32_t ETHERNET_MAC_MACCR_ACS_MASK                           = 0x00100000U;   /** @brief ACS */
    static const uint32_t ETHERNET_MAC_MACCR_CST_MASK                           = 0x00200000U;   /** @brief CST */
    static const uint32_t ETHERNET_MAC_MACCR_S2KP_MASK                          = 0x00400000U;   /** @brief S2KP */
    static const uint32_t ETHERNET_MAC_MACCR_GPSLCE_MASK                        = 0x00800000U;   /** @brief GPSLCE */
    static const uint32_t ETHERNET_MAC_MACCR_IPG_MASK                           = 0x07000000U;   /** @brief IPG */
    static const uint32_t ETHERNET_MAC_MACCR_IPC_MASK                           = 0x08000000U;   /** @brief IPC */
    static const uint32_t ETHERNET_MAC_MACCR_SARC_MASK                          = 0x70000000U;   /** @brief SARC */
    static const uint32_t ETHERNET_MAC_MACCR_ARPEN_MASK                         = 0x80000000U;   /** @brief ARPEN */
    static const uint32_t ETHERNET_MAC_MACECR_GPSL_MASK                         = 0x00003FFFU;   /** @brief GPSL */
    static const uint32_t ETHERNET_MAC_MACECR_DCRCC_MASK                        = 0x00010000U;   /** @brief DCRCC */
    static const uint32_t ETHERNET_MAC_MACECR_SPEN_MASK                         = 0x00020000U;   /** @brief SPEN */
    static const uint32_t ETHERNET_MAC_MACECR_USP_MASK                          = 0x00040000U;   /** @brief USP */
    static const uint32_t ETHERNET_MAC_MACECR_EIPGEN_MASK                       = 0x01000000U;   /** @brief EIPGEN */
    static const uint32_t ETHERNET_MAC_MACECR_EIPG_MASK                         = 0x3E000000U;   /** @brief EIPG */
    static const uint32_t ETHERNET_MAC_MACPFR_PR_MASK                           = 0x00000001U;   /** @brief PR */
    static const uint32_t ETHERNET_MAC_MACPFR_HUC_MASK                          = 0x00000002U;   /** @brief HUC */
    static const uint32_t ETHERNET_MAC_MACPFR_HMC_MASK                          = 0x00000004U;   /** @brief HMC */
    static const uint32_t ETHERNET_MAC_MACPFR_DAIF_MASK                         = 0x00000008U;   /** @brief DAIF */
    static const uint32_t ETHERNET_MAC_MACPFR_PM_MASK                           = 0x00000010U;   /** @brief PM */
    static const uint32_t ETHERNET_MAC_MACPFR_DBF_MASK                          = 0x00000020U;   /** @brief DBF */
    static const uint32_t ETHERNET_MAC_MACPFR_PCF_MASK                          = 0x000000C0U;   /** @brief PCF */
    static const uint32_t ETHERNET_MAC_MACPFR_SAIF_MASK                         = 0x00000100U;   /** @brief SAIF */
    static const uint32_t ETHERNET_MAC_MACPFR_SAF_MASK                          = 0x00000200U;   /** @brief SAF */
    static const uint32_t ETHERNET_MAC_MACPFR_HPF_MASK                          = 0x00000400U;   /** @brief HPF */
    static const uint32_t ETHERNET_MAC_MACPFR_VTFE_MASK                         = 0x00010000U;   /** @brief VTFE */
    static const uint32_t ETHERNET_MAC_MACPFR_IPFE_MASK                         = 0x00100000U;   /** @brief IPFE */
    static const uint32_t ETHERNET_MAC_MACPFR_DNTU_MASK                         = 0x00200000U;   /** @brief DNTU */
    static const uint32_t ETHERNET_MAC_MACPFR_RA_MASK                           = 0x80000000U;   /** @brief RA */
    static const uint32_t ETHERNET_MAC_MACWTR_WTO_MASK                          = 0x0000000FU;   /** @brief WTO */
    static const uint32_t ETHERNET_MAC_MACWTR_PWE_MASK                          = 0x00000100U;   /** @brief PWE */
    static const uint32_t ETHERNET_MAC_MACVTR_VL_MASK                           = 0x0000FFFFU;   /** @brief VL */
    static const uint32_t ETHERNET_MAC_MACVTR_ETV_MASK                          = 0x00010000U;   /** @brief ETV */
    static const uint32_t ETHERNET_MAC_MACVTR_VTIM_MASK                         = 0x00020000U;   /** @brief VTIM */
    static const uint32_t ETHERNET_MAC_MACVTR_ESVL_MASK                         = 0x00040000U;   /** @brief ESVL */
    static const uint32_t ETHERNET_MAC_MACVTR_ERSVLM_MASK                       = 0x00080000U;   /** @brief ERSVLM */
    static const uint32_t ETHERNET_MAC_MACVTR_DOVLTC_MASK                       = 0x00100000U;   /** @brief DOVLTC */
    static const uint32_t ETHERNET_MAC_MACVTR_EVLS_MASK                         = 0x00600000U;   /** @brief EVLS */
    static const uint32_t ETHERNET_MAC_MACVTR_EVLRXS_MASK                       = 0x01000000U;   /** @brief EVLRXS */
    static const uint32_t ETHERNET_MAC_MACVTR_VTHM_MASK                         = 0x02000000U;   /** @brief VTHM */
    static const uint32_t ETHERNET_MAC_MACVTR_EDVLP_MASK                        = 0x04000000U;   /** @brief EDVLP */
    static const uint32_t ETHERNET_MAC_MACVTR_ERIVLT_MASK                       = 0x08000000U;   /** @brief ERIVLT */
    static const uint32_t ETHERNET_MAC_MACVTR_EIVLS_MASK                        = 0x30000000U;   /** @brief EIVLS */
    static const uint32_t ETHERNET_MAC_MACVTR_EIVLRXS_MASK                      = 0x80000000U;   /** @brief EIVLRXS */
    static const uint32_t ETHERNET_MAC_MACVHTR_VLHT_MASK                        = 0x0000FFFFU;   /** @brief VLHT */
    static const uint32_t ETHERNET_MAC_MACVIR_VLT_MASK                          = 0x0000FFFFU;   /** @brief VLT */
    static const uint32_t ETHERNET_MAC_MACVIR_VLC_MASK                          = 0x00030000U;   /** @brief VLC */
    static const uint32_t ETHERNET_MAC_MACVIR_VLP_MASK                          = 0x00040000U;   /** @brief VLP */
    static const uint32_t ETHERNET_MAC_MACVIR_CSVL_MASK                         = 0x00080000U;   /** @brief CSVL */
    static const uint32_t ETHERNET_MAC_MACVIR_VLTI_MASK                         = 0x00100000U;   /** @brief VLTI */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLT_MASK                         = 0x0000FFFFU;   /** @brief VLT */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLC_MASK                         = 0x00030000U;   /** @brief VLC */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLP_MASK                         = 0x00040000U;   /** @brief VLP */
    static const uint32_t ETHERNET_MAC_MACIVIR_CSVL_MASK                        = 0x00080000U;   /** @brief CSVL */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLTI_MASK                        = 0x00100000U;   /** @brief VLTI */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_FCB_BPA_MASK                   = 0x00000001U;   /** @brief FCB_BPA */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_TFE_MASK                       = 0x00000002U;   /** @brief TFE */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_PLT_MASK                       = 0x00000070U;   /** @brief PLT */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_DZPQ_MASK                      = 0x00000080U;   /** @brief DZPQ */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_PT_MASK                        = 0xFFFF0000U;   /** @brief PT */
    static const uint32_t ETHERNET_MAC_MACRXFCR_RFE_MASK                        = 0x00000001U;   /** @brief RFE */
    static const uint32_t ETHERNET_MAC_MACRXFCR_UP_MASK                         = 0x00000002U;   /** @brief UP */
    static const uint32_t ETHERNET_MAC_MACISR_PHYIS_MASK                        = 0x00000008U;   /** @brief PHYIS */
    static const uint32_t ETHERNET_MAC_MACISR_PMTIS_MASK                        = 0x00000010U;   /** @brief PMTIS */
    static const uint32_t ETHERNET_MAC_MACISR_LPIIS_MASK                        = 0x00000020U;   /** @brief LPIIS */
    static const uint32_t ETHERNET_MAC_MACISR_MMCIS_MASK                        = 0x00000100U;   /** @brief MMCIS */
    static const uint32_t ETHERNET_MAC_MACISR_MMCRXIS_MASK                      = 0x00000200U;   /** @brief MMCRXIS */
    static const uint32_t ETHERNET_MAC_MACISR_MMCTXIS_MASK                      = 0x00000400U;   /** @brief MMCTXIS */
    static const uint32_t ETHERNET_MAC_MACISR_TSIS_MASK                         = 0x00001000U;   /** @brief TSIS */
    static const uint32_t ETHERNET_MAC_MACISR_TXSTSIS_MASK                      = 0x00002000U;   /** @brief TXSTSIS */
    static const uint32_t ETHERNET_MAC_MACISR_RXSTSIS_MASK                      = 0x00004000U;   /** @brief RXSTSIS */
    static const uint32_t ETHERNET_MAC_MACIER_PHYIE_MASK                        = 0x00000008U;   /** @brief PHYIE */
    static const uint32_t ETHERNET_MAC_MACIER_PMTIE_MASK                        = 0x00000010U;   /** @brief PMTIE */
    static const uint32_t ETHERNET_MAC_MACIER_LPIIE_MASK                        = 0x00000020U;   /** @brief LPIIE */
    static const uint32_t ETHERNET_MAC_MACIER_TSIE_MASK                         = 0x00001000U;   /** @brief TSIE */
    static const uint32_t ETHERNET_MAC_MACIER_TXSTSIE_MASK                      = 0x00002000U;   /** @brief TXSTSIE */
    static const uint32_t ETHERNET_MAC_MACIER_RXSTSIE_MASK                      = 0x00004000U;   /** @brief RXSTSIE */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_TJT_MASK                       = 0x00000001U;   /** @brief TJT */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_NCARR_MASK                     = 0x00000002U;   /** @brief NCARR */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_LCARR_MASK                     = 0x00000004U;   /** @brief LCARR */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_EXDEF_MASK                     = 0x00000008U;   /** @brief EXDEF */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_LCOL_MASK                      = 0x00000010U;   /** @brief LCOL */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_EXCOL_MASK                     = 0x00000020U;   /** @brief LCOL */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_RWT_MASK                       = 0x00000100U;   /** @brief RWT */
    static const uint32_t ETHERNET_MAC_MACPCSR_PWRDWN_MASK                      = 0x00000001U;   /** @brief PWRDWN */
    static const uint32_t ETHERNET_MAC_MACPCSR_MGKPKTEN_MASK                    = 0x00000002U;   /** @brief MGKPKTEN */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPKTEN_MASK                    = 0x00000004U;   /** @brief RWKPKTEN */
    static const uint32_t ETHERNET_MAC_MACPCSR_MGKPRCVD_MASK                    = 0x00000020U;   /** @brief MGKPRCVD */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPRCVD_MASK                    = 0x00000040U;   /** @brief RWKPRCVD */
    static const uint32_t ETHERNET_MAC_MACPCSR_GLBLUCAST_MASK                   = 0x00000200U;   /** @brief GLBLUCAST */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPFE_MASK                      = 0x00000400U;   /** @brief RWKPFE */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPTR_MASK                      = 0x1F000000U;   /** @brief RWKPTR */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKFILTRST_MASK                  = 0x80000000U;   /** @brief RWKFILTRST */
    static const uint32_t ETHERNET_MAC_MACLCSR_TLPIEN_MASK                      = 0x00000001U;   /** @brief TLPIEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_TLPIEX_MASK                      = 0x00000002U;   /** @brief TLPIEX */
    static const uint32_t ETHERNET_MAC_MACLCSR_RLPIEN_MASK                      = 0x00000004U;   /** @brief RLPIEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_RLPIEX_MASK                      = 0x00000008U;   /** @brief RLPIEX */
    static const uint32_t ETHERNET_MAC_MACLCSR_TLPIST_MASK                      = 0x00000100U;   /** @brief TLPIST */
    static const uint32_t ETHERNET_MAC_MACLCSR_RLPIST_MASK                      = 0x00000200U;   /** @brief RLPIST */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPIEN_MASK                       = 0x00010000U;   /** @brief LPIEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_PLS_MASK                         = 0x00020000U;   /** @brief PLS */
    static const uint32_t ETHERNET_MAC_MACLCSR_PLSEN_MASK                       = 0x00040000U;   /** @brief PLSEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPITXA_MASK                      = 0x00080000U;   /** @brief LPITXA */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPITE_MASK                       = 0x00100000U;   /** @brief LPITE */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPITCSE_MASK                     = 0x00200000U;   /** @brief LPITCSE */
    static const uint32_t ETHERNET_MAC_MACLTCR_TWT_MASK                         = 0x0000FFFFU;   /** @brief TWT */
    static const uint32_t ETHERNET_MAC_MACLTCR_LST_MASK                         = 0x03FF0000U;   /** @brief LST */
    static const uint32_t ETHERNET_MAC_MACLETR_LPIET_MASK                       = 0x0001FFFFU;   /** @brief LPIET */
    static const uint32_t ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR_MASK              = 0x00000FFFU;   /** @brief TIC_1US_CNTR */
    static const uint32_t ETHERNET_MAC_MACVR_SNPSVER_MASK                       = 0x000000FFU;   /** @brief SNPSVER */
    static const uint32_t ETHERNET_MAC_MACVR_USERVER_MASK                       = 0x0000FF00U;   /** @brief USERVER */
    static const uint32_t ETHERNET_MAC_MACHWF1R_RXFIFOSIZE_MASK                 = 0x0000001FU;   /** @brief RXFIFOSIZE */
    static const uint32_t ETHERNET_MAC_MACHWF1R_TXFIFOSIZE_MASK                 = 0x000007C0U;   /** @brief TXFIFOSIZE */
    static const uint32_t ETHERNET_MAC_MACHWF1R_OSTEN_MASK                      = 0x00000800U;   /** @brief OSTEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_PTOEN_MASK                      = 0x00001000U;   /** @brief PTOEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_ADVTHWORD_MASK                  = 0x00002000U;   /** @brief ADVTHWORD */
    static const uint32_t ETHERNET_MAC_MACHWF1R_DCBEN_MASK                      = 0x00010000U;   /** @brief DCBEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_SPHEN_MASK                      = 0x00020000U;   /** @brief SPHEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_TSOEN_MASK                      = 0x00040000U;   /** @brief TSOEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_DBGMEMA_MASK                    = 0x00080000U;   /** @brief DBGMEMA */
    static const uint32_t ETHERNET_MAC_MACHWF1R_AVSEL_MASK                      = 0x00100000U;   /** @brief AVSEL */
    static const uint32_t ETHERNET_MAC_MACHWF1R_HASHTBLSZ_MASK                  = 0x03000000U;   /** @brief HASHTBLSZ */
    static const uint32_t ETHERNET_MAC_MACHWF1R_L3L4FNUM_MASK                   = 0x78000000U;   /** @brief L3L4FNUM */
    static const uint32_t ETHERNET_MAC_MACHWF2R_RXQCNT_MASK                     = 0x0000000FU;   /** @brief RXQCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_TXQCNT_MASK                     = 0x000003C0U;   /** @brief TXQCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_RXCHCNT_MASK                    = 0x0000F000U;   /** @brief RXCHCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_TXCHCNT_MASK                    = 0x003C0000U;   /** @brief TXCHCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_PPSOUTNUM_MASK                  = 0x07000000U;   /** @brief PPSOUTNUM */
    static const uint32_t ETHERNET_MAC_MACHWF2R_AUXSNAPNUM_MASK                 = 0x70000000U;   /** @brief AUXSNAPNUM */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_MB_MASK                        = 0x00000001U;   /** @brief MB */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_C45E_MASK                      = 0x00000002U;   /** @brief C45E */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_GOC_MASK                       = 0x0000000CU;   /** @brief GOC */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_SKAP_MASK                      = 0x00000010U;   /** @brief SKAP */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_CR_MASK                        = 0x00000F00U;   /** @brief CR */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_NTC_MASK                       = 0x00007000U;   /** @brief NTC */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_RDA_MASK                       = 0x001F0000U;   /** @brief RDA */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_PA_MASK                        = 0x03E00000U;   /** @brief PA */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_BTB_MASK                       = 0x04000000U;   /** @brief BTB */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_PSE_MASK                       = 0x08000000U;   /** @brief PSE */
    static const uint32_t ETHERNET_MAC_MACMDIODR_MD_MASK                        = 0x0000FFFFU;   /** @brief MD */
    static const uint32_t ETHERNET_MAC_MACMDIODR_RA_MASK                        = 0xFFFF0000U;   /** @brief RA */
    static const uint32_t ETHERNET_MAC_MACA0HR_ADDRHI_MASK                      = 0x0000FFFFU;   /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACA0HR_AE_MASK                          = 0x80000000U;   /** @brief AE */
    static const uint32_t ETHERNET_MAC_MACA1HR_ADDRHI_MASK                      = 0x0000FFFFU;   /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACA1HR_MBC_MASK                         = 0x3F000000U;   /** @brief MBC */
    static const uint32_t ETHERNET_MAC_MACA1HR_SA_MASK                          = 0x40000000U;   /** @brief SA */
    static const uint32_t ETHERNET_MAC_MACA1HR_AE_MASK                          = 0x80000000U;   /** @brief AE */
    static const uint32_t ETHERNET_MAC_MACA2HR_ADDRHI_MASK                      = 0x0000FFFFU;   /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACA2HR_MBC_MASK                         = 0x3F000000U;   /** @brief MBC */
    static const uint32_t ETHERNET_MAC_MACA2HR_SA_MASK                          = 0x40000000U;   /** @brief SA */
    static const uint32_t ETHERNET_MAC_MACA2HR_AE_MASK                          = 0x80000000U;   /** @brief AE */
    static const uint32_t ETHERNET_MAC_MACA3HR_ADDRHI_MASK                      = 0x0000FFFFU;   /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACA3HR_MBC_MASK                         = 0x3F000000U;   /** @brief MBC */
    static const uint32_t ETHERNET_MAC_MACA3HR_SA_MASK                          = 0x40000000U;   /** @brief SA */
    static const uint32_t ETHERNET_MAC_MACA3HR_AE_MASK                          = 0x80000000U;   /** @brief AE */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTRST_MASK                  = 0x00000001U;   /** @brief CNTRST */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTSTOPRO_MASK               = 0x00000002U;   /** @brief CNTSTOPRO */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_RSTONRD_MASK                 = 0x00000004U;   /** @brief RSTONRD */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTFREEZ_MASK                = 0x00000008U;   /** @brief CNTFREEZ */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTPRST_MASK                 = 0x00000010U;   /** @brief CNTPRST */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTPRSTLVL_MASK              = 0x00000020U;   /** @brief CNTPRSTLVL */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_UCDBC_MASK                   = 0x00000100U;   /** @brief UCDBC */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXCRCERPIS_MASK         = 0x00000020U;   /** @brief RXCRCERPIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXALGNERPIS_MASK        = 0x00000040U;   /** @brief RXALGNERPIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXUCGPIS_MASK           = 0x00020000U;   /** @brief RXUCGPIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS_MASK         = 0x04000000U;   /** @brief RXLPIUSCIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS_MASK         = 0x08000000U;   /** @brief RXLPITRCIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS_MASK         = 0x00004000U;   /** @brief TXSCOLGPIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS_MASK         = 0x00008000U;   /** @brief TXMCOLGPIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXGPKTIS_MASK           = 0x00200000U;   /** @brief TXGPKTIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS_MASK         = 0x04000000U;   /** @brief TXLPIUSCIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS_MASK         = 0x08000000U;   /** @brief TXLPITRCIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM_MASK    = 0x00000020U;   /** @brief RXCRCERPIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM_MASK   = 0x00000040U;   /** @brief RXALGNERPIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM_MASK      = 0x00020000U;   /** @brief RXUCGPIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM_MASK    = 0x04000000U;   /** @brief RXLPIUSCIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_MASK    = 0x08000000U;   /** @brief RXLPITRCIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM_MASK    = 0x00004000U;   /** @brief TXSCOLGPIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM_MASK    = 0x00008000U;   /** @brief TXMCOLGPIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM_MASK      = 0x00200000U;   /** @brief TXGPKTIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM_MASK    = 0x04000000U;   /** @brief TXLPIUSCIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_MASK    = 0x08000000U;   /** @brief TXLPITRCIM */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3SAM0_MASK                   = 0x00000004U;   /** @brief L3SAM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3SAIM0_MASK                  = 0x00000008U;   /** @brief L3SAIM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3DAM0_MASK                   = 0x00000010U;   /** @brief L3DAM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3DAIM0_MASK                  = 0x00000020U;   /** @brief L3DAIM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3HSBM0_MASK                  = 0x000007C0U;   /** @brief L3HSBM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3HDBM0_MASK                  = 0x0000F800U;   /** @brief L3HDBM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4SPM0_MASK                   = 0x00040000U;   /** @brief L4SPM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4SPIM0_MASK                  = 0x00080000U;   /** @brief L4SPIM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4DPM0_MASK                   = 0x00100000U;   /** @brief L4DPM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4DPIM0_MASK                  = 0x00200000U;   /** @brief L4DPIM0 */
    static const uint32_t ETHERNET_MAC_MACL4AxR_L4SP0_MASK                      = 0x0000FFFFU;   /** @brief L4SP0 */
    static const uint32_t ETHERNET_MAC_MACL4AxR_L4DP0_MASK                      = 0xFFFF0000U;   /** @brief L4DP0 */
    static const uint32_t ETHERNET_MAC_MACDR_RPESTS_MASK                        = 0x00000001U;   /** @brief RPESTS */
    static const uint32_t ETHERNET_MAC_MACDR_RFCFCSTS_MASK                      = 0x00000006U;   /** @brief RFCFCSTS */
    static const uint32_t ETHERNET_MAC_MACDR_TPESTS_MASK                        = 0x00010000U;   /** @brief TPESTS */
    static const uint32_t ETHERNET_MAC_MACDR_TFCSTS_MASK                        = 0x00060000U;   /** @brief TFCSTS */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSENA_MASK                       = 0x00000001U;   /** @brief TSENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSCFUPDT_MASK                    = 0x00000002U;   /** @brief TSCFUPDT */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSINIT_MASK                      = 0x00000004U;   /** @brief TSINIT */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSUPDT_MASK                      = 0x00000008U;   /** @brief TSUPDT */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSADDREG_MASK                    = 0x00000020U;   /** @brief TSADDREG */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSENALL_MASK                     = 0x00000100U;   /** @brief TSENALL */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSCTRLSSR_MASK                   = 0x00000200U;   /** @brief TSCTRLSSR */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSVER2ENA_MASK                   = 0x00000400U;   /** @brief TSVER2ENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSIPENA_MASK                     = 0x00000800U;   /** @brief TSIPENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSEVNTENA_MASK                   = 0x00004000U;   /** @brief TSEVNTENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSMSTRENA_MASK                   = 0x00008000U;   /** @brief TSMSTRENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_SNAPTYPSEL_MASK                  = 0x00030000U;   /** @brief SNAPTYPSEL */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSENMACADDR_MASK                 = 0x00040000U;   /** @brief TSENMACADDR */
    static const uint32_t ETHERNET_MAC_MACTSCR_CSC_MASK                         = 0x00080000U;   /** @brief CSC */
    static const uint32_t ETHERNET_MAC_MACTSCR_TXTSSTSM_MASK                    = 0x01000000U;   /** @brief TXTSSTSM */
    static const uint32_t ETHERNET_MAC_MACSSIR_SNSINC_MASK                      = 0x0000FF00U;   /** @brief SNSINC */
    static const uint32_t ETHERNET_MAC_MACSSIR_SSINC_MASK                       = 0x00FF0000U;   /** @brief SSINC */
    static const uint32_t ETHERNET_MAC_MACSTNR_TSSS_MASK                        = 0x7FFFFFFFU;   /** @brief TSSS */
    static const uint32_t ETHERNET_MAC_MACSTNUR_TSSS_MASK                       = 0x7FFFFFFFU;   /** @brief TSSS */
    static const uint32_t ETHERNET_MAC_MACSTNUR_ADDSUB_MASK                     = 0x80000000U;   /** @brief ADDSUB */
    static const uint32_t ETHERNET_MAC_MACTSSR_TSSOVF_MASK                      = 0x00000001U;   /** @brief TSSOVF */
    static const uint32_t ETHERNET_MAC_MACTSSR_TSTARGT0_MASK                    = 0x00000002U;   /** @brief TSTARGT0 */
    static const uint32_t ETHERNET_MAC_MACTSSR_AUXTSTRIG_MASK                   = 0x00000004U;   /** @brief AUXTSTRIG */
    static const uint32_t ETHERNET_MAC_MACTSSR_TSTRGTERR0_MASK                  = 0x00000008U;   /** @brief TSTRGTERR0 */
    static const uint32_t ETHERNET_MAC_MACTSSR_TXTSSIS_MASK                     = 0x00008000U;   /** @brief TXTSSIS */
    static const uint32_t ETHERNET_MAC_MACTSSR_ATSSTN_MASK                      = 0x000F0000U;   /** @brief ATSSTN */
    static const uint32_t ETHERNET_MAC_MACTSSR_ATSSTM_MASK                      = 0x01000000U;   /** @brief ATSSTM */
    static const uint32_t ETHERNET_MAC_MACTSSR_ATSNS_MASK                       = 0x3E000000U;   /** @brief ATSNS */
    static const uint32_t ETHERNET_MAC_MACTXTSSNR_TXTSSLO_MASK                  = 0x7FFFFFFFU;   /** @brief TXTSSLO */
    static const uint32_t ETHERNET_MAC_MACTXTSSNR_TXTSSMIS_MASK                 = 0x80000000U;   /** @brief TXTSSMIS */
    static const uint32_t ETHERNET_MAC_MACACR_ATSFC_MASK                        = 0x00000001U;   /** @brief ATSFC */
    static const uint32_t ETHERNET_MAC_MACATSNR_AUXTSLO_MASK                    = 0x7FFFFFFFU;   /** @brief AUXTSLO */
    static const uint32_t ETHERNET_MAC_MACPPSCR_PPSCTRL_MASK                    = 0x0000000FU;   /** @brief PPSCTRL */
    static const uint32_t ETHERNET_MAC_MACPPSCR_PPSEN0_MASK                     = 0x00000010U;   /** @brief PPSEN0 */
    static const uint32_t ETHERNET_MAC_MACPPSCR_TRGTMODSEL0_MASK                = 0x00000060U;   /** @brief TRGTMODSEL0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTSR_TSTRH0_MASK                   = 0x7FFFFFFFU;   /** @brief TSTRH0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTNR_TTSL0_MASK                    = 0x7FFFFFFFU;   /** @brief TTSL0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0_MASK                = 0x80000000U;   /** @brief TRGTBUSY0 */
    static const uint32_t ETHERNET_MAC_MACPOCR_PTOEN_MASK                       = 0x00000001U;   /** @brief PTOEN */
    static const uint32_t ETHERNET_MAC_MACPOCR_ASYNCEN_MASK                     = 0x00000002U;   /** @brief ASYNCEN */
    static const uint32_t ETHERNET_MAC_MACPOCR_APDREQEN_MASK                    = 0x00000004U;   /** @brief APDREQEN */
    static const uint32_t ETHERNET_MAC_MACPOCR_ASYNCTRIG_MASK                   = 0x00000010U;   /** @brief ASYNCTRIG */
    static const uint32_t ETHERNET_MAC_MACPOCR_APDREQTRIG_MASK                  = 0x00000020U;   /** @brief APDREQTRIG */
    static const uint32_t ETHERNET_MAC_MACPOCR_DRRDIS_MASK                      = 0x00000040U;   /** @brief DRRDIS */
    static const uint32_t ETHERNET_MAC_MACPOCR_DN_MASK                          = 0x0000FF00U;   /** @brief DN */
    static const uint32_t ETHERNET_MAC_MACSPI2R_SPI2_MASK                       = 0x0000FFFFU;   /** @brief SPI2 */
    static const uint32_t ETHERNET_MAC_MACLMIR_LSI_MASK                         = 0x000000FFU;   /** @brief LSI */
    static const uint32_t ETHERNET_MAC_MACLMIR_DRSYNCR_MASK                     = 0x00000700U;   /** @brief DRSYNCR */
    static const uint32_t ETHERNET_MAC_MACLMIR_LMPDRI_MASK                      = 0xFF000000U;   /** @brief LMPDRI */

    /**** @subsection Enumerated ETHERNET_MAC Register Field Masks ****/

    static const uint32_t ETHERNET_MAC_MACL3L4CxR_LxPEN0_MASK[5] = {
      [3] = 0x00000001U,   /** @brief L3PEN0 */
      [4] = 0x00010000U,   /** @brief L4PEN0 */
    };

    static const uint32_t ETHERNET_MAC_MACTSCR_TSIPVxENA_MASK[7] = {
      [4] = 0x00002000U,   /** @brief TSIPV4ENA */
      [6] = 0x00001000U,   /** @brief TSIPV6ENA */
    };

    static const uint32_t ETHERNET_MAC_MACACR_ATSENx_MASK[4] = {
      [0] = 0x00000010U,   /** @brief ATSEN0 */
      [1] = 0x00000020U,   /** @brief ATSEN1 */
      [2] = 0x00000040U,   /** @brief ATSEN2 */
      [3] = 0x00000080U,   /** @brief ATSEN3 */
    };

    /**** @subsection ETHERNET_MAC Register Field Positions ****/

    static const int32_t ETHERNET_MAC_DMAMR_SWR_POS                           = 0;    /** @brief Software reset */
    static const int32_t ETHERNET_MAC_DMAMR_DA_POS                            = 1;    /** @brief DMA tx or rx arbitration scheme */
    static const int32_t ETHERNET_MAC_DMAMR_TXPR_POS                          = 11;   /** @brief Transmit priority */
    static const int32_t ETHERNET_MAC_DMAMR_PR_POS                            = 12;   /** @brief Priority ratio */
    static const int32_t ETHERNET_MAC_DMAMR_INTM_POS                          = 16;   /** @brief Interrupt mode */
    static const int32_t ETHERNET_MAC_DMASBMR_FB_POS                          = 0;    /** @brief Fixed burst length */
    static const int32_t ETHERNET_MAC_DMASBMR_AAL_POS                         = 12;   /** @brief Address-Aligned beats */
    static const int32_t ETHERNET_MAC_DMASBMR_MB_POS                          = 14;   /** @brief Mixed burst */
    static const int32_t ETHERNET_MAC_DMASBMR_RB_POS                          = 15;   /** @brief Rebuild incrx burst */
    static const int32_t ETHERNET_MAC_DMAISR_DC0IS_POS                        = 0;    /** @brief DMA channel interrupt status */
    static const int32_t ETHERNET_MAC_DMAISR_MTLIS_POS                        = 16;   /** @brief MTL interrupt status */
    static const int32_t ETHERNET_MAC_DMAISR_MACIS_POS                        = 17;   /** @brief MAC interrupt status */
    static const int32_t ETHERNET_MAC_DMADSR_AXWHSTS_POS                      = 0;    /** @brief AHB master write channel */
    static const int32_t ETHERNET_MAC_DMADSR_RPS0_POS                         = 8;    /** @brief DMA channel receive process state */
    static const int32_t ETHERNET_MAC_DMADSR_TPS0_POS                         = 12;   /** @brief DMA channel transmit process state */
    static const int32_t ETHERNET_MAC_DMACCR_MSS_POS                          = 0;    /** @brief Maximum segment size */
    static const int32_t ETHERNET_MAC_DMACCR_PBLX8_POS                        = 16;   /** @brief 8xPBL mode */
    static const int32_t ETHERNET_MAC_DMACCR_DSL_POS                          = 18;   /** @brief Descriptor skip length */
    static const int32_t ETHERNET_MAC_DMACTXCR_ST_POS                         = 0;    /** @brief Start or stop transmission command */
    static const int32_t ETHERNET_MAC_DMACTXCR_OSF_POS                        = 4;    /** @brief Operate on second packet */
    static const int32_t ETHERNET_MAC_DMACTXCR_TSE_POS                        = 12;   /** @brief TCP segmentation enabled */
    static const int32_t ETHERNET_MAC_DMACTXCR_TXPBL_POS                      = 16;   /** @brief Transmit programmable burst length */
    static const int32_t ETHERNET_MAC_DMACRXCR_SR_POS                         = 0;    /** @brief Start or stop receive command */
    static const int32_t ETHERNET_MAC_DMACRXCR_RBSZ_POS                       = 1;    /** @brief Receive buffer size */
    static const int32_t ETHERNET_MAC_DMACRXCR_RXPBL_POS                      = 16;   /** @brief RXPBL */
    static const int32_t ETHERNET_MAC_DMACRXCR_RPF_POS                        = 31;   /** @brief DMA rx channel packet flush */
    static const int32_t ETHERNET_MAC_DMACTXDLAR_TDESLA_POS                   = 2;    /** @brief Start of transmit list */
    static const int32_t ETHERNET_MAC_DMACRXDLAR_RDESLA_POS                   = 2;    /** @brief Start of receive list */
    static const int32_t ETHERNET_MAC_DMACTXDTPR_TDT_POS                      = 2;    /** @brief Transmit descriptor tail pointer */
    static const int32_t ETHERNET_MAC_DMACRXDTPR_RDT_POS                      = 2;    /** @brief Receive descriptor tail pointer */
    static const int32_t ETHERNET_MAC_DMACTXRLR_TDRL_POS                      = 0;    /** @brief Transmit descriptor ring length */
    static const int32_t ETHERNET_MAC_DMACRXRLR_RDRL_POS                      = 0;    /** @brief Receive descriptor ring length */
    static const int32_t ETHERNET_MAC_DMACIER_TIE_POS                         = 0;    /** @brief Transmit interrupt enable */
    static const int32_t ETHERNET_MAC_DMACIER_TXSE_POS                        = 1;    /** @brief Transmit stopped enable */
    static const int32_t ETHERNET_MAC_DMACIER_TBUE_POS                        = 2;    /** @brief Transmit buffer unavailable enable */
    static const int32_t ETHERNET_MAC_DMACIER_RIE_POS                         = 6;    /** @brief Receive interrupt enable */
    static const int32_t ETHERNET_MAC_DMACIER_RBUE_POS                        = 7;    /** @brief Receive buffer unavailable enable */
    static const int32_t ETHERNET_MAC_DMACIER_RSE_POS                         = 8;    /** @brief Receive stopped enable */
    static const int32_t ETHERNET_MAC_DMACIER_RWTE_POS                        = 9;    /** @brief Receive watchdog timeout enable */
    static const int32_t ETHERNET_MAC_DMACIER_ETIE_POS                        = 10;   /** @brief Early transmit interrupt enable */
    static const int32_t ETHERNET_MAC_DMACIER_ERIE_POS                        = 11;   /** @brief Early receive interrupt enable */
    static const int32_t ETHERNET_MAC_DMACIER_FBEE_POS                        = 12;   /** @brief Fatal bus error enable */
    static const int32_t ETHERNET_MAC_DMACIER_CDEE_POS                        = 13;   /** @brief Context descriptor error enable */
    static const int32_t ETHERNET_MAC_DMACIER_AIE_POS                         = 14;   /** @brief Abnormal interrupt summary enable */
    static const int32_t ETHERNET_MAC_DMACIER_NIE_POS                         = 15;   /** @brief Normal interrupt summary enable */
    static const int32_t ETHERNET_MAC_DMACRXIWTR_RWT_POS                      = 0;    /** @brief Receive interrupt watchdog timer count */
    static const int32_t ETHERNET_MAC_DMACSR_TI_POS                           = 0;    /** @brief Transmit interrupt */
    static const int32_t ETHERNET_MAC_DMACSR_TPS_POS                          = 1;    /** @brief Transmit process stopped */
    static const int32_t ETHERNET_MAC_DMACSR_TBU_POS                          = 2;    /** @brief Transmit buffer unavailable */
    static const int32_t ETHERNET_MAC_DMACSR_RI_POS                           = 6;    /** @brief Receive interrupt */
    static const int32_t ETHERNET_MAC_DMACSR_RBU_POS                          = 7;    /** @brief Receive buffer unavailable */
    static const int32_t ETHERNET_MAC_DMACSR_RPS_POS                          = 8;    /** @brief Receive process stopped */
    static const int32_t ETHERNET_MAC_DMACSR_RWT_POS                          = 9;    /** @brief Receive watchdog timeout */
    static const int32_t ETHERNET_MAC_DMACSR_ET_POS                           = 10;   /** @brief Early transmit interrupt */
    static const int32_t ETHERNET_MAC_DMACSR_ER_POS                           = 11;   /** @brief Early receive interrupt */
    static const int32_t ETHERNET_MAC_DMACSR_FBE_POS                          = 12;   /** @brief Fatal bus error */
    static const int32_t ETHERNET_MAC_DMACSR_CDE_POS                          = 13;   /** @brief Context descriptor error */
    static const int32_t ETHERNET_MAC_DMACSR_AIS_POS                          = 14;   /** @brief Abnormal interrupt summary */
    static const int32_t ETHERNET_MAC_DMACSR_NIS_POS                          = 15;   /** @brief Normal interrupt summary */
    static const int32_t ETHERNET_MAC_DMACSR_TEB_POS                          = 16;   /** @brief Tx DMA error bits */
    static const int32_t ETHERNET_MAC_DMACSR_REB_POS                          = 19;   /** @brief Rx DMA error bits */
    static const int32_t ETHERNET_MAC_DMACMFCR_MFC_POS                        = 0;    /** @brief Dropped packet counters */
    static const int32_t ETHERNET_MAC_DMACMFCR_MFCO_POS                       = 15;   /** @brief Overflow status of the MFC counter */
    static const int32_t ETHERNET_MAC_MTLOMR_DTXSTS_POS                       = 1;    /** @brief DTXSTS */
    static const int32_t ETHERNET_MAC_MTLOMR_CNTPRST_POS                      = 8;    /** @brief CNTPRST */
    static const int32_t ETHERNET_MAC_MTLOMR_CNTCLR_POS                       = 9;    /** @brief CNTCLR */
    static const int32_t ETHERNET_MAC_MTLISR_Q0IS_POS                         = 0;    /** @brief Queue interrupt status */
    static const int32_t ETHERNET_MAC_MTLTXQOMR_FTQ_POS                       = 0;    /** @brief Flush transmit queue */
    static const int32_t ETHERNET_MAC_MTLTXQOMR_TSF_POS                       = 1;    /** @brief Transmit store and forward */
    static const int32_t ETHERNET_MAC_MTLTXQOMR_TXQEN_POS                     = 2;    /** @brief Transmit queue enable */
    static const int32_t ETHERNET_MAC_MTLTXQOMR_TTC_POS                       = 4;    /** @brief Transmit threshold control */
    static const int32_t ETHERNET_MAC_MTLTXQOMR_TQS_POS                       = 16;   /** @brief Transmit queue size */
    static const int32_t ETHERNET_MAC_MTLTXQUR_UFFRMCNT_POS                   = 0;    /** @brief Underflow packet counter */
    static const int32_t ETHERNET_MAC_MTLTXQUR_UFCNTOVF_POS                   = 11;   /** @brief UFCNTOVF */
    static const int32_t ETHERNET_MAC_MTLTXQDR_TXQPAUSED_POS                  = 0;    /** @brief TXQPAUSED */
    static const int32_t ETHERNET_MAC_MTLTXQDR_TRCSTS_POS                     = 1;    /** @brief TRCSTS */
    static const int32_t ETHERNET_MAC_MTLTXQDR_TWCSTS_POS                     = 3;    /** @brief TWCSTS */
    static const int32_t ETHERNET_MAC_MTLTXQDR_TXQSTS_POS                     = 4;    /** @brief TXQSTS */
    static const int32_t ETHERNET_MAC_MTLTXQDR_TXSTSFSTS_POS                  = 5;    /** @brief TXSTSFSTS */
    static const int32_t ETHERNET_MAC_MTLTXQDR_PTXQ_POS                       = 16;   /** @brief PTXQ */
    static const int32_t ETHERNET_MAC_MTLTXQDR_STXSTSF_POS                    = 20;   /** @brief STXSTSF */
    static const int32_t ETHERNET_MAC_MTLQICSR_TXUNFIS_POS                    = 0;    /** @brief TXUNFIS */
    static const int32_t ETHERNET_MAC_MTLQICSR_TXUIE_POS                      = 8;    /** @brief TXUIE */
    static const int32_t ETHERNET_MAC_MTLQICSR_RXOVFIS_POS                    = 16;   /** @brief RXOVFIS */
    static const int32_t ETHERNET_MAC_MTLQICSR_RXOIE_POS                      = 24;   /** @brief RXOIE */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_RTC_POS                       = 0;    /** @brief RTC */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_FUP_POS                       = 3;    /** @brief FUP */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_FEP_POS                       = 4;    /** @brief FEP */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_RSF_POS                       = 5;    /** @brief RSF */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_DIS_TCP_EF_POS                = 6;    /** @brief DIS_TCP_EF */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_EHFC_POS                      = 7;    /** @brief EHFC */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_RFA_POS                       = 8;    /** @brief RFA */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_RFD_POS                       = 14;   /** @brief RFD */
    static const int32_t ETHERNET_MAC_MTLRXQOMR_RQS_POS                       = 20;   /** @brief RQS */
    static const int32_t ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT_POS               = 0;    /** @brief OVFPKTCNT */
    static const int32_t ETHERNET_MAC_MTLRXQMPOCR_OVFCNTOVF_POS               = 11;   /** @brief OVFCNTOVF */
    static const int32_t ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT_POS               = 16;   /** @brief MISPKTCNT */
    static const int32_t ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF_POS               = 27;   /** @brief MISCNTOVF */
    static const int32_t ETHERNET_MAC_MTLRXQDR_RWCSTS_POS                     = 0;    /** @brief RWCSTS */
    static const int32_t ETHERNET_MAC_MTLRXQDR_RRCSTS_POS                     = 1;    /** @brief RRCSTS */
    static const int32_t ETHERNET_MAC_MTLRXQDR_RXQSTS_POS                     = 4;    /** @brief RXQSTS */
    static const int32_t ETHERNET_MAC_MTLRXQDR_PRXQ_POS                       = 16;   /** @brief PRXQ */
    static const int32_t ETHERNET_MAC_MACCR_RE_POS                            = 0;    /** @brief Receiver enable */
    static const int32_t ETHERNET_MAC_MACCR_TE_POS                            = 1;    /** @brief TE */
    static const int32_t ETHERNET_MAC_MACCR_PRELEN_POS                        = 2;    /** @brief PRELEN */
    static const int32_t ETHERNET_MAC_MACCR_DC_POS                            = 4;    /** @brief DC */
    static const int32_t ETHERNET_MAC_MACCR_BL_POS                            = 5;    /** @brief BL */
    static const int32_t ETHERNET_MAC_MACCR_DR_POS                            = 8;    /** @brief DR */
    static const int32_t ETHERNET_MAC_MACCR_DCRS_POS                          = 9;    /** @brief DCRS */
    static const int32_t ETHERNET_MAC_MACCR_DO_POS                            = 10;   /** @brief DO */
    static const int32_t ETHERNET_MAC_MACCR_ECRSFD_POS                        = 11;   /** @brief ECRSFD */
    static const int32_t ETHERNET_MAC_MACCR_LM_POS                            = 12;   /** @brief LM */
    static const int32_t ETHERNET_MAC_MACCR_DM_POS                            = 13;   /** @brief DM */
    static const int32_t ETHERNET_MAC_MACCR_FES_POS                           = 14;   /** @brief FES */
    static const int32_t ETHERNET_MAC_MACCR_JE_POS                            = 16;   /** @brief JE */
    static const int32_t ETHERNET_MAC_MACCR_JD_POS                            = 17;   /** @brief JD */
    static const int32_t ETHERNET_MAC_MACCR_WD_POS                            = 19;   /** @brief WD */
    static const int32_t ETHERNET_MAC_MACCR_ACS_POS                           = 20;   /** @brief ACS */
    static const int32_t ETHERNET_MAC_MACCR_CST_POS                           = 21;   /** @brief CST */
    static const int32_t ETHERNET_MAC_MACCR_S2KP_POS                          = 22;   /** @brief S2KP */
    static const int32_t ETHERNET_MAC_MACCR_GPSLCE_POS                        = 23;   /** @brief GPSLCE */
    static const int32_t ETHERNET_MAC_MACCR_IPG_POS                           = 24;   /** @brief IPG */
    static const int32_t ETHERNET_MAC_MACCR_IPC_POS                           = 27;   /** @brief IPC */
    static const int32_t ETHERNET_MAC_MACCR_SARC_POS                          = 28;   /** @brief SARC */
    static const int32_t ETHERNET_MAC_MACCR_ARPEN_POS                         = 31;   /** @brief ARPEN */
    static const int32_t ETHERNET_MAC_MACECR_GPSL_POS                         = 0;    /** @brief GPSL */
    static const int32_t ETHERNET_MAC_MACECR_DCRCC_POS                        = 16;   /** @brief DCRCC */
    static const int32_t ETHERNET_MAC_MACECR_SPEN_POS                         = 17;   /** @brief SPEN */
    static const int32_t ETHERNET_MAC_MACECR_USP_POS                          = 18;   /** @brief USP */
    static const int32_t ETHERNET_MAC_MACECR_EIPGEN_POS                       = 24;   /** @brief EIPGEN */
    static const int32_t ETHERNET_MAC_MACECR_EIPG_POS                         = 25;   /** @brief EIPG */
    static const int32_t ETHERNET_MAC_MACPFR_PR_POS                           = 0;    /** @brief PR */
    static const int32_t ETHERNET_MAC_MACPFR_HUC_POS                          = 1;    /** @brief HUC */
    static const int32_t ETHERNET_MAC_MACPFR_HMC_POS                          = 2;    /** @brief HMC */
    static const int32_t ETHERNET_MAC_MACPFR_DAIF_POS                         = 3;    /** @brief DAIF */
    static const int32_t ETHERNET_MAC_MACPFR_PM_POS                           = 4;    /** @brief PM */
    static const int32_t ETHERNET_MAC_MACPFR_DBF_POS                          = 5;    /** @brief DBF */
    static const int32_t ETHERNET_MAC_MACPFR_PCF_POS                          = 6;    /** @brief PCF */
    static const int32_t ETHERNET_MAC_MACPFR_SAIF_POS                         = 8;    /** @brief SAIF */
    static const int32_t ETHERNET_MAC_MACPFR_SAF_POS                          = 9;    /** @brief SAF */
    static const int32_t ETHERNET_MAC_MACPFR_HPF_POS                          = 10;   /** @brief HPF */
    static const int32_t ETHERNET_MAC_MACPFR_VTFE_POS                         = 16;   /** @brief VTFE */
    static const int32_t ETHERNET_MAC_MACPFR_IPFE_POS                         = 20;   /** @brief IPFE */
    static const int32_t ETHERNET_MAC_MACPFR_DNTU_POS                         = 21;   /** @brief DNTU */
    static const int32_t ETHERNET_MAC_MACPFR_RA_POS                           = 31;   /** @brief RA */
    static const int32_t ETHERNET_MAC_MACWTR_WTO_POS                          = 0;    /** @brief WTO */
    static const int32_t ETHERNET_MAC_MACWTR_PWE_POS                          = 8;    /** @brief PWE */
    static const int32_t ETHERNET_MAC_MACVTR_VL_POS                           = 0;    /** @brief VL */
    static const int32_t ETHERNET_MAC_MACVTR_ETV_POS                          = 16;   /** @brief ETV */
    static const int32_t ETHERNET_MAC_MACVTR_VTIM_POS                         = 17;   /** @brief VTIM */
    static const int32_t ETHERNET_MAC_MACVTR_ESVL_POS                         = 18;   /** @brief ESVL */
    static const int32_t ETHERNET_MAC_MACVTR_ERSVLM_POS                       = 19;   /** @brief ERSVLM */
    static const int32_t ETHERNET_MAC_MACVTR_DOVLTC_POS                       = 20;   /** @brief DOVLTC */
    static const int32_t ETHERNET_MAC_MACVTR_EVLS_POS                         = 21;   /** @brief EVLS */
    static const int32_t ETHERNET_MAC_MACVTR_EVLRXS_POS                       = 24;   /** @brief EVLRXS */
    static const int32_t ETHERNET_MAC_MACVTR_VTHM_POS                         = 25;   /** @brief VTHM */
    static const int32_t ETHERNET_MAC_MACVTR_EDVLP_POS                        = 26;   /** @brief EDVLP */
    static const int32_t ETHERNET_MAC_MACVTR_ERIVLT_POS                       = 27;   /** @brief ERIVLT */
    static const int32_t ETHERNET_MAC_MACVTR_EIVLS_POS                        = 28;   /** @brief EIVLS */
    static const int32_t ETHERNET_MAC_MACVTR_EIVLRXS_POS                      = 31;   /** @brief EIVLRXS */
    static const int32_t ETHERNET_MAC_MACVHTR_VLHT_POS                        = 0;    /** @brief VLHT */
    static const int32_t ETHERNET_MAC_MACVIR_VLT_POS                          = 0;    /** @brief VLT */
    static const int32_t ETHERNET_MAC_MACVIR_VLC_POS                          = 16;   /** @brief VLC */
    static const int32_t ETHERNET_MAC_MACVIR_VLP_POS                          = 18;   /** @brief VLP */
    static const int32_t ETHERNET_MAC_MACVIR_CSVL_POS                         = 19;   /** @brief CSVL */
    static const int32_t ETHERNET_MAC_MACVIR_VLTI_POS                         = 20;   /** @brief VLTI */
    static const int32_t ETHERNET_MAC_MACIVIR_VLT_POS                         = 0;    /** @brief VLT */
    static const int32_t ETHERNET_MAC_MACIVIR_VLC_POS                         = 16;   /** @brief VLC */
    static const int32_t ETHERNET_MAC_MACIVIR_VLP_POS                         = 18;   /** @brief VLP */
    static const int32_t ETHERNET_MAC_MACIVIR_CSVL_POS                        = 19;   /** @brief CSVL */
    static const int32_t ETHERNET_MAC_MACIVIR_VLTI_POS                        = 20;   /** @brief VLTI */
    static const int32_t ETHERNET_MAC_MACQTXFCR_FCB_BPA_POS                   = 0;    /** @brief FCB_BPA */
    static const int32_t ETHERNET_MAC_MACQTXFCR_TFE_POS                       = 1;    /** @brief TFE */
    static const int32_t ETHERNET_MAC_MACQTXFCR_PLT_POS                       = 4;    /** @brief PLT */
    static const int32_t ETHERNET_MAC_MACQTXFCR_DZPQ_POS                      = 7;    /** @brief DZPQ */
    static const int32_t ETHERNET_MAC_MACQTXFCR_PT_POS                        = 16;   /** @brief PT */
    static const int32_t ETHERNET_MAC_MACRXFCR_RFE_POS                        = 0;    /** @brief RFE */
    static const int32_t ETHERNET_MAC_MACRXFCR_UP_POS                         = 1;    /** @brief UP */
    static const int32_t ETHERNET_MAC_MACISR_PHYIS_POS                        = 3;    /** @brief PHYIS */
    static const int32_t ETHERNET_MAC_MACISR_PMTIS_POS                        = 4;    /** @brief PMTIS */
    static const int32_t ETHERNET_MAC_MACISR_LPIIS_POS                        = 5;    /** @brief LPIIS */
    static const int32_t ETHERNET_MAC_MACISR_MMCIS_POS                        = 8;    /** @brief MMCIS */
    static const int32_t ETHERNET_MAC_MACISR_MMCRXIS_POS                      = 9;    /** @brief MMCRXIS */
    static const int32_t ETHERNET_MAC_MACISR_MMCTXIS_POS                      = 10;   /** @brief MMCTXIS */
    static const int32_t ETHERNET_MAC_MACISR_TSIS_POS                         = 12;   /** @brief TSIS */
    static const int32_t ETHERNET_MAC_MACISR_TXSTSIS_POS                      = 13;   /** @brief TXSTSIS */
    static const int32_t ETHERNET_MAC_MACISR_RXSTSIS_POS                      = 14;   /** @brief RXSTSIS */
    static const int32_t ETHERNET_MAC_MACIER_PHYIE_POS                        = 3;    /** @brief PHYIE */
    static const int32_t ETHERNET_MAC_MACIER_PMTIE_POS                        = 4;    /** @brief PMTIE */
    static const int32_t ETHERNET_MAC_MACIER_LPIIE_POS                        = 5;    /** @brief LPIIE */
    static const int32_t ETHERNET_MAC_MACIER_TSIE_POS                         = 12;   /** @brief TSIE */
    static const int32_t ETHERNET_MAC_MACIER_TXSTSIE_POS                      = 13;   /** @brief TXSTSIE */
    static const int32_t ETHERNET_MAC_MACIER_RXSTSIE_POS                      = 14;   /** @brief RXSTSIE */
    static const int32_t ETHERNET_MAC_MACRXTXSR_TJT_POS                       = 0;    /** @brief TJT */
    static const int32_t ETHERNET_MAC_MACRXTXSR_NCARR_POS                     = 1;    /** @brief NCARR */
    static const int32_t ETHERNET_MAC_MACRXTXSR_LCARR_POS                     = 2;    /** @brief LCARR */
    static const int32_t ETHERNET_MAC_MACRXTXSR_EXDEF_POS                     = 3;    /** @brief EXDEF */
    static const int32_t ETHERNET_MAC_MACRXTXSR_LCOL_POS                      = 4;    /** @brief LCOL */
    static const int32_t ETHERNET_MAC_MACRXTXSR_EXCOL_POS                     = 5;    /** @brief LCOL */
    static const int32_t ETHERNET_MAC_MACRXTXSR_RWT_POS                       = 8;    /** @brief RWT */
    static const int32_t ETHERNET_MAC_MACPCSR_PWRDWN_POS                      = 0;    /** @brief PWRDWN */
    static const int32_t ETHERNET_MAC_MACPCSR_MGKPKTEN_POS                    = 1;    /** @brief MGKPKTEN */
    static const int32_t ETHERNET_MAC_MACPCSR_RWKPKTEN_POS                    = 2;    /** @brief RWKPKTEN */
    static const int32_t ETHERNET_MAC_MACPCSR_MGKPRCVD_POS                    = 5;    /** @brief MGKPRCVD */
    static const int32_t ETHERNET_MAC_MACPCSR_RWKPRCVD_POS                    = 6;    /** @brief RWKPRCVD */
    static const int32_t ETHERNET_MAC_MACPCSR_GLBLUCAST_POS                   = 9;    /** @brief GLBLUCAST */
    static const int32_t ETHERNET_MAC_MACPCSR_RWKPFE_POS                      = 10;   /** @brief RWKPFE */
    static const int32_t ETHERNET_MAC_MACPCSR_RWKPTR_POS                      = 24;   /** @brief RWKPTR */
    static const int32_t ETHERNET_MAC_MACPCSR_RWKFILTRST_POS                  = 31;   /** @brief RWKFILTRST */
    static const int32_t ETHERNET_MAC_MACLCSR_TLPIEN_POS                      = 0;    /** @brief TLPIEN */
    static const int32_t ETHERNET_MAC_MACLCSR_TLPIEX_POS                      = 1;    /** @brief TLPIEX */
    static const int32_t ETHERNET_MAC_MACLCSR_RLPIEN_POS                      = 2;    /** @brief RLPIEN */
    static const int32_t ETHERNET_MAC_MACLCSR_RLPIEX_POS                      = 3;    /** @brief RLPIEX */
    static const int32_t ETHERNET_MAC_MACLCSR_TLPIST_POS                      = 8;    /** @brief TLPIST */
    static const int32_t ETHERNET_MAC_MACLCSR_RLPIST_POS                      = 9;    /** @brief RLPIST */
    static const int32_t ETHERNET_MAC_MACLCSR_LPIEN_POS                       = 16;   /** @brief LPIEN */
    static const int32_t ETHERNET_MAC_MACLCSR_PLS_POS                         = 17;   /** @brief PLS */
    static const int32_t ETHERNET_MAC_MACLCSR_PLSEN_POS                       = 18;   /** @brief PLSEN */
    static const int32_t ETHERNET_MAC_MACLCSR_LPITXA_POS                      = 19;   /** @brief LPITXA */
    static const int32_t ETHERNET_MAC_MACLCSR_LPITE_POS                       = 20;   /** @brief LPITE */
    static const int32_t ETHERNET_MAC_MACLCSR_LPITCSE_POS                     = 21;   /** @brief LPITCSE */
    static const int32_t ETHERNET_MAC_MACLTCR_TWT_POS                         = 0;    /** @brief TWT */
    static const int32_t ETHERNET_MAC_MACLTCR_LST_POS                         = 16;   /** @brief LST */
    static const int32_t ETHERNET_MAC_MACLETR_LPIET_POS                       = 0;    /** @brief LPIET */
    static const int32_t ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR_POS              = 0;    /** @brief TIC_1US_CNTR */
    static const int32_t ETHERNET_MAC_MACVR_SNPSVER_POS                       = 0;    /** @brief SNPSVER */
    static const int32_t ETHERNET_MAC_MACVR_USERVER_POS                       = 8;    /** @brief USERVER */
    static const int32_t ETHERNET_MAC_MACHWF1R_RXFIFOSIZE_POS                 = 0;    /** @brief RXFIFOSIZE */
    static const int32_t ETHERNET_MAC_MACHWF1R_TXFIFOSIZE_POS                 = 6;    /** @brief TXFIFOSIZE */
    static const int32_t ETHERNET_MAC_MACHWF1R_OSTEN_POS                      = 11;   /** @brief OSTEN */
    static const int32_t ETHERNET_MAC_MACHWF1R_PTOEN_POS                      = 12;   /** @brief PTOEN */
    static const int32_t ETHERNET_MAC_MACHWF1R_ADVTHWORD_POS                  = 13;   /** @brief ADVTHWORD */
    static const int32_t ETHERNET_MAC_MACHWF1R_DCBEN_POS                      = 16;   /** @brief DCBEN */
    static const int32_t ETHERNET_MAC_MACHWF1R_SPHEN_POS                      = 17;   /** @brief SPHEN */
    static const int32_t ETHERNET_MAC_MACHWF1R_TSOEN_POS                      = 18;   /** @brief TSOEN */
    static const int32_t ETHERNET_MAC_MACHWF1R_DBGMEMA_POS                    = 19;   /** @brief DBGMEMA */
    static const int32_t ETHERNET_MAC_MACHWF1R_AVSEL_POS                      = 20;   /** @brief AVSEL */
    static const int32_t ETHERNET_MAC_MACHWF1R_HASHTBLSZ_POS                  = 24;   /** @brief HASHTBLSZ */
    static const int32_t ETHERNET_MAC_MACHWF1R_L3L4FNUM_POS                   = 27;   /** @brief L3L4FNUM */
    static const int32_t ETHERNET_MAC_MACHWF2R_RXQCNT_POS                     = 0;    /** @brief RXQCNT */
    static const int32_t ETHERNET_MAC_MACHWF2R_TXQCNT_POS                     = 6;    /** @brief TXQCNT */
    static const int32_t ETHERNET_MAC_MACHWF2R_RXCHCNT_POS                    = 12;   /** @brief RXCHCNT */
    static const int32_t ETHERNET_MAC_MACHWF2R_TXCHCNT_POS                    = 18;   /** @brief TXCHCNT */
    static const int32_t ETHERNET_MAC_MACHWF2R_PPSOUTNUM_POS                  = 24;   /** @brief PPSOUTNUM */
    static const int32_t ETHERNET_MAC_MACHWF2R_AUXSNAPNUM_POS                 = 28;   /** @brief AUXSNAPNUM */
    static const int32_t ETHERNET_MAC_MACMDIOAR_MB_POS                        = 0;    /** @brief MB */
    static const int32_t ETHERNET_MAC_MACMDIOAR_C45E_POS                      = 1;    /** @brief C45E */
    static const int32_t ETHERNET_MAC_MACMDIOAR_GOC_POS                       = 2;    /** @brief GOC */
    static const int32_t ETHERNET_MAC_MACMDIOAR_SKAP_POS                      = 4;    /** @brief SKAP */
    static const int32_t ETHERNET_MAC_MACMDIOAR_CR_POS                        = 8;    /** @brief CR */
    static const int32_t ETHERNET_MAC_MACMDIOAR_NTC_POS                       = 12;   /** @brief NTC */
    static const int32_t ETHERNET_MAC_MACMDIOAR_RDA_POS                       = 16;   /** @brief RDA */
    static const int32_t ETHERNET_MAC_MACMDIOAR_PA_POS                        = 21;   /** @brief PA */
    static const int32_t ETHERNET_MAC_MACMDIOAR_BTB_POS                       = 26;   /** @brief BTB */
    static const int32_t ETHERNET_MAC_MACMDIOAR_PSE_POS                       = 27;   /** @brief PSE */
    static const int32_t ETHERNET_MAC_MACMDIODR_MD_POS                        = 0;    /** @brief MD */
    static const int32_t ETHERNET_MAC_MACMDIODR_RA_POS                        = 16;   /** @brief RA */
    static const int32_t ETHERNET_MAC_MACA0HR_ADDRHI_POS                      = 0;    /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACA0HR_AE_POS                          = 31;   /** @brief AE */
    static const int32_t ETHERNET_MAC_MACA1HR_ADDRHI_POS                      = 0;    /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACA1HR_MBC_POS                         = 24;   /** @brief MBC */
    static const int32_t ETHERNET_MAC_MACA1HR_SA_POS                          = 30;   /** @brief SA */
    static const int32_t ETHERNET_MAC_MACA1HR_AE_POS                          = 31;   /** @brief AE */
    static const int32_t ETHERNET_MAC_MACA2HR_ADDRHI_POS                      = 0;    /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACA2HR_MBC_POS                         = 24;   /** @brief MBC */
    static const int32_t ETHERNET_MAC_MACA2HR_SA_POS                          = 30;   /** @brief SA */
    static const int32_t ETHERNET_MAC_MACA2HR_AE_POS                          = 31;   /** @brief AE */
    static const int32_t ETHERNET_MAC_MACA3HR_ADDRHI_POS                      = 0;    /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACA3HR_MBC_POS                         = 24;   /** @brief MBC */
    static const int32_t ETHERNET_MAC_MACA3HR_SA_POS                          = 30;   /** @brief SA */
    static const int32_t ETHERNET_MAC_MACA3HR_AE_POS                          = 31;   /** @brief AE */
    static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTRST_POS                  = 0;    /** @brief CNTRST */
    static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTSTOPRO_POS               = 1;    /** @brief CNTSTOPRO */
    static const int32_t ETHERNET_MAC_MMC_CONTROL_RSTONRD_POS                 = 2;    /** @brief RSTONRD */
    static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTFREEZ_POS                = 3;    /** @brief CNTFREEZ */
    static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTPRST_POS                 = 4;    /** @brief CNTPRST */
    static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTPRSTLVL_POS              = 5;    /** @brief CNTPRSTLVL */
    static const int32_t ETHERNET_MAC_MMC_CONTROL_UCDBC_POS                   = 8;    /** @brief UCDBC */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXCRCERPIS_POS         = 5;    /** @brief RXCRCERPIS */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXALGNERPIS_POS        = 6;    /** @brief RXALGNERPIS */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXUCGPIS_POS           = 17;   /** @brief RXUCGPIS */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS_POS         = 26;   /** @brief RXLPIUSCIS */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS_POS         = 27;   /** @brief RXLPITRCIS */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS_POS         = 14;   /** @brief TXSCOLGPIS */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS_POS         = 15;   /** @brief TXMCOLGPIS */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXGPKTIS_POS           = 21;   /** @brief TXGPKTIS */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS_POS         = 26;   /** @brief TXLPIUSCIS */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS_POS         = 27;   /** @brief TXLPITRCIS */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM_POS    = 5;    /** @brief RXCRCERPIM */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM_POS   = 6;    /** @brief RXALGNERPIM */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM_POS      = 17;   /** @brief RXUCGPIM */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM_POS    = 26;   /** @brief RXLPIUSCIM */
    static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_POS    = 27;   /** @brief RXLPITRCIM */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM_POS    = 14;   /** @brief TXSCOLGPIM */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM_POS    = 15;   /** @brief TXMCOLGPIM */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM_POS      = 21;   /** @brief TXGPKTIM */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM_POS    = 26;   /** @brief TXLPIUSCIM */
    static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_POS    = 27;   /** @brief TXLPITRCIM */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L3SAM0_POS                   = 2;    /** @brief L3SAM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L3SAIM0_POS                  = 3;    /** @brief L3SAIM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L3DAM0_POS                   = 4;    /** @brief L3DAM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L3DAIM0_POS                  = 5;    /** @brief L3DAIM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L3HSBM0_POS                  = 6;    /** @brief L3HSBM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L3HDBM0_POS                  = 11;   /** @brief L3HDBM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L4SPM0_POS                   = 18;   /** @brief L4SPM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L4SPIM0_POS                  = 19;   /** @brief L4SPIM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L4DPM0_POS                   = 20;   /** @brief L4DPM0 */
    static const int32_t ETHERNET_MAC_MACL3L4CxR_L4DPIM0_POS                  = 21;   /** @brief L4DPIM0 */
    static const int32_t ETHERNET_MAC_MACL4AxR_L4SP0_POS                      = 0;    /** @brief L4SP0 */
    static const int32_t ETHERNET_MAC_MACL4AxR_L4DP0_POS                      = 16;   /** @brief L4DP0 */
    static const int32_t ETHERNET_MAC_MACDR_RPESTS_POS                        = 0;    /** @brief RPESTS */
    static const int32_t ETHERNET_MAC_MACDR_RFCFCSTS_POS                      = 1;    /** @brief RFCFCSTS */
    static const int32_t ETHERNET_MAC_MACDR_TPESTS_POS                        = 16;   /** @brief TPESTS */
    static const int32_t ETHERNET_MAC_MACDR_TFCSTS_POS                        = 17;   /** @brief TFCSTS */
    static const int32_t ETHERNET_MAC_MACTSCR_TSENA_POS                       = 0;    /** @brief TSENA */
    static const int32_t ETHERNET_MAC_MACTSCR_TSCFUPDT_POS                    = 1;    /** @brief TSCFUPDT */
    static const int32_t ETHERNET_MAC_MACTSCR_TSINIT_POS                      = 2;    /** @brief TSINIT */
    static const int32_t ETHERNET_MAC_MACTSCR_TSUPDT_POS                      = 3;    /** @brief TSUPDT */
    static const int32_t ETHERNET_MAC_MACTSCR_TSADDREG_POS                    = 5;    /** @brief TSADDREG */
    static const int32_t ETHERNET_MAC_MACTSCR_TSENALL_POS                     = 8;    /** @brief TSENALL */
    static const int32_t ETHERNET_MAC_MACTSCR_TSCTRLSSR_POS                   = 9;    /** @brief TSCTRLSSR */
    static const int32_t ETHERNET_MAC_MACTSCR_TSVER2ENA_POS                   = 10;   /** @brief TSVER2ENA */
    static const int32_t ETHERNET_MAC_MACTSCR_TSIPENA_POS                     = 11;   /** @brief TSIPENA */
    static const int32_t ETHERNET_MAC_MACTSCR_TSEVNTENA_POS                   = 14;   /** @brief TSEVNTENA */
    static const int32_t ETHERNET_MAC_MACTSCR_TSMSTRENA_POS                   = 15;   /** @brief TSMSTRENA */
    static const int32_t ETHERNET_MAC_MACTSCR_SNAPTYPSEL_POS                  = 16;   /** @brief SNAPTYPSEL */
    static const int32_t ETHERNET_MAC_MACTSCR_TSENMACADDR_POS                 = 18;   /** @brief TSENMACADDR */
    static const int32_t ETHERNET_MAC_MACTSCR_CSC_POS                         = 19;   /** @brief CSC */
    static const int32_t ETHERNET_MAC_MACTSCR_TXTSSTSM_POS                    = 24;   /** @brief TXTSSTSM */
    static const int32_t ETHERNET_MAC_MACSSIR_SNSINC_POS                      = 8;    /** @brief SNSINC */
    static const int32_t ETHERNET_MAC_MACSSIR_SSINC_POS                       = 16;   /** @brief SSINC */
    static const int32_t ETHERNET_MAC_MACSTNR_TSSS_POS                        = 0;    /** @brief TSSS */
    static const int32_t ETHERNET_MAC_MACSTNUR_TSSS_POS                       = 0;    /** @brief TSSS */
    static const int32_t ETHERNET_MAC_MACSTNUR_ADDSUB_POS                     = 31;   /** @brief ADDSUB */
    static const int32_t ETHERNET_MAC_MACTSSR_TSSOVF_POS                      = 0;    /** @brief TSSOVF */
    static const int32_t ETHERNET_MAC_MACTSSR_TSTARGT0_POS                    = 1;    /** @brief TSTARGT0 */
    static const int32_t ETHERNET_MAC_MACTSSR_AUXTSTRIG_POS                   = 2;    /** @brief AUXTSTRIG */
    static const int32_t ETHERNET_MAC_MACTSSR_TSTRGTERR0_POS                  = 3;    /** @brief TSTRGTERR0 */
    static const int32_t ETHERNET_MAC_MACTSSR_TXTSSIS_POS                     = 15;   /** @brief TXTSSIS */
    static const int32_t ETHERNET_MAC_MACTSSR_ATSSTN_POS                      = 16;   /** @brief ATSSTN */
    static const int32_t ETHERNET_MAC_MACTSSR_ATSSTM_POS                      = 24;   /** @brief ATSSTM */
    static const int32_t ETHERNET_MAC_MACTSSR_ATSNS_POS                       = 25;   /** @brief ATSNS */
    static const int32_t ETHERNET_MAC_MACTXTSSNR_TXTSSLO_POS                  = 0;    /** @brief TXTSSLO */
    static const int32_t ETHERNET_MAC_MACTXTSSNR_TXTSSMIS_POS                 = 31;   /** @brief TXTSSMIS */
    static const int32_t ETHERNET_MAC_MACACR_ATSFC_POS                        = 0;    /** @brief ATSFC */
    static const int32_t ETHERNET_MAC_MACATSNR_AUXTSLO_POS                    = 0;    /** @brief AUXTSLO */
    static const int32_t ETHERNET_MAC_MACPPSCR_PPSCTRL_POS                    = 0;    /** @brief PPSCTRL */
    static const int32_t ETHERNET_MAC_MACPPSCR_PPSEN0_POS                     = 4;    /** @brief PPSEN0 */
    static const int32_t ETHERNET_MAC_MACPPSCR_TRGTMODSEL0_POS                = 5;    /** @brief TRGTMODSEL0 */
    static const int32_t ETHERNET_MAC_MACPPSTTSR_TSTRH0_POS                   = 0;    /** @brief TSTRH0 */
    static const int32_t ETHERNET_MAC_MACPPSTTNR_TTSL0_POS                    = 0;    /** @brief TTSL0 */
    static const int32_t ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0_POS                = 31;   /** @brief TRGTBUSY0 */
    static const int32_t ETHERNET_MAC_MACPOCR_PTOEN_POS                       = 0;    /** @brief PTOEN */
    static const int32_t ETHERNET_MAC_MACPOCR_ASYNCEN_POS                     = 1;    /** @brief ASYNCEN */
    static const int32_t ETHERNET_MAC_MACPOCR_APDREQEN_POS                    = 2;    /** @brief APDREQEN */
    static const int32_t ETHERNET_MAC_MACPOCR_ASYNCTRIG_POS                   = 4;    /** @brief ASYNCTRIG */
    static const int32_t ETHERNET_MAC_MACPOCR_APDREQTRIG_POS                  = 5;    /** @brief APDREQTRIG */
    static const int32_t ETHERNET_MAC_MACPOCR_DRRDIS_POS                      = 6;    /** @brief DRRDIS */
    static const int32_t ETHERNET_MAC_MACPOCR_DN_POS                          = 8;    /** @brief DN */
    static const int32_t ETHERNET_MAC_MACSPI2R_SPI2_POS                       = 0;    /** @brief SPI2 */
    static const int32_t ETHERNET_MAC_MACLMIR_LSI_POS                         = 0;    /** @brief LSI */
    static const int32_t ETHERNET_MAC_MACLMIR_DRSYNCR_POS                     = 8;    /** @brief DRSYNCR */
    static const int32_t ETHERNET_MAC_MACLMIR_LMPDRI_POS                      = 24;   /** @brief LMPDRI */

    /**** @subsection Enumerated ETHERNET_MAC Register Field Positions ****/

    static const int32_t ETHERNET_MAC_MACL3L4CxR_LxPEN0_POS[5] = {
      [3] = 0,    /** @brief L3PEN0 */
      [4] = 16,   /** @brief L4PEN0 */
    };

    static const int32_t ETHERNET_MAC_MACTSCR_TSIPVxENA_POS[7] = {
      [4] = 13,   /** @brief TSIPV4ENA */
      [6] = 12,   /** @brief TSIPV6ENA */
    };

    static const int32_t ETHERNET_MAC_MACACR_ATSENx_POS[4] = {
      [0] = 4,   /** @brief ATSEN0 */
      [1] = 5,   /** @brief ATSEN1 */
      [2] = 6,   /** @brief ATSEN2 */
      [3] = 7,   /** @brief ATSEN3 */
    };

    /**********************************************************************************************
     * @section DMAx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated DMAx Register Pointers ****/

    static RO_ uint32_t* const DMAx_LISR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x40020000U,   /** @brief Low interrupt status register */
      [2] = (RO_ uint32_t* const)0x40020400U,   /** @brief Low interrupt status register */
    };

    static RO_ uint32_t* const DMAx_HISR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x40020004U,   /** @brief High interrupt status register */
      [2] = (RO_ uint32_t* const)0x40020404U,   /** @brief High interrupt status register */
    };

    static RW_ uint32_t* const DMAx_LIFCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40020008U,   /** @brief Low interrupt flag clear register */
      [2] = (RW_ uint32_t* const)0x40020408U,   /** @brief Low interrupt flag clear register */
    };

    static RW_ uint32_t* const DMAx_HIFCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4002000CU,   /** @brief High interrupt flag clear register */
      [2] = (RW_ uint32_t* const)0x4002040CU,   /** @brief High interrupt flag clear register */
    };

    static RW_ uint32_t* const DMAx_S0CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40020010U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020410U,   /** @brief Stream x configuration register */
    };

    static RW_ uint32_t* const DMAx_SxNDTR_PTR[3][8] = {
      [0] = {
        [0] = (RW_ uint32_t* const)0x40020014U,   /** @brief Stream x number of data register */
        [1] = (RW_ uint32_t* const)0x4002002CU,   /** @brief Stream x number of data register */
        [2] = (RW_ uint32_t* const)0x40020044U,   /** @brief Stream x number of data register */
        [3] = (RW_ uint32_t* const)0x4002005CU,   /** @brief Stream x number of data register */
        [4] = (RW_ uint32_t* const)0x40020074U,   /** @brief Stream x number of data register */
        [5] = (RW_ uint32_t* const)0x4002008CU,   /** @brief Stream x number of data register */
        [6] = (RW_ uint32_t* const)0x400200A4U,   /** @brief Stream x number of data register */
        [7] = (RW_ uint32_t* const)0x400200BCU,   /** @brief Stream x number of data register */
      },
      [1] = {
        [0] = (RW_ uint32_t* const)0x40020414U,   /** @brief Stream x number of data register */
        [1] = (RW_ uint32_t* const)0x4002042CU,   /** @brief Stream x number of data register */
        [2] = (RW_ uint32_t* const)0x40020444U,   /** @brief Stream x number of data register */
        [3] = (RW_ uint32_t* const)0x4002045CU,   /** @brief Stream x number of data register */
        [4] = (RW_ uint32_t* const)0x40020474U,   /** @brief Stream x number of data register */
        [5] = (RW_ uint32_t* const)0x4002048CU,   /** @brief Stream x number of data register */
        [6] = (RW_ uint32_t* const)0x400204A4U,   /** @brief Stream x number of data register */
        [7] = (RW_ uint32_t* const)0x400204BCU,   /** @brief Stream x number of data register */
      },
    };

    static RW_ uint32_t* const DMAx_SxPAR_PTR[3][8] = {
      [0] = {
        [0] = (RW_ uint32_t* const)0x40020018U,   /** @brief Stream x peripheral address register */
        [1] = (RW_ uint32_t* const)0x40020030U,   /** @brief Stream x peripheral address register */
        [2] = (RW_ uint32_t* const)0x40020048U,   /** @brief Stream x peripheral address register */
        [3] = (RW_ uint32_t* const)0x40020060U,   /** @brief Stream x peripheral address register */
        [4] = (RW_ uint32_t* const)0x40020078U,   /** @brief Stream x peripheral address register */
        [5] = (RW_ uint32_t* const)0x40020090U,   /** @brief Stream x peripheral address register */
        [6] = (RW_ uint32_t* const)0x400200A8U,   /** @brief Stream x peripheral address register */
        [7] = (RW_ uint32_t* const)0x400200C0U,   /** @brief Stream x peripheral address register */
      },
      [1] = {
        [0] = (RW_ uint32_t* const)0x40020418U,   /** @brief Stream x peripheral address register */
        [1] = (RW_ uint32_t* const)0x40020430U,   /** @brief Stream x peripheral address register */
        [2] = (RW_ uint32_t* const)0x40020448U,   /** @brief Stream x peripheral address register */
        [3] = (RW_ uint32_t* const)0x40020460U,   /** @brief Stream x peripheral address register */
        [4] = (RW_ uint32_t* const)0x40020478U,   /** @brief Stream x peripheral address register */
        [5] = (RW_ uint32_t* const)0x40020490U,   /** @brief Stream x peripheral address register */
        [6] = (RW_ uint32_t* const)0x400204A8U,   /** @brief Stream x peripheral address register */
        [7] = (RW_ uint32_t* const)0x400204C0U,   /** @brief Stream x peripheral address register */
      },
    };

    static RW_ uint32_t* const DMAx_SxM0AR_PTR[3][8] = {
      [0] = {
        [0] = (RW_ uint32_t* const)0x4002001CU,   /** @brief Stream x memory 0 address register */
        [1] = (RW_ uint32_t* const)0x40020034U,   /** @brief Stream x memory 0 address register */
        [2] = (RW_ uint32_t* const)0x4002004CU,   /** @brief Stream x memory 0 address register */
        [3] = (RW_ uint32_t* const)0x40020064U,   /** @brief Stream x memory 0 address register */
        [4] = (RW_ uint32_t* const)0x4002007CU,   /** @brief Stream x memory 0 address register */
        [5] = (RW_ uint32_t* const)0x40020094U,   /** @brief Stream x memory 0 address register */
        [6] = (RW_ uint32_t* const)0x400200ACU,   /** @brief Stream x memory 0 address register */
        [7] = (RW_ uint32_t* const)0x400200C4U,   /** @brief Stream x memory 0 address register */
      },
      [1] = {
        [0] = (RW_ uint32_t* const)0x4002041CU,   /** @brief Stream x memory 0 address register */
        [1] = (RW_ uint32_t* const)0x40020434U,   /** @brief Stream x memory 0 address register */
        [2] = (RW_ uint32_t* const)0x4002044CU,   /** @brief Stream x memory 0 address register */
        [3] = (RW_ uint32_t* const)0x40020464U,   /** @brief Stream x memory 0 address register */
        [4] = (RW_ uint32_t* const)0x4002047CU,   /** @brief Stream x memory 0 address register */
        [5] = (RW_ uint32_t* const)0x40020494U,   /** @brief Stream x memory 0 address register */
        [6] = (RW_ uint32_t* const)0x400204ACU,   /** @brief Stream x memory 0 address register */
        [7] = (RW_ uint32_t* const)0x400204C4U,   /** @brief Stream x memory 0 address register */
      },
    };

    static RW_ uint32_t* const DMAx_SxFCR_PTR[3][8] = {
      [0] = {
        [0] = (RW_ uint32_t* const)0x40020024U,   /** @brief Stream x FIFO control register */
        [1] = (RW_ uint32_t* const)0x4002003CU,   /** @brief Stream x FIFO control register */
        [2] = (RW_ uint32_t* const)0x40020054U,   /** @brief Stream x FIFO control register */
        [3] = (RW_ uint32_t* const)0x4002006CU,   /** @brief Stream x FIFO control register */
        [4] = (RW_ uint32_t* const)0x40020084U,   /** @brief Stream x FIFO control register */
        [5] = (RW_ uint32_t* const)0x4002009CU,   /** @brief Stream x FIFO control register */
        [6] = (RW_ uint32_t* const)0x400200B4U,   /** @brief Stream x FIFO control register */
        [7] = (RW_ uint32_t* const)0x400200CCU,   /** @brief Stream x FIFO control register */
      },
      [1] = {
        [0] = (RW_ uint32_t* const)0x40020424U,   /** @brief Stream x FIFO control register */
        [1] = (RW_ uint32_t* const)0x4002043CU,   /** @brief Stream x FIFO control register */
        [2] = (RW_ uint32_t* const)0x40020454U,   /** @brief Stream x FIFO control register */
        [3] = (RW_ uint32_t* const)0x4002046CU,   /** @brief Stream x FIFO control register */
        [4] = (RW_ uint32_t* const)0x40020484U,   /** @brief Stream x FIFO control register */
        [5] = (RW_ uint32_t* const)0x4002049CU,   /** @brief Stream x FIFO control register */
        [6] = (RW_ uint32_t* const)0x400204B4U,   /** @brief Stream x FIFO control register */
        [7] = (RW_ uint32_t* const)0x400204CCU,   /** @brief Stream x FIFO control register */
      },
    };

    static RW_ uint32_t* const DMAx_S1CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40020028U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020428U,   /** @brief Stream x configuration register */
    };

    static RW_ uint32_t* const DMAx_SxM1AR_PTR[3][8] = {
      [0] = {
        [1] = (RW_ uint32_t* const)0x40020038U,   /** @brief Stream x memory 1 address register */
        [2] = (RW_ uint32_t* const)0x40020050U,   /** @brief Stream x memory 1 address register */
        [3] = (RW_ uint32_t* const)0x40020068U,   /** @brief Stream x memory 1 address register */
        [4] = (RW_ uint32_t* const)0x40020080U,   /** @brief Stream x memory 1 address register */
        [5] = (RW_ uint32_t* const)0x40020098U,   /** @brief Stream x memory 1 address register */
        [6] = (RW_ uint32_t* const)0x400200B0U,   /** @brief Stream x memory 1 address register */
        [7] = (RW_ uint32_t* const)0x400200C8U,   /** @brief Stream x memory 1 address register */
      },
      [1] = {
        [1] = (RW_ uint32_t* const)0x40020438U,   /** @brief Stream x memory 1 address register */
        [2] = (RW_ uint32_t* const)0x40020450U,   /** @brief Stream x memory 1 address register */
        [3] = (RW_ uint32_t* const)0x40020468U,   /** @brief Stream x memory 1 address register */
        [4] = (RW_ uint32_t* const)0x40020480U,   /** @brief Stream x memory 1 address register */
        [5] = (RW_ uint32_t* const)0x40020498U,   /** @brief Stream x memory 1 address register */
        [6] = (RW_ uint32_t* const)0x400204B0U,   /** @brief Stream x memory 1 address register */
        [7] = (RW_ uint32_t* const)0x400204C8U,   /** @brief Stream x memory 1 address register */
      },
    };

    static RW_ uint32_t* const DMAx_S2CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40020040U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020440U,   /** @brief Stream x configuration register */
    };

    static RW_ uint32_t* const DMAx_S3CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40020058U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020458U,   /** @brief Stream x configuration register */
    };

    static RW_ uint32_t* const DMAx_S4CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40020070U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020470U,   /** @brief Stream x configuration register */
    };

    static RW_ uint32_t* const DMAx_S5CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40020088U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020488U,   /** @brief Stream x configuration register */
    };

    static RW_ uint32_t* const DMAx_S6CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400200A0U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x400204A0U,   /** @brief Stream x configuration register */
    };

    static RW_ uint32_t* const DMAx_S7CR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400200B8U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x400204B8U,   /** @brief Stream x configuration register */
    };

    /**** @subsection Enumerated DMAx Register Reset Values ****/

    static const uint32_t DMAx_LISR_RST[3] = {
      [1] = 0x00000000U,   /** @brief LISR register reset value */
      [2] = 0x00000000U,   /** @brief LISR register reset value */
    };

    static const uint32_t DMAx_HISR_RST[3] = {
      [1] = 0x00000000U,   /** @brief HISR register reset value */
      [2] = 0x00000000U,   /** @brief HISR register reset value */
    };

    static const uint32_t DMAx_LIFCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief LIFCR register reset value */
      [2] = 0x00000000U,   /** @brief LIFCR register reset value */
    };

    static const uint32_t DMAx_HIFCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief HIFCR register reset value */
      [2] = 0x00000000U,   /** @brief HIFCR register reset value */
    };

    static const uint32_t DMAx_S0CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S0CR register reset value */
      [2] = 0x00000000U,   /** @brief S0CR register reset value */
    };

    static const uint32_t DMAx_SxNDTR_RST[3][8] = {
      [0] = {
        [0] = 0x00000000U,   /** @brief S0NDTR register reset value. */
        [1] = 0x00000000U,   /** @brief S1NDTR register reset value. */
        [2] = 0x00000000U,   /** @brief S2NDTR register reset value. */
        [3] = 0x00000000U,   /** @brief S3NDTR register reset value. */
        [4] = 0x00000000U,   /** @brief S4NDTR register reset value. */
        [5] = 0x00000000U,   /** @brief S5NDTR register reset value. */
        [6] = 0x00000000U,   /** @brief S6NDTR register reset value. */
        [7] = 0x00000000U,   /** @brief S7NDTR register reset value. */
      },
      [1] = {
        [0] = 0x00000000U,   /** @brief S0NDTR register reset value. */
        [1] = 0x00000000U,   /** @brief S1NDTR register reset value. */
        [2] = 0x00000000U,   /** @brief S2NDTR register reset value. */
        [3] = 0x00000000U,   /** @brief S3NDTR register reset value. */
        [4] = 0x00000000U,   /** @brief S4NDTR register reset value. */
        [5] = 0x00000000U,   /** @brief S5NDTR register reset value. */
        [6] = 0x00000000U,   /** @brief S6NDTR register reset value. */
        [7] = 0x00000000U,   /** @brief S7NDTR register reset value. */
      },
    };

    static const uint32_t DMAx_SxPAR_RST[3][8] = {
      [0] = {
        [0] = 0x00000000U,   /** @brief S0PAR register reset value. */
        [1] = 0x00000000U,   /** @brief S1PAR register reset value. */
        [2] = 0x00000000U,   /** @brief S2PAR register reset value. */
        [3] = 0x00000000U,   /** @brief S3PAR register reset value. */
        [4] = 0x00000000U,   /** @brief S4PAR register reset value. */
        [5] = 0x00000000U,   /** @brief S5PAR register reset value. */
        [6] = 0x00000000U,   /** @brief S6PAR register reset value. */
        [7] = 0x00000000U,   /** @brief S7PAR register reset value. */
      },
      [1] = {
        [0] = 0x00000000U,   /** @brief S0PAR register reset value. */
        [1] = 0x00000000U,   /** @brief S1PAR register reset value. */
        [2] = 0x00000000U,   /** @brief S2PAR register reset value. */
        [3] = 0x00000000U,   /** @brief S3PAR register reset value. */
        [4] = 0x00000000U,   /** @brief S4PAR register reset value. */
        [5] = 0x00000000U,   /** @brief S5PAR register reset value. */
        [6] = 0x00000000U,   /** @brief S6PAR register reset value. */
        [7] = 0x00000000U,   /** @brief S7PAR register reset value. */
      },
    };

    static const uint32_t DMAx_SxM0AR_RST[3][8] = {
      [0] = {
        [0] = 0x00000000U,   /** @brief S0M0AR register reset value. */
        [1] = 0x00000000U,   /** @brief S1M0AR register reset value. */
        [2] = 0x00000000U,   /** @brief S2M0AR register reset value. */
        [3] = 0x00000000U,   /** @brief S3M0AR register reset value. */
        [4] = 0x00000000U,   /** @brief S4M0AR register reset value. */
        [5] = 0x00000000U,   /** @brief S5M0AR register reset value. */
        [6] = 0x00000000U,   /** @brief S6M0AR register reset value. */
        [7] = 0x00000000U,   /** @brief S7M0AR register reset value. */
      },
      [1] = {
        [0] = 0x00000000U,   /** @brief S0M0AR register reset value. */
        [1] = 0x00000000U,   /** @brief S1M0AR register reset value. */
        [2] = 0x00000000U,   /** @brief S2M0AR register reset value. */
        [3] = 0x00000000U,   /** @brief S3M0AR register reset value. */
        [4] = 0x00000000U,   /** @brief S4M0AR register reset value. */
        [5] = 0x00000000U,   /** @brief S5M0AR register reset value. */
        [6] = 0x00000000U,   /** @brief S6M0AR register reset value. */
        [7] = 0x00000000U,   /** @brief S7M0AR register reset value. */
      },
    };

    static const uint32_t DMAx_SxFCR_RST[3][8] = {
      [0] = {
        [0] = 0x00000021U,   /** @brief S0FCR register reset value. */
        [1] = 0x00000021U,   /** @brief S1FCR register reset value. */
        [2] = 0x00000021U,   /** @brief S2FCR register reset value. */
        [3] = 0x00000021U,   /** @brief S3FCR register reset value. */
        [4] = 0x00000021U,   /** @brief S4FCR register reset value. */
        [5] = 0x00000021U,   /** @brief S5FCR register reset value. */
        [6] = 0x00000021U,   /** @brief S6FCR register reset value. */
        [7] = 0x00000021U,   /** @brief S7FCR register reset value. */
      },
      [1] = {
        [0] = 0x00000021U,   /** @brief S0FCR register reset value. */
        [1] = 0x00000021U,   /** @brief S1FCR register reset value. */
        [2] = 0x00000021U,   /** @brief S2FCR register reset value. */
        [3] = 0x00000021U,   /** @brief S3FCR register reset value. */
        [4] = 0x00000021U,   /** @brief S4FCR register reset value. */
        [5] = 0x00000021U,   /** @brief S5FCR register reset value. */
        [6] = 0x00000021U,   /** @brief S6FCR register reset value. */
        [7] = 0x00000021U,   /** @brief S7FCR register reset value. */
      },
    };

    static const uint32_t DMAx_S1CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S1CR register reset value */
      [2] = 0x00000000U,   /** @brief S1CR register reset value */
    };

    static const uint32_t DMAx_SxM1AR_RST[3][8] = {
      [0] = {
        [1] = 0x00000000U,   /** @brief S1M1AR register reset value. */
        [2] = 0x00000000U,   /** @brief S2M1AR register reset value. */
        [3] = 0x00000000U,   /** @brief S3M1AR register reset value. */
        [4] = 0x00000000U,   /** @brief S4M1AR register reset value. */
        [5] = 0x00000000U,   /** @brief S5M1AR register reset value. */
        [6] = 0x00000000U,   /** @brief S6M1AR register reset value. */
        [7] = 0x00000000U,   /** @brief S7M1AR register reset value. */
      },
      [1] = {
        [1] = 0x00000000U,   /** @brief S1M1AR register reset value. */
        [2] = 0x00000000U,   /** @brief S2M1AR register reset value. */
        [3] = 0x00000000U,   /** @brief S3M1AR register reset value. */
        [4] = 0x00000000U,   /** @brief S4M1AR register reset value. */
        [5] = 0x00000000U,   /** @brief S5M1AR register reset value. */
        [6] = 0x00000000U,   /** @brief S6M1AR register reset value. */
        [7] = 0x00000000U,   /** @brief S7M1AR register reset value. */
      },
    };

    static const uint32_t DMAx_S2CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S2CR register reset value */
      [2] = 0x00000000U,   /** @brief S2CR register reset value */
    };

    static const uint32_t DMAx_S3CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S3CR register reset value */
      [2] = 0x00000000U,   /** @brief S3CR register reset value */
    };

    static const uint32_t DMAx_S4CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S4CR register reset value */
      [2] = 0x00000000U,   /** @brief S4CR register reset value */
    };

    static const uint32_t DMAx_S5CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S5CR register reset value */
      [2] = 0x00000000U,   /** @brief S5CR register reset value */
    };

    static const uint32_t DMAx_S6CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S6CR register reset value */
      [2] = 0x00000000U,   /** @brief S6CR register reset value */
    };

    static const uint32_t DMAx_S7CR_RST[3] = {
      [1] = 0x00000000U,   /** @brief S7CR register reset value */
      [2] = 0x00000000U,   /** @brief S7CR register reset value */
    };

    /**** @subsection Enumerated DMAx Register Value Types ****/

    typedef uint32_t DMAx_LISR_t;     /** @brief LISR register value type. */
    typedef uint32_t DMAx_HISR_t;     /** @brief HISR register value type. */
    typedef uint32_t DMAx_LIFCR_t;    /** @brief LIFCR register value type. */
    typedef uint32_t DMAx_HIFCR_t;    /** @brief HIFCR register value type. */
    typedef uint32_t DMAx_S0CR_t;     /** @brief S0CR register value type. */
    typedef uint32_t DMAx_SxNDTR_t;   /** @brief SxNDTR register value type. */
    typedef uint32_t DMAx_SxPAR_t;    /** @brief SxPAR register value type. */
    typedef uint32_t DMAx_SxM0AR_t;   /** @brief SxM0AR register value type. */
    typedef uint32_t DMAx_S0MxAR_t;   /** @brief S0MxAR register value type. */
    typedef uint32_t DMAx_SxFCR_t;    /** @brief SxFCR register value type. */
    typedef uint32_t DMAx_S1CR_t;     /** @brief S1CR register value type. */
    typedef uint32_t DMAx_SxM1AR_t;   /** @brief SxM1AR register value type. */
    typedef uint32_t DMAx_S2CR_t;     /** @brief S2CR register value type. */
    typedef uint32_t DMAx_S3CR_t;     /** @brief S3CR register value type. */
    typedef uint32_t DMAx_S4CR_t;     /** @brief S4CR register value type. */
    typedef uint32_t DMAx_S5CR_t;     /** @brief S5CR register value type. */
    typedef uint32_t DMAx_S6CR_t;     /** @brief S6CR register value type. */
    typedef uint32_t DMAx_S7CR_t;     /** @brief S7CR register value type. */

    /**** @subsection Enumerated DMAx Register Pointer Types ****/

    typedef uint32_t* const DMAx_LISR_PTR_t;     /** @brief LISR register pointer type. */
    typedef uint32_t* const DMAx_HISR_PTR_t;     /** @brief HISR register pointer type. */
    typedef uint32_t* const DMAx_LIFCR_PTR_t;    /** @brief LIFCR register pointer type. */
    typedef uint32_t* const DMAx_HIFCR_PTR_t;    /** @brief HIFCR register pointer type. */
    typedef uint32_t* const DMAx_S0CR_PTR_t;     /** @brief S0CR register pointer type. */
    typedef uint32_t* const DMAx_SxNDTR_PTR_t;   /** @brief SxNDTR register pointer type. */
    typedef uint32_t* const DMAx_SxPAR_PTR_t;    /** @brief SxPAR register pointer type. */
    typedef uint32_t* const DMAx_SxM0AR_PTR_t;   /** @brief SxM0AR register pointer type. */
    typedef uint32_t* const DMAx_S0MxAR_PTR_t;   /** @brief S0MxAR register pointer type. */
    typedef uint32_t* const DMAx_SxFCR_PTR_t;    /** @brief SxFCR register pointer type. */
    typedef uint32_t* const DMAx_S1CR_PTR_t;     /** @brief S1CR register pointer type. */
    typedef uint32_t* const DMAx_SxM1AR_PTR_t;   /** @brief SxM1AR register pointer type. */
    typedef uint32_t* const DMAx_S2CR_PTR_t;     /** @brief S2CR register pointer type. */
    typedef uint32_t* const DMAx_S3CR_PTR_t;     /** @brief S3CR register pointer type. */
    typedef uint32_t* const DMAx_S4CR_PTR_t;     /** @brief S4CR register pointer type. */
    typedef uint32_t* const DMAx_S5CR_PTR_t;     /** @brief S5CR register pointer type. */
    typedef uint32_t* const DMAx_S6CR_PTR_t;     /** @brief S6CR register pointer type. */
    typedef uint32_t* const DMAx_S7CR_PTR_t;     /** @brief S7CR register pointer type. */

    /**** @subsection DMAx Register Field Masks ****/

    static const uint32_t DMAx_S0CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S0CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S0CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S0CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S0CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S0CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S0CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S0CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S0CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S0CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S0CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S0CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S0CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S0CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S0CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S0CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S0CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S0CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAx_SxNDTR_NDT_MASK    = 0x0000FFFFU;   /** @brief Number of data items to transfer */
    static const uint32_t DMAx_SxFCR_FEIE_MASK    = 0x00000080U;   /** @brief FIFO error interrupt enable */
    static const uint32_t DMAx_SxFCR_FS_MASK      = 0x00000038U;   /** @brief FIFO status */
    static const uint32_t DMAx_SxFCR_DMDIS_MASK   = 0x00000004U;   /** @brief Direct mode disable */
    static const uint32_t DMAx_SxFCR_FTH_MASK     = 0x00000003U;   /** @brief FIFO threshold selection */
    static const uint32_t DMAx_S1CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S1CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S1CR_ACK_MASK      = 0x00100000U;   /** @brief ACK */
    static const uint32_t DMAx_S1CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S1CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S1CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S1CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S1CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S1CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S1CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S1CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S1CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S1CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S1CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S1CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S1CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S1CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S1CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S1CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAx_S2CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S2CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S2CR_ACK_MASK      = 0x00100000U;   /** @brief ACK */
    static const uint32_t DMAx_S2CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S2CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S2CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S2CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S2CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S2CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S2CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S2CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S2CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S2CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S2CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S2CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S2CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S2CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S2CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S2CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAx_S3CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S3CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S3CR_ACK_MASK      = 0x00100000U;   /** @brief ACK */
    static const uint32_t DMAx_S3CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S3CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S3CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S3CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S3CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S3CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S3CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S3CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S3CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S3CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S3CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S3CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S3CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S3CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S3CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S3CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAx_S4CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S4CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S4CR_ACK_MASK      = 0x00100000U;   /** @brief ACK */
    static const uint32_t DMAx_S4CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S4CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S4CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S4CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S4CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S4CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S4CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S4CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S4CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S4CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S4CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S4CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S4CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S4CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S4CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S4CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAx_S5CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S5CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S5CR_ACK_MASK      = 0x00100000U;   /** @brief ACK */
    static const uint32_t DMAx_S5CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S5CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S5CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S5CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S5CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S5CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S5CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S5CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S5CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S5CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S5CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S5CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S5CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S5CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S5CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S5CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAx_S6CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S6CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S6CR_ACK_MASK      = 0x00100000U;   /** @brief ACK */
    static const uint32_t DMAx_S6CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S6CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S6CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S6CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S6CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S6CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S6CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S6CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S6CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S6CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S6CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S6CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S6CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S6CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S6CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S6CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAx_S7CR_MBURST_MASK   = 0x01800000U;   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAx_S7CR_PBURST_MASK   = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAx_S7CR_ACK_MASK      = 0x00100000U;   /** @brief ACK */
    static const uint32_t DMAx_S7CR_CT_MASK       = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAx_S7CR_DBM_MASK      = 0x00040000U;   /** @brief Double buffer mode */
    static const uint32_t DMAx_S7CR_PL_MASK       = 0x00030000U;   /** @brief Priority level */
    static const uint32_t DMAx_S7CR_PINCOS_MASK   = 0x00008000U;   /** @brief Peripheral increment offset size */
    static const uint32_t DMAx_S7CR_MSIZE_MASK    = 0x00006000U;   /** @brief Memory data size */
    static const uint32_t DMAx_S7CR_PSIZE_MASK    = 0x00001800U;   /** @brief Peripheral data size */
    static const uint32_t DMAx_S7CR_MINC_MASK     = 0x00000400U;   /** @brief Memory increment mode */
    static const uint32_t DMAx_S7CR_PINC_MASK     = 0x00000200U;   /** @brief Peripheral increment mode */
    static const uint32_t DMAx_S7CR_CIRC_MASK     = 0x00000100U;   /** @brief Circular mode */
    static const uint32_t DMAx_S7CR_DIR_MASK      = 0x000000C0U;   /** @brief Data transfer direction */
    static const uint32_t DMAx_S7CR_PFCTRL_MASK   = 0x00000020U;   /** @brief Peripheral flow controller */
    static const uint32_t DMAx_S7CR_TCIE_MASK     = 0x00000010U;   /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAx_S7CR_HTIE_MASK     = 0x00000008U;   /** @brief Half transfer interrupt enable */
    static const uint32_t DMAx_S7CR_TEIE_MASK     = 0x00000004U;   /** @brief Transfer error interrupt enable */
    static const uint32_t DMAx_S7CR_DMEIE_MASK    = 0x00000002U;   /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAx_S7CR_EN_MASK       = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */

    /**** @subsection Enumerated DMAx Register Field Masks ****/

    static const uint32_t DMAx_LISR_TCIFx_MASK[4] = {
      [0] = 0x00000020U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      [1] = 0x00000800U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      [2] = 0x00200000U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      [3] = 0x08000000U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAx_LISR_HTIFx_MASK[4] = {
      [0] = 0x00000010U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      [1] = 0x00000400U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      [2] = 0x00100000U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      [3] = 0x04000000U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    };

    static const uint32_t DMAx_LISR_TEIFx_MASK[4] = {
      [0] = 0x00000008U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      [1] = 0x00000200U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      [2] = 0x00080000U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      [3] = 0x02000000U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    };

    static const uint32_t DMAx_LISR_DMEIFx_MASK[4] = {
      [0] = 0x00000004U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      [1] = 0x00000100U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      [2] = 0x00040000U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      [3] = 0x01000000U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    };

    static const uint32_t DMAx_LISR_FEIFx_MASK[4] = {
      [0] = 0x00000001U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      [1] = 0x00000040U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      [2] = 0x00010000U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      [3] = 0x00400000U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    };

    static const uint32_t DMAx_LIFCR_CTCIFx_MASK[4] = {
      [0] = 0x00000020U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      [1] = 0x00000800U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      [2] = 0x00200000U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      [3] = 0x08000000U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAx_LIFCR_CHTIFx_MASK[4] = {
      [0] = 0x00000010U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      [1] = 0x00000400U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      [2] = 0x00100000U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      [3] = 0x04000000U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAx_LIFCR_CTEIFx_MASK[4] = {
      [0] = 0x00000008U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      [1] = 0x00000200U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      [2] = 0x00080000U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      [3] = 0x02000000U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAx_LIFCR_CDMEIFx_MASK[4] = {
      [0] = 0x00000004U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      [1] = 0x00000100U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      [2] = 0x00040000U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      [3] = 0x01000000U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAx_LIFCR_CFEIFx_MASK[4] = {
      [0] = 0x00000001U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      [1] = 0x00000040U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      [2] = 0x00010000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      [3] = 0x00400000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    };

    /**** @subsection DMAx Register Field Positions ****/

    static const int32_t DMAx_S0CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S0CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S0CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S0CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S0CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S0CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S0CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S0CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S0CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S0CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S0CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S0CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S0CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S0CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S0CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S0CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S0CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S0CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAx_SxNDTR_NDT_POS    = 0;    /** @brief Number of data items to transfer */
    static const int32_t DMAx_SxFCR_FEIE_POS    = 7;    /** @brief FIFO error interrupt enable */
    static const int32_t DMAx_SxFCR_FS_POS      = 3;    /** @brief FIFO status */
    static const int32_t DMAx_SxFCR_DMDIS_POS   = 2;    /** @brief Direct mode disable */
    static const int32_t DMAx_SxFCR_FTH_POS     = 0;    /** @brief FIFO threshold selection */
    static const int32_t DMAx_S1CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S1CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S1CR_ACK_POS      = 20;   /** @brief ACK */
    static const int32_t DMAx_S1CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S1CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S1CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S1CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S1CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S1CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S1CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S1CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S1CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S1CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S1CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S1CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S1CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S1CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S1CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S1CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAx_S2CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S2CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S2CR_ACK_POS      = 20;   /** @brief ACK */
    static const int32_t DMAx_S2CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S2CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S2CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S2CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S2CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S2CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S2CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S2CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S2CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S2CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S2CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S2CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S2CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S2CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S2CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S2CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAx_S3CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S3CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S3CR_ACK_POS      = 20;   /** @brief ACK */
    static const int32_t DMAx_S3CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S3CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S3CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S3CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S3CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S3CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S3CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S3CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S3CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S3CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S3CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S3CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S3CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S3CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S3CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S3CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAx_S4CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S4CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S4CR_ACK_POS      = 20;   /** @brief ACK */
    static const int32_t DMAx_S4CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S4CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S4CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S4CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S4CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S4CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S4CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S4CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S4CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S4CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S4CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S4CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S4CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S4CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S4CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S4CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAx_S5CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S5CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S5CR_ACK_POS      = 20;   /** @brief ACK */
    static const int32_t DMAx_S5CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S5CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S5CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S5CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S5CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S5CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S5CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S5CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S5CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S5CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S5CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S5CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S5CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S5CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S5CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S5CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAx_S6CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S6CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S6CR_ACK_POS      = 20;   /** @brief ACK */
    static const int32_t DMAx_S6CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S6CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S6CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S6CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S6CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S6CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S6CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S6CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S6CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S6CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S6CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S6CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S6CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S6CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S6CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S6CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAx_S7CR_MBURST_POS   = 23;   /** @brief Memory burst transfer configuration */
    static const int32_t DMAx_S7CR_PBURST_POS   = 21;   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAx_S7CR_ACK_POS      = 20;   /** @brief ACK */
    static const int32_t DMAx_S7CR_CT_POS       = 19;   /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAx_S7CR_DBM_POS      = 18;   /** @brief Double buffer mode */
    static const int32_t DMAx_S7CR_PL_POS       = 16;   /** @brief Priority level */
    static const int32_t DMAx_S7CR_PINCOS_POS   = 15;   /** @brief Peripheral increment offset size */
    static const int32_t DMAx_S7CR_MSIZE_POS    = 13;   /** @brief Memory data size */
    static const int32_t DMAx_S7CR_PSIZE_POS    = 11;   /** @brief Peripheral data size */
    static const int32_t DMAx_S7CR_MINC_POS     = 10;   /** @brief Memory increment mode */
    static const int32_t DMAx_S7CR_PINC_POS     = 9;    /** @brief Peripheral increment mode */
    static const int32_t DMAx_S7CR_CIRC_POS     = 8;    /** @brief Circular mode */
    static const int32_t DMAx_S7CR_DIR_POS      = 6;    /** @brief Data transfer direction */
    static const int32_t DMAx_S7CR_PFCTRL_POS   = 5;    /** @brief Peripheral flow controller */
    static const int32_t DMAx_S7CR_TCIE_POS     = 4;    /** @brief Transfer complete interrupt enable */
    static const int32_t DMAx_S7CR_HTIE_POS     = 3;    /** @brief Half transfer interrupt enable */
    static const int32_t DMAx_S7CR_TEIE_POS     = 2;    /** @brief Transfer error interrupt enable */
    static const int32_t DMAx_S7CR_DMEIE_POS    = 1;    /** @brief Direct mode error interrupt enable */
    static const int32_t DMAx_S7CR_EN_POS       = 0;    /** @brief Stream enable / flag stream ready when read low */

    /**** @subsection Enumerated DMAx Register Field Positions ****/

    static const int32_t DMAx_LISR_TCIFx_POS[4] = {
      [0] = 5,    /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      [1] = 11,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      [2] = 21,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      [3] = 27,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    };

    static const int32_t DMAx_LISR_HTIFx_POS[4] = {
      [0] = 4,    /** @brief Stream x half transfer interrupt flag (x=3..0) */
      [1] = 10,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      [2] = 20,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      [3] = 26,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    };

    static const int32_t DMAx_LISR_TEIFx_POS[4] = {
      [0] = 3,    /** @brief Stream x transfer error interrupt flag (x=3..0) */
      [1] = 9,    /** @brief Stream x transfer error interrupt flag (x=3..0) */
      [2] = 19,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      [3] = 25,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    };

    static const int32_t DMAx_LISR_DMEIFx_POS[4] = {
      [0] = 2,    /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      [1] = 8,    /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      [2] = 18,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      [3] = 24,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    };

    static const int32_t DMAx_LISR_FEIFx_POS[4] = {
      [0] = 0,    /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      [1] = 6,    /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      [2] = 16,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      [3] = 22,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    };

    static const int32_t DMAx_LIFCR_CTCIFx_POS[4] = {
      [0] = 5,    /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      [1] = 11,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      [2] = 21,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      [3] = 27,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    };

    static const int32_t DMAx_LIFCR_CHTIFx_POS[4] = {
      [0] = 4,    /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      [1] = 10,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      [2] = 20,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      [3] = 26,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    };

    static const int32_t DMAx_LIFCR_CTEIFx_POS[4] = {
      [0] = 3,    /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      [1] = 9,    /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      [2] = 19,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      [3] = 25,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    };

    static const int32_t DMAx_LIFCR_CDMEIFx_POS[4] = {
      [0] = 2,    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      [1] = 8,    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      [2] = 18,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      [3] = 24,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    };

    static const int32_t DMAx_LIFCR_CFEIFx_POS[4] = {
      [0] = 0,    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      [1] = 6,    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      [2] = 16,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      [3] = 22,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    };

    /**********************************************************************************************
     * @section HRTIM_MASTER Register Information
     **********************************************************************************************/

    /**** @subsection HRTIM_MASTER Register Pointers ****/

    static RW_ uint32_t* const HRTIM_MASTER_MCR_PTR      = (RW_ uint32_t* const)0x40017400U;   /** @brief Master timer control register */
    static RO_ uint32_t* const HRTIM_MASTER_MISR_PTR     = (RO_ uint32_t* const)0x40017404U;   /** @brief Master timer interrupt status register */
    static RW_ uint32_t* const HRTIM_MASTER_MICR_PTR     = (RW_ uint32_t* const)0x40017408U;   /** @brief Master timer interrupt clear register */
    static RW_ uint32_t* const HRTIM_MASTER_MDIER4_PTR   = (RW_ uint32_t* const)0x4001740CU;   /** @brief MDIER4 */
    static RW_ uint32_t* const HRTIM_MASTER_MCNTR_PTR    = (RW_ uint32_t* const)0x40017410U;   /** @brief Master timer counter register */
    static RW_ uint32_t* const HRTIM_MASTER_MPER_PTR     = (RW_ uint32_t* const)0x40017414U;   /** @brief Master timer period register */
    static RW_ uint32_t* const HRTIM_MASTER_MREP_PTR     = (RW_ uint32_t* const)0x40017418U;   /** @brief Master timer repetition register */

    /**** @subsection Enumerated HRTIM_MASTER Register Pointers ****/

    static RW_ uint32_t* const HRTIM_MASTER_MCMPxR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001741CU,   /** @brief Master timer compare 1 register */
      [2] = (RW_ uint32_t* const)0x40017424U,   /** @brief Master timer compare 2 register */
      [3] = (RW_ uint32_t* const)0x40017428U,   /** @brief Master timer compare 3 register */
      [4] = (RW_ uint32_t* const)0x4001742CU,   /** @brief Master timer compare 4 register */
    };

    /**** @subsection HRTIM_MASTER Register Reset Values ****/

    static const uint32_t HRTIM_MASTER_MCR_RST      = 0x00000000U;   /** @brief MCR register reset value. */
    static const uint32_t HRTIM_MASTER_MISR_RST     = 0x00000000U;   /** @brief MISR register reset value. */
    static const uint32_t HRTIM_MASTER_MICR_RST     = 0x00000000U;   /** @brief MICR register reset value. */
    static const uint32_t HRTIM_MASTER_MDIER4_RST   = 0x00000000U;   /** @brief MDIER4 register reset value. */
    static const uint32_t HRTIM_MASTER_MCNTR_RST    = 0x00000000U;   /** @brief MCNTR register reset value. */
    static const uint32_t HRTIM_MASTER_MPER_RST     = 0x0000FFFFU;   /** @brief MPER register reset value. */
    static const uint32_t HRTIM_MASTER_MREP_RST     = 0x00000000U;   /** @brief MREP register reset value. */

    /**** @subsection Enumerated HRTIM_MASTER Register Reset Values ****/

    static const uint32_t HRTIM_MASTER_MCMPxR_RST[5] = {
      [1] = 0x00000000U,   /** @brief MCMP1R register reset value. */
      [2] = 0x00000000U,   /** @brief MCMP2R register reset value. */
      [3] = 0x00000000U,   /** @brief MCMP3R register reset value. */
      [4] = 0x00000000U,   /** @brief MCMP4R register reset value. */
    };

    /**** @subsection Enumerated HRTIM_MASTER Register Value Types ****/

    typedef uint32_t HRTIM_MASTER_MCR_t;      /** @brief MCR register value type. */
    typedef uint32_t HRTIM_MASTER_MISR_t;     /** @brief MISR register value type. */
    typedef uint32_t HRTIM_MASTER_MICR_t;     /** @brief MICR register value type. */
    typedef uint32_t HRTIM_MASTER_MDIER4_t;   /** @brief MDIER4 register value type. */
    typedef uint32_t HRTIM_MASTER_MCNTR_t;    /** @brief MCNTR register value type. */
    typedef uint32_t HRTIM_MASTER_MPER_t;     /** @brief MPER register value type. */
    typedef uint32_t HRTIM_MASTER_MREP_t;     /** @brief MREP register value type. */
    typedef uint32_t HRTIM_MASTER_MCMPxR_t;   /** @brief MCMPxR register value type. */

    /**** @subsection Enumerated HRTIM_MASTER Register Pointer Types ****/

    typedef uint32_t* const HRTIM_MASTER_MCR_PTR_t;      /** @brief MCR register pointer type. */
    typedef uint32_t* const HRTIM_MASTER_MISR_PTR_t;     /** @brief MISR register pointer type. */
    typedef uint32_t* const HRTIM_MASTER_MICR_PTR_t;     /** @brief MICR register pointer type. */
    typedef uint32_t* const HRTIM_MASTER_MDIER4_PTR_t;   /** @brief MDIER4 register pointer type. */
    typedef uint32_t* const HRTIM_MASTER_MCNTR_PTR_t;    /** @brief MCNTR register pointer type. */
    typedef uint32_t* const HRTIM_MASTER_MPER_PTR_t;     /** @brief MPER register pointer type. */
    typedef uint32_t* const HRTIM_MASTER_MREP_PTR_t;     /** @brief MREP register pointer type. */
    typedef uint32_t* const HRTIM_MASTER_MCMPxR_PTR_t;   /** @brief MCMPxR register pointer type. */

    /**** @subsection HRTIM_MASTER Register Field Masks ****/

    static const uint32_t HRTIM_MASTER_MCR_BRSTDMA_MASK     = 0xC0000000U;   /** @brief Burst DMA update */
    static const uint32_t HRTIM_MASTER_MCR_MREPU_MASK       = 0x20000000U;   /** @brief Master timer repetition update */
    static const uint32_t HRTIM_MASTER_MCR_PREEN_MASK       = 0x08000000U;   /** @brief Preload enable */
    static const uint32_t HRTIM_MASTER_MCR_DACSYNC_MASK     = 0x06000000U;   /** @brief AC synchronization */
    static const uint32_t HRTIM_MASTER_MCR_TECEN_MASK       = 0x00200000U;   /** @brief Timer E counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TDCEN_MASK       = 0x00100000U;   /** @brief Timer D counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TCCEN_MASK       = 0x00080000U;   /** @brief Timer C counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TBCEN_MASK       = 0x00040000U;   /** @brief Timer B counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TACEN_MASK       = 0x00020000U;   /** @brief Timer A counter enable */
    static const uint32_t HRTIM_MASTER_MCR_MCEN_MASK        = 0x00010000U;   /** @brief Master counter enable */
    static const uint32_t HRTIM_MASTER_MCR_SYNC_SRC_MASK    = 0x0000C000U;   /** @brief Synchronization source */
    static const uint32_t HRTIM_MASTER_MCR_SYNC_OUT_MASK    = 0x00003000U;   /** @brief Synchronization output */
    static const uint32_t HRTIM_MASTER_MCR_SYNCSTRTM_MASK   = 0x00000800U;   /** @brief Synchronization starts master */
    static const uint32_t HRTIM_MASTER_MCR_SYNCRSTM_MASK    = 0x00000400U;   /** @brief Synchronization resets master */
    static const uint32_t HRTIM_MASTER_MCR_SYNC_IN_MASK     = 0x00000300U;   /** @brief Ynchronization input */
    static const uint32_t HRTIM_MASTER_MCR_HALF_MASK        = 0x00000020U;   /** @brief Half mode enable */
    static const uint32_t HRTIM_MASTER_MCR_RETRIG_MASK      = 0x00000010U;   /** @brief Master re-triggerable mode */
    static const uint32_t HRTIM_MASTER_MCR_CONT_MASK        = 0x00000008U;   /** @brief Master continuous mode */
    static const uint32_t HRTIM_MASTER_MCR_CK_PSC_MASK      = 0x00000007U;   /** @brief HRTIM master clock prescaler */
    static const uint32_t HRTIM_MASTER_MISR_MUPD_MASK       = 0x00000040U;   /** @brief Master update interrupt flag */
    static const uint32_t HRTIM_MASTER_MISR_SYNC_MASK       = 0x00000020U;   /** @brief Sync input interrupt flag */
    static const uint32_t HRTIM_MASTER_MISR_MREP_MASK       = 0x00000010U;   /** @brief Master repetition interrupt flag */
    static const uint32_t HRTIM_MASTER_MICR_MUPDC_MASK      = 0x00000040U;   /** @brief Master update interrupt flag clear */
    static const uint32_t HRTIM_MASTER_MICR_SYNCC_MASK      = 0x00000020U;   /** @brief Sync input interrupt flag clear */
    static const uint32_t HRTIM_MASTER_MICR_MREPC_MASK      = 0x00000010U;   /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_MASTER_MDIER4_MUPDDE_MASK   = 0x00400000U;   /** @brief MUPDDE */
    static const uint32_t HRTIM_MASTER_MDIER4_SYNCDE_MASK   = 0x00200000U;   /** @brief SYNCDE */
    static const uint32_t HRTIM_MASTER_MDIER4_MREPDE_MASK   = 0x00100000U;   /** @brief MREPDE */
    static const uint32_t HRTIM_MASTER_MDIER4_MUPDIE_MASK   = 0x00000040U;   /** @brief MUPDIE */
    static const uint32_t HRTIM_MASTER_MDIER4_SYNCIE_MASK   = 0x00000020U;   /** @brief SYNCIE */
    static const uint32_t HRTIM_MASTER_MDIER4_MREPIE_MASK   = 0x00000010U;   /** @brief MREPIE */
    static const uint32_t HRTIM_MASTER_MCNTR_MCNT_MASK      = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t HRTIM_MASTER_MPER_MPER_MASK       = 0x0000FFFFU;   /** @brief Master timer period value */
    static const uint32_t HRTIM_MASTER_MREP_MREP_MASK       = 0x000000FFU;   /** @brief Master timer repetition counter value */
    static const uint32_t HRTIM_MASTER_MCMPxR_MCMP1_MASK    = 0x0000FFFFU;   /** @brief Master timer compare 1 value */

    /**** @subsection Enumerated HRTIM_MASTER Register Field Masks ****/

    static const uint32_t HRTIM_MASTER_MISR_MCMPx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Master compare 1 interrupt flag */
      [2] = 0x00000002U,   /** @brief Master compare 2 interrupt flag */
      [3] = 0x00000004U,   /** @brief Master compare 3 interrupt flag */
      [4] = 0x00000008U,   /** @brief Master compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_MASTER_MICR_MCMPxC_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Master compare 1 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Master compare 2 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Master compare 3 interrupt flag clear */
      [4] = 0x00000008U,   /** @brief Master compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_MASTER_MDIER4_MCMPxDE_MASK[5] = {
      [1] = 0x00010000U,   /** @brief MCMP1DE */
      [2] = 0x00020000U,   /** @brief MCMP2DE */
      [3] = 0x00040000U,   /** @brief MCMP3DE */
      [4] = 0x00080000U,   /** @brief MCMP4DE */
    };

    static const uint32_t HRTIM_MASTER_MDIER4_MCMPxIE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief MCMP1IE */
      [2] = 0x00000002U,   /** @brief MCMP2IE */
      [3] = 0x00000004U,   /** @brief MCMP3IE */
      [4] = 0x00000008U,   /** @brief MCMP4IE */
    };

    /**** @subsection HRTIM_MASTER Register Field Positions ****/

    static const int32_t HRTIM_MASTER_MCR_BRSTDMA_POS     = 30;   /** @brief Burst DMA update */
    static const int32_t HRTIM_MASTER_MCR_MREPU_POS       = 29;   /** @brief Master timer repetition update */
    static const int32_t HRTIM_MASTER_MCR_PREEN_POS       = 27;   /** @brief Preload enable */
    static const int32_t HRTIM_MASTER_MCR_DACSYNC_POS     = 25;   /** @brief AC synchronization */
    static const int32_t HRTIM_MASTER_MCR_TECEN_POS       = 21;   /** @brief Timer E counter enable */
    static const int32_t HRTIM_MASTER_MCR_TDCEN_POS       = 20;   /** @brief Timer D counter enable */
    static const int32_t HRTIM_MASTER_MCR_TCCEN_POS       = 19;   /** @brief Timer C counter enable */
    static const int32_t HRTIM_MASTER_MCR_TBCEN_POS       = 18;   /** @brief Timer B counter enable */
    static const int32_t HRTIM_MASTER_MCR_TACEN_POS       = 17;   /** @brief Timer A counter enable */
    static const int32_t HRTIM_MASTER_MCR_MCEN_POS        = 16;   /** @brief Master counter enable */
    static const int32_t HRTIM_MASTER_MCR_SYNC_SRC_POS    = 14;   /** @brief Synchronization source */
    static const int32_t HRTIM_MASTER_MCR_SYNC_OUT_POS    = 12;   /** @brief Synchronization output */
    static const int32_t HRTIM_MASTER_MCR_SYNCSTRTM_POS   = 11;   /** @brief Synchronization starts master */
    static const int32_t HRTIM_MASTER_MCR_SYNCRSTM_POS    = 10;   /** @brief Synchronization resets master */
    static const int32_t HRTIM_MASTER_MCR_SYNC_IN_POS     = 8;    /** @brief Ynchronization input */
    static const int32_t HRTIM_MASTER_MCR_HALF_POS        = 5;    /** @brief Half mode enable */
    static const int32_t HRTIM_MASTER_MCR_RETRIG_POS      = 4;    /** @brief Master re-triggerable mode */
    static const int32_t HRTIM_MASTER_MCR_CONT_POS        = 3;    /** @brief Master continuous mode */
    static const int32_t HRTIM_MASTER_MCR_CK_PSC_POS      = 0;    /** @brief HRTIM master clock prescaler */
    static const int32_t HRTIM_MASTER_MISR_MUPD_POS       = 6;    /** @brief Master update interrupt flag */
    static const int32_t HRTIM_MASTER_MISR_SYNC_POS       = 5;    /** @brief Sync input interrupt flag */
    static const int32_t HRTIM_MASTER_MISR_MREP_POS       = 4;    /** @brief Master repetition interrupt flag */
    static const int32_t HRTIM_MASTER_MICR_MUPDC_POS      = 6;    /** @brief Master update interrupt flag clear */
    static const int32_t HRTIM_MASTER_MICR_SYNCC_POS      = 5;    /** @brief Sync input interrupt flag clear */
    static const int32_t HRTIM_MASTER_MICR_MREPC_POS      = 4;    /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_MASTER_MDIER4_MUPDDE_POS   = 22;   /** @brief MUPDDE */
    static const int32_t HRTIM_MASTER_MDIER4_SYNCDE_POS   = 21;   /** @brief SYNCDE */
    static const int32_t HRTIM_MASTER_MDIER4_MREPDE_POS   = 20;   /** @brief MREPDE */
    static const int32_t HRTIM_MASTER_MDIER4_MUPDIE_POS   = 6;    /** @brief MUPDIE */
    static const int32_t HRTIM_MASTER_MDIER4_SYNCIE_POS   = 5;    /** @brief SYNCIE */
    static const int32_t HRTIM_MASTER_MDIER4_MREPIE_POS   = 4;    /** @brief MREPIE */
    static const int32_t HRTIM_MASTER_MCNTR_MCNT_POS      = 0;    /** @brief Counter value */
    static const int32_t HRTIM_MASTER_MPER_MPER_POS       = 0;    /** @brief Master timer period value */
    static const int32_t HRTIM_MASTER_MREP_MREP_POS       = 0;    /** @brief Master timer repetition counter value */
    static const int32_t HRTIM_MASTER_MCMPxR_MCMP1_POS    = 0;    /** @brief Master timer compare 1 value */

    /**** @subsection Enumerated HRTIM_MASTER Register Field Positions ****/

    static const int32_t HRTIM_MASTER_MISR_MCMPx_POS[5] = {
      [1] = 0,   /** @brief Master compare 1 interrupt flag */
      [2] = 1,   /** @brief Master compare 2 interrupt flag */
      [3] = 2,   /** @brief Master compare 3 interrupt flag */
      [4] = 3,   /** @brief Master compare 4 interrupt flag */
    };

    static const int32_t HRTIM_MASTER_MICR_MCMPxC_POS[5] = {
      [1] = 0,   /** @brief Master compare 1 interrupt flag clear */
      [2] = 1,   /** @brief Master compare 2 interrupt flag clear */
      [3] = 2,   /** @brief Master compare 3 interrupt flag clear */
      [4] = 3,   /** @brief Master compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_MASTER_MDIER4_MCMPxDE_POS[5] = {
      [1] = 16,   /** @brief MCMP1DE */
      [2] = 17,   /** @brief MCMP2DE */
      [3] = 18,   /** @brief MCMP3DE */
      [4] = 19,   /** @brief MCMP4DE */
    };

    static const int32_t HRTIM_MASTER_MDIER4_MCMPxIE_POS[5] = {
      [1] = 0,   /** @brief MCMP1IE */
      [2] = 1,   /** @brief MCMP2IE */
      [3] = 2,   /** @brief MCMP3IE */
      [4] = 3,   /** @brief MCMP4IE */
    };

    /**********************************************************************************************
     * @section HRTIM_TIMA Register Information
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMA Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMA_TIMACR_PTR      = (RW_ uint32_t* const)0x40017480U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMA_TIMAISR_PTR     = (RO_ uint32_t* const)0x40017484U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMA_TIMAICR_PTR     = (RW_ uint32_t* const)0x40017488U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMA_TIMADIER5_PTR   = (RW_ uint32_t* const)0x4001748CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMA_CNTAR_PTR       = (RW_ uint32_t* const)0x40017490U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMA_PERAR_PTR       = (RW_ uint32_t* const)0x40017494U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMA_REPAR_PTR       = (RW_ uint32_t* const)0x40017498U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMA_CMP1CAR_PTR     = (RW_ uint32_t* const)0x400174A0U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMA_DTAR_PTR        = (RW_ uint32_t* const)0x400174B8U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMA_EEFAR1_PTR      = (RW_ uint32_t* const)0x400174CCU;   /** @brief Timerx external event filtering register 1 */
    static RW_ uint32_t* const HRTIM_TIMA_EEFAR2_PTR      = (RW_ uint32_t* const)0x400174D0U;   /** @brief Timerx external event filtering register 2 */
    static RW_ uint32_t* const HRTIM_TIMA_RSTAR_PTR       = (RW_ uint32_t* const)0x400174D4U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMA_CHPAR_PTR       = (RW_ uint32_t* const)0x400174D8U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMA_OUTAR_PTR       = (RW_ uint32_t* const)0x400174E4U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMA_FLTAR_PTR       = (RW_ uint32_t* const)0x400174E8U;   /** @brief Timerx fault register */

    /**** @subsection Enumerated HRTIM_TIMA Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMA_CMPxAR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001749CU,   /** @brief Timerx compare 1 register */
      [2] = (RW_ uint32_t* const)0x400174A4U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t* const)0x400174A8U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t* const)0x400174ACU,   /** @brief Timerx compare 4 register */
    };

    static RO_ uint32_t* const HRTIM_TIMA_CPTxAR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x400174B0U,   /** @brief Timerx capture 1 register */
      [2] = (RO_ uint32_t* const)0x400174B4U,   /** @brief Timerx capture 2 register */
    };

    static RW_ uint32_t* const HRTIM_TIMA_SETAxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400174BCU,   /** @brief Timerx output1 set register */
      [2] = (RW_ uint32_t* const)0x400174C4U,   /** @brief Timerx output2 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMA_RSTAxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400174C0U,   /** @brief Timerx output1 reset register */
      [2] = (RW_ uint32_t* const)0x400174C8U,   /** @brief Timerx output2 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMA_CPTxACR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400174DCU,   /** @brief Timerx capture 2 control register */
      [2] = (RW_ uint32_t* const)0x400174E0U,   /** @brief CPT2xCR */
    };

    /**** @subsection HRTIM_TIMA Register Reset Values ****/

    static const uint32_t HRTIM_TIMA_TIMACR_RST      = 0x00000000U;   /** @brief TIMACR register reset value. */
    static const uint32_t HRTIM_TIMA_TIMAISR_RST     = 0x00000000U;   /** @brief TIMAISR register reset value. */
    static const uint32_t HRTIM_TIMA_TIMAICR_RST     = 0x00000000U;   /** @brief TIMAICR register reset value. */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RST   = 0x00000000U;   /** @brief TIMADIER5 register reset value. */
    static const uint32_t HRTIM_TIMA_CNTAR_RST       = 0x00000000U;   /** @brief CNTAR register reset value. */
    static const uint32_t HRTIM_TIMA_PERAR_RST       = 0x0000FFFFU;   /** @brief PERAR register reset value. */
    static const uint32_t HRTIM_TIMA_REPAR_RST       = 0x00000000U;   /** @brief REPAR register reset value. */
    static const uint32_t HRTIM_TIMA_CMP1CAR_RST     = 0x00000000U;   /** @brief CMP1CAR register reset value. */
    static const uint32_t HRTIM_TIMA_DTAR_RST        = 0x00000000U;   /** @brief DTAR register reset value. */
    static const uint32_t HRTIM_TIMA_EEFAR1_RST      = 0x00000000U;   /** @brief EEFAR1 register reset value. */
    static const uint32_t HRTIM_TIMA_EEFAR2_RST      = 0x00000000U;   /** @brief EEFAR2 register reset value. */
    static const uint32_t HRTIM_TIMA_RSTAR_RST       = 0x00000000U;   /** @brief RSTAR register reset value. */
    static const uint32_t HRTIM_TIMA_CHPAR_RST       = 0x00000000U;   /** @brief CHPAR register reset value. */
    static const uint32_t HRTIM_TIMA_OUTAR_RST       = 0x00000000U;   /** @brief OUTAR register reset value. */
    static const uint32_t HRTIM_TIMA_FLTAR_RST       = 0x00000000U;   /** @brief FLTAR register reset value. */

    /**** @subsection Enumerated HRTIM_TIMA Register Reset Values ****/

    static const uint32_t HRTIM_TIMA_CMPxAR_RST[5] = {
      [1] = 0x00000000U,   /** @brief CMP1AR register reset value. */
      [2] = 0x00000000U,   /** @brief CMP2AR register reset value. */
      [3] = 0x00000000U,   /** @brief CMP3AR register reset value. */
      [4] = 0x00000000U,   /** @brief CMP4AR register reset value. */
    };

    static const uint32_t HRTIM_TIMA_CPTxAR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1AR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2AR register reset value. */
    };

    static const uint32_t HRTIM_TIMA_SETAxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief SETA1R register reset value. */
      [2] = 0x00000000U,   /** @brief SETA2R register reset value. */
    };

    static const uint32_t HRTIM_TIMA_RSTAxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief RSTA1R register reset value. */
      [2] = 0x00000000U,   /** @brief RSTA2R register reset value. */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1ACR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2ACR register reset value. */
    };

    /**** @subsection Enumerated HRTIM_TIMA Register Value Types ****/

    typedef uint32_t HRTIM_TIMA_TIMACR_t;      /** @brief TIMACR register value type. */
    typedef uint32_t HRTIM_TIMA_TIMAISR_t;     /** @brief TIMAISR register value type. */
    typedef uint32_t HRTIM_TIMA_TIMAICR_t;     /** @brief TIMAICR register value type. */
    typedef uint32_t HRTIM_TIMA_TIMADIER5_t;   /** @brief TIMADIER5 register value type. */
    typedef uint32_t HRTIM_TIMA_CNTAR_t;       /** @brief CNTAR register value type. */
    typedef uint32_t HRTIM_TIMA_PERAR_t;       /** @brief PERAR register value type. */
    typedef uint32_t HRTIM_TIMA_REPAR_t;       /** @brief REPAR register value type. */
    typedef uint32_t HRTIM_TIMA_CMPxAR_t;      /** @brief CMPxAR register value type. */
    typedef uint32_t HRTIM_TIMA_CMP1CAR_t;     /** @brief CMP1CAR register value type. */
    typedef uint32_t HRTIM_TIMA_CPTxAR_t;      /** @brief CPTxAR register value type. */
    typedef uint32_t HRTIM_TIMA_DTAR_t;        /** @brief DTAR register value type. */
    typedef uint32_t HRTIM_TIMA_SETAxR_t;      /** @brief SETAxR register value type. */
    typedef uint32_t HRTIM_TIMA_RSTAxR_t;      /** @brief RSTAxR register value type. */
    typedef uint32_t HRTIM_TIMA_EEFAR1_t;      /** @brief EEFAR1 register value type. */
    typedef uint32_t HRTIM_TIMA_EEFAR2_t;      /** @brief EEFAR2 register value type. */
    typedef uint32_t HRTIM_TIMA_RSTAR_t;       /** @brief RSTAR register value type. */
    typedef uint32_t HRTIM_TIMA_CHPAR_t;       /** @brief CHPAR register value type. */
    typedef uint32_t HRTIM_TIMA_CPTxACR_t;     /** @brief CPTxACR register value type. */
    typedef uint32_t HRTIM_TIMA_OUTAR_t;       /** @brief OUTAR register value type. */
    typedef uint32_t HRTIM_TIMA_FLTAR_t;       /** @brief FLTAR register value type. */

    /**** @subsection Enumerated HRTIM_TIMA Register Pointer Types ****/

    typedef uint32_t* const HRTIM_TIMA_TIMACR_PTR_t;      /** @brief TIMACR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_TIMAISR_PTR_t;     /** @brief TIMAISR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_TIMAICR_PTR_t;     /** @brief TIMAICR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_TIMADIER5_PTR_t;   /** @brief TIMADIER5 register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_CNTAR_PTR_t;       /** @brief CNTAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_PERAR_PTR_t;       /** @brief PERAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_REPAR_PTR_t;       /** @brief REPAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_CMPxAR_PTR_t;      /** @brief CMPxAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_CMP1CAR_PTR_t;     /** @brief CMP1CAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_CPTxAR_PTR_t;      /** @brief CPTxAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_DTAR_PTR_t;        /** @brief DTAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_SETAxR_PTR_t;      /** @brief SETAxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_RSTAxR_PTR_t;      /** @brief RSTAxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_EEFAR1_PTR_t;      /** @brief EEFAR1 register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_EEFAR2_PTR_t;      /** @brief EEFAR2 register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_RSTAR_PTR_t;       /** @brief RSTAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_CHPAR_PTR_t;       /** @brief CHPAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_CPTxACR_PTR_t;     /** @brief CPTxACR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_OUTAR_PTR_t;       /** @brief OUTAR register pointer type. */
    typedef uint32_t* const HRTIM_TIMA_FLTAR_PTR_t;       /** @brief FLTAR register pointer type. */

    /**** @subsection HRTIM_TIMA Register Field Masks ****/

    static const uint32_t HRTIM_TIMA_TIMACR_UPDGAT_MASK        = 0xF0000000U;   /** @brief Update gating */
    static const uint32_t HRTIM_TIMA_TIMACR_PREEN_MASK         = 0x08000000U;   /** @brief Preload enable */
    static const uint32_t HRTIM_TIMA_TIMACR_DACSYNC_MASK       = 0x06000000U;   /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMA_TIMACR_MSTU_MASK          = 0x01000000U;   /** @brief Master timer update */
    static const uint32_t HRTIM_TIMA_TIMACR_TEU_MASK           = 0x00800000U;   /** @brief TEU */
    static const uint32_t HRTIM_TIMA_TIMACR_TDU_MASK           = 0x00400000U;   /** @brief TDU */
    static const uint32_t HRTIM_TIMA_TIMACR_TCU_MASK           = 0x00200000U;   /** @brief TCU */
    static const uint32_t HRTIM_TIMA_TIMACR_TBU_MASK           = 0x00100000U;   /** @brief TBU */
    static const uint32_t HRTIM_TIMA_TIMACR_TXRSTU_MASK        = 0x00040000U;   /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMA_TIMACR_TXREPU_MASK        = 0x00020000U;   /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMA_TIMACR_SYNCSTRTX_MASK     = 0x00000800U;   /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMA_TIMACR_SYNCRSTX_MASK      = 0x00000400U;   /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMA_TIMACR_PSHPLL_MASK        = 0x00000040U;   /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMA_TIMACR_HALF_MASK          = 0x00000020U;   /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMA_TIMACR_RETRIG_MASK        = 0x00000010U;   /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMA_TIMACR_CONT_MASK          = 0x00000008U;   /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMA_TIMACR_CK_PSCX_MASK       = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMA_TIMAISR_IPPSTAT_MASK      = 0x00020000U;   /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMA_TIMAISR_CPPSTAT_MASK      = 0x00010000U;   /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMA_TIMAISR_DLYPRT_MASK       = 0x00004000U;   /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_RST_MASK          = 0x00002000U;   /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_UPD_MASK          = 0x00000040U;   /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_REP_MASK          = 0x00000010U;   /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAICR_DLYPRTC_MASK      = 0x00004000U;   /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_RSTC_MASK         = 0x00002000U;   /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_UPDC_MASK         = 0x00000040U;   /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_REPC_MASK         = 0x00000010U;   /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMADIER5_DLYPRTDE_MASK   = 0x40000000U;   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTDE_MASK      = 0x20000000U;   /** @brief RSTDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SETX2DE_MASK    = 0x08000000U;   /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SET1XDE_MASK    = 0x02000000U;   /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_UPDDE_MASK      = 0x00400000U;   /** @brief UPDDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_REPDE_MASK      = 0x00100000U;   /** @brief REPDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_DLYPRTIE_MASK   = 0x00004000U;   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTIE_MASK      = 0x00002000U;   /** @brief RSTIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SETX2IE_MASK    = 0x00000800U;   /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SET1XIE_MASK    = 0x00000200U;   /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_UPDIE_MASK      = 0x00000040U;   /** @brief UPDIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_REPIE_MASK      = 0x00000010U;   /** @brief REPIE */
    static const uint32_t HRTIM_TIMA_CNTAR_CNTX_MASK           = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMA_PERAR_PERX_MASK           = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMA_REPAR_REPX_MASK           = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMA_CMPxAR_CMP1X_MASK         = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMA_CMP1CAR_REPX_MASK         = 0x00FF0000U;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMA_CMP1CAR_CMP1X_MASK        = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMA_CPTxAR_CPT1X_MASK         = 0x0000FFFFU;   /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMA_DTAR_DTFLKX_MASK          = 0x80000000U;   /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMA_DTAR_DTFSLKX_MASK         = 0x40000000U;   /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMA_DTAR_SDTFX_MASK           = 0x02000000U;   /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMA_DTAR_DTFX_MASK            = 0x01FF0000U;   /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMA_DTAR_DTRLKX_MASK          = 0x00008000U;   /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMA_DTAR_DTRSLKX_MASK         = 0x00004000U;   /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMA_DTAR_DTPRSC_MASK          = 0x00001C00U;   /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMA_DTAR_SDTRX_MASK           = 0x00000200U;   /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMA_DTAR_DTRX_MASK            = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMA_SETAxR_UPDATE_MASK        = 0x80000000U;   /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMA_SETAxR_MSTPER_MASK        = 0x00000080U;   /** @brief Master period */
    static const uint32_t HRTIM_TIMA_SETAxR_PER_MASK           = 0x00000004U;   /** @brief Timer A period */
    static const uint32_t HRTIM_TIMA_SETAxR_RESYNC_MASK        = 0x00000002U;   /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMA_SETAxR_SST_MASK           = 0x00000001U;   /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMA_RSTAxR_UPDATE_MASK        = 0x80000000U;   /** @brief UPDATE */
    static const uint32_t HRTIM_TIMA_RSTAxR_MSTPER_MASK        = 0x00000080U;   /** @brief MSTPER */
    static const uint32_t HRTIM_TIMA_RSTAxR_PER_MASK           = 0x00000004U;   /** @brief PER */
    static const uint32_t HRTIM_TIMA_RSTAxR_RESYNC_MASK        = 0x00000002U;   /** @brief RESYNC */
    static const uint32_t HRTIM_TIMA_RSTAxR_SRT_MASK           = 0x00000001U;   /** @brief SRT */
    static const uint32_t HRTIM_TIMA_RSTAR_MSTPER_MASK         = 0x00000010U;   /** @brief Master timer period */
    static const uint32_t HRTIM_TIMA_RSTAR_UPDT_MASK           = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMA_CHPAR_STRTPW_MASK         = 0x00000780U;   /** @brief STRTPW */
    static const uint32_t HRTIM_TIMA_CHPAR_CHPDTY_MASK         = 0x00000070U;   /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMA_CHPAR_CHPFRQ_MASK         = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMA_CPTxACR_TE1RST_MASK       = 0x20000000U;   /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMA_CPTxACR_TE1SET_MASK       = 0x10000000U;   /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMA_CPTxACR_TD1RST_MASK       = 0x02000000U;   /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMA_CPTxACR_TD1SET_MASK       = 0x01000000U;   /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMA_CPTxACR_TC1RST_MASK       = 0x00200000U;   /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMA_CPTxACR_TC1SET_MASK       = 0x00100000U;   /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMA_CPTxACR_TB1RST_MASK       = 0x00020000U;   /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMA_CPTxACR_TB1SET_MASK       = 0x00010000U;   /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMA_CPTxACR_UDPCPT_MASK       = 0x00000002U;   /** @brief Update capture */
    static const uint32_t HRTIM_TIMA_CPTxACR_SWCPT_MASK        = 0x00000001U;   /** @brief Software capture */
    static const uint32_t HRTIM_TIMA_OUTAR_DLYPRT_MASK         = 0x00001C00U;   /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMA_OUTAR_DLYPRTEN_MASK       = 0x00000200U;   /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMA_OUTAR_DTEN_MASK           = 0x00000100U;   /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMA_FLTAR_FLTLCK_MASK         = 0x80000000U;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMA Register Field Masks ****/

    static const uint32_t HRTIM_TIMA_TIMACR_DELCMPx_MASK[5] = {
      [2] = 0x00003000U,   /** @brief Delayed CMP2 mode */
      [4] = 0x0000C000U,   /** @brief Delayed CMP4 mode */
    };

    static const uint32_t HRTIM_TIMA_TIMAISR_OxSTAT_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Output 1 state */
      [2] = 0x00080000U,   /** @brief Output 2 state */
    };

    static const uint32_t HRTIM_TIMA_TIMAISR_RSTXx_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset interrupt flag */
      [2] = 0x00001000U,   /** @brief Output 2 reset interrupt flag */
    };

    static const uint32_t HRTIM_TIMA_TIMAISR_SETXx_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set interrupt flag */
      [2] = 0x00000800U,   /** @brief Output 2 set interrupt flag */
    };

    static const uint32_t HRTIM_TIMA_TIMAISR_CPTx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag */
    };

    static const uint32_t HRTIM_TIMA_TIMAISR_CMPx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMA_TIMAICR_RSTXxC_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset flag clear */
      [2] = 0x00001000U,   /** @brief Output 2 reset flag clear */
    };

    static const uint32_t HRTIM_TIMA_TIMAICR_SETxXC_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set flag clear */
      [2] = 0x00000800U,   /** @brief Output 2 set flag clear */
    };

    static const uint32_t HRTIM_TIMA_TIMAICR_CPTxC_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag clear */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMA_TIMAICR_CMPxC_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTXxDE_MASK[3] = {
      [1] = 0x04000000U,   /** @brief RSTx1DE */
      [2] = 0x10000000U,   /** @brief RSTx2DE */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_CPTxDE_MASK[3] = {
      [1] = 0x00800000U,   /** @brief CPT1DE */
      [2] = 0x01000000U,   /** @brief CPT2DE */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_CMPxDE_MASK[5] = {
      [1] = 0x00010000U,   /** @brief CMP1DE */
      [2] = 0x00020000U,   /** @brief CMP2DE */
      [3] = 0x00040000U,   /** @brief CMP3DE */
      [4] = 0x00080000U,   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTXxIE_MASK[3] = {
      [1] = 0x00000400U,   /** @brief RSTx1IE */
      [2] = 0x00001000U,   /** @brief RSTx2IE */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_CPTxIE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief CPT1IE */
      [2] = 0x00000100U,   /** @brief CPT2IE */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_CMPxIE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [4] = 0x00000008U,   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMA_SETAxR_EXTEVNTx_MASK[11] = {
      [1]  = 0x00200000U,   /** @brief External event 1 */
      [2]  = 0x00400000U,   /** @brief External event 2 */
      [3]  = 0x00800000U,   /** @brief External event 3 */
      [4]  = 0x01000000U,   /** @brief External event 4 */
      [5]  = 0x02000000U,   /** @brief External event 5 */
      [6]  = 0x04000000U,   /** @brief External event 6 */
      [7]  = 0x08000000U,   /** @brief External event 7 */
      [8]  = 0x10000000U,   /** @brief External event 8 */
      [9]  = 0x20000000U,   /** @brief External event 9 */
      [10] = 0x40000000U,   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMA_SETAxR_TIMEVNTx_MASK[10] = {
      [1]  = 0x00001000U,   /** @brief Timer event 1 */
      [2]  = 0x00002000U,   /** @brief Timer event 2 */
      [3]  = 0x00004000U,   /** @brief Timer event 3 */
      [4]  = 0x00008000U,   /** @brief Timer event 4 */
      [5]  = 0x00010000U,   /** @brief Timer event 5 */
      [6]  = 0x00020000U,   /** @brief Timer event 6 */
      [7]  = 0x00040000U,   /** @brief Timer event 7 */
      [8]  = 0x00080000U,   /** @brief Timer event 8 */
      [9]  = 0x00100000U,   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMA_SETAxR_MSTCMPx_MASK[5] = {
      [1] = 0x00000100U,   /** @brief Master compare 1 */
      [2] = 0x00000200U,   /** @brief Master compare 2 */
      [3] = 0x00000400U,   /** @brief Master compare 3 */
      [4] = 0x00000800U,   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMA_EEFAR1_EExFLTR_MASK[6] = {
      [1] = 0x0000001EU,   /** @brief External event 1 filter */
      [2] = 0x00000780U,   /** @brief External event 2 filter */
      [3] = 0x0001E000U,   /** @brief External event 3 filter */
      [4] = 0x00780000U,   /** @brief External event 4 filter */
      [5] = 0x1E000000U,   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMA_EEFAR1_EExLTCH_MASK[6] = {
      [1] = 0x00000001U,   /** @brief External event 1 latch */
      [2] = 0x00000040U,   /** @brief External event 2 latch */
      [3] = 0x00001000U,   /** @brief External event 3 latch */
      [4] = 0x00040000U,   /** @brief External event 4 latch */
      [5] = 0x01000000U,   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMECMPx_MASK[5] = {
      [1] = 0x10000000U,   /** @brief Timer E compare 1 */
      [2] = 0x20000000U,   /** @brief Timer E compare 2 */
      [4] = 0x40000000U,   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMDCMPx_MASK[5] = {
      [1] = 0x02000000U,   /** @brief Timer D compare 1 */
      [2] = 0x04000000U,   /** @brief Timer D compare 2 */
      [4] = 0x08000000U,   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMCCMPx_MASK[5] = {
      [1] = 0x00400000U,   /** @brief Timer C compare 1 */
      [2] = 0x00800000U,   /** @brief Timer C compare 2 */
      [4] = 0x01000000U,   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMBCMPx_MASK[5] = {
      [1] = 0x00080000U,   /** @brief Timer B compare 1 */
      [2] = 0x00100000U,   /** @brief Timer B compare 2 */
      [4] = 0x00200000U,   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_TECMPx_MASK[3] = {
      [1] = 0x40000000U,   /** @brief Timer E compare 1 */
      [2] = 0x80000000U,   /** @brief Timer E compare 2 */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_TDCMPx_MASK[3] = {
      [1] = 0x04000000U,   /** @brief Timer D compare 1 */
      [2] = 0x08000000U,   /** @brief Timer D compare 2 */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_TCCMPx_MASK[3] = {
      [1] = 0x00400000U,   /** @brief Timer C compare 1 */
      [2] = 0x00800000U,   /** @brief Timer C compare 2 */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_TBCMPx_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Timer B compare 1 */
      [2] = 0x00080000U,   /** @brief Timer B compare 2 */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_EXEVxCPT_MASK[11] = {
      [1]  = 0x00000004U,   /** @brief External event 1 capture */
      [2]  = 0x00000008U,   /** @brief External event 2 capture */
      [3]  = 0x00000010U,   /** @brief External event 3 capture */
      [4]  = 0x00000020U,   /** @brief External event 4 capture */
      [5]  = 0x00000040U,   /** @brief External event 5 capture */
      [6]  = 0x00000080U,   /** @brief External event 6 capture */
      [7]  = 0x00000100U,   /** @brief External event 7 capture */
      [8]  = 0x00000200U,   /** @brief External event 8 capture */
      [9]  = 0x00000400U,   /** @brief External event 9 capture */
      [10] = 0x00000800U,   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMA_OUTAR_DIDLx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 0x00800000U,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const uint32_t HRTIM_TIMA_OUTAR_CHPx_MASK[3] = {
      [1] = 0x00000040U,   /** @brief Output 1 chopper enable */
      [2] = 0x00400000U,   /** @brief Output 2 chopper enable */
    };

    static const uint32_t HRTIM_TIMA_OUTAR_FAULTx_MASK[3] = {
      [1] = 0x00000030U,   /** @brief Output 1 fault state */
      [2] = 0x00300000U,   /** @brief Output 2 fault state */
    };

    static const uint32_t HRTIM_TIMA_OUTAR_IDLESx_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output 1 idle state */
      [2] = 0x00080000U,   /** @brief Output 2 idle state */
    };

    static const uint32_t HRTIM_TIMA_OUTAR_IDLEMx_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output 1 idle mode */
      [2] = 0x00040000U,   /** @brief Output 2 idle mode */
    };

    static const uint32_t HRTIM_TIMA_OUTAR_POLx_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Output 1 polarity */
      [2] = 0x00020000U,   /** @brief Output 2 polarity */
    };

    static const uint32_t HRTIM_TIMA_FLTAR_FLTxEN_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [5] = 0x00000010U,   /** @brief Fault 5 enable */
    };

    /**** @subsection HRTIM_TIMA Register Field Positions ****/

    static const int32_t HRTIM_TIMA_TIMACR_UPDGAT_POS        = 28;   /** @brief Update gating */
    static const int32_t HRTIM_TIMA_TIMACR_PREEN_POS         = 27;   /** @brief Preload enable */
    static const int32_t HRTIM_TIMA_TIMACR_DACSYNC_POS       = 25;   /** @brief AC synchronization */
    static const int32_t HRTIM_TIMA_TIMACR_MSTU_POS          = 24;   /** @brief Master timer update */
    static const int32_t HRTIM_TIMA_TIMACR_TEU_POS           = 23;   /** @brief TEU */
    static const int32_t HRTIM_TIMA_TIMACR_TDU_POS           = 22;   /** @brief TDU */
    static const int32_t HRTIM_TIMA_TIMACR_TCU_POS           = 21;   /** @brief TCU */
    static const int32_t HRTIM_TIMA_TIMACR_TBU_POS           = 20;   /** @brief TBU */
    static const int32_t HRTIM_TIMA_TIMACR_TXRSTU_POS        = 18;   /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMA_TIMACR_TXREPU_POS        = 17;   /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMA_TIMACR_SYNCSTRTX_POS     = 11;   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMA_TIMACR_SYNCRSTX_POS      = 10;   /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMA_TIMACR_PSHPLL_POS        = 6;    /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMA_TIMACR_HALF_POS          = 5;    /** @brief Half mode enable */
    static const int32_t HRTIM_TIMA_TIMACR_RETRIG_POS        = 4;    /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMA_TIMACR_CONT_POS          = 3;    /** @brief Continuous mode */
    static const int32_t HRTIM_TIMA_TIMACR_CK_PSCX_POS       = 0;    /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMA_TIMAISR_IPPSTAT_POS      = 17;   /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMA_TIMAISR_CPPSTAT_POS      = 16;   /** @brief Current push pull status */
    static const int32_t HRTIM_TIMA_TIMAISR_DLYPRT_POS       = 14;   /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMA_TIMAISR_RST_POS          = 13;   /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMA_TIMAISR_UPD_POS          = 6;    /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMA_TIMAISR_REP_POS          = 4;    /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMA_TIMAICR_DLYPRTC_POS      = 14;   /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMA_TIMAICR_RSTC_POS         = 13;   /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMA_TIMAICR_UPDC_POS         = 6;    /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMA_TIMAICR_REPC_POS         = 4;    /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMA_TIMADIER5_DLYPRTDE_POS   = 30;   /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMA_TIMADIER5_RSTDE_POS      = 29;   /** @brief RSTDE */
    static const int32_t HRTIM_TIMA_TIMADIER5_SETX2DE_POS    = 27;   /** @brief SETx2DE */
    static const int32_t HRTIM_TIMA_TIMADIER5_SET1XDE_POS    = 25;   /** @brief SET1xDE */
    static const int32_t HRTIM_TIMA_TIMADIER5_UPDDE_POS      = 22;   /** @brief UPDDE */
    static const int32_t HRTIM_TIMA_TIMADIER5_REPDE_POS      = 20;   /** @brief REPDE */
    static const int32_t HRTIM_TIMA_TIMADIER5_DLYPRTIE_POS   = 14;   /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMA_TIMADIER5_RSTIE_POS      = 13;   /** @brief RSTIE */
    static const int32_t HRTIM_TIMA_TIMADIER5_SETX2IE_POS    = 11;   /** @brief SETx2IE */
    static const int32_t HRTIM_TIMA_TIMADIER5_SET1XIE_POS    = 9;    /** @brief SET1xIE */
    static const int32_t HRTIM_TIMA_TIMADIER5_UPDIE_POS      = 6;    /** @brief UPDIE */
    static const int32_t HRTIM_TIMA_TIMADIER5_REPIE_POS      = 4;    /** @brief REPIE */
    static const int32_t HRTIM_TIMA_CNTAR_CNTX_POS           = 0;    /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMA_PERAR_PERX_POS           = 0;    /** @brief Timerx period value */
    static const int32_t HRTIM_TIMA_REPAR_REPX_POS           = 0;    /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMA_CMPxAR_CMP1X_POS         = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMA_CMP1CAR_REPX_POS         = 16;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMA_CMP1CAR_CMP1X_POS        = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMA_CPTxAR_CPT1X_POS         = 0;    /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMA_DTAR_DTFLKX_POS          = 31;   /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMA_DTAR_DTFSLKX_POS         = 30;   /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMA_DTAR_SDTFX_POS           = 25;   /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMA_DTAR_DTFX_POS            = 16;   /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMA_DTAR_DTRLKX_POS          = 15;   /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMA_DTAR_DTRSLKX_POS         = 14;   /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMA_DTAR_DTPRSC_POS          = 10;   /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMA_DTAR_SDTRX_POS           = 9;    /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMA_DTAR_DTRX_POS            = 0;    /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMA_SETAxR_UPDATE_POS        = 31;   /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMA_SETAxR_MSTPER_POS        = 7;    /** @brief Master period */
    static const int32_t HRTIM_TIMA_SETAxR_PER_POS           = 2;    /** @brief Timer A period */
    static const int32_t HRTIM_TIMA_SETAxR_RESYNC_POS        = 1;    /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMA_SETAxR_SST_POS           = 0;    /** @brief Software set trigger */
    static const int32_t HRTIM_TIMA_RSTAxR_UPDATE_POS        = 31;   /** @brief UPDATE */
    static const int32_t HRTIM_TIMA_RSTAxR_MSTPER_POS        = 7;    /** @brief MSTPER */
    static const int32_t HRTIM_TIMA_RSTAxR_PER_POS           = 2;    /** @brief PER */
    static const int32_t HRTIM_TIMA_RSTAxR_RESYNC_POS        = 1;    /** @brief RESYNC */
    static const int32_t HRTIM_TIMA_RSTAxR_SRT_POS           = 0;    /** @brief SRT */
    static const int32_t HRTIM_TIMA_RSTAR_MSTPER_POS         = 4;    /** @brief Master timer period */
    static const int32_t HRTIM_TIMA_RSTAR_UPDT_POS           = 1;    /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMA_CHPAR_STRTPW_POS         = 7;    /** @brief STRTPW */
    static const int32_t HRTIM_TIMA_CHPAR_CHPDTY_POS         = 4;    /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMA_CHPAR_CHPFRQ_POS         = 0;    /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMA_CPTxACR_TE1RST_POS       = 29;   /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMA_CPTxACR_TE1SET_POS       = 28;   /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMA_CPTxACR_TD1RST_POS       = 25;   /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMA_CPTxACR_TD1SET_POS       = 24;   /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMA_CPTxACR_TC1RST_POS       = 21;   /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMA_CPTxACR_TC1SET_POS       = 20;   /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMA_CPTxACR_TB1RST_POS       = 17;   /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMA_CPTxACR_TB1SET_POS       = 16;   /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMA_CPTxACR_UDPCPT_POS       = 1;    /** @brief Update capture */
    static const int32_t HRTIM_TIMA_CPTxACR_SWCPT_POS        = 0;    /** @brief Software capture */
    static const int32_t HRTIM_TIMA_OUTAR_DLYPRT_POS         = 10;   /** @brief Delayed protection */
    static const int32_t HRTIM_TIMA_OUTAR_DLYPRTEN_POS       = 9;    /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMA_OUTAR_DTEN_POS           = 8;    /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMA_FLTAR_FLTLCK_POS         = 31;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMA Register Field Positions ****/

    static const int32_t HRTIM_TIMA_TIMACR_DELCMPx_POS[5] = {
      [2] = 12,   /** @brief Delayed CMP2 mode */
      [4] = 14,   /** @brief Delayed CMP4 mode */
    };

    static const int32_t HRTIM_TIMA_TIMAISR_OxSTAT_POS[3] = {
      [1] = 18,   /** @brief Output 1 state */
      [2] = 19,   /** @brief Output 2 state */
    };

    static const int32_t HRTIM_TIMA_TIMAISR_RSTXx_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset interrupt flag */
      [2] = 12,   /** @brief Output 2 reset interrupt flag */
    };

    static const int32_t HRTIM_TIMA_TIMAISR_SETXx_POS[3] = {
      [1] = 9,    /** @brief Output 1 set interrupt flag */
      [2] = 11,   /** @brief Output 2 set interrupt flag */
    };

    static const int32_t HRTIM_TIMA_TIMAISR_CPTx_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag */
      [2] = 8,   /** @brief Capture2 interrupt flag */
    };

    static const int32_t HRTIM_TIMA_TIMAISR_CMPx_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag */
      [2] = 1,   /** @brief Compare 2 interrupt flag */
      [3] = 2,   /** @brief Compare 3 interrupt flag */
      [4] = 3,   /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMA_TIMAICR_RSTXxC_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset flag clear */
      [2] = 12,   /** @brief Output 2 reset flag clear */
    };

    static const int32_t HRTIM_TIMA_TIMAICR_SETxXC_POS[3] = {
      [1] = 9,    /** @brief Output 1 set flag clear */
      [2] = 11,   /** @brief Output 2 set flag clear */
    };

    static const int32_t HRTIM_TIMA_TIMAICR_CPTxC_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag clear */
      [2] = 8,   /** @brief Capture2 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMA_TIMAICR_CMPxC_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag clear */
      [2] = 1,   /** @brief Compare 2 interrupt flag clear */
      [3] = 2,   /** @brief Compare 3 interrupt flag clear */
      [4] = 3,   /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMA_TIMADIER5_RSTXxDE_POS[3] = {
      [1] = 26,   /** @brief RSTx1DE */
      [2] = 28,   /** @brief RSTx2DE */
    };

    static const int32_t HRTIM_TIMA_TIMADIER5_CPTxDE_POS[3] = {
      [1] = 23,   /** @brief CPT1DE */
      [2] = 24,   /** @brief CPT2DE */
    };

    static const int32_t HRTIM_TIMA_TIMADIER5_CMPxDE_POS[5] = {
      [1] = 16,   /** @brief CMP1DE */
      [2] = 17,   /** @brief CMP2DE */
      [3] = 18,   /** @brief CMP3DE */
      [4] = 19,   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMA_TIMADIER5_RSTXxIE_POS[3] = {
      [1] = 10,   /** @brief RSTx1IE */
      [2] = 12,   /** @brief RSTx2IE */
    };

    static const int32_t HRTIM_TIMA_TIMADIER5_CPTxIE_POS[3] = {
      [1] = 7,   /** @brief CPT1IE */
      [2] = 8,   /** @brief CPT2IE */
    };

    static const int32_t HRTIM_TIMA_TIMADIER5_CMPxIE_POS[5] = {
      [1] = 0,   /** @brief CMP1IE */
      [2] = 1,   /** @brief CMP2IE */
      [3] = 2,   /** @brief CMP3IE */
      [4] = 3,   /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMA_SETAxR_EXTEVNTx_POS[11] = {
      [1]  = 21,   /** @brief External event 1 */
      [2]  = 22,   /** @brief External event 2 */
      [3]  = 23,   /** @brief External event 3 */
      [4]  = 24,   /** @brief External event 4 */
      [5]  = 25,   /** @brief External event 5 */
      [6]  = 26,   /** @brief External event 6 */
      [7]  = 27,   /** @brief External event 7 */
      [8]  = 28,   /** @brief External event 8 */
      [9]  = 29,   /** @brief External event 9 */
      [10] = 30,   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMA_SETAxR_TIMEVNTx_POS[10] = {
      [1]  = 12,   /** @brief Timer event 1 */
      [2]  = 13,   /** @brief Timer event 2 */
      [3]  = 14,   /** @brief Timer event 3 */
      [4]  = 15,   /** @brief Timer event 4 */
      [5]  = 16,   /** @brief Timer event 5 */
      [6]  = 17,   /** @brief Timer event 6 */
      [7]  = 18,   /** @brief Timer event 7 */
      [8]  = 19,   /** @brief Timer event 8 */
      [9]  = 20,   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMA_SETAxR_MSTCMPx_POS[5] = {
      [1] = 8,    /** @brief Master compare 1 */
      [2] = 9,    /** @brief Master compare 2 */
      [3] = 10,   /** @brief Master compare 3 */
      [4] = 11,   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMA_EEFAR1_EExFLTR_POS[6] = {
      [1] = 1,    /** @brief External event 1 filter */
      [2] = 7,    /** @brief External event 2 filter */
      [3] = 13,   /** @brief External event 3 filter */
      [4] = 19,   /** @brief External event 4 filter */
      [5] = 25,   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMA_EEFAR1_EExLTCH_POS[6] = {
      [1] = 0,    /** @brief External event 1 latch */
      [2] = 6,    /** @brief External event 2 latch */
      [3] = 12,   /** @brief External event 3 latch */
      [4] = 18,   /** @brief External event 4 latch */
      [5] = 24,   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMA_RSTAR_TIMECMPx_POS[5] = {
      [1] = 28,   /** @brief Timer E compare 1 */
      [2] = 29,   /** @brief Timer E compare 2 */
      [4] = 30,   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMA_RSTAR_TIMDCMPx_POS[5] = {
      [1] = 25,   /** @brief Timer D compare 1 */
      [2] = 26,   /** @brief Timer D compare 2 */
      [4] = 27,   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIMA_RSTAR_TIMCCMPx_POS[5] = {
      [1] = 22,   /** @brief Timer C compare 1 */
      [2] = 23,   /** @brief Timer C compare 2 */
      [4] = 24,   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIMA_RSTAR_TIMBCMPx_POS[5] = {
      [1] = 19,   /** @brief Timer B compare 1 */
      [2] = 20,   /** @brief Timer B compare 2 */
      [4] = 21,   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIMA_CPTxACR_TECMPx_POS[3] = {
      [1] = 30,   /** @brief Timer E compare 1 */
      [2] = 31,   /** @brief Timer E compare 2 */
    };

    static const int32_t HRTIM_TIMA_CPTxACR_TDCMPx_POS[3] = {
      [1] = 26,   /** @brief Timer D compare 1 */
      [2] = 27,   /** @brief Timer D compare 2 */
    };

    static const int32_t HRTIM_TIMA_CPTxACR_TCCMPx_POS[3] = {
      [1] = 22,   /** @brief Timer C compare 1 */
      [2] = 23,   /** @brief Timer C compare 2 */
    };

    static const int32_t HRTIM_TIMA_CPTxACR_TBCMPx_POS[3] = {
      [1] = 18,   /** @brief Timer B compare 1 */
      [2] = 19,   /** @brief Timer B compare 2 */
    };

    static const int32_t HRTIM_TIMA_CPTxACR_EXEVxCPT_POS[11] = {
      [1]  = 2,    /** @brief External event 1 capture */
      [2]  = 3,    /** @brief External event 2 capture */
      [3]  = 4,    /** @brief External event 3 capture */
      [4]  = 5,    /** @brief External event 4 capture */
      [5]  = 6,    /** @brief External event 5 capture */
      [6]  = 7,    /** @brief External event 6 capture */
      [7]  = 8,    /** @brief External event 7 capture */
      [8]  = 9,    /** @brief External event 8 capture */
      [9]  = 10,   /** @brief External event 9 capture */
      [10] = 11,   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMA_OUTAR_DIDLx_POS[3] = {
      [1] = 7,    /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 23,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const int32_t HRTIM_TIMA_OUTAR_CHPx_POS[3] = {
      [1] = 6,    /** @brief Output 1 chopper enable */
      [2] = 22,   /** @brief Output 2 chopper enable */
    };

    static const int32_t HRTIM_TIMA_OUTAR_FAULTx_POS[3] = {
      [1] = 4,    /** @brief Output 1 fault state */
      [2] = 20,   /** @brief Output 2 fault state */
    };

    static const int32_t HRTIM_TIMA_OUTAR_IDLESx_POS[3] = {
      [1] = 3,    /** @brief Output 1 idle state */
      [2] = 19,   /** @brief Output 2 idle state */
    };

    static const int32_t HRTIM_TIMA_OUTAR_IDLEMx_POS[3] = {
      [1] = 2,    /** @brief Output 1 idle mode */
      [2] = 18,   /** @brief Output 2 idle mode */
    };

    static const int32_t HRTIM_TIMA_OUTAR_POLx_POS[3] = {
      [1] = 1,    /** @brief Output 1 polarity */
      [2] = 17,   /** @brief Output 2 polarity */
    };

    static const int32_t HRTIM_TIMA_FLTAR_FLTxEN_POS[6] = {
      [1] = 0,   /** @brief Fault 1 enable */
      [2] = 1,   /** @brief Fault 2 enable */
      [3] = 2,   /** @brief Fault 3 enable */
      [4] = 3,   /** @brief Fault 4 enable */
      [5] = 4,   /** @brief Fault 5 enable */
    };

    /**********************************************************************************************
     * @section HRTIM_TIMB Register Information
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMB Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMB_TIMBCR_PTR      = (RW_ uint32_t* const)0x40017500U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMB_TIMBISR_PTR     = (RO_ uint32_t* const)0x40017504U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMB_TIMBICR_PTR     = (RW_ uint32_t* const)0x40017508U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMB_TIMBDIER5_PTR   = (RW_ uint32_t* const)0x4001750CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMB_CNTR_PTR        = (RW_ uint32_t* const)0x40017510U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMB_PERBR_PTR       = (RW_ uint32_t* const)0x40017514U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMB_REPBR_PTR       = (RW_ uint32_t* const)0x40017518U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMB_CMP1CBR_PTR     = (RW_ uint32_t* const)0x40017520U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMB_DTBR_PTR        = (RW_ uint32_t* const)0x40017538U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMB_EEFBR1_PTR      = (RW_ uint32_t* const)0x4001754CU;   /** @brief Timerx external event filtering register 1 */
    static RW_ uint32_t* const HRTIM_TIMB_EEFBR2_PTR      = (RW_ uint32_t* const)0x40017550U;   /** @brief Timerx external event filtering register 2 */
    static RW_ uint32_t* const HRTIM_TIMB_RSTBR_PTR       = (RW_ uint32_t* const)0x40017554U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMB_CHPBR_PTR       = (RW_ uint32_t* const)0x40017558U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMB_OUTBR_PTR       = (RW_ uint32_t* const)0x40017564U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMB_FLTBR_PTR       = (RW_ uint32_t* const)0x40017568U;   /** @brief Timerx fault register */

    /**** @subsection Enumerated HRTIM_TIMB Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMB_CMPxBR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001751CU,   /** @brief Timerx compare 1 register */
      [2] = (RW_ uint32_t* const)0x40017524U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t* const)0x40017528U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t* const)0x4001752CU,   /** @brief Timerx compare 4 register */
    };

    static RO_ uint32_t* const HRTIM_TIMB_CPTxBR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x40017530U,   /** @brief Timerx capture 1 register */
      [2] = (RO_ uint32_t* const)0x40017534U,   /** @brief Timerx capture 2 register */
    };

    static RW_ uint32_t* const HRTIM_TIMB_SETBxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4001753CU,   /** @brief Timerx output1 set register */
      [2] = (RW_ uint32_t* const)0x40017544U,   /** @brief Timerx output2 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMB_RSTBxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40017540U,   /** @brief Timerx output1 reset register */
      [2] = (RW_ uint32_t* const)0x40017548U,   /** @brief Timerx output2 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMB_CPTxBCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4001755CU,   /** @brief Timerx capture 2 control register */
      [2] = (RW_ uint32_t* const)0x40017560U,   /** @brief CPT2xCR */
    };

    /**** @subsection HRTIM_TIMB Register Reset Values ****/

    static const uint32_t HRTIM_TIMB_TIMBCR_RST      = 0x00000000U;   /** @brief TIMBCR register reset value. */
    static const uint32_t HRTIM_TIMB_TIMBISR_RST     = 0x00000000U;   /** @brief TIMBISR register reset value. */
    static const uint32_t HRTIM_TIMB_TIMBICR_RST     = 0x00000000U;   /** @brief TIMBICR register reset value. */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RST   = 0x00000000U;   /** @brief TIMBDIER5 register reset value. */
    static const uint32_t HRTIM_TIMB_CNTR_RST        = 0x00000000U;   /** @brief CNTR register reset value. */
    static const uint32_t HRTIM_TIMB_PERBR_RST       = 0x0000FFFFU;   /** @brief PERBR register reset value. */
    static const uint32_t HRTIM_TIMB_REPBR_RST       = 0x00000000U;   /** @brief REPBR register reset value. */
    static const uint32_t HRTIM_TIMB_CMP1CBR_RST     = 0x00000000U;   /** @brief CMP1CBR register reset value. */
    static const uint32_t HRTIM_TIMB_DTBR_RST        = 0x00000000U;   /** @brief DTBR register reset value. */
    static const uint32_t HRTIM_TIMB_EEFBR1_RST      = 0x00000000U;   /** @brief EEFBR1 register reset value. */
    static const uint32_t HRTIM_TIMB_EEFBR2_RST      = 0x00000000U;   /** @brief EEFBR2 register reset value. */
    static const uint32_t HRTIM_TIMB_RSTBR_RST       = 0x00000000U;   /** @brief RSTBR register reset value. */
    static const uint32_t HRTIM_TIMB_CHPBR_RST       = 0x00000000U;   /** @brief CHPBR register reset value. */
    static const uint32_t HRTIM_TIMB_OUTBR_RST       = 0x00000000U;   /** @brief OUTBR register reset value. */
    static const uint32_t HRTIM_TIMB_FLTBR_RST       = 0x00000000U;   /** @brief FLTBR register reset value. */

    /**** @subsection Enumerated HRTIM_TIMB Register Reset Values ****/

    static const uint32_t HRTIM_TIMB_CMPxBR_RST[5] = {
      [1] = 0x00000000U,   /** @brief CMP1BR register reset value. */
      [2] = 0x00000000U,   /** @brief CMP2BR register reset value. */
      [3] = 0x00000000U,   /** @brief CMP3BR register reset value. */
      [4] = 0x00000000U,   /** @brief CMP4BR register reset value. */
    };

    static const uint32_t HRTIM_TIMB_CPTxBR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1BR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2BR register reset value. */
    };

    static const uint32_t HRTIM_TIMB_SETBxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief SETB1R register reset value. */
      [2] = 0x00000000U,   /** @brief SETB2R register reset value. */
    };

    static const uint32_t HRTIM_TIMB_RSTBxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief RSTB1R register reset value. */
      [2] = 0x00000000U,   /** @brief RSTB2R register reset value. */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1BCR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2BCR register reset value. */
    };

    /**** @subsection Enumerated HRTIM_TIMB Register Value Types ****/

    typedef uint32_t HRTIM_TIMB_TIMBCR_t;      /** @brief TIMBCR register value type. */
    typedef uint32_t HRTIM_TIMB_TIMBISR_t;     /** @brief TIMBISR register value type. */
    typedef uint32_t HRTIM_TIMB_TIMBICR_t;     /** @brief TIMBICR register value type. */
    typedef uint32_t HRTIM_TIMB_TIMBDIER5_t;   /** @brief TIMBDIER5 register value type. */
    typedef uint32_t HRTIM_TIMB_CNTR_t;        /** @brief CNTR register value type. */
    typedef uint32_t HRTIM_TIMB_PERBR_t;       /** @brief PERBR register value type. */
    typedef uint32_t HRTIM_TIMB_REPBR_t;       /** @brief REPBR register value type. */
    typedef uint32_t HRTIM_TIMB_CMPxBR_t;      /** @brief CMPxBR register value type. */
    typedef uint32_t HRTIM_TIMB_CMP1CBR_t;     /** @brief CMP1CBR register value type. */
    typedef uint32_t HRTIM_TIMB_CPTxBR_t;      /** @brief CPTxBR register value type. */
    typedef uint32_t HRTIM_TIMB_DTBR_t;        /** @brief DTBR register value type. */
    typedef uint32_t HRTIM_TIMB_SETBxR_t;      /** @brief SETBxR register value type. */
    typedef uint32_t HRTIM_TIMB_RSTBxR_t;      /** @brief RSTBxR register value type. */
    typedef uint32_t HRTIM_TIMB_EEFBR1_t;      /** @brief EEFBR1 register value type. */
    typedef uint32_t HRTIM_TIMB_EEFBR2_t;      /** @brief EEFBR2 register value type. */
    typedef uint32_t HRTIM_TIMB_RSTBR_t;       /** @brief RSTBR register value type. */
    typedef uint32_t HRTIM_TIMB_CHPBR_t;       /** @brief CHPBR register value type. */
    typedef uint32_t HRTIM_TIMB_CPTxBCR_t;     /** @brief CPTxBCR register value type. */
    typedef uint32_t HRTIM_TIMB_OUTBR_t;       /** @brief OUTBR register value type. */
    typedef uint32_t HRTIM_TIMB_FLTBR_t;       /** @brief FLTBR register value type. */

    /**** @subsection Enumerated HRTIM_TIMB Register Pointer Types ****/

    typedef uint32_t* const HRTIM_TIMB_TIMBCR_PTR_t;      /** @brief TIMBCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_TIMBISR_PTR_t;     /** @brief TIMBISR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_TIMBICR_PTR_t;     /** @brief TIMBICR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_TIMBDIER5_PTR_t;   /** @brief TIMBDIER5 register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_CNTR_PTR_t;        /** @brief CNTR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_PERBR_PTR_t;       /** @brief PERBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_REPBR_PTR_t;       /** @brief REPBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_CMPxBR_PTR_t;      /** @brief CMPxBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_CMP1CBR_PTR_t;     /** @brief CMP1CBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_CPTxBR_PTR_t;      /** @brief CPTxBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_DTBR_PTR_t;        /** @brief DTBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_SETBxR_PTR_t;      /** @brief SETBxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_RSTBxR_PTR_t;      /** @brief RSTBxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_EEFBR1_PTR_t;      /** @brief EEFBR1 register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_EEFBR2_PTR_t;      /** @brief EEFBR2 register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_RSTBR_PTR_t;       /** @brief RSTBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_CHPBR_PTR_t;       /** @brief CHPBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_CPTxBCR_PTR_t;     /** @brief CPTxBCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_OUTBR_PTR_t;       /** @brief OUTBR register pointer type. */
    typedef uint32_t* const HRTIM_TIMB_FLTBR_PTR_t;       /** @brief FLTBR register pointer type. */

    /**** @subsection HRTIM_TIMB Register Field Masks ****/

    static const uint32_t HRTIM_TIMB_TIMBCR_UPDGAT_MASK        = 0xF0000000U;   /** @brief Update gating */
    static const uint32_t HRTIM_TIMB_TIMBCR_PREEN_MASK         = 0x08000000U;   /** @brief Preload enable */
    static const uint32_t HRTIM_TIMB_TIMBCR_DACSYNC_MASK       = 0x06000000U;   /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMB_TIMBCR_MSTU_MASK          = 0x01000000U;   /** @brief Master timer update */
    static const uint32_t HRTIM_TIMB_TIMBCR_TEU_MASK           = 0x00800000U;   /** @brief TEU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TDU_MASK           = 0x00400000U;   /** @brief TDU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TCU_MASK           = 0x00200000U;   /** @brief TCU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TBU_MASK           = 0x00100000U;   /** @brief TBU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TXRSTU_MASK        = 0x00040000U;   /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMB_TIMBCR_TXREPU_MASK        = 0x00020000U;   /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMB_TIMBCR_SYNCSTRTX_MASK     = 0x00000800U;   /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMB_TIMBCR_SYNCRSTX_MASK      = 0x00000400U;   /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMB_TIMBCR_PSHPLL_MASK        = 0x00000040U;   /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMB_TIMBCR_HALF_MASK          = 0x00000020U;   /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMB_TIMBCR_RETRIG_MASK        = 0x00000010U;   /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMB_TIMBCR_CONT_MASK          = 0x00000008U;   /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMB_TIMBCR_CK_PSCX_MASK       = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMB_TIMBISR_IPPSTAT_MASK      = 0x00020000U;   /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMB_TIMBISR_CPPSTAT_MASK      = 0x00010000U;   /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMB_TIMBISR_DLYPRT_MASK       = 0x00004000U;   /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_RST_MASK          = 0x00002000U;   /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_UPD_MASK          = 0x00000040U;   /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_REP_MASK          = 0x00000010U;   /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBICR_DLYPRTC_MASK      = 0x00004000U;   /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_RSTC_MASK         = 0x00002000U;   /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_UPDC_MASK         = 0x00000040U;   /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_REPC_MASK         = 0x00000010U;   /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_DLYPRTDE_MASK   = 0x40000000U;   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTDE_MASK      = 0x20000000U;   /** @brief RSTDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SETX2DE_MASK    = 0x08000000U;   /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SET1XDE_MASK    = 0x02000000U;   /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_UPDDE_MASK      = 0x00400000U;   /** @brief UPDDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_REPDE_MASK      = 0x00100000U;   /** @brief REPDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_DLYPRTIE_MASK   = 0x00004000U;   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTIE_MASK      = 0x00002000U;   /** @brief RSTIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SETX2IE_MASK    = 0x00000800U;   /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SET1XIE_MASK    = 0x00000200U;   /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_UPDIE_MASK      = 0x00000040U;   /** @brief UPDIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_REPIE_MASK      = 0x00000010U;   /** @brief REPIE */
    static const uint32_t HRTIM_TIMB_CNTR_CNTX_MASK            = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMB_PERBR_PERX_MASK           = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMB_REPBR_REPX_MASK           = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMB_CMPxBR_CMP1X_MASK         = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMB_CMP1CBR_REPX_MASK         = 0x00FF0000U;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMB_CMP1CBR_CMP1X_MASK        = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMB_CPTxBR_CPT1X_MASK         = 0x0000FFFFU;   /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMB_DTBR_DTFLKX_MASK          = 0x80000000U;   /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMB_DTBR_DTFSLKX_MASK         = 0x40000000U;   /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMB_DTBR_SDTFX_MASK           = 0x02000000U;   /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMB_DTBR_DTFX_MASK            = 0x01FF0000U;   /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMB_DTBR_DTRLKX_MASK          = 0x00008000U;   /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMB_DTBR_DTRSLKX_MASK         = 0x00004000U;   /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMB_DTBR_DTPRSC_MASK          = 0x00001C00U;   /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMB_DTBR_SDTRX_MASK           = 0x00000200U;   /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMB_DTBR_DTRX_MASK            = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMB_SETBxR_UPDATE_MASK        = 0x80000000U;   /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMB_SETBxR_MSTPER_MASK        = 0x00000080U;   /** @brief Master period */
    static const uint32_t HRTIM_TIMB_SETBxR_PER_MASK           = 0x00000004U;   /** @brief Timer A period */
    static const uint32_t HRTIM_TIMB_SETBxR_RESYNC_MASK        = 0x00000002U;   /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMB_SETBxR_SST_MASK           = 0x00000001U;   /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMB_RSTBxR_UPDATE_MASK        = 0x80000000U;   /** @brief UPDATE */
    static const uint32_t HRTIM_TIMB_RSTBxR_MSTPER_MASK        = 0x00000080U;   /** @brief MSTPER */
    static const uint32_t HRTIM_TIMB_RSTBxR_PER_MASK           = 0x00000004U;   /** @brief PER */
    static const uint32_t HRTIM_TIMB_RSTBxR_RESYNC_MASK        = 0x00000002U;   /** @brief RESYNC */
    static const uint32_t HRTIM_TIMB_RSTBxR_SRT_MASK           = 0x00000001U;   /** @brief SRT */
    static const uint32_t HRTIM_TIMB_RSTBR_MSTPER_MASK         = 0x00000010U;   /** @brief Master timer period */
    static const uint32_t HRTIM_TIMB_RSTBR_UPDT_MASK           = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMB_CHPBR_STRTPW_MASK         = 0x00000780U;   /** @brief STRTPW */
    static const uint32_t HRTIM_TIMB_CHPBR_CHPDTY_MASK         = 0x00000070U;   /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMB_CHPBR_CHPFRQ_MASK         = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TE1RST_MASK       = 0x20000000U;   /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TE1SET_MASK       = 0x10000000U;   /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TD1RST_MASK       = 0x02000000U;   /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TD1SET_MASK       = 0x01000000U;   /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TC1RST_MASK       = 0x00200000U;   /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TC1SET_MASK       = 0x00100000U;   /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TA1RST_MASK       = 0x00002000U;   /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMB_CPTxBCR_TA1SET_MASK       = 0x00001000U;   /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMB_CPTxBCR_UDPCPT_MASK       = 0x00000002U;   /** @brief Update capture */
    static const uint32_t HRTIM_TIMB_CPTxBCR_SWCPT_MASK        = 0x00000001U;   /** @brief Software capture */
    static const uint32_t HRTIM_TIMB_OUTBR_DLYPRT_MASK         = 0x00001C00U;   /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMB_OUTBR_DLYPRTEN_MASK       = 0x00000200U;   /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMB_OUTBR_DTEN_MASK           = 0x00000100U;   /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMB_FLTBR_FLTLCK_MASK         = 0x80000000U;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMB Register Field Masks ****/

    static const uint32_t HRTIM_TIMB_TIMBCR_DELCMPx_MASK[5] = {
      [2] = 0x00003000U,   /** @brief Delayed CMP2 mode */
      [4] = 0x0000C000U,   /** @brief Delayed CMP4 mode */
    };

    static const uint32_t HRTIM_TIMB_TIMBISR_OxSTAT_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Output 1 state */
      [2] = 0x00080000U,   /** @brief Output 2 state */
    };

    static const uint32_t HRTIM_TIMB_TIMBISR_RSTXx_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset interrupt flag */
      [2] = 0x00001000U,   /** @brief Output 2 reset interrupt flag */
    };

    static const uint32_t HRTIM_TIMB_TIMBISR_SETXx_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set interrupt flag */
      [2] = 0x00000800U,   /** @brief Output 2 set interrupt flag */
    };

    static const uint32_t HRTIM_TIMB_TIMBISR_CPTx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag */
    };

    static const uint32_t HRTIM_TIMB_TIMBISR_CMPx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMB_TIMBICR_RSTXxC_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset flag clear */
      [2] = 0x00001000U,   /** @brief Output 2 reset flag clear */
    };

    static const uint32_t HRTIM_TIMB_TIMBICR_SETxXC_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set flag clear */
      [2] = 0x00000800U,   /** @brief Output 2 set flag clear */
    };

    static const uint32_t HRTIM_TIMB_TIMBICR_CPTxC_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag clear */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMB_TIMBICR_CMPxC_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTXxDE_MASK[3] = {
      [1] = 0x04000000U,   /** @brief RSTx1DE */
      [2] = 0x10000000U,   /** @brief RSTx2DE */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_CPTxDE_MASK[3] = {
      [1] = 0x00800000U,   /** @brief CPT1DE */
      [2] = 0x01000000U,   /** @brief CPT2DE */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_CMPxDE_MASK[5] = {
      [1] = 0x00010000U,   /** @brief CMP1DE */
      [2] = 0x00020000U,   /** @brief CMP2DE */
      [3] = 0x00040000U,   /** @brief CMP3DE */
      [4] = 0x00080000U,   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTXxIE_MASK[3] = {
      [1] = 0x00000400U,   /** @brief RSTx1IE */
      [2] = 0x00001000U,   /** @brief RSTx2IE */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_CPTxIE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief CPT1IE */
      [2] = 0x00000100U,   /** @brief CPT2IE */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_CMPxIE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [4] = 0x00000008U,   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMB_SETBxR_EXTEVNTx_MASK[11] = {
      [1]  = 0x00200000U,   /** @brief External event 1 */
      [2]  = 0x00400000U,   /** @brief External event 2 */
      [3]  = 0x00800000U,   /** @brief External event 3 */
      [4]  = 0x01000000U,   /** @brief External event 4 */
      [5]  = 0x02000000U,   /** @brief External event 5 */
      [6]  = 0x04000000U,   /** @brief External event 6 */
      [7]  = 0x08000000U,   /** @brief External event 7 */
      [8]  = 0x10000000U,   /** @brief External event 8 */
      [9]  = 0x20000000U,   /** @brief External event 9 */
      [10] = 0x40000000U,   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMB_SETBxR_TIMEVNTx_MASK[10] = {
      [1]  = 0x00001000U,   /** @brief Timer event 1 */
      [2]  = 0x00002000U,   /** @brief Timer event 2 */
      [3]  = 0x00004000U,   /** @brief Timer event 3 */
      [4]  = 0x00008000U,   /** @brief Timer event 4 */
      [5]  = 0x00010000U,   /** @brief Timer event 5 */
      [6]  = 0x00020000U,   /** @brief Timer event 6 */
      [7]  = 0x00040000U,   /** @brief Timer event 7 */
      [8]  = 0x00080000U,   /** @brief Timer event 8 */
      [9]  = 0x00100000U,   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMB_SETBxR_MSTCMPx_MASK[5] = {
      [1] = 0x00000100U,   /** @brief Master compare 1 */
      [2] = 0x00000200U,   /** @brief Master compare 2 */
      [3] = 0x00000400U,   /** @brief Master compare 3 */
      [4] = 0x00000800U,   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMB_EEFBR1_EExFLTR_MASK[6] = {
      [1] = 0x0000001EU,   /** @brief External event 1 filter */
      [2] = 0x00000780U,   /** @brief External event 2 filter */
      [3] = 0x0001E000U,   /** @brief External event 3 filter */
      [4] = 0x00780000U,   /** @brief External event 4 filter */
      [5] = 0x1E000000U,   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMB_EEFBR1_EExLTCH_MASK[6] = {
      [1] = 0x00000001U,   /** @brief External event 1 latch */
      [2] = 0x00000040U,   /** @brief External event 2 latch */
      [3] = 0x00001000U,   /** @brief External event 3 latch */
      [4] = 0x00040000U,   /** @brief External event 4 latch */
      [5] = 0x01000000U,   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMECMPx_MASK[5] = {
      [1] = 0x10000000U,   /** @brief Timer E compare 1 */
      [2] = 0x20000000U,   /** @brief Timer E compare 2 */
      [4] = 0x40000000U,   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMDCMPx_MASK[5] = {
      [1] = 0x02000000U,   /** @brief Timer D compare 1 */
      [2] = 0x04000000U,   /** @brief Timer D compare 2 */
      [4] = 0x08000000U,   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMCCMPx_MASK[5] = {
      [1] = 0x00400000U,   /** @brief Timer C compare 1 */
      [2] = 0x00800000U,   /** @brief Timer C compare 2 */
      [4] = 0x01000000U,   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMACMPx_MASK[5] = {
      [1] = 0x00080000U,   /** @brief Timer A compare 1 */
      [2] = 0x00100000U,   /** @brief Timer A compare 2 */
      [4] = 0x00200000U,   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_TECMPx_MASK[3] = {
      [1] = 0x40000000U,   /** @brief Timer E compare 1 */
      [2] = 0x80000000U,   /** @brief Timer E compare 2 */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_TDCMPx_MASK[3] = {
      [1] = 0x04000000U,   /** @brief Timer D compare 1 */
      [2] = 0x08000000U,   /** @brief Timer D compare 2 */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_TCCMPx_MASK[3] = {
      [1] = 0x00400000U,   /** @brief Timer C compare 1 */
      [2] = 0x00800000U,   /** @brief Timer C compare 2 */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_TACMPx_MASK[3] = {
      [1] = 0x00004000U,   /** @brief Timer A compare 1 */
      [2] = 0x00008000U,   /** @brief Timer A compare 2 */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_EXEVxCPT_MASK[11] = {
      [1]  = 0x00000004U,   /** @brief External event 1 capture */
      [2]  = 0x00000008U,   /** @brief External event 2 capture */
      [3]  = 0x00000010U,   /** @brief External event 3 capture */
      [4]  = 0x00000020U,   /** @brief External event 4 capture */
      [5]  = 0x00000040U,   /** @brief External event 5 capture */
      [6]  = 0x00000080U,   /** @brief External event 6 capture */
      [7]  = 0x00000100U,   /** @brief External event 7 capture */
      [8]  = 0x00000200U,   /** @brief External event 8 capture */
      [9]  = 0x00000400U,   /** @brief External event 9 capture */
      [10] = 0x00000800U,   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMB_OUTBR_DIDLx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 0x00800000U,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const uint32_t HRTIM_TIMB_OUTBR_CHPx_MASK[3] = {
      [1] = 0x00000040U,   /** @brief Output 1 chopper enable */
      [2] = 0x00400000U,   /** @brief Output 2 chopper enable */
    };

    static const uint32_t HRTIM_TIMB_OUTBR_FAULTx_MASK[3] = {
      [1] = 0x00000030U,   /** @brief Output 1 fault state */
      [2] = 0x00300000U,   /** @brief Output 2 fault state */
    };

    static const uint32_t HRTIM_TIMB_OUTBR_IDLESx_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output 1 idle state */
      [2] = 0x00080000U,   /** @brief Output 2 idle state */
    };

    static const uint32_t HRTIM_TIMB_OUTBR_IDLEMx_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output 1 idle mode */
      [2] = 0x00040000U,   /** @brief Output 2 idle mode */
    };

    static const uint32_t HRTIM_TIMB_OUTBR_POLx_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Output 1 polarity */
      [2] = 0x00020000U,   /** @brief Output 2 polarity */
    };

    static const uint32_t HRTIM_TIMB_FLTBR_FLTxEN_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [5] = 0x00000010U,   /** @brief Fault 5 enable */
    };

    /**** @subsection HRTIM_TIMB Register Field Positions ****/

    static const int32_t HRTIM_TIMB_TIMBCR_UPDGAT_POS        = 28;   /** @brief Update gating */
    static const int32_t HRTIM_TIMB_TIMBCR_PREEN_POS         = 27;   /** @brief Preload enable */
    static const int32_t HRTIM_TIMB_TIMBCR_DACSYNC_POS       = 25;   /** @brief AC synchronization */
    static const int32_t HRTIM_TIMB_TIMBCR_MSTU_POS          = 24;   /** @brief Master timer update */
    static const int32_t HRTIM_TIMB_TIMBCR_TEU_POS           = 23;   /** @brief TEU */
    static const int32_t HRTIM_TIMB_TIMBCR_TDU_POS           = 22;   /** @brief TDU */
    static const int32_t HRTIM_TIMB_TIMBCR_TCU_POS           = 21;   /** @brief TCU */
    static const int32_t HRTIM_TIMB_TIMBCR_TBU_POS           = 20;   /** @brief TBU */
    static const int32_t HRTIM_TIMB_TIMBCR_TXRSTU_POS        = 18;   /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMB_TIMBCR_TXREPU_POS        = 17;   /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMB_TIMBCR_SYNCSTRTX_POS     = 11;   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMB_TIMBCR_SYNCRSTX_POS      = 10;   /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMB_TIMBCR_PSHPLL_POS        = 6;    /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMB_TIMBCR_HALF_POS          = 5;    /** @brief Half mode enable */
    static const int32_t HRTIM_TIMB_TIMBCR_RETRIG_POS        = 4;    /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMB_TIMBCR_CONT_POS          = 3;    /** @brief Continuous mode */
    static const int32_t HRTIM_TIMB_TIMBCR_CK_PSCX_POS       = 0;    /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMB_TIMBISR_IPPSTAT_POS      = 17;   /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMB_TIMBISR_CPPSTAT_POS      = 16;   /** @brief Current push pull status */
    static const int32_t HRTIM_TIMB_TIMBISR_DLYPRT_POS       = 14;   /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMB_TIMBISR_RST_POS          = 13;   /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMB_TIMBISR_UPD_POS          = 6;    /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMB_TIMBISR_REP_POS          = 4;    /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMB_TIMBICR_DLYPRTC_POS      = 14;   /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMB_TIMBICR_RSTC_POS         = 13;   /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMB_TIMBICR_UPDC_POS         = 6;    /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMB_TIMBICR_REPC_POS         = 4;    /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMB_TIMBDIER5_DLYPRTDE_POS   = 30;   /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_RSTDE_POS      = 29;   /** @brief RSTDE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_SETX2DE_POS    = 27;   /** @brief SETx2DE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_SET1XDE_POS    = 25;   /** @brief SET1xDE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_UPDDE_POS      = 22;   /** @brief UPDDE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_REPDE_POS      = 20;   /** @brief REPDE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_DLYPRTIE_POS   = 14;   /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_RSTIE_POS      = 13;   /** @brief RSTIE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_SETX2IE_POS    = 11;   /** @brief SETx2IE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_SET1XIE_POS    = 9;    /** @brief SET1xIE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_UPDIE_POS      = 6;    /** @brief UPDIE */
    static const int32_t HRTIM_TIMB_TIMBDIER5_REPIE_POS      = 4;    /** @brief REPIE */
    static const int32_t HRTIM_TIMB_CNTR_CNTX_POS            = 0;    /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMB_PERBR_PERX_POS           = 0;    /** @brief Timerx period value */
    static const int32_t HRTIM_TIMB_REPBR_REPX_POS           = 0;    /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMB_CMPxBR_CMP1X_POS         = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMB_CMP1CBR_REPX_POS         = 16;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMB_CMP1CBR_CMP1X_POS        = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMB_CPTxBR_CPT1X_POS         = 0;    /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMB_DTBR_DTFLKX_POS          = 31;   /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMB_DTBR_DTFSLKX_POS         = 30;   /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMB_DTBR_SDTFX_POS           = 25;   /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMB_DTBR_DTFX_POS            = 16;   /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMB_DTBR_DTRLKX_POS          = 15;   /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMB_DTBR_DTRSLKX_POS         = 14;   /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMB_DTBR_DTPRSC_POS          = 10;   /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMB_DTBR_SDTRX_POS           = 9;    /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMB_DTBR_DTRX_POS            = 0;    /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMB_SETBxR_UPDATE_POS        = 31;   /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMB_SETBxR_MSTPER_POS        = 7;    /** @brief Master period */
    static const int32_t HRTIM_TIMB_SETBxR_PER_POS           = 2;    /** @brief Timer A period */
    static const int32_t HRTIM_TIMB_SETBxR_RESYNC_POS        = 1;    /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMB_SETBxR_SST_POS           = 0;    /** @brief Software set trigger */
    static const int32_t HRTIM_TIMB_RSTBxR_UPDATE_POS        = 31;   /** @brief UPDATE */
    static const int32_t HRTIM_TIMB_RSTBxR_MSTPER_POS        = 7;    /** @brief MSTPER */
    static const int32_t HRTIM_TIMB_RSTBxR_PER_POS           = 2;    /** @brief PER */
    static const int32_t HRTIM_TIMB_RSTBxR_RESYNC_POS        = 1;    /** @brief RESYNC */
    static const int32_t HRTIM_TIMB_RSTBxR_SRT_POS           = 0;    /** @brief SRT */
    static const int32_t HRTIM_TIMB_RSTBR_MSTPER_POS         = 4;    /** @brief Master timer period */
    static const int32_t HRTIM_TIMB_RSTBR_UPDT_POS           = 1;    /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMB_CHPBR_STRTPW_POS         = 7;    /** @brief STRTPW */
    static const int32_t HRTIM_TIMB_CHPBR_CHPDTY_POS         = 4;    /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMB_CHPBR_CHPFRQ_POS         = 0;    /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMB_CPTxBCR_TE1RST_POS       = 29;   /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMB_CPTxBCR_TE1SET_POS       = 28;   /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMB_CPTxBCR_TD1RST_POS       = 25;   /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMB_CPTxBCR_TD1SET_POS       = 24;   /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMB_CPTxBCR_TC1RST_POS       = 21;   /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMB_CPTxBCR_TC1SET_POS       = 20;   /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMB_CPTxBCR_TA1RST_POS       = 13;   /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMB_CPTxBCR_TA1SET_POS       = 12;   /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMB_CPTxBCR_UDPCPT_POS       = 1;    /** @brief Update capture */
    static const int32_t HRTIM_TIMB_CPTxBCR_SWCPT_POS        = 0;    /** @brief Software capture */
    static const int32_t HRTIM_TIMB_OUTBR_DLYPRT_POS         = 10;   /** @brief Delayed protection */
    static const int32_t HRTIM_TIMB_OUTBR_DLYPRTEN_POS       = 9;    /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMB_OUTBR_DTEN_POS           = 8;    /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMB_FLTBR_FLTLCK_POS         = 31;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMB Register Field Positions ****/

    static const int32_t HRTIM_TIMB_TIMBCR_DELCMPx_POS[5] = {
      [2] = 12,   /** @brief Delayed CMP2 mode */
      [4] = 14,   /** @brief Delayed CMP4 mode */
    };

    static const int32_t HRTIM_TIMB_TIMBISR_OxSTAT_POS[3] = {
      [1] = 18,   /** @brief Output 1 state */
      [2] = 19,   /** @brief Output 2 state */
    };

    static const int32_t HRTIM_TIMB_TIMBISR_RSTXx_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset interrupt flag */
      [2] = 12,   /** @brief Output 2 reset interrupt flag */
    };

    static const int32_t HRTIM_TIMB_TIMBISR_SETXx_POS[3] = {
      [1] = 9,    /** @brief Output 1 set interrupt flag */
      [2] = 11,   /** @brief Output 2 set interrupt flag */
    };

    static const int32_t HRTIM_TIMB_TIMBISR_CPTx_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag */
      [2] = 8,   /** @brief Capture2 interrupt flag */
    };

    static const int32_t HRTIM_TIMB_TIMBISR_CMPx_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag */
      [2] = 1,   /** @brief Compare 2 interrupt flag */
      [3] = 2,   /** @brief Compare 3 interrupt flag */
      [4] = 3,   /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMB_TIMBICR_RSTXxC_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset flag clear */
      [2] = 12,   /** @brief Output 2 reset flag clear */
    };

    static const int32_t HRTIM_TIMB_TIMBICR_SETxXC_POS[3] = {
      [1] = 9,    /** @brief Output 1 set flag clear */
      [2] = 11,   /** @brief Output 2 set flag clear */
    };

    static const int32_t HRTIM_TIMB_TIMBICR_CPTxC_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag clear */
      [2] = 8,   /** @brief Capture2 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMB_TIMBICR_CMPxC_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag clear */
      [2] = 1,   /** @brief Compare 2 interrupt flag clear */
      [3] = 2,   /** @brief Compare 3 interrupt flag clear */
      [4] = 3,   /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMB_TIMBDIER5_RSTXxDE_POS[3] = {
      [1] = 26,   /** @brief RSTx1DE */
      [2] = 28,   /** @brief RSTx2DE */
    };

    static const int32_t HRTIM_TIMB_TIMBDIER5_CPTxDE_POS[3] = {
      [1] = 23,   /** @brief CPT1DE */
      [2] = 24,   /** @brief CPT2DE */
    };

    static const int32_t HRTIM_TIMB_TIMBDIER5_CMPxDE_POS[5] = {
      [1] = 16,   /** @brief CMP1DE */
      [2] = 17,   /** @brief CMP2DE */
      [3] = 18,   /** @brief CMP3DE */
      [4] = 19,   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMB_TIMBDIER5_RSTXxIE_POS[3] = {
      [1] = 10,   /** @brief RSTx1IE */
      [2] = 12,   /** @brief RSTx2IE */
    };

    static const int32_t HRTIM_TIMB_TIMBDIER5_CPTxIE_POS[3] = {
      [1] = 7,   /** @brief CPT1IE */
      [2] = 8,   /** @brief CPT2IE */
    };

    static const int32_t HRTIM_TIMB_TIMBDIER5_CMPxIE_POS[5] = {
      [1] = 0,   /** @brief CMP1IE */
      [2] = 1,   /** @brief CMP2IE */
      [3] = 2,   /** @brief CMP3IE */
      [4] = 3,   /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMB_SETBxR_EXTEVNTx_POS[11] = {
      [1]  = 21,   /** @brief External event 1 */
      [2]  = 22,   /** @brief External event 2 */
      [3]  = 23,   /** @brief External event 3 */
      [4]  = 24,   /** @brief External event 4 */
      [5]  = 25,   /** @brief External event 5 */
      [6]  = 26,   /** @brief External event 6 */
      [7]  = 27,   /** @brief External event 7 */
      [8]  = 28,   /** @brief External event 8 */
      [9]  = 29,   /** @brief External event 9 */
      [10] = 30,   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMB_SETBxR_TIMEVNTx_POS[10] = {
      [1]  = 12,   /** @brief Timer event 1 */
      [2]  = 13,   /** @brief Timer event 2 */
      [3]  = 14,   /** @brief Timer event 3 */
      [4]  = 15,   /** @brief Timer event 4 */
      [5]  = 16,   /** @brief Timer event 5 */
      [6]  = 17,   /** @brief Timer event 6 */
      [7]  = 18,   /** @brief Timer event 7 */
      [8]  = 19,   /** @brief Timer event 8 */
      [9]  = 20,   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMB_SETBxR_MSTCMPx_POS[5] = {
      [1] = 8,    /** @brief Master compare 1 */
      [2] = 9,    /** @brief Master compare 2 */
      [3] = 10,   /** @brief Master compare 3 */
      [4] = 11,   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMB_EEFBR1_EExFLTR_POS[6] = {
      [1] = 1,    /** @brief External event 1 filter */
      [2] = 7,    /** @brief External event 2 filter */
      [3] = 13,   /** @brief External event 3 filter */
      [4] = 19,   /** @brief External event 4 filter */
      [5] = 25,   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMB_EEFBR1_EExLTCH_POS[6] = {
      [1] = 0,    /** @brief External event 1 latch */
      [2] = 6,    /** @brief External event 2 latch */
      [3] = 12,   /** @brief External event 3 latch */
      [4] = 18,   /** @brief External event 4 latch */
      [5] = 24,   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMB_RSTBR_TIMECMPx_POS[5] = {
      [1] = 28,   /** @brief Timer E compare 1 */
      [2] = 29,   /** @brief Timer E compare 2 */
      [4] = 30,   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMB_RSTBR_TIMDCMPx_POS[5] = {
      [1] = 25,   /** @brief Timer D compare 1 */
      [2] = 26,   /** @brief Timer D compare 2 */
      [4] = 27,   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIMB_RSTBR_TIMCCMPx_POS[5] = {
      [1] = 22,   /** @brief Timer C compare 1 */
      [2] = 23,   /** @brief Timer C compare 2 */
      [4] = 24,   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIMB_RSTBR_TIMACMPx_POS[5] = {
      [1] = 19,   /** @brief Timer A compare 1 */
      [2] = 20,   /** @brief Timer A compare 2 */
      [4] = 21,   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIMB_CPTxBCR_TECMPx_POS[3] = {
      [1] = 30,   /** @brief Timer E compare 1 */
      [2] = 31,   /** @brief Timer E compare 2 */
    };

    static const int32_t HRTIM_TIMB_CPTxBCR_TDCMPx_POS[3] = {
      [1] = 26,   /** @brief Timer D compare 1 */
      [2] = 27,   /** @brief Timer D compare 2 */
    };

    static const int32_t HRTIM_TIMB_CPTxBCR_TCCMPx_POS[3] = {
      [1] = 22,   /** @brief Timer C compare 1 */
      [2] = 23,   /** @brief Timer C compare 2 */
    };

    static const int32_t HRTIM_TIMB_CPTxBCR_TACMPx_POS[3] = {
      [1] = 14,   /** @brief Timer A compare 1 */
      [2] = 15,   /** @brief Timer A compare 2 */
    };

    static const int32_t HRTIM_TIMB_CPTxBCR_EXEVxCPT_POS[11] = {
      [1]  = 2,    /** @brief External event 1 capture */
      [2]  = 3,    /** @brief External event 2 capture */
      [3]  = 4,    /** @brief External event 3 capture */
      [4]  = 5,    /** @brief External event 4 capture */
      [5]  = 6,    /** @brief External event 5 capture */
      [6]  = 7,    /** @brief External event 6 capture */
      [7]  = 8,    /** @brief External event 7 capture */
      [8]  = 9,    /** @brief External event 8 capture */
      [9]  = 10,   /** @brief External event 9 capture */
      [10] = 11,   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMB_OUTBR_DIDLx_POS[3] = {
      [1] = 7,    /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 23,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const int32_t HRTIM_TIMB_OUTBR_CHPx_POS[3] = {
      [1] = 6,    /** @brief Output 1 chopper enable */
      [2] = 22,   /** @brief Output 2 chopper enable */
    };

    static const int32_t HRTIM_TIMB_OUTBR_FAULTx_POS[3] = {
      [1] = 4,    /** @brief Output 1 fault state */
      [2] = 20,   /** @brief Output 2 fault state */
    };

    static const int32_t HRTIM_TIMB_OUTBR_IDLESx_POS[3] = {
      [1] = 3,    /** @brief Output 1 idle state */
      [2] = 19,   /** @brief Output 2 idle state */
    };

    static const int32_t HRTIM_TIMB_OUTBR_IDLEMx_POS[3] = {
      [1] = 2,    /** @brief Output 1 idle mode */
      [2] = 18,   /** @brief Output 2 idle mode */
    };

    static const int32_t HRTIM_TIMB_OUTBR_POLx_POS[3] = {
      [1] = 1,    /** @brief Output 1 polarity */
      [2] = 17,   /** @brief Output 2 polarity */
    };

    static const int32_t HRTIM_TIMB_FLTBR_FLTxEN_POS[6] = {
      [1] = 0,   /** @brief Fault 1 enable */
      [2] = 1,   /** @brief Fault 2 enable */
      [3] = 2,   /** @brief Fault 3 enable */
      [4] = 3,   /** @brief Fault 4 enable */
      [5] = 4,   /** @brief Fault 5 enable */
    };

    /**********************************************************************************************
     * @section HRTIM_TIMC Register Information
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMC Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMC_TIMCCR_PTR      = (RW_ uint32_t* const)0x40017580U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMC_TIMCISR_PTR     = (RO_ uint32_t* const)0x40017584U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMC_TIMCICR_PTR     = (RW_ uint32_t* const)0x40017588U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMC_TIMCDIER5_PTR   = (RW_ uint32_t* const)0x4001758CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMC_CNTCR_PTR       = (RW_ uint32_t* const)0x40017590U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMC_PERCR_PTR       = (RW_ uint32_t* const)0x40017594U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMC_REPCR_PTR       = (RW_ uint32_t* const)0x40017598U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMC_CMP1CCR_PTR     = (RW_ uint32_t* const)0x400175A0U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMC_DTCR_PTR        = (RW_ uint32_t* const)0x400175B8U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMC_EEFCR1_PTR      = (RW_ uint32_t* const)0x400175CCU;   /** @brief Timerx external event filtering register 1 */
    static RW_ uint32_t* const HRTIM_TIMC_EEFCR2_PTR      = (RW_ uint32_t* const)0x400175D0U;   /** @brief Timerx external event filtering register 2 */
    static RW_ uint32_t* const HRTIM_TIMC_RSTCR_PTR       = (RW_ uint32_t* const)0x400175D4U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMC_CHPCR_PTR       = (RW_ uint32_t* const)0x400175D8U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMC_OUTCR_PTR       = (RW_ uint32_t* const)0x400175E4U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMC_FLTCR_PTR       = (RW_ uint32_t* const)0x400175E8U;   /** @brief Timerx fault register */

    /**** @subsection Enumerated HRTIM_TIMC Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMC_CMPxCR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001759CU,   /** @brief Timerx compare 1 register */
      [2] = (RW_ uint32_t* const)0x400175A4U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t* const)0x400175A8U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t* const)0x400175ACU,   /** @brief Timerx compare 4 register */
    };

    static RO_ uint32_t* const HRTIM_TIMC_CPTxCR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x400175B0U,   /** @brief Timerx capture 1 register */
      [2] = (RO_ uint32_t* const)0x400175B4U,   /** @brief Timerx capture 2 register */
    };

    static RW_ uint32_t* const HRTIM_TIMC_SETCxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400175BCU,   /** @brief Timerx output1 set register */
      [2] = (RW_ uint32_t* const)0x400175C4U,   /** @brief Timerx output2 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMC_RSTCxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400175C0U,   /** @brief Timerx output1 reset register */
      [2] = (RW_ uint32_t* const)0x400175C8U,   /** @brief Timerx output2 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMC_CPTxCCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400175DCU,   /** @brief Timerx capture 2 control register */
      [2] = (RW_ uint32_t* const)0x400175E0U,   /** @brief CPT2xCR */
    };

    /**** @subsection HRTIM_TIMC Register Reset Values ****/

    static const uint32_t HRTIM_TIMC_TIMCCR_RST      = 0x00000000U;   /** @brief TIMCCR register reset value. */
    static const uint32_t HRTIM_TIMC_TIMCISR_RST     = 0x00000000U;   /** @brief TIMCISR register reset value. */
    static const uint32_t HRTIM_TIMC_TIMCICR_RST     = 0x00000000U;   /** @brief TIMCICR register reset value. */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RST   = 0x00000000U;   /** @brief TIMCDIER5 register reset value. */
    static const uint32_t HRTIM_TIMC_CNTCR_RST       = 0x00000000U;   /** @brief CNTCR register reset value. */
    static const uint32_t HRTIM_TIMC_PERCR_RST       = 0x0000FFFFU;   /** @brief PERCR register reset value. */
    static const uint32_t HRTIM_TIMC_REPCR_RST       = 0x00000000U;   /** @brief REPCR register reset value. */
    static const uint32_t HRTIM_TIMC_CMP1CCR_RST     = 0x00000000U;   /** @brief CMP1CCR register reset value. */
    static const uint32_t HRTIM_TIMC_DTCR_RST        = 0x00000000U;   /** @brief DTCR register reset value. */
    static const uint32_t HRTIM_TIMC_EEFCR1_RST      = 0x00000000U;   /** @brief EEFCR1 register reset value. */
    static const uint32_t HRTIM_TIMC_EEFCR2_RST      = 0x00000000U;   /** @brief EEFCR2 register reset value. */
    static const uint32_t HRTIM_TIMC_RSTCR_RST       = 0x00000000U;   /** @brief RSTCR register reset value. */
    static const uint32_t HRTIM_TIMC_CHPCR_RST       = 0x00000000U;   /** @brief CHPCR register reset value. */
    static const uint32_t HRTIM_TIMC_OUTCR_RST       = 0x00000000U;   /** @brief OUTCR register reset value. */
    static const uint32_t HRTIM_TIMC_FLTCR_RST       = 0x00000000U;   /** @brief FLTCR register reset value. */

    /**** @subsection Enumerated HRTIM_TIMC Register Reset Values ****/

    static const uint32_t HRTIM_TIMC_CMPxCR_RST[5] = {
      [1] = 0x00000000U,   /** @brief CMP1CR register reset value. */
      [2] = 0x00000000U,   /** @brief CMP2CR register reset value. */
      [3] = 0x00000000U,   /** @brief CMP3CR register reset value. */
      [4] = 0x00000000U,   /** @brief CMP4CR register reset value. */
    };

    static const uint32_t HRTIM_TIMC_CPTxCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1CR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2CR register reset value. */
    };

    static const uint32_t HRTIM_TIMC_SETCxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief SETC1R register reset value. */
      [2] = 0x00000000U,   /** @brief SETC2R register reset value. */
    };

    static const uint32_t HRTIM_TIMC_RSTCxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief RSTC1R register reset value. */
      [2] = 0x00000000U,   /** @brief RSTC2R register reset value. */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1CCR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2CCR register reset value. */
    };

    /**** @subsection Enumerated HRTIM_TIMC Register Value Types ****/

    typedef uint32_t HRTIM_TIMC_TIMCCR_t;      /** @brief TIMCCR register value type. */
    typedef uint32_t HRTIM_TIMC_TIMCISR_t;     /** @brief TIMCISR register value type. */
    typedef uint32_t HRTIM_TIMC_TIMCICR_t;     /** @brief TIMCICR register value type. */
    typedef uint32_t HRTIM_TIMC_TIMCDIER5_t;   /** @brief TIMCDIER5 register value type. */
    typedef uint32_t HRTIM_TIMC_CNTCR_t;       /** @brief CNTCR register value type. */
    typedef uint32_t HRTIM_TIMC_PERCR_t;       /** @brief PERCR register value type. */
    typedef uint32_t HRTIM_TIMC_REPCR_t;       /** @brief REPCR register value type. */
    typedef uint32_t HRTIM_TIMC_CMPxCR_t;      /** @brief CMPxCR register value type. */
    typedef uint32_t HRTIM_TIMC_CMP1CCR_t;     /** @brief CMP1CCR register value type. */
    typedef uint32_t HRTIM_TIMC_CPTxCR_t;      /** @brief CPTxCR register value type. */
    typedef uint32_t HRTIM_TIMC_DTCR_t;        /** @brief DTCR register value type. */
    typedef uint32_t HRTIM_TIMC_SETCxR_t;      /** @brief SETCxR register value type. */
    typedef uint32_t HRTIM_TIMC_RSTCxR_t;      /** @brief RSTCxR register value type. */
    typedef uint32_t HRTIM_TIMC_EEFCR1_t;      /** @brief EEFCR1 register value type. */
    typedef uint32_t HRTIM_TIMC_EEFCR2_t;      /** @brief EEFCR2 register value type. */
    typedef uint32_t HRTIM_TIMC_RSTCR_t;       /** @brief RSTCR register value type. */
    typedef uint32_t HRTIM_TIMC_CHPCR_t;       /** @brief CHPCR register value type. */
    typedef uint32_t HRTIM_TIMC_CPTxCCR_t;     /** @brief CPTxCCR register value type. */
    typedef uint32_t HRTIM_TIMC_OUTCR_t;       /** @brief OUTCR register value type. */
    typedef uint32_t HRTIM_TIMC_FLTCR_t;       /** @brief FLTCR register value type. */

    /**** @subsection Enumerated HRTIM_TIMC Register Pointer Types ****/

    typedef uint32_t* const HRTIM_TIMC_TIMCCR_PTR_t;      /** @brief TIMCCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_TIMCISR_PTR_t;     /** @brief TIMCISR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_TIMCICR_PTR_t;     /** @brief TIMCICR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_TIMCDIER5_PTR_t;   /** @brief TIMCDIER5 register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_CNTCR_PTR_t;       /** @brief CNTCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_PERCR_PTR_t;       /** @brief PERCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_REPCR_PTR_t;       /** @brief REPCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_CMPxCR_PTR_t;      /** @brief CMPxCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_CMP1CCR_PTR_t;     /** @brief CMP1CCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_CPTxCR_PTR_t;      /** @brief CPTxCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_DTCR_PTR_t;        /** @brief DTCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_SETCxR_PTR_t;      /** @brief SETCxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_RSTCxR_PTR_t;      /** @brief RSTCxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_EEFCR1_PTR_t;      /** @brief EEFCR1 register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_EEFCR2_PTR_t;      /** @brief EEFCR2 register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_RSTCR_PTR_t;       /** @brief RSTCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_CHPCR_PTR_t;       /** @brief CHPCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_CPTxCCR_PTR_t;     /** @brief CPTxCCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_OUTCR_PTR_t;       /** @brief OUTCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMC_FLTCR_PTR_t;       /** @brief FLTCR register pointer type. */

    /**** @subsection HRTIM_TIMC Register Field Masks ****/

    static const uint32_t HRTIM_TIMC_TIMCCR_UPDGAT_MASK        = 0xF0000000U;   /** @brief Update gating */
    static const uint32_t HRTIM_TIMC_TIMCCR_PREEN_MASK         = 0x08000000U;   /** @brief Preload enable */
    static const uint32_t HRTIM_TIMC_TIMCCR_DACSYNC_MASK       = 0x06000000U;   /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMC_TIMCCR_MSTU_MASK          = 0x01000000U;   /** @brief Master timer update */
    static const uint32_t HRTIM_TIMC_TIMCCR_TEU_MASK           = 0x00800000U;   /** @brief TEU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TDU_MASK           = 0x00400000U;   /** @brief TDU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TCU_MASK           = 0x00200000U;   /** @brief TCU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TBU_MASK           = 0x00100000U;   /** @brief TBU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TXRSTU_MASK        = 0x00040000U;   /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMC_TIMCCR_TXREPU_MASK        = 0x00020000U;   /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMC_TIMCCR_SYNCSTRTX_MASK     = 0x00000800U;   /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMC_TIMCCR_SYNCRSTX_MASK      = 0x00000400U;   /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMC_TIMCCR_PSHPLL_MASK        = 0x00000040U;   /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMC_TIMCCR_HALF_MASK          = 0x00000020U;   /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMC_TIMCCR_RETRIG_MASK        = 0x00000010U;   /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMC_TIMCCR_CONT_MASK          = 0x00000008U;   /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMC_TIMCCR_CK_PSCX_MASK       = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMC_TIMCISR_IPPSTAT_MASK      = 0x00020000U;   /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMC_TIMCISR_CPPSTAT_MASK      = 0x00010000U;   /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMC_TIMCISR_DLYPRT_MASK       = 0x00004000U;   /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_RST_MASK          = 0x00002000U;   /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_UPD_MASK          = 0x00000040U;   /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_REP_MASK          = 0x00000010U;   /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCICR_DLYPRTC_MASK      = 0x00004000U;   /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_RSTC_MASK         = 0x00002000U;   /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_UPDC_MASK         = 0x00000040U;   /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_REPC_MASK         = 0x00000010U;   /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_DLYPRTDE_MASK   = 0x40000000U;   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTDE_MASK      = 0x20000000U;   /** @brief RSTDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SETX2DE_MASK    = 0x08000000U;   /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SET1XDE_MASK    = 0x02000000U;   /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_UPDDE_MASK      = 0x00400000U;   /** @brief UPDDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_REPDE_MASK      = 0x00100000U;   /** @brief REPDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_DLYPRTIE_MASK   = 0x00004000U;   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTIE_MASK      = 0x00002000U;   /** @brief RSTIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SETX2IE_MASK    = 0x00000800U;   /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SET1XIE_MASK    = 0x00000200U;   /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_UPDIE_MASK      = 0x00000040U;   /** @brief UPDIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_REPIE_MASK      = 0x00000010U;   /** @brief REPIE */
    static const uint32_t HRTIM_TIMC_CNTCR_CNTX_MASK           = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMC_PERCR_PERX_MASK           = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMC_REPCR_REPX_MASK           = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMC_CMPxCR_CMP1X_MASK         = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMC_CMP1CCR_REPX_MASK         = 0x00FF0000U;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMC_CMP1CCR_CMP1X_MASK        = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMC_CPTxCR_CPT1X_MASK         = 0x0000FFFFU;   /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMC_DTCR_DTFLKX_MASK          = 0x80000000U;   /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMC_DTCR_DTFSLKX_MASK         = 0x40000000U;   /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMC_DTCR_SDTFX_MASK           = 0x02000000U;   /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMC_DTCR_DTFX_MASK            = 0x01FF0000U;   /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMC_DTCR_DTRLKX_MASK          = 0x00008000U;   /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMC_DTCR_DTRSLKX_MASK         = 0x00004000U;   /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMC_DTCR_DTPRSC_MASK          = 0x00001C00U;   /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMC_DTCR_SDTRX_MASK           = 0x00000200U;   /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMC_DTCR_DTRX_MASK            = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMC_SETCxR_UPDATE_MASK        = 0x80000000U;   /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMC_SETCxR_MSTPER_MASK        = 0x00000080U;   /** @brief Master period */
    static const uint32_t HRTIM_TIMC_SETCxR_PER_MASK           = 0x00000004U;   /** @brief Timer A period */
    static const uint32_t HRTIM_TIMC_SETCxR_RESYNC_MASK        = 0x00000002U;   /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMC_SETCxR_SST_MASK           = 0x00000001U;   /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMC_RSTCxR_UPDATE_MASK        = 0x80000000U;   /** @brief UPDATE */
    static const uint32_t HRTIM_TIMC_RSTCxR_MSTPER_MASK        = 0x00000080U;   /** @brief MSTPER */
    static const uint32_t HRTIM_TIMC_RSTCxR_PER_MASK           = 0x00000004U;   /** @brief PER */
    static const uint32_t HRTIM_TIMC_RSTCxR_RESYNC_MASK        = 0x00000002U;   /** @brief RESYNC */
    static const uint32_t HRTIM_TIMC_RSTCxR_SRT_MASK           = 0x00000001U;   /** @brief SRT */
    static const uint32_t HRTIM_TIMC_RSTCR_MSTPER_MASK         = 0x00000010U;   /** @brief Master timer period */
    static const uint32_t HRTIM_TIMC_RSTCR_UPDT_MASK           = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMC_CHPCR_STRTPW_MASK         = 0x00000780U;   /** @brief STRTPW */
    static const uint32_t HRTIM_TIMC_CHPCR_CHPDTY_MASK         = 0x00000070U;   /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMC_CHPCR_CHPFRQ_MASK         = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TE1RST_MASK       = 0x20000000U;   /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TE1SET_MASK       = 0x10000000U;   /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TD1RST_MASK       = 0x02000000U;   /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TD1SET_MASK       = 0x01000000U;   /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TB1RST_MASK       = 0x00020000U;   /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TB1SET_MASK       = 0x00010000U;   /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TA1RST_MASK       = 0x00002000U;   /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMC_CPTxCCR_TA1SET_MASK       = 0x00001000U;   /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMC_CPTxCCR_UDPCPT_MASK       = 0x00000002U;   /** @brief Update capture */
    static const uint32_t HRTIM_TIMC_CPTxCCR_SWCPT_MASK        = 0x00000001U;   /** @brief Software capture */
    static const uint32_t HRTIM_TIMC_OUTCR_DLYPRT_MASK         = 0x00001C00U;   /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMC_OUTCR_DLYPRTEN_MASK       = 0x00000200U;   /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMC_OUTCR_DTEN_MASK           = 0x00000100U;   /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMC_FLTCR_FLTLCK_MASK         = 0x80000000U;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMC Register Field Masks ****/

    static const uint32_t HRTIM_TIMC_TIMCCR_DELCMPx_MASK[5] = {
      [2] = 0x00003000U,   /** @brief Delayed CMP2 mode */
      [4] = 0x0000C000U,   /** @brief Delayed CMP4 mode */
    };

    static const uint32_t HRTIM_TIMC_TIMCISR_OxSTAT_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Output 1 state */
      [2] = 0x00080000U,   /** @brief Output 2 state */
    };

    static const uint32_t HRTIM_TIMC_TIMCISR_RSTXx_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset interrupt flag */
      [2] = 0x00001000U,   /** @brief Output 2 reset interrupt flag */
    };

    static const uint32_t HRTIM_TIMC_TIMCISR_SETXx_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set interrupt flag */
      [2] = 0x00000800U,   /** @brief Output 2 set interrupt flag */
    };

    static const uint32_t HRTIM_TIMC_TIMCISR_CPTx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag */
    };

    static const uint32_t HRTIM_TIMC_TIMCISR_CMPx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMC_TIMCICR_RSTXxC_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset flag clear */
      [2] = 0x00001000U,   /** @brief Output 2 reset flag clear */
    };

    static const uint32_t HRTIM_TIMC_TIMCICR_SETxXC_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set flag clear */
      [2] = 0x00000800U,   /** @brief Output 2 set flag clear */
    };

    static const uint32_t HRTIM_TIMC_TIMCICR_CPTxC_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag clear */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMC_TIMCICR_CMPxC_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTXxDE_MASK[3] = {
      [1] = 0x04000000U,   /** @brief RSTx1DE */
      [2] = 0x10000000U,   /** @brief RSTx2DE */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_CPTxDE_MASK[3] = {
      [1] = 0x00800000U,   /** @brief CPT1DE */
      [2] = 0x01000000U,   /** @brief CPT2DE */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_CMPxDE_MASK[5] = {
      [1] = 0x00010000U,   /** @brief CMP1DE */
      [2] = 0x00020000U,   /** @brief CMP2DE */
      [3] = 0x00040000U,   /** @brief CMP3DE */
      [4] = 0x00080000U,   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTXxIE_MASK[3] = {
      [1] = 0x00000400U,   /** @brief RSTx1IE */
      [2] = 0x00001000U,   /** @brief RSTx2IE */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_CPTxIE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief CPT1IE */
      [2] = 0x00000100U,   /** @brief CPT2IE */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_CMPxIE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [4] = 0x00000008U,   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMC_SETCxR_EXTEVNTx_MASK[11] = {
      [1]  = 0x00200000U,   /** @brief External event 1 */
      [2]  = 0x00400000U,   /** @brief External event 2 */
      [3]  = 0x00800000U,   /** @brief External event 3 */
      [4]  = 0x01000000U,   /** @brief External event 4 */
      [5]  = 0x02000000U,   /** @brief External event 5 */
      [6]  = 0x04000000U,   /** @brief External event 6 */
      [7]  = 0x08000000U,   /** @brief External event 7 */
      [8]  = 0x10000000U,   /** @brief External event 8 */
      [9]  = 0x20000000U,   /** @brief External event 9 */
      [10] = 0x40000000U,   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMC_SETCxR_TIMEVNTx_MASK[10] = {
      [1]  = 0x00001000U,   /** @brief Timer event 1 */
      [2]  = 0x00002000U,   /** @brief Timer event 2 */
      [3]  = 0x00004000U,   /** @brief Timer event 3 */
      [4]  = 0x00008000U,   /** @brief Timer event 4 */
      [5]  = 0x00010000U,   /** @brief Timer event 5 */
      [6]  = 0x00020000U,   /** @brief Timer event 6 */
      [7]  = 0x00040000U,   /** @brief Timer event 7 */
      [8]  = 0x00080000U,   /** @brief Timer event 8 */
      [9]  = 0x00100000U,   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMC_SETCxR_MSTCMPx_MASK[5] = {
      [1] = 0x00000100U,   /** @brief Master compare 1 */
      [2] = 0x00000200U,   /** @brief Master compare 2 */
      [3] = 0x00000400U,   /** @brief Master compare 3 */
      [4] = 0x00000800U,   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMC_EEFCR1_EExFLTR_MASK[6] = {
      [1] = 0x0000001EU,   /** @brief External event 1 filter */
      [2] = 0x00000780U,   /** @brief External event 2 filter */
      [3] = 0x0001E000U,   /** @brief External event 3 filter */
      [4] = 0x00780000U,   /** @brief External event 4 filter */
      [5] = 0x1E000000U,   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMC_EEFCR1_EExLTCH_MASK[6] = {
      [1] = 0x00000001U,   /** @brief External event 1 latch */
      [2] = 0x00000040U,   /** @brief External event 2 latch */
      [3] = 0x00001000U,   /** @brief External event 3 latch */
      [4] = 0x00040000U,   /** @brief External event 4 latch */
      [5] = 0x01000000U,   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMECMPx_MASK[5] = {
      [1] = 0x10000000U,   /** @brief Timer E compare 1 */
      [2] = 0x20000000U,   /** @brief Timer E compare 2 */
      [4] = 0x40000000U,   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMDCMPx_MASK[5] = {
      [1] = 0x02000000U,   /** @brief Timer D compare 1 */
      [2] = 0x04000000U,   /** @brief Timer D compare 2 */
      [4] = 0x08000000U,   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMBCMPx_MASK[5] = {
      [1] = 0x00400000U,   /** @brief Timer B compare 1 */
      [2] = 0x00800000U,   /** @brief Timer B compare 2 */
      [4] = 0x01000000U,   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMACMPx_MASK[5] = {
      [1] = 0x00080000U,   /** @brief Timer A compare 1 */
      [2] = 0x00100000U,   /** @brief Timer A compare 2 */
      [4] = 0x00200000U,   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_TECMPx_MASK[3] = {
      [1] = 0x40000000U,   /** @brief Timer E compare 1 */
      [2] = 0x80000000U,   /** @brief Timer E compare 2 */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_TDCMPx_MASK[3] = {
      [1] = 0x04000000U,   /** @brief Timer D compare 1 */
      [2] = 0x08000000U,   /** @brief Timer D compare 2 */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_TBCMPx_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Timer B compare 1 */
      [2] = 0x00080000U,   /** @brief Timer B compare 2 */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_TACMPx_MASK[3] = {
      [1] = 0x00004000U,   /** @brief Timer A compare 1 */
      [2] = 0x00008000U,   /** @brief Timer A compare 2 */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_EXEVxCPT_MASK[11] = {
      [1]  = 0x00000004U,   /** @brief External event 1 capture */
      [2]  = 0x00000008U,   /** @brief External event 2 capture */
      [3]  = 0x00000010U,   /** @brief External event 3 capture */
      [4]  = 0x00000020U,   /** @brief External event 4 capture */
      [5]  = 0x00000040U,   /** @brief External event 5 capture */
      [6]  = 0x00000080U,   /** @brief External event 6 capture */
      [7]  = 0x00000100U,   /** @brief External event 7 capture */
      [8]  = 0x00000200U,   /** @brief External event 8 capture */
      [9]  = 0x00000400U,   /** @brief External event 9 capture */
      [10] = 0x00000800U,   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMC_OUTCR_DIDLx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 0x00800000U,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const uint32_t HRTIM_TIMC_OUTCR_CHPx_MASK[3] = {
      [1] = 0x00000040U,   /** @brief Output 1 chopper enable */
      [2] = 0x00400000U,   /** @brief Output 2 chopper enable */
    };

    static const uint32_t HRTIM_TIMC_OUTCR_FAULTx_MASK[3] = {
      [1] = 0x00000030U,   /** @brief Output 1 fault state */
      [2] = 0x00300000U,   /** @brief Output 2 fault state */
    };

    static const uint32_t HRTIM_TIMC_OUTCR_IDLESx_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output 1 idle state */
      [2] = 0x00080000U,   /** @brief Output 2 idle state */
    };

    static const uint32_t HRTIM_TIMC_OUTCR_IDLEMx_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output 1 idle mode */
      [2] = 0x00040000U,   /** @brief Output 2 idle mode */
    };

    static const uint32_t HRTIM_TIMC_OUTCR_POLx_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Output 1 polarity */
      [2] = 0x00020000U,   /** @brief Output 2 polarity */
    };

    static const uint32_t HRTIM_TIMC_FLTCR_FLTxEN_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [5] = 0x00000010U,   /** @brief Fault 5 enable */
    };

    /**** @subsection HRTIM_TIMC Register Field Positions ****/

    static const int32_t HRTIM_TIMC_TIMCCR_UPDGAT_POS        = 28;   /** @brief Update gating */
    static const int32_t HRTIM_TIMC_TIMCCR_PREEN_POS         = 27;   /** @brief Preload enable */
    static const int32_t HRTIM_TIMC_TIMCCR_DACSYNC_POS       = 25;   /** @brief AC synchronization */
    static const int32_t HRTIM_TIMC_TIMCCR_MSTU_POS          = 24;   /** @brief Master timer update */
    static const int32_t HRTIM_TIMC_TIMCCR_TEU_POS           = 23;   /** @brief TEU */
    static const int32_t HRTIM_TIMC_TIMCCR_TDU_POS           = 22;   /** @brief TDU */
    static const int32_t HRTIM_TIMC_TIMCCR_TCU_POS           = 21;   /** @brief TCU */
    static const int32_t HRTIM_TIMC_TIMCCR_TBU_POS           = 20;   /** @brief TBU */
    static const int32_t HRTIM_TIMC_TIMCCR_TXRSTU_POS        = 18;   /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMC_TIMCCR_TXREPU_POS        = 17;   /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMC_TIMCCR_SYNCSTRTX_POS     = 11;   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMC_TIMCCR_SYNCRSTX_POS      = 10;   /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMC_TIMCCR_PSHPLL_POS        = 6;    /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMC_TIMCCR_HALF_POS          = 5;    /** @brief Half mode enable */
    static const int32_t HRTIM_TIMC_TIMCCR_RETRIG_POS        = 4;    /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMC_TIMCCR_CONT_POS          = 3;    /** @brief Continuous mode */
    static const int32_t HRTIM_TIMC_TIMCCR_CK_PSCX_POS       = 0;    /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMC_TIMCISR_IPPSTAT_POS      = 17;   /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMC_TIMCISR_CPPSTAT_POS      = 16;   /** @brief Current push pull status */
    static const int32_t HRTIM_TIMC_TIMCISR_DLYPRT_POS       = 14;   /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMC_TIMCISR_RST_POS          = 13;   /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMC_TIMCISR_UPD_POS          = 6;    /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMC_TIMCISR_REP_POS          = 4;    /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMC_TIMCICR_DLYPRTC_POS      = 14;   /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMC_TIMCICR_RSTC_POS         = 13;   /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMC_TIMCICR_UPDC_POS         = 6;    /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMC_TIMCICR_REPC_POS         = 4;    /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMC_TIMCDIER5_DLYPRTDE_POS   = 30;   /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_RSTDE_POS      = 29;   /** @brief RSTDE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_SETX2DE_POS    = 27;   /** @brief SETx2DE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_SET1XDE_POS    = 25;   /** @brief SET1xDE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_UPDDE_POS      = 22;   /** @brief UPDDE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_REPDE_POS      = 20;   /** @brief REPDE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_DLYPRTIE_POS   = 14;   /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_RSTIE_POS      = 13;   /** @brief RSTIE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_SETX2IE_POS    = 11;   /** @brief SETx2IE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_SET1XIE_POS    = 9;    /** @brief SET1xIE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_UPDIE_POS      = 6;    /** @brief UPDIE */
    static const int32_t HRTIM_TIMC_TIMCDIER5_REPIE_POS      = 4;    /** @brief REPIE */
    static const int32_t HRTIM_TIMC_CNTCR_CNTX_POS           = 0;    /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMC_PERCR_PERX_POS           = 0;    /** @brief Timerx period value */
    static const int32_t HRTIM_TIMC_REPCR_REPX_POS           = 0;    /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMC_CMPxCR_CMP1X_POS         = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMC_CMP1CCR_REPX_POS         = 16;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMC_CMP1CCR_CMP1X_POS        = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMC_CPTxCR_CPT1X_POS         = 0;    /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMC_DTCR_DTFLKX_POS          = 31;   /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMC_DTCR_DTFSLKX_POS         = 30;   /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMC_DTCR_SDTFX_POS           = 25;   /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMC_DTCR_DTFX_POS            = 16;   /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMC_DTCR_DTRLKX_POS          = 15;   /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMC_DTCR_DTRSLKX_POS         = 14;   /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMC_DTCR_DTPRSC_POS          = 10;   /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMC_DTCR_SDTRX_POS           = 9;    /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMC_DTCR_DTRX_POS            = 0;    /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMC_SETCxR_UPDATE_POS        = 31;   /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMC_SETCxR_MSTPER_POS        = 7;    /** @brief Master period */
    static const int32_t HRTIM_TIMC_SETCxR_PER_POS           = 2;    /** @brief Timer A period */
    static const int32_t HRTIM_TIMC_SETCxR_RESYNC_POS        = 1;    /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMC_SETCxR_SST_POS           = 0;    /** @brief Software set trigger */
    static const int32_t HRTIM_TIMC_RSTCxR_UPDATE_POS        = 31;   /** @brief UPDATE */
    static const int32_t HRTIM_TIMC_RSTCxR_MSTPER_POS        = 7;    /** @brief MSTPER */
    static const int32_t HRTIM_TIMC_RSTCxR_PER_POS           = 2;    /** @brief PER */
    static const int32_t HRTIM_TIMC_RSTCxR_RESYNC_POS        = 1;    /** @brief RESYNC */
    static const int32_t HRTIM_TIMC_RSTCxR_SRT_POS           = 0;    /** @brief SRT */
    static const int32_t HRTIM_TIMC_RSTCR_MSTPER_POS         = 4;    /** @brief Master timer period */
    static const int32_t HRTIM_TIMC_RSTCR_UPDT_POS           = 1;    /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMC_CHPCR_STRTPW_POS         = 7;    /** @brief STRTPW */
    static const int32_t HRTIM_TIMC_CHPCR_CHPDTY_POS         = 4;    /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMC_CHPCR_CHPFRQ_POS         = 0;    /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMC_CPTxCCR_TE1RST_POS       = 29;   /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMC_CPTxCCR_TE1SET_POS       = 28;   /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMC_CPTxCCR_TD1RST_POS       = 25;   /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMC_CPTxCCR_TD1SET_POS       = 24;   /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMC_CPTxCCR_TB1RST_POS       = 17;   /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMC_CPTxCCR_TB1SET_POS       = 16;   /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMC_CPTxCCR_TA1RST_POS       = 13;   /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMC_CPTxCCR_TA1SET_POS       = 12;   /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMC_CPTxCCR_UDPCPT_POS       = 1;    /** @brief Update capture */
    static const int32_t HRTIM_TIMC_CPTxCCR_SWCPT_POS        = 0;    /** @brief Software capture */
    static const int32_t HRTIM_TIMC_OUTCR_DLYPRT_POS         = 10;   /** @brief Delayed protection */
    static const int32_t HRTIM_TIMC_OUTCR_DLYPRTEN_POS       = 9;    /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMC_OUTCR_DTEN_POS           = 8;    /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMC_FLTCR_FLTLCK_POS         = 31;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMC Register Field Positions ****/

    static const int32_t HRTIM_TIMC_TIMCCR_DELCMPx_POS[5] = {
      [2] = 12,   /** @brief Delayed CMP2 mode */
      [4] = 14,   /** @brief Delayed CMP4 mode */
    };

    static const int32_t HRTIM_TIMC_TIMCISR_OxSTAT_POS[3] = {
      [1] = 18,   /** @brief Output 1 state */
      [2] = 19,   /** @brief Output 2 state */
    };

    static const int32_t HRTIM_TIMC_TIMCISR_RSTXx_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset interrupt flag */
      [2] = 12,   /** @brief Output 2 reset interrupt flag */
    };

    static const int32_t HRTIM_TIMC_TIMCISR_SETXx_POS[3] = {
      [1] = 9,    /** @brief Output 1 set interrupt flag */
      [2] = 11,   /** @brief Output 2 set interrupt flag */
    };

    static const int32_t HRTIM_TIMC_TIMCISR_CPTx_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag */
      [2] = 8,   /** @brief Capture2 interrupt flag */
    };

    static const int32_t HRTIM_TIMC_TIMCISR_CMPx_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag */
      [2] = 1,   /** @brief Compare 2 interrupt flag */
      [3] = 2,   /** @brief Compare 3 interrupt flag */
      [4] = 3,   /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMC_TIMCICR_RSTXxC_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset flag clear */
      [2] = 12,   /** @brief Output 2 reset flag clear */
    };

    static const int32_t HRTIM_TIMC_TIMCICR_SETxXC_POS[3] = {
      [1] = 9,    /** @brief Output 1 set flag clear */
      [2] = 11,   /** @brief Output 2 set flag clear */
    };

    static const int32_t HRTIM_TIMC_TIMCICR_CPTxC_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag clear */
      [2] = 8,   /** @brief Capture2 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMC_TIMCICR_CMPxC_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag clear */
      [2] = 1,   /** @brief Compare 2 interrupt flag clear */
      [3] = 2,   /** @brief Compare 3 interrupt flag clear */
      [4] = 3,   /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMC_TIMCDIER5_RSTXxDE_POS[3] = {
      [1] = 26,   /** @brief RSTx1DE */
      [2] = 28,   /** @brief RSTx2DE */
    };

    static const int32_t HRTIM_TIMC_TIMCDIER5_CPTxDE_POS[3] = {
      [1] = 23,   /** @brief CPT1DE */
      [2] = 24,   /** @brief CPT2DE */
    };

    static const int32_t HRTIM_TIMC_TIMCDIER5_CMPxDE_POS[5] = {
      [1] = 16,   /** @brief CMP1DE */
      [2] = 17,   /** @brief CMP2DE */
      [3] = 18,   /** @brief CMP3DE */
      [4] = 19,   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMC_TIMCDIER5_RSTXxIE_POS[3] = {
      [1] = 10,   /** @brief RSTx1IE */
      [2] = 12,   /** @brief RSTx2IE */
    };

    static const int32_t HRTIM_TIMC_TIMCDIER5_CPTxIE_POS[3] = {
      [1] = 7,   /** @brief CPT1IE */
      [2] = 8,   /** @brief CPT2IE */
    };

    static const int32_t HRTIM_TIMC_TIMCDIER5_CMPxIE_POS[5] = {
      [1] = 0,   /** @brief CMP1IE */
      [2] = 1,   /** @brief CMP2IE */
      [3] = 2,   /** @brief CMP3IE */
      [4] = 3,   /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMC_SETCxR_EXTEVNTx_POS[11] = {
      [1]  = 21,   /** @brief External event 1 */
      [2]  = 22,   /** @brief External event 2 */
      [3]  = 23,   /** @brief External event 3 */
      [4]  = 24,   /** @brief External event 4 */
      [5]  = 25,   /** @brief External event 5 */
      [6]  = 26,   /** @brief External event 6 */
      [7]  = 27,   /** @brief External event 7 */
      [8]  = 28,   /** @brief External event 8 */
      [9]  = 29,   /** @brief External event 9 */
      [10] = 30,   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMC_SETCxR_TIMEVNTx_POS[10] = {
      [1]  = 12,   /** @brief Timer event 1 */
      [2]  = 13,   /** @brief Timer event 2 */
      [3]  = 14,   /** @brief Timer event 3 */
      [4]  = 15,   /** @brief Timer event 4 */
      [5]  = 16,   /** @brief Timer event 5 */
      [6]  = 17,   /** @brief Timer event 6 */
      [7]  = 18,   /** @brief Timer event 7 */
      [8]  = 19,   /** @brief Timer event 8 */
      [9]  = 20,   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMC_SETCxR_MSTCMPx_POS[5] = {
      [1] = 8,    /** @brief Master compare 1 */
      [2] = 9,    /** @brief Master compare 2 */
      [3] = 10,   /** @brief Master compare 3 */
      [4] = 11,   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMC_EEFCR1_EExFLTR_POS[6] = {
      [1] = 1,    /** @brief External event 1 filter */
      [2] = 7,    /** @brief External event 2 filter */
      [3] = 13,   /** @brief External event 3 filter */
      [4] = 19,   /** @brief External event 4 filter */
      [5] = 25,   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMC_EEFCR1_EExLTCH_POS[6] = {
      [1] = 0,    /** @brief External event 1 latch */
      [2] = 6,    /** @brief External event 2 latch */
      [3] = 12,   /** @brief External event 3 latch */
      [4] = 18,   /** @brief External event 4 latch */
      [5] = 24,   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMC_RSTCR_TIMECMPx_POS[5] = {
      [1] = 28,   /** @brief Timer E compare 1 */
      [2] = 29,   /** @brief Timer E compare 2 */
      [4] = 30,   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMC_RSTCR_TIMDCMPx_POS[5] = {
      [1] = 25,   /** @brief Timer D compare 1 */
      [2] = 26,   /** @brief Timer D compare 2 */
      [4] = 27,   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIMC_RSTCR_TIMBCMPx_POS[5] = {
      [1] = 22,   /** @brief Timer B compare 1 */
      [2] = 23,   /** @brief Timer B compare 2 */
      [4] = 24,   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIMC_RSTCR_TIMACMPx_POS[5] = {
      [1] = 19,   /** @brief Timer A compare 1 */
      [2] = 20,   /** @brief Timer A compare 2 */
      [4] = 21,   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIMC_CPTxCCR_TECMPx_POS[3] = {
      [1] = 30,   /** @brief Timer E compare 1 */
      [2] = 31,   /** @brief Timer E compare 2 */
    };

    static const int32_t HRTIM_TIMC_CPTxCCR_TDCMPx_POS[3] = {
      [1] = 26,   /** @brief Timer D compare 1 */
      [2] = 27,   /** @brief Timer D compare 2 */
    };

    static const int32_t HRTIM_TIMC_CPTxCCR_TBCMPx_POS[3] = {
      [1] = 18,   /** @brief Timer B compare 1 */
      [2] = 19,   /** @brief Timer B compare 2 */
    };

    static const int32_t HRTIM_TIMC_CPTxCCR_TACMPx_POS[3] = {
      [1] = 14,   /** @brief Timer A compare 1 */
      [2] = 15,   /** @brief Timer A compare 2 */
    };

    static const int32_t HRTIM_TIMC_CPTxCCR_EXEVxCPT_POS[11] = {
      [1]  = 2,    /** @brief External event 1 capture */
      [2]  = 3,    /** @brief External event 2 capture */
      [3]  = 4,    /** @brief External event 3 capture */
      [4]  = 5,    /** @brief External event 4 capture */
      [5]  = 6,    /** @brief External event 5 capture */
      [6]  = 7,    /** @brief External event 6 capture */
      [7]  = 8,    /** @brief External event 7 capture */
      [8]  = 9,    /** @brief External event 8 capture */
      [9]  = 10,   /** @brief External event 9 capture */
      [10] = 11,   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMC_OUTCR_DIDLx_POS[3] = {
      [1] = 7,    /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 23,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const int32_t HRTIM_TIMC_OUTCR_CHPx_POS[3] = {
      [1] = 6,    /** @brief Output 1 chopper enable */
      [2] = 22,   /** @brief Output 2 chopper enable */
    };

    static const int32_t HRTIM_TIMC_OUTCR_FAULTx_POS[3] = {
      [1] = 4,    /** @brief Output 1 fault state */
      [2] = 20,   /** @brief Output 2 fault state */
    };

    static const int32_t HRTIM_TIMC_OUTCR_IDLESx_POS[3] = {
      [1] = 3,    /** @brief Output 1 idle state */
      [2] = 19,   /** @brief Output 2 idle state */
    };

    static const int32_t HRTIM_TIMC_OUTCR_IDLEMx_POS[3] = {
      [1] = 2,    /** @brief Output 1 idle mode */
      [2] = 18,   /** @brief Output 2 idle mode */
    };

    static const int32_t HRTIM_TIMC_OUTCR_POLx_POS[3] = {
      [1] = 1,    /** @brief Output 1 polarity */
      [2] = 17,   /** @brief Output 2 polarity */
    };

    static const int32_t HRTIM_TIMC_FLTCR_FLTxEN_POS[6] = {
      [1] = 0,   /** @brief Fault 1 enable */
      [2] = 1,   /** @brief Fault 2 enable */
      [3] = 2,   /** @brief Fault 3 enable */
      [4] = 3,   /** @brief Fault 4 enable */
      [5] = 4,   /** @brief Fault 5 enable */
    };

    /**********************************************************************************************
     * @section HRTIM_TIMD Register Information
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMD Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMD_TIMDCR_PTR      = (RW_ uint32_t* const)0x40017600U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMD_TIMDISR_PTR     = (RO_ uint32_t* const)0x40017604U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMD_TIMDICR_PTR     = (RW_ uint32_t* const)0x40017608U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMD_TIMDDIER5_PTR   = (RW_ uint32_t* const)0x4001760CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMD_CNTDR_PTR       = (RW_ uint32_t* const)0x40017610U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMD_PERDR_PTR       = (RW_ uint32_t* const)0x40017614U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMD_REPDR_PTR       = (RW_ uint32_t* const)0x40017618U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMD_CMP1CDR_PTR     = (RW_ uint32_t* const)0x40017620U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMD_DTDR_PTR        = (RW_ uint32_t* const)0x40017638U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMD_EEFDR1_PTR      = (RW_ uint32_t* const)0x4001764CU;   /** @brief Timerx external event filtering register 1 */
    static RW_ uint32_t* const HRTIM_TIMD_EEFDR2_PTR      = (RW_ uint32_t* const)0x40017650U;   /** @brief Timerx external event filtering register 2 */
    static RW_ uint32_t* const HRTIM_TIMD_RSTDR_PTR       = (RW_ uint32_t* const)0x40017654U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMD_CHPDR_PTR       = (RW_ uint32_t* const)0x40017658U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMD_OUTDR_PTR       = (RW_ uint32_t* const)0x40017664U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMD_FLTDR_PTR       = (RW_ uint32_t* const)0x40017668U;   /** @brief Timerx fault register */

    /**** @subsection Enumerated HRTIM_TIMD Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIMD_CMPxDR_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001761CU,   /** @brief Timerx compare 1 register */
      [2] = (RW_ uint32_t* const)0x40017624U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t* const)0x40017628U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t* const)0x4001762CU,   /** @brief Timerx compare 4 register */
    };

    static RO_ uint32_t* const HRTIM_TIMD_CPTxDR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x40017630U,   /** @brief Timerx capture 1 register */
      [2] = (RO_ uint32_t* const)0x40017634U,   /** @brief Timerx capture 2 register */
    };

    static RW_ uint32_t* const HRTIM_TIMD_SETDxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4001763CU,   /** @brief Timerx output1 set register */
      [2] = (RW_ uint32_t* const)0x40017644U,   /** @brief Timerx output2 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMD_RSTDxR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40017640U,   /** @brief Timerx output1 reset register */
      [2] = (RW_ uint32_t* const)0x40017648U,   /** @brief Timerx output2 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMD_CPTxDCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4001765CU,   /** @brief Timerx capture 2 control register */
      [2] = (RW_ uint32_t* const)0x40017660U,   /** @brief CPT2xCR */
    };

    /**** @subsection HRTIM_TIMD Register Reset Values ****/

    static const uint32_t HRTIM_TIMD_TIMDCR_RST      = 0x00000000U;   /** @brief TIMDCR register reset value. */
    static const uint32_t HRTIM_TIMD_TIMDISR_RST     = 0x00000000U;   /** @brief TIMDISR register reset value. */
    static const uint32_t HRTIM_TIMD_TIMDICR_RST     = 0x00000000U;   /** @brief TIMDICR register reset value. */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RST   = 0x00000000U;   /** @brief TIMDDIER5 register reset value. */
    static const uint32_t HRTIM_TIMD_CNTDR_RST       = 0x00000000U;   /** @brief CNTDR register reset value. */
    static const uint32_t HRTIM_TIMD_PERDR_RST       = 0x0000FFFFU;   /** @brief PERDR register reset value. */
    static const uint32_t HRTIM_TIMD_REPDR_RST       = 0x00000000U;   /** @brief REPDR register reset value. */
    static const uint32_t HRTIM_TIMD_CMP1CDR_RST     = 0x00000000U;   /** @brief CMP1CDR register reset value. */
    static const uint32_t HRTIM_TIMD_DTDR_RST        = 0x00000000U;   /** @brief DTDR register reset value. */
    static const uint32_t HRTIM_TIMD_EEFDR1_RST      = 0x00000000U;   /** @brief EEFDR1 register reset value. */
    static const uint32_t HRTIM_TIMD_EEFDR2_RST      = 0x00000000U;   /** @brief EEFDR2 register reset value. */
    static const uint32_t HRTIM_TIMD_RSTDR_RST       = 0x00000000U;   /** @brief RSTDR register reset value. */
    static const uint32_t HRTIM_TIMD_CHPDR_RST       = 0x00000000U;   /** @brief CHPDR register reset value. */
    static const uint32_t HRTIM_TIMD_OUTDR_RST       = 0x00000000U;   /** @brief OUTDR register reset value. */
    static const uint32_t HRTIM_TIMD_FLTDR_RST       = 0x00000000U;   /** @brief FLTDR register reset value. */

    /**** @subsection Enumerated HRTIM_TIMD Register Reset Values ****/

    static const uint32_t HRTIM_TIMD_CMPxDR_RST[5] = {
      [1] = 0x00000000U,   /** @brief CMP1DR register reset value. */
      [2] = 0x00000000U,   /** @brief CMP2DR register reset value. */
      [3] = 0x00000000U,   /** @brief CMP3DR register reset value. */
      [4] = 0x00000000U,   /** @brief CMP4DR register reset value. */
    };

    static const uint32_t HRTIM_TIMD_CPTxDR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1DR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2DR register reset value. */
    };

    static const uint32_t HRTIM_TIMD_SETDxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief SETD1R register reset value. */
      [2] = 0x00000000U,   /** @brief SETD2R register reset value. */
    };

    static const uint32_t HRTIM_TIMD_RSTDxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief RSTD1R register reset value. */
      [2] = 0x00000000U,   /** @brief RSTD2R register reset value. */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1DCR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2DCR register reset value. */
    };

    /**** @subsection Enumerated HRTIM_TIMD Register Value Types ****/

    typedef uint32_t HRTIM_TIMD_TIMDCR_t;      /** @brief TIMDCR register value type. */
    typedef uint32_t HRTIM_TIMD_TIMDISR_t;     /** @brief TIMDISR register value type. */
    typedef uint32_t HRTIM_TIMD_TIMDICR_t;     /** @brief TIMDICR register value type. */
    typedef uint32_t HRTIM_TIMD_TIMDDIER5_t;   /** @brief TIMDDIER5 register value type. */
    typedef uint32_t HRTIM_TIMD_CNTDR_t;       /** @brief CNTDR register value type. */
    typedef uint32_t HRTIM_TIMD_PERDR_t;       /** @brief PERDR register value type. */
    typedef uint32_t HRTIM_TIMD_REPDR_t;       /** @brief REPDR register value type. */
    typedef uint32_t HRTIM_TIMD_CMPxDR_t;      /** @brief CMPxDR register value type. */
    typedef uint32_t HRTIM_TIMD_CMP1CDR_t;     /** @brief CMP1CDR register value type. */
    typedef uint32_t HRTIM_TIMD_CPTxDR_t;      /** @brief CPTxDR register value type. */
    typedef uint32_t HRTIM_TIMD_DTDR_t;        /** @brief DTDR register value type. */
    typedef uint32_t HRTIM_TIMD_SETDxR_t;      /** @brief SETDxR register value type. */
    typedef uint32_t HRTIM_TIMD_RSTDxR_t;      /** @brief RSTDxR register value type. */
    typedef uint32_t HRTIM_TIMD_EEFDR1_t;      /** @brief EEFDR1 register value type. */
    typedef uint32_t HRTIM_TIMD_EEFDR2_t;      /** @brief EEFDR2 register value type. */
    typedef uint32_t HRTIM_TIMD_RSTDR_t;       /** @brief RSTDR register value type. */
    typedef uint32_t HRTIM_TIMD_CHPDR_t;       /** @brief CHPDR register value type. */
    typedef uint32_t HRTIM_TIMD_CPTxDCR_t;     /** @brief CPTxDCR register value type. */
    typedef uint32_t HRTIM_TIMD_OUTDR_t;       /** @brief OUTDR register value type. */
    typedef uint32_t HRTIM_TIMD_FLTDR_t;       /** @brief FLTDR register value type. */

    /**** @subsection Enumerated HRTIM_TIMD Register Pointer Types ****/

    typedef uint32_t* const HRTIM_TIMD_TIMDCR_PTR_t;      /** @brief TIMDCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_TIMDISR_PTR_t;     /** @brief TIMDISR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_TIMDICR_PTR_t;     /** @brief TIMDICR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_TIMDDIER5_PTR_t;   /** @brief TIMDDIER5 register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_CNTDR_PTR_t;       /** @brief CNTDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_PERDR_PTR_t;       /** @brief PERDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_REPDR_PTR_t;       /** @brief REPDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_CMPxDR_PTR_t;      /** @brief CMPxDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_CMP1CDR_PTR_t;     /** @brief CMP1CDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_CPTxDR_PTR_t;      /** @brief CPTxDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_DTDR_PTR_t;        /** @brief DTDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_SETDxR_PTR_t;      /** @brief SETDxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_RSTDxR_PTR_t;      /** @brief RSTDxR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_EEFDR1_PTR_t;      /** @brief EEFDR1 register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_EEFDR2_PTR_t;      /** @brief EEFDR2 register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_RSTDR_PTR_t;       /** @brief RSTDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_CHPDR_PTR_t;       /** @brief CHPDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_CPTxDCR_PTR_t;     /** @brief CPTxDCR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_OUTDR_PTR_t;       /** @brief OUTDR register pointer type. */
    typedef uint32_t* const HRTIM_TIMD_FLTDR_PTR_t;       /** @brief FLTDR register pointer type. */

    /**** @subsection HRTIM_TIMD Register Field Masks ****/

    static const uint32_t HRTIM_TIMD_TIMDCR_UPDGAT_MASK        = 0xF0000000U;   /** @brief Update gating */
    static const uint32_t HRTIM_TIMD_TIMDCR_PREEN_MASK         = 0x08000000U;   /** @brief Preload enable */
    static const uint32_t HRTIM_TIMD_TIMDCR_DACSYNC_MASK       = 0x06000000U;   /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMD_TIMDCR_MSTU_MASK          = 0x01000000U;   /** @brief Master timer update */
    static const uint32_t HRTIM_TIMD_TIMDCR_TEU_MASK           = 0x00800000U;   /** @brief TEU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TDU_MASK           = 0x00400000U;   /** @brief TDU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TCU_MASK           = 0x00200000U;   /** @brief TCU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TBU_MASK           = 0x00100000U;   /** @brief TBU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TXRSTU_MASK        = 0x00040000U;   /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMD_TIMDCR_TXREPU_MASK        = 0x00020000U;   /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMD_TIMDCR_SYNCSTRTX_MASK     = 0x00000800U;   /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMD_TIMDCR_SYNCRSTX_MASK      = 0x00000400U;   /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMD_TIMDCR_PSHPLL_MASK        = 0x00000040U;   /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMD_TIMDCR_HALF_MASK          = 0x00000020U;   /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMD_TIMDCR_RETRIG_MASK        = 0x00000010U;   /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMD_TIMDCR_CONT_MASK          = 0x00000008U;   /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMD_TIMDCR_CK_PSCX_MASK       = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMD_TIMDISR_IPPSTAT_MASK      = 0x00020000U;   /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMD_TIMDISR_CPPSTAT_MASK      = 0x00010000U;   /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMD_TIMDISR_DLYPRT_MASK       = 0x00004000U;   /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_RST_MASK          = 0x00002000U;   /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_UPD_MASK          = 0x00000040U;   /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_REP_MASK          = 0x00000010U;   /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDICR_DLYPRTC_MASK      = 0x00004000U;   /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_RSTC_MASK         = 0x00002000U;   /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_UPDC_MASK         = 0x00000040U;   /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_REPC_MASK         = 0x00000010U;   /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_DLYPRTDE_MASK   = 0x40000000U;   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTDE_MASK      = 0x20000000U;   /** @brief RSTDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SETX2DE_MASK    = 0x08000000U;   /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SET1XDE_MASK    = 0x02000000U;   /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_UPDDE_MASK      = 0x00400000U;   /** @brief UPDDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_REPDE_MASK      = 0x00100000U;   /** @brief REPDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_DLYPRTIE_MASK   = 0x00004000U;   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTIE_MASK      = 0x00002000U;   /** @brief RSTIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SETX2IE_MASK    = 0x00000800U;   /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SET1XIE_MASK    = 0x00000200U;   /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_UPDIE_MASK      = 0x00000040U;   /** @brief UPDIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_REPIE_MASK      = 0x00000010U;   /** @brief REPIE */
    static const uint32_t HRTIM_TIMD_CNTDR_CNTX_MASK           = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMD_PERDR_PERX_MASK           = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMD_REPDR_REPX_MASK           = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMD_CMPxDR_CMP1X_MASK         = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMD_CMP1CDR_REPX_MASK         = 0x00FF0000U;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMD_CMP1CDR_CMP1X_MASK        = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMD_CPTxDR_CPT1X_MASK         = 0x0000FFFFU;   /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMD_DTDR_DTFLKX_MASK          = 0x80000000U;   /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMD_DTDR_DTFSLKX_MASK         = 0x40000000U;   /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMD_DTDR_SDTFX_MASK           = 0x02000000U;   /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMD_DTDR_DTFX_MASK            = 0x01FF0000U;   /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMD_DTDR_DTRLKX_MASK          = 0x00008000U;   /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMD_DTDR_DTRSLKX_MASK         = 0x00004000U;   /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMD_DTDR_DTPRSC_MASK          = 0x00001C00U;   /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMD_DTDR_SDTRX_MASK           = 0x00000200U;   /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMD_DTDR_DTRX_MASK            = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMD_SETDxR_UPDATE_MASK        = 0x80000000U;   /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMD_SETDxR_MSTPER_MASK        = 0x00000080U;   /** @brief Master period */
    static const uint32_t HRTIM_TIMD_SETDxR_PER_MASK           = 0x00000004U;   /** @brief Timer A period */
    static const uint32_t HRTIM_TIMD_SETDxR_RESYNC_MASK        = 0x00000002U;   /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMD_SETDxR_SST_MASK           = 0x00000001U;   /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMD_RSTDxR_UPDATE_MASK        = 0x80000000U;   /** @brief UPDATE */
    static const uint32_t HRTIM_TIMD_RSTDxR_MSTPER_MASK        = 0x00000080U;   /** @brief MSTPER */
    static const uint32_t HRTIM_TIMD_RSTDxR_PER_MASK           = 0x00000004U;   /** @brief PER */
    static const uint32_t HRTIM_TIMD_RSTDxR_RESYNC_MASK        = 0x00000002U;   /** @brief RESYNC */
    static const uint32_t HRTIM_TIMD_RSTDxR_SRT_MASK           = 0x00000001U;   /** @brief SRT */
    static const uint32_t HRTIM_TIMD_RSTDR_MSTPER_MASK         = 0x00000010U;   /** @brief Master timer period */
    static const uint32_t HRTIM_TIMD_RSTDR_UPDT_MASK           = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMD_CHPDR_STRTPW_MASK         = 0x00000780U;   /** @brief STRTPW */
    static const uint32_t HRTIM_TIMD_CHPDR_CHPDTY_MASK         = 0x00000070U;   /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMD_CHPDR_CHPFRQ_MASK         = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TE1RST_MASK       = 0x20000000U;   /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TE1SET_MASK       = 0x10000000U;   /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TC1RST_MASK       = 0x00200000U;   /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TC1SET_MASK       = 0x00100000U;   /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TB1RST_MASK       = 0x00020000U;   /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TB1SET_MASK       = 0x00010000U;   /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TA1RST_MASK       = 0x00002000U;   /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMD_CPTxDCR_TA1SET_MASK       = 0x00001000U;   /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMD_CPTxDCR_UDPCPT_MASK       = 0x00000002U;   /** @brief Update capture */
    static const uint32_t HRTIM_TIMD_CPTxDCR_SWCPT_MASK        = 0x00000001U;   /** @brief Software capture */
    static const uint32_t HRTIM_TIMD_OUTDR_DLYPRT_MASK         = 0x00001C00U;   /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMD_OUTDR_DLYPRTEN_MASK       = 0x00000200U;   /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMD_OUTDR_DTEN_MASK           = 0x00000100U;   /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMD_FLTDR_FLTLCK_MASK         = 0x80000000U;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMD Register Field Masks ****/

    static const uint32_t HRTIM_TIMD_TIMDCR_DELCMPx_MASK[5] = {
      [2] = 0x00003000U,   /** @brief Delayed CMP2 mode */
      [4] = 0x0000C000U,   /** @brief Delayed CMP4 mode */
    };

    static const uint32_t HRTIM_TIMD_TIMDISR_OxSTAT_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Output 1 state */
      [2] = 0x00080000U,   /** @brief Output 2 state */
    };

    static const uint32_t HRTIM_TIMD_TIMDISR_RSTXx_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset interrupt flag */
      [2] = 0x00001000U,   /** @brief Output 2 reset interrupt flag */
    };

    static const uint32_t HRTIM_TIMD_TIMDISR_SETXx_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set interrupt flag */
      [2] = 0x00000800U,   /** @brief Output 2 set interrupt flag */
    };

    static const uint32_t HRTIM_TIMD_TIMDISR_CPTx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag */
    };

    static const uint32_t HRTIM_TIMD_TIMDISR_CMPx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMD_TIMDICR_RSTXxC_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset flag clear */
      [2] = 0x00001000U,   /** @brief Output 2 reset flag clear */
    };

    static const uint32_t HRTIM_TIMD_TIMDICR_SETxXC_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set flag clear */
      [2] = 0x00000800U,   /** @brief Output 2 set flag clear */
    };

    static const uint32_t HRTIM_TIMD_TIMDICR_CPTxC_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag clear */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMD_TIMDICR_CMPxC_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTXxDE_MASK[3] = {
      [1] = 0x04000000U,   /** @brief RSTx1DE */
      [2] = 0x10000000U,   /** @brief RSTx2DE */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_CPTxDE_MASK[3] = {
      [1] = 0x00800000U,   /** @brief CPT1DE */
      [2] = 0x01000000U,   /** @brief CPT2DE */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_CMPxDE_MASK[5] = {
      [1] = 0x00010000U,   /** @brief CMP1DE */
      [2] = 0x00020000U,   /** @brief CMP2DE */
      [3] = 0x00040000U,   /** @brief CMP3DE */
      [4] = 0x00080000U,   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTXxIE_MASK[3] = {
      [1] = 0x00000400U,   /** @brief RSTx1IE */
      [2] = 0x00001000U,   /** @brief RSTx2IE */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_CPTxIE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief CPT1IE */
      [2] = 0x00000100U,   /** @brief CPT2IE */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_CMPxIE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [4] = 0x00000008U,   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMD_SETDxR_EXTEVNTx_MASK[11] = {
      [1]  = 0x00200000U,   /** @brief External event 1 */
      [2]  = 0x00400000U,   /** @brief External event 2 */
      [3]  = 0x00800000U,   /** @brief External event 3 */
      [4]  = 0x01000000U,   /** @brief External event 4 */
      [5]  = 0x02000000U,   /** @brief External event 5 */
      [6]  = 0x04000000U,   /** @brief External event 6 */
      [7]  = 0x08000000U,   /** @brief External event 7 */
      [8]  = 0x10000000U,   /** @brief External event 8 */
      [9]  = 0x20000000U,   /** @brief External event 9 */
      [10] = 0x40000000U,   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMD_SETDxR_TIMEVNTx_MASK[10] = {
      [1]  = 0x00001000U,   /** @brief Timer event 1 */
      [2]  = 0x00002000U,   /** @brief Timer event 2 */
      [3]  = 0x00004000U,   /** @brief Timer event 3 */
      [4]  = 0x00008000U,   /** @brief Timer event 4 */
      [5]  = 0x00010000U,   /** @brief Timer event 5 */
      [6]  = 0x00020000U,   /** @brief Timer event 6 */
      [7]  = 0x00040000U,   /** @brief Timer event 7 */
      [8]  = 0x00080000U,   /** @brief Timer event 8 */
      [9]  = 0x00100000U,   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMD_SETDxR_MSTCMPx_MASK[5] = {
      [1] = 0x00000100U,   /** @brief Master compare 1 */
      [2] = 0x00000200U,   /** @brief Master compare 2 */
      [3] = 0x00000400U,   /** @brief Master compare 3 */
      [4] = 0x00000800U,   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMD_EEFDR1_EExFLTR_MASK[6] = {
      [1] = 0x0000001EU,   /** @brief External event 1 filter */
      [2] = 0x00000780U,   /** @brief External event 2 filter */
      [3] = 0x0001E000U,   /** @brief External event 3 filter */
      [4] = 0x00780000U,   /** @brief External event 4 filter */
      [5] = 0x1E000000U,   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMD_EEFDR1_EExLTCH_MASK[6] = {
      [1] = 0x00000001U,   /** @brief External event 1 latch */
      [2] = 0x00000040U,   /** @brief External event 2 latch */
      [3] = 0x00001000U,   /** @brief External event 3 latch */
      [4] = 0x00040000U,   /** @brief External event 4 latch */
      [5] = 0x01000000U,   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMECMPx_MASK[5] = {
      [1] = 0x10000000U,   /** @brief Timer E compare 1 */
      [2] = 0x20000000U,   /** @brief Timer E compare 2 */
      [4] = 0x40000000U,   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMCCMPx_MASK[5] = {
      [1] = 0x02000000U,   /** @brief Timer C compare 1 */
      [2] = 0x04000000U,   /** @brief Timer C compare 2 */
      [4] = 0x08000000U,   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMBCMPx_MASK[5] = {
      [1] = 0x00400000U,   /** @brief Timer B compare 1 */
      [2] = 0x00800000U,   /** @brief Timer B compare 2 */
      [4] = 0x01000000U,   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMACMPx_MASK[5] = {
      [1] = 0x00080000U,   /** @brief Timer A compare 1 */
      [2] = 0x00100000U,   /** @brief Timer A compare 2 */
      [4] = 0x00200000U,   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_TECMPx_MASK[3] = {
      [1] = 0x40000000U,   /** @brief Timer E compare 1 */
      [2] = 0x80000000U,   /** @brief Timer E compare 2 */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_TCCMPx_MASK[3] = {
      [1] = 0x00400000U,   /** @brief Timer C compare 1 */
      [2] = 0x00800000U,   /** @brief Timer C compare 2 */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_TBCMPx_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Timer B compare 1 */
      [2] = 0x00080000U,   /** @brief Timer B compare 2 */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_TACMPx_MASK[3] = {
      [1] = 0x00004000U,   /** @brief Timer A compare 1 */
      [2] = 0x00008000U,   /** @brief Timer A compare 2 */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_EXEVxCPT_MASK[11] = {
      [1]  = 0x00000004U,   /** @brief External event 1 capture */
      [2]  = 0x00000008U,   /** @brief External event 2 capture */
      [3]  = 0x00000010U,   /** @brief External event 3 capture */
      [4]  = 0x00000020U,   /** @brief External event 4 capture */
      [5]  = 0x00000040U,   /** @brief External event 5 capture */
      [6]  = 0x00000080U,   /** @brief External event 6 capture */
      [7]  = 0x00000100U,   /** @brief External event 7 capture */
      [8]  = 0x00000200U,   /** @brief External event 8 capture */
      [9]  = 0x00000400U,   /** @brief External event 9 capture */
      [10] = 0x00000800U,   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMD_OUTDR_DIDLx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 0x00800000U,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const uint32_t HRTIM_TIMD_OUTDR_CHPx_MASK[3] = {
      [1] = 0x00000040U,   /** @brief Output 1 chopper enable */
      [2] = 0x00400000U,   /** @brief Output 2 chopper enable */
    };

    static const uint32_t HRTIM_TIMD_OUTDR_FAULTx_MASK[3] = {
      [1] = 0x00000030U,   /** @brief Output 1 fault state */
      [2] = 0x00300000U,   /** @brief Output 2 fault state */
    };

    static const uint32_t HRTIM_TIMD_OUTDR_IDLESx_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output 1 idle state */
      [2] = 0x00080000U,   /** @brief Output 2 idle state */
    };

    static const uint32_t HRTIM_TIMD_OUTDR_IDLEMx_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output 1 idle mode */
      [2] = 0x00040000U,   /** @brief Output 2 idle mode */
    };

    static const uint32_t HRTIM_TIMD_OUTDR_POLx_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Output 1 polarity */
      [2] = 0x00020000U,   /** @brief Output 2 polarity */
    };

    static const uint32_t HRTIM_TIMD_FLTDR_FLTxEN_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [5] = 0x00000010U,   /** @brief Fault 5 enable */
    };

    /**** @subsection HRTIM_TIMD Register Field Positions ****/

    static const int32_t HRTIM_TIMD_TIMDCR_UPDGAT_POS        = 28;   /** @brief Update gating */
    static const int32_t HRTIM_TIMD_TIMDCR_PREEN_POS         = 27;   /** @brief Preload enable */
    static const int32_t HRTIM_TIMD_TIMDCR_DACSYNC_POS       = 25;   /** @brief AC synchronization */
    static const int32_t HRTIM_TIMD_TIMDCR_MSTU_POS          = 24;   /** @brief Master timer update */
    static const int32_t HRTIM_TIMD_TIMDCR_TEU_POS           = 23;   /** @brief TEU */
    static const int32_t HRTIM_TIMD_TIMDCR_TDU_POS           = 22;   /** @brief TDU */
    static const int32_t HRTIM_TIMD_TIMDCR_TCU_POS           = 21;   /** @brief TCU */
    static const int32_t HRTIM_TIMD_TIMDCR_TBU_POS           = 20;   /** @brief TBU */
    static const int32_t HRTIM_TIMD_TIMDCR_TXRSTU_POS        = 18;   /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMD_TIMDCR_TXREPU_POS        = 17;   /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMD_TIMDCR_SYNCSTRTX_POS     = 11;   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMD_TIMDCR_SYNCRSTX_POS      = 10;   /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMD_TIMDCR_PSHPLL_POS        = 6;    /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMD_TIMDCR_HALF_POS          = 5;    /** @brief Half mode enable */
    static const int32_t HRTIM_TIMD_TIMDCR_RETRIG_POS        = 4;    /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMD_TIMDCR_CONT_POS          = 3;    /** @brief Continuous mode */
    static const int32_t HRTIM_TIMD_TIMDCR_CK_PSCX_POS       = 0;    /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMD_TIMDISR_IPPSTAT_POS      = 17;   /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMD_TIMDISR_CPPSTAT_POS      = 16;   /** @brief Current push pull status */
    static const int32_t HRTIM_TIMD_TIMDISR_DLYPRT_POS       = 14;   /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMD_TIMDISR_RST_POS          = 13;   /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMD_TIMDISR_UPD_POS          = 6;    /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMD_TIMDISR_REP_POS          = 4;    /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMD_TIMDICR_DLYPRTC_POS      = 14;   /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMD_TIMDICR_RSTC_POS         = 13;   /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMD_TIMDICR_UPDC_POS         = 6;    /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMD_TIMDICR_REPC_POS         = 4;    /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMD_TIMDDIER5_DLYPRTDE_POS   = 30;   /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_RSTDE_POS      = 29;   /** @brief RSTDE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_SETX2DE_POS    = 27;   /** @brief SETx2DE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_SET1XDE_POS    = 25;   /** @brief SET1xDE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_UPDDE_POS      = 22;   /** @brief UPDDE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_REPDE_POS      = 20;   /** @brief REPDE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_DLYPRTIE_POS   = 14;   /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_RSTIE_POS      = 13;   /** @brief RSTIE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_SETX2IE_POS    = 11;   /** @brief SETx2IE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_SET1XIE_POS    = 9;    /** @brief SET1xIE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_UPDIE_POS      = 6;    /** @brief UPDIE */
    static const int32_t HRTIM_TIMD_TIMDDIER5_REPIE_POS      = 4;    /** @brief REPIE */
    static const int32_t HRTIM_TIMD_CNTDR_CNTX_POS           = 0;    /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMD_PERDR_PERX_POS           = 0;    /** @brief Timerx period value */
    static const int32_t HRTIM_TIMD_REPDR_REPX_POS           = 0;    /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMD_CMPxDR_CMP1X_POS         = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMD_CMP1CDR_REPX_POS         = 16;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMD_CMP1CDR_CMP1X_POS        = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMD_CPTxDR_CPT1X_POS         = 0;    /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMD_DTDR_DTFLKX_POS          = 31;   /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMD_DTDR_DTFSLKX_POS         = 30;   /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMD_DTDR_SDTFX_POS           = 25;   /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMD_DTDR_DTFX_POS            = 16;   /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMD_DTDR_DTRLKX_POS          = 15;   /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMD_DTDR_DTRSLKX_POS         = 14;   /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMD_DTDR_DTPRSC_POS          = 10;   /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMD_DTDR_SDTRX_POS           = 9;    /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMD_DTDR_DTRX_POS            = 0;    /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMD_SETDxR_UPDATE_POS        = 31;   /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMD_SETDxR_MSTPER_POS        = 7;    /** @brief Master period */
    static const int32_t HRTIM_TIMD_SETDxR_PER_POS           = 2;    /** @brief Timer A period */
    static const int32_t HRTIM_TIMD_SETDxR_RESYNC_POS        = 1;    /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMD_SETDxR_SST_POS           = 0;    /** @brief Software set trigger */
    static const int32_t HRTIM_TIMD_RSTDxR_UPDATE_POS        = 31;   /** @brief UPDATE */
    static const int32_t HRTIM_TIMD_RSTDxR_MSTPER_POS        = 7;    /** @brief MSTPER */
    static const int32_t HRTIM_TIMD_RSTDxR_PER_POS           = 2;    /** @brief PER */
    static const int32_t HRTIM_TIMD_RSTDxR_RESYNC_POS        = 1;    /** @brief RESYNC */
    static const int32_t HRTIM_TIMD_RSTDxR_SRT_POS           = 0;    /** @brief SRT */
    static const int32_t HRTIM_TIMD_RSTDR_MSTPER_POS         = 4;    /** @brief Master timer period */
    static const int32_t HRTIM_TIMD_RSTDR_UPDT_POS           = 1;    /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMD_CHPDR_STRTPW_POS         = 7;    /** @brief STRTPW */
    static const int32_t HRTIM_TIMD_CHPDR_CHPDTY_POS         = 4;    /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMD_CHPDR_CHPFRQ_POS         = 0;    /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMD_CPTxDCR_TE1RST_POS       = 29;   /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMD_CPTxDCR_TE1SET_POS       = 28;   /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMD_CPTxDCR_TC1RST_POS       = 21;   /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMD_CPTxDCR_TC1SET_POS       = 20;   /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMD_CPTxDCR_TB1RST_POS       = 17;   /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMD_CPTxDCR_TB1SET_POS       = 16;   /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMD_CPTxDCR_TA1RST_POS       = 13;   /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMD_CPTxDCR_TA1SET_POS       = 12;   /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMD_CPTxDCR_UDPCPT_POS       = 1;    /** @brief Update capture */
    static const int32_t HRTIM_TIMD_CPTxDCR_SWCPT_POS        = 0;    /** @brief Software capture */
    static const int32_t HRTIM_TIMD_OUTDR_DLYPRT_POS         = 10;   /** @brief Delayed protection */
    static const int32_t HRTIM_TIMD_OUTDR_DLYPRTEN_POS       = 9;    /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMD_OUTDR_DTEN_POS           = 8;    /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMD_FLTDR_FLTLCK_POS         = 31;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIMD Register Field Positions ****/

    static const int32_t HRTIM_TIMD_TIMDCR_DELCMPx_POS[5] = {
      [2] = 12,   /** @brief Delayed CMP2 mode */
      [4] = 14,   /** @brief Delayed CMP4 mode */
    };

    static const int32_t HRTIM_TIMD_TIMDISR_OxSTAT_POS[3] = {
      [1] = 18,   /** @brief Output 1 state */
      [2] = 19,   /** @brief Output 2 state */
    };

    static const int32_t HRTIM_TIMD_TIMDISR_RSTXx_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset interrupt flag */
      [2] = 12,   /** @brief Output 2 reset interrupt flag */
    };

    static const int32_t HRTIM_TIMD_TIMDISR_SETXx_POS[3] = {
      [1] = 9,    /** @brief Output 1 set interrupt flag */
      [2] = 11,   /** @brief Output 2 set interrupt flag */
    };

    static const int32_t HRTIM_TIMD_TIMDISR_CPTx_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag */
      [2] = 8,   /** @brief Capture2 interrupt flag */
    };

    static const int32_t HRTIM_TIMD_TIMDISR_CMPx_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag */
      [2] = 1,   /** @brief Compare 2 interrupt flag */
      [3] = 2,   /** @brief Compare 3 interrupt flag */
      [4] = 3,   /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMD_TIMDICR_RSTXxC_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset flag clear */
      [2] = 12,   /** @brief Output 2 reset flag clear */
    };

    static const int32_t HRTIM_TIMD_TIMDICR_SETxXC_POS[3] = {
      [1] = 9,    /** @brief Output 1 set flag clear */
      [2] = 11,   /** @brief Output 2 set flag clear */
    };

    static const int32_t HRTIM_TIMD_TIMDICR_CPTxC_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag clear */
      [2] = 8,   /** @brief Capture2 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMD_TIMDICR_CMPxC_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag clear */
      [2] = 1,   /** @brief Compare 2 interrupt flag clear */
      [3] = 2,   /** @brief Compare 3 interrupt flag clear */
      [4] = 3,   /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMD_TIMDDIER5_RSTXxDE_POS[3] = {
      [1] = 26,   /** @brief RSTx1DE */
      [2] = 28,   /** @brief RSTx2DE */
    };

    static const int32_t HRTIM_TIMD_TIMDDIER5_CPTxDE_POS[3] = {
      [1] = 23,   /** @brief CPT1DE */
      [2] = 24,   /** @brief CPT2DE */
    };

    static const int32_t HRTIM_TIMD_TIMDDIER5_CMPxDE_POS[5] = {
      [1] = 16,   /** @brief CMP1DE */
      [2] = 17,   /** @brief CMP2DE */
      [3] = 18,   /** @brief CMP3DE */
      [4] = 19,   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMD_TIMDDIER5_RSTXxIE_POS[3] = {
      [1] = 10,   /** @brief RSTx1IE */
      [2] = 12,   /** @brief RSTx2IE */
    };

    static const int32_t HRTIM_TIMD_TIMDDIER5_CPTxIE_POS[3] = {
      [1] = 7,   /** @brief CPT1IE */
      [2] = 8,   /** @brief CPT2IE */
    };

    static const int32_t HRTIM_TIMD_TIMDDIER5_CMPxIE_POS[5] = {
      [1] = 0,   /** @brief CMP1IE */
      [2] = 1,   /** @brief CMP2IE */
      [3] = 2,   /** @brief CMP3IE */
      [4] = 3,   /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMD_SETDxR_EXTEVNTx_POS[11] = {
      [1]  = 21,   /** @brief External event 1 */
      [2]  = 22,   /** @brief External event 2 */
      [3]  = 23,   /** @brief External event 3 */
      [4]  = 24,   /** @brief External event 4 */
      [5]  = 25,   /** @brief External event 5 */
      [6]  = 26,   /** @brief External event 6 */
      [7]  = 27,   /** @brief External event 7 */
      [8]  = 28,   /** @brief External event 8 */
      [9]  = 29,   /** @brief External event 9 */
      [10] = 30,   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMD_SETDxR_TIMEVNTx_POS[10] = {
      [1]  = 12,   /** @brief Timer event 1 */
      [2]  = 13,   /** @brief Timer event 2 */
      [3]  = 14,   /** @brief Timer event 3 */
      [4]  = 15,   /** @brief Timer event 4 */
      [5]  = 16,   /** @brief Timer event 5 */
      [6]  = 17,   /** @brief Timer event 6 */
      [7]  = 18,   /** @brief Timer event 7 */
      [8]  = 19,   /** @brief Timer event 8 */
      [9]  = 20,   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMD_SETDxR_MSTCMPx_POS[5] = {
      [1] = 8,    /** @brief Master compare 1 */
      [2] = 9,    /** @brief Master compare 2 */
      [3] = 10,   /** @brief Master compare 3 */
      [4] = 11,   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMD_EEFDR1_EExFLTR_POS[6] = {
      [1] = 1,    /** @brief External event 1 filter */
      [2] = 7,    /** @brief External event 2 filter */
      [3] = 13,   /** @brief External event 3 filter */
      [4] = 19,   /** @brief External event 4 filter */
      [5] = 25,   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMD_EEFDR1_EExLTCH_POS[6] = {
      [1] = 0,    /** @brief External event 1 latch */
      [2] = 6,    /** @brief External event 2 latch */
      [3] = 12,   /** @brief External event 3 latch */
      [4] = 18,   /** @brief External event 4 latch */
      [5] = 24,   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMD_RSTDR_TIMECMPx_POS[5] = {
      [1] = 28,   /** @brief Timer E compare 1 */
      [2] = 29,   /** @brief Timer E compare 2 */
      [4] = 30,   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMD_RSTDR_TIMCCMPx_POS[5] = {
      [1] = 25,   /** @brief Timer C compare 1 */
      [2] = 26,   /** @brief Timer C compare 2 */
      [4] = 27,   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIMD_RSTDR_TIMBCMPx_POS[5] = {
      [1] = 22,   /** @brief Timer B compare 1 */
      [2] = 23,   /** @brief Timer B compare 2 */
      [4] = 24,   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIMD_RSTDR_TIMACMPx_POS[5] = {
      [1] = 19,   /** @brief Timer A compare 1 */
      [2] = 20,   /** @brief Timer A compare 2 */
      [4] = 21,   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIMD_CPTxDCR_TECMPx_POS[3] = {
      [1] = 30,   /** @brief Timer E compare 1 */
      [2] = 31,   /** @brief Timer E compare 2 */
    };

    static const int32_t HRTIM_TIMD_CPTxDCR_TCCMPx_POS[3] = {
      [1] = 22,   /** @brief Timer C compare 1 */
      [2] = 23,   /** @brief Timer C compare 2 */
    };

    static const int32_t HRTIM_TIMD_CPTxDCR_TBCMPx_POS[3] = {
      [1] = 18,   /** @brief Timer B compare 1 */
      [2] = 19,   /** @brief Timer B compare 2 */
    };

    static const int32_t HRTIM_TIMD_CPTxDCR_TACMPx_POS[3] = {
      [1] = 14,   /** @brief Timer A compare 1 */
      [2] = 15,   /** @brief Timer A compare 2 */
    };

    static const int32_t HRTIM_TIMD_CPTxDCR_EXEVxCPT_POS[11] = {
      [1]  = 2,    /** @brief External event 1 capture */
      [2]  = 3,    /** @brief External event 2 capture */
      [3]  = 4,    /** @brief External event 3 capture */
      [4]  = 5,    /** @brief External event 4 capture */
      [5]  = 6,    /** @brief External event 5 capture */
      [6]  = 7,    /** @brief External event 6 capture */
      [7]  = 8,    /** @brief External event 7 capture */
      [8]  = 9,    /** @brief External event 8 capture */
      [9]  = 10,   /** @brief External event 9 capture */
      [10] = 11,   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMD_OUTDR_DIDLx_POS[3] = {
      [1] = 7,    /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 23,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const int32_t HRTIM_TIMD_OUTDR_CHPx_POS[3] = {
      [1] = 6,    /** @brief Output 1 chopper enable */
      [2] = 22,   /** @brief Output 2 chopper enable */
    };

    static const int32_t HRTIM_TIMD_OUTDR_FAULTx_POS[3] = {
      [1] = 4,    /** @brief Output 1 fault state */
      [2] = 20,   /** @brief Output 2 fault state */
    };

    static const int32_t HRTIM_TIMD_OUTDR_IDLESx_POS[3] = {
      [1] = 3,    /** @brief Output 1 idle state */
      [2] = 19,   /** @brief Output 2 idle state */
    };

    static const int32_t HRTIM_TIMD_OUTDR_IDLEMx_POS[3] = {
      [1] = 2,    /** @brief Output 1 idle mode */
      [2] = 18,   /** @brief Output 2 idle mode */
    };

    static const int32_t HRTIM_TIMD_OUTDR_POLx_POS[3] = {
      [1] = 1,    /** @brief Output 1 polarity */
      [2] = 17,   /** @brief Output 2 polarity */
    };

    static const int32_t HRTIM_TIMD_FLTDR_FLTxEN_POS[6] = {
      [1] = 0,   /** @brief Fault 1 enable */
      [2] = 1,   /** @brief Fault 2 enable */
      [3] = 2,   /** @brief Fault 3 enable */
      [4] = 3,   /** @brief Fault 4 enable */
      [5] = 4,   /** @brief Fault 5 enable */
    };

    /**********************************************************************************************
     * @section HRTIM_TIME Register Information
     **********************************************************************************************/

    /**** @subsection HRTIM_TIME Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIME_TIMECR_PTR      = (RW_ uint32_t* const)0x40017680U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIME_TIMEISR_PTR     = (RO_ uint32_t* const)0x40017684U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIME_TIMEICR_PTR     = (RW_ uint32_t* const)0x40017688U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIME_TIMEDIER5_PTR   = (RW_ uint32_t* const)0x4001768CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIME_CNTER_PTR       = (RW_ uint32_t* const)0x40017690U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIME_PERER_PTR       = (RW_ uint32_t* const)0x40017694U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIME_REPER_PTR       = (RW_ uint32_t* const)0x40017698U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIME_CMP1CER_PTR     = (RW_ uint32_t* const)0x400176A0U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIME_DTER_PTR        = (RW_ uint32_t* const)0x400176B8U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIME_EEFER1_PTR      = (RW_ uint32_t* const)0x400176CCU;   /** @brief Timerx external event filtering register 1 */
    static RW_ uint32_t* const HRTIM_TIME_EEFER2_PTR      = (RW_ uint32_t* const)0x400176D0U;   /** @brief Timerx external event filtering register 2 */
    static RW_ uint32_t* const HRTIM_TIME_RSTER_PTR       = (RW_ uint32_t* const)0x400176D4U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIME_CHPER_PTR       = (RW_ uint32_t* const)0x400176D8U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIME_OUTER_PTR       = (RW_ uint32_t* const)0x400176E4U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIME_FLTER_PTR       = (RW_ uint32_t* const)0x400176E8U;   /** @brief Timerx fault register */

    /**** @subsection Enumerated HRTIM_TIME Register Pointers ****/

    static RW_ uint32_t* const HRTIM_TIME_CMPxER_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x4001769CU,   /** @brief Timerx compare 1 register */
      [2] = (RW_ uint32_t* const)0x400176A4U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t* const)0x400176A8U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t* const)0x400176ACU,   /** @brief Timerx compare 4 register */
    };

    static RO_ uint32_t* const HRTIM_TIME_CPTxER_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x400176B0U,   /** @brief Timerx capture 1 register */
      [2] = (RO_ uint32_t* const)0x400176B4U,   /** @brief Timerx capture 2 register */
    };

    static RW_ uint32_t* const HRTIM_TIME_SETExR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400176BCU,   /** @brief Timerx output1 set register */
      [2] = (RW_ uint32_t* const)0x400176C4U,   /** @brief Timerx output2 set register */
    };

    static RW_ uint32_t* const HRTIM_TIME_RSTExR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400176C0U,   /** @brief Timerx output1 reset register */
      [2] = (RW_ uint32_t* const)0x400176C8U,   /** @brief Timerx output2 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIME_CPTxECR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x400176DCU,   /** @brief Timerx capture 2 control register */
      [2] = (RW_ uint32_t* const)0x400176E0U,   /** @brief CPT2xCR */
    };

    /**** @subsection HRTIM_TIME Register Reset Values ****/

    static const uint32_t HRTIM_TIME_TIMECR_RST      = 0x00000000U;   /** @brief TIMECR register reset value. */
    static const uint32_t HRTIM_TIME_TIMEISR_RST     = 0x00000000U;   /** @brief TIMEISR register reset value. */
    static const uint32_t HRTIM_TIME_TIMEICR_RST     = 0x00000000U;   /** @brief TIMEICR register reset value. */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RST   = 0x00000000U;   /** @brief TIMEDIER5 register reset value. */
    static const uint32_t HRTIM_TIME_CNTER_RST       = 0x00000000U;   /** @brief CNTER register reset value. */
    static const uint32_t HRTIM_TIME_PERER_RST       = 0x0000FFFFU;   /** @brief PERER register reset value. */
    static const uint32_t HRTIM_TIME_REPER_RST       = 0x00000000U;   /** @brief REPER register reset value. */
    static const uint32_t HRTIM_TIME_CMP1CER_RST     = 0x00000000U;   /** @brief CMP1CER register reset value. */
    static const uint32_t HRTIM_TIME_DTER_RST        = 0x00000000U;   /** @brief DTER register reset value. */
    static const uint32_t HRTIM_TIME_EEFER1_RST      = 0x00000000U;   /** @brief EEFER1 register reset value. */
    static const uint32_t HRTIM_TIME_EEFER2_RST      = 0x00000000U;   /** @brief EEFER2 register reset value. */
    static const uint32_t HRTIM_TIME_RSTER_RST       = 0x00000000U;   /** @brief RSTER register reset value. */
    static const uint32_t HRTIM_TIME_CHPER_RST       = 0x00000000U;   /** @brief CHPER register reset value. */
    static const uint32_t HRTIM_TIME_OUTER_RST       = 0x00000000U;   /** @brief OUTER register reset value. */
    static const uint32_t HRTIM_TIME_FLTER_RST       = 0x00000000U;   /** @brief FLTER register reset value. */

    /**** @subsection Enumerated HRTIM_TIME Register Reset Values ****/

    static const uint32_t HRTIM_TIME_CMPxER_RST[5] = {
      [1] = 0x00000000U,   /** @brief CMP1ER register reset value. */
      [2] = 0x00000000U,   /** @brief CMP2ER register reset value. */
      [3] = 0x00000000U,   /** @brief CMP3ER register reset value. */
      [4] = 0x00000000U,   /** @brief CMP4ER register reset value. */
    };

    static const uint32_t HRTIM_TIME_CPTxER_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1ER register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2ER register reset value. */
    };

    static const uint32_t HRTIM_TIME_SETExR_RST[3] = {
      [1] = 0x00000000U,   /** @brief SETE1R register reset value. */
      [2] = 0x00000000U,   /** @brief SETE2R register reset value. */
    };

    static const uint32_t HRTIM_TIME_RSTExR_RST[3] = {
      [1] = 0x00000000U,   /** @brief RSTE1R register reset value. */
      [2] = 0x00000000U,   /** @brief RSTE2R register reset value. */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_RST[3] = {
      [1] = 0x00000000U,   /** @brief CPT1ECR register reset value. */
      [2] = 0x00000000U,   /** @brief CPT2ECR register reset value. */
    };

    /**** @subsection Enumerated HRTIM_TIME Register Value Types ****/

    typedef uint32_t HRTIM_TIME_TIMECR_t;      /** @brief TIMECR register value type. */
    typedef uint32_t HRTIM_TIME_TIMEISR_t;     /** @brief TIMEISR register value type. */
    typedef uint32_t HRTIM_TIME_TIMEICR_t;     /** @brief TIMEICR register value type. */
    typedef uint32_t HRTIM_TIME_TIMEDIER5_t;   /** @brief TIMEDIER5 register value type. */
    typedef uint32_t HRTIM_TIME_CNTER_t;       /** @brief CNTER register value type. */
    typedef uint32_t HRTIM_TIME_PERER_t;       /** @brief PERER register value type. */
    typedef uint32_t HRTIM_TIME_REPER_t;       /** @brief REPER register value type. */
    typedef uint32_t HRTIM_TIME_CMPxER_t;      /** @brief CMPxER register value type. */
    typedef uint32_t HRTIM_TIME_CMP1CER_t;     /** @brief CMP1CER register value type. */
    typedef uint32_t HRTIM_TIME_CPTxER_t;      /** @brief CPTxER register value type. */
    typedef uint32_t HRTIM_TIME_DTER_t;        /** @brief DTER register value type. */
    typedef uint32_t HRTIM_TIME_SETExR_t;      /** @brief SETExR register value type. */
    typedef uint32_t HRTIM_TIME_RSTExR_t;      /** @brief RSTExR register value type. */
    typedef uint32_t HRTIM_TIME_EEFER1_t;      /** @brief EEFER1 register value type. */
    typedef uint32_t HRTIM_TIME_EEFER2_t;      /** @brief EEFER2 register value type. */
    typedef uint32_t HRTIM_TIME_RSTER_t;       /** @brief RSTER register value type. */
    typedef uint32_t HRTIM_TIME_CHPER_t;       /** @brief CHPER register value type. */
    typedef uint32_t HRTIM_TIME_CPTxECR_t;     /** @brief CPTxECR register value type. */
    typedef uint32_t HRTIM_TIME_OUTER_t;       /** @brief OUTER register value type. */
    typedef uint32_t HRTIM_TIME_FLTER_t;       /** @brief FLTER register value type. */

    /**** @subsection Enumerated HRTIM_TIME Register Pointer Types ****/

    typedef uint32_t* const HRTIM_TIME_TIMECR_PTR_t;      /** @brief TIMECR register pointer type. */
    typedef uint32_t* const HRTIM_TIME_TIMEISR_PTR_t;     /** @brief TIMEISR register pointer type. */
    typedef uint32_t* const HRTIM_TIME_TIMEICR_PTR_t;     /** @brief TIMEICR register pointer type. */
    typedef uint32_t* const HRTIM_TIME_TIMEDIER5_PTR_t;   /** @brief TIMEDIER5 register pointer type. */
    typedef uint32_t* const HRTIM_TIME_CNTER_PTR_t;       /** @brief CNTER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_PERER_PTR_t;       /** @brief PERER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_REPER_PTR_t;       /** @brief REPER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_CMPxER_PTR_t;      /** @brief CMPxER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_CMP1CER_PTR_t;     /** @brief CMP1CER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_CPTxER_PTR_t;      /** @brief CPTxER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_DTER_PTR_t;        /** @brief DTER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_SETExR_PTR_t;      /** @brief SETExR register pointer type. */
    typedef uint32_t* const HRTIM_TIME_RSTExR_PTR_t;      /** @brief RSTExR register pointer type. */
    typedef uint32_t* const HRTIM_TIME_EEFER1_PTR_t;      /** @brief EEFER1 register pointer type. */
    typedef uint32_t* const HRTIM_TIME_EEFER2_PTR_t;      /** @brief EEFER2 register pointer type. */
    typedef uint32_t* const HRTIM_TIME_RSTER_PTR_t;       /** @brief RSTER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_CHPER_PTR_t;       /** @brief CHPER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_CPTxECR_PTR_t;     /** @brief CPTxECR register pointer type. */
    typedef uint32_t* const HRTIM_TIME_OUTER_PTR_t;       /** @brief OUTER register pointer type. */
    typedef uint32_t* const HRTIM_TIME_FLTER_PTR_t;       /** @brief FLTER register pointer type. */

    /**** @subsection HRTIM_TIME Register Field Masks ****/

    static const uint32_t HRTIM_TIME_TIMECR_UPDGAT_MASK        = 0xF0000000U;   /** @brief Update gating */
    static const uint32_t HRTIM_TIME_TIMECR_PREEN_MASK         = 0x08000000U;   /** @brief Preload enable */
    static const uint32_t HRTIM_TIME_TIMECR_DACSYNC_MASK       = 0x06000000U;   /** @brief AC synchronization */
    static const uint32_t HRTIM_TIME_TIMECR_MSTU_MASK          = 0x01000000U;   /** @brief Master timer update */
    static const uint32_t HRTIM_TIME_TIMECR_TEU_MASK           = 0x00800000U;   /** @brief TEU */
    static const uint32_t HRTIM_TIME_TIMECR_TDU_MASK           = 0x00400000U;   /** @brief TDU */
    static const uint32_t HRTIM_TIME_TIMECR_TCU_MASK           = 0x00200000U;   /** @brief TCU */
    static const uint32_t HRTIM_TIME_TIMECR_TBU_MASK           = 0x00100000U;   /** @brief TBU */
    static const uint32_t HRTIM_TIME_TIMECR_TXRSTU_MASK        = 0x00040000U;   /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIME_TIMECR_TXREPU_MASK        = 0x00020000U;   /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIME_TIMECR_SYNCSTRTX_MASK     = 0x00000800U;   /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIME_TIMECR_SYNCRSTX_MASK      = 0x00000400U;   /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIME_TIMECR_PSHPLL_MASK        = 0x00000040U;   /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIME_TIMECR_HALF_MASK          = 0x00000020U;   /** @brief Half mode enable */
    static const uint32_t HRTIM_TIME_TIMECR_RETRIG_MASK        = 0x00000010U;   /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIME_TIMECR_CONT_MASK          = 0x00000008U;   /** @brief Continuous mode */
    static const uint32_t HRTIM_TIME_TIMECR_CK_PSCX_MASK       = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIME_TIMEISR_IPPSTAT_MASK      = 0x00020000U;   /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIME_TIMEISR_CPPSTAT_MASK      = 0x00010000U;   /** @brief Current push pull status */
    static const uint32_t HRTIM_TIME_TIMEISR_DLYPRT_MASK       = 0x00004000U;   /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIME_TIMEISR_RST_MASK          = 0x00002000U;   /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_UPD_MASK          = 0x00000040U;   /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_REP_MASK          = 0x00000010U;   /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEICR_DLYPRTC_MASK      = 0x00004000U;   /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_RSTC_MASK         = 0x00002000U;   /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_UPDC_MASK         = 0x00000040U;   /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_REPC_MASK         = 0x00000010U;   /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEDIER5_DLYPRTDE_MASK   = 0x40000000U;   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTDE_MASK      = 0x20000000U;   /** @brief RSTDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SETX2DE_MASK    = 0x08000000U;   /** @brief SETx2DE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SET1XDE_MASK    = 0x02000000U;   /** @brief SET1xDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_UPDDE_MASK      = 0x00400000U;   /** @brief UPDDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_REPDE_MASK      = 0x00100000U;   /** @brief REPDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_DLYPRTIE_MASK   = 0x00004000U;   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTIE_MASK      = 0x00002000U;   /** @brief RSTIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SETX2IE_MASK    = 0x00000800U;   /** @brief SETx2IE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SET1XIE_MASK    = 0x00000200U;   /** @brief SET1xIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_UPDIE_MASK      = 0x00000040U;   /** @brief UPDIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_REPIE_MASK      = 0x00000010U;   /** @brief REPIE */
    static const uint32_t HRTIM_TIME_CNTER_CNTX_MASK           = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIME_PERER_PERX_MASK           = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIME_REPER_REPX_MASK           = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIME_CMPxER_CMP1X_MASK         = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIME_CMP1CER_REPX_MASK         = 0x00FF0000U;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIME_CMP1CER_CMP1X_MASK        = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIME_CPTxER_CPT1X_MASK         = 0x0000FFFFU;   /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIME_DTER_DTFLKX_MASK          = 0x80000000U;   /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIME_DTER_DTFSLKX_MASK         = 0x40000000U;   /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIME_DTER_SDTFX_MASK           = 0x02000000U;   /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIME_DTER_DTFX_MASK            = 0x01FF0000U;   /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIME_DTER_DTRLKX_MASK          = 0x00008000U;   /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIME_DTER_DTRSLKX_MASK         = 0x00004000U;   /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIME_DTER_DTPRSC_MASK          = 0x00001C00U;   /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIME_DTER_SDTRX_MASK           = 0x00000200U;   /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIME_DTER_DTRX_MASK            = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIME_SETExR_UPDATE_MASK        = 0x80000000U;   /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIME_SETExR_MSTPER_MASK        = 0x00000080U;   /** @brief Master period */
    static const uint32_t HRTIM_TIME_SETExR_PER_MASK           = 0x00000004U;   /** @brief Timer A period */
    static const uint32_t HRTIM_TIME_SETExR_RESYNC_MASK        = 0x00000002U;   /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIME_SETExR_SST_MASK           = 0x00000001U;   /** @brief Software set trigger */
    static const uint32_t HRTIM_TIME_RSTExR_UPDATE_MASK        = 0x80000000U;   /** @brief UPDATE */
    static const uint32_t HRTIM_TIME_RSTExR_MSTPER_MASK        = 0x00000080U;   /** @brief MSTPER */
    static const uint32_t HRTIM_TIME_RSTExR_PER_MASK           = 0x00000004U;   /** @brief PER */
    static const uint32_t HRTIM_TIME_RSTExR_RESYNC_MASK        = 0x00000002U;   /** @brief RESYNC */
    static const uint32_t HRTIM_TIME_RSTExR_SRT_MASK           = 0x00000001U;   /** @brief SRT */
    static const uint32_t HRTIM_TIME_RSTER_MSTPER_MASK         = 0x00000010U;   /** @brief Master timer period */
    static const uint32_t HRTIM_TIME_RSTER_UPDT_MASK           = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIME_CHPER_STRTPW_MASK         = 0x00000780U;   /** @brief STRTPW */
    static const uint32_t HRTIM_TIME_CHPER_CHPDTY_MASK         = 0x00000070U;   /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIME_CHPER_CHPFRQ_MASK         = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIME_CPTxECR_TD1RST_MASK       = 0x02000000U;   /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIME_CPTxECR_TD1SET_MASK       = 0x01000000U;   /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIME_CPTxECR_TC1RST_MASK       = 0x00200000U;   /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIME_CPTxECR_TC1SET_MASK       = 0x00100000U;   /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIME_CPTxECR_TB1RST_MASK       = 0x00020000U;   /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIME_CPTxECR_TB1SET_MASK       = 0x00010000U;   /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIME_CPTxECR_TA1RST_MASK       = 0x00002000U;   /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIME_CPTxECR_TA1SET_MASK       = 0x00001000U;   /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIME_CPTxECR_UDPCPT_MASK       = 0x00000002U;   /** @brief Update capture */
    static const uint32_t HRTIM_TIME_CPTxECR_SWCPT_MASK        = 0x00000001U;   /** @brief Software capture */
    static const uint32_t HRTIM_TIME_OUTER_DLYPRT_MASK         = 0x00001C00U;   /** @brief Delayed protection */
    static const uint32_t HRTIM_TIME_OUTER_DLYPRTEN_MASK       = 0x00000200U;   /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIME_OUTER_DTEN_MASK           = 0x00000100U;   /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIME_FLTER_FLTLCK_MASK         = 0x80000000U;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIME Register Field Masks ****/

    static const uint32_t HRTIM_TIME_TIMECR_DELCMPx_MASK[5] = {
      [2] = 0x00003000U,   /** @brief Delayed CMP2 mode */
      [4] = 0x0000C000U,   /** @brief Delayed CMP4 mode */
    };

    static const uint32_t HRTIM_TIME_TIMEISR_OxSTAT_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Output 1 state */
      [2] = 0x00080000U,   /** @brief Output 2 state */
    };

    static const uint32_t HRTIM_TIME_TIMEISR_RSTXx_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset interrupt flag */
      [2] = 0x00001000U,   /** @brief Output 2 reset interrupt flag */
    };

    static const uint32_t HRTIM_TIME_TIMEISR_SETXx_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set interrupt flag */
      [2] = 0x00000800U,   /** @brief Output 2 set interrupt flag */
    };

    static const uint32_t HRTIM_TIME_TIMEISR_CPTx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag */
    };

    static const uint32_t HRTIM_TIME_TIMEISR_CMPx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIME_TIMEICR_RSTXxC_MASK[3] = {
      [1] = 0x00000400U,   /** @brief Output 1 reset flag clear */
      [2] = 0x00001000U,   /** @brief Output 2 reset flag clear */
    };

    static const uint32_t HRTIM_TIME_TIMEICR_SETxXC_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Output 1 set flag clear */
      [2] = 0x00000800U,   /** @brief Output 2 set flag clear */
    };

    static const uint32_t HRTIM_TIME_TIMEICR_CPTxC_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Capture1 interrupt flag clear */
      [2] = 0x00000100U,   /** @brief Capture2 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIME_TIMEICR_CMPxC_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTXxDE_MASK[3] = {
      [1] = 0x04000000U,   /** @brief RSTx1DE */
      [2] = 0x10000000U,   /** @brief RSTx2DE */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_CPTxDE_MASK[3] = {
      [1] = 0x00800000U,   /** @brief CPT1DE */
      [2] = 0x01000000U,   /** @brief CPT2DE */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_CMPxDE_MASK[5] = {
      [1] = 0x00010000U,   /** @brief CMP1DE */
      [2] = 0x00020000U,   /** @brief CMP2DE */
      [3] = 0x00040000U,   /** @brief CMP3DE */
      [4] = 0x00080000U,   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTXxIE_MASK[3] = {
      [1] = 0x00000400U,   /** @brief RSTx1IE */
      [2] = 0x00001000U,   /** @brief RSTx2IE */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_CPTxIE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief CPT1IE */
      [2] = 0x00000100U,   /** @brief CPT2IE */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_CMPxIE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [4] = 0x00000008U,   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIME_SETExR_EXTEVNTx_MASK[11] = {
      [1]  = 0x00200000U,   /** @brief External event 1 */
      [2]  = 0x00400000U,   /** @brief External event 2 */
      [3]  = 0x00800000U,   /** @brief External event 3 */
      [4]  = 0x01000000U,   /** @brief External event 4 */
      [5]  = 0x02000000U,   /** @brief External event 5 */
      [6]  = 0x04000000U,   /** @brief External event 6 */
      [7]  = 0x08000000U,   /** @brief External event 7 */
      [8]  = 0x10000000U,   /** @brief External event 8 */
      [9]  = 0x20000000U,   /** @brief External event 9 */
      [10] = 0x40000000U,   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIME_SETExR_TIMEVNTx_MASK[10] = {
      [1]  = 0x00001000U,   /** @brief Timer event 1 */
      [2]  = 0x00002000U,   /** @brief Timer event 2 */
      [3]  = 0x00004000U,   /** @brief Timer event 3 */
      [4]  = 0x00008000U,   /** @brief Timer event 4 */
      [5]  = 0x00010000U,   /** @brief Timer event 5 */
      [6]  = 0x00020000U,   /** @brief Timer event 6 */
      [7]  = 0x00040000U,   /** @brief Timer event 7 */
      [8]  = 0x00080000U,   /** @brief Timer event 8 */
      [9]  = 0x00100000U,   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIME_SETExR_MSTCMPx_MASK[5] = {
      [1] = 0x00000100U,   /** @brief Master compare 1 */
      [2] = 0x00000200U,   /** @brief Master compare 2 */
      [3] = 0x00000400U,   /** @brief Master compare 3 */
      [4] = 0x00000800U,   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIME_EEFER1_EExFLTR_MASK[6] = {
      [1] = 0x0000001EU,   /** @brief External event 1 filter */
      [2] = 0x00000780U,   /** @brief External event 2 filter */
      [3] = 0x0001E000U,   /** @brief External event 3 filter */
      [4] = 0x00780000U,   /** @brief External event 4 filter */
      [5] = 0x1E000000U,   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIME_EEFER1_EExLTCH_MASK[6] = {
      [1] = 0x00000001U,   /** @brief External event 1 latch */
      [2] = 0x00000040U,   /** @brief External event 2 latch */
      [3] = 0x00001000U,   /** @brief External event 3 latch */
      [4] = 0x00040000U,   /** @brief External event 4 latch */
      [5] = 0x01000000U,   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMDCMPx_MASK[5] = {
      [1] = 0x10000000U,   /** @brief Timer D compare 1 */
      [2] = 0x20000000U,   /** @brief Timer D compare 2 */
      [4] = 0x40000000U,   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMCCMPx_MASK[5] = {
      [1] = 0x02000000U,   /** @brief Timer C compare 1 */
      [2] = 0x04000000U,   /** @brief Timer C compare 2 */
      [4] = 0x08000000U,   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMBCMPx_MASK[5] = {
      [1] = 0x00400000U,   /** @brief Timer B compare 1 */
      [2] = 0x00800000U,   /** @brief Timer B compare 2 */
      [4] = 0x01000000U,   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMACMPx_MASK[5] = {
      [1] = 0x00080000U,   /** @brief Timer A compare 1 */
      [2] = 0x00100000U,   /** @brief Timer A compare 2 */
      [4] = 0x00200000U,   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_TDCMPx_MASK[3] = {
      [1] = 0x04000000U,   /** @brief Timer D compare 1 */
      [2] = 0x08000000U,   /** @brief Timer D compare 2 */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_TCCMPx_MASK[3] = {
      [1] = 0x00400000U,   /** @brief Timer C compare 1 */
      [2] = 0x00800000U,   /** @brief Timer C compare 2 */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_TBCMPx_MASK[3] = {
      [1] = 0x00040000U,   /** @brief Timer B compare 1 */
      [2] = 0x00080000U,   /** @brief Timer B compare 2 */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_TACMPx_MASK[3] = {
      [1] = 0x00004000U,   /** @brief Timer A compare 1 */
      [2] = 0x00008000U,   /** @brief Timer A compare 2 */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_EXEVxCPT_MASK[11] = {
      [1]  = 0x00000004U,   /** @brief External event 1 capture */
      [2]  = 0x00000008U,   /** @brief External event 2 capture */
      [3]  = 0x00000010U,   /** @brief External event 3 capture */
      [4]  = 0x00000020U,   /** @brief External event 4 capture */
      [5]  = 0x00000040U,   /** @brief External event 5 capture */
      [6]  = 0x00000080U,   /** @brief External event 6 capture */
      [7]  = 0x00000100U,   /** @brief External event 7 capture */
      [8]  = 0x00000200U,   /** @brief External event 8 capture */
      [9]  = 0x00000400U,   /** @brief External event 9 capture */
      [10] = 0x00000800U,   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIME_OUTER_DIDLx_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 0x00800000U,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const uint32_t HRTIM_TIME_OUTER_CHPx_MASK[3] = {
      [1] = 0x00000040U,   /** @brief Output 1 chopper enable */
      [2] = 0x00400000U,   /** @brief Output 2 chopper enable */
    };

    static const uint32_t HRTIM_TIME_OUTER_FAULTx_MASK[3] = {
      [1] = 0x00000030U,   /** @brief Output 1 fault state */
      [2] = 0x00300000U,   /** @brief Output 2 fault state */
    };

    static const uint32_t HRTIM_TIME_OUTER_IDLESx_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output 1 idle state */
      [2] = 0x00080000U,   /** @brief Output 2 idle state */
    };

    static const uint32_t HRTIM_TIME_OUTER_IDLEMx_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output 1 idle mode */
      [2] = 0x00040000U,   /** @brief Output 2 idle mode */
    };

    static const uint32_t HRTIM_TIME_OUTER_POLx_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Output 1 polarity */
      [2] = 0x00020000U,   /** @brief Output 2 polarity */
    };

    static const uint32_t HRTIM_TIME_FLTER_FLTxEN_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [5] = 0x00000010U,   /** @brief Fault 5 enable */
    };

    /**** @subsection HRTIM_TIME Register Field Positions ****/

    static const int32_t HRTIM_TIME_TIMECR_UPDGAT_POS        = 28;   /** @brief Update gating */
    static const int32_t HRTIM_TIME_TIMECR_PREEN_POS         = 27;   /** @brief Preload enable */
    static const int32_t HRTIM_TIME_TIMECR_DACSYNC_POS       = 25;   /** @brief AC synchronization */
    static const int32_t HRTIM_TIME_TIMECR_MSTU_POS          = 24;   /** @brief Master timer update */
    static const int32_t HRTIM_TIME_TIMECR_TEU_POS           = 23;   /** @brief TEU */
    static const int32_t HRTIM_TIME_TIMECR_TDU_POS           = 22;   /** @brief TDU */
    static const int32_t HRTIM_TIME_TIMECR_TCU_POS           = 21;   /** @brief TCU */
    static const int32_t HRTIM_TIME_TIMECR_TBU_POS           = 20;   /** @brief TBU */
    static const int32_t HRTIM_TIME_TIMECR_TXRSTU_POS        = 18;   /** @brief Timerx reset update */
    static const int32_t HRTIM_TIME_TIMECR_TXREPU_POS        = 17;   /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIME_TIMECR_SYNCSTRTX_POS     = 11;   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIME_TIMECR_SYNCRSTX_POS      = 10;   /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIME_TIMECR_PSHPLL_POS        = 6;    /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIME_TIMECR_HALF_POS          = 5;    /** @brief Half mode enable */
    static const int32_t HRTIM_TIME_TIMECR_RETRIG_POS        = 4;    /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIME_TIMECR_CONT_POS          = 3;    /** @brief Continuous mode */
    static const int32_t HRTIM_TIME_TIMECR_CK_PSCX_POS       = 0;    /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIME_TIMEISR_IPPSTAT_POS      = 17;   /** @brief Idle push pull status */
    static const int32_t HRTIM_TIME_TIMEISR_CPPSTAT_POS      = 16;   /** @brief Current push pull status */
    static const int32_t HRTIM_TIME_TIMEISR_DLYPRT_POS       = 14;   /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIME_TIMEISR_RST_POS          = 13;   /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIME_TIMEISR_UPD_POS          = 6;    /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIME_TIMEISR_REP_POS          = 4;    /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIME_TIMEICR_DLYPRTC_POS      = 14;   /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIME_TIMEICR_RSTC_POS         = 13;   /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIME_TIMEICR_UPDC_POS         = 6;    /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIME_TIMEICR_REPC_POS         = 4;    /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIME_TIMEDIER5_DLYPRTDE_POS   = 30;   /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIME_TIMEDIER5_RSTDE_POS      = 29;   /** @brief RSTDE */
    static const int32_t HRTIM_TIME_TIMEDIER5_SETX2DE_POS    = 27;   /** @brief SETx2DE */
    static const int32_t HRTIM_TIME_TIMEDIER5_SET1XDE_POS    = 25;   /** @brief SET1xDE */
    static const int32_t HRTIM_TIME_TIMEDIER5_UPDDE_POS      = 22;   /** @brief UPDDE */
    static const int32_t HRTIM_TIME_TIMEDIER5_REPDE_POS      = 20;   /** @brief REPDE */
    static const int32_t HRTIM_TIME_TIMEDIER5_DLYPRTIE_POS   = 14;   /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIME_TIMEDIER5_RSTIE_POS      = 13;   /** @brief RSTIE */
    static const int32_t HRTIM_TIME_TIMEDIER5_SETX2IE_POS    = 11;   /** @brief SETx2IE */
    static const int32_t HRTIM_TIME_TIMEDIER5_SET1XIE_POS    = 9;    /** @brief SET1xIE */
    static const int32_t HRTIM_TIME_TIMEDIER5_UPDIE_POS      = 6;    /** @brief UPDIE */
    static const int32_t HRTIM_TIME_TIMEDIER5_REPIE_POS      = 4;    /** @brief REPIE */
    static const int32_t HRTIM_TIME_CNTER_CNTX_POS           = 0;    /** @brief Timerx counter value */
    static const int32_t HRTIM_TIME_PERER_PERX_POS           = 0;    /** @brief Timerx period value */
    static const int32_t HRTIM_TIME_REPER_REPX_POS           = 0;    /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIME_CMPxER_CMP1X_POS         = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIME_CMP1CER_REPX_POS         = 16;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIME_CMP1CER_CMP1X_POS        = 0;    /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIME_CPTxER_CPT1X_POS         = 0;    /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIME_DTER_DTFLKX_POS          = 31;   /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIME_DTER_DTFSLKX_POS         = 30;   /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIME_DTER_SDTFX_POS           = 25;   /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIME_DTER_DTFX_POS            = 16;   /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIME_DTER_DTRLKX_POS          = 15;   /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIME_DTER_DTRSLKX_POS         = 14;   /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIME_DTER_DTPRSC_POS          = 10;   /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIME_DTER_SDTRX_POS           = 9;    /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIME_DTER_DTRX_POS            = 0;    /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIME_SETExR_UPDATE_POS        = 31;   /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIME_SETExR_MSTPER_POS        = 7;    /** @brief Master period */
    static const int32_t HRTIM_TIME_SETExR_PER_POS           = 2;    /** @brief Timer A period */
    static const int32_t HRTIM_TIME_SETExR_RESYNC_POS        = 1;    /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIME_SETExR_SST_POS           = 0;    /** @brief Software set trigger */
    static const int32_t HRTIM_TIME_RSTExR_UPDATE_POS        = 31;   /** @brief UPDATE */
    static const int32_t HRTIM_TIME_RSTExR_MSTPER_POS        = 7;    /** @brief MSTPER */
    static const int32_t HRTIM_TIME_RSTExR_PER_POS           = 2;    /** @brief PER */
    static const int32_t HRTIM_TIME_RSTExR_RESYNC_POS        = 1;    /** @brief RESYNC */
    static const int32_t HRTIM_TIME_RSTExR_SRT_POS           = 0;    /** @brief SRT */
    static const int32_t HRTIM_TIME_RSTER_MSTPER_POS         = 4;    /** @brief Master timer period */
    static const int32_t HRTIM_TIME_RSTER_UPDT_POS           = 1;    /** @brief Timer A update reset */
    static const int32_t HRTIM_TIME_CHPER_STRTPW_POS         = 7;    /** @brief STRTPW */
    static const int32_t HRTIM_TIME_CHPER_CHPDTY_POS         = 4;    /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIME_CHPER_CHPFRQ_POS         = 0;    /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIME_CPTxECR_TD1RST_POS       = 25;   /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIME_CPTxECR_TD1SET_POS       = 24;   /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIME_CPTxECR_TC1RST_POS       = 21;   /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIME_CPTxECR_TC1SET_POS       = 20;   /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIME_CPTxECR_TB1RST_POS       = 17;   /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIME_CPTxECR_TB1SET_POS       = 16;   /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIME_CPTxECR_TA1RST_POS       = 13;   /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIME_CPTxECR_TA1SET_POS       = 12;   /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIME_CPTxECR_UDPCPT_POS       = 1;    /** @brief Update capture */
    static const int32_t HRTIM_TIME_CPTxECR_SWCPT_POS        = 0;    /** @brief Software capture */
    static const int32_t HRTIM_TIME_OUTER_DLYPRT_POS         = 10;   /** @brief Delayed protection */
    static const int32_t HRTIM_TIME_OUTER_DLYPRTEN_POS       = 9;    /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIME_OUTER_DTEN_POS           = 8;    /** @brief Deadtime enable */
    static const int32_t HRTIM_TIME_FLTER_FLTLCK_POS         = 31;   /** @brief Fault sources lock */

    /**** @subsection Enumerated HRTIM_TIME Register Field Positions ****/

    static const int32_t HRTIM_TIME_TIMECR_DELCMPx_POS[5] = {
      [2] = 12,   /** @brief Delayed CMP2 mode */
      [4] = 14,   /** @brief Delayed CMP4 mode */
    };

    static const int32_t HRTIM_TIME_TIMEISR_OxSTAT_POS[3] = {
      [1] = 18,   /** @brief Output 1 state */
      [2] = 19,   /** @brief Output 2 state */
    };

    static const int32_t HRTIM_TIME_TIMEISR_RSTXx_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset interrupt flag */
      [2] = 12,   /** @brief Output 2 reset interrupt flag */
    };

    static const int32_t HRTIM_TIME_TIMEISR_SETXx_POS[3] = {
      [1] = 9,    /** @brief Output 1 set interrupt flag */
      [2] = 11,   /** @brief Output 2 set interrupt flag */
    };

    static const int32_t HRTIM_TIME_TIMEISR_CPTx_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag */
      [2] = 8,   /** @brief Capture2 interrupt flag */
    };

    static const int32_t HRTIM_TIME_TIMEISR_CMPx_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag */
      [2] = 1,   /** @brief Compare 2 interrupt flag */
      [3] = 2,   /** @brief Compare 3 interrupt flag */
      [4] = 3,   /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIME_TIMEICR_RSTXxC_POS[3] = {
      [1] = 10,   /** @brief Output 1 reset flag clear */
      [2] = 12,   /** @brief Output 2 reset flag clear */
    };

    static const int32_t HRTIM_TIME_TIMEICR_SETxXC_POS[3] = {
      [1] = 9,    /** @brief Output 1 set flag clear */
      [2] = 11,   /** @brief Output 2 set flag clear */
    };

    static const int32_t HRTIM_TIME_TIMEICR_CPTxC_POS[3] = {
      [1] = 7,   /** @brief Capture1 interrupt flag clear */
      [2] = 8,   /** @brief Capture2 interrupt flag clear */
    };

    static const int32_t HRTIM_TIME_TIMEICR_CMPxC_POS[5] = {
      [1] = 0,   /** @brief Compare 1 interrupt flag clear */
      [2] = 1,   /** @brief Compare 2 interrupt flag clear */
      [3] = 2,   /** @brief Compare 3 interrupt flag clear */
      [4] = 3,   /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIME_TIMEDIER5_RSTXxDE_POS[3] = {
      [1] = 26,   /** @brief RSTx1DE */
      [2] = 28,   /** @brief RSTx2DE */
    };

    static const int32_t HRTIM_TIME_TIMEDIER5_CPTxDE_POS[3] = {
      [1] = 23,   /** @brief CPT1DE */
      [2] = 24,   /** @brief CPT2DE */
    };

    static const int32_t HRTIM_TIME_TIMEDIER5_CMPxDE_POS[5] = {
      [1] = 16,   /** @brief CMP1DE */
      [2] = 17,   /** @brief CMP2DE */
      [3] = 18,   /** @brief CMP3DE */
      [4] = 19,   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIME_TIMEDIER5_RSTXxIE_POS[3] = {
      [1] = 10,   /** @brief RSTx1IE */
      [2] = 12,   /** @brief RSTx2IE */
    };

    static const int32_t HRTIM_TIME_TIMEDIER5_CPTxIE_POS[3] = {
      [1] = 7,   /** @brief CPT1IE */
      [2] = 8,   /** @brief CPT2IE */
    };

    static const int32_t HRTIM_TIME_TIMEDIER5_CMPxIE_POS[5] = {
      [1] = 0,   /** @brief CMP1IE */
      [2] = 1,   /** @brief CMP2IE */
      [3] = 2,   /** @brief CMP3IE */
      [4] = 3,   /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIME_SETExR_EXTEVNTx_POS[11] = {
      [1]  = 21,   /** @brief External event 1 */
      [2]  = 22,   /** @brief External event 2 */
      [3]  = 23,   /** @brief External event 3 */
      [4]  = 24,   /** @brief External event 4 */
      [5]  = 25,   /** @brief External event 5 */
      [6]  = 26,   /** @brief External event 6 */
      [7]  = 27,   /** @brief External event 7 */
      [8]  = 28,   /** @brief External event 8 */
      [9]  = 29,   /** @brief External event 9 */
      [10] = 30,   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIME_SETExR_TIMEVNTx_POS[10] = {
      [1]  = 12,   /** @brief Timer event 1 */
      [2]  = 13,   /** @brief Timer event 2 */
      [3]  = 14,   /** @brief Timer event 3 */
      [4]  = 15,   /** @brief Timer event 4 */
      [5]  = 16,   /** @brief Timer event 5 */
      [6]  = 17,   /** @brief Timer event 6 */
      [7]  = 18,   /** @brief Timer event 7 */
      [8]  = 19,   /** @brief Timer event 8 */
      [9]  = 20,   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIME_SETExR_MSTCMPx_POS[5] = {
      [1] = 8,    /** @brief Master compare 1 */
      [2] = 9,    /** @brief Master compare 2 */
      [3] = 10,   /** @brief Master compare 3 */
      [4] = 11,   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIME_EEFER1_EExFLTR_POS[6] = {
      [1] = 1,    /** @brief External event 1 filter */
      [2] = 7,    /** @brief External event 2 filter */
      [3] = 13,   /** @brief External event 3 filter */
      [4] = 19,   /** @brief External event 4 filter */
      [5] = 25,   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIME_EEFER1_EExLTCH_POS[6] = {
      [1] = 0,    /** @brief External event 1 latch */
      [2] = 6,    /** @brief External event 2 latch */
      [3] = 12,   /** @brief External event 3 latch */
      [4] = 18,   /** @brief External event 4 latch */
      [5] = 24,   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIME_RSTER_TIMDCMPx_POS[5] = {
      [1] = 28,   /** @brief Timer D compare 1 */
      [2] = 29,   /** @brief Timer D compare 2 */
      [4] = 30,   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIME_RSTER_TIMCCMPx_POS[5] = {
      [1] = 25,   /** @brief Timer C compare 1 */
      [2] = 26,   /** @brief Timer C compare 2 */
      [4] = 27,   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIME_RSTER_TIMBCMPx_POS[5] = {
      [1] = 22,   /** @brief Timer B compare 1 */
      [2] = 23,   /** @brief Timer B compare 2 */
      [4] = 24,   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIME_RSTER_TIMACMPx_POS[5] = {
      [1] = 19,   /** @brief Timer A compare 1 */
      [2] = 20,   /** @brief Timer A compare 2 */
      [4] = 21,   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIME_CPTxECR_TDCMPx_POS[3] = {
      [1] = 26,   /** @brief Timer D compare 1 */
      [2] = 27,   /** @brief Timer D compare 2 */
    };

    static const int32_t HRTIM_TIME_CPTxECR_TCCMPx_POS[3] = {
      [1] = 22,   /** @brief Timer C compare 1 */
      [2] = 23,   /** @brief Timer C compare 2 */
    };

    static const int32_t HRTIM_TIME_CPTxECR_TBCMPx_POS[3] = {
      [1] = 18,   /** @brief Timer B compare 1 */
      [2] = 19,   /** @brief Timer B compare 2 */
    };

    static const int32_t HRTIM_TIME_CPTxECR_TACMPx_POS[3] = {
      [1] = 14,   /** @brief Timer A compare 1 */
      [2] = 15,   /** @brief Timer A compare 2 */
    };

    static const int32_t HRTIM_TIME_CPTxECR_EXEVxCPT_POS[11] = {
      [1]  = 2,    /** @brief External event 1 capture */
      [2]  = 3,    /** @brief External event 2 capture */
      [3]  = 4,    /** @brief External event 3 capture */
      [4]  = 5,    /** @brief External event 4 capture */
      [5]  = 6,    /** @brief External event 5 capture */
      [6]  = 7,    /** @brief External event 6 capture */
      [7]  = 8,    /** @brief External event 7 capture */
      [8]  = 9,    /** @brief External event 8 capture */
      [9]  = 10,   /** @brief External event 9 capture */
      [10] = 11,   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIME_OUTER_DIDLx_POS[3] = {
      [1] = 7,    /** @brief Output 1 deadtime upon burst mode idle entry */
      [2] = 23,   /** @brief Output 2 deadtime upon burst mode idle entry */
    };

    static const int32_t HRTIM_TIME_OUTER_CHPx_POS[3] = {
      [1] = 6,    /** @brief Output 1 chopper enable */
      [2] = 22,   /** @brief Output 2 chopper enable */
    };

    static const int32_t HRTIM_TIME_OUTER_FAULTx_POS[3] = {
      [1] = 4,    /** @brief Output 1 fault state */
      [2] = 20,   /** @brief Output 2 fault state */
    };

    static const int32_t HRTIM_TIME_OUTER_IDLESx_POS[3] = {
      [1] = 3,    /** @brief Output 1 idle state */
      [2] = 19,   /** @brief Output 2 idle state */
    };

    static const int32_t HRTIM_TIME_OUTER_IDLEMx_POS[3] = {
      [1] = 2,    /** @brief Output 1 idle mode */
      [2] = 18,   /** @brief Output 2 idle mode */
    };

    static const int32_t HRTIM_TIME_OUTER_POLx_POS[3] = {
      [1] = 1,    /** @brief Output 1 polarity */
      [2] = 17,   /** @brief Output 2 polarity */
    };

    static const int32_t HRTIM_TIME_FLTER_FLTxEN_POS[6] = {
      [1] = 0,   /** @brief Fault 1 enable */
      [2] = 1,   /** @brief Fault 2 enable */
      [3] = 2,   /** @brief Fault 3 enable */
      [4] = 3,   /** @brief Fault 4 enable */
      [5] = 4,   /** @brief Fault 5 enable */
    };

    /**********************************************************************************************
     * @section HRTIM_COMMON Register Information
     **********************************************************************************************/

    /**** @subsection HRTIM_COMMON Register Pointers ****/

    static RW_ uint32_t* const HRTIM_COMMON_CR1_PTR       = (RW_ uint32_t* const)0x40017780U;   /** @brief Control register 1 */
    static RW_ uint32_t* const HRTIM_COMMON_CR2_PTR       = (RW_ uint32_t* const)0x40017784U;   /** @brief Control register 2 */
    static RW_ uint32_t* const HRTIM_COMMON_ISR_PTR       = (RW_ uint32_t* const)0x40017788U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const HRTIM_COMMON_ICR_PTR       = (RW_ uint32_t* const)0x4001778CU;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const HRTIM_COMMON_IER_PTR       = (RW_ uint32_t* const)0x40017790U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const HRTIM_COMMON_OENR_PTR      = (RW_ uint32_t* const)0x40017794U;   /** @brief Output enable register */
    static RW_ uint32_t* const HRTIM_COMMON_DISR_PTR      = (RW_ uint32_t* const)0x40017798U;   /** @brief DISR */
    static RO_ uint32_t* const HRTIM_COMMON_ODSR_PTR      = (RO_ uint32_t* const)0x4001779CU;   /** @brief Output disable status register */
    static RW_ uint32_t* const HRTIM_COMMON_BMCR_PTR      = (RW_ uint32_t* const)0x400177A0U;   /** @brief Burst mode control register */
    static RW_ uint32_t* const HRTIM_COMMON_BMTRG_PTR     = (RW_ uint32_t* const)0x400177A4U;   /** @brief BMTRG */
    static RW_ uint32_t* const HRTIM_COMMON_BMCMPR6_PTR   = (RW_ uint32_t* const)0x400177A8U;   /** @brief BMCMPR6 */
    static RW_ uint32_t* const HRTIM_COMMON_BMPER_PTR     = (RW_ uint32_t* const)0x400177ACU;   /** @brief Burst mode period register */
    static RW_ uint32_t* const HRTIM_COMMON_EECR1_PTR     = (RW_ uint32_t* const)0x400177B0U;   /** @brief Timer external event control register 1 */
    static RW_ uint32_t* const HRTIM_COMMON_EECR2_PTR     = (RW_ uint32_t* const)0x400177B4U;   /** @brief Timer external event control register 2 */
    static RW_ uint32_t* const HRTIM_COMMON_EECR3_PTR     = (RW_ uint32_t* const)0x400177B8U;   /** @brief Timer external event control register 3 */
    static RW_ uint32_t* const HRTIM_COMMON_ADC1R_PTR     = (RW_ uint32_t* const)0x400177BCU;   /** @brief ADC trigger 1 register */
    static RW_ uint32_t* const HRTIM_COMMON_ADC2R_PTR     = (RW_ uint32_t* const)0x400177C0U;   /** @brief ADC trigger 2 register */
    static RW_ uint32_t* const HRTIM_COMMON_ADC3R_PTR     = (RW_ uint32_t* const)0x400177C4U;   /** @brief ADC trigger 3 register */
    static RW_ uint32_t* const HRTIM_COMMON_ADC4R_PTR     = (RW_ uint32_t* const)0x400177C8U;   /** @brief ADC trigger 4 register */
    static RW_ uint32_t* const HRTIM_COMMON_DLLCR_PTR     = (RW_ uint32_t* const)0x400177CCU;   /** @brief DLL control register */
    static RW_ uint32_t* const HRTIM_COMMON_FLTINR1_PTR   = (RW_ uint32_t* const)0x400177D0U;   /** @brief HRTIM fault input register 1 */
    static RW_ uint32_t* const HRTIM_COMMON_FLTINR2_PTR   = (RW_ uint32_t* const)0x400177D4U;   /** @brief HRTIM fault input register 2 */
    static RW_ uint32_t* const HRTIM_COMMON_BDMUPDR_PTR   = (RW_ uint32_t* const)0x400177D8U;   /** @brief BDMUPDR */
    static RW_ uint32_t* const HRTIM_COMMON_BDTXUPR_PTR   = (RW_ uint32_t* const)0x400177DCU;   /** @brief Burst DMA timerx update register */
    static RW_ uint32_t* const HRTIM_COMMON_BDMADR_PTR    = (RW_ uint32_t* const)0x400177E0U;   /** @brief Burst DMA data register */

    /**** @subsection HRTIM_COMMON Register Reset Values ****/

    static const uint32_t HRTIM_COMMON_CR1_RST       = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t HRTIM_COMMON_CR2_RST       = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t HRTIM_COMMON_ISR_RST       = 0x00000000U;   /** @brief ISR register reset value. */
    static const uint32_t HRTIM_COMMON_ICR_RST       = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t HRTIM_COMMON_IER_RST       = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t HRTIM_COMMON_OENR_RST      = 0x00000000U;   /** @brief OENR register reset value. */
    static const uint32_t HRTIM_COMMON_DISR_RST      = 0x00000000U;   /** @brief DISR register reset value. */
    static const uint32_t HRTIM_COMMON_ODSR_RST      = 0x00000000U;   /** @brief ODSR register reset value. */
    static const uint32_t HRTIM_COMMON_BMCR_RST      = 0x00000000U;   /** @brief BMCR register reset value. */
    static const uint32_t HRTIM_COMMON_BMTRG_RST     = 0x00000000U;   /** @brief BMTRG register reset value. */
    static const uint32_t HRTIM_COMMON_BMCMPR6_RST   = 0x00000000U;   /** @brief BMCMPR6 register reset value. */
    static const uint32_t HRTIM_COMMON_BMPER_RST     = 0x00000000U;   /** @brief BMPER register reset value. */
    static const uint32_t HRTIM_COMMON_EECR1_RST     = 0x00000000U;   /** @brief EECR1 register reset value. */
    static const uint32_t HRTIM_COMMON_EECR2_RST     = 0x00000000U;   /** @brief EECR2 register reset value. */
    static const uint32_t HRTIM_COMMON_EECR3_RST     = 0x00000000U;   /** @brief EECR3 register reset value. */
    static const uint32_t HRTIM_COMMON_ADC1R_RST     = 0x00000000U;   /** @brief ADC1R register reset value. */
    static const uint32_t HRTIM_COMMON_ADC2R_RST     = 0x00000000U;   /** @brief ADC2R register reset value. */
    static const uint32_t HRTIM_COMMON_ADC3R_RST     = 0x00000000U;   /** @brief ADC3R register reset value. */
    static const uint32_t HRTIM_COMMON_ADC4R_RST     = 0x00000000U;   /** @brief ADC4R register reset value. */
    static const uint32_t HRTIM_COMMON_DLLCR_RST     = 0x00000000U;   /** @brief DLLCR register reset value. */
    static const uint32_t HRTIM_COMMON_FLTINR1_RST   = 0x00000000U;   /** @brief FLTINR1 register reset value. */
    static const uint32_t HRTIM_COMMON_FLTINR2_RST   = 0x00000000U;   /** @brief FLTINR2 register reset value. */
    static const uint32_t HRTIM_COMMON_BDMUPDR_RST   = 0x00000000U;   /** @brief BDMUPDR register reset value. */
    static const uint32_t HRTIM_COMMON_BDTXUPR_RST   = 0x00000000U;   /** @brief BDTXUPR register reset value. */
    static const uint32_t HRTIM_COMMON_BDMADR_RST    = 0x00000000U;   /** @brief BDMADR register reset value. */

    /**** @subsection Enumerated HRTIM_COMMON Register Value Types ****/

    typedef uint32_t HRTIM_COMMON_CR1_t;       /** @brief CR1 register value type. */
    typedef uint32_t HRTIM_COMMON_CR2_t;       /** @brief CR2 register value type. */
    typedef uint32_t HRTIM_COMMON_ISR_t;       /** @brief ISR register value type. */
    typedef uint32_t HRTIM_COMMON_ICR_t;       /** @brief ICR register value type. */
    typedef uint32_t HRTIM_COMMON_IER_t;       /** @brief IER register value type. */
    typedef uint32_t HRTIM_COMMON_OENR_t;      /** @brief OENR register value type. */
    typedef uint32_t HRTIM_COMMON_DISR_t;      /** @brief DISR register value type. */
    typedef uint32_t HRTIM_COMMON_ODSR_t;      /** @brief ODSR register value type. */
    typedef uint32_t HRTIM_COMMON_BMCR_t;      /** @brief BMCR register value type. */
    typedef uint32_t HRTIM_COMMON_BMTRG_t;     /** @brief BMTRG register value type. */
    typedef uint32_t HRTIM_COMMON_BMCMPR6_t;   /** @brief BMCMPR6 register value type. */
    typedef uint32_t HRTIM_COMMON_BMPER_t;     /** @brief BMPER register value type. */
    typedef uint32_t HRTIM_COMMON_EECR1_t;     /** @brief EECR1 register value type. */
    typedef uint32_t HRTIM_COMMON_EECR2_t;     /** @brief EECR2 register value type. */
    typedef uint32_t HRTIM_COMMON_EECR3_t;     /** @brief EECR3 register value type. */
    typedef uint32_t HRTIM_COMMON_ADC1R_t;     /** @brief ADC1R register value type. */
    typedef uint32_t HRTIM_COMMON_ADC2R_t;     /** @brief ADC2R register value type. */
    typedef uint32_t HRTIM_COMMON_ADC3R_t;     /** @brief ADC3R register value type. */
    typedef uint32_t HRTIM_COMMON_ADC4R_t;     /** @brief ADC4R register value type. */
    typedef uint32_t HRTIM_COMMON_DLLCR_t;     /** @brief DLLCR register value type. */
    typedef uint32_t HRTIM_COMMON_FLTINR1_t;   /** @brief FLTINR1 register value type. */
    typedef uint32_t HRTIM_COMMON_FLTINR2_t;   /** @brief FLTINR2 register value type. */
    typedef uint32_t HRTIM_COMMON_BDMUPDR_t;   /** @brief BDMUPDR register value type. */
    typedef uint32_t HRTIM_COMMON_BDTXUPR_t;   /** @brief BDTXUPR register value type. */
    typedef uint32_t HRTIM_COMMON_BDMADR_t;    /** @brief BDMADR register value type. */

    /**** @subsection Enumerated HRTIM_COMMON Register Pointer Types ****/

    typedef uint32_t* const HRTIM_COMMON_CR1_PTR_t;       /** @brief CR1 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_CR2_PTR_t;       /** @brief CR2 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_ISR_PTR_t;       /** @brief ISR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_ICR_PTR_t;       /** @brief ICR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_IER_PTR_t;       /** @brief IER register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_OENR_PTR_t;      /** @brief OENR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_DISR_PTR_t;      /** @brief DISR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_ODSR_PTR_t;      /** @brief ODSR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_BMCR_PTR_t;      /** @brief BMCR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_BMTRG_PTR_t;     /** @brief BMTRG register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_BMCMPR6_PTR_t;   /** @brief BMCMPR6 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_BMPER_PTR_t;     /** @brief BMPER register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_EECR1_PTR_t;     /** @brief EECR1 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_EECR2_PTR_t;     /** @brief EECR2 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_EECR3_PTR_t;     /** @brief EECR3 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_ADC1R_PTR_t;     /** @brief ADC1R register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_ADC2R_PTR_t;     /** @brief ADC2R register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_ADC3R_PTR_t;     /** @brief ADC3R register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_ADC4R_PTR_t;     /** @brief ADC4R register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_DLLCR_PTR_t;     /** @brief DLLCR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_FLTINR1_PTR_t;   /** @brief FLTINR1 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_FLTINR2_PTR_t;   /** @brief FLTINR2 register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_BDMUPDR_PTR_t;   /** @brief BDMUPDR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_BDTXUPR_PTR_t;   /** @brief BDTXUPR register pointer type. */
    typedef uint32_t* const HRTIM_COMMON_BDMADR_PTR_t;    /** @brief BDMADR register pointer type. */

    /**** @subsection HRTIM_COMMON Register Field Masks ****/

    static const uint32_t HRTIM_COMMON_CR1_TEUDIS_MASK          = 0x00000020U;   /** @brief Timer E update disable */
    static const uint32_t HRTIM_COMMON_CR1_TDUDIS_MASK          = 0x00000010U;   /** @brief Timer D update disable */
    static const uint32_t HRTIM_COMMON_CR1_TCUDIS_MASK          = 0x00000008U;   /** @brief Timer C update disable */
    static const uint32_t HRTIM_COMMON_CR1_TBUDIS_MASK          = 0x00000004U;   /** @brief Timer B update disable */
    static const uint32_t HRTIM_COMMON_CR1_TAUDIS_MASK          = 0x00000002U;   /** @brief Timer A update disable */
    static const uint32_t HRTIM_COMMON_CR1_MUDIS_MASK           = 0x00000001U;   /** @brief Master update disable */
    static const uint32_t HRTIM_COMMON_CR2_TERST_MASK           = 0x00002000U;   /** @brief Timer E counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TDRST_MASK           = 0x00001000U;   /** @brief Timer D counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TCRST_MASK           = 0x00000800U;   /** @brief Timer C counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TBRST_MASK           = 0x00000400U;   /** @brief Timer B counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TARST_MASK           = 0x00000200U;   /** @brief Timer A counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_MRST_MASK            = 0x00000100U;   /** @brief Master counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TESWU_MASK           = 0x00000020U;   /** @brief Timer E software update */
    static const uint32_t HRTIM_COMMON_CR2_TDSWU_MASK           = 0x00000010U;   /** @brief Timer D software update */
    static const uint32_t HRTIM_COMMON_CR2_TCSWU_MASK           = 0x00000008U;   /** @brief Timer C software update */
    static const uint32_t HRTIM_COMMON_CR2_TBSWU_MASK           = 0x00000004U;   /** @brief Timer B software update */
    static const uint32_t HRTIM_COMMON_CR2_TASWU_MASK           = 0x00000002U;   /** @brief Timer A software update */
    static const uint32_t HRTIM_COMMON_CR2_MSWU_MASK            = 0x00000001U;   /** @brief Master timer software update */
    static const uint32_t HRTIM_COMMON_ISR_BMPER_MASK           = 0x00020000U;   /** @brief Burst mode period interrupt flag */
    static const uint32_t HRTIM_COMMON_ISR_DLLRDY_MASK          = 0x00010000U;   /** @brief DLL ready interrupt flag */
    static const uint32_t HRTIM_COMMON_ISR_SYSFLT_MASK          = 0x00000020U;   /** @brief System fault interrupt flag */
    static const uint32_t HRTIM_COMMON_ICR_BMPERC_MASK          = 0x00020000U;   /** @brief Burst mode period flag clear */
    static const uint32_t HRTIM_COMMON_ICR_DLLRDYC_MASK         = 0x00010000U;   /** @brief DLL ready interrupt flag clear */
    static const uint32_t HRTIM_COMMON_ICR_SYSFLTC_MASK         = 0x00000020U;   /** @brief System fault interrupt flag clear */
    static const uint32_t HRTIM_COMMON_IER_BMPERIE_MASK         = 0x00020000U;   /** @brief Burst mode period interrupt enable */
    static const uint32_t HRTIM_COMMON_IER_DLLRDYIE_MASK        = 0x00010000U;   /** @brief DLL ready interrupt enable */
    static const uint32_t HRTIM_COMMON_IER_SYSFLTE_MASK         = 0x00000020U;   /** @brief System fault interrupt enable */
    static const uint32_t HRTIM_COMMON_BMCR_BMSTAT_MASK         = 0x80000000U;   /** @brief Burst mode status */
    static const uint32_t HRTIM_COMMON_BMCR_TEBM_MASK           = 0x00200000U;   /** @brief Timer E burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TDBM_MASK           = 0x00100000U;   /** @brief Timer D burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TCBM_MASK           = 0x00080000U;   /** @brief Timer C burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TBBM_MASK           = 0x00040000U;   /** @brief Timer B burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TABM_MASK           = 0x00020000U;   /** @brief Timer A burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_MTBM_MASK           = 0x00010000U;   /** @brief Master timer burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_BMPREN_MASK         = 0x00000400U;   /** @brief Burst mode preload enable */
    static const uint32_t HRTIM_COMMON_BMCR_BMPRSC_MASK         = 0x000003C0U;   /** @brief Burst mode prescaler */
    static const uint32_t HRTIM_COMMON_BMCR_BMCLK_MASK          = 0x0000003CU;   /** @brief Burst mode clock source */
    static const uint32_t HRTIM_COMMON_BMCR_BMOM_MASK           = 0x00000002U;   /** @brief Burst mode operating mode */
    static const uint32_t HRTIM_COMMON_BMCR_BME_MASK            = 0x00000001U;   /** @brief Burst mode enable */
    static const uint32_t HRTIM_COMMON_BMTRG_OCHPEV_MASK        = 0x80000000U;   /** @brief OCHPEV */
    static const uint32_t HRTIM_COMMON_BMTRG_TEREP_MASK         = 0x01000000U;   /** @brief TEREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TERST_MASK         = 0x00800000U;   /** @brief TERST */
    static const uint32_t HRTIM_COMMON_BMTRG_TDREP_MASK         = 0x00100000U;   /** @brief TDREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TDRST_MASK         = 0x00080000U;   /** @brief TDRST */
    static const uint32_t HRTIM_COMMON_BMTRG_TCREP_MASK         = 0x00010000U;   /** @brief TCREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TCRST_MASK         = 0x00008000U;   /** @brief TCRST */
    static const uint32_t HRTIM_COMMON_BMTRG_TBREP_MASK         = 0x00001000U;   /** @brief TBREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TBRST_MASK         = 0x00000800U;   /** @brief TBRST */
    static const uint32_t HRTIM_COMMON_BMTRG_TAREP_MASK         = 0x00000100U;   /** @brief TAREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TARST_MASK         = 0x00000080U;   /** @brief TARST */
    static const uint32_t HRTIM_COMMON_BMTRG_MSTREP_MASK        = 0x00000004U;   /** @brief MSTREP */
    static const uint32_t HRTIM_COMMON_BMTRG_MSTRST_MASK        = 0x00000002U;   /** @brief MSTRST */
    static const uint32_t HRTIM_COMMON_BMTRG_SW_MASK            = 0x00000001U;   /** @brief SW */
    static const uint32_t HRTIM_COMMON_BMCMPR6_BMCMP_MASK       = 0x0000FFFFU;   /** @brief BMCMP */
    static const uint32_t HRTIM_COMMON_BMPER_BMPER_MASK         = 0x0000FFFFU;   /** @brief Burst mode period */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1TEPER_MASK      = 0x80000000U;   /** @brief ADC trigger 1 on timer E period */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1TDPER_MASK      = 0x08000000U;   /** @brief ADC trigger 1 on timer D period */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1TCPER_MASK      = 0x00800000U;   /** @brief ADC trigger 1 on timer C period */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1TBRST_MASK      = 0x00080000U;   /** @brief ADC trigger 1 on timer B reset */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1TBPER_MASK      = 0x00040000U;   /** @brief ADC trigger 1 on timer B period */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1TARST_MASK      = 0x00004000U;   /** @brief ADC trigger 1 on timer A reset */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1TAPER_MASK      = 0x00002000U;   /** @brief ADC trigger 1 on timer A period */
    static const uint32_t HRTIM_COMMON_ADC1R_AD1MPER_MASK       = 0x00000010U;   /** @brief ADC trigger 1 on master period */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2TERST_MASK      = 0x80000000U;   /** @brief ADC trigger 2 on timer E reset */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2TDRST_MASK      = 0x08000000U;   /** @brief ADC trigger 2 on timer D reset */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2TDPER_MASK      = 0x04000000U;   /** @brief ADC trigger 2 on timer D period */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2TCRST_MASK      = 0x00400000U;   /** @brief ADC trigger 2 on timer C reset */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2TCPER_MASK      = 0x00200000U;   /** @brief ADC trigger 2 on timer C period */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2TBPER_MASK      = 0x00020000U;   /** @brief ADC trigger 2 on timer B period */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2TAPER_MASK      = 0x00002000U;   /** @brief ADC trigger 2 on timer A period */
    static const uint32_t HRTIM_COMMON_ADC2R_AD2MPER_MASK       = 0x00000010U;   /** @brief ADC trigger 2 on master period */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1TEPER_MASK      = 0x80000000U;   /** @brief AD1TEPER */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1TDPER_MASK      = 0x08000000U;   /** @brief AD1TDPER */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1TCPER_MASK      = 0x00800000U;   /** @brief AD1TCPER */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1TBRST_MASK      = 0x00080000U;   /** @brief AD1TBRST */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1TBPER_MASK      = 0x00040000U;   /** @brief AD1TBPER */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1TARST_MASK      = 0x00004000U;   /** @brief AD1TARST */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1TAPER_MASK      = 0x00002000U;   /** @brief AD1TAPER */
    static const uint32_t HRTIM_COMMON_ADC3R_AD1MPER_MASK       = 0x00000010U;   /** @brief AD1MPER */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2TERST_MASK      = 0x80000000U;   /** @brief AD2TERST */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2TDRST_MASK      = 0x08000000U;   /** @brief AD2TDRST */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2TDPER_MASK      = 0x04000000U;   /** @brief AD2TDPER */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2TCRST_MASK      = 0x00400000U;   /** @brief AD2TCRST */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2TCPER_MASK      = 0x00200000U;   /** @brief AD2TCPER */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2TBPER_MASK      = 0x00020000U;   /** @brief AD2TBPER */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2TAPER_MASK      = 0x00002000U;   /** @brief AD2TAPER */
    static const uint32_t HRTIM_COMMON_ADC4R_AD2MPER_MASK       = 0x00000010U;   /** @brief AD2MPER */
    static const uint32_t HRTIM_COMMON_DLLCR_CALRTE_MASK        = 0x0000000CU;   /** @brief DLL calibration rate */
    static const uint32_t HRTIM_COMMON_DLLCR_CALEN_MASK         = 0x00000002U;   /** @brief DLL calibration enable */
    static const uint32_t HRTIM_COMMON_DLLCR_CAL_MASK           = 0x00000001U;   /** @brief DLL calibration start */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLTSD_MASK       = 0x03000000U;   /** @brief FLTSD */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5LCK_MASK     = 0x00000080U;   /** @brief FLT5LCK */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5F_MASK       = 0x00000078U;   /** @brief FLT5F */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5SRC_MASK     = 0x00000004U;   /** @brief FLT5SRC */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5P_MASK       = 0x00000002U;   /** @brief FLT5P */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5E_MASK       = 0x00000001U;   /** @brief FLT5E */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MREP_MASK        = 0x00000020U;   /** @brief MREP */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MPER_MASK        = 0x00000010U;   /** @brief MPER */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MCNT_MASK        = 0x00000008U;   /** @brief MCNT */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MDIER_MASK       = 0x00000004U;   /** @brief MDIER */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MICR_MASK        = 0x00000002U;   /** @brief MICR */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MCR_MASK         = 0x00000001U;   /** @brief MCR */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXFLTR_MASK    = 0x00100000U;   /** @brief HRTIM_FLTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXOUTR_MASK    = 0x00080000U;   /** @brief HRTIM_OUTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCHPR_MASK    = 0x00040000U;   /** @brief HRTIM_CHPxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXRSTR_MASK    = 0x00020000U;   /** @brief HRTIM_RSTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMX_DTXR_MASK   = 0x00000400U;   /** @brief HRTIM_DTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXREP_MASK     = 0x00000020U;   /** @brief HRTIM_REPxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXPER_MASK     = 0x00000010U;   /** @brief HRTIM_PERxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCNT_MASK     = 0x00000008U;   /** @brief HRTIM_CNTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXDIER_MASK    = 0x00000004U;   /** @brief HRTIM_TIMxDIER register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXICR_MASK     = 0x00000002U;   /** @brief HRTIM_TIMxICR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCR_MASK      = 0x00000001U;   /** @brief HRTIM_TIMxCR register update enable */

    /**** @subsection Enumerated HRTIM_COMMON Register Field Masks ****/

    static const uint32_t HRTIM_COMMON_CR1_ADxUSRC_MASK[5] = {
      [1] = 0x00070000U,   /** @brief ADC trigger 1 update source */
      [2] = 0x00380000U,   /** @brief ADC trigger 2 update source */
      [3] = 0x01C00000U,   /** @brief ADC trigger 3 update source */
      [4] = 0x0E000000U,   /** @brief ADC trigger 4 update source */
    };

    static const uint32_t HRTIM_COMMON_ISR_FLTx_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 interrupt flag */
      [2] = 0x00000002U,   /** @brief Fault 2 interrupt flag */
      [3] = 0x00000004U,   /** @brief Fault 3 interrupt flag */
      [4] = 0x00000008U,   /** @brief Fault 4 interrupt flag */
      [5] = 0x00000010U,   /** @brief Fault 5 interrupt flag */
    };

    static const uint32_t HRTIM_COMMON_ICR_FLTxC_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Fault 2 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Fault 3 interrupt flag clear */
      [4] = 0x00000008U,   /** @brief Fault 4 interrupt flag clear */
      [5] = 0x00000010U,   /** @brief Fault 5 interrupt flag clear */
    };

    static const uint32_t HRTIM_COMMON_IER_FLTxIE_MASK[6] = {
      [1] = 0x00000001U,   /** @brief Fault 1 interrupt enable */
      [2] = 0x00000002U,   /** @brief Fault 2 interrupt enable */
      [3] = 0x00000004U,   /** @brief Fault 3 interrupt enable */
      [4] = 0x00000008U,   /** @brief Fault 4 interrupt enable */
      [5] = 0x00000010U,   /** @brief Fault 5 interrupt enable */
    };

    static const uint32_t HRTIM_COMMON_OENR_TExOEN_MASK[3] = {
      [1] = 0x00000100U,   /** @brief Timer E output 1 enable */
      [2] = 0x00000200U,   /** @brief Timer E output 2 enable */
    };

    static const uint32_t HRTIM_COMMON_OENR_TDxOEN_MASK[3] = {
      [1] = 0x00000040U,   /** @brief Timer D output 1 enable */
      [2] = 0x00000080U,   /** @brief Timer D output 2 enable */
    };

    static const uint32_t HRTIM_COMMON_OENR_TCxOEN_MASK[3] = {
      [1] = 0x00000010U,   /** @brief Timer C output 1 enable */
      [2] = 0x00000020U,   /** @brief Timer C output 2 enable */
    };

    static const uint32_t HRTIM_COMMON_OENR_TBxOEN_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Timer B output 1 enable */
      [2] = 0x00000008U,   /** @brief Timer B output 2 enable */
    };

    static const uint32_t HRTIM_COMMON_OENR_TAxOEN_MASK[3] = {
      [1] = 0x00000001U,   /** @brief Timer A output 1 enable */
      [2] = 0x00000002U,   /** @brief Timer A output 2 enable */
    };

    static const uint32_t HRTIM_COMMON_DISR_TExODIS_MASK[3] = {
      [1] = 0x00000100U,   /** @brief TE1ODIS */
      [2] = 0x00000200U,   /** @brief TE2ODIS */
    };

    static const uint32_t HRTIM_COMMON_DISR_TDxODIS_MASK[3] = {
      [1] = 0x00000040U,   /** @brief TD1ODIS */
      [2] = 0x00000080U,   /** @brief TD2ODIS */
    };

    static const uint32_t HRTIM_COMMON_DISR_TCxODIS_MASK[3] = {
      [1] = 0x00000010U,   /** @brief TC1ODIS */
      [2] = 0x00000020U,   /** @brief TC2ODIS */
    };

    static const uint32_t HRTIM_COMMON_DISR_TBxODIS_MASK[3] = {
      [1] = 0x00000004U,   /** @brief TB1ODIS */
      [2] = 0x00000008U,   /** @brief TB2ODIS */
    };

    static const uint32_t HRTIM_COMMON_DISR_TAxODIS_MASK[3] = {
      [1] = 0x00000001U,   /** @brief TA1ODIS */
      [2] = 0x00000002U,   /** @brief TA2ODIS */
    };

    static const uint32_t HRTIM_COMMON_ODSR_TExODS_MASK[3] = {
      [1] = 0x00000100U,   /** @brief Timer E output 1 disable status */
      [2] = 0x00000200U,   /** @brief Timer E output 2 disable status */
    };

    static const uint32_t HRTIM_COMMON_ODSR_TDxODS_MASK[3] = {
      [1] = 0x00000040U,   /** @brief Timer D output 1 disable status */
      [2] = 0x00000080U,   /** @brief Timer D output 2 disable status */
    };

    static const uint32_t HRTIM_COMMON_ODSR_TCxODS_MASK[3] = {
      [1] = 0x00000010U,   /** @brief Timer C output 1 disable status */
      [2] = 0x00000020U,   /** @brief Timer C output 2 disable status */
    };

    static const uint32_t HRTIM_COMMON_ODSR_TBxODS_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Timer B output 1 disable status */
      [2] = 0x00000008U,   /** @brief Timer B output 2 disable status */
    };

    static const uint32_t HRTIM_COMMON_ODSR_TAxODS_MASK[3] = {
      [1] = 0x00000001U,   /** @brief Timer A output 1 disable status */
      [2] = 0x00000002U,   /** @brief Timer A output 2 disable status */
    };

    static const uint32_t HRTIM_COMMON_BMTRG_TECMPx_MASK[3] = {
      [1] = 0x02000000U,   /** @brief TECMP1 */
      [2] = 0x04000000U,   /** @brief TECMP2 */
    };

    static const uint32_t HRTIM_COMMON_BMTRG_TDCMPx_MASK[3] = {
      [1] = 0x00200000U,   /** @brief TDCMP1 */
      [2] = 0x00400000U,   /** @brief TDCMP2 */
    };

    static const uint32_t HRTIM_COMMON_BMTRG_TCCMPx_MASK[3] = {
      [1] = 0x00020000U,   /** @brief TCCMP1 */
      [2] = 0x00040000U,   /** @brief TCCMP2 */
    };

    static const uint32_t HRTIM_COMMON_BMTRG_TBCMPx_MASK[3] = {
      [1] = 0x00002000U,   /** @brief TBCMP1 */
      [2] = 0x00004000U,   /** @brief TBCMP2 */
    };

    static const uint32_t HRTIM_COMMON_BMTRG_TACMPx_MASK[3] = {
      [1] = 0x00000200U,   /** @brief TACMP1 */
      [2] = 0x00000400U,   /** @brief TACMP2 */
    };

    static const uint32_t HRTIM_COMMON_BMTRG_MSTCMPx_MASK[5] = {
      [1] = 0x00000008U,   /** @brief MSTCMP1 */
      [2] = 0x00000010U,   /** @brief MSTCMP2 */
      [3] = 0x00000020U,   /** @brief MSTCMP3 */
      [4] = 0x00000040U,   /** @brief MSTCMP4 */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EExFAST_MASK[6] = {
      [1] = 0x00000020U,   /** @brief External event 1 fast mode */
      [2] = 0x00000800U,   /** @brief External event 2 fast mode */
      [3] = 0x00020000U,   /** @brief External event 3 fast mode */
      [4] = 0x00800000U,   /** @brief External event 4 fast mode */
      [5] = 0x20000000U,   /** @brief External event 5 fast mode */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EExSNS_MASK[6] = {
      [1] = 0x00000018U,   /** @brief External event 1 sensitivity */
      [2] = 0x00000600U,   /** @brief External event 2 sensitivity */
      [3] = 0x00018000U,   /** @brief External event 3 sensitivity */
      [4] = 0x00600000U,   /** @brief External event 4 sensitivity */
      [5] = 0x18000000U,   /** @brief External event 5 sensitivity */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EExPOL_MASK[6] = {
      [1] = 0x00000004U,   /** @brief External event 1 polarity */
      [2] = 0x00000100U,   /** @brief External event 2 polarity */
      [3] = 0x00004000U,   /** @brief External event 3 polarity */
      [4] = 0x00100000U,   /** @brief External event 4 polarity */
      [5] = 0x04000000U,   /** @brief External event 5 polarity */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EExSRC_MASK[6] = {
      [1] = 0x00000003U,   /** @brief External event 1 source */
      [2] = 0x000000C0U,   /** @brief External event 2 source */
      [3] = 0x00003000U,   /** @brief External event 3 source */
      [4] = 0x000C0000U,   /** @brief External event 4 source */
      [5] = 0x03000000U,   /** @brief External event 5 source */
    };

    static const uint32_t HRTIM_COMMON_ADC1R_AD1TECx_MASK[5] = {
      [2] = 0x10000000U,   /** @brief ADC trigger 1 on timer E compare 2 */
      [3] = 0x20000000U,   /** @brief ADC trigger 1 on timer E compare 3 */
      [4] = 0x40000000U,   /** @brief ADC trigger 1 on timer E compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC1R_AD1TDCx_MASK[5] = {
      [2] = 0x01000000U,   /** @brief ADC trigger 1 on timer D compare 2 */
      [3] = 0x02000000U,   /** @brief ADC trigger 1 on timer D compare 3 */
      [4] = 0x04000000U,   /** @brief ADC trigger 1 on timer D compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC1R_AD1TCCx_MASK[5] = {
      [2] = 0x00100000U,   /** @brief ADC trigger 1 on timer C compare 2 */
      [3] = 0x00200000U,   /** @brief ADC trigger 1 on timer C compare 3 */
      [4] = 0x00400000U,   /** @brief ADC trigger 1 on timer C compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC1R_AD1TBCx_MASK[5] = {
      [2] = 0x00008000U,   /** @brief ADC trigger 1 on timer B compare 2 */
      [3] = 0x00010000U,   /** @brief ADC trigger 1 on timer B compare 3 */
      [4] = 0x00020000U,   /** @brief ADC trigger 1 on timer B compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC1R_AD1TACx_MASK[5] = {
      [2] = 0x00000400U,   /** @brief ADC trigger 1 on timer A compare 2 */
      [3] = 0x00000800U,   /** @brief ADC trigger 1 on timer A compare 3 */
      [4] = 0x00001000U,   /** @brief ADC trigger 1 on timer A compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC1R_AD1EEVx_MASK[6] = {
      [1] = 0x00000020U,   /** @brief ADC trigger 1 on external event 1 */
      [2] = 0x00000040U,   /** @brief ADC trigger 1 on external event 2 */
      [3] = 0x00000080U,   /** @brief ADC trigger 1 on external event 3 */
      [4] = 0x00000100U,   /** @brief ADC trigger 1 on external event 4 */
      [5] = 0x00000200U,   /** @brief ADC trigger 1 on external event 5 */
    };

    static const uint32_t HRTIM_COMMON_ADC1R_AD1MCx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief ADC trigger 1 on master compare 1 */
      [2] = 0x00000002U,   /** @brief ADC trigger 1 on master compare 2 */
      [3] = 0x00000004U,   /** @brief ADC trigger 1 on master compare 3 */
      [4] = 0x00000008U,   /** @brief ADC trigger 1 on master compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC2R_AD2TECx_MASK[5] = {
      [2] = 0x10000000U,   /** @brief ADC trigger 2 on timer E compare 2 */
      [3] = 0x20000000U,   /** @brief ADC trigger 2 on timer E compare 3 */
      [4] = 0x40000000U,   /** @brief ADC trigger 2 on timer E compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC2R_AD2TDCx_MASK[5] = {
      [2] = 0x00800000U,   /** @brief ADC trigger 2 on timer D compare 2 */
      [3] = 0x01000000U,   /** @brief ADC trigger 2 on timer D compare 3 */
      [4] = 0x02000000U,   /** @brief ADC trigger 2 on timer D compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC2R_AD2TCCx_MASK[5] = {
      [2] = 0x00040000U,   /** @brief ADC trigger 2 on timer C compare 2 */
      [3] = 0x00080000U,   /** @brief ADC trigger 2 on timer C compare 3 */
      [4] = 0x00100000U,   /** @brief ADC trigger 2 on timer C compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC2R_AD2TBCx_MASK[5] = {
      [2] = 0x00004000U,   /** @brief ADC trigger 2 on timer B compare 2 */
      [3] = 0x00008000U,   /** @brief ADC trigger 2 on timer B compare 3 */
      [4] = 0x00010000U,   /** @brief ADC trigger 2 on timer B compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC2R_AD2TACx_MASK[5] = {
      [2] = 0x00000400U,   /** @brief ADC trigger 2 on timer A compare 2 */
      [3] = 0x00000800U,   /** @brief ADC trigger 2 on timer A compare 3 */
      [4] = 0x00001000U,   /** @brief ADC trigger 2 on timer A compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADC2R_AD2EEVx_MASK[11] = {
      [6]  = 0x00000020U,   /** @brief ADC trigger 2 on external event 6 */
      [7]  = 0x00000040U,   /** @brief ADC trigger 2 on external event 7 */
      [8]  = 0x00000080U,   /** @brief ADC trigger 2 on external event 8 */
      [9]  = 0x00000100U,   /** @brief ADC trigger 2 on external event 9 */
      [10] = 0x00000200U,   /** @brief ADC trigger 2 on external event 10 */
    };

    static const uint32_t HRTIM_COMMON_ADC2R_AD2MCx_MASK[5] = {
      [1] = 0x00000001U,   /** @brief ADC trigger 2 on master compare 1 */
      [2] = 0x00000002U,   /** @brief ADC trigger 2 on master compare 2 */
      [3] = 0x00000004U,   /** @brief ADC trigger 2 on master compare 3 */
      [4] = 0x00000008U,   /** @brief ADC trigger 2 on master compare 4 */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTxLCK_MASK[5] = {
      [1] = 0x00000080U,   /** @brief FLT1LCK */
      [2] = 0x00008000U,   /** @brief FLT2LCK */
      [3] = 0x00800000U,   /** @brief FLT3LCK */
      [4] = 0x80000000U,   /** @brief FLT4LCK */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTxF_MASK[5] = {
      [1] = 0x00000078U,   /** @brief FLT1F */
      [2] = 0x00007800U,   /** @brief FLT2F */
      [3] = 0x00780000U,   /** @brief FLT3F */
      [4] = 0x78000000U,   /** @brief FLT4F */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTxSRC_MASK[5] = {
      [1] = 0x00000004U,   /** @brief FLT1SRC */
      [2] = 0x00000400U,   /** @brief FLT2SRC */
      [3] = 0x00040000U,   /** @brief FLT3SRC */
      [4] = 0x04000000U,   /** @brief FLT4SRC */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief FLT1P */
      [2] = 0x00000200U,   /** @brief FLT2P */
      [3] = 0x00020000U,   /** @brief FLT3P */
      [4] = 0x02000000U,   /** @brief FLT4P */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief FLT1E */
      [2] = 0x00000100U,   /** @brief FLT2E */
      [3] = 0x00010000U,   /** @brief FLT3E */
      [4] = 0x01000000U,   /** @brief FLT4E */
    };

    static const uint32_t HRTIM_COMMON_BDMUPDR_MCMPx_MASK[5] = {
      [1] = 0x00000040U,   /** @brief MCMP1 */
      [2] = 0x00000080U,   /** @brief MCMP2 */
      [3] = 0x00000100U,   /** @brief MCMP3 */
      [4] = 0x00000200U,   /** @brief MCMP4 */
    };

    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXEEFRx_MASK[3] = {
      [1] = 0x00008000U,   /** @brief HRTIM_EEFxR1 register update enable */
      [2] = 0x00010000U,   /** @brief HRTIM_EEFxR2 register update enable */
    };

    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXRSTxR_MASK[3] = {
      [1] = 0x00001000U,   /** @brief HRTIM_RST1xR register update enable */
      [2] = 0x00004000U,   /** @brief HRTIM_RST2xR register update enable */
    };

    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXSETxR_MASK[3] = {
      [1] = 0x00000800U,   /** @brief HRTIM_SET1xR register update enable */
      [2] = 0x00002000U,   /** @brief HRTIM_SET2xR register update enable */
    };

    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCMPx_MASK[5] = {
      [1] = 0x00000040U,   /** @brief HRTIM_CMP1xR register update enable */
      [2] = 0x00000080U,   /** @brief HRTIM_CMP2xR register update enable */
      [3] = 0x00000100U,   /** @brief HRTIM_CMP3xR register update enable */
      [4] = 0x00000200U,   /** @brief HRTIM_CMP4xR register update enable */
    };

    /**** @subsection HRTIM_COMMON Register Field Positions ****/

    static const int32_t HRTIM_COMMON_CR1_TEUDIS_POS          = 5;    /** @brief Timer E update disable */
    static const int32_t HRTIM_COMMON_CR1_TDUDIS_POS          = 4;    /** @brief Timer D update disable */
    static const int32_t HRTIM_COMMON_CR1_TCUDIS_POS          = 3;    /** @brief Timer C update disable */
    static const int32_t HRTIM_COMMON_CR1_TBUDIS_POS          = 2;    /** @brief Timer B update disable */
    static const int32_t HRTIM_COMMON_CR1_TAUDIS_POS          = 1;    /** @brief Timer A update disable */
    static const int32_t HRTIM_COMMON_CR1_MUDIS_POS           = 0;    /** @brief Master update disable */
    static const int32_t HRTIM_COMMON_CR2_TERST_POS           = 13;   /** @brief Timer E counter software reset */
    static const int32_t HRTIM_COMMON_CR2_TDRST_POS           = 12;   /** @brief Timer D counter software reset */
    static const int32_t HRTIM_COMMON_CR2_TCRST_POS           = 11;   /** @brief Timer C counter software reset */
    static const int32_t HRTIM_COMMON_CR2_TBRST_POS           = 10;   /** @brief Timer B counter software reset */
    static const int32_t HRTIM_COMMON_CR2_TARST_POS           = 9;    /** @brief Timer A counter software reset */
    static const int32_t HRTIM_COMMON_CR2_MRST_POS            = 8;    /** @brief Master counter software reset */
    static const int32_t HRTIM_COMMON_CR2_TESWU_POS           = 5;    /** @brief Timer E software update */
    static const int32_t HRTIM_COMMON_CR2_TDSWU_POS           = 4;    /** @brief Timer D software update */
    static const int32_t HRTIM_COMMON_CR2_TCSWU_POS           = 3;    /** @brief Timer C software update */
    static const int32_t HRTIM_COMMON_CR2_TBSWU_POS           = 2;    /** @brief Timer B software update */
    static const int32_t HRTIM_COMMON_CR2_TASWU_POS           = 1;    /** @brief Timer A software update */
    static const int32_t HRTIM_COMMON_CR2_MSWU_POS            = 0;    /** @brief Master timer software update */
    static const int32_t HRTIM_COMMON_ISR_BMPER_POS           = 17;   /** @brief Burst mode period interrupt flag */
    static const int32_t HRTIM_COMMON_ISR_DLLRDY_POS          = 16;   /** @brief DLL ready interrupt flag */
    static const int32_t HRTIM_COMMON_ISR_SYSFLT_POS          = 5;    /** @brief System fault interrupt flag */
    static const int32_t HRTIM_COMMON_ICR_BMPERC_POS          = 17;   /** @brief Burst mode period flag clear */
    static const int32_t HRTIM_COMMON_ICR_DLLRDYC_POS         = 16;   /** @brief DLL ready interrupt flag clear */
    static const int32_t HRTIM_COMMON_ICR_SYSFLTC_POS         = 5;    /** @brief System fault interrupt flag clear */
    static const int32_t HRTIM_COMMON_IER_BMPERIE_POS         = 17;   /** @brief Burst mode period interrupt enable */
    static const int32_t HRTIM_COMMON_IER_DLLRDYIE_POS        = 16;   /** @brief DLL ready interrupt enable */
    static const int32_t HRTIM_COMMON_IER_SYSFLTE_POS         = 5;    /** @brief System fault interrupt enable */
    static const int32_t HRTIM_COMMON_BMCR_BMSTAT_POS         = 31;   /** @brief Burst mode status */
    static const int32_t HRTIM_COMMON_BMCR_TEBM_POS           = 21;   /** @brief Timer E burst mode */
    static const int32_t HRTIM_COMMON_BMCR_TDBM_POS           = 20;   /** @brief Timer D burst mode */
    static const int32_t HRTIM_COMMON_BMCR_TCBM_POS           = 19;   /** @brief Timer C burst mode */
    static const int32_t HRTIM_COMMON_BMCR_TBBM_POS           = 18;   /** @brief Timer B burst mode */
    static const int32_t HRTIM_COMMON_BMCR_TABM_POS           = 17;   /** @brief Timer A burst mode */
    static const int32_t HRTIM_COMMON_BMCR_MTBM_POS           = 16;   /** @brief Master timer burst mode */
    static const int32_t HRTIM_COMMON_BMCR_BMPREN_POS         = 10;   /** @brief Burst mode preload enable */
    static const int32_t HRTIM_COMMON_BMCR_BMPRSC_POS         = 6;    /** @brief Burst mode prescaler */
    static const int32_t HRTIM_COMMON_BMCR_BMCLK_POS          = 2;    /** @brief Burst mode clock source */
    static const int32_t HRTIM_COMMON_BMCR_BMOM_POS           = 1;    /** @brief Burst mode operating mode */
    static const int32_t HRTIM_COMMON_BMCR_BME_POS            = 0;    /** @brief Burst mode enable */
    static const int32_t HRTIM_COMMON_BMTRG_OCHPEV_POS        = 31;   /** @brief OCHPEV */
    static const int32_t HRTIM_COMMON_BMTRG_TEREP_POS         = 24;   /** @brief TEREP */
    static const int32_t HRTIM_COMMON_BMTRG_TERST_POS         = 23;   /** @brief TERST */
    static const int32_t HRTIM_COMMON_BMTRG_TDREP_POS         = 20;   /** @brief TDREP */
    static const int32_t HRTIM_COMMON_BMTRG_TDRST_POS         = 19;   /** @brief TDRST */
    static const int32_t HRTIM_COMMON_BMTRG_TCREP_POS         = 16;   /** @brief TCREP */
    static const int32_t HRTIM_COMMON_BMTRG_TCRST_POS         = 15;   /** @brief TCRST */
    static const int32_t HRTIM_COMMON_BMTRG_TBREP_POS         = 12;   /** @brief TBREP */
    static const int32_t HRTIM_COMMON_BMTRG_TBRST_POS         = 11;   /** @brief TBRST */
    static const int32_t HRTIM_COMMON_BMTRG_TAREP_POS         = 8;    /** @brief TAREP */
    static const int32_t HRTIM_COMMON_BMTRG_TARST_POS         = 7;    /** @brief TARST */
    static const int32_t HRTIM_COMMON_BMTRG_MSTREP_POS        = 2;    /** @brief MSTREP */
    static const int32_t HRTIM_COMMON_BMTRG_MSTRST_POS        = 1;    /** @brief MSTRST */
    static const int32_t HRTIM_COMMON_BMTRG_SW_POS            = 0;    /** @brief SW */
    static const int32_t HRTIM_COMMON_BMCMPR6_BMCMP_POS       = 0;    /** @brief BMCMP */
    static const int32_t HRTIM_COMMON_BMPER_BMPER_POS         = 0;    /** @brief Burst mode period */
    static const int32_t HRTIM_COMMON_ADC1R_AD1TEPER_POS      = 31;   /** @brief ADC trigger 1 on timer E period */
    static const int32_t HRTIM_COMMON_ADC1R_AD1TDPER_POS      = 27;   /** @brief ADC trigger 1 on timer D period */
    static const int32_t HRTIM_COMMON_ADC1R_AD1TCPER_POS      = 23;   /** @brief ADC trigger 1 on timer C period */
    static const int32_t HRTIM_COMMON_ADC1R_AD1TBRST_POS      = 19;   /** @brief ADC trigger 1 on timer B reset */
    static const int32_t HRTIM_COMMON_ADC1R_AD1TBPER_POS      = 18;   /** @brief ADC trigger 1 on timer B period */
    static const int32_t HRTIM_COMMON_ADC1R_AD1TARST_POS      = 14;   /** @brief ADC trigger 1 on timer A reset */
    static const int32_t HRTIM_COMMON_ADC1R_AD1TAPER_POS      = 13;   /** @brief ADC trigger 1 on timer A period */
    static const int32_t HRTIM_COMMON_ADC1R_AD1MPER_POS       = 4;    /** @brief ADC trigger 1 on master period */
    static const int32_t HRTIM_COMMON_ADC2R_AD2TERST_POS      = 31;   /** @brief ADC trigger 2 on timer E reset */
    static const int32_t HRTIM_COMMON_ADC2R_AD2TDRST_POS      = 27;   /** @brief ADC trigger 2 on timer D reset */
    static const int32_t HRTIM_COMMON_ADC2R_AD2TDPER_POS      = 26;   /** @brief ADC trigger 2 on timer D period */
    static const int32_t HRTIM_COMMON_ADC2R_AD2TCRST_POS      = 22;   /** @brief ADC trigger 2 on timer C reset */
    static const int32_t HRTIM_COMMON_ADC2R_AD2TCPER_POS      = 21;   /** @brief ADC trigger 2 on timer C period */
    static const int32_t HRTIM_COMMON_ADC2R_AD2TBPER_POS      = 17;   /** @brief ADC trigger 2 on timer B period */
    static const int32_t HRTIM_COMMON_ADC2R_AD2TAPER_POS      = 13;   /** @brief ADC trigger 2 on timer A period */
    static const int32_t HRTIM_COMMON_ADC2R_AD2MPER_POS       = 4;    /** @brief ADC trigger 2 on master period */
    static const int32_t HRTIM_COMMON_ADC3R_AD1TEPER_POS      = 31;   /** @brief AD1TEPER */
    static const int32_t HRTIM_COMMON_ADC3R_AD1TDPER_POS      = 27;   /** @brief AD1TDPER */
    static const int32_t HRTIM_COMMON_ADC3R_AD1TCPER_POS      = 23;   /** @brief AD1TCPER */
    static const int32_t HRTIM_COMMON_ADC3R_AD1TBRST_POS      = 19;   /** @brief AD1TBRST */
    static const int32_t HRTIM_COMMON_ADC3R_AD1TBPER_POS      = 18;   /** @brief AD1TBPER */
    static const int32_t HRTIM_COMMON_ADC3R_AD1TARST_POS      = 14;   /** @brief AD1TARST */
    static const int32_t HRTIM_COMMON_ADC3R_AD1TAPER_POS      = 13;   /** @brief AD1TAPER */
    static const int32_t HRTIM_COMMON_ADC3R_AD1MPER_POS       = 4;    /** @brief AD1MPER */
    static const int32_t HRTIM_COMMON_ADC4R_AD2TERST_POS      = 31;   /** @brief AD2TERST */
    static const int32_t HRTIM_COMMON_ADC4R_AD2TDRST_POS      = 27;   /** @brief AD2TDRST */
    static const int32_t HRTIM_COMMON_ADC4R_AD2TDPER_POS      = 26;   /** @brief AD2TDPER */
    static const int32_t HRTIM_COMMON_ADC4R_AD2TCRST_POS      = 22;   /** @brief AD2TCRST */
    static const int32_t HRTIM_COMMON_ADC4R_AD2TCPER_POS      = 21;   /** @brief AD2TCPER */
    static const int32_t HRTIM_COMMON_ADC4R_AD2TBPER_POS      = 17;   /** @brief AD2TBPER */
    static const int32_t HRTIM_COMMON_ADC4R_AD2TAPER_POS      = 13;   /** @brief AD2TAPER */
    static const int32_t HRTIM_COMMON_ADC4R_AD2MPER_POS       = 4;    /** @brief AD2MPER */
    static const int32_t HRTIM_COMMON_DLLCR_CALRTE_POS        = 2;    /** @brief DLL calibration rate */
    static const int32_t HRTIM_COMMON_DLLCR_CALEN_POS         = 1;    /** @brief DLL calibration enable */
    static const int32_t HRTIM_COMMON_DLLCR_CAL_POS           = 0;    /** @brief DLL calibration start */
    static const int32_t HRTIM_COMMON_FLTINR2_FLTSD_POS       = 24;   /** @brief FLTSD */
    static const int32_t HRTIM_COMMON_FLTINR2_FLT5LCK_POS     = 7;    /** @brief FLT5LCK */
    static const int32_t HRTIM_COMMON_FLTINR2_FLT5F_POS       = 3;    /** @brief FLT5F */
    static const int32_t HRTIM_COMMON_FLTINR2_FLT5SRC_POS     = 2;    /** @brief FLT5SRC */
    static const int32_t HRTIM_COMMON_FLTINR2_FLT5P_POS       = 1;    /** @brief FLT5P */
    static const int32_t HRTIM_COMMON_FLTINR2_FLT5E_POS       = 0;    /** @brief FLT5E */
    static const int32_t HRTIM_COMMON_BDMUPDR_MREP_POS        = 5;    /** @brief MREP */
    static const int32_t HRTIM_COMMON_BDMUPDR_MPER_POS        = 4;    /** @brief MPER */
    static const int32_t HRTIM_COMMON_BDMUPDR_MCNT_POS        = 3;    /** @brief MCNT */
    static const int32_t HRTIM_COMMON_BDMUPDR_MDIER_POS       = 2;    /** @brief MDIER */
    static const int32_t HRTIM_COMMON_BDMUPDR_MICR_POS        = 1;    /** @brief MICR */
    static const int32_t HRTIM_COMMON_BDMUPDR_MCR_POS         = 0;    /** @brief MCR */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXFLTR_POS    = 20;   /** @brief HRTIM_FLTxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXOUTR_POS    = 19;   /** @brief HRTIM_OUTxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCHPR_POS    = 18;   /** @brief HRTIM_CHPxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXRSTR_POS    = 17;   /** @brief HRTIM_RSTxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMX_DTXR_POS   = 10;   /** @brief HRTIM_DTxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXREP_POS     = 5;    /** @brief HRTIM_REPxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXPER_POS     = 4;    /** @brief HRTIM_PERxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCNT_POS     = 3;    /** @brief HRTIM_CNTxR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXDIER_POS    = 2;    /** @brief HRTIM_TIMxDIER register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXICR_POS     = 1;    /** @brief HRTIM_TIMxICR register update enable */
    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCR_POS      = 0;    /** @brief HRTIM_TIMxCR register update enable */

    /**** @subsection Enumerated HRTIM_COMMON Register Field Positions ****/

    static const int32_t HRTIM_COMMON_CR1_ADxUSRC_POS[5] = {
      [1] = 16,   /** @brief ADC trigger 1 update source */
      [2] = 19,   /** @brief ADC trigger 2 update source */
      [3] = 22,   /** @brief ADC trigger 3 update source */
      [4] = 25,   /** @brief ADC trigger 4 update source */
    };

    static const int32_t HRTIM_COMMON_ISR_FLTx_POS[6] = {
      [1] = 0,   /** @brief Fault 1 interrupt flag */
      [2] = 1,   /** @brief Fault 2 interrupt flag */
      [3] = 2,   /** @brief Fault 3 interrupt flag */
      [4] = 3,   /** @brief Fault 4 interrupt flag */
      [5] = 4,   /** @brief Fault 5 interrupt flag */
    };

    static const int32_t HRTIM_COMMON_ICR_FLTxC_POS[6] = {
      [1] = 0,   /** @brief Fault 1 interrupt flag clear */
      [2] = 1,   /** @brief Fault 2 interrupt flag clear */
      [3] = 2,   /** @brief Fault 3 interrupt flag clear */
      [4] = 3,   /** @brief Fault 4 interrupt flag clear */
      [5] = 4,   /** @brief Fault 5 interrupt flag clear */
    };

    static const int32_t HRTIM_COMMON_IER_FLTxIE_POS[6] = {
      [1] = 0,   /** @brief Fault 1 interrupt enable */
      [2] = 1,   /** @brief Fault 2 interrupt enable */
      [3] = 2,   /** @brief Fault 3 interrupt enable */
      [4] = 3,   /** @brief Fault 4 interrupt enable */
      [5] = 4,   /** @brief Fault 5 interrupt enable */
    };

    static const int32_t HRTIM_COMMON_OENR_TExOEN_POS[3] = {
      [1] = 8,   /** @brief Timer E output 1 enable */
      [2] = 9,   /** @brief Timer E output 2 enable */
    };

    static const int32_t HRTIM_COMMON_OENR_TDxOEN_POS[3] = {
      [1] = 6,   /** @brief Timer D output 1 enable */
      [2] = 7,   /** @brief Timer D output 2 enable */
    };

    static const int32_t HRTIM_COMMON_OENR_TCxOEN_POS[3] = {
      [1] = 4,   /** @brief Timer C output 1 enable */
      [2] = 5,   /** @brief Timer C output 2 enable */
    };

    static const int32_t HRTIM_COMMON_OENR_TBxOEN_POS[3] = {
      [1] = 2,   /** @brief Timer B output 1 enable */
      [2] = 3,   /** @brief Timer B output 2 enable */
    };

    static const int32_t HRTIM_COMMON_OENR_TAxOEN_POS[3] = {
      [1] = 0,   /** @brief Timer A output 1 enable */
      [2] = 1,   /** @brief Timer A output 2 enable */
    };

    static const int32_t HRTIM_COMMON_DISR_TExODIS_POS[3] = {
      [1] = 8,   /** @brief TE1ODIS */
      [2] = 9,   /** @brief TE2ODIS */
    };

    static const int32_t HRTIM_COMMON_DISR_TDxODIS_POS[3] = {
      [1] = 6,   /** @brief TD1ODIS */
      [2] = 7,   /** @brief TD2ODIS */
    };

    static const int32_t HRTIM_COMMON_DISR_TCxODIS_POS[3] = {
      [1] = 4,   /** @brief TC1ODIS */
      [2] = 5,   /** @brief TC2ODIS */
    };

    static const int32_t HRTIM_COMMON_DISR_TBxODIS_POS[3] = {
      [1] = 2,   /** @brief TB1ODIS */
      [2] = 3,   /** @brief TB2ODIS */
    };

    static const int32_t HRTIM_COMMON_DISR_TAxODIS_POS[3] = {
      [1] = 0,   /** @brief TA1ODIS */
      [2] = 1,   /** @brief TA2ODIS */
    };

    static const int32_t HRTIM_COMMON_ODSR_TExODS_POS[3] = {
      [1] = 8,   /** @brief Timer E output 1 disable status */
      [2] = 9,   /** @brief Timer E output 2 disable status */
    };

    static const int32_t HRTIM_COMMON_ODSR_TDxODS_POS[3] = {
      [1] = 6,   /** @brief Timer D output 1 disable status */
      [2] = 7,   /** @brief Timer D output 2 disable status */
    };

    static const int32_t HRTIM_COMMON_ODSR_TCxODS_POS[3] = {
      [1] = 4,   /** @brief Timer C output 1 disable status */
      [2] = 5,   /** @brief Timer C output 2 disable status */
    };

    static const int32_t HRTIM_COMMON_ODSR_TBxODS_POS[3] = {
      [1] = 2,   /** @brief Timer B output 1 disable status */
      [2] = 3,   /** @brief Timer B output 2 disable status */
    };

    static const int32_t HRTIM_COMMON_ODSR_TAxODS_POS[3] = {
      [1] = 0,   /** @brief Timer A output 1 disable status */
      [2] = 1,   /** @brief Timer A output 2 disable status */
    };

    static const int32_t HRTIM_COMMON_BMTRG_TECMPx_POS[3] = {
      [1] = 25,   /** @brief TECMP1 */
      [2] = 26,   /** @brief TECMP2 */
    };

    static const int32_t HRTIM_COMMON_BMTRG_TDCMPx_POS[3] = {
      [1] = 21,   /** @brief TDCMP1 */
      [2] = 22,   /** @brief TDCMP2 */
    };

    static const int32_t HRTIM_COMMON_BMTRG_TCCMPx_POS[3] = {
      [1] = 17,   /** @brief TCCMP1 */
      [2] = 18,   /** @brief TCCMP2 */
    };

    static const int32_t HRTIM_COMMON_BMTRG_TBCMPx_POS[3] = {
      [1] = 13,   /** @brief TBCMP1 */
      [2] = 14,   /** @brief TBCMP2 */
    };

    static const int32_t HRTIM_COMMON_BMTRG_TACMPx_POS[3] = {
      [1] = 9,    /** @brief TACMP1 */
      [2] = 10,   /** @brief TACMP2 */
    };

    static const int32_t HRTIM_COMMON_BMTRG_MSTCMPx_POS[5] = {
      [1] = 3,   /** @brief MSTCMP1 */
      [2] = 4,   /** @brief MSTCMP2 */
      [3] = 5,   /** @brief MSTCMP3 */
      [4] = 6,   /** @brief MSTCMP4 */
    };

    static const int32_t HRTIM_COMMON_EECR1_EExFAST_POS[6] = {
      [1] = 5,    /** @brief External event 1 fast mode */
      [2] = 11,   /** @brief External event 2 fast mode */
      [3] = 17,   /** @brief External event 3 fast mode */
      [4] = 23,   /** @brief External event 4 fast mode */
      [5] = 29,   /** @brief External event 5 fast mode */
    };

    static const int32_t HRTIM_COMMON_EECR1_EExSNS_POS[6] = {
      [1] = 3,    /** @brief External event 1 sensitivity */
      [2] = 9,    /** @brief External event 2 sensitivity */
      [3] = 15,   /** @brief External event 3 sensitivity */
      [4] = 21,   /** @brief External event 4 sensitivity */
      [5] = 27,   /** @brief External event 5 sensitivity */
    };

    static const int32_t HRTIM_COMMON_EECR1_EExPOL_POS[6] = {
      [1] = 2,    /** @brief External event 1 polarity */
      [2] = 8,    /** @brief External event 2 polarity */
      [3] = 14,   /** @brief External event 3 polarity */
      [4] = 20,   /** @brief External event 4 polarity */
      [5] = 26,   /** @brief External event 5 polarity */
    };

    static const int32_t HRTIM_COMMON_EECR1_EExSRC_POS[6] = {
      [1] = 0,    /** @brief External event 1 source */
      [2] = 6,    /** @brief External event 2 source */
      [3] = 12,   /** @brief External event 3 source */
      [4] = 18,   /** @brief External event 4 source */
      [5] = 24,   /** @brief External event 5 source */
    };

    static const int32_t HRTIM_COMMON_ADC1R_AD1TECx_POS[5] = {
      [2] = 28,   /** @brief ADC trigger 1 on timer E compare 2 */
      [3] = 29,   /** @brief ADC trigger 1 on timer E compare 3 */
      [4] = 30,   /** @brief ADC trigger 1 on timer E compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC1R_AD1TDCx_POS[5] = {
      [2] = 24,   /** @brief ADC trigger 1 on timer D compare 2 */
      [3] = 25,   /** @brief ADC trigger 1 on timer D compare 3 */
      [4] = 26,   /** @brief ADC trigger 1 on timer D compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC1R_AD1TCCx_POS[5] = {
      [2] = 20,   /** @brief ADC trigger 1 on timer C compare 2 */
      [3] = 21,   /** @brief ADC trigger 1 on timer C compare 3 */
      [4] = 22,   /** @brief ADC trigger 1 on timer C compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC1R_AD1TBCx_POS[5] = {
      [2] = 15,   /** @brief ADC trigger 1 on timer B compare 2 */
      [3] = 16,   /** @brief ADC trigger 1 on timer B compare 3 */
      [4] = 17,   /** @brief ADC trigger 1 on timer B compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC1R_AD1TACx_POS[5] = {
      [2] = 10,   /** @brief ADC trigger 1 on timer A compare 2 */
      [3] = 11,   /** @brief ADC trigger 1 on timer A compare 3 */
      [4] = 12,   /** @brief ADC trigger 1 on timer A compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC1R_AD1EEVx_POS[6] = {
      [1] = 5,   /** @brief ADC trigger 1 on external event 1 */
      [2] = 6,   /** @brief ADC trigger 1 on external event 2 */
      [3] = 7,   /** @brief ADC trigger 1 on external event 3 */
      [4] = 8,   /** @brief ADC trigger 1 on external event 4 */
      [5] = 9,   /** @brief ADC trigger 1 on external event 5 */
    };

    static const int32_t HRTIM_COMMON_ADC1R_AD1MCx_POS[5] = {
      [1] = 0,   /** @brief ADC trigger 1 on master compare 1 */
      [2] = 1,   /** @brief ADC trigger 1 on master compare 2 */
      [3] = 2,   /** @brief ADC trigger 1 on master compare 3 */
      [4] = 3,   /** @brief ADC trigger 1 on master compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC2R_AD2TECx_POS[5] = {
      [2] = 28,   /** @brief ADC trigger 2 on timer E compare 2 */
      [3] = 29,   /** @brief ADC trigger 2 on timer E compare 3 */
      [4] = 30,   /** @brief ADC trigger 2 on timer E compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC2R_AD2TDCx_POS[5] = {
      [2] = 23,   /** @brief ADC trigger 2 on timer D compare 2 */
      [3] = 24,   /** @brief ADC trigger 2 on timer D compare 3 */
      [4] = 25,   /** @brief ADC trigger 2 on timer D compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC2R_AD2TCCx_POS[5] = {
      [2] = 18,   /** @brief ADC trigger 2 on timer C compare 2 */
      [3] = 19,   /** @brief ADC trigger 2 on timer C compare 3 */
      [4] = 20,   /** @brief ADC trigger 2 on timer C compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC2R_AD2TBCx_POS[5] = {
      [2] = 14,   /** @brief ADC trigger 2 on timer B compare 2 */
      [3] = 15,   /** @brief ADC trigger 2 on timer B compare 3 */
      [4] = 16,   /** @brief ADC trigger 2 on timer B compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC2R_AD2TACx_POS[5] = {
      [2] = 10,   /** @brief ADC trigger 2 on timer A compare 2 */
      [3] = 11,   /** @brief ADC trigger 2 on timer A compare 3 */
      [4] = 12,   /** @brief ADC trigger 2 on timer A compare 4 */
    };

    static const int32_t HRTIM_COMMON_ADC2R_AD2EEVx_POS[11] = {
      [6]  = 5,   /** @brief ADC trigger 2 on external event 6 */
      [7]  = 6,   /** @brief ADC trigger 2 on external event 7 */
      [8]  = 7,   /** @brief ADC trigger 2 on external event 8 */
      [9]  = 8,   /** @brief ADC trigger 2 on external event 9 */
      [10] = 9,   /** @brief ADC trigger 2 on external event 10 */
    };

    static const int32_t HRTIM_COMMON_ADC2R_AD2MCx_POS[5] = {
      [1] = 0,   /** @brief ADC trigger 2 on master compare 1 */
      [2] = 1,   /** @brief ADC trigger 2 on master compare 2 */
      [3] = 2,   /** @brief ADC trigger 2 on master compare 3 */
      [4] = 3,   /** @brief ADC trigger 2 on master compare 4 */
    };

    static const int32_t HRTIM_COMMON_FLTINR1_FLTxLCK_POS[5] = {
      [1] = 7,    /** @brief FLT1LCK */
      [2] = 15,   /** @brief FLT2LCK */
      [3] = 23,   /** @brief FLT3LCK */
      [4] = 31,   /** @brief FLT4LCK */
    };

    static const int32_t HRTIM_COMMON_FLTINR1_FLTxF_POS[5] = {
      [1] = 3,    /** @brief FLT1F */
      [2] = 11,   /** @brief FLT2F */
      [3] = 19,   /** @brief FLT3F */
      [4] = 27,   /** @brief FLT4F */
    };

    static const int32_t HRTIM_COMMON_FLTINR1_FLTxSRC_POS[5] = {
      [1] = 2,    /** @brief FLT1SRC */
      [2] = 10,   /** @brief FLT2SRC */
      [3] = 18,   /** @brief FLT3SRC */
      [4] = 26,   /** @brief FLT4SRC */
    };

    static const int32_t HRTIM_COMMON_FLTINR1_FLTxP_POS[5] = {
      [1] = 1,    /** @brief FLT1P */
      [2] = 9,    /** @brief FLT2P */
      [3] = 17,   /** @brief FLT3P */
      [4] = 25,   /** @brief FLT4P */
    };

    static const int32_t HRTIM_COMMON_FLTINR1_FLTxE_POS[5] = {
      [1] = 0,    /** @brief FLT1E */
      [2] = 8,    /** @brief FLT2E */
      [3] = 16,   /** @brief FLT3E */
      [4] = 24,   /** @brief FLT4E */
    };

    static const int32_t HRTIM_COMMON_BDMUPDR_MCMPx_POS[5] = {
      [1] = 6,   /** @brief MCMP1 */
      [2] = 7,   /** @brief MCMP2 */
      [3] = 8,   /** @brief MCMP3 */
      [4] = 9,   /** @brief MCMP4 */
    };

    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXEEFRx_POS[3] = {
      [1] = 15,   /** @brief HRTIM_EEFxR1 register update enable */
      [2] = 16,   /** @brief HRTIM_EEFxR2 register update enable */
    };

    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXRSTxR_POS[3] = {
      [1] = 12,   /** @brief HRTIM_RST1xR register update enable */
      [2] = 14,   /** @brief HRTIM_RST2xR register update enable */
    };

    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXSETxR_POS[3] = {
      [1] = 11,   /** @brief HRTIM_SET1xR register update enable */
      [2] = 13,   /** @brief HRTIM_SET2xR register update enable */
    };

    static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCMPx_POS[5] = {
      [1] = 6,   /** @brief HRTIM_CMP1xR register update enable */
      [2] = 7,   /** @brief HRTIM_CMP2xR register update enable */
      [3] = 8,   /** @brief HRTIM_CMP3xR register update enable */
      [4] = 9,   /** @brief HRTIM_CMP4xR register update enable */
    };

    /**********************************************************************************************
     * @section DFSDM Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated DFSDM Register Pointers ****/

    static RW_ uint32_t* const DFSDM_DFSDM_CHCFGxR1_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40017000U,   /** @brief DFSDM channel configuration 0 register 1 */
      [1] = (RW_ uint32_t* const)0x40017004U,   /** @brief DFSDM channel configuration 1 register 1 */
      [2] = (RW_ uint32_t* const)0x40017008U,   /** @brief DFSDM channel configuration 2 register 1 */
      [3] = (RW_ uint32_t* const)0x4001700CU,   /** @brief DFSDM channel configuration 3 register 1 */
      [4] = (RW_ uint32_t* const)0x40017010U,   /** @brief DFSDM channel configuration 4 register 1 */
      [5] = (RW_ uint32_t* const)0x40017014U,   /** @brief DFSDM channel configuration 5 register 1 */
      [6] = (RW_ uint32_t* const)0x40017018U,   /** @brief DFSDM channel configuration 6 register 1 */
      [7] = (RW_ uint32_t* const)0x4001701CU,   /** @brief DFSDM channel configuration 7 register 1 */
    };

    static RW_ uint32_t* const DFSDM_DFSDM_CHCFGxR2_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40017020U,   /** @brief DFSDM channel configuration 0 register 2 */
      [1] = (RW_ uint32_t* const)0x40017024U,   /** @brief DFSDM channel configuration 1 register 2 */
      [2] = (RW_ uint32_t* const)0x40017028U,   /** @brief DFSDM channel configuration 2 register 2 */
      [3] = (RW_ uint32_t* const)0x4001702CU,   /** @brief DFSDM channel configuration 3 register 2 */
      [4] = (RW_ uint32_t* const)0x40017030U,   /** @brief DFSDM channel configuration 4 register 2 */
      [5] = (RW_ uint32_t* const)0x40017034U,   /** @brief DFSDM channel configuration 5 register 2 */
      [6] = (RW_ uint32_t* const)0x40017038U,   /** @brief DFSDM channel configuration 6 register 2 */
      [7] = (RW_ uint32_t* const)0x4001703CU,   /** @brief DFSDM channel configuration 7 register 2 */
    };

    static RW_ uint32_t* const DFSDM_DFSDM_AWSCDxR_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40017040U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [1] = (RW_ uint32_t* const)0x40017044U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [2] = (RW_ uint32_t* const)0x40017048U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [3] = (RW_ uint32_t* const)0x4001704CU,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [4] = (RW_ uint32_t* const)0x40017050U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [5] = (RW_ uint32_t* const)0x40017054U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [6] = (RW_ uint32_t* const)0x40017058U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [7] = (RW_ uint32_t* const)0x4001705CU,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    };

    static RO_ uint32_t* const DFSDM_DFSDM_CHWDATxR_PTR[8] = {
      [0] = (RO_ uint32_t* const)0x40017060U,   /** @brief DFSDM channel watchdog filter data register */
      [1] = (RO_ uint32_t* const)0x40017064U,   /** @brief DFSDM channel watchdog filter data register */
      [2] = (RO_ uint32_t* const)0x40017068U,   /** @brief DFSDM channel watchdog filter data register */
      [3] = (RO_ uint32_t* const)0x4001706CU,   /** @brief DFSDM channel watchdog filter data register */
      [4] = (RO_ uint32_t* const)0x40017070U,   /** @brief DFSDM channel watchdog filter data register */
      [5] = (RO_ uint32_t* const)0x40017074U,   /** @brief DFSDM channel watchdog filter data register */
      [6] = (RO_ uint32_t* const)0x40017078U,   /** @brief DFSDM channel watchdog filter data register */
      [7] = (RO_ uint32_t* const)0x4001707CU,   /** @brief DFSDM channel watchdog filter data register */
    };

    static RW_ uint32_t* const DFSDM_DFSDM_CHDATINxR_PTR[8] = {
      [0] = (RW_ uint32_t* const)0x40017080U,   /** @brief DFSDM channel data input register */
      [1] = (RW_ uint32_t* const)0x40017084U,   /** @brief DFSDM channel data input register */
      [2] = (RW_ uint32_t* const)0x40017088U,   /** @brief DFSDM channel data input register */
      [3] = (RW_ uint32_t* const)0x4001708CU,   /** @brief DFSDM channel data input register */
      [4] = (RW_ uint32_t* const)0x40017090U,   /** @brief DFSDM channel data input register */
      [5] = (RW_ uint32_t* const)0x40017094U,   /** @brief DFSDM channel data input register */
      [6] = (RW_ uint32_t* const)0x40017098U,   /** @brief DFSDM channel data input register */
      [7] = (RW_ uint32_t* const)0x4001709CU,   /** @brief DFSDM channel data input register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_CR1_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x400170A0U,   /** @brief DFSDM control register 1 */
      [1] = (RW_ uint32_t* const)0x400170A4U,   /** @brief DFSDM control register 1 */
      [2] = (RW_ uint32_t* const)0x400170A8U,   /** @brief DFSDM control register 1 */
      [3] = (RW_ uint32_t* const)0x400170ACU,   /** @brief DFSDM control register 1 */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_CR2_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x400170B0U,   /** @brief DFSDM control register 2 */
      [1] = (RW_ uint32_t* const)0x400170B4U,   /** @brief DFSDM control register 2 */
      [2] = (RW_ uint32_t* const)0x400170B8U,   /** @brief DFSDM control register 2 */
      [3] = (RW_ uint32_t* const)0x400170BCU,   /** @brief DFSDM control register 2 */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_ISR_PTR[4] = {
      [0] = (RO_ uint32_t* const)0x400170C0U,   /** @brief DFSDM interrupt and status register */
      [1] = (RO_ uint32_t* const)0x400170C4U,   /** @brief DFSDM interrupt and status register */
      [2] = (RO_ uint32_t* const)0x400170C8U,   /** @brief DFSDM interrupt and status register */
      [3] = (RO_ uint32_t* const)0x400170CCU,   /** @brief DFSDM interrupt and status register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_ICR_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x400170D0U,   /** @brief DFSDM interrupt flag clear register */
      [1] = (RW_ uint32_t* const)0x400170D4U,   /** @brief DFSDM interrupt flag clear register */
      [2] = (RW_ uint32_t* const)0x400170D8U,   /** @brief DFSDM interrupt flag clear register */
      [3] = (RW_ uint32_t* const)0x400170DCU,   /** @brief DFSDM interrupt flag clear register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_JCHGR_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x400170E0U,   /** @brief DFSDM injected channel group selection register */
      [1] = (RW_ uint32_t* const)0x400170E4U,   /** @brief DFSDM injected channel group selection register */
      [2] = (RW_ uint32_t* const)0x400170E8U,   /** @brief DFSDM injected channel group selection register */
      [3] = (RW_ uint32_t* const)0x400170ECU,   /** @brief DFSDM injected channel group selection register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_FCR_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x400170F0U,   /** @brief DFSDM filter control register */
      [1] = (RW_ uint32_t* const)0x400170F4U,   /** @brief DFSDM filter control register */
      [2] = (RW_ uint32_t* const)0x400170F8U,   /** @brief DFSDM filter control register */
      [3] = (RW_ uint32_t* const)0x400170FCU,   /** @brief DFSDM filter control register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_JDATAR_PTR[4] = {
      [0] = (RO_ uint32_t* const)0x40017100U,   /** @brief DFSDM data register for injected group */
      [1] = (RO_ uint32_t* const)0x40017104U,   /** @brief DFSDM data register for injected group */
      [2] = (RO_ uint32_t* const)0x40017108U,   /** @brief DFSDM data register for injected group */
      [3] = (RO_ uint32_t* const)0x4001710CU,   /** @brief DFSDM data register for injected group */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_RDATAR_PTR[4] = {
      [0] = (RO_ uint32_t* const)0x40017110U,   /** @brief DFSDM data register for the regular channel */
      [1] = (RO_ uint32_t* const)0x40017114U,   /** @brief DFSDM data register for the regular channel */
      [2] = (RO_ uint32_t* const)0x40017118U,   /** @brief DFSDM data register for the regular channel */
      [3] = (RO_ uint32_t* const)0x4001711CU,   /** @brief DFSDM data register for the regular channel */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_AWHTR_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x40017120U,   /** @brief DFSDM analog watchdog high threshold register */
      [1] = (RW_ uint32_t* const)0x40017124U,   /** @brief DFSDM analog watchdog high threshold register */
      [2] = (RW_ uint32_t* const)0x40017128U,   /** @brief DFSDM analog watchdog high threshold register */
      [3] = (RW_ uint32_t* const)0x4001712CU,   /** @brief DFSDM analog watchdog high threshold register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_AWLTR_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x40017130U,   /** @brief DFSDM analog watchdog low threshold register */
      [1] = (RW_ uint32_t* const)0x40017134U,   /** @brief DFSDM analog watchdog low threshold register */
      [2] = (RW_ uint32_t* const)0x40017138U,   /** @brief DFSDM analog watchdog low threshold register */
      [3] = (RW_ uint32_t* const)0x4001713CU,   /** @brief DFSDM analog watchdog low threshold register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_AWSR_PTR[4] = {
      [0] = (RO_ uint32_t* const)0x40017140U,   /** @brief DFSDM analog watchdog status register */
      [1] = (RO_ uint32_t* const)0x40017144U,   /** @brief DFSDM analog watchdog status register */
      [2] = (RO_ uint32_t* const)0x40017148U,   /** @brief DFSDM analog watchdog status register */
      [3] = (RO_ uint32_t* const)0x4001714CU,   /** @brief DFSDM analog watchdog status register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_AWCFR_PTR[4] = {
      [0] = (RW_ uint32_t* const)0x40017150U,   /** @brief DFSDM analog watchdog clear flag register */
      [1] = (RW_ uint32_t* const)0x40017154U,   /** @brief DFSDM analog watchdog clear flag register */
      [2] = (RW_ uint32_t* const)0x40017158U,   /** @brief DFSDM analog watchdog clear flag register */
      [3] = (RW_ uint32_t* const)0x4001715CU,   /** @brief DFSDM analog watchdog clear flag register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_EXMAX_PTR[4] = {
      [0] = (RO_ uint32_t* const)0x40017160U,   /** @brief DFSDM extremes detector maximum register */
      [1] = (RO_ uint32_t* const)0x40017164U,   /** @brief DFSDM extremes detector maximum register */
      [2] = (RO_ uint32_t* const)0x40017168U,   /** @brief DFSDM extremes detector maximum register */
      [3] = (RO_ uint32_t* const)0x4001716CU,   /** @brief DFSDM extremes detector maximum register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_EXMIN_PTR[4] = {
      [0] = (RO_ uint32_t* const)0x40017170U,   /** @brief DFSDM extremes detector minimum register */
      [1] = (RO_ uint32_t* const)0x40017174U,   /** @brief DFSDM extremes detector minimum register */
      [2] = (RO_ uint32_t* const)0x40017178U,   /** @brief DFSDM extremes detector minimum register */
      [3] = (RO_ uint32_t* const)0x4001717CU,   /** @brief DFSDM extremes detector minimum register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_CNVTIMR_PTR[4] = {
      [0] = (RO_ uint32_t* const)0x40017180U,   /** @brief DFSDM conversion timer register */
      [1] = (RO_ uint32_t* const)0x40017184U,   /** @brief DFSDM conversion timer register */
      [2] = (RO_ uint32_t* const)0x40017188U,   /** @brief DFSDM conversion timer register */
      [3] = (RO_ uint32_t* const)0x4001718CU,   /** @brief DFSDM conversion timer register */
    };

    /**** @subsection Enumerated DFSDM Register Reset Values ****/

    static const uint32_t DFSDM_DFSDM_CHCFGxR1_RST[8] = {
      [0] = 0x00000000U,   /** @brief DFSDM_CHCFG0R1 register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM_CHCFG1R1 register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM_CHCFG2R1 register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM_CHCFG3R1 register reset value. */
      [4] = 0x00000000U,   /** @brief DFSDM_CHCFG4R1 register reset value. */
      [5] = 0x00000000U,   /** @brief DFSDM_CHCFG5R1 register reset value. */
      [6] = 0x00000000U,   /** @brief DFSDM_CHCFG6R1 register reset value. */
      [7] = 0x00000000U,   /** @brief DFSDM_CHCFG7R1 register reset value. */
    };

    static const uint32_t DFSDM_DFSDM_CHCFGxR2_RST[8] = {
      [0] = 0x00000000U,   /** @brief DFSDM_CHCFG0R2 register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM_CHCFG1R2 register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM_CHCFG2R2 register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM_CHCFG3R2 register reset value. */
      [4] = 0x00000000U,   /** @brief DFSDM_CHCFG4R2 register reset value. */
      [5] = 0x00000000U,   /** @brief DFSDM_CHCFG5R2 register reset value. */
      [6] = 0x00000000U,   /** @brief DFSDM_CHCFG6R2 register reset value. */
      [7] = 0x00000000U,   /** @brief DFSDM_CHCFG7R2 register reset value. */
    };

    static const uint32_t DFSDM_DFSDM_AWSCDxR_RST[8] = {
      [0] = 0x00000000U,   /** @brief DFSDM_AWSCD0R register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM_AWSCD1R register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM_AWSCD2R register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM_AWSCD3R register reset value. */
      [4] = 0x00000000U,   /** @brief DFSDM_AWSCD4R register reset value. */
      [5] = 0x00000000U,   /** @brief DFSDM_AWSCD5R register reset value. */
      [6] = 0x00000000U,   /** @brief DFSDM_AWSCD6R register reset value. */
      [7] = 0x00000000U,   /** @brief DFSDM_AWSCD7R register reset value. */
    };

    static const uint32_t DFSDM_DFSDM_CHWDATxR_RST[8] = {
      [0] = 0x00000000U,   /** @brief DFSDM_CHWDAT0R register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM_CHWDAT1R register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM_CHWDAT2R register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM_CHWDAT3R register reset value. */
      [4] = 0x00000000U,   /** @brief DFSDM_CHWDAT4R register reset value. */
      [5] = 0x00000000U,   /** @brief DFSDM_CHWDAT5R register reset value. */
      [6] = 0x00000000U,   /** @brief DFSDM_CHWDAT6R register reset value. */
      [7] = 0x00000000U,   /** @brief DFSDM_CHWDAT7R register reset value. */
    };

    static const uint32_t DFSDM_DFSDM_CHDATINxR_RST[8] = {
      [0] = 0x00000000U,   /** @brief DFSDM_CHDATIN0R register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM_CHDATIN1R register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM_CHDATIN2R register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM_CHDATIN3R register reset value. */
      [4] = 0x00000000U,   /** @brief DFSDM_CHDATIN4R register reset value. */
      [5] = 0x00000000U,   /** @brief DFSDM_CHDATIN5R register reset value. */
      [6] = 0x00000000U,   /** @brief DFSDM_CHDATIN6R register reset value. */
      [7] = 0x00000000U,   /** @brief DFSDM_CHDATIN7R register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_CR1_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_CR1 register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_CR1 register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_CR1 register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_CR1 register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_CR2_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_CR2 register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_CR2 register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_CR2 register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_CR2 register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_ISR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_ISR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_ISR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_ISR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_ISR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_ICR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_ICR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_ICR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_ICR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_ICR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_JCHGR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_JCHGR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_JCHGR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_JCHGR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_JCHGR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_FCR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_FCR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_FCR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_FCR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_FCR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_JDATAR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_JDATAR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_JDATAR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_JDATAR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_JDATAR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_RDATAR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_RDATAR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_RDATAR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_RDATAR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_RDATAR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_AWHTR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_AWHTR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_AWHTR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_AWHTR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_AWHTR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_AWLTR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_AWLTR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_AWLTR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_AWLTR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_AWLTR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_AWSR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_AWSR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_AWSR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_AWSR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_AWSR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_AWCFR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_AWCFR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_AWCFR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_AWCFR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_AWCFR register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_EXMAX_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_EXMAX register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_EXMAX register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_EXMAX register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_EXMAX register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_EXMIN_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_EXMIN register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_EXMIN register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_EXMIN register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_EXMIN register reset value. */
    };

    static const uint32_t DFSDM_DFSDMx_CNVTIMR_RST[4] = {
      [0] = 0x00000000U,   /** @brief DFSDM0_CNVTIMR register reset value. */
      [1] = 0x00000000U,   /** @brief DFSDM1_CNVTIMR register reset value. */
      [2] = 0x00000000U,   /** @brief DFSDM2_CNVTIMR register reset value. */
      [3] = 0x00000000U,   /** @brief DFSDM3_CNVTIMR register reset value. */
    };

    /**** @subsection Enumerated DFSDM Register Value Types ****/

    typedef uint32_t DFSDM_DFSDM_CHCFGxR1_t;    /** @brief DFSDM_CHCFGxR1 register value type. */
    typedef uint32_t DFSDM_DFSDM_CHCFGxR2_t;    /** @brief DFSDM_CHCFGxR2 register value type. */
    typedef uint32_t DFSDM_DFSDM_AWSCDxR_t;     /** @brief DFSDM_AWSCDxR register value type. */
    typedef uint32_t DFSDM_DFSDM_CHWDATxR_t;    /** @brief DFSDM_CHWDATxR register value type. */
    typedef uint32_t DFSDM_DFSDM_CHDATINxR_t;   /** @brief DFSDM_CHDATINxR register value type. */
    typedef uint32_t DFSDM_DFSDMx_CR1_t;        /** @brief DFSDMx_CR1 register value type. */
    typedef uint32_t DFSDM_DFSDMx_CR2_t;        /** @brief DFSDMx_CR2 register value type. */
    typedef uint32_t DFSDM_DFSDMx_ISR_t;        /** @brief DFSDMx_ISR register value type. */
    typedef uint32_t DFSDM_DFSDMx_ICR_t;        /** @brief DFSDMx_ICR register value type. */
    typedef uint32_t DFSDM_DFSDMx_JCHGR_t;      /** @brief DFSDMx_JCHGR register value type. */
    typedef uint32_t DFSDM_DFSDMx_FCR_t;        /** @brief DFSDMx_FCR register value type. */
    typedef uint32_t DFSDM_DFSDMx_JDATAR_t;     /** @brief DFSDMx_JDATAR register value type. */
    typedef uint32_t DFSDM_DFSDMx_RDATAR_t;     /** @brief DFSDMx_RDATAR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWHTR_t;      /** @brief DFSDMx_AWHTR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWLTR_t;      /** @brief DFSDMx_AWLTR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWSR_t;       /** @brief DFSDMx_AWSR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWCFR_t;      /** @brief DFSDMx_AWCFR register value type. */
    typedef uint32_t DFSDM_DFSDMx_EXMAX_t;      /** @brief DFSDMx_EXMAX register value type. */
    typedef uint32_t DFSDM_DFSDMx_EXMIN_t;      /** @brief DFSDMx_EXMIN register value type. */
    typedef uint32_t DFSDM_DFSDMx_CNVTIMR_t;    /** @brief DFSDMx_CNVTIMR register value type. */

    /**** @subsection Enumerated DFSDM Register Pointer Types ****/

    typedef uint32_t* const DFSDM_DFSDM_CHCFGxR1_PTR_t;    /** @brief DFSDM_CHCFGxR1 register pointer type. */
    typedef uint32_t* const DFSDM_DFSDM_CHCFGxR2_PTR_t;    /** @brief DFSDM_CHCFGxR2 register pointer type. */
    typedef uint32_t* const DFSDM_DFSDM_AWSCDxR_PTR_t;     /** @brief DFSDM_AWSCDxR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDM_CHWDATxR_PTR_t;    /** @brief DFSDM_CHWDATxR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDM_CHDATINxR_PTR_t;   /** @brief DFSDM_CHDATINxR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_CR1_PTR_t;        /** @brief DFSDMx_CR1 register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_CR2_PTR_t;        /** @brief DFSDMx_CR2 register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_ISR_PTR_t;        /** @brief DFSDMx_ISR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_ICR_PTR_t;        /** @brief DFSDMx_ICR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_JCHGR_PTR_t;      /** @brief DFSDMx_JCHGR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_FCR_PTR_t;        /** @brief DFSDMx_FCR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_JDATAR_PTR_t;     /** @brief DFSDMx_JDATAR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_RDATAR_PTR_t;     /** @brief DFSDMx_RDATAR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_AWHTR_PTR_t;      /** @brief DFSDMx_AWHTR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_AWLTR_PTR_t;      /** @brief DFSDMx_AWLTR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_AWSR_PTR_t;       /** @brief DFSDMx_AWSR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_AWCFR_PTR_t;      /** @brief DFSDMx_AWCFR register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_EXMAX_PTR_t;      /** @brief DFSDMx_EXMAX register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_EXMIN_PTR_t;      /** @brief DFSDMx_EXMIN register pointer type. */
    typedef uint32_t* const DFSDM_DFSDMx_CNVTIMR_PTR_t;    /** @brief DFSDMx_CNVTIMR register pointer type. */

    /**** @subsection DFSDM Register Field Masks ****/

    static const uint32_t DFSDM_DFSDM_CHCFGxR1_SITP_MASK       = 0x00000003U;   /** @brief Serial interface type for channel 0 */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_SPICKSEL_MASK   = 0x0000000CU;   /** @brief SPI clock select for channel 0 */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_SCDEN_MASK      = 0x00000020U;   /** @brief Short-circuit detector enable on channel 0 */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_CKABEN_MASK     = 0x00000040U;   /** @brief Clock absence detector enable on channel 0 */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_CHEN_MASK       = 0x00000080U;   /** @brief Channel 0 enable */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_CHINSEL_MASK    = 0x00000100U;   /** @brief Channel inputs selection */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_DATMPX_MASK     = 0x00003000U;   /** @brief Input data multiplexer for channel 0 */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_DATPACK_MASK    = 0x0000C000U;   /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_CKOUTDIV_MASK   = 0x00FF0000U;   /** @brief Output serial clock divider */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_CKOUTSRC_MASK   = 0x40000000U;   /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_DFSDM_CHCFGxR1_DFSDMEN_MASK    = 0x80000000U;   /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_DFSDM_CHCFGxR2_DTRBS_MASK      = 0x000000F8U;   /** @brief Data right bit-shift for channel 0 */
    static const uint32_t DFSDM_DFSDM_CHCFGxR2_OFFSET_MASK     = 0xFFFFFF00U;   /** @brief 24-bit calibration offset for channel 0 */
    static const uint32_t DFSDM_DFSDM_AWSCDxR_SCDT_MASK        = 0x000000FFU;   /** @brief Short-circuit detector threshold for channel 0 */
    static const uint32_t DFSDM_DFSDM_AWSCDxR_BKSCD_MASK       = 0x0000F000U;   /** @brief Break signal assignment for short-circuit detector on channel 0 */
    static const uint32_t DFSDM_DFSDM_AWSCDxR_AWFOSR_MASK      = 0x001F0000U;   /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 0 */
    static const uint32_t DFSDM_DFSDM_AWSCDxR_AWFORD_MASK      = 0x00C00000U;   /** @brief Analog watchdog sinc filter order on channel 0 */
    static const uint32_t DFSDM_DFSDM_CHWDATxR_WDATA_MASK      = 0x0000FFFFU;   /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_DFSDMx_CR1_DFEN_MASK           = 0x00000001U;   /** @brief DFSDM enable */
    static const uint32_t DFSDM_DFSDMx_CR1_JSWSTART_MASK       = 0x00000002U;   /** @brief Start a conversion of the injected group of channels */
    static const uint32_t DFSDM_DFSDMx_CR1_JSYNC_MASK          = 0x00000008U;   /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const uint32_t DFSDM_DFSDMx_CR1_JSCAN_MASK          = 0x00000010U;   /** @brief Scanning conversion mode for injected conversions */
    static const uint32_t DFSDM_DFSDMx_CR1_JDMAEN_MASK         = 0x00000020U;   /** @brief DMA channel enabled to read data for the injected channel group */
    static const uint32_t DFSDM_DFSDMx_CR1_JEXTSEL_MASK        = 0x00001F00U;   /** @brief Trigger signal selection for launching injected conversions */
    static const uint32_t DFSDM_DFSDMx_CR1_JEXTEN_MASK         = 0x00006000U;   /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const uint32_t DFSDM_DFSDMx_CR1_RSWSTART_MASK       = 0x00020000U;   /** @brief Software start of a conversion on the regular channel */
    static const uint32_t DFSDM_DFSDMx_CR1_RCONT_MASK          = 0x00040000U;   /** @brief Continuous mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDMx_CR1_RSYNC_MASK          = 0x00080000U;   /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const uint32_t DFSDM_DFSDMx_CR1_RDMAEN_MASK         = 0x00200000U;   /** @brief DMA channel enabled to read data for the regular conversion */
    static const uint32_t DFSDM_DFSDMx_CR1_RCH_MASK            = 0x07000000U;   /** @brief Regular channel selection */
    static const uint32_t DFSDM_DFSDMx_CR1_FAST_MASK           = 0x20000000U;   /** @brief Fast conversion mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDMx_CR1_AWFSEL_MASK         = 0x40000000U;   /** @brief Analog watchdog fast mode select */
    static const uint32_t DFSDM_DFSDMx_CR2_JEOCIE_MASK         = 0x00000001U;   /** @brief Injected end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMx_CR2_REOCIE_MASK         = 0x00000002U;   /** @brief Regular end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMx_CR2_JOVRIE_MASK         = 0x00000004U;   /** @brief Injected data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMx_CR2_ROVRIE_MASK         = 0x00000008U;   /** @brief Regular data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMx_CR2_AWDIE_MASK          = 0x00000010U;   /** @brief Analog watchdog interrupt enable */
    static const uint32_t DFSDM_DFSDMx_CR2_SCDIE_MASK          = 0x00000020U;   /** @brief Short-circuit detector interrupt enable */
    static const uint32_t DFSDM_DFSDMx_CR2_CKABIE_MASK         = 0x00000040U;   /** @brief Clock absence interrupt enable */
    static const uint32_t DFSDM_DFSDMx_CR2_EXCH_MASK           = 0x0000FF00U;   /** @brief Extremes detector channel selection */
    static const uint32_t DFSDM_DFSDMx_CR2_AWDCH_MASK          = 0x00FF0000U;   /** @brief Analog watchdog channel selection */
    static const uint32_t DFSDM_DFSDMx_ISR_JEOCF_MASK          = 0x00000001U;   /** @brief End of injected conversion flag */
    static const uint32_t DFSDM_DFSDMx_ISR_REOCF_MASK          = 0x00000002U;   /** @brief End of regular conversion flag */
    static const uint32_t DFSDM_DFSDMx_ISR_JOVRF_MASK          = 0x00000004U;   /** @brief Injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMx_ISR_ROVRF_MASK          = 0x00000008U;   /** @brief Regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMx_ISR_AWDF_MASK           = 0x00000010U;   /** @brief Analog watchdog */
    static const uint32_t DFSDM_DFSDMx_ISR_JCIP_MASK           = 0x00002000U;   /** @brief Injected conversion in progress status */
    static const uint32_t DFSDM_DFSDMx_ISR_RCIP_MASK           = 0x00004000U;   /** @brief Regular conversion in progress status */
    static const uint32_t DFSDM_DFSDMx_ISR_CKABF_MASK          = 0x00FF0000U;   /** @brief Clock absence flag */
    static const uint32_t DFSDM_DFSDMx_ISR_SCDF_MASK           = 0xFF000000U;   /** @brief Short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMx_ICR_CLRJOVRF_MASK       = 0x00000004U;   /** @brief Clear the injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMx_ICR_CLRROVRF_MASK       = 0x00000008U;   /** @brief Clear the regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMx_ICR_CLRCKABF_MASK       = 0x00FF0000U;   /** @brief Clear the clock absence flag */
    static const uint32_t DFSDM_DFSDMx_ICR_CLRSCDF_MASK        = 0xFF000000U;   /** @brief Clear the short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMx_JCHGR_JCHG_MASK         = 0x000000FFU;   /** @brief Injected channel group selection */
    static const uint32_t DFSDM_DFSDMx_FCR_IOSR_MASK           = 0x000000FFU;   /** @brief Integrator oversampling ratio (averaging length) */
    static const uint32_t DFSDM_DFSDMx_FCR_FOSR_MASK           = 0x03FF0000U;   /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const uint32_t DFSDM_DFSDMx_FCR_FORD_MASK           = 0xE0000000U;   /** @brief Sinc filter order */
    static const uint32_t DFSDM_DFSDMx_JDATAR_JDATACH_MASK     = 0x00000007U;   /** @brief Injected channel most recently converted */
    static const uint32_t DFSDM_DFSDMx_JDATAR_JDATA_MASK       = 0xFFFFFF00U;   /** @brief Injected group conversion data */
    static const uint32_t DFSDM_DFSDMx_RDATAR_RDATACH_MASK     = 0x00000007U;   /** @brief Regular channel most recently converted */
    static const uint32_t DFSDM_DFSDMx_RDATAR_RPEND_MASK       = 0x00000010U;   /** @brief Regular channel pending data */
    static const uint32_t DFSDM_DFSDMx_RDATAR_RDATA_MASK       = 0xFFFFFF00U;   /** @brief Regular channel conversion data */
    static const uint32_t DFSDM_DFSDMx_AWHTR_BKAWH_MASK        = 0x0000000FU;   /** @brief Break signal assignment to analog watchdog high threshold event */
    static const uint32_t DFSDM_DFSDMx_AWHTR_AWHT_MASK         = 0xFFFFFF00U;   /** @brief Analog watchdog high threshold */
    static const uint32_t DFSDM_DFSDMx_AWLTR_BKAWL_MASK        = 0x0000000FU;   /** @brief Break signal assignment to analog watchdog low threshold event */
    static const uint32_t DFSDM_DFSDMx_AWLTR_AWLT_MASK         = 0xFFFFFF00U;   /** @brief Analog watchdog low threshold */
    static const uint32_t DFSDM_DFSDMx_AWSR_AWLTF_MASK         = 0x000000FFU;   /** @brief Analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMx_AWSR_AWHTF_MASK         = 0x0000FF00U;   /** @brief Analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMx_AWCFR_CLRAWLTF_MASK     = 0x000000FFU;   /** @brief Clear the analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMx_AWCFR_CLRAWHTF_MASK     = 0x0000FF00U;   /** @brief Clear the analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMx_EXMAX_EXMAXCH_MASK      = 0x00000007U;   /** @brief Extremes detector maximum data channel */
    static const uint32_t DFSDM_DFSDMx_EXMAX_EXMAX_MASK        = 0xFFFFFF00U;   /** @brief Extremes detector maximum value */
    static const uint32_t DFSDM_DFSDMx_EXMIN_EXMINCH_MASK      = 0x00000007U;   /** @brief Extremes detector minimum data channel */
    static const uint32_t DFSDM_DFSDMx_EXMIN_EXMIN_MASK        = 0xFFFFFF00U;   /** @brief Extremes detector minimum value */
    static const uint32_t DFSDM_DFSDMx_CNVTIMR_CNVCNT_MASK     = 0xFFFFFFF0U;   /** @brief 28-bit timer counting conversion time */

    /**** @subsection Enumerated DFSDM Register Field Masks ****/

    static const uint32_t DFSDM_DFSDM_CHDATINxR_INDATx_MASK[2] = {
      [0] = 0x0000FFFFU,   /** @brief Input data for channel 0 */
      [1] = 0xFFFF0000U,   /** @brief Input data for channel 1 */
    };

    /**** @subsection DFSDM Register Field Positions ****/

    static const int32_t DFSDM_DFSDM_CHCFGxR1_SITP_POS       = 0;    /** @brief Serial interface type for channel 0 */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_SPICKSEL_POS   = 2;    /** @brief SPI clock select for channel 0 */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_SCDEN_POS      = 5;    /** @brief Short-circuit detector enable on channel 0 */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_CKABEN_POS     = 6;    /** @brief Clock absence detector enable on channel 0 */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_CHEN_POS       = 7;    /** @brief Channel 0 enable */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_CHINSEL_POS    = 8;    /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_DATMPX_POS     = 12;   /** @brief Input data multiplexer for channel 0 */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_DATPACK_POS    = 14;   /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_CKOUTDIV_POS   = 16;   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_CKOUTSRC_POS   = 30;   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDM_CHCFGxR1_DFSDMEN_POS    = 31;   /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDM_CHCFGxR2_DTRBS_POS      = 3;    /** @brief Data right bit-shift for channel 0 */
    static const int32_t DFSDM_DFSDM_CHCFGxR2_OFFSET_POS     = 8;    /** @brief 24-bit calibration offset for channel 0 */
    static const int32_t DFSDM_DFSDM_AWSCDxR_SCDT_POS        = 0;    /** @brief Short-circuit detector threshold for channel 0 */
    static const int32_t DFSDM_DFSDM_AWSCDxR_BKSCD_POS       = 12;   /** @brief Break signal assignment for short-circuit detector on channel 0 */
    static const int32_t DFSDM_DFSDM_AWSCDxR_AWFOSR_POS      = 16;   /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 0 */
    static const int32_t DFSDM_DFSDM_AWSCDxR_AWFORD_POS      = 22;   /** @brief Analog watchdog sinc filter order on channel 0 */
    static const int32_t DFSDM_DFSDM_CHWDATxR_WDATA_POS      = 0;    /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMx_CR1_DFEN_POS           = 0;    /** @brief DFSDM enable */
    static const int32_t DFSDM_DFSDMx_CR1_JSWSTART_POS       = 1;    /** @brief Start a conversion of the injected group of channels */
    static const int32_t DFSDM_DFSDMx_CR1_JSYNC_POS          = 3;    /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const int32_t DFSDM_DFSDMx_CR1_JSCAN_POS          = 4;    /** @brief Scanning conversion mode for injected conversions */
    static const int32_t DFSDM_DFSDMx_CR1_JDMAEN_POS         = 5;    /** @brief DMA channel enabled to read data for the injected channel group */
    static const int32_t DFSDM_DFSDMx_CR1_JEXTSEL_POS        = 8;    /** @brief Trigger signal selection for launching injected conversions */
    static const int32_t DFSDM_DFSDMx_CR1_JEXTEN_POS         = 13;   /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const int32_t DFSDM_DFSDMx_CR1_RSWSTART_POS       = 17;   /** @brief Software start of a conversion on the regular channel */
    static const int32_t DFSDM_DFSDMx_CR1_RCONT_POS          = 18;   /** @brief Continuous mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMx_CR1_RSYNC_POS          = 19;   /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const int32_t DFSDM_DFSDMx_CR1_RDMAEN_POS         = 21;   /** @brief DMA channel enabled to read data for the regular conversion */
    static const int32_t DFSDM_DFSDMx_CR1_RCH_POS            = 24;   /** @brief Regular channel selection */
    static const int32_t DFSDM_DFSDMx_CR1_FAST_POS           = 29;   /** @brief Fast conversion mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMx_CR1_AWFSEL_POS         = 30;   /** @brief Analog watchdog fast mode select */
    static const int32_t DFSDM_DFSDMx_CR2_JEOCIE_POS         = 0;    /** @brief Injected end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMx_CR2_REOCIE_POS         = 1;    /** @brief Regular end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMx_CR2_JOVRIE_POS         = 2;    /** @brief Injected data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMx_CR2_ROVRIE_POS         = 3;    /** @brief Regular data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMx_CR2_AWDIE_POS          = 4;    /** @brief Analog watchdog interrupt enable */
    static const int32_t DFSDM_DFSDMx_CR2_SCDIE_POS          = 5;    /** @brief Short-circuit detector interrupt enable */
    static const int32_t DFSDM_DFSDMx_CR2_CKABIE_POS         = 6;    /** @brief Clock absence interrupt enable */
    static const int32_t DFSDM_DFSDMx_CR2_EXCH_POS           = 8;    /** @brief Extremes detector channel selection */
    static const int32_t DFSDM_DFSDMx_CR2_AWDCH_POS          = 16;   /** @brief Analog watchdog channel selection */
    static const int32_t DFSDM_DFSDMx_ISR_JEOCF_POS          = 0;    /** @brief End of injected conversion flag */
    static const int32_t DFSDM_DFSDMx_ISR_REOCF_POS          = 1;    /** @brief End of regular conversion flag */
    static const int32_t DFSDM_DFSDMx_ISR_JOVRF_POS          = 2;    /** @brief Injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMx_ISR_ROVRF_POS          = 3;    /** @brief Regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMx_ISR_AWDF_POS           = 4;    /** @brief Analog watchdog */
    static const int32_t DFSDM_DFSDMx_ISR_JCIP_POS           = 13;   /** @brief Injected conversion in progress status */
    static const int32_t DFSDM_DFSDMx_ISR_RCIP_POS           = 14;   /** @brief Regular conversion in progress status */
    static const int32_t DFSDM_DFSDMx_ISR_CKABF_POS          = 16;   /** @brief Clock absence flag */
    static const int32_t DFSDM_DFSDMx_ISR_SCDF_POS           = 24;   /** @brief Short-circuit detector flag */
    static const int32_t DFSDM_DFSDMx_ICR_CLRJOVRF_POS       = 2;    /** @brief Clear the injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMx_ICR_CLRROVRF_POS       = 3;    /** @brief Clear the regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMx_ICR_CLRCKABF_POS       = 16;   /** @brief Clear the clock absence flag */
    static const int32_t DFSDM_DFSDMx_ICR_CLRSCDF_POS        = 24;   /** @brief Clear the short-circuit detector flag */
    static const int32_t DFSDM_DFSDMx_JCHGR_JCHG_POS         = 0;    /** @brief Injected channel group selection */
    static const int32_t DFSDM_DFSDMx_FCR_IOSR_POS           = 0;    /** @brief Integrator oversampling ratio (averaging length) */
    static const int32_t DFSDM_DFSDMx_FCR_FOSR_POS           = 16;   /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const int32_t DFSDM_DFSDMx_FCR_FORD_POS           = 29;   /** @brief Sinc filter order */
    static const int32_t DFSDM_DFSDMx_JDATAR_JDATACH_POS     = 0;    /** @brief Injected channel most recently converted */
    static const int32_t DFSDM_DFSDMx_JDATAR_JDATA_POS       = 8;    /** @brief Injected group conversion data */
    static const int32_t DFSDM_DFSDMx_RDATAR_RDATACH_POS     = 0;    /** @brief Regular channel most recently converted */
    static const int32_t DFSDM_DFSDMx_RDATAR_RPEND_POS       = 4;    /** @brief Regular channel pending data */
    static const int32_t DFSDM_DFSDMx_RDATAR_RDATA_POS       = 8;    /** @brief Regular channel conversion data */
    static const int32_t DFSDM_DFSDMx_AWHTR_BKAWH_POS        = 0;    /** @brief Break signal assignment to analog watchdog high threshold event */
    static const int32_t DFSDM_DFSDMx_AWHTR_AWHT_POS         = 8;    /** @brief Analog watchdog high threshold */
    static const int32_t DFSDM_DFSDMx_AWLTR_BKAWL_POS        = 0;    /** @brief Break signal assignment to analog watchdog low threshold event */
    static const int32_t DFSDM_DFSDMx_AWLTR_AWLT_POS         = 8;    /** @brief Analog watchdog low threshold */
    static const int32_t DFSDM_DFSDMx_AWSR_AWLTF_POS         = 0;    /** @brief Analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMx_AWSR_AWHTF_POS         = 8;    /** @brief Analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMx_AWCFR_CLRAWLTF_POS     = 0;    /** @brief Clear the analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMx_AWCFR_CLRAWHTF_POS     = 8;    /** @brief Clear the analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMx_EXMAX_EXMAXCH_POS      = 0;    /** @brief Extremes detector maximum data channel */
    static const int32_t DFSDM_DFSDMx_EXMAX_EXMAX_POS        = 8;    /** @brief Extremes detector maximum value */
    static const int32_t DFSDM_DFSDMx_EXMIN_EXMINCH_POS      = 0;    /** @brief Extremes detector minimum data channel */
    static const int32_t DFSDM_DFSDMx_EXMIN_EXMIN_POS        = 8;    /** @brief Extremes detector minimum value */
    static const int32_t DFSDM_DFSDMx_CNVTIMR_CNVCNT_POS     = 4;    /** @brief 28-bit timer counting conversion time */

    /**** @subsection Enumerated DFSDM Register Field Positions ****/

    static const int32_t DFSDM_DFSDM_CHDATINxR_INDATx_POS[2] = {
      [0] = 0,    /** @brief Input data for channel 0 */
      [1] = 16,   /** @brief Input data for channel 1 */
    };

    /**********************************************************************************************
     * @section G2_TIM16 Register Information
     **********************************************************************************************/

    /**** @subsection G2_TIM16 Register Pointers ****/

    static RW_ uint32_t* const G2_TIM16_CR1_PTR            = (RW_ uint32_t* const)0x40014400U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G2_TIM16_CR2_PTR            = (RW_ uint32_t* const)0x40014404U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G2_TIM16_DIER_PTR           = (RW_ uint32_t* const)0x4001440CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G2_TIM16_SR_PTR             = (RW_ uint32_t* const)0x40014410U;   /** @brief Status register */
    static RW_ uint32_t* const G2_TIM16_EGR_PTR            = (RW_ uint32_t* const)0x40014414U;   /** @brief Event generation register */
    static RW_ uint32_t* const G2_TIM16_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40014418U;   /** @brief Capture/compare mode register (output mode) */
    static RW_ uint32_t* const G2_TIM16_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40014418U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G2_TIM16_CCER_PTR           = (RW_ uint32_t* const)0x40014420U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G2_TIM16_CNT_PTR            = (RW_ uint32_t* const)0x40014424U;   /** @brief Counter */
    static RW_ uint32_t* const G2_TIM16_PSC_PTR            = (RW_ uint32_t* const)0x40014428U;   /** @brief Prescaler */
    static RW_ uint32_t* const G2_TIM16_ARR_PTR            = (RW_ uint32_t* const)0x4001442CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G2_TIM16_RCR_PTR            = (RW_ uint32_t* const)0x40014430U;   /** @brief Repetition counter register */
    static RW_ uint32_t* const G2_TIM16_CCR1_PTR           = (RW_ uint32_t* const)0x40014434U;   /** @brief Capture/compare register 1 */
    static RW_ uint32_t* const G2_TIM16_BDTR_PTR           = (RW_ uint32_t* const)0x40014444U;   /** @brief Break and dead-time register */
    static RW_ uint32_t* const G2_TIM16_DCR_PTR            = (RW_ uint32_t* const)0x40014448U;   /** @brief DMA control register */
    static RW_ uint32_t* const G2_TIM16_DMAR_PTR           = (RW_ uint32_t* const)0x4001444CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G2_TIM16_TIM16_AF1_PTR      = (RW_ uint32_t* const)0x40014460U;   /** @brief TIM16 alternate function register 1 */
    static RW_ uint32_t* const G2_TIM16_TIM16_TISEL_PTR    = (RW_ uint32_t* const)0x40014468U;   /** @brief TIM16 input selection register */

    /**** @subsection G2_TIM16 Register Reset Values ****/

    static const uint32_t G2_TIM16_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G2_TIM16_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G2_TIM16_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G2_TIM16_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G2_TIM16_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G2_TIM16_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G2_TIM16_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G2_TIM16_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G2_TIM16_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G2_TIM16_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G2_TIM16_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G2_TIM16_RCR_RST            = 0x00000000U;   /** @brief RCR register reset value. */
    static const uint32_t G2_TIM16_CCR1_RST           = 0x00000000U;   /** @brief CCR1 register reset value. */
    static const uint32_t G2_TIM16_BDTR_RST           = 0x00000000U;   /** @brief BDTR register reset value. */
    static const uint32_t G2_TIM16_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G2_TIM16_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G2_TIM16_TIM16_AF1_RST      = 0x00000000U;   /** @brief TIM16_AF1 register reset value. */
    static const uint32_t G2_TIM16_TIM16_TISEL_RST    = 0x00000000U;   /** @brief TIM16_TISEL register reset value. */

    /**** @subsection Enumerated G2_TIM16 Register Value Types ****/

    typedef uint32_t G2_TIM16_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G2_TIM16_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G2_TIM16_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G2_TIM16_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G2_TIM16_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G2_TIM16_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G2_TIM16_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G2_TIM16_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G2_TIM16_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G2_TIM16_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G2_TIM16_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G2_TIM16_RCR_t;            /** @brief RCR register value type. */
    typedef uint32_t G2_TIM16_CCR1_t;           /** @brief CCR1 register value type. */
    typedef uint32_t G2_TIM16_BDTR_t;           /** @brief BDTR register value type. */
    typedef uint32_t G2_TIM16_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G2_TIM16_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G2_TIM16_TIM16_AF1_t;      /** @brief TIM16_AF1 register value type. */
    typedef uint32_t G2_TIM16_TIM16_TISEL_t;    /** @brief TIM16_TISEL register value type. */

    /**** @subsection Enumerated G2_TIM16 Register Pointer Types ****/

    typedef uint32_t* const G2_TIM16_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G2_TIM16_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G2_TIM16_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G2_TIM16_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G2_TIM16_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G2_TIM16_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G2_TIM16_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G2_TIM16_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G2_TIM16_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G2_TIM16_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G2_TIM16_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G2_TIM16_RCR_PTR_t;            /** @brief RCR register pointer type. */
    typedef uint32_t* const G2_TIM16_CCR1_PTR_t;           /** @brief CCR1 register pointer type. */
    typedef uint32_t* const G2_TIM16_BDTR_PTR_t;           /** @brief BDTR register pointer type. */
    typedef uint32_t* const G2_TIM16_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G2_TIM16_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G2_TIM16_TIM16_AF1_PTR_t;      /** @brief TIM16_AF1 register pointer type. */
    typedef uint32_t* const G2_TIM16_TIM16_TISEL_PTR_t;    /** @brief TIM16_TISEL register pointer type. */

    /**** @subsection G2_TIM16 Register Field Masks ****/

    static const uint32_t G2_TIM16_CR1_CEN_MASK               = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G2_TIM16_CR1_UDIS_MASK              = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G2_TIM16_CR1_URS_MASK               = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G2_TIM16_CR1_OPM_MASK               = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G2_TIM16_CR1_ARPE_MASK              = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G2_TIM16_CR1_CKD_MASK               = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G2_TIM16_CR1_UIFREMAP_MASK          = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G2_TIM16_CR2_OIS1N_MASK             = 0x00000200U;   /** @brief Output idle state 1 */
    static const uint32_t G2_TIM16_CR2_OIS1_MASK              = 0x00000100U;   /** @brief Output idle state 1 */
    static const uint32_t G2_TIM16_CR2_CCDS_MASK              = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G2_TIM16_CR2_CCUS_MASK              = 0x00000004U;   /** @brief Capture/compare control update selection */
    static const uint32_t G2_TIM16_CR2_CCPC_MASK              = 0x00000001U;   /** @brief Capture/compare preloaded control */
    static const uint32_t G2_TIM16_DIER_UIE_MASK              = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G2_TIM16_DIER_CC1IE_MASK            = 0x00000002U;   /** @brief Capture/Compare 1 interrupt enable */
    static const uint32_t G2_TIM16_DIER_COMIE_MASK            = 0x00000020U;   /** @brief COM interrupt enable */
    static const uint32_t G2_TIM16_DIER_BIE_MASK              = 0x00000080U;   /** @brief Break interrupt enable */
    static const uint32_t G2_TIM16_DIER_UDE_MASK              = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G2_TIM16_DIER_CC1DE_MASK            = 0x00000200U;   /** @brief Capture/Compare 1 DMA request enable */
    static const uint32_t G2_TIM16_DIER_COMDE_MASK            = 0x00002000U;   /** @brief COM DMA request enable */
    static const uint32_t G2_TIM16_SR_CC1OF_MASK              = 0x00000200U;   /** @brief Capture/Compare 1 overcapture flag */
    static const uint32_t G2_TIM16_SR_BIF_MASK                = 0x00000080U;   /** @brief Break interrupt flag */
    static const uint32_t G2_TIM16_SR_COMIF_MASK              = 0x00000020U;   /** @brief COM interrupt flag */
    static const uint32_t G2_TIM16_SR_CC1IF_MASK              = 0x00000002U;   /** @brief Capture/compare 1 interrupt flag */
    static const uint32_t G2_TIM16_SR_UIF_MASK                = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G2_TIM16_EGR_BG_MASK                = 0x00000080U;   /** @brief Break generation */
    static const uint32_t G2_TIM16_EGR_COMG_MASK              = 0x00000020U;   /** @brief Capture/Compare control update generation */
    static const uint32_t G2_TIM16_EGR_CC1G_MASK              = 0x00000002U;   /** @brief Capture/compare 1 generation */
    static const uint32_t G2_TIM16_EGR_UG_MASK                = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G2_TIM16_CCMR1_OUTPUT_CC1S_MASK     = 0x00000003U;   /** @brief Capture/Compare 1 selection */
    static const uint32_t G2_TIM16_CCMR1_OUTPUT_OC1FE_MASK    = 0x00000004U;   /** @brief Output compare 1 fast enable */
    static const uint32_t G2_TIM16_CCMR1_OUTPUT_OC1PE_MASK    = 0x00000008U;   /** @brief Output compare 1 preload enable */
    static const uint32_t G2_TIM16_CCMR1_OUTPUT_OC1M_MASK     = 0x00000070U;   /** @brief Output compare 1 mode */
    static const uint32_t G2_TIM16_CCMR1_OUTPUT_OC1M_3_MASK   = 0x00010000U;   /** @brief Output compare 1 mode */
    static const uint32_t G2_TIM16_CCMR1_INPUT_IC1F_MASK      = 0x000000F0U;   /** @brief Input capture 1 filter */
    static const uint32_t G2_TIM16_CCMR1_INPUT_IC1PSC_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G2_TIM16_CCMR1_INPUT_CC1S_MASK      = 0x00000003U;   /** @brief Capture/Compare 1 selection */
    static const uint32_t G2_TIM16_CCER_CC1NP_MASK            = 0x00000008U;   /** @brief Capture/Compare 1 output polarity */
    static const uint32_t G2_TIM16_CCER_CC1NE_MASK            = 0x00000004U;   /** @brief Capture/Compare 1 complementary output enable */
    static const uint32_t G2_TIM16_CCER_CC1P_MASK             = 0x00000002U;   /** @brief Capture/Compare 1 output polarity */
    static const uint32_t G2_TIM16_CCER_CC1E_MASK             = 0x00000001U;   /** @brief Capture/Compare 1 output enable */
    static const uint32_t G2_TIM16_CNT_CNT_MASK               = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t G2_TIM16_CNT_UIFCPY_MASK            = 0x80000000U;   /** @brief UIF copy */
    static const uint32_t G2_TIM16_PSC_PSC_MASK               = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G2_TIM16_ARR_ARR_MASK               = 0x0000FFFFU;   /** @brief Auto-reload value */
    static const uint32_t G2_TIM16_RCR_REP_MASK               = 0x000000FFU;   /** @brief Repetition counter value */
    static const uint32_t G2_TIM16_CCR1_CCR1_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
    static const uint32_t G2_TIM16_BDTR_DTG_MASK              = 0x000000FFU;   /** @brief Dead-time generator setup */
    static const uint32_t G2_TIM16_BDTR_LOCK_MASK             = 0x00000300U;   /** @brief Lock configuration */
    static const uint32_t G2_TIM16_BDTR_OSSI_MASK             = 0x00000400U;   /** @brief Off-state selection for idle mode */
    static const uint32_t G2_TIM16_BDTR_OSSR_MASK             = 0x00000800U;   /** @brief Off-state selection for run mode */
    static const uint32_t G2_TIM16_BDTR_BKE_MASK              = 0x00001000U;   /** @brief Break enable */
    static const uint32_t G2_TIM16_BDTR_BKP_MASK              = 0x00002000U;   /** @brief Break polarity */
    static const uint32_t G2_TIM16_BDTR_AOE_MASK              = 0x00004000U;   /** @brief Automatic output enable */
    static const uint32_t G2_TIM16_BDTR_MOE_MASK              = 0x00008000U;   /** @brief Main output enable */
    static const uint32_t G2_TIM16_BDTR_BKF_MASK              = 0x000F0000U;   /** @brief Break filter */
    static const uint32_t G2_TIM16_DCR_DBL_MASK               = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G2_TIM16_DCR_DBA_MASK               = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G2_TIM16_DMAR_DMAB_MASK             = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G2_TIM16_TIM16_AF1_BKINE_MASK       = 0x00000001U;   /** @brief BRK BKIN input enable */
    static const uint32_t G2_TIM16_TIM16_AF1_BKDFBK1E_MASK    = 0x00000100U;   /** @brief BRK dfsdm1_break[1] enable */
    static const uint32_t G2_TIM16_TIM16_AF1_BKINP_MASK       = 0x00000200U;   /** @brief BRK BKIN input polarity */
    static const uint32_t G2_TIM16_TIM16_TISEL_TI1SEL_MASK    = 0x0000000FU;   /** @brief Selects TI1[0] to TI1[15] input */

    /**** @subsection Enumerated G2_TIM16 Register Field Masks ****/

    static const uint32_t G2_TIM16_TIM16_AF1_BKCMPxE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
      [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
    };

    static const uint32_t G2_TIM16_TIM16_AF1_BKCMPxP_MASK[3] = {
      [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
      [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
    };

    /**** @subsection G2_TIM16 Register Field Positions ****/

    static const int32_t G2_TIM16_CR1_CEN_POS               = 0;    /** @brief Counter enable */
    static const int32_t G2_TIM16_CR1_UDIS_POS              = 1;    /** @brief Update disable */
    static const int32_t G2_TIM16_CR1_URS_POS               = 2;    /** @brief Update request source */
    static const int32_t G2_TIM16_CR1_OPM_POS               = 3;    /** @brief One-pulse mode */
    static const int32_t G2_TIM16_CR1_ARPE_POS              = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G2_TIM16_CR1_CKD_POS               = 8;    /** @brief Clock division */
    static const int32_t G2_TIM16_CR1_UIFREMAP_POS          = 11;   /** @brief UIF status bit remapping */
    static const int32_t G2_TIM16_CR2_OIS1N_POS             = 9;    /** @brief Output idle state 1 */
    static const int32_t G2_TIM16_CR2_OIS1_POS              = 8;    /** @brief Output idle state 1 */
    static const int32_t G2_TIM16_CR2_CCDS_POS              = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G2_TIM16_CR2_CCUS_POS              = 2;    /** @brief Capture/compare control update selection */
    static const int32_t G2_TIM16_CR2_CCPC_POS              = 0;    /** @brief Capture/compare preloaded control */
    static const int32_t G2_TIM16_DIER_UIE_POS              = 0;    /** @brief Update interrupt enable */
    static const int32_t G2_TIM16_DIER_CC1IE_POS            = 1;    /** @brief Capture/Compare 1 interrupt enable */
    static const int32_t G2_TIM16_DIER_COMIE_POS            = 5;    /** @brief COM interrupt enable */
    static const int32_t G2_TIM16_DIER_BIE_POS              = 7;    /** @brief Break interrupt enable */
    static const int32_t G2_TIM16_DIER_UDE_POS              = 8;    /** @brief Update DMA request enable */
    static const int32_t G2_TIM16_DIER_CC1DE_POS            = 9;    /** @brief Capture/Compare 1 DMA request enable */
    static const int32_t G2_TIM16_DIER_COMDE_POS            = 13;   /** @brief COM DMA request enable */
    static const int32_t G2_TIM16_SR_CC1OF_POS              = 9;    /** @brief Capture/Compare 1 overcapture flag */
    static const int32_t G2_TIM16_SR_BIF_POS                = 7;    /** @brief Break interrupt flag */
    static const int32_t G2_TIM16_SR_COMIF_POS              = 5;    /** @brief COM interrupt flag */
    static const int32_t G2_TIM16_SR_CC1IF_POS              = 1;    /** @brief Capture/compare 1 interrupt flag */
    static const int32_t G2_TIM16_SR_UIF_POS                = 0;    /** @brief Update interrupt flag */
    static const int32_t G2_TIM16_EGR_BG_POS                = 7;    /** @brief Break generation */
    static const int32_t G2_TIM16_EGR_COMG_POS              = 5;    /** @brief Capture/Compare control update generation */
    static const int32_t G2_TIM16_EGR_CC1G_POS              = 1;    /** @brief Capture/compare 1 generation */
    static const int32_t G2_TIM16_EGR_UG_POS                = 0;    /** @brief Update generation */
    static const int32_t G2_TIM16_CCMR1_OUTPUT_CC1S_POS     = 0;    /** @brief Capture/Compare 1 selection */
    static const int32_t G2_TIM16_CCMR1_OUTPUT_OC1FE_POS    = 2;    /** @brief Output compare 1 fast enable */
    static const int32_t G2_TIM16_CCMR1_OUTPUT_OC1PE_POS    = 3;    /** @brief Output compare 1 preload enable */
    static const int32_t G2_TIM16_CCMR1_OUTPUT_OC1M_POS     = 4;    /** @brief Output compare 1 mode */
    static const int32_t G2_TIM16_CCMR1_OUTPUT_OC1M_3_POS   = 16;   /** @brief Output compare 1 mode */
    static const int32_t G2_TIM16_CCMR1_INPUT_IC1F_POS      = 4;    /** @brief Input capture 1 filter */
    static const int32_t G2_TIM16_CCMR1_INPUT_IC1PSC_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G2_TIM16_CCMR1_INPUT_CC1S_POS      = 0;    /** @brief Capture/Compare 1 selection */
    static const int32_t G2_TIM16_CCER_CC1NP_POS            = 3;    /** @brief Capture/Compare 1 output polarity */
    static const int32_t G2_TIM16_CCER_CC1NE_POS            = 2;    /** @brief Capture/Compare 1 complementary output enable */
    static const int32_t G2_TIM16_CCER_CC1P_POS             = 1;    /** @brief Capture/Compare 1 output polarity */
    static const int32_t G2_TIM16_CCER_CC1E_POS             = 0;    /** @brief Capture/Compare 1 output enable */
    static const int32_t G2_TIM16_CNT_CNT_POS               = 0;    /** @brief Counter value */
    static const int32_t G2_TIM16_CNT_UIFCPY_POS            = 31;   /** @brief UIF copy */
    static const int32_t G2_TIM16_PSC_PSC_POS               = 0;    /** @brief Prescaler value */
    static const int32_t G2_TIM16_ARR_ARR_POS               = 0;    /** @brief Auto-reload value */
    static const int32_t G2_TIM16_RCR_REP_POS               = 0;    /** @brief Repetition counter value */
    static const int32_t G2_TIM16_CCR1_CCR1_POS             = 0;    /** @brief Capture/Compare 1 value */
    static const int32_t G2_TIM16_BDTR_DTG_POS              = 0;    /** @brief Dead-time generator setup */
    static const int32_t G2_TIM16_BDTR_LOCK_POS             = 8;    /** @brief Lock configuration */
    static const int32_t G2_TIM16_BDTR_OSSI_POS             = 10;   /** @brief Off-state selection for idle mode */
    static const int32_t G2_TIM16_BDTR_OSSR_POS             = 11;   /** @brief Off-state selection for run mode */
    static const int32_t G2_TIM16_BDTR_BKE_POS              = 12;   /** @brief Break enable */
    static const int32_t G2_TIM16_BDTR_BKP_POS              = 13;   /** @brief Break polarity */
    static const int32_t G2_TIM16_BDTR_AOE_POS              = 14;   /** @brief Automatic output enable */
    static const int32_t G2_TIM16_BDTR_MOE_POS              = 15;   /** @brief Main output enable */
    static const int32_t G2_TIM16_BDTR_BKF_POS              = 16;   /** @brief Break filter */
    static const int32_t G2_TIM16_DCR_DBL_POS               = 8;    /** @brief DMA burst length */
    static const int32_t G2_TIM16_DCR_DBA_POS               = 0;    /** @brief DMA base address */
    static const int32_t G2_TIM16_DMAR_DMAB_POS             = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G2_TIM16_TIM16_AF1_BKINE_POS       = 0;    /** @brief BRK BKIN input enable */
    static const int32_t G2_TIM16_TIM16_AF1_BKDFBK1E_POS    = 8;    /** @brief BRK dfsdm1_break[1] enable */
    static const int32_t G2_TIM16_TIM16_AF1_BKINP_POS       = 9;    /** @brief BRK BKIN input polarity */
    static const int32_t G2_TIM16_TIM16_TISEL_TI1SEL_POS    = 0;    /** @brief Selects TI1[0] to TI1[15] input */

    /**** @subsection Enumerated G2_TIM16 Register Field Positions ****/

    static const int32_t G2_TIM16_TIM16_AF1_BKCMPxE_POS[3] = {
      [1] = 1,   /** @brief BRK COMP1 enable */
      [2] = 2,   /** @brief BRK COMP2 enable */
    };

    static const int32_t G2_TIM16_TIM16_AF1_BKCMPxP_POS[3] = {
      [1] = 10,   /** @brief BRK COMP1 input polarity */
      [2] = 11,   /** @brief BRK COMP2 input polarity */
    };

    /**********************************************************************************************
     * @section G2_TIM17 Register Information
     **********************************************************************************************/

    /**** @subsection G2_TIM17 Register Pointers ****/

    static RW_ uint32_t* const G2_TIM17_CR1_PTR            = (RW_ uint32_t* const)0x40014800U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G2_TIM17_CR2_PTR            = (RW_ uint32_t* const)0x40014804U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G2_TIM17_DIER_PTR           = (RW_ uint32_t* const)0x4001480CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G2_TIM17_SR_PTR             = (RW_ uint32_t* const)0x40014810U;   /** @brief Status register */
    static RW_ uint32_t* const G2_TIM17_EGR_PTR            = (RW_ uint32_t* const)0x40014814U;   /** @brief Event generation register */
    static RW_ uint32_t* const G2_TIM17_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40014818U;   /** @brief Capture/compare mode register (output mode) */
    static RW_ uint32_t* const G2_TIM17_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40014818U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G2_TIM17_CCER_PTR           = (RW_ uint32_t* const)0x40014820U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G2_TIM17_CNT_PTR            = (RW_ uint32_t* const)0x40014824U;   /** @brief Counter */
    static RW_ uint32_t* const G2_TIM17_PSC_PTR            = (RW_ uint32_t* const)0x40014828U;   /** @brief Prescaler */
    static RW_ uint32_t* const G2_TIM17_ARR_PTR            = (RW_ uint32_t* const)0x4001482CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G2_TIM17_RCR_PTR            = (RW_ uint32_t* const)0x40014830U;   /** @brief Repetition counter register */
    static RW_ uint32_t* const G2_TIM17_CCR1_PTR           = (RW_ uint32_t* const)0x40014834U;   /** @brief Capture/compare register 1 */
    static RW_ uint32_t* const G2_TIM17_BDTR_PTR           = (RW_ uint32_t* const)0x40014844U;   /** @brief Break and dead-time register */
    static RW_ uint32_t* const G2_TIM17_DCR_PTR            = (RW_ uint32_t* const)0x40014848U;   /** @brief DMA control register */
    static RW_ uint32_t* const G2_TIM17_DMAR_PTR           = (RW_ uint32_t* const)0x4001484CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G2_TIM17_TIM17_AF1_PTR      = (RW_ uint32_t* const)0x40014860U;   /** @brief TIM17 alternate function register 1 */
    static RW_ uint32_t* const G2_TIM17_TIM17_TISEL_PTR    = (RW_ uint32_t* const)0x40014868U;   /** @brief TIM17 input selection register */

    /**** @subsection G2_TIM17 Register Reset Values ****/

    static const uint32_t G2_TIM17_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G2_TIM17_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G2_TIM17_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G2_TIM17_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G2_TIM17_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G2_TIM17_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G2_TIM17_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G2_TIM17_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G2_TIM17_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G2_TIM17_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G2_TIM17_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G2_TIM17_RCR_RST            = 0x00000000U;   /** @brief RCR register reset value. */
    static const uint32_t G2_TIM17_CCR1_RST           = 0x00000000U;   /** @brief CCR1 register reset value. */
    static const uint32_t G2_TIM17_BDTR_RST           = 0x00000000U;   /** @brief BDTR register reset value. */
    static const uint32_t G2_TIM17_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G2_TIM17_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G2_TIM17_TIM17_AF1_RST      = 0x00000000U;   /** @brief TIM17_AF1 register reset value. */
    static const uint32_t G2_TIM17_TIM17_TISEL_RST    = 0x00000000U;   /** @brief TIM17_TISEL register reset value. */

    /**** @subsection Enumerated G2_TIM17 Register Value Types ****/

    typedef uint32_t G2_TIM17_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G2_TIM17_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G2_TIM17_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G2_TIM17_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G2_TIM17_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G2_TIM17_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G2_TIM17_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G2_TIM17_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G2_TIM17_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G2_TIM17_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G2_TIM17_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G2_TIM17_RCR_t;            /** @brief RCR register value type. */
    typedef uint32_t G2_TIM17_CCR1_t;           /** @brief CCR1 register value type. */
    typedef uint32_t G2_TIM17_BDTR_t;           /** @brief BDTR register value type. */
    typedef uint32_t G2_TIM17_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G2_TIM17_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G2_TIM17_TIM17_AF1_t;      /** @brief TIM17_AF1 register value type. */
    typedef uint32_t G2_TIM17_TIM17_TISEL_t;    /** @brief TIM17_TISEL register value type. */

    /**** @subsection Enumerated G2_TIM17 Register Pointer Types ****/

    typedef uint32_t* const G2_TIM17_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G2_TIM17_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G2_TIM17_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G2_TIM17_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G2_TIM17_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G2_TIM17_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G2_TIM17_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G2_TIM17_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G2_TIM17_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G2_TIM17_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G2_TIM17_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G2_TIM17_RCR_PTR_t;            /** @brief RCR register pointer type. */
    typedef uint32_t* const G2_TIM17_CCR1_PTR_t;           /** @brief CCR1 register pointer type. */
    typedef uint32_t* const G2_TIM17_BDTR_PTR_t;           /** @brief BDTR register pointer type. */
    typedef uint32_t* const G2_TIM17_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G2_TIM17_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G2_TIM17_TIM17_AF1_PTR_t;      /** @brief TIM17_AF1 register pointer type. */
    typedef uint32_t* const G2_TIM17_TIM17_TISEL_PTR_t;    /** @brief TIM17_TISEL register pointer type. */

    /**** @subsection G2_TIM17 Register Field Masks ****/

    static const uint32_t G2_TIM17_CR1_CEN_MASK               = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G2_TIM17_CR1_UDIS_MASK              = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G2_TIM17_CR1_URS_MASK               = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G2_TIM17_CR1_OPM_MASK               = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G2_TIM17_CR1_ARPE_MASK              = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G2_TIM17_CR1_CKD_MASK               = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G2_TIM17_CR1_UIFREMAP_MASK          = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G2_TIM17_CR2_OIS1N_MASK             = 0x00000200U;   /** @brief Output idle state 1 */
    static const uint32_t G2_TIM17_CR2_OIS1_MASK              = 0x00000100U;   /** @brief Output idle state 1 */
    static const uint32_t G2_TIM17_CR2_CCDS_MASK              = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G2_TIM17_CR2_CCUS_MASK              = 0x00000004U;   /** @brief Capture/compare control update selection */
    static const uint32_t G2_TIM17_CR2_CCPC_MASK              = 0x00000001U;   /** @brief Capture/compare preloaded control */
    static const uint32_t G2_TIM17_DIER_UIE_MASK              = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G2_TIM17_DIER_CC1IE_MASK            = 0x00000002U;   /** @brief Capture/Compare 1 interrupt enable */
    static const uint32_t G2_TIM17_DIER_COMIE_MASK            = 0x00000020U;   /** @brief COM interrupt enable */
    static const uint32_t G2_TIM17_DIER_BIE_MASK              = 0x00000080U;   /** @brief Break interrupt enable */
    static const uint32_t G2_TIM17_DIER_UDE_MASK              = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G2_TIM17_DIER_CC1DE_MASK            = 0x00000200U;   /** @brief Capture/Compare 1 DMA request enable */
    static const uint32_t G2_TIM17_DIER_COMDE_MASK            = 0x00002000U;   /** @brief COM DMA request enable */
    static const uint32_t G2_TIM17_SR_CC1OF_MASK              = 0x00000200U;   /** @brief Capture/Compare 1 overcapture flag */
    static const uint32_t G2_TIM17_SR_BIF_MASK                = 0x00000080U;   /** @brief Break interrupt flag */
    static const uint32_t G2_TIM17_SR_COMIF_MASK              = 0x00000020U;   /** @brief COM interrupt flag */
    static const uint32_t G2_TIM17_SR_CC1IF_MASK              = 0x00000002U;   /** @brief Capture/compare 1 interrupt flag */
    static const uint32_t G2_TIM17_SR_UIF_MASK                = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G2_TIM17_EGR_BG_MASK                = 0x00000080U;   /** @brief Break generation */
    static const uint32_t G2_TIM17_EGR_COMG_MASK              = 0x00000020U;   /** @brief Capture/Compare control update generation */
    static const uint32_t G2_TIM17_EGR_CC1G_MASK              = 0x00000002U;   /** @brief Capture/compare 1 generation */
    static const uint32_t G2_TIM17_EGR_UG_MASK                = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G2_TIM17_CCMR1_OUTPUT_CC1S_MASK     = 0x00000003U;   /** @brief Capture/Compare 1 selection */
    static const uint32_t G2_TIM17_CCMR1_OUTPUT_OC1FE_MASK    = 0x00000004U;   /** @brief Output compare 1 fast enable */
    static const uint32_t G2_TIM17_CCMR1_OUTPUT_OC1PE_MASK    = 0x00000008U;   /** @brief Output compare 1 preload enable */
    static const uint32_t G2_TIM17_CCMR1_OUTPUT_OC1M_MASK     = 0x00000070U;   /** @brief Output compare 1 mode */
    static const uint32_t G2_TIM17_CCMR1_OUTPUT_OC1M_3_MASK   = 0x00010000U;   /** @brief Output compare 1 mode */
    static const uint32_t G2_TIM17_CCMR1_INPUT_IC1F_MASK      = 0x000000F0U;   /** @brief Input capture 1 filter */
    static const uint32_t G2_TIM17_CCMR1_INPUT_IC1PSC_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G2_TIM17_CCMR1_INPUT_CC1S_MASK      = 0x00000003U;   /** @brief Capture/Compare 1 selection */
    static const uint32_t G2_TIM17_CCER_CC1NP_MASK            = 0x00000008U;   /** @brief Capture/Compare 1 output polarity */
    static const uint32_t G2_TIM17_CCER_CC1NE_MASK            = 0x00000004U;   /** @brief Capture/Compare 1 complementary output enable */
    static const uint32_t G2_TIM17_CCER_CC1P_MASK             = 0x00000002U;   /** @brief Capture/Compare 1 output polarity */
    static const uint32_t G2_TIM17_CCER_CC1E_MASK             = 0x00000001U;   /** @brief Capture/Compare 1 output enable */
    static const uint32_t G2_TIM17_CNT_CNT_MASK               = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t G2_TIM17_CNT_UIFCPY_MASK            = 0x80000000U;   /** @brief UIF copy */
    static const uint32_t G2_TIM17_PSC_PSC_MASK               = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G2_TIM17_ARR_ARR_MASK               = 0x0000FFFFU;   /** @brief Auto-reload value */
    static const uint32_t G2_TIM17_RCR_REP_MASK               = 0x000000FFU;   /** @brief Repetition counter value */
    static const uint32_t G2_TIM17_CCR1_CCR1_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
    static const uint32_t G2_TIM17_BDTR_DTG_MASK              = 0x000000FFU;   /** @brief Dead-time generator setup */
    static const uint32_t G2_TIM17_BDTR_LOCK_MASK             = 0x00000300U;   /** @brief Lock configuration */
    static const uint32_t G2_TIM17_BDTR_OSSI_MASK             = 0x00000400U;   /** @brief Off-state selection for idle mode */
    static const uint32_t G2_TIM17_BDTR_OSSR_MASK             = 0x00000800U;   /** @brief Off-state selection for run mode */
    static const uint32_t G2_TIM17_BDTR_BKE_MASK              = 0x00001000U;   /** @brief Break enable */
    static const uint32_t G2_TIM17_BDTR_BKP_MASK              = 0x00002000U;   /** @brief Break polarity */
    static const uint32_t G2_TIM17_BDTR_AOE_MASK              = 0x00004000U;   /** @brief Automatic output enable */
    static const uint32_t G2_TIM17_BDTR_MOE_MASK              = 0x00008000U;   /** @brief Main output enable */
    static const uint32_t G2_TIM17_BDTR_BKF_MASK              = 0x000F0000U;   /** @brief Break filter */
    static const uint32_t G2_TIM17_DCR_DBL_MASK               = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G2_TIM17_DCR_DBA_MASK               = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G2_TIM17_DMAR_DMAB_MASK             = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G2_TIM17_TIM17_AF1_BKINE_MASK       = 0x00000001U;   /** @brief BRK BKIN input enable */
    static const uint32_t G2_TIM17_TIM17_AF1_BKDFBK1E_MASK    = 0x00000100U;   /** @brief BRK dfsdm1_break[1] enable */
    static const uint32_t G2_TIM17_TIM17_AF1_BKINP_MASK       = 0x00000200U;   /** @brief BRK BKIN input polarity */
    static const uint32_t G2_TIM17_TIM17_TISEL_TI1SEL_MASK    = 0x0000000FU;   /** @brief Selects TI1[0] to TI1[15] input */

    /**** @subsection Enumerated G2_TIM17 Register Field Masks ****/

    static const uint32_t G2_TIM17_TIM17_AF1_BKCMPxE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
      [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
    };

    static const uint32_t G2_TIM17_TIM17_AF1_BKCMPxP_MASK[3] = {
      [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
      [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
    };

    /**** @subsection G2_TIM17 Register Field Positions ****/

    static const int32_t G2_TIM17_CR1_CEN_POS               = 0;    /** @brief Counter enable */
    static const int32_t G2_TIM17_CR1_UDIS_POS              = 1;    /** @brief Update disable */
    static const int32_t G2_TIM17_CR1_URS_POS               = 2;    /** @brief Update request source */
    static const int32_t G2_TIM17_CR1_OPM_POS               = 3;    /** @brief One-pulse mode */
    static const int32_t G2_TIM17_CR1_ARPE_POS              = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G2_TIM17_CR1_CKD_POS               = 8;    /** @brief Clock division */
    static const int32_t G2_TIM17_CR1_UIFREMAP_POS          = 11;   /** @brief UIF status bit remapping */
    static const int32_t G2_TIM17_CR2_OIS1N_POS             = 9;    /** @brief Output idle state 1 */
    static const int32_t G2_TIM17_CR2_OIS1_POS              = 8;    /** @brief Output idle state 1 */
    static const int32_t G2_TIM17_CR2_CCDS_POS              = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G2_TIM17_CR2_CCUS_POS              = 2;    /** @brief Capture/compare control update selection */
    static const int32_t G2_TIM17_CR2_CCPC_POS              = 0;    /** @brief Capture/compare preloaded control */
    static const int32_t G2_TIM17_DIER_UIE_POS              = 0;    /** @brief Update interrupt enable */
    static const int32_t G2_TIM17_DIER_CC1IE_POS            = 1;    /** @brief Capture/Compare 1 interrupt enable */
    static const int32_t G2_TIM17_DIER_COMIE_POS            = 5;    /** @brief COM interrupt enable */
    static const int32_t G2_TIM17_DIER_BIE_POS              = 7;    /** @brief Break interrupt enable */
    static const int32_t G2_TIM17_DIER_UDE_POS              = 8;    /** @brief Update DMA request enable */
    static const int32_t G2_TIM17_DIER_CC1DE_POS            = 9;    /** @brief Capture/Compare 1 DMA request enable */
    static const int32_t G2_TIM17_DIER_COMDE_POS            = 13;   /** @brief COM DMA request enable */
    static const int32_t G2_TIM17_SR_CC1OF_POS              = 9;    /** @brief Capture/Compare 1 overcapture flag */
    static const int32_t G2_TIM17_SR_BIF_POS                = 7;    /** @brief Break interrupt flag */
    static const int32_t G2_TIM17_SR_COMIF_POS              = 5;    /** @brief COM interrupt flag */
    static const int32_t G2_TIM17_SR_CC1IF_POS              = 1;    /** @brief Capture/compare 1 interrupt flag */
    static const int32_t G2_TIM17_SR_UIF_POS                = 0;    /** @brief Update interrupt flag */
    static const int32_t G2_TIM17_EGR_BG_POS                = 7;    /** @brief Break generation */
    static const int32_t G2_TIM17_EGR_COMG_POS              = 5;    /** @brief Capture/Compare control update generation */
    static const int32_t G2_TIM17_EGR_CC1G_POS              = 1;    /** @brief Capture/compare 1 generation */
    static const int32_t G2_TIM17_EGR_UG_POS                = 0;    /** @brief Update generation */
    static const int32_t G2_TIM17_CCMR1_OUTPUT_CC1S_POS     = 0;    /** @brief Capture/Compare 1 selection */
    static const int32_t G2_TIM17_CCMR1_OUTPUT_OC1FE_POS    = 2;    /** @brief Output compare 1 fast enable */
    static const int32_t G2_TIM17_CCMR1_OUTPUT_OC1PE_POS    = 3;    /** @brief Output compare 1 preload enable */
    static const int32_t G2_TIM17_CCMR1_OUTPUT_OC1M_POS     = 4;    /** @brief Output compare 1 mode */
    static const int32_t G2_TIM17_CCMR1_OUTPUT_OC1M_3_POS   = 16;   /** @brief Output compare 1 mode */
    static const int32_t G2_TIM17_CCMR1_INPUT_IC1F_POS      = 4;    /** @brief Input capture 1 filter */
    static const int32_t G2_TIM17_CCMR1_INPUT_IC1PSC_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G2_TIM17_CCMR1_INPUT_CC1S_POS      = 0;    /** @brief Capture/Compare 1 selection */
    static const int32_t G2_TIM17_CCER_CC1NP_POS            = 3;    /** @brief Capture/Compare 1 output polarity */
    static const int32_t G2_TIM17_CCER_CC1NE_POS            = 2;    /** @brief Capture/Compare 1 complementary output enable */
    static const int32_t G2_TIM17_CCER_CC1P_POS             = 1;    /** @brief Capture/Compare 1 output polarity */
    static const int32_t G2_TIM17_CCER_CC1E_POS             = 0;    /** @brief Capture/Compare 1 output enable */
    static const int32_t G2_TIM17_CNT_CNT_POS               = 0;    /** @brief Counter value */
    static const int32_t G2_TIM17_CNT_UIFCPY_POS            = 31;   /** @brief UIF copy */
    static const int32_t G2_TIM17_PSC_PSC_POS               = 0;    /** @brief Prescaler value */
    static const int32_t G2_TIM17_ARR_ARR_POS               = 0;    /** @brief Auto-reload value */
    static const int32_t G2_TIM17_RCR_REP_POS               = 0;    /** @brief Repetition counter value */
    static const int32_t G2_TIM17_CCR1_CCR1_POS             = 0;    /** @brief Capture/Compare 1 value */
    static const int32_t G2_TIM17_BDTR_DTG_POS              = 0;    /** @brief Dead-time generator setup */
    static const int32_t G2_TIM17_BDTR_LOCK_POS             = 8;    /** @brief Lock configuration */
    static const int32_t G2_TIM17_BDTR_OSSI_POS             = 10;   /** @brief Off-state selection for idle mode */
    static const int32_t G2_TIM17_BDTR_OSSR_POS             = 11;   /** @brief Off-state selection for run mode */
    static const int32_t G2_TIM17_BDTR_BKE_POS              = 12;   /** @brief Break enable */
    static const int32_t G2_TIM17_BDTR_BKP_POS              = 13;   /** @brief Break polarity */
    static const int32_t G2_TIM17_BDTR_AOE_POS              = 14;   /** @brief Automatic output enable */
    static const int32_t G2_TIM17_BDTR_MOE_POS              = 15;   /** @brief Main output enable */
    static const int32_t G2_TIM17_BDTR_BKF_POS              = 16;   /** @brief Break filter */
    static const int32_t G2_TIM17_DCR_DBL_POS               = 8;    /** @brief DMA burst length */
    static const int32_t G2_TIM17_DCR_DBA_POS               = 0;    /** @brief DMA base address */
    static const int32_t G2_TIM17_DMAR_DMAB_POS             = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G2_TIM17_TIM17_AF1_BKINE_POS       = 0;    /** @brief BRK BKIN input enable */
    static const int32_t G2_TIM17_TIM17_AF1_BKDFBK1E_POS    = 8;    /** @brief BRK dfsdm1_break[1] enable */
    static const int32_t G2_TIM17_TIM17_AF1_BKINP_POS       = 9;    /** @brief BRK BKIN input polarity */
    static const int32_t G2_TIM17_TIM17_TISEL_TI1SEL_POS    = 0;    /** @brief Selects TI1[0] to TI1[15] input */

    /**** @subsection Enumerated G2_TIM17 Register Field Positions ****/

    static const int32_t G2_TIM17_TIM17_AF1_BKCMPxE_POS[3] = {
      [1] = 1,   /** @brief BRK COMP1 enable */
      [2] = 2,   /** @brief BRK COMP2 enable */
    };

    static const int32_t G2_TIM17_TIM17_AF1_BKCMPxP_POS[3] = {
      [1] = 10,   /** @brief BRK COMP1 input polarity */
      [2] = 11,   /** @brief BRK COMP2 input polarity */
    };

    /**********************************************************************************************
     * @section TIM15 Register Information
     **********************************************************************************************/

    /**** @subsection TIM15 Register Pointers ****/

    static RW_ uint32_t* const TIM15_CR1_PTR            = (RW_ uint32_t* const)0x40014000U;   /** @brief Control register 1 */
    static RW_ uint32_t* const TIM15_CR2_PTR            = (RW_ uint32_t* const)0x40014004U;   /** @brief Control register 2 */
    static RW_ uint32_t* const TIM15_SMCR_PTR           = (RW_ uint32_t* const)0x40014008U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const TIM15_DIER_PTR           = (RW_ uint32_t* const)0x4001400CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const TIM15_SR_PTR             = (RW_ uint32_t* const)0x40014010U;   /** @brief Status register */
    static RW_ uint32_t* const TIM15_EGR_PTR            = (RW_ uint32_t* const)0x40014014U;   /** @brief Event generation register */
    static RW_ uint32_t* const TIM15_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40014018U;   /** @brief Capture/compare mode register (output mode) */
    static RW_ uint32_t* const TIM15_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40014018U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const TIM15_CCER_PTR           = (RW_ uint32_t* const)0x40014020U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const TIM15_CNT_PTR            = (RW_ uint32_t* const)0x40014024U;   /** @brief Counter */
    static RW_ uint32_t* const TIM15_PSC_PTR            = (RW_ uint32_t* const)0x40014028U;   /** @brief Prescaler */
    static RW_ uint32_t* const TIM15_ARR_PTR            = (RW_ uint32_t* const)0x4001402CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const TIM15_RCR_PTR            = (RW_ uint32_t* const)0x40014030U;   /** @brief Repetition counter register */
    static RW_ uint32_t* const TIM15_BDTR_PTR           = (RW_ uint32_t* const)0x40014044U;   /** @brief Break and dead-time register */
    static RW_ uint32_t* const TIM15_DCR_PTR            = (RW_ uint32_t* const)0x40014048U;   /** @brief DMA control register */
    static RW_ uint32_t* const TIM15_DMAR_PTR           = (RW_ uint32_t* const)0x4001404CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const TIM15_AF1_PTR            = (RW_ uint32_t* const)0x40014060U;   /** @brief TIM15 alternate fdfsdm1_breakon register 1 */
    static RW_ uint32_t* const TIM15_TISEL_PTR          = (RW_ uint32_t* const)0x40014068U;   /** @brief TIM15 input selection register */

    /**** @subsection Enumerated TIM15 Register Pointers ****/

    static RW_ uint32_t* const TIM15_CCRx_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40014034U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40014038U,   /** @brief Capture/compare register 2 */
    };

    /**** @subsection TIM15 Register Reset Values ****/

    static const uint32_t TIM15_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t TIM15_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t TIM15_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t TIM15_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t TIM15_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t TIM15_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t TIM15_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t TIM15_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t TIM15_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t TIM15_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t TIM15_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t TIM15_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t TIM15_RCR_RST            = 0x00000000U;   /** @brief RCR register reset value. */
    static const uint32_t TIM15_BDTR_RST           = 0x00000000U;   /** @brief BDTR register reset value. */
    static const uint32_t TIM15_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t TIM15_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t TIM15_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t TIM15_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated TIM15 Register Reset Values ****/

    static const uint32_t TIM15_CCRx_RST[3] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
    };

    /**** @subsection Enumerated TIM15 Register Value Types ****/

    typedef uint32_t TIM15_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t TIM15_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t TIM15_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t TIM15_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t TIM15_SR_t;             /** @brief SR register value type. */
    typedef uint32_t TIM15_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t TIM15_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t TIM15_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t TIM15_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t TIM15_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t TIM15_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t TIM15_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t TIM15_RCR_t;            /** @brief RCR register value type. */
    typedef uint32_t TIM15_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t TIM15_BDTR_t;           /** @brief BDTR register value type. */
    typedef uint32_t TIM15_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t TIM15_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t TIM15_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t TIM15_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated TIM15 Register Pointer Types ****/

    typedef uint32_t* const TIM15_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const TIM15_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const TIM15_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const TIM15_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const TIM15_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const TIM15_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const TIM15_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const TIM15_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const TIM15_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const TIM15_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const TIM15_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const TIM15_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const TIM15_RCR_PTR_t;            /** @brief RCR register pointer type. */
    typedef uint32_t* const TIM15_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const TIM15_BDTR_PTR_t;           /** @brief BDTR register pointer type. */
    typedef uint32_t* const TIM15_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const TIM15_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const TIM15_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const TIM15_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection TIM15 Register Field Masks ****/

    static const uint32_t TIM15_CR1_CEN_MASK         = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t TIM15_CR1_UDIS_MASK        = 0x00000002U;   /** @brief Update disable */
    static const uint32_t TIM15_CR1_URS_MASK         = 0x00000004U;   /** @brief Update request source */
    static const uint32_t TIM15_CR1_OPM_MASK         = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t TIM15_CR1_ARPE_MASK        = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t TIM15_CR1_CKD_MASK         = 0x00000300U;   /** @brief Clock division */
    static const uint32_t TIM15_CR1_UIFREMAP_MASK    = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t TIM15_CR2_CCPC_MASK        = 0x00000001U;   /** @brief Capture/compare preloaded control */
    static const uint32_t TIM15_CR2_CCUS_MASK        = 0x00000004U;   /** @brief Capture/compare control update selection */
    static const uint32_t TIM15_CR2_CCDS_MASK        = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t TIM15_CR2_MMS_MASK         = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t TIM15_CR2_TI1S_MASK        = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t TIM15_CR2_OIS1N_MASK       = 0x00000200U;   /** @brief Output idle state 1 */
    static const uint32_t TIM15_SMCR_SMS_MASK        = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t TIM15_SMCR_TS_2_0_MASK     = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t TIM15_SMCR_MSM_MASK        = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t TIM15_SMCR_SMS_3_MASK      = 0x00010000U;   /** @brief Slave mode selection bit 3 */
    static const uint32_t TIM15_SMCR_TS_4_3_MASK     = 0x00300000U;   /** @brief Trigger selection - bit 4:3 */
    static const uint32_t TIM15_DIER_UIE_MASK        = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t TIM15_DIER_COMIE_MASK      = 0x00000020U;   /** @brief COM interrupt enable */
    static const uint32_t TIM15_DIER_TIE_MASK        = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t TIM15_DIER_BIE_MASK        = 0x00000080U;   /** @brief Break interrupt enable */
    static const uint32_t TIM15_DIER_UDE_MASK        = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t TIM15_DIER_COMDE_MASK      = 0x00002000U;   /** @brief COM DMA request enable */
    static const uint32_t TIM15_DIER_TDE_MASK        = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t TIM15_SR_BIF_MASK          = 0x00000080U;   /** @brief Break interrupt flag */
    static const uint32_t TIM15_SR_TIF_MASK          = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t TIM15_SR_COMIF_MASK        = 0x00000020U;   /** @brief COM interrupt flag */
    static const uint32_t TIM15_SR_UIF_MASK          = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t TIM15_EGR_BG_MASK          = 0x00000080U;   /** @brief Break generation */
    static const uint32_t TIM15_EGR_TG_MASK          = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t TIM15_EGR_COMG_MASK        = 0x00000020U;   /** @brief Capture/Compare control update generation */
    static const uint32_t TIM15_EGR_UG_MASK          = 0x00000001U;   /** @brief Update generation */
    static const uint32_t TIM15_CCER_CC1NE_MASK      = 0x00000004U;   /** @brief Capture/Compare 1 complementary output enable */
    static const uint32_t TIM15_CNT_CNT_MASK         = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t TIM15_CNT_UIFCPY_MASK      = 0x80000000U;   /** @brief UIF copy */
    static const uint32_t TIM15_PSC_PSC_MASK         = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t TIM15_ARR_ARR_MASK         = 0x0000FFFFU;   /** @brief Auto-reload value */
    static const uint32_t TIM15_RCR_REP_MASK         = 0x000000FFU;   /** @brief Repetition counter value */
    static const uint32_t TIM15_CCRx_CCR1_MASK       = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
    static const uint32_t TIM15_BDTR_MOE_MASK        = 0x00008000U;   /** @brief Main output enable */
    static const uint32_t TIM15_BDTR_AOE_MASK        = 0x00004000U;   /** @brief Automatic output enable */
    static const uint32_t TIM15_BDTR_BKP_MASK        = 0x00002000U;   /** @brief Break polarity */
    static const uint32_t TIM15_BDTR_BKE_MASK        = 0x00001000U;   /** @brief Break enable */
    static const uint32_t TIM15_BDTR_OSSR_MASK       = 0x00000800U;   /** @brief Off-state selection for run mode */
    static const uint32_t TIM15_BDTR_OSSI_MASK       = 0x00000400U;   /** @brief Off-state selection for idle mode */
    static const uint32_t TIM15_BDTR_LOCK_MASK       = 0x00000300U;   /** @brief Lock configuration */
    static const uint32_t TIM15_BDTR_DTG_MASK        = 0x000000FFU;   /** @brief Dead-time generator setup */
    static const uint32_t TIM15_BDTR_BKF_MASK        = 0x000F0000U;   /** @brief Break filter */
    static const uint32_t TIM15_DCR_DBL_MASK         = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t TIM15_DCR_DBA_MASK         = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t TIM15_DMAR_DMAB_MASK       = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t TIM15_AF1_BKINE_MASK       = 0x00000001U;   /** @brief BRK BKIN input enable */
    static const uint32_t TIM15_AF1_BKDF1BK0E_MASK   = 0x00000100U;   /** @brief BRK dfsdm1_break[0] enable */
    static const uint32_t TIM15_AF1_BKINP_MASK       = 0x00000200U;   /** @brief BRK BKIN input polarity */

    /**** @subsection Enumerated TIM15 Register Field Masks ****/

    static const uint32_t TIM15_CR2_OISx_MASK[3] = {
      [1] = 0x00000100U,   /** @brief Output idle state 1 */
      [2] = 0x00000400U,   /** @brief Output idle state 2 */
    };

    static const uint32_t TIM15_DIER_CCxIE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
    };

    static const uint32_t TIM15_DIER_CCxDE_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
    };

    static const uint32_t TIM15_SR_CCxOF_MASK[3] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
    };

    static const uint32_t TIM15_SR_CCxIF_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
    };

    static const uint32_t TIM15_EGR_CCxG_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
    };

    static const uint32_t TIM15_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief Capture/Compare 1 selection */
      [2] = 0x00000300U,   /** @brief Capture/Compare 2 selection */
    };

    static const uint32_t TIM15_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output compare 1 fast enable */
      [2] = 0x00000400U,   /** @brief Output compare 2 fast enable */
    };

    static const uint32_t TIM15_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output compare 1 preload enable */
      [2] = 0x00000800U,   /** @brief Output compare 2 preload enable */
    };

    static const uint32_t TIM15_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief Output compare 1 mode */
      [2] = 0x00007000U,   /** @brief Output compare 2 mode */
    };

    static const uint32_t TIM15_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode bit 3 */
    };

    static const uint32_t TIM15_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t TIM15_CCMR1_INPUT_ICxPSC_MASK[3] = {
      [1] = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [2] = 0x00000C00U,   /** @brief Input capture 2 prescaler */
    };

    static const uint32_t TIM15_CCER_CCxNP_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
    };

    static const uint32_t TIM15_CCER_CCxP_MASK[3] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
    };

    static const uint32_t TIM15_CCER_CCxE_MASK[3] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
    };

    static const uint32_t TIM15_AF1_BKCMPxE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
      [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
    };

    static const uint32_t TIM15_AF1_BKCMPxP_MASK[3] = {
      [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
      [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
    };

    static const uint32_t TIM15_TISEL_TIxSEL_MASK[3] = {
      [1] = 0x0000000FU,   /** @brief Selects TI1[0] to TI1[15] input */
      [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
    };

    /**** @subsection TIM15 Register Field Positions ****/

    static const int32_t TIM15_CR1_CEN_POS         = 0;    /** @brief Counter enable */
    static const int32_t TIM15_CR1_UDIS_POS        = 1;    /** @brief Update disable */
    static const int32_t TIM15_CR1_URS_POS         = 2;    /** @brief Update request source */
    static const int32_t TIM15_CR1_OPM_POS         = 3;    /** @brief One-pulse mode */
    static const int32_t TIM15_CR1_ARPE_POS        = 7;    /** @brief Auto-reload preload enable */
    static const int32_t TIM15_CR1_CKD_POS         = 8;    /** @brief Clock division */
    static const int32_t TIM15_CR1_UIFREMAP_POS    = 11;   /** @brief UIF status bit remapping */
    static const int32_t TIM15_CR2_CCPC_POS        = 0;    /** @brief Capture/compare preloaded control */
    static const int32_t TIM15_CR2_CCUS_POS        = 2;    /** @brief Capture/compare control update selection */
    static const int32_t TIM15_CR2_CCDS_POS        = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t TIM15_CR2_MMS_POS         = 4;    /** @brief Master mode selection */
    static const int32_t TIM15_CR2_TI1S_POS        = 7;    /** @brief TI1 selection */
    static const int32_t TIM15_CR2_OIS1N_POS       = 9;    /** @brief Output idle state 1 */
    static const int32_t TIM15_SMCR_SMS_POS        = 0;    /** @brief Slave mode selection */
    static const int32_t TIM15_SMCR_TS_2_0_POS     = 4;    /** @brief Trigger selection */
    static const int32_t TIM15_SMCR_MSM_POS        = 7;    /** @brief Master/Slave mode */
    static const int32_t TIM15_SMCR_SMS_3_POS      = 16;   /** @brief Slave mode selection bit 3 */
    static const int32_t TIM15_SMCR_TS_4_3_POS     = 20;   /** @brief Trigger selection - bit 4:3 */
    static const int32_t TIM15_DIER_UIE_POS        = 0;    /** @brief Update interrupt enable */
    static const int32_t TIM15_DIER_COMIE_POS      = 5;    /** @brief COM interrupt enable */
    static const int32_t TIM15_DIER_TIE_POS        = 6;    /** @brief Trigger interrupt enable */
    static const int32_t TIM15_DIER_BIE_POS        = 7;    /** @brief Break interrupt enable */
    static const int32_t TIM15_DIER_UDE_POS        = 8;    /** @brief Update DMA request enable */
    static const int32_t TIM15_DIER_COMDE_POS      = 13;   /** @brief COM DMA request enable */
    static const int32_t TIM15_DIER_TDE_POS        = 14;   /** @brief Trigger DMA request enable */
    static const int32_t TIM15_SR_BIF_POS          = 7;    /** @brief Break interrupt flag */
    static const int32_t TIM15_SR_TIF_POS          = 6;    /** @brief Trigger interrupt flag */
    static const int32_t TIM15_SR_COMIF_POS        = 5;    /** @brief COM interrupt flag */
    static const int32_t TIM15_SR_UIF_POS          = 0;    /** @brief Update interrupt flag */
    static const int32_t TIM15_EGR_BG_POS          = 7;    /** @brief Break generation */
    static const int32_t TIM15_EGR_TG_POS          = 6;    /** @brief Trigger generation */
    static const int32_t TIM15_EGR_COMG_POS        = 5;    /** @brief Capture/Compare control update generation */
    static const int32_t TIM15_EGR_UG_POS          = 0;    /** @brief Update generation */
    static const int32_t TIM15_CCER_CC1NE_POS      = 2;    /** @brief Capture/Compare 1 complementary output enable */
    static const int32_t TIM15_CNT_CNT_POS         = 0;    /** @brief Counter value */
    static const int32_t TIM15_CNT_UIFCPY_POS      = 31;   /** @brief UIF copy */
    static const int32_t TIM15_PSC_PSC_POS         = 0;    /** @brief Prescaler value */
    static const int32_t TIM15_ARR_ARR_POS         = 0;    /** @brief Auto-reload value */
    static const int32_t TIM15_RCR_REP_POS         = 0;    /** @brief Repetition counter value */
    static const int32_t TIM15_CCRx_CCR1_POS       = 0;    /** @brief Capture/Compare 1 value */
    static const int32_t TIM15_BDTR_MOE_POS        = 15;   /** @brief Main output enable */
    static const int32_t TIM15_BDTR_AOE_POS        = 14;   /** @brief Automatic output enable */
    static const int32_t TIM15_BDTR_BKP_POS        = 13;   /** @brief Break polarity */
    static const int32_t TIM15_BDTR_BKE_POS        = 12;   /** @brief Break enable */
    static const int32_t TIM15_BDTR_OSSR_POS       = 11;   /** @brief Off-state selection for run mode */
    static const int32_t TIM15_BDTR_OSSI_POS       = 10;   /** @brief Off-state selection for idle mode */
    static const int32_t TIM15_BDTR_LOCK_POS       = 8;    /** @brief Lock configuration */
    static const int32_t TIM15_BDTR_DTG_POS        = 0;    /** @brief Dead-time generator setup */
    static const int32_t TIM15_BDTR_BKF_POS        = 16;   /** @brief Break filter */
    static const int32_t TIM15_DCR_DBL_POS         = 8;    /** @brief DMA burst length */
    static const int32_t TIM15_DCR_DBA_POS         = 0;    /** @brief DMA base address */
    static const int32_t TIM15_DMAR_DMAB_POS       = 0;    /** @brief DMA register for burst accesses */
    static const int32_t TIM15_AF1_BKINE_POS       = 0;    /** @brief BRK BKIN input enable */
    static const int32_t TIM15_AF1_BKDF1BK0E_POS   = 8;    /** @brief BRK dfsdm1_break[0] enable */
    static const int32_t TIM15_AF1_BKINP_POS       = 9;    /** @brief BRK BKIN input polarity */

    /**** @subsection Enumerated TIM15 Register Field Positions ****/

    static const int32_t TIM15_CR2_OISx_POS[3] = {
      [1] = 8,    /** @brief Output idle state 1 */
      [2] = 10,   /** @brief Output idle state 2 */
    };

    static const int32_t TIM15_DIER_CCxIE_POS[3] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
    };

    static const int32_t TIM15_DIER_CCxDE_POS[3] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
    };

    static const int32_t TIM15_SR_CCxOF_POS[3] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
    };

    static const int32_t TIM15_SR_CCxIF_POS[3] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
    };

    static const int32_t TIM15_EGR_CCxG_POS[3] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
    };

    static const int32_t TIM15_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief Capture/Compare 1 selection */
      [2] = 8,   /** @brief Capture/Compare 2 selection */
    };

    static const int32_t TIM15_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief Output compare 1 fast enable */
      [2] = 10,   /** @brief Output compare 2 fast enable */
    };

    static const int32_t TIM15_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief Output compare 1 preload enable */
      [2] = 11,   /** @brief Output compare 2 preload enable */
    };

    static const int32_t TIM15_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief Output compare 1 mode */
      [2] = 12,   /** @brief Output compare 2 mode */
    };

    static const int32_t TIM15_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode bit 3 */
    };

    static const int32_t TIM15_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t TIM15_CCMR1_INPUT_ICxPSC_POS[3] = {
      [1] = 2,    /** @brief Input capture 1 prescaler */
      [2] = 10,   /** @brief Input capture 2 prescaler */
    };

    static const int32_t TIM15_CCER_CCxNP_POS[3] = {
      [1] = 3,   /** @brief Capture/Compare 1 output polarity */
      [2] = 7,   /** @brief Capture/Compare 2 output polarity */
    };

    static const int32_t TIM15_CCER_CCxP_POS[3] = {
      [1] = 1,   /** @brief Capture/Compare 1 output polarity */
      [2] = 5,   /** @brief Capture/Compare 2 output polarity */
    };

    static const int32_t TIM15_CCER_CCxE_POS[3] = {
      [1] = 0,   /** @brief Capture/Compare 1 output enable */
      [2] = 4,   /** @brief Capture/Compare 2 output enable */
    };

    static const int32_t TIM15_AF1_BKCMPxE_POS[3] = {
      [1] = 1,   /** @brief BRK COMP1 enable */
      [2] = 2,   /** @brief BRK COMP2 enable */
    };

    static const int32_t TIM15_AF1_BKCMPxP_POS[3] = {
      [1] = 10,   /** @brief BRK COMP1 input polarity */
      [2] = 11,   /** @brief BRK COMP2 input polarity */
    };

    static const int32_t TIM15_TISEL_TIxSEL_POS[3] = {
      [1] = 0,   /** @brief Selects TI1[0] to TI1[15] input */
      [2] = 8,   /** @brief Selects TI2[0] to TI2[15] input */
    };

    /**********************************************************************************************
     * @section USARTx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated USARTx Register Pointers ****/

    static RW_ uint32_t* const USARTx_CR1_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40004400U,   /** @brief Control register 1 */
      [3] = (RW_ uint32_t* const)0x40004800U,   /** @brief Control register 1 */
      [6] = (RW_ uint32_t* const)0x40011400U,   /** @brief Control register 1 */
    };

    static RW_ uint32_t* const USARTx_CR2_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011004U,   /** @brief Control register 2 */
      [2] = (RW_ uint32_t* const)0x40004404U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40004804U,   /** @brief Control register 2 */
      [6] = (RW_ uint32_t* const)0x40011404U,   /** @brief Control register 2 */
    };

    static RW_ uint32_t* const USARTx_CR3_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011008U,   /** @brief Control register 3 */
      [2] = (RW_ uint32_t* const)0x40004408U,   /** @brief Control register 3 */
      [3] = (RW_ uint32_t* const)0x40004808U,   /** @brief Control register 3 */
      [6] = (RW_ uint32_t* const)0x40011408U,   /** @brief Control register 3 */
    };

    static RW_ uint32_t* const USARTx_BRR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x4001100CU,   /** @brief Baud rate register */
      [2] = (RW_ uint32_t* const)0x4000440CU,   /** @brief Baud rate register */
      [3] = (RW_ uint32_t* const)0x4000480CU,   /** @brief Baud rate register */
      [6] = (RW_ uint32_t* const)0x4001140CU,   /** @brief Baud rate register */
    };

    static RW_ uint32_t* const USARTx_GTPR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011010U,   /** @brief Guard time and prescaler register */
      [2] = (RW_ uint32_t* const)0x40004410U,   /** @brief Guard time and prescaler register */
      [3] = (RW_ uint32_t* const)0x40004810U,   /** @brief Guard time and prescaler register */
      [6] = (RW_ uint32_t* const)0x40011410U,   /** @brief Guard time and prescaler register */
    };

    static RW_ uint32_t* const USARTx_RTOR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011014U,   /** @brief Receiver timeout register */
      [2] = (RW_ uint32_t* const)0x40004414U,   /** @brief Receiver timeout register */
      [3] = (RW_ uint32_t* const)0x40004814U,   /** @brief Receiver timeout register */
      [6] = (RW_ uint32_t* const)0x40011414U,   /** @brief Receiver timeout register */
    };

    static RW_ uint32_t* const USARTx_RQR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011018U,   /** @brief Request register */
      [2] = (RW_ uint32_t* const)0x40004418U,   /** @brief Request register */
      [3] = (RW_ uint32_t* const)0x40004818U,   /** @brief Request register */
      [6] = (RW_ uint32_t* const)0x40011418U,   /** @brief Request register */
    };

    static RO_ uint32_t* const USARTx_ISR_PTR[7] = {
      [1] = (RO_ uint32_t* const)0x4001101CU,   /** @brief Interrupt & status register */
      [2] = (RO_ uint32_t* const)0x4000441CU,   /** @brief Interrupt & status register */
      [3] = (RO_ uint32_t* const)0x4000481CU,   /** @brief Interrupt & status register */
      [6] = (RO_ uint32_t* const)0x4001141CU,   /** @brief Interrupt & status register */
    };

    static RW_ uint32_t* const USARTx_ICR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011020U,   /** @brief Interrupt flag clear register */
      [2] = (RW_ uint32_t* const)0x40004420U,   /** @brief Interrupt flag clear register */
      [3] = (RW_ uint32_t* const)0x40004820U,   /** @brief Interrupt flag clear register */
      [6] = (RW_ uint32_t* const)0x40011420U,   /** @brief Interrupt flag clear register */
    };

    static RO_ uint32_t* const USARTx_RDR_PTR[7] = {
      [1] = (RO_ uint32_t* const)0x40011024U,   /** @brief Receive data register */
      [2] = (RO_ uint32_t* const)0x40004424U,   /** @brief Receive data register */
      [3] = (RO_ uint32_t* const)0x40004824U,   /** @brief Receive data register */
      [6] = (RO_ uint32_t* const)0x40011424U,   /** @brief Receive data register */
    };

    static RW_ uint32_t* const USARTx_TDR_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x40011028U,   /** @brief Transmit data register */
      [2] = (RW_ uint32_t* const)0x40004428U,   /** @brief Transmit data register */
      [3] = (RW_ uint32_t* const)0x40004828U,   /** @brief Transmit data register */
      [6] = (RW_ uint32_t* const)0x40011428U,   /** @brief Transmit data register */
    };

    static RW_ uint32_t* const USARTx_PRESC_PTR[7] = {
      [1] = (RW_ uint32_t* const)0x4001102CU,   /** @brief USART prescaler register */
      [2] = (RW_ uint32_t* const)0x4000442CU,   /** @brief USART prescaler register */
      [3] = (RW_ uint32_t* const)0x4000482CU,   /** @brief USART prescaler register */
      [6] = (RW_ uint32_t* const)0x4001142CU,   /** @brief USART prescaler register */
    };

    /**** @subsection Enumerated USARTx Register Reset Values ****/

    static const uint32_t USARTx_CR1_RST[7] = {
      [1] = 0x00000000U,   /** @brief CR1 register reset value */
      [2] = 0x00000000U,   /** @brief CR1 register reset value */
      [3] = 0x00000000U,   /** @brief CR1 register reset value */
      [6] = 0x00000000U,   /** @brief CR1 register reset value */
    };

    static const uint32_t USARTx_CR2_RST[7] = {
      [1] = 0x00000000U,   /** @brief CR2 register reset value */
      [2] = 0x00000000U,   /** @brief CR2 register reset value */
      [3] = 0x00000000U,   /** @brief CR2 register reset value */
      [6] = 0x00000000U,   /** @brief CR2 register reset value */
    };

    static const uint32_t USARTx_CR3_RST[7] = {
      [1] = 0x00000000U,   /** @brief CR3 register reset value */
      [2] = 0x00000000U,   /** @brief CR3 register reset value */
      [3] = 0x00000000U,   /** @brief CR3 register reset value */
      [6] = 0x00000000U,   /** @brief CR3 register reset value */
    };

    static const uint32_t USARTx_BRR_RST[7] = {
      [1] = 0x00000000U,   /** @brief BRR register reset value */
      [2] = 0x00000000U,   /** @brief BRR register reset value */
      [3] = 0x00000000U,   /** @brief BRR register reset value */
      [6] = 0x00000000U,   /** @brief BRR register reset value */
    };

    static const uint32_t USARTx_GTPR_RST[7] = {
      [1] = 0x00000000U,   /** @brief GTPR register reset value */
      [2] = 0x00000000U,   /** @brief GTPR register reset value */
      [3] = 0x00000000U,   /** @brief GTPR register reset value */
      [6] = 0x00000000U,   /** @brief GTPR register reset value */
    };

    static const uint32_t USARTx_RTOR_RST[7] = {
      [1] = 0x00000000U,   /** @brief RTOR register reset value */
      [2] = 0x00000000U,   /** @brief RTOR register reset value */
      [3] = 0x00000000U,   /** @brief RTOR register reset value */
      [6] = 0x00000000U,   /** @brief RTOR register reset value */
    };

    static const uint32_t USARTx_RQR_RST[7] = {
      [1] = 0x00000000U,   /** @brief RQR register reset value */
      [2] = 0x00000000U,   /** @brief RQR register reset value */
      [3] = 0x00000000U,   /** @brief RQR register reset value */
      [6] = 0x00000000U,   /** @brief RQR register reset value */
    };

    static const uint32_t USARTx_ISR_RST[7] = {
      [1] = 0x000000C0U,   /** @brief ISR register reset value */
      [2] = 0x000000C0U,   /** @brief ISR register reset value */
      [3] = 0x000000C0U,   /** @brief ISR register reset value */
      [6] = 0x000000C0U,   /** @brief ISR register reset value */
    };

    static const uint32_t USARTx_ICR_RST[7] = {
      [1] = 0x00000000U,   /** @brief ICR register reset value */
      [2] = 0x00000000U,   /** @brief ICR register reset value */
      [3] = 0x00000000U,   /** @brief ICR register reset value */
      [6] = 0x00000000U,   /** @brief ICR register reset value */
    };

    static const uint32_t USARTx_RDR_RST[7] = {
      [1] = 0x00000000U,   /** @brief RDR register reset value */
      [2] = 0x00000000U,   /** @brief RDR register reset value */
      [3] = 0x00000000U,   /** @brief RDR register reset value */
      [6] = 0x00000000U,   /** @brief RDR register reset value */
    };

    static const uint32_t USARTx_TDR_RST[7] = {
      [1] = 0x00000000U,   /** @brief TDR register reset value */
      [2] = 0x00000000U,   /** @brief TDR register reset value */
      [3] = 0x00000000U,   /** @brief TDR register reset value */
      [6] = 0x00000000U,   /** @brief TDR register reset value */
    };

    static const uint32_t USARTx_PRESC_RST[7] = {
      [1] = 0x00000000U,   /** @brief PRESC register reset value */
      [2] = 0x00000000U,   /** @brief PRESC register reset value */
      [3] = 0x00000000U,   /** @brief PRESC register reset value */
      [6] = 0x00000000U,   /** @brief PRESC register reset value */
    };

    /**** @subsection Enumerated USARTx Register Value Types ****/

    typedef uint32_t USARTx_CR1_t;     /** @brief CR1 register value type. */
    typedef uint32_t USARTx_CR2_t;     /** @brief CR2 register value type. */
    typedef uint32_t USARTx_CR3_t;     /** @brief CR3 register value type. */
    typedef uint32_t USARTx_BRR_t;     /** @brief BRR register value type. */
    typedef uint32_t USARTx_GTPR_t;    /** @brief GTPR register value type. */
    typedef uint32_t USARTx_RTOR_t;    /** @brief RTOR register value type. */
    typedef uint32_t USARTx_RQR_t;     /** @brief RQR register value type. */
    typedef uint32_t USARTx_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t USARTx_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t USARTx_RDR_t;     /** @brief RDR register value type. */
    typedef uint32_t USARTx_TDR_t;     /** @brief TDR register value type. */
    typedef uint32_t USARTx_PRESC_t;   /** @brief PRESC register value type. */

    /**** @subsection Enumerated USARTx Register Pointer Types ****/

    typedef uint32_t* const USARTx_CR1_PTR_t;     /** @brief CR1 register pointer type. */
    typedef uint32_t* const USARTx_CR2_PTR_t;     /** @brief CR2 register pointer type. */
    typedef uint32_t* const USARTx_CR3_PTR_t;     /** @brief CR3 register pointer type. */
    typedef uint32_t* const USARTx_BRR_PTR_t;     /** @brief BRR register pointer type. */
    typedef uint32_t* const USARTx_GTPR_PTR_t;    /** @brief GTPR register pointer type. */
    typedef uint32_t* const USARTx_RTOR_PTR_t;    /** @brief RTOR register pointer type. */
    typedef uint32_t* const USARTx_RQR_PTR_t;     /** @brief RQR register pointer type. */
    typedef uint32_t* const USARTx_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const USARTx_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const USARTx_RDR_PTR_t;     /** @brief RDR register pointer type. */
    typedef uint32_t* const USARTx_TDR_PTR_t;     /** @brief TDR register pointer type. */
    typedef uint32_t* const USARTx_PRESC_PTR_t;   /** @brief PRESC register pointer type. */

    /**** @subsection USARTx Register Field Masks ****/

    static const uint32_t USARTx_CR1_RXFFIE_MASK        = 0x80000000U;   /** @brief RXFIFO full interrupt enable */
    static const uint32_t USARTx_CR1_TXFEIE_MASK        = 0x40000000U;   /** @brief TXFIFO empty interrupt enable */
    static const uint32_t USARTx_CR1_FIFOEN_MASK        = 0x20000000U;   /** @brief FIFO mode enable */
    static const uint32_t USARTx_CR1_EOBIE_MASK         = 0x08000000U;   /** @brief End of block interrupt enable */
    static const uint32_t USARTx_CR1_RTOIE_MASK         = 0x04000000U;   /** @brief Receiver timeout interrupt enable */
    static const uint32_t USARTx_CR1_OVER8_MASK         = 0x00008000U;   /** @brief Oversampling mode */
    static const uint32_t USARTx_CR1_CMIE_MASK          = 0x00004000U;   /** @brief Character match interrupt enable */
    static const uint32_t USARTx_CR1_MME_MASK           = 0x00002000U;   /** @brief Mute mode enable */
    static const uint32_t USARTx_CR1_WAKE_MASK          = 0x00000800U;   /** @brief Receiver wakeup method */
    static const uint32_t USARTx_CR1_PCE_MASK           = 0x00000400U;   /** @brief Parity control enable */
    static const uint32_t USARTx_CR1_PS_MASK            = 0x00000200U;   /** @brief Parity selection */
    static const uint32_t USARTx_CR1_PEIE_MASK          = 0x00000100U;   /** @brief PE interrupt enable */
    static const uint32_t USARTx_CR1_TXEIE_MASK         = 0x00000080U;   /** @brief Interrupt enable */
    static const uint32_t USARTx_CR1_TCIE_MASK          = 0x00000040U;   /** @brief Transmission complete interrupt enable */
    static const uint32_t USARTx_CR1_RXNEIE_MASK        = 0x00000020U;   /** @brief RXNE interrupt enable */
    static const uint32_t USARTx_CR1_IDLEIE_MASK        = 0x00000010U;   /** @brief IDLE interrupt enable */
    static const uint32_t USARTx_CR1_TE_MASK            = 0x00000008U;   /** @brief Transmitter enable */
    static const uint32_t USARTx_CR1_RE_MASK            = 0x00000004U;   /** @brief Receiver enable */
    static const uint32_t USARTx_CR1_UESM_MASK          = 0x00000002U;   /** @brief USART enable in stop mode */
    static const uint32_t USARTx_CR1_UE_MASK            = 0x00000001U;   /** @brief USART enable */
    static const uint32_t USARTx_CR2_ADD4_7_MASK        = 0xF0000000U;   /** @brief Address of the USART node */
    static const uint32_t USARTx_CR2_ADD0_3_MASK        = 0x0F000000U;   /** @brief Address of the USART node */
    static const uint32_t USARTx_CR2_RTOEN_MASK         = 0x00800000U;   /** @brief Receiver timeout enable */
    static const uint32_t USARTx_CR2_ABREN_MASK         = 0x00100000U;   /** @brief Auto baud rate enable */
    static const uint32_t USARTx_CR2_MSBFIRST_MASK      = 0x00080000U;   /** @brief Most significant bit first */
    static const uint32_t USARTx_CR2_TAINV_MASK         = 0x00040000U;   /** @brief Binary data inversion */
    static const uint32_t USARTx_CR2_TXINV_MASK         = 0x00020000U;   /** @brief TX pin active level inversion */
    static const uint32_t USARTx_CR2_RXINV_MASK         = 0x00010000U;   /** @brief RX pin active level inversion */
    static const uint32_t USARTx_CR2_SWAP_MASK          = 0x00008000U;   /** @brief Swap TX/RX pins */
    static const uint32_t USARTx_CR2_LINEN_MASK         = 0x00004000U;   /** @brief LIN mode enable */
    static const uint32_t USARTx_CR2_STOP_MASK          = 0x00003000U;   /** @brief STOP bits */
    static const uint32_t USARTx_CR2_CLKEN_MASK         = 0x00000800U;   /** @brief Clock enable */
    static const uint32_t USARTx_CR2_CPOL_MASK          = 0x00000400U;   /** @brief Clock polarity */
    static const uint32_t USARTx_CR2_CPHA_MASK          = 0x00000200U;   /** @brief Clock phase */
    static const uint32_t USARTx_CR2_LBCL_MASK          = 0x00000100U;   /** @brief Last bit clock pulse */
    static const uint32_t USARTx_CR2_LBDIE_MASK         = 0x00000040U;   /** @brief LIN break detection interrupt enable */
    static const uint32_t USARTx_CR2_LBDL_MASK          = 0x00000020U;   /** @brief LIN break detection length */
    static const uint32_t USARTx_CR2_ADDM7_MASK         = 0x00000010U;   /** @brief 7-bit address detection/4-bit address detection */
    static const uint32_t USARTx_CR2_DIS_NSS_MASK       = 0x00000008U;   /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const uint32_t USARTx_CR2_SLVEN_MASK         = 0x00000001U;   /** @brief Synchronous slave mode enable */
    static const uint32_t USARTx_CR3_TXFTCFG_MASK       = 0xE0000000U;   /** @brief TXFIFO threshold configuration */
    static const uint32_t USARTx_CR3_RXFTIE_MASK        = 0x10000000U;   /** @brief RXFIFO threshold interrupt enable */
    static const uint32_t USARTx_CR3_RXFTCFG_MASK       = 0x0E000000U;   /** @brief Receive FIFO threshold configuration */
    static const uint32_t USARTx_CR3_TCBGTIE_MASK       = 0x01000000U;   /** @brief Transmission complete before guard time, interrupt enable */
    static const uint32_t USARTx_CR3_TXFTIE_MASK        = 0x00800000U;   /** @brief TXFIFO threshold interrupt enable */
    static const uint32_t USARTx_CR3_WUFIE_MASK         = 0x00400000U;   /** @brief Wakeup from stop mode interrupt enable */
    static const uint32_t USARTx_CR3_WUS_MASK           = 0x00300000U;   /** @brief Wakeup from stop mode interrupt flag selection */
    static const uint32_t USARTx_CR3_SCARCNT_MASK       = 0x000E0000U;   /** @brief Smartcard auto-retry count */
    static const uint32_t USARTx_CR3_DEP_MASK           = 0x00008000U;   /** @brief Driver enable polarity selection */
    static const uint32_t USARTx_CR3_DEM_MASK           = 0x00004000U;   /** @brief Driver enable mode */
    static const uint32_t USARTx_CR3_DDRE_MASK          = 0x00002000U;   /** @brief DMA disable on reception error */
    static const uint32_t USARTx_CR3_OVRDIS_MASK        = 0x00001000U;   /** @brief Overrun disable */
    static const uint32_t USARTx_CR3_ONEBIT_MASK        = 0x00000800U;   /** @brief One sample bit method enable */
    static const uint32_t USARTx_CR3_CTSIE_MASK         = 0x00000400U;   /** @brief CTS interrupt enable */
    static const uint32_t USARTx_CR3_CTSE_MASK          = 0x00000200U;   /** @brief CTS enable */
    static const uint32_t USARTx_CR3_RTSE_MASK          = 0x00000100U;   /** @brief RTS enable */
    static const uint32_t USARTx_CR3_DMAT_MASK          = 0x00000080U;   /** @brief DMA enable transmitter */
    static const uint32_t USARTx_CR3_DMAR_MASK          = 0x00000040U;   /** @brief DMA enable receiver */
    static const uint32_t USARTx_CR3_SCEN_MASK          = 0x00000020U;   /** @brief Smartcard mode enable */
    static const uint32_t USARTx_CR3_NACK_MASK          = 0x00000010U;   /** @brief Smartcard NACK enable */
    static const uint32_t USARTx_CR3_HDSEL_MASK         = 0x00000008U;   /** @brief Half-duplex selection */
    static const uint32_t USARTx_CR3_IRLP_MASK          = 0x00000004U;   /** @brief Ir low-power */
    static const uint32_t USARTx_CR3_IREN_MASK          = 0x00000002U;   /** @brief Ir mode enable */
    static const uint32_t USARTx_CR3_EIE_MASK           = 0x00000001U;   /** @brief Error interrupt enable */
    static const uint32_t USARTx_BRR_BRR_4_15_MASK      = 0x0000FFF0U;   /** @brief DIV_Mantissa */
    static const uint32_t USARTx_BRR_BRR_0_3_MASK       = 0x0000000FU;   /** @brief DIV_Fraction */
    static const uint32_t USARTx_GTPR_GT_MASK           = 0x0000FF00U;   /** @brief Guard time value */
    static const uint32_t USARTx_GTPR_PSC_MASK          = 0x000000FFU;   /** @brief Prescaler value */
    static const uint32_t USARTx_RTOR_BLEN_MASK         = 0xFF000000U;   /** @brief Block length */
    static const uint32_t USARTx_RTOR_RTO_MASK          = 0x00FFFFFFU;   /** @brief Receiver timeout value */
    static const uint32_t USARTx_RQR_TXFRQ_MASK         = 0x00000010U;   /** @brief Transmit data flush request */
    static const uint32_t USARTx_RQR_RXFRQ_MASK         = 0x00000008U;   /** @brief Receive data flush request */
    static const uint32_t USARTx_RQR_MMRQ_MASK          = 0x00000004U;   /** @brief Mute mode request */
    static const uint32_t USARTx_RQR_SBKRQ_MASK         = 0x00000002U;   /** @brief Send break request */
    static const uint32_t USARTx_RQR_ABRRQ_MASK         = 0x00000001U;   /** @brief Auto baud rate request */
    static const uint32_t USARTx_ISR_TXFT_MASK          = 0x08000000U;   /** @brief TXFIFO threshold flag */
    static const uint32_t USARTx_ISR_RXFT_MASK          = 0x04000000U;   /** @brief RXFIFO threshold flag */
    static const uint32_t USARTx_ISR_TCBGT_MASK         = 0x02000000U;   /** @brief Transmission complete before guard time flag */
    static const uint32_t USARTx_ISR_RXFF_MASK          = 0x01000000U;   /** @brief RXFIFO full */
    static const uint32_t USARTx_ISR_TXFE_MASK          = 0x00800000U;   /** @brief TXFIFO empty */
    static const uint32_t USARTx_ISR_REACK_MASK         = 0x00400000U;   /** @brief REACK */
    static const uint32_t USARTx_ISR_TEACK_MASK         = 0x00200000U;   /** @brief TEACK */
    static const uint32_t USARTx_ISR_WUF_MASK           = 0x00100000U;   /** @brief WUF */
    static const uint32_t USARTx_ISR_RWU_MASK           = 0x00080000U;   /** @brief RWU */
    static const uint32_t USARTx_ISR_SBKF_MASK          = 0x00040000U;   /** @brief SBKF */
    static const uint32_t USARTx_ISR_CMF_MASK           = 0x00020000U;   /** @brief CMF */
    static const uint32_t USARTx_ISR_BUSY_MASK          = 0x00010000U;   /** @brief BUSY */
    static const uint32_t USARTx_ISR_ABRF_MASK          = 0x00008000U;   /** @brief ABRF */
    static const uint32_t USARTx_ISR_ABRE_MASK          = 0x00004000U;   /** @brief ABRE */
    static const uint32_t USARTx_ISR_UDR_MASK           = 0x00002000U;   /** @brief SPI slave underrun error flag */
    static const uint32_t USARTx_ISR_EOBF_MASK          = 0x00001000U;   /** @brief EOBF */
    static const uint32_t USARTx_ISR_RTOF_MASK          = 0x00000800U;   /** @brief RTOF */
    static const uint32_t USARTx_ISR_CTS_MASK           = 0x00000400U;   /** @brief CTS */
    static const uint32_t USARTx_ISR_CTSIF_MASK         = 0x00000200U;   /** @brief CTSIF */
    static const uint32_t USARTx_ISR_LBDF_MASK          = 0x00000100U;   /** @brief LBDF */
    static const uint32_t USARTx_ISR_TXE_MASK           = 0x00000080U;   /** @brief TXE */
    static const uint32_t USARTx_ISR_TC_MASK            = 0x00000040U;   /** @brief TC */
    static const uint32_t USARTx_ISR_RXNE_MASK          = 0x00000020U;   /** @brief RXNE */
    static const uint32_t USARTx_ISR_IDLE_MASK          = 0x00000010U;   /** @brief IDLE */
    static const uint32_t USARTx_ISR_ORE_MASK           = 0x00000008U;   /** @brief ORE */
    static const uint32_t USARTx_ISR_NF_MASK            = 0x00000004U;   /** @brief NF */
    static const uint32_t USARTx_ISR_FE_MASK            = 0x00000002U;   /** @brief FE */
    static const uint32_t USARTx_ISR_PE_MASK            = 0x00000001U;   /** @brief PE */
    static const uint32_t USARTx_ICR_WUCF_MASK          = 0x00100000U;   /** @brief Wakeup from stop mode clear flag */
    static const uint32_t USARTx_ICR_CMCF_MASK          = 0x00020000U;   /** @brief Character match clear flag */
    static const uint32_t USARTx_ICR_UDRCF_MASK         = 0x00002000U;   /** @brief SPI slave underrun clear flag */
    static const uint32_t USARTx_ICR_EOBCF_MASK         = 0x00001000U;   /** @brief End of block clear flag */
    static const uint32_t USARTx_ICR_RTOCF_MASK         = 0x00000800U;   /** @brief Receiver timeout clear flag */
    static const uint32_t USARTx_ICR_CTSCF_MASK         = 0x00000200U;   /** @brief CTS clear flag */
    static const uint32_t USARTx_ICR_LBDCF_MASK         = 0x00000100U;   /** @brief LIN break detection clear flag */
    static const uint32_t USARTx_ICR_TCBGTC_MASK        = 0x00000080U;   /** @brief Transmission complete before guard time clear flag */
    static const uint32_t USARTx_ICR_TCCF_MASK          = 0x00000040U;   /** @brief Transmission complete clear flag */
    static const uint32_t USARTx_ICR_TXFECF_MASK        = 0x00000020U;   /** @brief TXFIFO empty clear flag */
    static const uint32_t USARTx_ICR_IDLECF_MASK        = 0x00000010U;   /** @brief Idle line detected clear flag */
    static const uint32_t USARTx_ICR_ORECF_MASK         = 0x00000008U;   /** @brief Overrun error clear flag */
    static const uint32_t USARTx_ICR_NCF_MASK           = 0x00000004U;   /** @brief Noise detected clear flag */
    static const uint32_t USARTx_ICR_FECF_MASK          = 0x00000002U;   /** @brief Framing error clear flag */
    static const uint32_t USARTx_ICR_PECF_MASK          = 0x00000001U;   /** @brief Parity error clear flag */
    static const uint32_t USARTx_RDR_RDR_MASK           = 0x000001FFU;   /** @brief Receive data value */
    static const uint32_t USARTx_TDR_TDR_MASK           = 0x000001FFU;   /** @brief Transmit data value */
    static const uint32_t USARTx_PRESC_PRESCALER_MASK   = 0x0000000FU;   /** @brief Clock prescaler */

    /**** @subsection Enumerated USARTx Register Field Masks ****/

    static const uint32_t USARTx_CR1_Mx_MASK[2] = {
      [0] = 0x00001000U,   /** @brief Word length */
      [1] = 0x10000000U,   /** @brief Word length */
    };

    static const uint32_t USARTx_CR1_DEATx_MASK[5] = {
      [0] = 0x00200000U,   /** @brief DEAT0 */
      [1] = 0x00400000U,   /** @brief DEAT1 */
      [2] = 0x00800000U,   /** @brief DEAT2 */
      [3] = 0x01000000U,   /** @brief DEAT3 */
      [4] = 0x02000000U,   /** @brief Driver enable assertion time */
    };

    static const uint32_t USARTx_CR1_DEDTx_MASK[5] = {
      [0] = 0x00010000U,   /** @brief DEDT0 */
      [1] = 0x00020000U,   /** @brief DEDT1 */
      [2] = 0x00040000U,   /** @brief DEDT2 */
      [3] = 0x00080000U,   /** @brief DEDT3 */
      [4] = 0x00100000U,   /** @brief Driver enable de-assertion time */
    };

    static const uint32_t USARTx_CR2_ABRMODx_MASK[2] = {
      [0] = 0x00200000U,   /** @brief ABRMOD0 */
      [1] = 0x00400000U,   /** @brief Auto baud rate mode */
    };

    /**** @subsection USARTx Register Field Positions ****/

    static const int32_t USARTx_CR1_RXFFIE_POS        = 31;   /** @brief RXFIFO full interrupt enable */
    static const int32_t USARTx_CR1_TXFEIE_POS        = 30;   /** @brief TXFIFO empty interrupt enable */
    static const int32_t USARTx_CR1_FIFOEN_POS        = 29;   /** @brief FIFO mode enable */
    static const int32_t USARTx_CR1_EOBIE_POS         = 27;   /** @brief End of block interrupt enable */
    static const int32_t USARTx_CR1_RTOIE_POS         = 26;   /** @brief Receiver timeout interrupt enable */
    static const int32_t USARTx_CR1_OVER8_POS         = 15;   /** @brief Oversampling mode */
    static const int32_t USARTx_CR1_CMIE_POS          = 14;   /** @brief Character match interrupt enable */
    static const int32_t USARTx_CR1_MME_POS           = 13;   /** @brief Mute mode enable */
    static const int32_t USARTx_CR1_WAKE_POS          = 11;   /** @brief Receiver wakeup method */
    static const int32_t USARTx_CR1_PCE_POS           = 10;   /** @brief Parity control enable */
    static const int32_t USARTx_CR1_PS_POS            = 9;    /** @brief Parity selection */
    static const int32_t USARTx_CR1_PEIE_POS          = 8;    /** @brief PE interrupt enable */
    static const int32_t USARTx_CR1_TXEIE_POS         = 7;    /** @brief Interrupt enable */
    static const int32_t USARTx_CR1_TCIE_POS          = 6;    /** @brief Transmission complete interrupt enable */
    static const int32_t USARTx_CR1_RXNEIE_POS        = 5;    /** @brief RXNE interrupt enable */
    static const int32_t USARTx_CR1_IDLEIE_POS        = 4;    /** @brief IDLE interrupt enable */
    static const int32_t USARTx_CR1_TE_POS            = 3;    /** @brief Transmitter enable */
    static const int32_t USARTx_CR1_RE_POS            = 2;    /** @brief Receiver enable */
    static const int32_t USARTx_CR1_UESM_POS          = 1;    /** @brief USART enable in stop mode */
    static const int32_t USARTx_CR1_UE_POS            = 0;    /** @brief USART enable */
    static const int32_t USARTx_CR2_ADD4_7_POS        = 28;   /** @brief Address of the USART node */
    static const int32_t USARTx_CR2_ADD0_3_POS        = 24;   /** @brief Address of the USART node */
    static const int32_t USARTx_CR2_RTOEN_POS         = 23;   /** @brief Receiver timeout enable */
    static const int32_t USARTx_CR2_ABREN_POS         = 20;   /** @brief Auto baud rate enable */
    static const int32_t USARTx_CR2_MSBFIRST_POS      = 19;   /** @brief Most significant bit first */
    static const int32_t USARTx_CR2_TAINV_POS         = 18;   /** @brief Binary data inversion */
    static const int32_t USARTx_CR2_TXINV_POS         = 17;   /** @brief TX pin active level inversion */
    static const int32_t USARTx_CR2_RXINV_POS         = 16;   /** @brief RX pin active level inversion */
    static const int32_t USARTx_CR2_SWAP_POS          = 15;   /** @brief Swap TX/RX pins */
    static const int32_t USARTx_CR2_LINEN_POS         = 14;   /** @brief LIN mode enable */
    static const int32_t USARTx_CR2_STOP_POS          = 12;   /** @brief STOP bits */
    static const int32_t USARTx_CR2_CLKEN_POS         = 11;   /** @brief Clock enable */
    static const int32_t USARTx_CR2_CPOL_POS          = 10;   /** @brief Clock polarity */
    static const int32_t USARTx_CR2_CPHA_POS          = 9;    /** @brief Clock phase */
    static const int32_t USARTx_CR2_LBCL_POS          = 8;    /** @brief Last bit clock pulse */
    static const int32_t USARTx_CR2_LBDIE_POS         = 6;    /** @brief LIN break detection interrupt enable */
    static const int32_t USARTx_CR2_LBDL_POS          = 5;    /** @brief LIN break detection length */
    static const int32_t USARTx_CR2_ADDM7_POS         = 4;    /** @brief 7-bit address detection/4-bit address detection */
    static const int32_t USARTx_CR2_DIS_NSS_POS       = 3;    /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const int32_t USARTx_CR2_SLVEN_POS         = 0;    /** @brief Synchronous slave mode enable */
    static const int32_t USARTx_CR3_TXFTCFG_POS       = 29;   /** @brief TXFIFO threshold configuration */
    static const int32_t USARTx_CR3_RXFTIE_POS        = 28;   /** @brief RXFIFO threshold interrupt enable */
    static const int32_t USARTx_CR3_RXFTCFG_POS       = 25;   /** @brief Receive FIFO threshold configuration */
    static const int32_t USARTx_CR3_TCBGTIE_POS       = 24;   /** @brief Transmission complete before guard time, interrupt enable */
    static const int32_t USARTx_CR3_TXFTIE_POS        = 23;   /** @brief TXFIFO threshold interrupt enable */
    static const int32_t USARTx_CR3_WUFIE_POS         = 22;   /** @brief Wakeup from stop mode interrupt enable */
    static const int32_t USARTx_CR3_WUS_POS           = 20;   /** @brief Wakeup from stop mode interrupt flag selection */
    static const int32_t USARTx_CR3_SCARCNT_POS       = 17;   /** @brief Smartcard auto-retry count */
    static const int32_t USARTx_CR3_DEP_POS           = 15;   /** @brief Driver enable polarity selection */
    static const int32_t USARTx_CR3_DEM_POS           = 14;   /** @brief Driver enable mode */
    static const int32_t USARTx_CR3_DDRE_POS          = 13;   /** @brief DMA disable on reception error */
    static const int32_t USARTx_CR3_OVRDIS_POS        = 12;   /** @brief Overrun disable */
    static const int32_t USARTx_CR3_ONEBIT_POS        = 11;   /** @brief One sample bit method enable */
    static const int32_t USARTx_CR3_CTSIE_POS         = 10;   /** @brief CTS interrupt enable */
    static const int32_t USARTx_CR3_CTSE_POS          = 9;    /** @brief CTS enable */
    static const int32_t USARTx_CR3_RTSE_POS          = 8;    /** @brief RTS enable */
    static const int32_t USARTx_CR3_DMAT_POS          = 7;    /** @brief DMA enable transmitter */
    static const int32_t USARTx_CR3_DMAR_POS          = 6;    /** @brief DMA enable receiver */
    static const int32_t USARTx_CR3_SCEN_POS          = 5;    /** @brief Smartcard mode enable */
    static const int32_t USARTx_CR3_NACK_POS          = 4;    /** @brief Smartcard NACK enable */
    static const int32_t USARTx_CR3_HDSEL_POS         = 3;    /** @brief Half-duplex selection */
    static const int32_t USARTx_CR3_IRLP_POS          = 2;    /** @brief Ir low-power */
    static const int32_t USARTx_CR3_IREN_POS          = 1;    /** @brief Ir mode enable */
    static const int32_t USARTx_CR3_EIE_POS           = 0;    /** @brief Error interrupt enable */
    static const int32_t USARTx_BRR_BRR_4_15_POS      = 4;    /** @brief DIV_Mantissa */
    static const int32_t USARTx_BRR_BRR_0_3_POS       = 0;    /** @brief DIV_Fraction */
    static const int32_t USARTx_GTPR_GT_POS           = 8;    /** @brief Guard time value */
    static const int32_t USARTx_GTPR_PSC_POS          = 0;    /** @brief Prescaler value */
    static const int32_t USARTx_RTOR_BLEN_POS         = 24;   /** @brief Block length */
    static const int32_t USARTx_RTOR_RTO_POS          = 0;    /** @brief Receiver timeout value */
    static const int32_t USARTx_RQR_TXFRQ_POS         = 4;    /** @brief Transmit data flush request */
    static const int32_t USARTx_RQR_RXFRQ_POS         = 3;    /** @brief Receive data flush request */
    static const int32_t USARTx_RQR_MMRQ_POS          = 2;    /** @brief Mute mode request */
    static const int32_t USARTx_RQR_SBKRQ_POS         = 1;    /** @brief Send break request */
    static const int32_t USARTx_RQR_ABRRQ_POS         = 0;    /** @brief Auto baud rate request */
    static const int32_t USARTx_ISR_TXFT_POS          = 27;   /** @brief TXFIFO threshold flag */
    static const int32_t USARTx_ISR_RXFT_POS          = 26;   /** @brief RXFIFO threshold flag */
    static const int32_t USARTx_ISR_TCBGT_POS         = 25;   /** @brief Transmission complete before guard time flag */
    static const int32_t USARTx_ISR_RXFF_POS          = 24;   /** @brief RXFIFO full */
    static const int32_t USARTx_ISR_TXFE_POS          = 23;   /** @brief TXFIFO empty */
    static const int32_t USARTx_ISR_REACK_POS         = 22;   /** @brief REACK */
    static const int32_t USARTx_ISR_TEACK_POS         = 21;   /** @brief TEACK */
    static const int32_t USARTx_ISR_WUF_POS           = 20;   /** @brief WUF */
    static const int32_t USARTx_ISR_RWU_POS           = 19;   /** @brief RWU */
    static const int32_t USARTx_ISR_SBKF_POS          = 18;   /** @brief SBKF */
    static const int32_t USARTx_ISR_CMF_POS           = 17;   /** @brief CMF */
    static const int32_t USARTx_ISR_BUSY_POS          = 16;   /** @brief BUSY */
    static const int32_t USARTx_ISR_ABRF_POS          = 15;   /** @brief ABRF */
    static const int32_t USARTx_ISR_ABRE_POS          = 14;   /** @brief ABRE */
    static const int32_t USARTx_ISR_UDR_POS           = 13;   /** @brief SPI slave underrun error flag */
    static const int32_t USARTx_ISR_EOBF_POS          = 12;   /** @brief EOBF */
    static const int32_t USARTx_ISR_RTOF_POS          = 11;   /** @brief RTOF */
    static const int32_t USARTx_ISR_CTS_POS           = 10;   /** @brief CTS */
    static const int32_t USARTx_ISR_CTSIF_POS         = 9;    /** @brief CTSIF */
    static const int32_t USARTx_ISR_LBDF_POS          = 8;    /** @brief LBDF */
    static const int32_t USARTx_ISR_TXE_POS           = 7;    /** @brief TXE */
    static const int32_t USARTx_ISR_TC_POS            = 6;    /** @brief TC */
    static const int32_t USARTx_ISR_RXNE_POS          = 5;    /** @brief RXNE */
    static const int32_t USARTx_ISR_IDLE_POS          = 4;    /** @brief IDLE */
    static const int32_t USARTx_ISR_ORE_POS           = 3;    /** @brief ORE */
    static const int32_t USARTx_ISR_NF_POS            = 2;    /** @brief NF */
    static const int32_t USARTx_ISR_FE_POS            = 1;    /** @brief FE */
    static const int32_t USARTx_ISR_PE_POS            = 0;    /** @brief PE */
    static const int32_t USARTx_ICR_WUCF_POS          = 20;   /** @brief Wakeup from stop mode clear flag */
    static const int32_t USARTx_ICR_CMCF_POS          = 17;   /** @brief Character match clear flag */
    static const int32_t USARTx_ICR_UDRCF_POS         = 13;   /** @brief SPI slave underrun clear flag */
    static const int32_t USARTx_ICR_EOBCF_POS         = 12;   /** @brief End of block clear flag */
    static const int32_t USARTx_ICR_RTOCF_POS         = 11;   /** @brief Receiver timeout clear flag */
    static const int32_t USARTx_ICR_CTSCF_POS         = 9;    /** @brief CTS clear flag */
    static const int32_t USARTx_ICR_LBDCF_POS         = 8;    /** @brief LIN break detection clear flag */
    static const int32_t USARTx_ICR_TCBGTC_POS        = 7;    /** @brief Transmission complete before guard time clear flag */
    static const int32_t USARTx_ICR_TCCF_POS          = 6;    /** @brief Transmission complete clear flag */
    static const int32_t USARTx_ICR_TXFECF_POS        = 5;    /** @brief TXFIFO empty clear flag */
    static const int32_t USARTx_ICR_IDLECF_POS        = 4;    /** @brief Idle line detected clear flag */
    static const int32_t USARTx_ICR_ORECF_POS         = 3;    /** @brief Overrun error clear flag */
    static const int32_t USARTx_ICR_NCF_POS           = 2;    /** @brief Noise detected clear flag */
    static const int32_t USARTx_ICR_FECF_POS          = 1;    /** @brief Framing error clear flag */
    static const int32_t USARTx_ICR_PECF_POS          = 0;    /** @brief Parity error clear flag */
    static const int32_t USARTx_RDR_RDR_POS           = 0;    /** @brief Receive data value */
    static const int32_t USARTx_TDR_TDR_POS           = 0;    /** @brief Transmit data value */
    static const int32_t USARTx_PRESC_PRESCALER_POS   = 0;    /** @brief Clock prescaler */

    /**** @subsection Enumerated USARTx Register Field Positions ****/

    static const int32_t USARTx_CR1_Mx_POS[2] = {
      [0] = 12,   /** @brief Word length */
      [1] = 28,   /** @brief Word length */
    };

    static const int32_t USARTx_CR1_DEATx_POS[5] = {
      [0] = 21,   /** @brief DEAT0 */
      [1] = 22,   /** @brief DEAT1 */
      [2] = 23,   /** @brief DEAT2 */
      [3] = 24,   /** @brief DEAT3 */
      [4] = 25,   /** @brief Driver enable assertion time */
    };

    static const int32_t USARTx_CR1_DEDTx_POS[5] = {
      [0] = 16,   /** @brief DEDT0 */
      [1] = 17,   /** @brief DEDT1 */
      [2] = 18,   /** @brief DEDT2 */
      [3] = 19,   /** @brief DEDT3 */
      [4] = 20,   /** @brief Driver enable de-assertion time */
    };

    static const int32_t USARTx_CR2_ABRMODx_POS[2] = {
      [0] = 21,   /** @brief ABRMOD0 */
      [1] = 22,   /** @brief Auto baud rate mode */
    };

    /**********************************************************************************************
     * @section UARTx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated UARTx Register Pointers ****/

    static RW_ uint32_t* const UARTx_CR1_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C00U,   /** @brief Control register 1 */
      [5] = (RW_ uint32_t* const)0x40005000U,   /** @brief Control register 1 */
      [7] = (RW_ uint32_t* const)0x40007800U,   /** @brief Control register 1 */
      [8] = (RW_ uint32_t* const)0x40007C00U,   /** @brief Control register 1 */
    };

    static RW_ uint32_t* const UARTx_CR2_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C04U,   /** @brief Control register 2 */
      [5] = (RW_ uint32_t* const)0x40005004U,   /** @brief Control register 2 */
      [7] = (RW_ uint32_t* const)0x40007804U,   /** @brief Control register 2 */
      [8] = (RW_ uint32_t* const)0x40007C04U,   /** @brief Control register 2 */
    };

    static RW_ uint32_t* const UARTx_CR3_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C08U,   /** @brief Control register 3 */
      [5] = (RW_ uint32_t* const)0x40005008U,   /** @brief Control register 3 */
      [7] = (RW_ uint32_t* const)0x40007808U,   /** @brief Control register 3 */
      [8] = (RW_ uint32_t* const)0x40007C08U,   /** @brief Control register 3 */
    };

    static RW_ uint32_t* const UARTx_BRR_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C0CU,   /** @brief Baud rate register */
      [5] = (RW_ uint32_t* const)0x4000500CU,   /** @brief Baud rate register */
      [7] = (RW_ uint32_t* const)0x4000780CU,   /** @brief Baud rate register */
      [8] = (RW_ uint32_t* const)0x40007C0CU,   /** @brief Baud rate register */
    };

    static RW_ uint32_t* const UARTx_GTPR_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C10U,   /** @brief Guard time and prescaler register */
      [5] = (RW_ uint32_t* const)0x40005010U,   /** @brief Guard time and prescaler register */
      [7] = (RW_ uint32_t* const)0x40007810U,   /** @brief Guard time and prescaler register */
      [8] = (RW_ uint32_t* const)0x40007C10U,   /** @brief Guard time and prescaler register */
    };

    static RW_ uint32_t* const UARTx_RTOR_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C14U,   /** @brief Receiver timeout register */
      [5] = (RW_ uint32_t* const)0x40005014U,   /** @brief Receiver timeout register */
      [7] = (RW_ uint32_t* const)0x40007814U,   /** @brief Receiver timeout register */
      [8] = (RW_ uint32_t* const)0x40007C14U,   /** @brief Receiver timeout register */
    };

    static RW_ uint32_t* const UARTx_RQR_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C18U,   /** @brief Request register */
      [5] = (RW_ uint32_t* const)0x40005018U,   /** @brief Request register */
      [7] = (RW_ uint32_t* const)0x40007818U,   /** @brief Request register */
      [8] = (RW_ uint32_t* const)0x40007C18U,   /** @brief Request register */
    };

    static RO_ uint32_t* const UARTx_ISR_PTR[9] = {
      [4] = (RO_ uint32_t* const)0x40004C1CU,   /** @brief Interrupt & status register */
      [5] = (RO_ uint32_t* const)0x4000501CU,   /** @brief Interrupt & status register */
      [7] = (RO_ uint32_t* const)0x4000781CU,   /** @brief Interrupt & status register */
      [8] = (RO_ uint32_t* const)0x40007C1CU,   /** @brief Interrupt & status register */
    };

    static RW_ uint32_t* const UARTx_ICR_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C20U,   /** @brief Interrupt flag clear register */
      [5] = (RW_ uint32_t* const)0x40005020U,   /** @brief Interrupt flag clear register */
      [7] = (RW_ uint32_t* const)0x40007820U,   /** @brief Interrupt flag clear register */
      [8] = (RW_ uint32_t* const)0x40007C20U,   /** @brief Interrupt flag clear register */
    };

    static RO_ uint32_t* const UARTx_RDR_PTR[9] = {
      [4] = (RO_ uint32_t* const)0x40004C24U,   /** @brief Receive data register */
      [5] = (RO_ uint32_t* const)0x40005024U,   /** @brief Receive data register */
      [7] = (RO_ uint32_t* const)0x40007824U,   /** @brief Receive data register */
      [8] = (RO_ uint32_t* const)0x40007C24U,   /** @brief Receive data register */
    };

    static RW_ uint32_t* const UARTx_TDR_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C28U,   /** @brief Transmit data register */
      [5] = (RW_ uint32_t* const)0x40005028U,   /** @brief Transmit data register */
      [7] = (RW_ uint32_t* const)0x40007828U,   /** @brief Transmit data register */
      [8] = (RW_ uint32_t* const)0x40007C28U,   /** @brief Transmit data register */
    };

    static RW_ uint32_t* const UARTx_PRESC_PTR[9] = {
      [4] = (RW_ uint32_t* const)0x40004C2CU,   /** @brief USART prescaler register */
      [5] = (RW_ uint32_t* const)0x4000502CU,   /** @brief USART prescaler register */
      [7] = (RW_ uint32_t* const)0x4000782CU,   /** @brief USART prescaler register */
      [8] = (RW_ uint32_t* const)0x40007C2CU,   /** @brief USART prescaler register */
    };

    /**** @subsection Enumerated UARTx Register Reset Values ****/

    static const uint32_t UARTx_CR1_RST[9] = {
      [4] = 0x00000000U,   /** @brief CR1 register reset value */
      [5] = 0x00000000U,   /** @brief CR1 register reset value */
      [7] = 0x00000000U,   /** @brief CR1 register reset value */
      [8] = 0x00000000U,   /** @brief CR1 register reset value */
    };

    static const uint32_t UARTx_CR2_RST[9] = {
      [4] = 0x00000000U,   /** @brief CR2 register reset value */
      [5] = 0x00000000U,   /** @brief CR2 register reset value */
      [7] = 0x00000000U,   /** @brief CR2 register reset value */
      [8] = 0x00000000U,   /** @brief CR2 register reset value */
    };

    static const uint32_t UARTx_CR3_RST[9] = {
      [4] = 0x00000000U,   /** @brief CR3 register reset value */
      [5] = 0x00000000U,   /** @brief CR3 register reset value */
      [7] = 0x00000000U,   /** @brief CR3 register reset value */
      [8] = 0x00000000U,   /** @brief CR3 register reset value */
    };

    static const uint32_t UARTx_BRR_RST[9] = {
      [4] = 0x00000000U,   /** @brief BRR register reset value */
      [5] = 0x00000000U,   /** @brief BRR register reset value */
      [7] = 0x00000000U,   /** @brief BRR register reset value */
      [8] = 0x00000000U,   /** @brief BRR register reset value */
    };

    static const uint32_t UARTx_GTPR_RST[9] = {
      [4] = 0x00000000U,   /** @brief GTPR register reset value */
      [5] = 0x00000000U,   /** @brief GTPR register reset value */
      [7] = 0x00000000U,   /** @brief GTPR register reset value */
      [8] = 0x00000000U,   /** @brief GTPR register reset value */
    };

    static const uint32_t UARTx_RTOR_RST[9] = {
      [4] = 0x00000000U,   /** @brief RTOR register reset value */
      [5] = 0x00000000U,   /** @brief RTOR register reset value */
      [7] = 0x00000000U,   /** @brief RTOR register reset value */
      [8] = 0x00000000U,   /** @brief RTOR register reset value */
    };

    static const uint32_t UARTx_RQR_RST[9] = {
      [4] = 0x00000000U,   /** @brief RQR register reset value */
      [5] = 0x00000000U,   /** @brief RQR register reset value */
      [7] = 0x00000000U,   /** @brief RQR register reset value */
      [8] = 0x00000000U,   /** @brief RQR register reset value */
    };

    static const uint32_t UARTx_ISR_RST[9] = {
      [4] = 0x000000C0U,   /** @brief ISR register reset value */
      [5] = 0x000000C0U,   /** @brief ISR register reset value */
      [7] = 0x000000C0U,   /** @brief ISR register reset value */
      [8] = 0x000000C0U,   /** @brief ISR register reset value */
    };

    static const uint32_t UARTx_ICR_RST[9] = {
      [4] = 0x00000000U,   /** @brief ICR register reset value */
      [5] = 0x00000000U,   /** @brief ICR register reset value */
      [7] = 0x00000000U,   /** @brief ICR register reset value */
      [8] = 0x00000000U,   /** @brief ICR register reset value */
    };

    static const uint32_t UARTx_RDR_RST[9] = {
      [4] = 0x00000000U,   /** @brief RDR register reset value */
      [5] = 0x00000000U,   /** @brief RDR register reset value */
      [7] = 0x00000000U,   /** @brief RDR register reset value */
      [8] = 0x00000000U,   /** @brief RDR register reset value */
    };

    static const uint32_t UARTx_TDR_RST[9] = {
      [4] = 0x00000000U,   /** @brief TDR register reset value */
      [5] = 0x00000000U,   /** @brief TDR register reset value */
      [7] = 0x00000000U,   /** @brief TDR register reset value */
      [8] = 0x00000000U,   /** @brief TDR register reset value */
    };

    static const uint32_t UARTx_PRESC_RST[9] = {
      [4] = 0x00000000U,   /** @brief PRESC register reset value */
      [5] = 0x00000000U,   /** @brief PRESC register reset value */
      [7] = 0x00000000U,   /** @brief PRESC register reset value */
      [8] = 0x00000000U,   /** @brief PRESC register reset value */
    };

    /**** @subsection Enumerated UARTx Register Value Types ****/

    typedef uint32_t UARTx_CR1_t;     /** @brief CR1 register value type. */
    typedef uint32_t UARTx_CR2_t;     /** @brief CR2 register value type. */
    typedef uint32_t UARTx_CR3_t;     /** @brief CR3 register value type. */
    typedef uint32_t UARTx_BRR_t;     /** @brief BRR register value type. */
    typedef uint32_t UARTx_GTPR_t;    /** @brief GTPR register value type. */
    typedef uint32_t UARTx_RTOR_t;    /** @brief RTOR register value type. */
    typedef uint32_t UARTx_RQR_t;     /** @brief RQR register value type. */
    typedef uint32_t UARTx_ISR_t;     /** @brief ISR register value type. */
    typedef uint32_t UARTx_ICR_t;     /** @brief ICR register value type. */
    typedef uint32_t UARTx_RDR_t;     /** @brief RDR register value type. */
    typedef uint32_t UARTx_TDR_t;     /** @brief TDR register value type. */
    typedef uint32_t UARTx_PRESC_t;   /** @brief PRESC register value type. */

    /**** @subsection Enumerated UARTx Register Pointer Types ****/

    typedef uint32_t* const UARTx_CR1_PTR_t;     /** @brief CR1 register pointer type. */
    typedef uint32_t* const UARTx_CR2_PTR_t;     /** @brief CR2 register pointer type. */
    typedef uint32_t* const UARTx_CR3_PTR_t;     /** @brief CR3 register pointer type. */
    typedef uint32_t* const UARTx_BRR_PTR_t;     /** @brief BRR register pointer type. */
    typedef uint32_t* const UARTx_GTPR_PTR_t;    /** @brief GTPR register pointer type. */
    typedef uint32_t* const UARTx_RTOR_PTR_t;    /** @brief RTOR register pointer type. */
    typedef uint32_t* const UARTx_RQR_PTR_t;     /** @brief RQR register pointer type. */
    typedef uint32_t* const UARTx_ISR_PTR_t;     /** @brief ISR register pointer type. */
    typedef uint32_t* const UARTx_ICR_PTR_t;     /** @brief ICR register pointer type. */
    typedef uint32_t* const UARTx_RDR_PTR_t;     /** @brief RDR register pointer type. */
    typedef uint32_t* const UARTx_TDR_PTR_t;     /** @brief TDR register pointer type. */
    typedef uint32_t* const UARTx_PRESC_PTR_t;   /** @brief PRESC register pointer type. */

    /**** @subsection UARTx Register Field Masks ****/

    static const uint32_t UARTx_CR1_RXFFIE_MASK        = 0x80000000U;   /** @brief RXFIFO full interrupt enable */
    static const uint32_t UARTx_CR1_TXFEIE_MASK        = 0x40000000U;   /** @brief TXFIFO empty interrupt enable */
    static const uint32_t UARTx_CR1_FIFOEN_MASK        = 0x20000000U;   /** @brief FIFO mode enable */
    static const uint32_t UARTx_CR1_EOBIE_MASK         = 0x08000000U;   /** @brief End of block interrupt enable */
    static const uint32_t UARTx_CR1_RTOIE_MASK         = 0x04000000U;   /** @brief Receiver timeout interrupt enable */
    static const uint32_t UARTx_CR1_OVER8_MASK         = 0x00008000U;   /** @brief Oversampling mode */
    static const uint32_t UARTx_CR1_CMIE_MASK          = 0x00004000U;   /** @brief Character match interrupt enable */
    static const uint32_t UARTx_CR1_MME_MASK           = 0x00002000U;   /** @brief Mute mode enable */
    static const uint32_t UARTx_CR1_WAKE_MASK          = 0x00000800U;   /** @brief Receiver wakeup method */
    static const uint32_t UARTx_CR1_PCE_MASK           = 0x00000400U;   /** @brief Parity control enable */
    static const uint32_t UARTx_CR1_PS_MASK            = 0x00000200U;   /** @brief Parity selection */
    static const uint32_t UARTx_CR1_PEIE_MASK          = 0x00000100U;   /** @brief PE interrupt enable */
    static const uint32_t UARTx_CR1_TXEIE_MASK         = 0x00000080U;   /** @brief Interrupt enable */
    static const uint32_t UARTx_CR1_TCIE_MASK          = 0x00000040U;   /** @brief Transmission complete interrupt enable */
    static const uint32_t UARTx_CR1_RXNEIE_MASK        = 0x00000020U;   /** @brief RXNE interrupt enable */
    static const uint32_t UARTx_CR1_IDLEIE_MASK        = 0x00000010U;   /** @brief IDLE interrupt enable */
    static const uint32_t UARTx_CR1_TE_MASK            = 0x00000008U;   /** @brief Transmitter enable */
    static const uint32_t UARTx_CR1_RE_MASK            = 0x00000004U;   /** @brief Receiver enable */
    static const uint32_t UARTx_CR1_UESM_MASK          = 0x00000002U;   /** @brief USART enable in stop mode */
    static const uint32_t UARTx_CR1_UE_MASK            = 0x00000001U;   /** @brief USART enable */
    static const uint32_t UARTx_CR2_ADD4_7_MASK        = 0xF0000000U;   /** @brief Address of the USART node */
    static const uint32_t UARTx_CR2_ADD0_3_MASK        = 0x0F000000U;   /** @brief Address of the USART node */
    static const uint32_t UARTx_CR2_RTOEN_MASK         = 0x00800000U;   /** @brief Receiver timeout enable */
    static const uint32_t UARTx_CR2_ABREN_MASK         = 0x00100000U;   /** @brief Auto baud rate enable */
    static const uint32_t UARTx_CR2_MSBFIRST_MASK      = 0x00080000U;   /** @brief Most significant bit first */
    static const uint32_t UARTx_CR2_TAINV_MASK         = 0x00040000U;   /** @brief Binary data inversion */
    static const uint32_t UARTx_CR2_TXINV_MASK         = 0x00020000U;   /** @brief TX pin active level inversion */
    static const uint32_t UARTx_CR2_RXINV_MASK         = 0x00010000U;   /** @brief RX pin active level inversion */
    static const uint32_t UARTx_CR2_SWAP_MASK          = 0x00008000U;   /** @brief Swap TX/RX pins */
    static const uint32_t UARTx_CR2_LINEN_MASK         = 0x00004000U;   /** @brief LIN mode enable */
    static const uint32_t UARTx_CR2_STOP_MASK          = 0x00003000U;   /** @brief STOP bits */
    static const uint32_t UARTx_CR2_CLKEN_MASK         = 0x00000800U;   /** @brief Clock enable */
    static const uint32_t UARTx_CR2_CPOL_MASK          = 0x00000400U;   /** @brief Clock polarity */
    static const uint32_t UARTx_CR2_CPHA_MASK          = 0x00000200U;   /** @brief Clock phase */
    static const uint32_t UARTx_CR2_LBCL_MASK          = 0x00000100U;   /** @brief Last bit clock pulse */
    static const uint32_t UARTx_CR2_LBDIE_MASK         = 0x00000040U;   /** @brief LIN break detection interrupt enable */
    static const uint32_t UARTx_CR2_LBDL_MASK          = 0x00000020U;   /** @brief LIN break detection length */
    static const uint32_t UARTx_CR2_ADDM7_MASK         = 0x00000010U;   /** @brief 7-bit address detection/4-bit address detection */
    static const uint32_t UARTx_CR2_DIS_NSS_MASK       = 0x00000008U;   /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const uint32_t UARTx_CR2_SLVEN_MASK         = 0x00000001U;   /** @brief Synchronous slave mode enable */
    static const uint32_t UARTx_CR3_TXFTCFG_MASK       = 0xE0000000U;   /** @brief TXFIFO threshold configuration */
    static const uint32_t UARTx_CR3_RXFTIE_MASK        = 0x10000000U;   /** @brief RXFIFO threshold interrupt enable */
    static const uint32_t UARTx_CR3_RXFTCFG_MASK       = 0x0E000000U;   /** @brief Receive FIFO threshold configuration */
    static const uint32_t UARTx_CR3_TCBGTIE_MASK       = 0x01000000U;   /** @brief Transmission complete before guard time, interrupt enable */
    static const uint32_t UARTx_CR3_TXFTIE_MASK        = 0x00800000U;   /** @brief TXFIFO threshold interrupt enable */
    static const uint32_t UARTx_CR3_WUFIE_MASK         = 0x00400000U;   /** @brief Wakeup from stop mode interrupt enable */
    static const uint32_t UARTx_CR3_WUS_MASK           = 0x00300000U;   /** @brief Wakeup from stop mode interrupt flag selection */
    static const uint32_t UARTx_CR3_SCARCNT_MASK       = 0x000E0000U;   /** @brief Smartcard auto-retry count */
    static const uint32_t UARTx_CR3_DEP_MASK           = 0x00008000U;   /** @brief Driver enable polarity selection */
    static const uint32_t UARTx_CR3_DEM_MASK           = 0x00004000U;   /** @brief Driver enable mode */
    static const uint32_t UARTx_CR3_DDRE_MASK          = 0x00002000U;   /** @brief DMA disable on reception error */
    static const uint32_t UARTx_CR3_OVRDIS_MASK        = 0x00001000U;   /** @brief Overrun disable */
    static const uint32_t UARTx_CR3_ONEBIT_MASK        = 0x00000800U;   /** @brief One sample bit method enable */
    static const uint32_t UARTx_CR3_CTSIE_MASK         = 0x00000400U;   /** @brief CTS interrupt enable */
    static const uint32_t UARTx_CR3_CTSE_MASK          = 0x00000200U;   /** @brief CTS enable */
    static const uint32_t UARTx_CR3_RTSE_MASK          = 0x00000100U;   /** @brief RTS enable */
    static const uint32_t UARTx_CR3_DMAT_MASK          = 0x00000080U;   /** @brief DMA enable transmitter */
    static const uint32_t UARTx_CR3_DMAR_MASK          = 0x00000040U;   /** @brief DMA enable receiver */
    static const uint32_t UARTx_CR3_SCEN_MASK          = 0x00000020U;   /** @brief Smartcard mode enable */
    static const uint32_t UARTx_CR3_NACK_MASK          = 0x00000010U;   /** @brief Smartcard NACK enable */
    static const uint32_t UARTx_CR3_HDSEL_MASK         = 0x00000008U;   /** @brief Half-duplex selection */
    static const uint32_t UARTx_CR3_IRLP_MASK          = 0x00000004U;   /** @brief Ir low-power */
    static const uint32_t UARTx_CR3_IREN_MASK          = 0x00000002U;   /** @brief Ir mode enable */
    static const uint32_t UARTx_CR3_EIE_MASK           = 0x00000001U;   /** @brief Error interrupt enable */
    static const uint32_t UARTx_BRR_BRR_4_15_MASK      = 0x0000FFF0U;   /** @brief DIV_Mantissa */
    static const uint32_t UARTx_BRR_BRR_0_3_MASK       = 0x0000000FU;   /** @brief DIV_Fraction */
    static const uint32_t UARTx_GTPR_GT_MASK           = 0x0000FF00U;   /** @brief Guard time value */
    static const uint32_t UARTx_GTPR_PSC_MASK          = 0x000000FFU;   /** @brief Prescaler value */
    static const uint32_t UARTx_RTOR_BLEN_MASK         = 0xFF000000U;   /** @brief Block length */
    static const uint32_t UARTx_RTOR_RTO_MASK          = 0x00FFFFFFU;   /** @brief Receiver timeout value */
    static const uint32_t UARTx_RQR_TXFRQ_MASK         = 0x00000010U;   /** @brief Transmit data flush request */
    static const uint32_t UARTx_RQR_RXFRQ_MASK         = 0x00000008U;   /** @brief Receive data flush request */
    static const uint32_t UARTx_RQR_MMRQ_MASK          = 0x00000004U;   /** @brief Mute mode request */
    static const uint32_t UARTx_RQR_SBKRQ_MASK         = 0x00000002U;   /** @brief Send break request */
    static const uint32_t UARTx_RQR_ABRRQ_MASK         = 0x00000001U;   /** @brief Auto baud rate request */
    static const uint32_t UARTx_ISR_TXFT_MASK          = 0x08000000U;   /** @brief TXFIFO threshold flag */
    static const uint32_t UARTx_ISR_RXFT_MASK          = 0x04000000U;   /** @brief RXFIFO threshold flag */
    static const uint32_t UARTx_ISR_TCBGT_MASK         = 0x02000000U;   /** @brief Transmission complete before guard time flag */
    static const uint32_t UARTx_ISR_RXFF_MASK          = 0x01000000U;   /** @brief RXFIFO full */
    static const uint32_t UARTx_ISR_TXFE_MASK          = 0x00800000U;   /** @brief TXFIFO empty */
    static const uint32_t UARTx_ISR_REACK_MASK         = 0x00400000U;   /** @brief REACK */
    static const uint32_t UARTx_ISR_TEACK_MASK         = 0x00200000U;   /** @brief TEACK */
    static const uint32_t UARTx_ISR_WUF_MASK           = 0x00100000U;   /** @brief WUF */
    static const uint32_t UARTx_ISR_RWU_MASK           = 0x00080000U;   /** @brief RWU */
    static const uint32_t UARTx_ISR_SBKF_MASK          = 0x00040000U;   /** @brief SBKF */
    static const uint32_t UARTx_ISR_CMF_MASK           = 0x00020000U;   /** @brief CMF */
    static const uint32_t UARTx_ISR_BUSY_MASK          = 0x00010000U;   /** @brief BUSY */
    static const uint32_t UARTx_ISR_ABRF_MASK          = 0x00008000U;   /** @brief ABRF */
    static const uint32_t UARTx_ISR_ABRE_MASK          = 0x00004000U;   /** @brief ABRE */
    static const uint32_t UARTx_ISR_UDR_MASK           = 0x00002000U;   /** @brief SPI slave underrun error flag */
    static const uint32_t UARTx_ISR_EOBF_MASK          = 0x00001000U;   /** @brief EOBF */
    static const uint32_t UARTx_ISR_RTOF_MASK          = 0x00000800U;   /** @brief RTOF */
    static const uint32_t UARTx_ISR_CTS_MASK           = 0x00000400U;   /** @brief CTS */
    static const uint32_t UARTx_ISR_CTSIF_MASK         = 0x00000200U;   /** @brief CTSIF */
    static const uint32_t UARTx_ISR_LBDF_MASK          = 0x00000100U;   /** @brief LBDF */
    static const uint32_t UARTx_ISR_TXE_MASK           = 0x00000080U;   /** @brief TXE */
    static const uint32_t UARTx_ISR_TC_MASK            = 0x00000040U;   /** @brief TC */
    static const uint32_t UARTx_ISR_RXNE_MASK          = 0x00000020U;   /** @brief RXNE */
    static const uint32_t UARTx_ISR_IDLE_MASK          = 0x00000010U;   /** @brief IDLE */
    static const uint32_t UARTx_ISR_ORE_MASK           = 0x00000008U;   /** @brief ORE */
    static const uint32_t UARTx_ISR_NF_MASK            = 0x00000004U;   /** @brief NF */
    static const uint32_t UARTx_ISR_FE_MASK            = 0x00000002U;   /** @brief FE */
    static const uint32_t UARTx_ISR_PE_MASK            = 0x00000001U;   /** @brief PE */
    static const uint32_t UARTx_ICR_WUCF_MASK          = 0x00100000U;   /** @brief Wakeup from stop mode clear flag */
    static const uint32_t UARTx_ICR_CMCF_MASK          = 0x00020000U;   /** @brief Character match clear flag */
    static const uint32_t UARTx_ICR_UDRCF_MASK         = 0x00002000U;   /** @brief SPI slave underrun clear flag */
    static const uint32_t UARTx_ICR_EOBCF_MASK         = 0x00001000U;   /** @brief End of block clear flag */
    static const uint32_t UARTx_ICR_RTOCF_MASK         = 0x00000800U;   /** @brief Receiver timeout clear flag */
    static const uint32_t UARTx_ICR_CTSCF_MASK         = 0x00000200U;   /** @brief CTS clear flag */
    static const uint32_t UARTx_ICR_LBDCF_MASK         = 0x00000100U;   /** @brief LIN break detection clear flag */
    static const uint32_t UARTx_ICR_TCBGTC_MASK        = 0x00000080U;   /** @brief Transmission complete before guard time clear flag */
    static const uint32_t UARTx_ICR_TCCF_MASK          = 0x00000040U;   /** @brief Transmission complete clear flag */
    static const uint32_t UARTx_ICR_TXFECF_MASK        = 0x00000020U;   /** @brief TXFIFO empty clear flag */
    static const uint32_t UARTx_ICR_IDLECF_MASK        = 0x00000010U;   /** @brief Idle line detected clear flag */
    static const uint32_t UARTx_ICR_ORECF_MASK         = 0x00000008U;   /** @brief Overrun error clear flag */
    static const uint32_t UARTx_ICR_NCF_MASK           = 0x00000004U;   /** @brief Noise detected clear flag */
    static const uint32_t UARTx_ICR_FECF_MASK          = 0x00000002U;   /** @brief Framing error clear flag */
    static const uint32_t UARTx_ICR_PECF_MASK          = 0x00000001U;   /** @brief Parity error clear flag */
    static const uint32_t UARTx_RDR_RDR_MASK           = 0x000001FFU;   /** @brief Receive data value */
    static const uint32_t UARTx_TDR_TDR_MASK           = 0x000001FFU;   /** @brief Transmit data value */
    static const uint32_t UARTx_PRESC_PRESCALER_MASK   = 0x0000000FU;   /** @brief Clock prescaler */

    /**** @subsection Enumerated UARTx Register Field Masks ****/

    static const uint32_t UARTx_CR1_Mx_MASK[2] = {
      [0] = 0x00001000U,   /** @brief Word length */
      [1] = 0x10000000U,   /** @brief Word length */
    };

    static const uint32_t UARTx_CR1_DEATx_MASK[5] = {
      [0] = 0x00200000U,   /** @brief DEAT0 */
      [1] = 0x00400000U,   /** @brief DEAT1 */
      [2] = 0x00800000U,   /** @brief DEAT2 */
      [3] = 0x01000000U,   /** @brief DEAT3 */
      [4] = 0x02000000U,   /** @brief Driver enable assertion time */
    };

    static const uint32_t UARTx_CR1_DEDTx_MASK[5] = {
      [0] = 0x00010000U,   /** @brief DEDT0 */
      [1] = 0x00020000U,   /** @brief DEDT1 */
      [2] = 0x00040000U,   /** @brief DEDT2 */
      [3] = 0x00080000U,   /** @brief DEDT3 */
      [4] = 0x00100000U,   /** @brief Driver enable de-assertion time */
    };

    static const uint32_t UARTx_CR2_ABRMODx_MASK[2] = {
      [0] = 0x00200000U,   /** @brief ABRMOD0 */
      [1] = 0x00400000U,   /** @brief Auto baud rate mode */
    };

    /**** @subsection UARTx Register Field Positions ****/

    static const int32_t UARTx_CR1_RXFFIE_POS        = 31;   /** @brief RXFIFO full interrupt enable */
    static const int32_t UARTx_CR1_TXFEIE_POS        = 30;   /** @brief TXFIFO empty interrupt enable */
    static const int32_t UARTx_CR1_FIFOEN_POS        = 29;   /** @brief FIFO mode enable */
    static const int32_t UARTx_CR1_EOBIE_POS         = 27;   /** @brief End of block interrupt enable */
    static const int32_t UARTx_CR1_RTOIE_POS         = 26;   /** @brief Receiver timeout interrupt enable */
    static const int32_t UARTx_CR1_OVER8_POS         = 15;   /** @brief Oversampling mode */
    static const int32_t UARTx_CR1_CMIE_POS          = 14;   /** @brief Character match interrupt enable */
    static const int32_t UARTx_CR1_MME_POS           = 13;   /** @brief Mute mode enable */
    static const int32_t UARTx_CR1_WAKE_POS          = 11;   /** @brief Receiver wakeup method */
    static const int32_t UARTx_CR1_PCE_POS           = 10;   /** @brief Parity control enable */
    static const int32_t UARTx_CR1_PS_POS            = 9;    /** @brief Parity selection */
    static const int32_t UARTx_CR1_PEIE_POS          = 8;    /** @brief PE interrupt enable */
    static const int32_t UARTx_CR1_TXEIE_POS         = 7;    /** @brief Interrupt enable */
    static const int32_t UARTx_CR1_TCIE_POS          = 6;    /** @brief Transmission complete interrupt enable */
    static const int32_t UARTx_CR1_RXNEIE_POS        = 5;    /** @brief RXNE interrupt enable */
    static const int32_t UARTx_CR1_IDLEIE_POS        = 4;    /** @brief IDLE interrupt enable */
    static const int32_t UARTx_CR1_TE_POS            = 3;    /** @brief Transmitter enable */
    static const int32_t UARTx_CR1_RE_POS            = 2;    /** @brief Receiver enable */
    static const int32_t UARTx_CR1_UESM_POS          = 1;    /** @brief USART enable in stop mode */
    static const int32_t UARTx_CR1_UE_POS            = 0;    /** @brief USART enable */
    static const int32_t UARTx_CR2_ADD4_7_POS        = 28;   /** @brief Address of the USART node */
    static const int32_t UARTx_CR2_ADD0_3_POS        = 24;   /** @brief Address of the USART node */
    static const int32_t UARTx_CR2_RTOEN_POS         = 23;   /** @brief Receiver timeout enable */
    static const int32_t UARTx_CR2_ABREN_POS         = 20;   /** @brief Auto baud rate enable */
    static const int32_t UARTx_CR2_MSBFIRST_POS      = 19;   /** @brief Most significant bit first */
    static const int32_t UARTx_CR2_TAINV_POS         = 18;   /** @brief Binary data inversion */
    static const int32_t UARTx_CR2_TXINV_POS         = 17;   /** @brief TX pin active level inversion */
    static const int32_t UARTx_CR2_RXINV_POS         = 16;   /** @brief RX pin active level inversion */
    static const int32_t UARTx_CR2_SWAP_POS          = 15;   /** @brief Swap TX/RX pins */
    static const int32_t UARTx_CR2_LINEN_POS         = 14;   /** @brief LIN mode enable */
    static const int32_t UARTx_CR2_STOP_POS          = 12;   /** @brief STOP bits */
    static const int32_t UARTx_CR2_CLKEN_POS         = 11;   /** @brief Clock enable */
    static const int32_t UARTx_CR2_CPOL_POS          = 10;   /** @brief Clock polarity */
    static const int32_t UARTx_CR2_CPHA_POS          = 9;    /** @brief Clock phase */
    static const int32_t UARTx_CR2_LBCL_POS          = 8;    /** @brief Last bit clock pulse */
    static const int32_t UARTx_CR2_LBDIE_POS         = 6;    /** @brief LIN break detection interrupt enable */
    static const int32_t UARTx_CR2_LBDL_POS          = 5;    /** @brief LIN break detection length */
    static const int32_t UARTx_CR2_ADDM7_POS         = 4;    /** @brief 7-bit address detection/4-bit address detection */
    static const int32_t UARTx_CR2_DIS_NSS_POS       = 3;    /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const int32_t UARTx_CR2_SLVEN_POS         = 0;    /** @brief Synchronous slave mode enable */
    static const int32_t UARTx_CR3_TXFTCFG_POS       = 29;   /** @brief TXFIFO threshold configuration */
    static const int32_t UARTx_CR3_RXFTIE_POS        = 28;   /** @brief RXFIFO threshold interrupt enable */
    static const int32_t UARTx_CR3_RXFTCFG_POS       = 25;   /** @brief Receive FIFO threshold configuration */
    static const int32_t UARTx_CR3_TCBGTIE_POS       = 24;   /** @brief Transmission complete before guard time, interrupt enable */
    static const int32_t UARTx_CR3_TXFTIE_POS        = 23;   /** @brief TXFIFO threshold interrupt enable */
    static const int32_t UARTx_CR3_WUFIE_POS         = 22;   /** @brief Wakeup from stop mode interrupt enable */
    static const int32_t UARTx_CR3_WUS_POS           = 20;   /** @brief Wakeup from stop mode interrupt flag selection */
    static const int32_t UARTx_CR3_SCARCNT_POS       = 17;   /** @brief Smartcard auto-retry count */
    static const int32_t UARTx_CR3_DEP_POS           = 15;   /** @brief Driver enable polarity selection */
    static const int32_t UARTx_CR3_DEM_POS           = 14;   /** @brief Driver enable mode */
    static const int32_t UARTx_CR3_DDRE_POS          = 13;   /** @brief DMA disable on reception error */
    static const int32_t UARTx_CR3_OVRDIS_POS        = 12;   /** @brief Overrun disable */
    static const int32_t UARTx_CR3_ONEBIT_POS        = 11;   /** @brief One sample bit method enable */
    static const int32_t UARTx_CR3_CTSIE_POS         = 10;   /** @brief CTS interrupt enable */
    static const int32_t UARTx_CR3_CTSE_POS          = 9;    /** @brief CTS enable */
    static const int32_t UARTx_CR3_RTSE_POS          = 8;    /** @brief RTS enable */
    static const int32_t UARTx_CR3_DMAT_POS          = 7;    /** @brief DMA enable transmitter */
    static const int32_t UARTx_CR3_DMAR_POS          = 6;    /** @brief DMA enable receiver */
    static const int32_t UARTx_CR3_SCEN_POS          = 5;    /** @brief Smartcard mode enable */
    static const int32_t UARTx_CR3_NACK_POS          = 4;    /** @brief Smartcard NACK enable */
    static const int32_t UARTx_CR3_HDSEL_POS         = 3;    /** @brief Half-duplex selection */
    static const int32_t UARTx_CR3_IRLP_POS          = 2;    /** @brief Ir low-power */
    static const int32_t UARTx_CR3_IREN_POS          = 1;    /** @brief Ir mode enable */
    static const int32_t UARTx_CR3_EIE_POS           = 0;    /** @brief Error interrupt enable */
    static const int32_t UARTx_BRR_BRR_4_15_POS      = 4;    /** @brief DIV_Mantissa */
    static const int32_t UARTx_BRR_BRR_0_3_POS       = 0;    /** @brief DIV_Fraction */
    static const int32_t UARTx_GTPR_GT_POS           = 8;    /** @brief Guard time value */
    static const int32_t UARTx_GTPR_PSC_POS          = 0;    /** @brief Prescaler value */
    static const int32_t UARTx_RTOR_BLEN_POS         = 24;   /** @brief Block length */
    static const int32_t UARTx_RTOR_RTO_POS          = 0;    /** @brief Receiver timeout value */
    static const int32_t UARTx_RQR_TXFRQ_POS         = 4;    /** @brief Transmit data flush request */
    static const int32_t UARTx_RQR_RXFRQ_POS         = 3;    /** @brief Receive data flush request */
    static const int32_t UARTx_RQR_MMRQ_POS          = 2;    /** @brief Mute mode request */
    static const int32_t UARTx_RQR_SBKRQ_POS         = 1;    /** @brief Send break request */
    static const int32_t UARTx_RQR_ABRRQ_POS         = 0;    /** @brief Auto baud rate request */
    static const int32_t UARTx_ISR_TXFT_POS          = 27;   /** @brief TXFIFO threshold flag */
    static const int32_t UARTx_ISR_RXFT_POS          = 26;   /** @brief RXFIFO threshold flag */
    static const int32_t UARTx_ISR_TCBGT_POS         = 25;   /** @brief Transmission complete before guard time flag */
    static const int32_t UARTx_ISR_RXFF_POS          = 24;   /** @brief RXFIFO full */
    static const int32_t UARTx_ISR_TXFE_POS          = 23;   /** @brief TXFIFO empty */
    static const int32_t UARTx_ISR_REACK_POS         = 22;   /** @brief REACK */
    static const int32_t UARTx_ISR_TEACK_POS         = 21;   /** @brief TEACK */
    static const int32_t UARTx_ISR_WUF_POS           = 20;   /** @brief WUF */
    static const int32_t UARTx_ISR_RWU_POS           = 19;   /** @brief RWU */
    static const int32_t UARTx_ISR_SBKF_POS          = 18;   /** @brief SBKF */
    static const int32_t UARTx_ISR_CMF_POS           = 17;   /** @brief CMF */
    static const int32_t UARTx_ISR_BUSY_POS          = 16;   /** @brief BUSY */
    static const int32_t UARTx_ISR_ABRF_POS          = 15;   /** @brief ABRF */
    static const int32_t UARTx_ISR_ABRE_POS          = 14;   /** @brief ABRE */
    static const int32_t UARTx_ISR_UDR_POS           = 13;   /** @brief SPI slave underrun error flag */
    static const int32_t UARTx_ISR_EOBF_POS          = 12;   /** @brief EOBF */
    static const int32_t UARTx_ISR_RTOF_POS          = 11;   /** @brief RTOF */
    static const int32_t UARTx_ISR_CTS_POS           = 10;   /** @brief CTS */
    static const int32_t UARTx_ISR_CTSIF_POS         = 9;    /** @brief CTSIF */
    static const int32_t UARTx_ISR_LBDF_POS          = 8;    /** @brief LBDF */
    static const int32_t UARTx_ISR_TXE_POS           = 7;    /** @brief TXE */
    static const int32_t UARTx_ISR_TC_POS            = 6;    /** @brief TC */
    static const int32_t UARTx_ISR_RXNE_POS          = 5;    /** @brief RXNE */
    static const int32_t UARTx_ISR_IDLE_POS          = 4;    /** @brief IDLE */
    static const int32_t UARTx_ISR_ORE_POS           = 3;    /** @brief ORE */
    static const int32_t UARTx_ISR_NF_POS            = 2;    /** @brief NF */
    static const int32_t UARTx_ISR_FE_POS            = 1;    /** @brief FE */
    static const int32_t UARTx_ISR_PE_POS            = 0;    /** @brief PE */
    static const int32_t UARTx_ICR_WUCF_POS          = 20;   /** @brief Wakeup from stop mode clear flag */
    static const int32_t UARTx_ICR_CMCF_POS          = 17;   /** @brief Character match clear flag */
    static const int32_t UARTx_ICR_UDRCF_POS         = 13;   /** @brief SPI slave underrun clear flag */
    static const int32_t UARTx_ICR_EOBCF_POS         = 12;   /** @brief End of block clear flag */
    static const int32_t UARTx_ICR_RTOCF_POS         = 11;   /** @brief Receiver timeout clear flag */
    static const int32_t UARTx_ICR_CTSCF_POS         = 9;    /** @brief CTS clear flag */
    static const int32_t UARTx_ICR_LBDCF_POS         = 8;    /** @brief LIN break detection clear flag */
    static const int32_t UARTx_ICR_TCBGTC_POS        = 7;    /** @brief Transmission complete before guard time clear flag */
    static const int32_t UARTx_ICR_TCCF_POS          = 6;    /** @brief Transmission complete clear flag */
    static const int32_t UARTx_ICR_TXFECF_POS        = 5;    /** @brief TXFIFO empty clear flag */
    static const int32_t UARTx_ICR_IDLECF_POS        = 4;    /** @brief Idle line detected clear flag */
    static const int32_t UARTx_ICR_ORECF_POS         = 3;    /** @brief Overrun error clear flag */
    static const int32_t UARTx_ICR_NCF_POS           = 2;    /** @brief Noise detected clear flag */
    static const int32_t UARTx_ICR_FECF_POS          = 1;    /** @brief Framing error clear flag */
    static const int32_t UARTx_ICR_PECF_POS          = 0;    /** @brief Parity error clear flag */
    static const int32_t UARTx_RDR_RDR_POS           = 0;    /** @brief Receive data value */
    static const int32_t UARTx_TDR_TDR_POS           = 0;    /** @brief Transmit data value */
    static const int32_t UARTx_PRESC_PRESCALER_POS   = 0;    /** @brief Clock prescaler */

    /**** @subsection Enumerated UARTx Register Field Positions ****/

    static const int32_t UARTx_CR1_Mx_POS[2] = {
      [0] = 12,   /** @brief Word length */
      [1] = 28,   /** @brief Word length */
    };

    static const int32_t UARTx_CR1_DEATx_POS[5] = {
      [0] = 21,   /** @brief DEAT0 */
      [1] = 22,   /** @brief DEAT1 */
      [2] = 23,   /** @brief DEAT2 */
      [3] = 24,   /** @brief DEAT3 */
      [4] = 25,   /** @brief Driver enable assertion time */
    };

    static const int32_t UARTx_CR1_DEDTx_POS[5] = {
      [0] = 16,   /** @brief DEDT0 */
      [1] = 17,   /** @brief DEDT1 */
      [2] = 18,   /** @brief DEDT2 */
      [3] = 19,   /** @brief DEDT3 */
      [4] = 20,   /** @brief Driver enable de-assertion time */
    };

    static const int32_t UARTx_CR2_ABRMODx_POS[2] = {
      [0] = 21,   /** @brief ABRMOD0 */
      [1] = 22,   /** @brief Auto baud rate mode */
    };

    /**********************************************************************************************
     * @section A_TIM1 Register Information
     **********************************************************************************************/

    /**** @subsection A_TIM1 Register Pointers ****/

    static RW_ uint32_t* const A_TIM1_CR1_PTR            = (RW_ uint32_t* const)0x40010000U;   /** @brief Control register 1 */
    static RW_ uint32_t* const A_TIM1_CR2_PTR            = (RW_ uint32_t* const)0x40010004U;   /** @brief Control register 2 */
    static RW_ uint32_t* const A_TIM1_SMCR_PTR           = (RW_ uint32_t* const)0x40010008U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const A_TIM1_DIER_PTR           = (RW_ uint32_t* const)0x4001000CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const A_TIM1_SR_PTR             = (RW_ uint32_t* const)0x40010010U;   /** @brief Status register */
    static RW_ uint32_t* const A_TIM1_EGR_PTR            = (RW_ uint32_t* const)0x40010014U;   /** @brief Event generation register */
    static RW_ uint32_t* const A_TIM1_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40010018U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const A_TIM1_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40010018U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const A_TIM1_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x4001001CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const A_TIM1_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x4001001CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const A_TIM1_CCER_PTR           = (RW_ uint32_t* const)0x40010020U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const A_TIM1_CNT_PTR            = (RW_ uint32_t* const)0x40010024U;   /** @brief Counter */
    static RW_ uint32_t* const A_TIM1_PSC_PTR            = (RW_ uint32_t* const)0x40010028U;   /** @brief Prescaler */
    static RW_ uint32_t* const A_TIM1_ARR_PTR            = (RW_ uint32_t* const)0x4001002CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const A_TIM1_CCR1_PTR           = (RW_ uint32_t* const)0x40010034U;   /** @brief Capture/compare register 1 */
    static RW_ uint32_t* const A_TIM1_CCR2_PTR           = (RW_ uint32_t* const)0x40010038U;   /** @brief Capture/compare register 2 */
    static RW_ uint32_t* const A_TIM1_CCR3_PTR           = (RW_ uint32_t* const)0x4001003CU;   /** @brief Capture/compare register 3 */
    static RW_ uint32_t* const A_TIM1_CCR4_PTR           = (RW_ uint32_t* const)0x40010040U;   /** @brief Capture/compare register 4 */
    static RW_ uint32_t* const A_TIM1_DCR_PTR            = (RW_ uint32_t* const)0x40010048U;   /** @brief DMA control register */
    static RW_ uint32_t* const A_TIM1_DMAR_PTR           = (RW_ uint32_t* const)0x4001004CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const A_TIM1_RCR_PTR            = (RW_ uint32_t* const)0x40010030U;   /** @brief Repetition counter register */
    static RW_ uint32_t* const A_TIM1_BDTR_PTR           = (RW_ uint32_t* const)0x40010044U;   /** @brief Break and dead-time register */
    static RW_ uint32_t* const A_TIM1_CCMR3_OUTPUT_PTR   = (RW_ uint32_t* const)0x40010054U;   /** @brief Capture/compare mode register 3 (output mode) */
    static RW_ uint32_t* const A_TIM1_CCR5_PTR           = (RW_ uint32_t* const)0x40010058U;   /** @brief Capture/compare register 5 */
    static RW_ uint32_t* const A_TIM1_CRR6_PTR           = (RW_ uint32_t* const)0x4001005CU;   /** @brief Capture/compare register 6 */
    static RW_ uint32_t* const A_TIM1_AF1_PTR            = (RW_ uint32_t* const)0x40010060U;   /** @brief TIM1 alternate function option register 1 */
    static RW_ uint32_t* const A_TIM1_AF2_PTR            = (RW_ uint32_t* const)0x40010064U;   /** @brief TIM1 alternate function odfsdm1_breakster 2 */
    static RW_ uint32_t* const A_TIM1_TISEL_PTR          = (RW_ uint32_t* const)0x40010068U;   /** @brief TIM1 timer input selection register */

    /**** @subsection A_TIM1 Register Reset Values ****/

    static const uint32_t A_TIM1_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t A_TIM1_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t A_TIM1_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t A_TIM1_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t A_TIM1_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t A_TIM1_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t A_TIM1_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t A_TIM1_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t A_TIM1_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t A_TIM1_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t A_TIM1_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t A_TIM1_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t A_TIM1_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t A_TIM1_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t A_TIM1_CCR1_RST           = 0x00000000U;   /** @brief CCR1 register reset value. */
    static const uint32_t A_TIM1_CCR2_RST           = 0x00000000U;   /** @brief CCR2 register reset value. */
    static const uint32_t A_TIM1_CCR3_RST           = 0x00000000U;   /** @brief CCR3 register reset value. */
    static const uint32_t A_TIM1_CCR4_RST           = 0x00000000U;   /** @brief CCR4 register reset value. */
    static const uint32_t A_TIM1_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t A_TIM1_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t A_TIM1_RCR_RST            = 0x00000000U;   /** @brief RCR register reset value. */
    static const uint32_t A_TIM1_BDTR_RST           = 0x00000000U;   /** @brief BDTR register reset value. */
    static const uint32_t A_TIM1_CCMR3_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR3_OUTPUT register reset value. */
    static const uint32_t A_TIM1_CCR5_RST           = 0x00000000U;   /** @brief CCR5 register reset value. */
    static const uint32_t A_TIM1_CRR6_RST           = 0x00000000U;   /** @brief CRR6 register reset value. */
    static const uint32_t A_TIM1_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t A_TIM1_AF2_RST            = 0x00000000U;   /** @brief AF2 register reset value. */
    static const uint32_t A_TIM1_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated A_TIM1 Register Value Types ****/

    typedef uint32_t A_TIM1_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t A_TIM1_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t A_TIM1_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t A_TIM1_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t A_TIM1_SR_t;             /** @brief SR register value type. */
    typedef uint32_t A_TIM1_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t A_TIM1_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t A_TIM1_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t A_TIM1_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t A_TIM1_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t A_TIM1_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t A_TIM1_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t A_TIM1_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t A_TIM1_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t A_TIM1_CCR1_t;           /** @brief CCR1 register value type. */
    typedef uint32_t A_TIM1_CCR2_t;           /** @brief CCR2 register value type. */
    typedef uint32_t A_TIM1_CCR3_t;           /** @brief CCR3 register value type. */
    typedef uint32_t A_TIM1_CCR4_t;           /** @brief CCR4 register value type. */
    typedef uint32_t A_TIM1_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t A_TIM1_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t A_TIM1_RCR_t;            /** @brief RCR register value type. */
    typedef uint32_t A_TIM1_BDTR_t;           /** @brief BDTR register value type. */
    typedef uint32_t A_TIM1_CCMR3_OUTPUT_t;   /** @brief CCMR3_OUTPUT register value type. */
    typedef uint32_t A_TIM1_CCR5_t;           /** @brief CCR5 register value type. */
    typedef uint32_t A_TIM1_CRR6_t;           /** @brief CRR6 register value type. */
    typedef uint32_t A_TIM1_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t A_TIM1_AF2_t;            /** @brief AF2 register value type. */
    typedef uint32_t A_TIM1_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated A_TIM1 Register Pointer Types ****/

    typedef uint32_t* const A_TIM1_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const A_TIM1_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const A_TIM1_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const A_TIM1_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const A_TIM1_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const A_TIM1_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const A_TIM1_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const A_TIM1_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const A_TIM1_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const A_TIM1_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const A_TIM1_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const A_TIM1_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const A_TIM1_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const A_TIM1_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const A_TIM1_CCR1_PTR_t;           /** @brief CCR1 register pointer type. */
    typedef uint32_t* const A_TIM1_CCR2_PTR_t;           /** @brief CCR2 register pointer type. */
    typedef uint32_t* const A_TIM1_CCR3_PTR_t;           /** @brief CCR3 register pointer type. */
    typedef uint32_t* const A_TIM1_CCR4_PTR_t;           /** @brief CCR4 register pointer type. */
    typedef uint32_t* const A_TIM1_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const A_TIM1_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const A_TIM1_RCR_PTR_t;            /** @brief RCR register pointer type. */
    typedef uint32_t* const A_TIM1_BDTR_PTR_t;           /** @brief BDTR register pointer type. */
    typedef uint32_t* const A_TIM1_CCMR3_OUTPUT_PTR_t;   /** @brief CCMR3_OUTPUT register pointer type. */
    typedef uint32_t* const A_TIM1_CCR5_PTR_t;           /** @brief CCR5 register pointer type. */
    typedef uint32_t* const A_TIM1_CRR6_PTR_t;           /** @brief CRR6 register pointer type. */
    typedef uint32_t* const A_TIM1_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const A_TIM1_AF2_PTR_t;            /** @brief AF2 register pointer type. */
    typedef uint32_t* const A_TIM1_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection A_TIM1 Register Field Masks ****/

    static const uint32_t A_TIM1_CR1_CEN_MASK               = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t A_TIM1_CR1_UDIS_MASK              = 0x00000002U;   /** @brief Update disable */
    static const uint32_t A_TIM1_CR1_URS_MASK               = 0x00000004U;   /** @brief Update request source */
    static const uint32_t A_TIM1_CR1_OPM_MASK               = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t A_TIM1_CR1_DIR_MASK               = 0x00000010U;   /** @brief Direction */
    static const uint32_t A_TIM1_CR1_CMS_MASK               = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t A_TIM1_CR1_ARPE_MASK              = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t A_TIM1_CR1_CKD_MASK               = 0x00000300U;   /** @brief Clock division */
    static const uint32_t A_TIM1_CR1_UIFREMAP_MASK          = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t A_TIM1_CR2_MMS2_MASK              = 0x00F00000U;   /** @brief Master mode selection 2 */
    static const uint32_t A_TIM1_CR2_TI1S_MASK              = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t A_TIM1_CR2_MMS_MASK               = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t A_TIM1_CR2_CCDS_MASK              = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t A_TIM1_CR2_CCUS_MASK              = 0x00000004U;   /** @brief Capture/compare control update selection */
    static const uint32_t A_TIM1_CR2_CCPC_MASK              = 0x00000001U;   /** @brief Capture/compare preloaded control */
    static const uint32_t A_TIM1_SMCR_SMS_MASK              = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t A_TIM1_SMCR_TS_MASK               = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t A_TIM1_SMCR_MSM_MASK              = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t A_TIM1_SMCR_ETF_MASK              = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t A_TIM1_SMCR_ETPS_MASK             = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t A_TIM1_SMCR_ECE_MASK              = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t A_TIM1_SMCR_ETP_MASK              = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t A_TIM1_SMCR_SMS_3_MASK            = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t A_TIM1_SMCR_TS_4_3_MASK           = 0x00300000U;   /** @brief Trigger selection - bit 4:3 */
    static const uint32_t A_TIM1_DIER_TDE_MASK              = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t A_TIM1_DIER_COMDE_MASK            = 0x00002000U;   /** @brief COM DMA request enable */
    static const uint32_t A_TIM1_DIER_UDE_MASK              = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t A_TIM1_DIER_TIE_MASK              = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t A_TIM1_DIER_UIE_MASK              = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t A_TIM1_DIER_BIE_MASK              = 0x00000080U;   /** @brief Break interrupt enable */
    static const uint32_t A_TIM1_DIER_COMIE_MASK            = 0x00000020U;   /** @brief COM interrupt enable */
    static const uint32_t A_TIM1_SR_SBIF_MASK               = 0x00002000U;   /** @brief System break interrupt flag */
    static const uint32_t A_TIM1_SR_B2IF_MASK               = 0x00000100U;   /** @brief Break 2 interrupt flag */
    static const uint32_t A_TIM1_SR_BIF_MASK                = 0x00000080U;   /** @brief Break interrupt flag */
    static const uint32_t A_TIM1_SR_TIF_MASK                = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t A_TIM1_SR_COMIF_MASK              = 0x00000020U;   /** @brief COM interrupt flag */
    static const uint32_t A_TIM1_SR_UIF_MASK                = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t A_TIM1_EGR_UG_MASK                = 0x00000001U;   /** @brief Update generation */
    static const uint32_t A_TIM1_EGR_COMG_MASK              = 0x00000020U;   /** @brief Capture/Compare control update generation */
    static const uint32_t A_TIM1_EGR_TG_MASK                = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t A_TIM1_EGR_BG_MASK                = 0x00000080U;   /** @brief Break generation */
    static const uint32_t A_TIM1_EGR_B2G_MASK               = 0x00000100U;   /** @brief Break 2 generation */
    static const uint32_t A_TIM1_CCMR1_INPUT_IC2PCS_MASK    = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t A_TIM1_CCMR1_INPUT_ICPCS_MASK     = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t A_TIM1_CCMR2_OUTPUT_OC3M_3_MASK   = 0x00010000U;   /** @brief Output compare 3 mode - bit 3 */
    static const uint32_t A_TIM1_CCMR2_OUTPUT_OC4M_4_MASK   = 0x01000000U;   /** @brief Output compare 4 mode - bit 3 */
    static const uint32_t A_TIM1_CNT_CNT_MASK               = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t A_TIM1_CNT_UIFCPY_MASK            = 0x80000000U;   /** @brief UIF copy */
    static const uint32_t A_TIM1_PSC_PSC_MASK               = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t A_TIM1_ARR_ARR_MASK               = 0x0000FFFFU;   /** @brief Auto-reload value */
    static const uint32_t A_TIM1_CCR1_CCR1_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
    static const uint32_t A_TIM1_CCR2_CCR2_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 2 value */
    static const uint32_t A_TIM1_CCR3_CCR3_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare value */
    static const uint32_t A_TIM1_CCR4_CCR4_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare value */
    static const uint32_t A_TIM1_DCR_DBL_MASK               = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t A_TIM1_DCR_DBA_MASK               = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t A_TIM1_DMAR_DMAB_MASK             = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t A_TIM1_RCR_REP_MASK               = 0x000000FFU;   /** @brief Repetition counter value */
    static const uint32_t A_TIM1_BDTR_DTG_MASK              = 0x000000FFU;   /** @brief Dead-time generator setup */
    static const uint32_t A_TIM1_BDTR_LOCK_MASK             = 0x00000300U;   /** @brief Lock configuration */
    static const uint32_t A_TIM1_BDTR_OSSI_MASK             = 0x00000400U;   /** @brief Off-state selection for idle mode */
    static const uint32_t A_TIM1_BDTR_OSSR_MASK             = 0x00000800U;   /** @brief Off-state selection for run mode */
    static const uint32_t A_TIM1_BDTR_BKE_MASK              = 0x00001000U;   /** @brief Break enable */
    static const uint32_t A_TIM1_BDTR_BKP_MASK              = 0x00002000U;   /** @brief Break polarity */
    static const uint32_t A_TIM1_BDTR_AOE_MASK              = 0x00004000U;   /** @brief Automatic output enable */
    static const uint32_t A_TIM1_BDTR_MOE_MASK              = 0x00008000U;   /** @brief Main output enable */
    static const uint32_t A_TIM1_BDTR_BKF_MASK              = 0x000F0000U;   /** @brief Break filter */
    static const uint32_t A_TIM1_BDTR_BK2F_MASK             = 0x00F00000U;   /** @brief Break 2 filter */
    static const uint32_t A_TIM1_BDTR_BK2E_MASK             = 0x01000000U;   /** @brief Break 2 enable */
    static const uint32_t A_TIM1_BDTR_BK2P_MASK             = 0x02000000U;   /** @brief Break 2 polarity */
    static const uint32_t A_TIM1_CCR5_CCR5_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 5 value */
    static const uint32_t A_TIM1_CRR6_CCR6_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 6 value */
    static const uint32_t A_TIM1_AF1_BKINE_MASK             = 0x00000001U;   /** @brief BRK BKIN input enable */
    static const uint32_t A_TIM1_AF1_BKDF1BK0E_MASK         = 0x00000100U;   /** @brief BRK dfsdm1_break[0] enable */
    static const uint32_t A_TIM1_AF1_BKINP_MASK             = 0x00000200U;   /** @brief BRK BKIN input polarity */
    static const uint32_t A_TIM1_AF1_ETRSEL_MASK            = 0x0003C000U;   /** @brief ETR source selection */
    static const uint32_t A_TIM1_AF2_BK2INE_MASK            = 0x00000001U;   /** @brief BRK2 BKIN input enable */
    static const uint32_t A_TIM1_AF2_BK2DF1BK1E_MASK        = 0x00000100U;   /** @brief BRK2 dfsdm1_break[1] enable */
    static const uint32_t A_TIM1_AF2_BK2INP_MASK            = 0x00000200U;   /** @brief BRK2 BKIN2 input polarity */

    /**** @subsection Enumerated A_TIM1 Register Field Masks ****/

    static const uint32_t A_TIM1_CR2_OISx_MASK[7] = {
      [1] = 0x00000100U,   /** @brief Output idle state 1 */
      [2] = 0x00000400U,   /** @brief Output idle state 2 */
      [3] = 0x00001000U,   /** @brief Output idle state 3 */
      [4] = 0x00004000U,   /** @brief Output idle state 4 */
      [5] = 0x00010000U,   /** @brief Output idle state 5 */
      [6] = 0x00040000U,   /** @brief Output idle state 6 */
    };

    static const uint32_t A_TIM1_CR2_OISxN_MASK[4] = {
      [1] = 0x00000200U,   /** @brief Output idle state 1 */
      [2] = 0x00000800U,   /** @brief Output idle state 2 */
      [3] = 0x00002000U,   /** @brief Output idle state 3 */
    };

    static const uint32_t A_TIM1_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t A_TIM1_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t A_TIM1_SR_CCxIF_MASK[7] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
      [5] = 0x00010000U,   /** @brief Compare 5 interrupt flag */
      [6] = 0x00020000U,   /** @brief Compare 6 interrupt flag */
    };

    static const uint32_t A_TIM1_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t A_TIM1_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t A_TIM1_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief Capture/Compare 1 selection */
      [2] = 0x00000300U,   /** @brief Capture/Compare 2 selection */
    };

    static const uint32_t A_TIM1_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output compare 1 fast enable */
      [2] = 0x00000400U,   /** @brief Output compare 2 fast enable */
    };

    static const uint32_t A_TIM1_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output compare 1 preload enable */
      [2] = 0x00000800U,   /** @brief Output compare 2 preload enable */
    };

    static const uint32_t A_TIM1_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief Output compare 1 mode */
      [2] = 0x00007000U,   /** @brief Output compare 2 mode */
    };

    static const uint32_t A_TIM1_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Output compare 1 clear enable */
      [2] = 0x00008000U,   /** @brief Output compare 2 clear enable */
    };

    static const uint32_t A_TIM1_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t A_TIM1_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t A_TIM1_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t A_TIM1_CCER_CCxE_MASK[7] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
      [5] = 0x00010000U,   /** @brief Capture/Compare 5 output enable */
      [6] = 0x00100000U,   /** @brief Capture/Compare 6 output enable */
    };

    static const uint32_t A_TIM1_CCER_CCxP_MASK[7] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
      [5] = 0x00020000U,   /** @brief Capture/Compare 5 output polarity */
      [6] = 0x00200000U,   /** @brief Capture/Compare 6 output polarity */
    };

    static const uint32_t A_TIM1_CCER_CCxNE_MASK[4] = {
      [1] = 0x00000004U,   /** @brief Capture/Compare 1 complementary output enable */
      [2] = 0x00000040U,   /** @brief Capture/Compare 2 complementary output enable */
      [3] = 0x00000400U,   /** @brief Capture/Compare 3 complementary output enable */
    };

    static const uint32_t A_TIM1_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 complementary output polarity */
    };

    static const uint32_t A_TIM1_CCMR3_OUTPUT_OCxM3_MASK[7] = {
      [5] = 0x00010000U,   /** @brief Output compare 5 mode */
      [6] = 0x01000000U,   /** @brief Output compare 6 mode */
    };

    static const uint32_t A_TIM1_CCR5_GC5Cx_MASK[4] = {
      [1] = 0x20000000U,   /** @brief Group channel 5 and channel 1 */
      [2] = 0x40000000U,   /** @brief Group channel 5 and channel 2 */
      [3] = 0x80000000U,   /** @brief Group channel 5 and channel 3 */
    };

    static const uint32_t A_TIM1_AF1_BKCMPxE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
      [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
    };

    static const uint32_t A_TIM1_AF1_BKCMPxP_MASK[3] = {
      [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
      [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
    };

    static const uint32_t A_TIM1_AF2_BK2CMPxE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief BRK2 COMP1 enable */
      [2] = 0x00000004U,   /** @brief BRK2 COMP2 enable */
    };

    static const uint32_t A_TIM1_AF2_BK2CMPxP_MASK[3] = {
      [1] = 0x00000400U,   /** @brief BRK2 COMP1 input polarit */
      [2] = 0x00000800U,   /** @brief BRK2 COMP2 input polarity */
    };

    static const uint32_t A_TIM1_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief Selects TI1[0] to TI1[15] input */
      [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
      [3] = 0x000F0000U,   /** @brief Selects TI3[0] to TI3[15] input */
      [4] = 0x0F000000U,   /** @brief Selects TI4[0] to TI4[15] input */
    };

    /**** @subsection A_TIM1 Register Field Positions ****/

    static const int32_t A_TIM1_CR1_CEN_POS               = 0;    /** @brief Counter enable */
    static const int32_t A_TIM1_CR1_UDIS_POS              = 1;    /** @brief Update disable */
    static const int32_t A_TIM1_CR1_URS_POS               = 2;    /** @brief Update request source */
    static const int32_t A_TIM1_CR1_OPM_POS               = 3;    /** @brief One-pulse mode */
    static const int32_t A_TIM1_CR1_DIR_POS               = 4;    /** @brief Direction */
    static const int32_t A_TIM1_CR1_CMS_POS               = 5;    /** @brief Center-aligned mode selection */
    static const int32_t A_TIM1_CR1_ARPE_POS              = 7;    /** @brief Auto-reload preload enable */
    static const int32_t A_TIM1_CR1_CKD_POS               = 8;    /** @brief Clock division */
    static const int32_t A_TIM1_CR1_UIFREMAP_POS          = 11;   /** @brief UIF status bit remapping */
    static const int32_t A_TIM1_CR2_MMS2_POS              = 20;   /** @brief Master mode selection 2 */
    static const int32_t A_TIM1_CR2_TI1S_POS              = 7;    /** @brief TI1 selection */
    static const int32_t A_TIM1_CR2_MMS_POS               = 4;    /** @brief Master mode selection */
    static const int32_t A_TIM1_CR2_CCDS_POS              = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t A_TIM1_CR2_CCUS_POS              = 2;    /** @brief Capture/compare control update selection */
    static const int32_t A_TIM1_CR2_CCPC_POS              = 0;    /** @brief Capture/compare preloaded control */
    static const int32_t A_TIM1_SMCR_SMS_POS              = 0;    /** @brief Slave mode selection */
    static const int32_t A_TIM1_SMCR_TS_POS               = 4;    /** @brief Trigger selection */
    static const int32_t A_TIM1_SMCR_MSM_POS              = 7;    /** @brief Master/Slave mode */
    static const int32_t A_TIM1_SMCR_ETF_POS              = 8;    /** @brief External trigger filter */
    static const int32_t A_TIM1_SMCR_ETPS_POS             = 12;   /** @brief External trigger prescaler */
    static const int32_t A_TIM1_SMCR_ECE_POS              = 14;   /** @brief External clock enable */
    static const int32_t A_TIM1_SMCR_ETP_POS              = 15;   /** @brief External trigger polarity */
    static const int32_t A_TIM1_SMCR_SMS_3_POS            = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t A_TIM1_SMCR_TS_4_3_POS           = 20;   /** @brief Trigger selection - bit 4:3 */
    static const int32_t A_TIM1_DIER_TDE_POS              = 14;   /** @brief Trigger DMA request enable */
    static const int32_t A_TIM1_DIER_COMDE_POS            = 13;   /** @brief COM DMA request enable */
    static const int32_t A_TIM1_DIER_UDE_POS              = 8;    /** @brief Update DMA request enable */
    static const int32_t A_TIM1_DIER_TIE_POS              = 6;    /** @brief Trigger interrupt enable */
    static const int32_t A_TIM1_DIER_UIE_POS              = 0;    /** @brief Update interrupt enable */
    static const int32_t A_TIM1_DIER_BIE_POS              = 7;    /** @brief Break interrupt enable */
    static const int32_t A_TIM1_DIER_COMIE_POS            = 5;    /** @brief COM interrupt enable */
    static const int32_t A_TIM1_SR_SBIF_POS               = 13;   /** @brief System break interrupt flag */
    static const int32_t A_TIM1_SR_B2IF_POS               = 8;    /** @brief Break 2 interrupt flag */
    static const int32_t A_TIM1_SR_BIF_POS                = 7;    /** @brief Break interrupt flag */
    static const int32_t A_TIM1_SR_TIF_POS                = 6;    /** @brief Trigger interrupt flag */
    static const int32_t A_TIM1_SR_COMIF_POS              = 5;    /** @brief COM interrupt flag */
    static const int32_t A_TIM1_SR_UIF_POS                = 0;    /** @brief Update interrupt flag */
    static const int32_t A_TIM1_EGR_UG_POS                = 0;    /** @brief Update generation */
    static const int32_t A_TIM1_EGR_COMG_POS              = 5;    /** @brief Capture/Compare control update generation */
    static const int32_t A_TIM1_EGR_TG_POS                = 6;    /** @brief Trigger generation */
    static const int32_t A_TIM1_EGR_BG_POS                = 7;    /** @brief Break generation */
    static const int32_t A_TIM1_EGR_B2G_POS               = 8;    /** @brief Break 2 generation */
    static const int32_t A_TIM1_CCMR1_INPUT_IC2PCS_POS    = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t A_TIM1_CCMR1_INPUT_ICPCS_POS     = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t A_TIM1_CCMR2_OUTPUT_OC3M_3_POS   = 16;   /** @brief Output compare 3 mode - bit 3 */
    static const int32_t A_TIM1_CCMR2_OUTPUT_OC4M_4_POS   = 24;   /** @brief Output compare 4 mode - bit 3 */
    static const int32_t A_TIM1_CNT_CNT_POS               = 0;    /** @brief Counter value */
    static const int32_t A_TIM1_CNT_UIFCPY_POS            = 31;   /** @brief UIF copy */
    static const int32_t A_TIM1_PSC_PSC_POS               = 0;    /** @brief Prescaler value */
    static const int32_t A_TIM1_ARR_ARR_POS               = 0;    /** @brief Auto-reload value */
    static const int32_t A_TIM1_CCR1_CCR1_POS             = 0;    /** @brief Capture/Compare 1 value */
    static const int32_t A_TIM1_CCR2_CCR2_POS             = 0;    /** @brief Capture/Compare 2 value */
    static const int32_t A_TIM1_CCR3_CCR3_POS             = 0;    /** @brief Capture/Compare value */
    static const int32_t A_TIM1_CCR4_CCR4_POS             = 0;    /** @brief Capture/Compare value */
    static const int32_t A_TIM1_DCR_DBL_POS               = 8;    /** @brief DMA burst length */
    static const int32_t A_TIM1_DCR_DBA_POS               = 0;    /** @brief DMA base address */
    static const int32_t A_TIM1_DMAR_DMAB_POS             = 0;    /** @brief DMA register for burst accesses */
    static const int32_t A_TIM1_RCR_REP_POS               = 0;    /** @brief Repetition counter value */
    static const int32_t A_TIM1_BDTR_DTG_POS              = 0;    /** @brief Dead-time generator setup */
    static const int32_t A_TIM1_BDTR_LOCK_POS             = 8;    /** @brief Lock configuration */
    static const int32_t A_TIM1_BDTR_OSSI_POS             = 10;   /** @brief Off-state selection for idle mode */
    static const int32_t A_TIM1_BDTR_OSSR_POS             = 11;   /** @brief Off-state selection for run mode */
    static const int32_t A_TIM1_BDTR_BKE_POS              = 12;   /** @brief Break enable */
    static const int32_t A_TIM1_BDTR_BKP_POS              = 13;   /** @brief Break polarity */
    static const int32_t A_TIM1_BDTR_AOE_POS              = 14;   /** @brief Automatic output enable */
    static const int32_t A_TIM1_BDTR_MOE_POS              = 15;   /** @brief Main output enable */
    static const int32_t A_TIM1_BDTR_BKF_POS              = 16;   /** @brief Break filter */
    static const int32_t A_TIM1_BDTR_BK2F_POS             = 20;   /** @brief Break 2 filter */
    static const int32_t A_TIM1_BDTR_BK2E_POS             = 24;   /** @brief Break 2 enable */
    static const int32_t A_TIM1_BDTR_BK2P_POS             = 25;   /** @brief Break 2 polarity */
    static const int32_t A_TIM1_CCR5_CCR5_POS             = 0;    /** @brief Capture/Compare 5 value */
    static const int32_t A_TIM1_CRR6_CCR6_POS             = 0;    /** @brief Capture/Compare 6 value */
    static const int32_t A_TIM1_AF1_BKINE_POS             = 0;    /** @brief BRK BKIN input enable */
    static const int32_t A_TIM1_AF1_BKDF1BK0E_POS         = 8;    /** @brief BRK dfsdm1_break[0] enable */
    static const int32_t A_TIM1_AF1_BKINP_POS             = 9;    /** @brief BRK BKIN input polarity */
    static const int32_t A_TIM1_AF1_ETRSEL_POS            = 14;   /** @brief ETR source selection */
    static const int32_t A_TIM1_AF2_BK2INE_POS            = 0;    /** @brief BRK2 BKIN input enable */
    static const int32_t A_TIM1_AF2_BK2DF1BK1E_POS        = 8;    /** @brief BRK2 dfsdm1_break[1] enable */
    static const int32_t A_TIM1_AF2_BK2INP_POS            = 9;    /** @brief BRK2 BKIN2 input polarity */

    /**** @subsection Enumerated A_TIM1 Register Field Positions ****/

    static const int32_t A_TIM1_CR2_OISx_POS[7] = {
      [1] = 8,    /** @brief Output idle state 1 */
      [2] = 10,   /** @brief Output idle state 2 */
      [3] = 12,   /** @brief Output idle state 3 */
      [4] = 14,   /** @brief Output idle state 4 */
      [5] = 16,   /** @brief Output idle state 5 */
      [6] = 18,   /** @brief Output idle state 6 */
    };

    static const int32_t A_TIM1_CR2_OISxN_POS[4] = {
      [1] = 9,    /** @brief Output idle state 1 */
      [2] = 11,   /** @brief Output idle state 2 */
      [3] = 13,   /** @brief Output idle state 3 */
    };

    static const int32_t A_TIM1_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t A_TIM1_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t A_TIM1_SR_CCxIF_POS[7] = {
      [1] = 1,    /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,    /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,    /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,    /** @brief Capture/Compare 4 interrupt flag */
      [5] = 16,   /** @brief Compare 5 interrupt flag */
      [6] = 17,   /** @brief Compare 6 interrupt flag */
    };

    static const int32_t A_TIM1_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t A_TIM1_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t A_TIM1_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief Capture/Compare 1 selection */
      [2] = 8,   /** @brief Capture/Compare 2 selection */
    };

    static const int32_t A_TIM1_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief Output compare 1 fast enable */
      [2] = 10,   /** @brief Output compare 2 fast enable */
    };

    static const int32_t A_TIM1_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief Output compare 1 preload enable */
      [2] = 11,   /** @brief Output compare 2 preload enable */
    };

    static const int32_t A_TIM1_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief Output compare 1 mode */
      [2] = 12,   /** @brief Output compare 2 mode */
    };

    static const int32_t A_TIM1_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief Output compare 1 clear enable */
      [2] = 15,   /** @brief Output compare 2 clear enable */
    };

    static const int32_t A_TIM1_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t A_TIM1_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t A_TIM1_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t A_TIM1_CCER_CCxE_POS[7] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
      [5] = 16,   /** @brief Capture/Compare 5 output enable */
      [6] = 20,   /** @brief Capture/Compare 6 output enable */
    };

    static const int32_t A_TIM1_CCER_CCxP_POS[7] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
      [5] = 17,   /** @brief Capture/Compare 5 output polarity */
      [6] = 21,   /** @brief Capture/Compare 6 output polarity */
    };

    static const int32_t A_TIM1_CCER_CCxNE_POS[4] = {
      [1] = 2,    /** @brief Capture/Compare 1 complementary output enable */
      [2] = 6,    /** @brief Capture/Compare 2 complementary output enable */
      [3] = 10,   /** @brief Capture/Compare 3 complementary output enable */
    };

    static const int32_t A_TIM1_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 complementary output polarity */
    };

    static const int32_t A_TIM1_CCMR3_OUTPUT_OCxM3_POS[7] = {
      [5] = 16,   /** @brief Output compare 5 mode */
      [6] = 24,   /** @brief Output compare 6 mode */
    };

    static const int32_t A_TIM1_CCR5_GC5Cx_POS[4] = {
      [1] = 29,   /** @brief Group channel 5 and channel 1 */
      [2] = 30,   /** @brief Group channel 5 and channel 2 */
      [3] = 31,   /** @brief Group channel 5 and channel 3 */
    };

    static const int32_t A_TIM1_AF1_BKCMPxE_POS[3] = {
      [1] = 1,   /** @brief BRK COMP1 enable */
      [2] = 2,   /** @brief BRK COMP2 enable */
    };

    static const int32_t A_TIM1_AF1_BKCMPxP_POS[3] = {
      [1] = 10,   /** @brief BRK COMP1 input polarity */
      [2] = 11,   /** @brief BRK COMP2 input polarity */
    };

    static const int32_t A_TIM1_AF2_BK2CMPxE_POS[3] = {
      [1] = 1,   /** @brief BRK2 COMP1 enable */
      [2] = 2,   /** @brief BRK2 COMP2 enable */
    };

    static const int32_t A_TIM1_AF2_BK2CMPxP_POS[3] = {
      [1] = 10,   /** @brief BRK2 COMP1 input polarit */
      [2] = 11,   /** @brief BRK2 COMP2 input polarity */
    };

    static const int32_t A_TIM1_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief Selects TI1[0] to TI1[15] input */
      [2] = 8,    /** @brief Selects TI2[0] to TI2[15] input */
      [3] = 16,   /** @brief Selects TI3[0] to TI3[15] input */
      [4] = 24,   /** @brief Selects TI4[0] to TI4[15] input */
    };

    /**********************************************************************************************
     * @section A_TIM8 Register Information
     **********************************************************************************************/

    /**** @subsection A_TIM8 Register Pointers ****/

    static RW_ uint32_t* const A_TIM8_CR1_PTR            = (RW_ uint32_t* const)0x40010400U;   /** @brief Control register 1 */
    static RW_ uint32_t* const A_TIM8_CR2_PTR            = (RW_ uint32_t* const)0x40010404U;   /** @brief Control register 2 */
    static RW_ uint32_t* const A_TIM8_SMCR_PTR           = (RW_ uint32_t* const)0x40010408U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const A_TIM8_DIER_PTR           = (RW_ uint32_t* const)0x4001040CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const A_TIM8_SR_PTR             = (RW_ uint32_t* const)0x40010410U;   /** @brief Status register */
    static RW_ uint32_t* const A_TIM8_EGR_PTR            = (RW_ uint32_t* const)0x40010414U;   /** @brief Event generation register */
    static RW_ uint32_t* const A_TIM8_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40010418U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const A_TIM8_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40010418U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const A_TIM8_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x4001041CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const A_TIM8_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x4001041CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const A_TIM8_CCER_PTR           = (RW_ uint32_t* const)0x40010420U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const A_TIM8_CNT_PTR            = (RW_ uint32_t* const)0x40010424U;   /** @brief Counter */
    static RW_ uint32_t* const A_TIM8_PSC_PTR            = (RW_ uint32_t* const)0x40010428U;   /** @brief Prescaler */
    static RW_ uint32_t* const A_TIM8_ARR_PTR            = (RW_ uint32_t* const)0x4001042CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const A_TIM8_CCR1_PTR           = (RW_ uint32_t* const)0x40010434U;   /** @brief Capture/compare register 1 */
    static RW_ uint32_t* const A_TIM8_CCR2_PTR           = (RW_ uint32_t* const)0x40010438U;   /** @brief Capture/compare register 2 */
    static RW_ uint32_t* const A_TIM8_CCR3_PTR           = (RW_ uint32_t* const)0x4001043CU;   /** @brief Capture/compare register 3 */
    static RW_ uint32_t* const A_TIM8_CCR4_PTR           = (RW_ uint32_t* const)0x40010440U;   /** @brief Capture/compare register 4 */
    static RW_ uint32_t* const A_TIM8_DCR_PTR            = (RW_ uint32_t* const)0x40010448U;   /** @brief DMA control register */
    static RW_ uint32_t* const A_TIM8_DMAR_PTR           = (RW_ uint32_t* const)0x4001044CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const A_TIM8_RCR_PTR            = (RW_ uint32_t* const)0x40010430U;   /** @brief Repetition counter register */
    static RW_ uint32_t* const A_TIM8_BDTR_PTR           = (RW_ uint32_t* const)0x40010444U;   /** @brief Break and dead-time register */
    static RW_ uint32_t* const A_TIM8_CCMR3_OUTPUT_PTR   = (RW_ uint32_t* const)0x40010454U;   /** @brief Capture/compare mode register 3 (output mode) */
    static RW_ uint32_t* const A_TIM8_CCR5_PTR           = (RW_ uint32_t* const)0x40010458U;   /** @brief Capture/compare register 5 */
    static RW_ uint32_t* const A_TIM8_CRR6_PTR           = (RW_ uint32_t* const)0x4001045CU;   /** @brief Capture/compare register 6 */
    static RW_ uint32_t* const A_TIM8_AF1_PTR            = (RW_ uint32_t* const)0x40010460U;   /** @brief TIM1 alternate function option register 1 */
    static RW_ uint32_t* const A_TIM8_AF2_PTR            = (RW_ uint32_t* const)0x40010464U;   /** @brief TIM1 alternate function odfsdm1_breakster 2 */
    static RW_ uint32_t* const A_TIM8_TISEL_PTR          = (RW_ uint32_t* const)0x40010468U;   /** @brief TIM1 timer input selection register */

    /**** @subsection A_TIM8 Register Reset Values ****/

    static const uint32_t A_TIM8_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t A_TIM8_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t A_TIM8_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t A_TIM8_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t A_TIM8_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t A_TIM8_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t A_TIM8_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t A_TIM8_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t A_TIM8_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t A_TIM8_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t A_TIM8_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t A_TIM8_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t A_TIM8_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t A_TIM8_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t A_TIM8_CCR1_RST           = 0x00000000U;   /** @brief CCR1 register reset value. */
    static const uint32_t A_TIM8_CCR2_RST           = 0x00000000U;   /** @brief CCR2 register reset value. */
    static const uint32_t A_TIM8_CCR3_RST           = 0x00000000U;   /** @brief CCR3 register reset value. */
    static const uint32_t A_TIM8_CCR4_RST           = 0x00000000U;   /** @brief CCR4 register reset value. */
    static const uint32_t A_TIM8_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t A_TIM8_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t A_TIM8_RCR_RST            = 0x00000000U;   /** @brief RCR register reset value. */
    static const uint32_t A_TIM8_BDTR_RST           = 0x00000000U;   /** @brief BDTR register reset value. */
    static const uint32_t A_TIM8_CCMR3_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR3_OUTPUT register reset value. */
    static const uint32_t A_TIM8_CCR5_RST           = 0x00000000U;   /** @brief CCR5 register reset value. */
    static const uint32_t A_TIM8_CRR6_RST           = 0x00000000U;   /** @brief CRR6 register reset value. */
    static const uint32_t A_TIM8_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t A_TIM8_AF2_RST            = 0x00000000U;   /** @brief AF2 register reset value. */
    static const uint32_t A_TIM8_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated A_TIM8 Register Value Types ****/

    typedef uint32_t A_TIM8_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t A_TIM8_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t A_TIM8_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t A_TIM8_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t A_TIM8_SR_t;             /** @brief SR register value type. */
    typedef uint32_t A_TIM8_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t A_TIM8_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t A_TIM8_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t A_TIM8_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t A_TIM8_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t A_TIM8_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t A_TIM8_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t A_TIM8_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t A_TIM8_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t A_TIM8_CCR1_t;           /** @brief CCR1 register value type. */
    typedef uint32_t A_TIM8_CCR2_t;           /** @brief CCR2 register value type. */
    typedef uint32_t A_TIM8_CCR3_t;           /** @brief CCR3 register value type. */
    typedef uint32_t A_TIM8_CCR4_t;           /** @brief CCR4 register value type. */
    typedef uint32_t A_TIM8_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t A_TIM8_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t A_TIM8_RCR_t;            /** @brief RCR register value type. */
    typedef uint32_t A_TIM8_BDTR_t;           /** @brief BDTR register value type. */
    typedef uint32_t A_TIM8_CCMR3_OUTPUT_t;   /** @brief CCMR3_OUTPUT register value type. */
    typedef uint32_t A_TIM8_CCR5_t;           /** @brief CCR5 register value type. */
    typedef uint32_t A_TIM8_CRR6_t;           /** @brief CRR6 register value type. */
    typedef uint32_t A_TIM8_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t A_TIM8_AF2_t;            /** @brief AF2 register value type. */
    typedef uint32_t A_TIM8_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated A_TIM8 Register Pointer Types ****/

    typedef uint32_t* const A_TIM8_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const A_TIM8_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const A_TIM8_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const A_TIM8_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const A_TIM8_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const A_TIM8_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const A_TIM8_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const A_TIM8_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const A_TIM8_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const A_TIM8_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const A_TIM8_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const A_TIM8_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const A_TIM8_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const A_TIM8_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const A_TIM8_CCR1_PTR_t;           /** @brief CCR1 register pointer type. */
    typedef uint32_t* const A_TIM8_CCR2_PTR_t;           /** @brief CCR2 register pointer type. */
    typedef uint32_t* const A_TIM8_CCR3_PTR_t;           /** @brief CCR3 register pointer type. */
    typedef uint32_t* const A_TIM8_CCR4_PTR_t;           /** @brief CCR4 register pointer type. */
    typedef uint32_t* const A_TIM8_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const A_TIM8_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const A_TIM8_RCR_PTR_t;            /** @brief RCR register pointer type. */
    typedef uint32_t* const A_TIM8_BDTR_PTR_t;           /** @brief BDTR register pointer type. */
    typedef uint32_t* const A_TIM8_CCMR3_OUTPUT_PTR_t;   /** @brief CCMR3_OUTPUT register pointer type. */
    typedef uint32_t* const A_TIM8_CCR5_PTR_t;           /** @brief CCR5 register pointer type. */
    typedef uint32_t* const A_TIM8_CRR6_PTR_t;           /** @brief CRR6 register pointer type. */
    typedef uint32_t* const A_TIM8_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const A_TIM8_AF2_PTR_t;            /** @brief AF2 register pointer type. */
    typedef uint32_t* const A_TIM8_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection A_TIM8 Register Field Masks ****/

    static const uint32_t A_TIM8_CR1_CEN_MASK               = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t A_TIM8_CR1_UDIS_MASK              = 0x00000002U;   /** @brief Update disable */
    static const uint32_t A_TIM8_CR1_URS_MASK               = 0x00000004U;   /** @brief Update request source */
    static const uint32_t A_TIM8_CR1_OPM_MASK               = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t A_TIM8_CR1_DIR_MASK               = 0x00000010U;   /** @brief Direction */
    static const uint32_t A_TIM8_CR1_CMS_MASK               = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t A_TIM8_CR1_ARPE_MASK              = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t A_TIM8_CR1_CKD_MASK               = 0x00000300U;   /** @brief Clock division */
    static const uint32_t A_TIM8_CR1_UIFREMAP_MASK          = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t A_TIM8_CR2_MMS2_MASK              = 0x00F00000U;   /** @brief Master mode selection 2 */
    static const uint32_t A_TIM8_CR2_TI1S_MASK              = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t A_TIM8_CR2_MMS_MASK               = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t A_TIM8_CR2_CCDS_MASK              = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t A_TIM8_CR2_CCUS_MASK              = 0x00000004U;   /** @brief Capture/compare control update selection */
    static const uint32_t A_TIM8_CR2_CCPC_MASK              = 0x00000001U;   /** @brief Capture/compare preloaded control */
    static const uint32_t A_TIM8_SMCR_SMS_MASK              = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t A_TIM8_SMCR_TS_MASK               = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t A_TIM8_SMCR_MSM_MASK              = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t A_TIM8_SMCR_ETF_MASK              = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t A_TIM8_SMCR_ETPS_MASK             = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t A_TIM8_SMCR_ECE_MASK              = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t A_TIM8_SMCR_ETP_MASK              = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t A_TIM8_SMCR_SMS_3_MASK            = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t A_TIM8_SMCR_TS_4_3_MASK           = 0x00300000U;   /** @brief Trigger selection - bit 4:3 */
    static const uint32_t A_TIM8_DIER_TDE_MASK              = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t A_TIM8_DIER_COMDE_MASK            = 0x00002000U;   /** @brief COM DMA request enable */
    static const uint32_t A_TIM8_DIER_UDE_MASK              = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t A_TIM8_DIER_TIE_MASK              = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t A_TIM8_DIER_UIE_MASK              = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t A_TIM8_DIER_BIE_MASK              = 0x00000080U;   /** @brief Break interrupt enable */
    static const uint32_t A_TIM8_DIER_COMIE_MASK            = 0x00000020U;   /** @brief COM interrupt enable */
    static const uint32_t A_TIM8_SR_SBIF_MASK               = 0x00002000U;   /** @brief System break interrupt flag */
    static const uint32_t A_TIM8_SR_B2IF_MASK               = 0x00000100U;   /** @brief Break 2 interrupt flag */
    static const uint32_t A_TIM8_SR_BIF_MASK                = 0x00000080U;   /** @brief Break interrupt flag */
    static const uint32_t A_TIM8_SR_TIF_MASK                = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t A_TIM8_SR_COMIF_MASK              = 0x00000020U;   /** @brief COM interrupt flag */
    static const uint32_t A_TIM8_SR_UIF_MASK                = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t A_TIM8_EGR_UG_MASK                = 0x00000001U;   /** @brief Update generation */
    static const uint32_t A_TIM8_EGR_COMG_MASK              = 0x00000020U;   /** @brief Capture/Compare control update generation */
    static const uint32_t A_TIM8_EGR_TG_MASK                = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t A_TIM8_EGR_BG_MASK                = 0x00000080U;   /** @brief Break generation */
    static const uint32_t A_TIM8_EGR_B2G_MASK               = 0x00000100U;   /** @brief Break 2 generation */
    static const uint32_t A_TIM8_CCMR1_INPUT_IC2PCS_MASK    = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t A_TIM8_CCMR1_INPUT_ICPCS_MASK     = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t A_TIM8_CCMR2_OUTPUT_OC3M_3_MASK   = 0x00010000U;   /** @brief Output compare 3 mode - bit 3 */
    static const uint32_t A_TIM8_CCMR2_OUTPUT_OC4M_4_MASK   = 0x01000000U;   /** @brief Output compare 4 mode - bit 3 */
    static const uint32_t A_TIM8_CNT_CNT_MASK               = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t A_TIM8_CNT_UIFCPY_MASK            = 0x80000000U;   /** @brief UIF copy */
    static const uint32_t A_TIM8_PSC_PSC_MASK               = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t A_TIM8_ARR_ARR_MASK               = 0x0000FFFFU;   /** @brief Auto-reload value */
    static const uint32_t A_TIM8_CCR1_CCR1_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
    static const uint32_t A_TIM8_CCR2_CCR2_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 2 value */
    static const uint32_t A_TIM8_CCR3_CCR3_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare value */
    static const uint32_t A_TIM8_CCR4_CCR4_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare value */
    static const uint32_t A_TIM8_DCR_DBL_MASK               = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t A_TIM8_DCR_DBA_MASK               = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t A_TIM8_DMAR_DMAB_MASK             = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t A_TIM8_RCR_REP_MASK               = 0x000000FFU;   /** @brief Repetition counter value */
    static const uint32_t A_TIM8_BDTR_DTG_MASK              = 0x000000FFU;   /** @brief Dead-time generator setup */
    static const uint32_t A_TIM8_BDTR_LOCK_MASK             = 0x00000300U;   /** @brief Lock configuration */
    static const uint32_t A_TIM8_BDTR_OSSI_MASK             = 0x00000400U;   /** @brief Off-state selection for idle mode */
    static const uint32_t A_TIM8_BDTR_OSSR_MASK             = 0x00000800U;   /** @brief Off-state selection for run mode */
    static const uint32_t A_TIM8_BDTR_BKE_MASK              = 0x00001000U;   /** @brief Break enable */
    static const uint32_t A_TIM8_BDTR_BKP_MASK              = 0x00002000U;   /** @brief Break polarity */
    static const uint32_t A_TIM8_BDTR_AOE_MASK              = 0x00004000U;   /** @brief Automatic output enable */
    static const uint32_t A_TIM8_BDTR_MOE_MASK              = 0x00008000U;   /** @brief Main output enable */
    static const uint32_t A_TIM8_BDTR_BKF_MASK              = 0x000F0000U;   /** @brief Break filter */
    static const uint32_t A_TIM8_BDTR_BK2F_MASK             = 0x00F00000U;   /** @brief Break 2 filter */
    static const uint32_t A_TIM8_BDTR_BK2E_MASK             = 0x01000000U;   /** @brief Break 2 enable */
    static const uint32_t A_TIM8_BDTR_BK2P_MASK             = 0x02000000U;   /** @brief Break 2 polarity */
    static const uint32_t A_TIM8_CCR5_CCR5_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 5 value */
    static const uint32_t A_TIM8_CRR6_CCR6_MASK             = 0x0000FFFFU;   /** @brief Capture/Compare 6 value */
    static const uint32_t A_TIM8_AF1_BKINE_MASK             = 0x00000001U;   /** @brief BRK BKIN input enable */
    static const uint32_t A_TIM8_AF1_BKDF1BK0E_MASK         = 0x00000100U;   /** @brief BRK dfsdm1_break[0] enable */
    static const uint32_t A_TIM8_AF1_BKINP_MASK             = 0x00000200U;   /** @brief BRK BKIN input polarity */
    static const uint32_t A_TIM8_AF1_ETRSEL_MASK            = 0x0003C000U;   /** @brief ETR source selection */
    static const uint32_t A_TIM8_AF2_BK2INE_MASK            = 0x00000001U;   /** @brief BRK2 BKIN input enable */
    static const uint32_t A_TIM8_AF2_BK2DF1BK1E_MASK        = 0x00000100U;   /** @brief BRK2 dfsdm1_break[1] enable */
    static const uint32_t A_TIM8_AF2_BK2INP_MASK            = 0x00000200U;   /** @brief BRK2 BKIN2 input polarity */

    /**** @subsection Enumerated A_TIM8 Register Field Masks ****/

    static const uint32_t A_TIM8_CR2_OISx_MASK[7] = {
      [1] = 0x00000100U,   /** @brief Output idle state 1 */
      [2] = 0x00000400U,   /** @brief Output idle state 2 */
      [3] = 0x00001000U,   /** @brief Output idle state 3 */
      [4] = 0x00004000U,   /** @brief Output idle state 4 */
      [5] = 0x00010000U,   /** @brief Output idle state 5 */
      [6] = 0x00040000U,   /** @brief Output idle state 6 */
    };

    static const uint32_t A_TIM8_CR2_OISxN_MASK[4] = {
      [1] = 0x00000200U,   /** @brief Output idle state 1 */
      [2] = 0x00000800U,   /** @brief Output idle state 2 */
      [3] = 0x00002000U,   /** @brief Output idle state 3 */
    };

    static const uint32_t A_TIM8_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t A_TIM8_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t A_TIM8_SR_CCxIF_MASK[7] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
      [5] = 0x00010000U,   /** @brief Compare 5 interrupt flag */
      [6] = 0x00020000U,   /** @brief Compare 6 interrupt flag */
    };

    static const uint32_t A_TIM8_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t A_TIM8_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t A_TIM8_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief Capture/Compare 1 selection */
      [2] = 0x00000300U,   /** @brief Capture/Compare 2 selection */
    };

    static const uint32_t A_TIM8_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief Output compare 1 fast enable */
      [2] = 0x00000400U,   /** @brief Output compare 2 fast enable */
    };

    static const uint32_t A_TIM8_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief Output compare 1 preload enable */
      [2] = 0x00000800U,   /** @brief Output compare 2 preload enable */
    };

    static const uint32_t A_TIM8_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief Output compare 1 mode */
      [2] = 0x00007000U,   /** @brief Output compare 2 mode */
    };

    static const uint32_t A_TIM8_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief Output compare 1 clear enable */
      [2] = 0x00008000U,   /** @brief Output compare 2 clear enable */
    };

    static const uint32_t A_TIM8_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t A_TIM8_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t A_TIM8_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t A_TIM8_CCER_CCxE_MASK[7] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
      [5] = 0x00010000U,   /** @brief Capture/Compare 5 output enable */
      [6] = 0x00100000U,   /** @brief Capture/Compare 6 output enable */
    };

    static const uint32_t A_TIM8_CCER_CCxP_MASK[7] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
      [5] = 0x00020000U,   /** @brief Capture/Compare 5 output polarity */
      [6] = 0x00200000U,   /** @brief Capture/Compare 6 output polarity */
    };

    static const uint32_t A_TIM8_CCER_CCxNE_MASK[4] = {
      [1] = 0x00000004U,   /** @brief Capture/Compare 1 complementary output enable */
      [2] = 0x00000040U,   /** @brief Capture/Compare 2 complementary output enable */
      [3] = 0x00000400U,   /** @brief Capture/Compare 3 complementary output enable */
    };

    static const uint32_t A_TIM8_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 complementary output polarity */
    };

    static const uint32_t A_TIM8_CCMR3_OUTPUT_OCxM3_MASK[7] = {
      [5] = 0x00010000U,   /** @brief Output compare 5 mode */
      [6] = 0x01000000U,   /** @brief Output compare 6 mode */
    };

    static const uint32_t A_TIM8_CCR5_GC5Cx_MASK[4] = {
      [1] = 0x20000000U,   /** @brief Group channel 5 and channel 1 */
      [2] = 0x40000000U,   /** @brief Group channel 5 and channel 2 */
      [3] = 0x80000000U,   /** @brief Group channel 5 and channel 3 */
    };

    static const uint32_t A_TIM8_AF1_BKCMPxE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
      [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
    };

    static const uint32_t A_TIM8_AF1_BKCMPxP_MASK[3] = {
      [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
      [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
    };

    static const uint32_t A_TIM8_AF2_BK2CMPxE_MASK[3] = {
      [1] = 0x00000002U,   /** @brief BRK2 COMP1 enable */
      [2] = 0x00000004U,   /** @brief BRK2 COMP2 enable */
    };

    static const uint32_t A_TIM8_AF2_BK2CMPxP_MASK[3] = {
      [1] = 0x00000400U,   /** @brief BRK2 COMP1 input polarit */
      [2] = 0x00000800U,   /** @brief BRK2 COMP2 input polarity */
    };

    static const uint32_t A_TIM8_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief Selects TI1[0] to TI1[15] input */
      [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
      [3] = 0x000F0000U,   /** @brief Selects TI3[0] to TI3[15] input */
      [4] = 0x0F000000U,   /** @brief Selects TI4[0] to TI4[15] input */
    };

    /**** @subsection A_TIM8 Register Field Positions ****/

    static const int32_t A_TIM8_CR1_CEN_POS               = 0;    /** @brief Counter enable */
    static const int32_t A_TIM8_CR1_UDIS_POS              = 1;    /** @brief Update disable */
    static const int32_t A_TIM8_CR1_URS_POS               = 2;    /** @brief Update request source */
    static const int32_t A_TIM8_CR1_OPM_POS               = 3;    /** @brief One-pulse mode */
    static const int32_t A_TIM8_CR1_DIR_POS               = 4;    /** @brief Direction */
    static const int32_t A_TIM8_CR1_CMS_POS               = 5;    /** @brief Center-aligned mode selection */
    static const int32_t A_TIM8_CR1_ARPE_POS              = 7;    /** @brief Auto-reload preload enable */
    static const int32_t A_TIM8_CR1_CKD_POS               = 8;    /** @brief Clock division */
    static const int32_t A_TIM8_CR1_UIFREMAP_POS          = 11;   /** @brief UIF status bit remapping */
    static const int32_t A_TIM8_CR2_MMS2_POS              = 20;   /** @brief Master mode selection 2 */
    static const int32_t A_TIM8_CR2_TI1S_POS              = 7;    /** @brief TI1 selection */
    static const int32_t A_TIM8_CR2_MMS_POS               = 4;    /** @brief Master mode selection */
    static const int32_t A_TIM8_CR2_CCDS_POS              = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t A_TIM8_CR2_CCUS_POS              = 2;    /** @brief Capture/compare control update selection */
    static const int32_t A_TIM8_CR2_CCPC_POS              = 0;    /** @brief Capture/compare preloaded control */
    static const int32_t A_TIM8_SMCR_SMS_POS              = 0;    /** @brief Slave mode selection */
    static const int32_t A_TIM8_SMCR_TS_POS               = 4;    /** @brief Trigger selection */
    static const int32_t A_TIM8_SMCR_MSM_POS              = 7;    /** @brief Master/Slave mode */
    static const int32_t A_TIM8_SMCR_ETF_POS              = 8;    /** @brief External trigger filter */
    static const int32_t A_TIM8_SMCR_ETPS_POS             = 12;   /** @brief External trigger prescaler */
    static const int32_t A_TIM8_SMCR_ECE_POS              = 14;   /** @brief External clock enable */
    static const int32_t A_TIM8_SMCR_ETP_POS              = 15;   /** @brief External trigger polarity */
    static const int32_t A_TIM8_SMCR_SMS_3_POS            = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t A_TIM8_SMCR_TS_4_3_POS           = 20;   /** @brief Trigger selection - bit 4:3 */
    static const int32_t A_TIM8_DIER_TDE_POS              = 14;   /** @brief Trigger DMA request enable */
    static const int32_t A_TIM8_DIER_COMDE_POS            = 13;   /** @brief COM DMA request enable */
    static const int32_t A_TIM8_DIER_UDE_POS              = 8;    /** @brief Update DMA request enable */
    static const int32_t A_TIM8_DIER_TIE_POS              = 6;    /** @brief Trigger interrupt enable */
    static const int32_t A_TIM8_DIER_UIE_POS              = 0;    /** @brief Update interrupt enable */
    static const int32_t A_TIM8_DIER_BIE_POS              = 7;    /** @brief Break interrupt enable */
    static const int32_t A_TIM8_DIER_COMIE_POS            = 5;    /** @brief COM interrupt enable */
    static const int32_t A_TIM8_SR_SBIF_POS               = 13;   /** @brief System break interrupt flag */
    static const int32_t A_TIM8_SR_B2IF_POS               = 8;    /** @brief Break 2 interrupt flag */
    static const int32_t A_TIM8_SR_BIF_POS                = 7;    /** @brief Break interrupt flag */
    static const int32_t A_TIM8_SR_TIF_POS                = 6;    /** @brief Trigger interrupt flag */
    static const int32_t A_TIM8_SR_COMIF_POS              = 5;    /** @brief COM interrupt flag */
    static const int32_t A_TIM8_SR_UIF_POS                = 0;    /** @brief Update interrupt flag */
    static const int32_t A_TIM8_EGR_UG_POS                = 0;    /** @brief Update generation */
    static const int32_t A_TIM8_EGR_COMG_POS              = 5;    /** @brief Capture/Compare control update generation */
    static const int32_t A_TIM8_EGR_TG_POS                = 6;    /** @brief Trigger generation */
    static const int32_t A_TIM8_EGR_BG_POS                = 7;    /** @brief Break generation */
    static const int32_t A_TIM8_EGR_B2G_POS               = 8;    /** @brief Break 2 generation */
    static const int32_t A_TIM8_CCMR1_INPUT_IC2PCS_POS    = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t A_TIM8_CCMR1_INPUT_ICPCS_POS     = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t A_TIM8_CCMR2_OUTPUT_OC3M_3_POS   = 16;   /** @brief Output compare 3 mode - bit 3 */
    static const int32_t A_TIM8_CCMR2_OUTPUT_OC4M_4_POS   = 24;   /** @brief Output compare 4 mode - bit 3 */
    static const int32_t A_TIM8_CNT_CNT_POS               = 0;    /** @brief Counter value */
    static const int32_t A_TIM8_CNT_UIFCPY_POS            = 31;   /** @brief UIF copy */
    static const int32_t A_TIM8_PSC_PSC_POS               = 0;    /** @brief Prescaler value */
    static const int32_t A_TIM8_ARR_ARR_POS               = 0;    /** @brief Auto-reload value */
    static const int32_t A_TIM8_CCR1_CCR1_POS             = 0;    /** @brief Capture/Compare 1 value */
    static const int32_t A_TIM8_CCR2_CCR2_POS             = 0;    /** @brief Capture/Compare 2 value */
    static const int32_t A_TIM8_CCR3_CCR3_POS             = 0;    /** @brief Capture/Compare value */
    static const int32_t A_TIM8_CCR4_CCR4_POS             = 0;    /** @brief Capture/Compare value */
    static const int32_t A_TIM8_DCR_DBL_POS               = 8;    /** @brief DMA burst length */
    static const int32_t A_TIM8_DCR_DBA_POS               = 0;    /** @brief DMA base address */
    static const int32_t A_TIM8_DMAR_DMAB_POS             = 0;    /** @brief DMA register for burst accesses */
    static const int32_t A_TIM8_RCR_REP_POS               = 0;    /** @brief Repetition counter value */
    static const int32_t A_TIM8_BDTR_DTG_POS              = 0;    /** @brief Dead-time generator setup */
    static const int32_t A_TIM8_BDTR_LOCK_POS             = 8;    /** @brief Lock configuration */
    static const int32_t A_TIM8_BDTR_OSSI_POS             = 10;   /** @brief Off-state selection for idle mode */
    static const int32_t A_TIM8_BDTR_OSSR_POS             = 11;   /** @brief Off-state selection for run mode */
    static const int32_t A_TIM8_BDTR_BKE_POS              = 12;   /** @brief Break enable */
    static const int32_t A_TIM8_BDTR_BKP_POS              = 13;   /** @brief Break polarity */
    static const int32_t A_TIM8_BDTR_AOE_POS              = 14;   /** @brief Automatic output enable */
    static const int32_t A_TIM8_BDTR_MOE_POS              = 15;   /** @brief Main output enable */
    static const int32_t A_TIM8_BDTR_BKF_POS              = 16;   /** @brief Break filter */
    static const int32_t A_TIM8_BDTR_BK2F_POS             = 20;   /** @brief Break 2 filter */
    static const int32_t A_TIM8_BDTR_BK2E_POS             = 24;   /** @brief Break 2 enable */
    static const int32_t A_TIM8_BDTR_BK2P_POS             = 25;   /** @brief Break 2 polarity */
    static const int32_t A_TIM8_CCR5_CCR5_POS             = 0;    /** @brief Capture/Compare 5 value */
    static const int32_t A_TIM8_CRR6_CCR6_POS             = 0;    /** @brief Capture/Compare 6 value */
    static const int32_t A_TIM8_AF1_BKINE_POS             = 0;    /** @brief BRK BKIN input enable */
    static const int32_t A_TIM8_AF1_BKDF1BK0E_POS         = 8;    /** @brief BRK dfsdm1_break[0] enable */
    static const int32_t A_TIM8_AF1_BKINP_POS             = 9;    /** @brief BRK BKIN input polarity */
    static const int32_t A_TIM8_AF1_ETRSEL_POS            = 14;   /** @brief ETR source selection */
    static const int32_t A_TIM8_AF2_BK2INE_POS            = 0;    /** @brief BRK2 BKIN input enable */
    static const int32_t A_TIM8_AF2_BK2DF1BK1E_POS        = 8;    /** @brief BRK2 dfsdm1_break[1] enable */
    static const int32_t A_TIM8_AF2_BK2INP_POS            = 9;    /** @brief BRK2 BKIN2 input polarity */

    /**** @subsection Enumerated A_TIM8 Register Field Positions ****/

    static const int32_t A_TIM8_CR2_OISx_POS[7] = {
      [1] = 8,    /** @brief Output idle state 1 */
      [2] = 10,   /** @brief Output idle state 2 */
      [3] = 12,   /** @brief Output idle state 3 */
      [4] = 14,   /** @brief Output idle state 4 */
      [5] = 16,   /** @brief Output idle state 5 */
      [6] = 18,   /** @brief Output idle state 6 */
    };

    static const int32_t A_TIM8_CR2_OISxN_POS[4] = {
      [1] = 9,    /** @brief Output idle state 1 */
      [2] = 11,   /** @brief Output idle state 2 */
      [3] = 13,   /** @brief Output idle state 3 */
    };

    static const int32_t A_TIM8_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t A_TIM8_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t A_TIM8_SR_CCxIF_POS[7] = {
      [1] = 1,    /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,    /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,    /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,    /** @brief Capture/Compare 4 interrupt flag */
      [5] = 16,   /** @brief Compare 5 interrupt flag */
      [6] = 17,   /** @brief Compare 6 interrupt flag */
    };

    static const int32_t A_TIM8_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t A_TIM8_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t A_TIM8_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief Capture/Compare 1 selection */
      [2] = 8,   /** @brief Capture/Compare 2 selection */
    };

    static const int32_t A_TIM8_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief Output compare 1 fast enable */
      [2] = 10,   /** @brief Output compare 2 fast enable */
    };

    static const int32_t A_TIM8_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief Output compare 1 preload enable */
      [2] = 11,   /** @brief Output compare 2 preload enable */
    };

    static const int32_t A_TIM8_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief Output compare 1 mode */
      [2] = 12,   /** @brief Output compare 2 mode */
    };

    static const int32_t A_TIM8_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief Output compare 1 clear enable */
      [2] = 15,   /** @brief Output compare 2 clear enable */
    };

    static const int32_t A_TIM8_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t A_TIM8_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t A_TIM8_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t A_TIM8_CCER_CCxE_POS[7] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
      [5] = 16,   /** @brief Capture/Compare 5 output enable */
      [6] = 20,   /** @brief Capture/Compare 6 output enable */
    };

    static const int32_t A_TIM8_CCER_CCxP_POS[7] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
      [5] = 17,   /** @brief Capture/Compare 5 output polarity */
      [6] = 21,   /** @brief Capture/Compare 6 output polarity */
    };

    static const int32_t A_TIM8_CCER_CCxNE_POS[4] = {
      [1] = 2,    /** @brief Capture/Compare 1 complementary output enable */
      [2] = 6,    /** @brief Capture/Compare 2 complementary output enable */
      [3] = 10,   /** @brief Capture/Compare 3 complementary output enable */
    };

    static const int32_t A_TIM8_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 complementary output polarity */
    };

    static const int32_t A_TIM8_CCMR3_OUTPUT_OCxM3_POS[7] = {
      [5] = 16,   /** @brief Output compare 5 mode */
      [6] = 24,   /** @brief Output compare 6 mode */
    };

    static const int32_t A_TIM8_CCR5_GC5Cx_POS[4] = {
      [1] = 29,   /** @brief Group channel 5 and channel 1 */
      [2] = 30,   /** @brief Group channel 5 and channel 2 */
      [3] = 31,   /** @brief Group channel 5 and channel 3 */
    };

    static const int32_t A_TIM8_AF1_BKCMPxE_POS[3] = {
      [1] = 1,   /** @brief BRK COMP1 enable */
      [2] = 2,   /** @brief BRK COMP2 enable */
    };

    static const int32_t A_TIM8_AF1_BKCMPxP_POS[3] = {
      [1] = 10,   /** @brief BRK COMP1 input polarity */
      [2] = 11,   /** @brief BRK COMP2 input polarity */
    };

    static const int32_t A_TIM8_AF2_BK2CMPxE_POS[3] = {
      [1] = 1,   /** @brief BRK2 COMP1 enable */
      [2] = 2,   /** @brief BRK2 COMP2 enable */
    };

    static const int32_t A_TIM8_AF2_BK2CMPxP_POS[3] = {
      [1] = 10,   /** @brief BRK2 COMP1 input polarit */
      [2] = 11,   /** @brief BRK2 COMP2 input polarity */
    };

    static const int32_t A_TIM8_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief Selects TI1[0] to TI1[15] input */
      [2] = 8,    /** @brief Selects TI2[0] to TI2[15] input */
      [3] = 16,   /** @brief Selects TI3[0] to TI3[15] input */
      [4] = 24,   /** @brief Selects TI4[0] to TI4[15] input */
    };

    /**********************************************************************************************
     * @section FDCANx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated FDCANx Register Pointers ****/

    static RO_ uint32_t* const FDCANx_FDCAN_CREL_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A000U,   /** @brief FDCAN core release register */
      [2] = (RO_ uint32_t* const)0x4000A400U,   /** @brief FDCAN core release register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_ENDN_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A004U,   /** @brief FDCAN core release register */
      [2] = (RO_ uint32_t* const)0x4000A404U,   /** @brief FDCAN core release register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_DBTP_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A00CU,   /** @brief FDCAN data bit timing and prescaler register */
      [2] = (RO_ uint32_t* const)0x4000A40CU,   /** @brief FDCAN data bit timing and prescaler register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TEST_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A010U,   /** @brief FDCAN test register */
      [2] = (RO_ uint32_t* const)0x4000A410U,   /** @brief FDCAN test register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_RWD_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A014U,   /** @brief FDCAN RAM watchdog register */
      [2] = (RO_ uint32_t* const)0x4000A414U,   /** @brief FDCAN RAM watchdog register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_CCCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A018U,   /** @brief FDCAN CC control register */
      [2] = (RW_ uint32_t* const)0x4000A418U,   /** @brief FDCAN CC control register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_NBTP_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A01CU,   /** @brief FDCAN nominal bit timing and prescaler register */
      [2] = (RW_ uint32_t* const)0x4000A41CU,   /** @brief FDCAN nominal bit timing and prescaler register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TSCC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A020U,   /** @brief FDCAN timestamp counter configuration register */
      [2] = (RW_ uint32_t* const)0x4000A420U,   /** @brief FDCAN timestamp counter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TSCV_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A024U,   /** @brief FDCAN timestamp counter value register */
      [2] = (RW_ uint32_t* const)0x4000A424U,   /** @brief FDCAN timestamp counter value register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TOCC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A028U,   /** @brief FDCAN timeout counter configuration register */
      [2] = (RW_ uint32_t* const)0x4000A428U,   /** @brief FDCAN timeout counter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TOCV_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A02CU,   /** @brief FDCAN timeout counter value register */
      [2] = (RW_ uint32_t* const)0x4000A42CU,   /** @brief FDCAN timeout counter value register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_ECR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A040U,   /** @brief FDCAN error counter register */
      [2] = (RW_ uint32_t* const)0x4000A440U,   /** @brief FDCAN error counter register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_PSR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A044U,   /** @brief FDCAN protocol status register */
      [2] = (RW_ uint32_t* const)0x4000A444U,   /** @brief FDCAN protocol status register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TDCR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A048U,   /** @brief FDCAN transmitter delay compensation register */
      [2] = (RO_ uint32_t* const)0x4000A448U,   /** @brief FDCAN transmitter delay compensation register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_IR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A050U,   /** @brief FDCAN interrupt register */
      [2] = (RO_ uint32_t* const)0x4000A450U,   /** @brief FDCAN interrupt register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_IE_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A054U,   /** @brief FDCAN interrupt enable register */
      [2] = (RO_ uint32_t* const)0x4000A454U,   /** @brief FDCAN interrupt enable register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_ILS_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A058U,   /** @brief FDCAN interrupt line select register */
      [2] = (RO_ uint32_t* const)0x4000A458U,   /** @brief FDCAN interrupt line select register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_ILE_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A05CU,   /** @brief FDCAN interrupt line enable register */
      [2] = (RW_ uint32_t* const)0x4000A45CU,   /** @brief FDCAN interrupt line enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_GFC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A080U,   /** @brief FDCAN global filter configuration register */
      [2] = (RW_ uint32_t* const)0x4000A480U,   /** @brief FDCAN global filter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_SIDFC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A084U,   /** @brief FDCAN standard ID filter configuration register */
      [2] = (RW_ uint32_t* const)0x4000A484U,   /** @brief FDCAN standard ID filter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_XIDFC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A088U,   /** @brief FDCAN extended ID filter configuration register */
      [2] = (RW_ uint32_t* const)0x4000A488U,   /** @brief FDCAN extended ID filter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_XIDAM_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A090U,   /** @brief FDCAN extended ID and mask register */
      [2] = (RW_ uint32_t* const)0x4000A490U,   /** @brief FDCAN extended ID and mask register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_HPMS_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A094U,   /** @brief FDCAN high priority message status register */
      [2] = (RO_ uint32_t* const)0x4000A494U,   /** @brief FDCAN high priority message status register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_NDAT1_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A098U,   /** @brief FDCAN new data 1 register */
      [2] = (RO_ uint32_t* const)0x4000A498U,   /** @brief FDCAN new data 1 register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_NDAT2_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A09CU,   /** @brief FDCAN new data 2 register */
      [2] = (RO_ uint32_t* const)0x4000A49CU,   /** @brief FDCAN new data 2 register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXF0C_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0A0U,   /** @brief FDCAN rx FIFO 0 configuration register */
      [2] = (RW_ uint32_t* const)0x4000A4A0U,   /** @brief FDCAN rx FIFO 0 configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXF0S_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0A4U,   /** @brief FDCAN rx FIFO 0 status register */
      [2] = (RW_ uint32_t* const)0x4000A4A4U,   /** @brief FDCAN rx FIFO 0 status register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXF0A_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0A8U,   /** @brief CAN rx FIFO 0 acknowledge register */
      [2] = (RW_ uint32_t* const)0x4000A4A8U,   /** @brief CAN rx FIFO 0 acknowledge register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXBC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0ACU,   /** @brief FDCAN rx buffer configuration register */
      [2] = (RW_ uint32_t* const)0x4000A4ACU,   /** @brief FDCAN rx buffer configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXF1C_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0B0U,   /** @brief FDCAN rx FIFO 1 configuration register */
      [2] = (RW_ uint32_t* const)0x4000A4B0U,   /** @brief FDCAN rx FIFO 1 configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXF1S_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0B4U,   /** @brief FDCAN rx FIFO 1 status register */
      [2] = (RW_ uint32_t* const)0x4000A4B4U,   /** @brief FDCAN rx FIFO 1 status register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXF1A_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0B8U,   /** @brief FDCAN rx FIFO 1 acknowledge register */
      [2] = (RW_ uint32_t* const)0x4000A4B8U,   /** @brief FDCAN rx FIFO 1 acknowledge register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXESC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0BCU,   /** @brief FDCAN rx buffer element size configuration register */
      [2] = (RW_ uint32_t* const)0x4000A4BCU,   /** @brief FDCAN rx buffer element size configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0C0U,   /** @brief FDCAN tx buffer configuration register */
      [2] = (RW_ uint32_t* const)0x4000A4C0U,   /** @brief FDCAN tx buffer configuration register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TXFQS_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A0C4U,   /** @brief FDCAN tx fifo/queue status register */
      [2] = (RO_ uint32_t* const)0x4000A4C4U,   /** @brief FDCAN tx fifo/queue status register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXESC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0C8U,   /** @brief FDCAN tx buffer element size configuration register */
      [2] = (RW_ uint32_t* const)0x4000A4C8U,   /** @brief FDCAN tx buffer element size configuration register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TXBRP_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A0CCU,   /** @brief FDCAN tx buffer request pending register */
      [2] = (RO_ uint32_t* const)0x4000A4CCU,   /** @brief FDCAN tx buffer request pending register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBAR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0D0U,   /** @brief FDCAN tx buffer add request register */
      [2] = (RW_ uint32_t* const)0x4000A4D0U,   /** @brief FDCAN tx buffer add request register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0D4U,   /** @brief FDCAN tx buffer cancellation request register */
      [2] = (RW_ uint32_t* const)0x4000A4D4U,   /** @brief FDCAN tx buffer cancellation request register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBTO_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0D8U,   /** @brief FDCAN tx buffer transmission occurred register */
      [2] = (RW_ uint32_t* const)0x4000A4D8U,   /** @brief FDCAN tx buffer transmission occurred register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TXBCF_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A0DCU,   /** @brief FDCAN tx buffer cancellation finished register */
      [2] = (RO_ uint32_t* const)0x4000A4DCU,   /** @brief FDCAN tx buffer cancellation finished register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBTIE_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0E0U,   /** @brief FDCAN tx buffer transmission interrupt enable register */
      [2] = (RW_ uint32_t* const)0x4000A4E0U,   /** @brief FDCAN tx buffer transmission interrupt enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBCIE_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0E4U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
      [2] = (RW_ uint32_t* const)0x4000A4E4U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXEFC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0F0U,   /** @brief FDCAN tx event FIFO configuration register */
      [2] = (RW_ uint32_t* const)0x4000A4F0U,   /** @brief FDCAN tx event FIFO configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXEFS_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0F4U,   /** @brief FDCAN tx event FIFO status register */
      [2] = (RW_ uint32_t* const)0x4000A4F4U,   /** @brief FDCAN tx event FIFO status register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXEFA_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A0F8U,   /** @brief FDCAN tx event FIFO acknowledge register */
      [2] = (RW_ uint32_t* const)0x4000A4F8U,   /** @brief FDCAN tx event FIFO acknowledge register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTTMC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A100U,   /** @brief FDCAN TT trigger memory configuration register */
      [2] = (RW_ uint32_t* const)0x4000A500U,   /** @brief FDCAN TT trigger memory configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTRMC_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A104U,   /** @brief FDCAN TT reference message configuration register */
      [2] = (RW_ uint32_t* const)0x4000A504U,   /** @brief FDCAN TT reference message configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTOCF_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A108U,   /** @brief FDCAN TT operation configuration register */
      [2] = (RW_ uint32_t* const)0x4000A508U,   /** @brief FDCAN TT operation configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTMLM_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A10CU,   /** @brief FDCAN TT matrix limits register */
      [2] = (RW_ uint32_t* const)0x4000A50CU,   /** @brief FDCAN TT matrix limits register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TURCF_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A110U,   /** @brief FDCAN TUR configuration register */
      [2] = (RW_ uint32_t* const)0x4000A510U,   /** @brief FDCAN TUR configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTOCN_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A114U,   /** @brief FDCAN TT operation control register */
      [2] = (RW_ uint32_t* const)0x4000A514U,   /** @brief FDCAN TT operation control register */
    };

    static RW_ uint32_t* const FDCANx_CAN_TTGTP_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A118U,   /** @brief FDCAN TT global time preset register */
      [2] = (RW_ uint32_t* const)0x4000A518U,   /** @brief FDCAN TT global time preset register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTTMK_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A11CU,   /** @brief FDCAN TT time mark register */
      [2] = (RW_ uint32_t* const)0x4000A51CU,   /** @brief FDCAN TT time mark register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTIR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A120U,   /** @brief FDCAN TT interrupt register */
      [2] = (RW_ uint32_t* const)0x4000A520U,   /** @brief FDCAN TT interrupt register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTIE_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A124U,   /** @brief FDCAN TT interrupt enable register */
      [2] = (RW_ uint32_t* const)0x4000A524U,   /** @brief FDCAN TT interrupt enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTILS_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A128U,   /** @brief FDCAN TT interrupt line select register */
      [2] = (RW_ uint32_t* const)0x4000A528U,   /** @brief FDCAN TT interrupt line select register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTOST_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A12CU,   /** @brief FDCAN TT operation status register */
      [2] = (RW_ uint32_t* const)0x4000A52CU,   /** @brief FDCAN TT operation status register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TURNA_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A130U,   /** @brief FDCAN TUR numerator actual register */
      [2] = (RO_ uint32_t* const)0x4000A530U,   /** @brief FDCAN TUR numerator actual register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTLGT_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A134U,   /** @brief FDCAN TT local and global time register */
      [2] = (RO_ uint32_t* const)0x4000A534U,   /** @brief FDCAN TT local and global time register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTCTC_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A138U,   /** @brief FDCAN TT cycle time and count register */
      [2] = (RO_ uint32_t* const)0x4000A538U,   /** @brief FDCAN TT cycle time and count register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTCPT_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A13CU,   /** @brief FDCAN TT capture time register */
      [2] = (RO_ uint32_t* const)0x4000A53CU,   /** @brief FDCAN TT capture time register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTCSM_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x4000A140U,   /** @brief FDCAN TT cycle sync mark register */
      [2] = (RO_ uint32_t* const)0x4000A540U,   /** @brief FDCAN TT cycle sync mark register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTTS_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x4000A300U,   /** @brief FDCAN TT trigger select register */
      [2] = (RW_ uint32_t* const)0x4000A700U,   /** @brief FDCAN TT trigger select register */
    };

    /**** @subsection Enumerated FDCANx Register Reset Values ****/

    static const uint32_t FDCANx_FDCAN_CREL_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_CREL register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_CREL register reset value */
    };

    static const uint32_t FDCANx_FDCAN_ENDN_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_ENDN register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_ENDN register reset value */
    };

    static const uint32_t FDCANx_FDCAN_DBTP_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_DBTP register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_DBTP register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TEST_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TEST register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TEST register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RWD_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RWD register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RWD register reset value */
    };

    static const uint32_t FDCANx_FDCAN_CCCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_CCCR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_CCCR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_NBTP_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_NBTP register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_NBTP register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TSCC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TSCC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TSCC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TSCV_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TSCV register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TSCV register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TOCC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TOCC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TOCC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TOCV_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TOCV register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TOCV register reset value */
    };

    static const uint32_t FDCANx_FDCAN_ECR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_ECR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_ECR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_PSR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_PSR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_PSR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TDCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TDCR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TDCR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_IR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_IR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_IR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_IE_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_IE register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_IE register reset value */
    };

    static const uint32_t FDCANx_FDCAN_ILS_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_ILS register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_ILS register reset value */
    };

    static const uint32_t FDCANx_FDCAN_ILE_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_ILE register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_ILE register reset value */
    };

    static const uint32_t FDCANx_FDCAN_GFC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_GFC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_GFC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_SIDFC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_SIDFC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_SIDFC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_XIDFC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_XIDFC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_XIDFC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_XIDAM_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_XIDAM register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_XIDAM register reset value */
    };

    static const uint32_t FDCANx_FDCAN_HPMS_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_HPMS register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_HPMS register reset value */
    };

    static const uint32_t FDCANx_FDCAN_NDAT1_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_NDAT1 register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_NDAT1 register reset value */
    };

    static const uint32_t FDCANx_FDCAN_NDAT2_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_NDAT2 register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_NDAT2 register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXF0C_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXF0C register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXF0C register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXF0S_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXF0S register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXF0S register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXF0A_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXF0A register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXF0A register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXBC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXBC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXBC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXF1C_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXF1C register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXF1C register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXF1S_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXF1S register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXF1S register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXF1A_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXF1A register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXF1A register reset value */
    };

    static const uint32_t FDCANx_FDCAN_RXESC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_RXESC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_RXESC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXFQS_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXFQS register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXFQS register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXESC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXESC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXESC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBRP_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBRP register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBRP register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBAR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBAR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBAR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBCR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBCR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBTO_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBTO register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBTO register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBCF_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBCF register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBCF register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBTIE_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBTIE register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBTIE register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXBCIE_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXBCIE register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXBCIE register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXEFC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXEFC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXEFC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXEFS_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXEFS register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXEFS register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TXEFA_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TXEFA register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TXEFA register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTTMC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTTMC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTTMC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTRMC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTRMC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTRMC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTOCF_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTOCF register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTOCF register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTMLM_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTMLM register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTMLM register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TURCF_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TURCF register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TURCF register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTOCN_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTOCN register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTOCN register reset value */
    };

    static const uint32_t FDCANx_CAN_TTGTP_RST[3] = {
      [1] = 0x00000000U,   /** @brief CAN_TTGTP register reset value */
      [2] = 0x00000000U,   /** @brief CAN_TTGTP register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTTMK_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTTMK register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTTMK register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTIR_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTIR register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTIR register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTIE_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTIE register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTIE register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTILS_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTILS register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTILS register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTOST_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTOST register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTOST register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TURNA_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TURNA register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TURNA register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTLGT_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTLGT register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTLGT register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTCTC_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTCTC register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTCTC register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTCPT_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTCPT register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTCPT register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTCSM_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTCSM register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTCSM register reset value */
    };

    static const uint32_t FDCANx_FDCAN_TTTS_RST[3] = {
      [1] = 0x00000000U,   /** @brief FDCAN_TTTS register reset value */
      [2] = 0x00000000U,   /** @brief FDCAN_TTTS register reset value */
    };

    /**** @subsection Enumerated FDCANx Register Value Types ****/

    typedef uint32_t FDCANx_FDCAN_CREL_t;     /** @brief FDCAN_CREL register value type. */
    typedef uint32_t FDCANx_FDCAN_ENDN_t;     /** @brief FDCAN_ENDN register value type. */
    typedef uint32_t FDCANx_FDCAN_DBTP_t;     /** @brief FDCAN_DBTP register value type. */
    typedef uint32_t FDCANx_FDCAN_TEST_t;     /** @brief FDCAN_TEST register value type. */
    typedef uint32_t FDCANx_FDCAN_RWD_t;      /** @brief FDCAN_RWD register value type. */
    typedef uint32_t FDCANx_FDCAN_CCCR_t;     /** @brief FDCAN_CCCR register value type. */
    typedef uint32_t FDCANx_FDCAN_NBTP_t;     /** @brief FDCAN_NBTP register value type. */
    typedef uint32_t FDCANx_FDCAN_TSCC_t;     /** @brief FDCAN_TSCC register value type. */
    typedef uint32_t FDCANx_FDCAN_TSCV_t;     /** @brief FDCAN_TSCV register value type. */
    typedef uint32_t FDCANx_FDCAN_TOCC_t;     /** @brief FDCAN_TOCC register value type. */
    typedef uint32_t FDCANx_FDCAN_TOCV_t;     /** @brief FDCAN_TOCV register value type. */
    typedef uint32_t FDCANx_FDCAN_ECR_t;      /** @brief FDCAN_ECR register value type. */
    typedef uint32_t FDCANx_FDCAN_PSR_t;      /** @brief FDCAN_PSR register value type. */
    typedef uint32_t FDCANx_FDCAN_TDCR_t;     /** @brief FDCAN_TDCR register value type. */
    typedef uint32_t FDCANx_FDCAN_IR_t;       /** @brief FDCAN_IR register value type. */
    typedef uint32_t FDCANx_FDCAN_IE_t;       /** @brief FDCAN_IE register value type. */
    typedef uint32_t FDCANx_FDCAN_ILS_t;      /** @brief FDCAN_ILS register value type. */
    typedef uint32_t FDCANx_FDCAN_ILE_t;      /** @brief FDCAN_ILE register value type. */
    typedef uint32_t FDCANx_FDCAN_GFC_t;      /** @brief FDCAN_GFC register value type. */
    typedef uint32_t FDCANx_FDCAN_SIDFC_t;    /** @brief FDCAN_SIDFC register value type. */
    typedef uint32_t FDCANx_FDCAN_XIDFC_t;    /** @brief FDCAN_XIDFC register value type. */
    typedef uint32_t FDCANx_FDCAN_XIDAM_t;    /** @brief FDCAN_XIDAM register value type. */
    typedef uint32_t FDCANx_FDCAN_HPMS_t;     /** @brief FDCAN_HPMS register value type. */
    typedef uint32_t FDCANx_FDCAN_NDAT1_t;    /** @brief FDCAN_NDAT1 register value type. */
    typedef uint32_t FDCANx_FDCAN_NDAT2_t;    /** @brief FDCAN_NDAT2 register value type. */
    typedef uint32_t FDCANx_FDCAN_RXF0C_t;    /** @brief FDCAN_RXF0C register value type. */
    typedef uint32_t FDCANx_FDCAN_RXF0S_t;    /** @brief FDCAN_RXF0S register value type. */
    typedef uint32_t FDCANx_FDCAN_RXF0A_t;    /** @brief FDCAN_RXF0A register value type. */
    typedef uint32_t FDCANx_FDCAN_RXBC_t;     /** @brief FDCAN_RXBC register value type. */
    typedef uint32_t FDCANx_FDCAN_RXF1C_t;    /** @brief FDCAN_RXF1C register value type. */
    typedef uint32_t FDCANx_FDCAN_RXF1S_t;    /** @brief FDCAN_RXF1S register value type. */
    typedef uint32_t FDCANx_FDCAN_RXF1A_t;    /** @brief FDCAN_RXF1A register value type. */
    typedef uint32_t FDCANx_FDCAN_RXESC_t;    /** @brief FDCAN_RXESC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBC_t;     /** @brief FDCAN_TXBC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXFQS_t;    /** @brief FDCAN_TXFQS register value type. */
    typedef uint32_t FDCANx_FDCAN_TXESC_t;    /** @brief FDCAN_TXESC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBRP_t;    /** @brief FDCAN_TXBRP register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBAR_t;    /** @brief FDCAN_TXBAR register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBCR_t;    /** @brief FDCAN_TXBCR register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBTO_t;    /** @brief FDCAN_TXBTO register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBCF_t;    /** @brief FDCAN_TXBCF register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBTIE_t;   /** @brief FDCAN_TXBTIE register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBCIE_t;   /** @brief FDCAN_TXBCIE register value type. */
    typedef uint32_t FDCANx_FDCAN_TXEFC_t;    /** @brief FDCAN_TXEFC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXEFS_t;    /** @brief FDCAN_TXEFS register value type. */
    typedef uint32_t FDCANx_FDCAN_TXEFA_t;    /** @brief FDCAN_TXEFA register value type. */
    typedef uint32_t FDCANx_FDCAN_TTTMC_t;    /** @brief FDCAN_TTTMC register value type. */
    typedef uint32_t FDCANx_FDCAN_TTRMC_t;    /** @brief FDCAN_TTRMC register value type. */
    typedef uint32_t FDCANx_FDCAN_TTOCF_t;    /** @brief FDCAN_TTOCF register value type. */
    typedef uint32_t FDCANx_FDCAN_TTMLM_t;    /** @brief FDCAN_TTMLM register value type. */
    typedef uint32_t FDCANx_FDCAN_TURCF_t;    /** @brief FDCAN_TURCF register value type. */
    typedef uint32_t FDCANx_FDCAN_TTOCN_t;    /** @brief FDCAN_TTOCN register value type. */
    typedef uint32_t FDCANx_CAN_TTGTP_t;      /** @brief CAN_TTGTP register value type. */
    typedef uint32_t FDCANx_FDCAN_TTTMK_t;    /** @brief FDCAN_TTTMK register value type. */
    typedef uint32_t FDCANx_FDCAN_TTIR_t;     /** @brief FDCAN_TTIR register value type. */
    typedef uint32_t FDCANx_FDCAN_TTIE_t;     /** @brief FDCAN_TTIE register value type. */
    typedef uint32_t FDCANx_FDCAN_TTILS_t;    /** @brief FDCAN_TTILS register value type. */
    typedef uint32_t FDCANx_FDCAN_TTOST_t;    /** @brief FDCAN_TTOST register value type. */
    typedef uint32_t FDCANx_FDCAN_TURNA_t;    /** @brief FDCAN_TURNA register value type. */
    typedef uint32_t FDCANx_FDCAN_TTLGT_t;    /** @brief FDCAN_TTLGT register value type. */
    typedef uint32_t FDCANx_FDCAN_TTCTC_t;    /** @brief FDCAN_TTCTC register value type. */
    typedef uint32_t FDCANx_FDCAN_TTCPT_t;    /** @brief FDCAN_TTCPT register value type. */
    typedef uint32_t FDCANx_FDCAN_TTCSM_t;    /** @brief FDCAN_TTCSM register value type. */
    typedef uint32_t FDCANx_FDCAN_TTTS_t;     /** @brief FDCAN_TTTS register value type. */

    /**** @subsection Enumerated FDCANx Register Pointer Types ****/

    typedef uint32_t* const FDCANx_FDCAN_CREL_PTR_t;     /** @brief FDCAN_CREL register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_ENDN_PTR_t;     /** @brief FDCAN_ENDN register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_DBTP_PTR_t;     /** @brief FDCAN_DBTP register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TEST_PTR_t;     /** @brief FDCAN_TEST register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RWD_PTR_t;      /** @brief FDCAN_RWD register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_CCCR_PTR_t;     /** @brief FDCAN_CCCR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_NBTP_PTR_t;     /** @brief FDCAN_NBTP register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TSCC_PTR_t;     /** @brief FDCAN_TSCC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TSCV_PTR_t;     /** @brief FDCAN_TSCV register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TOCC_PTR_t;     /** @brief FDCAN_TOCC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TOCV_PTR_t;     /** @brief FDCAN_TOCV register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_ECR_PTR_t;      /** @brief FDCAN_ECR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_PSR_PTR_t;      /** @brief FDCAN_PSR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TDCR_PTR_t;     /** @brief FDCAN_TDCR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_IR_PTR_t;       /** @brief FDCAN_IR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_IE_PTR_t;       /** @brief FDCAN_IE register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_ILS_PTR_t;      /** @brief FDCAN_ILS register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_ILE_PTR_t;      /** @brief FDCAN_ILE register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_GFC_PTR_t;      /** @brief FDCAN_GFC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_SIDFC_PTR_t;    /** @brief FDCAN_SIDFC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_XIDFC_PTR_t;    /** @brief FDCAN_XIDFC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_XIDAM_PTR_t;    /** @brief FDCAN_XIDAM register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_HPMS_PTR_t;     /** @brief FDCAN_HPMS register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_NDAT1_PTR_t;    /** @brief FDCAN_NDAT1 register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_NDAT2_PTR_t;    /** @brief FDCAN_NDAT2 register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXF0C_PTR_t;    /** @brief FDCAN_RXF0C register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXF0S_PTR_t;    /** @brief FDCAN_RXF0S register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXF0A_PTR_t;    /** @brief FDCAN_RXF0A register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXBC_PTR_t;     /** @brief FDCAN_RXBC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXF1C_PTR_t;    /** @brief FDCAN_RXF1C register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXF1S_PTR_t;    /** @brief FDCAN_RXF1S register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXF1A_PTR_t;    /** @brief FDCAN_RXF1A register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_RXESC_PTR_t;    /** @brief FDCAN_RXESC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBC_PTR_t;     /** @brief FDCAN_TXBC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXFQS_PTR_t;    /** @brief FDCAN_TXFQS register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXESC_PTR_t;    /** @brief FDCAN_TXESC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBRP_PTR_t;    /** @brief FDCAN_TXBRP register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBAR_PTR_t;    /** @brief FDCAN_TXBAR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBCR_PTR_t;    /** @brief FDCAN_TXBCR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBTO_PTR_t;    /** @brief FDCAN_TXBTO register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBCF_PTR_t;    /** @brief FDCAN_TXBCF register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBTIE_PTR_t;   /** @brief FDCAN_TXBTIE register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXBCIE_PTR_t;   /** @brief FDCAN_TXBCIE register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXEFC_PTR_t;    /** @brief FDCAN_TXEFC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXEFS_PTR_t;    /** @brief FDCAN_TXEFS register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TXEFA_PTR_t;    /** @brief FDCAN_TXEFA register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTTMC_PTR_t;    /** @brief FDCAN_TTTMC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTRMC_PTR_t;    /** @brief FDCAN_TTRMC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTOCF_PTR_t;    /** @brief FDCAN_TTOCF register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTMLM_PTR_t;    /** @brief FDCAN_TTMLM register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TURCF_PTR_t;    /** @brief FDCAN_TURCF register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTOCN_PTR_t;    /** @brief FDCAN_TTOCN register pointer type. */
    typedef uint32_t* const FDCANx_CAN_TTGTP_PTR_t;      /** @brief CAN_TTGTP register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTTMK_PTR_t;    /** @brief FDCAN_TTTMK register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTIR_PTR_t;     /** @brief FDCAN_TTIR register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTIE_PTR_t;     /** @brief FDCAN_TTIE register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTILS_PTR_t;    /** @brief FDCAN_TTILS register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTOST_PTR_t;    /** @brief FDCAN_TTOST register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TURNA_PTR_t;    /** @brief FDCAN_TURNA register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTLGT_PTR_t;    /** @brief FDCAN_TTLGT register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTCTC_PTR_t;    /** @brief FDCAN_TTCTC register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTCPT_PTR_t;    /** @brief FDCAN_TTCPT register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTCSM_PTR_t;    /** @brief FDCAN_TTCSM register pointer type. */
    typedef uint32_t* const FDCANx_FDCAN_TTTS_PTR_t;     /** @brief FDCAN_TTTS register pointer type. */

    /**** @subsection FDCANx Register Field Masks ****/

    static const uint32_t FDCANx_FDCAN_CREL_REL_MASK       = 0xF0000000U;   /** @brief Core release */
    static const uint32_t FDCANx_FDCAN_CREL_STEP_MASK      = 0x0F000000U;   /** @brief Step of core release */
    static const uint32_t FDCANx_FDCAN_CREL_SUBSTEP_MASK   = 0x00F00000U;   /** @brief Sub-step of core release */
    static const uint32_t FDCANx_FDCAN_CREL_YEAR_MASK      = 0x000F0000U;   /** @brief Timestamp year */
    static const uint32_t FDCANx_FDCAN_CREL_MON_MASK       = 0x0000FF00U;   /** @brief Timestamp month */
    static const uint32_t FDCANx_FDCAN_CREL_DAY_MASK       = 0x000000FFU;   /** @brief Timestamp day */
    static const uint32_t FDCANx_FDCAN_DBTP_DSJW_MASK      = 0x0000000FU;   /** @brief Synchronization jump width */
    static const uint32_t FDCANx_FDCAN_DBTP_DBRP_MASK      = 0x001F0000U;   /** @brief Data bit rate prescaler */
    static const uint32_t FDCANx_FDCAN_DBTP_TDC_MASK       = 0x00800000U;   /** @brief Transceiver delay compensation */
    static const uint32_t FDCANx_FDCAN_TEST_LBCK_MASK      = 0x00000010U;   /** @brief Loop back mode */
    static const uint32_t FDCANx_FDCAN_TEST_TX_MASK        = 0x00000060U;   /** @brief Loop back mode */
    static const uint32_t FDCANx_FDCAN_TEST_RX_MASK        = 0x00000080U;   /** @brief Control of transmit pin */
    static const uint32_t FDCANx_FDCAN_RWD_WDV_MASK        = 0x0000FF00U;   /** @brief Watchdog value */
    static const uint32_t FDCANx_FDCAN_RWD_WDC_MASK        = 0x000000FFU;   /** @brief Watchdog configuration */
    static const uint32_t FDCANx_FDCAN_CCCR_INIT_MASK      = 0x00000001U;   /** @brief Initialization */
    static const uint32_t FDCANx_FDCAN_CCCR_CCE_MASK       = 0x00000002U;   /** @brief Configuration change enable */
    static const uint32_t FDCANx_FDCAN_CCCR_ASM_MASK       = 0x00000004U;   /** @brief ASM restricted operation mode */
    static const uint32_t FDCANx_FDCAN_CCCR_CSA_MASK       = 0x00000008U;   /** @brief Clock stop acknowledge */
    static const uint32_t FDCANx_FDCAN_CCCR_CSR_MASK       = 0x00000010U;   /** @brief Clock stop request */
    static const uint32_t FDCANx_FDCAN_CCCR_MON_MASK       = 0x00000020U;   /** @brief Bus monitoring mode */
    static const uint32_t FDCANx_FDCAN_CCCR_DAR_MASK       = 0x00000040U;   /** @brief Disable automatic retransmission */
    static const uint32_t FDCANx_FDCAN_CCCR_TEST_MASK      = 0x00000080U;   /** @brief Test mode enable */
    static const uint32_t FDCANx_FDCAN_CCCR_FDOE_MASK      = 0x00000100U;   /** @brief FD operation enable */
    static const uint32_t FDCANx_FDCAN_CCCR_BSE_MASK       = 0x00000200U;   /** @brief FDCAN bit rate switching */
    static const uint32_t FDCANx_FDCAN_CCCR_PXHD_MASK      = 0x00001000U;   /** @brief Protocol exception handling disable */
    static const uint32_t FDCANx_FDCAN_CCCR_EFBI_MASK      = 0x00002000U;   /** @brief Edge filtering during bus integration */
    static const uint32_t FDCANx_FDCAN_CCCR_TXP_MASK       = 0x00004000U;   /** @brief TXP */
    static const uint32_t FDCANx_FDCAN_CCCR_NISO_MASK      = 0x00008000U;   /** @brief Non ISO operation */
    static const uint32_t FDCANx_FDCAN_NBTP_NSJW_MASK      = 0xFE000000U;   /** @brief NSJW: nominal (re)synchronization jump width */
    static const uint32_t FDCANx_FDCAN_NBTP_NBRP_MASK      = 0x01FF0000U;   /** @brief Bit rate prescaler */
    static const uint32_t FDCANx_FDCAN_NBTP_NTSEG1_MASK    = 0x0000FF00U;   /** @brief Nominal time segment before sample point */
    static const uint32_t FDCANx_FDCAN_NBTP_TSEG2_MASK     = 0x0000007FU;   /** @brief Nominal time segment after sample point */
    static const uint32_t FDCANx_FDCAN_TSCC_TCP_MASK       = 0x000F0000U;   /** @brief Timestamp counter prescaler */
    static const uint32_t FDCANx_FDCAN_TSCC_TSS_MASK       = 0x00000003U;   /** @brief Timestamp select */
    static const uint32_t FDCANx_FDCAN_TSCV_TSC_MASK       = 0x0000FFFFU;   /** @brief Timestamp counter */
    static const uint32_t FDCANx_FDCAN_TOCC_ETOC_MASK      = 0x00000001U;   /** @brief Enable timeout counter */
    static const uint32_t FDCANx_FDCAN_TOCC_TOS_MASK       = 0x00000006U;   /** @brief Timeout select */
    static const uint32_t FDCANx_FDCAN_TOCC_TOP_MASK       = 0xFFFF0000U;   /** @brief Timeout period */
    static const uint32_t FDCANx_FDCAN_TOCV_TOC_MASK       = 0x0000FFFFU;   /** @brief Timeout counter */
    static const uint32_t FDCANx_FDCAN_ECR_CEL_MASK        = 0x00FF0000U;   /** @brief AN error logging */
    static const uint32_t FDCANx_FDCAN_ECR_RP_MASK         = 0x00008000U;   /** @brief Receive error passive */
    static const uint32_t FDCANx_FDCAN_ECR_TREC_MASK       = 0x00007F00U;   /** @brief Receive error counter */
    static const uint32_t FDCANx_FDCAN_ECR_TEC_MASK        = 0x000000FFU;   /** @brief Transmit error counter */
    static const uint32_t FDCANx_FDCAN_PSR_LEC_MASK        = 0x00000007U;   /** @brief Last error code */
    static const uint32_t FDCANx_FDCAN_PSR_ACT_MASK        = 0x00000018U;   /** @brief Activity */
    static const uint32_t FDCANx_FDCAN_PSR_EP_MASK         = 0x00000020U;   /** @brief Error passive */
    static const uint32_t FDCANx_FDCAN_PSR_EW_MASK         = 0x00000040U;   /** @brief Warning status */
    static const uint32_t FDCANx_FDCAN_PSR_BO_MASK         = 0x00000080U;   /** @brief Bus_Off status */
    static const uint32_t FDCANx_FDCAN_PSR_DLEC_MASK       = 0x00000700U;   /** @brief Data last error code */
    static const uint32_t FDCANx_FDCAN_PSR_RESI_MASK       = 0x00000800U;   /** @brief ESI flag of last received FDCAN message */
    static const uint32_t FDCANx_FDCAN_PSR_RBRS_MASK       = 0x00001000U;   /** @brief BRS flag of last received FDCAN message */
    static const uint32_t FDCANx_FDCAN_PSR_REDL_MASK       = 0x00002000U;   /** @brief Received FDCAN message */
    static const uint32_t FDCANx_FDCAN_PSR_PXE_MASK        = 0x00004000U;   /** @brief Protocol exception event */
    static const uint32_t FDCANx_FDCAN_PSR_TDCV_MASK       = 0x007F0000U;   /** @brief Transmitter delay compensation value */
    static const uint32_t FDCANx_FDCAN_TDCR_TDCF_MASK      = 0x0000007FU;   /** @brief Transmitter delay compensation filter window length */
    static const uint32_t FDCANx_FDCAN_TDCR_TDCO_MASK      = 0x00007F00U;   /** @brief Transmitter delay compensation offset */
    static const uint32_t FDCANx_FDCAN_IR_HPM_MASK         = 0x00000100U;   /** @brief High priority message */
    static const uint32_t FDCANx_FDCAN_IR_TC_MASK          = 0x00000200U;   /** @brief Transmission completed */
    static const uint32_t FDCANx_FDCAN_IR_TCF_MASK         = 0x00000400U;   /** @brief Transmission cancellation finished */
    static const uint32_t FDCANx_FDCAN_IR_TEF_MASK         = 0x00000800U;   /** @brief Tx FIFO empty */
    static const uint32_t FDCANx_FDCAN_IR_TEFN_MASK        = 0x00001000U;   /** @brief Tx event FIFO new entry */
    static const uint32_t FDCANx_FDCAN_IR_TEFW_MASK        = 0x00002000U;   /** @brief Tx event FIFO watermark reached */
    static const uint32_t FDCANx_FDCAN_IR_TEFF_MASK        = 0x00004000U;   /** @brief Tx event FIFO full */
    static const uint32_t FDCANx_FDCAN_IR_TEFL_MASK        = 0x00008000U;   /** @brief Tx event FIFO element lost */
    static const uint32_t FDCANx_FDCAN_IR_TSW_MASK         = 0x00010000U;   /** @brief Timestamp wraparound */
    static const uint32_t FDCANx_FDCAN_IR_MRAF_MASK        = 0x00020000U;   /** @brief Message RAM access failure */
    static const uint32_t FDCANx_FDCAN_IR_TOO_MASK         = 0x00040000U;   /** @brief Timeout occurred */
    static const uint32_t FDCANx_FDCAN_IR_DRX_MASK         = 0x00080000U;   /** @brief Message stored to dedicated rx buffer */
    static const uint32_t FDCANx_FDCAN_IR_ELO_MASK         = 0x00400000U;   /** @brief Error logging overflow */
    static const uint32_t FDCANx_FDCAN_IR_EP_MASK          = 0x00800000U;   /** @brief Error passive */
    static const uint32_t FDCANx_FDCAN_IR_EW_MASK          = 0x01000000U;   /** @brief Warning status */
    static const uint32_t FDCANx_FDCAN_IR_BO_MASK          = 0x02000000U;   /** @brief Bus_Off status */
    static const uint32_t FDCANx_FDCAN_IR_WDI_MASK         = 0x04000000U;   /** @brief Watchdog interrupt */
    static const uint32_t FDCANx_FDCAN_IR_PEA_MASK         = 0x08000000U;   /** @brief Protocol error in arbitration phase (nominal bit time is used) */
    static const uint32_t FDCANx_FDCAN_IR_PED_MASK         = 0x10000000U;   /** @brief Protocol error in data phase (data bit time is used) */
    static const uint32_t FDCANx_FDCAN_IR_ARA_MASK         = 0x20000000U;   /** @brief Access to reserved address */
    static const uint32_t FDCANx_FDCAN_IE_HPME_MASK        = 0x00000100U;   /** @brief High priority message enable */
    static const uint32_t FDCANx_FDCAN_IE_TCE_MASK         = 0x00000200U;   /** @brief Transmission completed enable */
    static const uint32_t FDCANx_FDCAN_IE_TCFE_MASK        = 0x00000400U;   /** @brief Transmission cancellation finished enable */
    static const uint32_t FDCANx_FDCAN_IE_TEFE_MASK        = 0x00000800U;   /** @brief Tx FIFO empty enable */
    static const uint32_t FDCANx_FDCAN_IE_TEFNE_MASK       = 0x00001000U;   /** @brief Tx event FIFO new entry enable */
    static const uint32_t FDCANx_FDCAN_IE_TEFWE_MASK       = 0x00002000U;   /** @brief Tx event FIFO watermark reached enable */
    static const uint32_t FDCANx_FDCAN_IE_TEFFE_MASK       = 0x00004000U;   /** @brief Tx event FIFO full enable */
    static const uint32_t FDCANx_FDCAN_IE_TEFLE_MASK       = 0x00008000U;   /** @brief Tx event FIFO element lost enable */
    static const uint32_t FDCANx_FDCAN_IE_TSWE_MASK        = 0x00010000U;   /** @brief Timestamp wraparound enable */
    static const uint32_t FDCANx_FDCAN_IE_MRAFE_MASK       = 0x00020000U;   /** @brief Message RAM access failure enable */
    static const uint32_t FDCANx_FDCAN_IE_TOOE_MASK        = 0x00040000U;   /** @brief Timeout occurred enable */
    static const uint32_t FDCANx_FDCAN_IE_DRXE_MASK        = 0x00080000U;   /** @brief Message stored to dedicated rx buffer enable */
    static const uint32_t FDCANx_FDCAN_IE_BECE_MASK        = 0x00100000U;   /** @brief Bit error corrected interrupt enable */
    static const uint32_t FDCANx_FDCAN_IE_BEUE_MASK        = 0x00200000U;   /** @brief Bit error uncorrected interrupt enable */
    static const uint32_t FDCANx_FDCAN_IE_ELOE_MASK        = 0x00400000U;   /** @brief Error logging overflow enable */
    static const uint32_t FDCANx_FDCAN_IE_EPE_MASK         = 0x00800000U;   /** @brief Error passive enable */
    static const uint32_t FDCANx_FDCAN_IE_EWE_MASK         = 0x01000000U;   /** @brief Warning status enable */
    static const uint32_t FDCANx_FDCAN_IE_BOE_MASK         = 0x02000000U;   /** @brief Bus_Off status enable */
    static const uint32_t FDCANx_FDCAN_IE_WDIE_MASK        = 0x04000000U;   /** @brief Watchdog interrupt enable */
    static const uint32_t FDCANx_FDCAN_IE_PEAE_MASK        = 0x08000000U;   /** @brief Protocol error in arbitration phase enable */
    static const uint32_t FDCANx_FDCAN_IE_PEDE_MASK        = 0x10000000U;   /** @brief Protocol error in data phase enable */
    static const uint32_t FDCANx_FDCAN_IE_ARAE_MASK        = 0x20000000U;   /** @brief Access to reserved address enable */
    static const uint32_t FDCANx_FDCAN_ILS_HPML_MASK       = 0x00000100U;   /** @brief High priority message interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TCL_MASK        = 0x00000200U;   /** @brief Transmission completed interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TCFL_MASK       = 0x00000400U;   /** @brief Transmission cancellation finished interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TEFL_MASK       = 0x00000800U;   /** @brief Tx FIFO empty interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TEFNL_MASK      = 0x00001000U;   /** @brief Tx event FIFO new entry interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TEFWL_MASK      = 0x00002000U;   /** @brief Tx event FIFO watermark reached interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TEFFL_MASK      = 0x00004000U;   /** @brief Tx event FIFO full interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TEFLL_MASK      = 0x00008000U;   /** @brief Tx event FIFO element lost interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TSWL_MASK       = 0x00010000U;   /** @brief Timestamp wraparound interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_MRAFL_MASK      = 0x00020000U;   /** @brief Message RAM access failure interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_TOOL_MASK       = 0x00040000U;   /** @brief Timeout occurred interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_DRXL_MASK       = 0x00080000U;   /** @brief Message stored to dedicated rx buffer interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_BECL_MASK       = 0x00100000U;   /** @brief Bit error corrected interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_BEUL_MASK       = 0x00200000U;   /** @brief Bit error uncorrected interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_ELOL_MASK       = 0x00400000U;   /** @brief Error logging overflow interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_EPL_MASK        = 0x00800000U;   /** @brief Error passive interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_EWL_MASK        = 0x01000000U;   /** @brief Warning status interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_BOL_MASK        = 0x02000000U;   /** @brief Bus_Off status */
    static const uint32_t FDCANx_FDCAN_ILS_WDIL_MASK       = 0x04000000U;   /** @brief Watchdog interrupt line */
    static const uint32_t FDCANx_FDCAN_ILS_PEAL_MASK       = 0x08000000U;   /** @brief Protocol error in arbitration phase line */
    static const uint32_t FDCANx_FDCAN_ILS_PEDL_MASK       = 0x10000000U;   /** @brief Protocol error in data phase line */
    static const uint32_t FDCANx_FDCAN_ILS_ARAL_MASK       = 0x20000000U;   /** @brief Access to reserved address line */
    static const uint32_t FDCANx_FDCAN_GFC_RRFE_MASK       = 0x00000001U;   /** @brief Reject remote frames extended */
    static const uint32_t FDCANx_FDCAN_GFC_RRFS_MASK       = 0x00000002U;   /** @brief Reject remote frames standard */
    static const uint32_t FDCANx_FDCAN_GFC_ANFE_MASK       = 0x0000000CU;   /** @brief Accept non-matching frames extended */
    static const uint32_t FDCANx_FDCAN_GFC_ANFS_MASK       = 0x00000030U;   /** @brief Accept non-matching frames standard */
    static const uint32_t FDCANx_FDCAN_SIDFC_FLSSA_MASK    = 0x0000FFFCU;   /** @brief Filter list standard start address */
    static const uint32_t FDCANx_FDCAN_SIDFC_LSS_MASK      = 0x00FF0000U;   /** @brief List size standard */
    static const uint32_t FDCANx_FDCAN_XIDFC_FLESA_MASK    = 0x0000FFFCU;   /** @brief Filter list standard start address */
    static const uint32_t FDCANx_FDCAN_XIDFC_LSE_MASK      = 0x00FF0000U;   /** @brief List size extended */
    static const uint32_t FDCANx_FDCAN_XIDAM_EIDM_MASK     = 0x1FFFFFFFU;   /** @brief Extended ID mask */
    static const uint32_t FDCANx_FDCAN_HPMS_BIDX_MASK      = 0x0000003FU;   /** @brief Buffer index */
    static const uint32_t FDCANx_FDCAN_HPMS_MSI_MASK       = 0x000000C0U;   /** @brief Message storage indicator */
    static const uint32_t FDCANx_FDCAN_HPMS_FIDX_MASK      = 0x00007F00U;   /** @brief Filter index */
    static const uint32_t FDCANx_FDCAN_HPMS_FLST_MASK      = 0x00008000U;   /** @brief Filter list */
    static const uint32_t FDCANx_FDCAN_RXF0C_F0SA_MASK     = 0x0000FFFCU;   /** @brief Rx FIFO 0 start address */
    static const uint32_t FDCANx_FDCAN_RXF0C_F0S_MASK      = 0x00FF0000U;   /** @brief Rx FIFO 0 size */
    static const uint32_t FDCANx_FDCAN_RXF0C_F0WM_MASK     = 0xFF000000U;   /** @brief FIFO 0 watermark */
    static const uint32_t FDCANx_FDCAN_RXF0S_F0FL_MASK     = 0x0000007FU;   /** @brief Rx FIFO 0 fill level */
    static const uint32_t FDCANx_FDCAN_RXF0S_F0G_MASK      = 0x00003F00U;   /** @brief Rx FIFO 0 get index */
    static const uint32_t FDCANx_FDCAN_RXF0S_F0P_MASK      = 0x003F0000U;   /** @brief Rx FIFO 0 put index */
    static const uint32_t FDCANx_FDCAN_RXF0S_F0F_MASK      = 0x01000000U;   /** @brief Rx FIFO 0 full */
    static const uint32_t FDCANx_FDCAN_RXF0S_RF0L_MASK     = 0x02000000U;   /** @brief Rx FIFO 0 message lost */
    static const uint32_t FDCANx_FDCAN_RXF0A_FA01_MASK     = 0x0000003FU;   /** @brief Rx FIFO 0 acknowledge index */
    static const uint32_t FDCANx_FDCAN_RXBC_RBSA_MASK      = 0x0000FFFCU;   /** @brief Rx buffer start address */
    static const uint32_t FDCANx_FDCAN_RXF1C_F1SA_MASK     = 0x0000FFFCU;   /** @brief Rx FIFO 1 start address */
    static const uint32_t FDCANx_FDCAN_RXF1C_F1S_MASK      = 0x007F0000U;   /** @brief Rx FIFO 1 size */
    static const uint32_t FDCANx_FDCAN_RXF1C_F1WM_MASK     = 0x7F000000U;   /** @brief Rx FIFO 1 watermark */
    static const uint32_t FDCANx_FDCAN_RXF1S_F1FL_MASK     = 0x0000007FU;   /** @brief Rx FIFO 1 fill level */
    static const uint32_t FDCANx_FDCAN_RXF1S_F1GI_MASK     = 0x00007F00U;   /** @brief Rx FIFO 1 get index */
    static const uint32_t FDCANx_FDCAN_RXF1S_F1PI_MASK     = 0x007F0000U;   /** @brief Rx FIFO 1 put index */
    static const uint32_t FDCANx_FDCAN_RXF1S_F1F_MASK      = 0x01000000U;   /** @brief Rx FIFO 1 full */
    static const uint32_t FDCANx_FDCAN_RXF1S_RF1L_MASK     = 0x02000000U;   /** @brief Rx FIFO 1 message lost */
    static const uint32_t FDCANx_FDCAN_RXF1S_DMS_MASK      = 0xC0000000U;   /** @brief Debug message status */
    static const uint32_t FDCANx_FDCAN_RXF1A_F1AI_MASK     = 0x0000003FU;   /** @brief Rx FIFO 1 acknowledge index */
    static const uint32_t FDCANx_FDCAN_RXESC_RBDS_MASK     = 0x00000700U;   /** @brief Rx buffer data field size: */
    static const uint32_t FDCANx_FDCAN_TXBC_TBSA_MASK      = 0x0000FFFCU;   /** @brief Tx buffers start address */
    static const uint32_t FDCANx_FDCAN_TXBC_NDTB_MASK      = 0x003F0000U;   /** @brief Number of dedicated transmit buffers */
    static const uint32_t FDCANx_FDCAN_TXBC_TFQS_MASK      = 0x3F000000U;   /** @brief Transmit fifo/queue size */
    static const uint32_t FDCANx_FDCAN_TXBC_TFQM_MASK      = 0x40000000U;   /** @brief Tx fifo/queue mode */
    static const uint32_t FDCANx_FDCAN_TXFQS_TFFL_MASK     = 0x0000003FU;   /** @brief Tx FIFO free level */
    static const uint32_t FDCANx_FDCAN_TXFQS_TFGI_MASK     = 0x00001F00U;   /** @brief TFGI */
    static const uint32_t FDCANx_FDCAN_TXFQS_TFQPI_MASK    = 0x001F0000U;   /** @brief Tx fifo/queue put index */
    static const uint32_t FDCANx_FDCAN_TXFQS_TFQF_MASK     = 0x00200000U;   /** @brief Tx fifo/queue full */
    static const uint32_t FDCANx_FDCAN_TXESC_TBDS_MASK     = 0x00000007U;   /** @brief Tx buffer data field size: */
    static const uint32_t FDCANx_FDCAN_TXEFC_EFSA_MASK     = 0x0000FFFCU;   /** @brief Event FIFO start address */
    static const uint32_t FDCANx_FDCAN_TXEFC_EFS_MASK      = 0x003F0000U;   /** @brief Event FIFO size */
    static const uint32_t FDCANx_FDCAN_TXEFC_EFWM_MASK     = 0x3F000000U;   /** @brief Event FIFO watermark */
    static const uint32_t FDCANx_FDCAN_TXEFS_EFFL_MASK     = 0x0000003FU;   /** @brief Event FIFO fill level */
    static const uint32_t FDCANx_FDCAN_TXEFS_EFGI_MASK     = 0x00001F00U;   /** @brief Event FIFO get index. */
    static const uint32_t FDCANx_FDCAN_TXEFS_EFF_MASK      = 0x01000000U;   /** @brief Event FIFO full. */
    static const uint32_t FDCANx_FDCAN_TXEFS_TEFL_MASK     = 0x02000000U;   /** @brief Tx event FIFO element lost. */
    static const uint32_t FDCANx_FDCAN_TXEFA_EFAI_MASK     = 0x0000001FU;   /** @brief Event FIFO acknowledge index */
    static const uint32_t FDCANx_FDCAN_TTTMC_TMSA_MASK     = 0x0000FFFCU;   /** @brief Trigger memory start address */
    static const uint32_t FDCANx_FDCAN_TTTMC_TME_MASK      = 0x007F0000U;   /** @brief Trigger memory elements */
    static const uint32_t FDCANx_FDCAN_TTRMC_RID_MASK      = 0x1FFFFFFFU;   /** @brief Reference identifier. */
    static const uint32_t FDCANx_FDCAN_TTRMC_XTD_MASK      = 0x40000000U;   /** @brief Extended identifier */
    static const uint32_t FDCANx_FDCAN_TTRMC_RMPS_MASK     = 0x80000000U;   /** @brief Reference message payload select */
    static const uint32_t FDCANx_FDCAN_TTOCF_OM_MASK       = 0x00000003U;   /** @brief Operation mode */
    static const uint32_t FDCANx_FDCAN_TTOCF_GEN_MASK      = 0x00000008U;   /** @brief Gap enable */
    static const uint32_t FDCANx_FDCAN_TTOCF_TM_MASK       = 0x00000010U;   /** @brief Time master */
    static const uint32_t FDCANx_FDCAN_TTOCF_LDSDL_MASK    = 0x000000E0U;   /** @brief LD of synchronization deviation limit */
    static const uint32_t FDCANx_FDCAN_TTOCF_IRTO_MASK     = 0x00007F00U;   /** @brief Initial reference trigger offset */
    static const uint32_t FDCANx_FDCAN_TTOCF_EECS_MASK     = 0x00008000U;   /** @brief Enable external clock synchronization */
    static const uint32_t FDCANx_FDCAN_TTOCF_AWL_MASK      = 0x00FF0000U;   /** @brief Application watchdog limit */
    static const uint32_t FDCANx_FDCAN_TTOCF_EGTF_MASK     = 0x01000000U;   /** @brief Enable global time filtering */
    static const uint32_t FDCANx_FDCAN_TTOCF_ECC_MASK      = 0x02000000U;   /** @brief Enable clock calibration */
    static const uint32_t FDCANx_FDCAN_TTOCF_EVTP_MASK     = 0x04000000U;   /** @brief Event trigger polarity */
    static const uint32_t FDCANx_FDCAN_TTMLM_CCM_MASK      = 0x0000003FU;   /** @brief Cycle count max */
    static const uint32_t FDCANx_FDCAN_TTMLM_CSS_MASK      = 0x000000C0U;   /** @brief Cycle start synchronization */
    static const uint32_t FDCANx_FDCAN_TTMLM_TXEW_MASK     = 0x00000F00U;   /** @brief Tx enable window */
    static const uint32_t FDCANx_FDCAN_TTMLM_ENTT_MASK     = 0x0FFF0000U;   /** @brief Expected number of tx triggers */
    static const uint32_t FDCANx_FDCAN_TURCF_NCL_MASK      = 0x0000FFFFU;   /** @brief Numerator configuration low. */
    static const uint32_t FDCANx_FDCAN_TURCF_DC_MASK       = 0x3FFF0000U;   /** @brief Denominator configuration. */
    static const uint32_t FDCANx_FDCAN_TURCF_ELT_MASK      = 0x80000000U;   /** @brief Enable local time */
    static const uint32_t FDCANx_FDCAN_TTOCN_SGT_MASK      = 0x00000001U;   /** @brief Set global time */
    static const uint32_t FDCANx_FDCAN_TTOCN_ECS_MASK      = 0x00000002U;   /** @brief External clock synchronization */
    static const uint32_t FDCANx_FDCAN_TTOCN_SWP_MASK      = 0x00000004U;   /** @brief Stop watch polarity */
    static const uint32_t FDCANx_FDCAN_TTOCN_SWS_MASK      = 0x00000018U;   /** @brief Stop watch source. */
    static const uint32_t FDCANx_FDCAN_TTOCN_RTIE_MASK     = 0x00000020U;   /** @brief Register time mark interrupt pulse enable */
    static const uint32_t FDCANx_FDCAN_TTOCN_TMC_MASK      = 0x000000C0U;   /** @brief Register time mark compare */
    static const uint32_t FDCANx_FDCAN_TTOCN_TTIE_MASK     = 0x00000100U;   /** @brief Trigger time mark interrupt pulse enable */
    static const uint32_t FDCANx_FDCAN_TTOCN_GCS_MASK      = 0x00000200U;   /** @brief Gap control select */
    static const uint32_t FDCANx_FDCAN_TTOCN_FGP_MASK      = 0x00000400U;   /** @brief Finish gap. */
    static const uint32_t FDCANx_FDCAN_TTOCN_TMG_MASK      = 0x00000800U;   /** @brief Time mark gap */
    static const uint32_t FDCANx_FDCAN_TTOCN_NIG_MASK      = 0x00001000U;   /** @brief Next is gap */
    static const uint32_t FDCANx_FDCAN_TTOCN_ESCN_MASK     = 0x00002000U;   /** @brief External synchronization control */
    static const uint32_t FDCANx_FDCAN_TTOCN_LCKC_MASK     = 0x00008000U;   /** @brief TT operation control register locked */
    static const uint32_t FDCANx_CAN_TTGTP_NCL_MASK        = 0x0000FFFFU;   /** @brief Time preset */
    static const uint32_t FDCANx_CAN_TTGTP_CTP_MASK        = 0xFFFF0000U;   /** @brief Cycle time target phase */
    static const uint32_t FDCANx_FDCAN_TTTMK_TM_MASK       = 0x0000FFFFU;   /** @brief Time mark */
    static const uint32_t FDCANx_FDCAN_TTTMK_TICC_MASK     = 0x007F0000U;   /** @brief Time mark cycle code */
    static const uint32_t FDCANx_FDCAN_TTTMK_LCKM_MASK     = 0x80000000U;   /** @brief TT time mark register locked */
    static const uint32_t FDCANx_FDCAN_TTIR_SBC_MASK       = 0x00000001U;   /** @brief Start of basic cycle */
    static const uint32_t FDCANx_FDCAN_TTIR_SMC_MASK       = 0x00000002U;   /** @brief Start of matrix cycle */
    static const uint32_t FDCANx_FDCAN_TTIR_CSM_MASK       = 0x00000004U;   /** @brief Change of synchronization mode */
    static const uint32_t FDCANx_FDCAN_TTIR_SOG_MASK       = 0x00000008U;   /** @brief Start of gap */
    static const uint32_t FDCANx_FDCAN_TTIR_RTMI_MASK      = 0x00000010U;   /** @brief Register time mark interrupt. */
    static const uint32_t FDCANx_FDCAN_TTIR_TTMI_MASK      = 0x00000020U;   /** @brief Trigger time mark event internal */
    static const uint32_t FDCANx_FDCAN_TTIR_SWE_MASK       = 0x00000040U;   /** @brief Stop watch event */
    static const uint32_t FDCANx_FDCAN_TTIR_GTW_MASK       = 0x00000080U;   /** @brief Global time wrap */
    static const uint32_t FDCANx_FDCAN_TTIR_GTD_MASK       = 0x00000100U;   /** @brief Global time discontinuity */
    static const uint32_t FDCANx_FDCAN_TTIR_GTE_MASK       = 0x00000200U;   /** @brief Global time error */
    static const uint32_t FDCANx_FDCAN_TTIR_TXU_MASK       = 0x00000400U;   /** @brief Tx count underflow */
    static const uint32_t FDCANx_FDCAN_TTIR_TXO_MASK       = 0x00000800U;   /** @brief Tx count overflow */
    static const uint32_t FDCANx_FDCAN_TTIR_ELC_MASK       = 0x00004000U;   /** @brief Error level changed. */
    static const uint32_t FDCANx_FDCAN_TTIR_IWTG_MASK      = 0x00008000U;   /** @brief Initialization watch trigger */
    static const uint32_t FDCANx_FDCAN_TTIR_WT_MASK        = 0x00010000U;   /** @brief Watch trigger */
    static const uint32_t FDCANx_FDCAN_TTIR_AW_MASK        = 0x00020000U;   /** @brief Application watchdog */
    static const uint32_t FDCANx_FDCAN_TTIR_CER_MASK       = 0x00040000U;   /** @brief Configuration error */
    static const uint32_t FDCANx_FDCAN_TTIE_SBCE_MASK      = 0x00000001U;   /** @brief Start of basic cycle interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_SMCE_MASK      = 0x00000002U;   /** @brief Start of matrix cycle interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_CSME_MASK      = 0x00000004U;   /** @brief Change of synchronization mode interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_SOGE_MASK      = 0x00000008U;   /** @brief Start of gap interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_RTMIE_MASK     = 0x00000010U;   /** @brief Register time mark interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_TTMIE_MASK     = 0x00000020U;   /** @brief Trigger time mark event internal interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_SWEE_MASK      = 0x00000040U;   /** @brief Stop watch event interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_GTWE_MASK      = 0x00000080U;   /** @brief Global time wrap interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_GTDE_MASK      = 0x00000100U;   /** @brief Global time discontinuity interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_GTEE_MASK      = 0x00000200U;   /** @brief Global time error interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_TXUE_MASK      = 0x00000400U;   /** @brief Tx count underflow interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_TXOE_MASK      = 0x00000800U;   /** @brief Tx count overflow interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_ELCE_MASK      = 0x00004000U;   /** @brief Change error level interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_IWTGE_MASK     = 0x00008000U;   /** @brief Initialization watch trigger interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_WTE_MASK       = 0x00010000U;   /** @brief Watch trigger interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_AWE_MASK       = 0x00020000U;   /** @brief Application watchdog interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTIE_CERE_MASK      = 0x00040000U;   /** @brief Configuration error interrupt enable */
    static const uint32_t FDCANx_FDCAN_TTILS_SBCL_MASK     = 0x00000001U;   /** @brief Start of basic cycle interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_SMCL_MASK     = 0x00000002U;   /** @brief Start of matrix cycle interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_CSML_MASK     = 0x00000004U;   /** @brief Change of synchronization mode interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_SOGL_MASK     = 0x00000008U;   /** @brief Start of gap interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_RTMIL_MASK    = 0x00000010U;   /** @brief Register time mark interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_TTMIL_MASK    = 0x00000020U;   /** @brief Trigger time mark event internal interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_SWEL_MASK     = 0x00000040U;   /** @brief Stop watch event interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_GTWL_MASK     = 0x00000080U;   /** @brief Global time wrap interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_GTDL_MASK     = 0x00000100U;   /** @brief Global time discontinuity interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_GTEL_MASK     = 0x00000200U;   /** @brief Global time error interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_TXUL_MASK     = 0x00000400U;   /** @brief Tx count underflow interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_TXOL_MASK     = 0x00000800U;   /** @brief Tx count overflow interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_ELCL_MASK     = 0x00004000U;   /** @brief Change error level interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_IWTGL_MASK    = 0x00008000U;   /** @brief Initialization watch trigger interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_WTL_MASK      = 0x00010000U;   /** @brief Watch trigger interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_AWL_MASK      = 0x00020000U;   /** @brief Application watchdog interrupt line */
    static const uint32_t FDCANx_FDCAN_TTILS_CERL_MASK     = 0x00040000U;   /** @brief Configuration error interrupt line */
    static const uint32_t FDCANx_FDCAN_TTOST_EL_MASK       = 0x00000003U;   /** @brief Error level */
    static const uint32_t FDCANx_FDCAN_TTOST_MS_MASK       = 0x0000000CU;   /** @brief Master state. */
    static const uint32_t FDCANx_FDCAN_TTOST_SYS_MASK      = 0x00000030U;   /** @brief Synchronization state */
    static const uint32_t FDCANx_FDCAN_TTOST_GTP_MASK      = 0x00000040U;   /** @brief Quality of global time phase */
    static const uint32_t FDCANx_FDCAN_TTOST_QCS_MASK      = 0x00000080U;   /** @brief Quality of clock speed */
    static const uint32_t FDCANx_FDCAN_TTOST_RTO_MASK      = 0x0000FF00U;   /** @brief Reference trigger offset */
    static const uint32_t FDCANx_FDCAN_TTOST_WGTD_MASK     = 0x00400000U;   /** @brief Wait for global time discontinuity */
    static const uint32_t FDCANx_FDCAN_TTOST_GFI_MASK      = 0x00800000U;   /** @brief Gap finished indicator. */
    static const uint32_t FDCANx_FDCAN_TTOST_TMP_MASK      = 0x07000000U;   /** @brief Time master priority */
    static const uint32_t FDCANx_FDCAN_TTOST_GSI_MASK      = 0x08000000U;   /** @brief Gap started indicator. */
    static const uint32_t FDCANx_FDCAN_TTOST_WFE_MASK      = 0x10000000U;   /** @brief Wait for event */
    static const uint32_t FDCANx_FDCAN_TTOST_AWE_MASK      = 0x20000000U;   /** @brief Application watchdog event */
    static const uint32_t FDCANx_FDCAN_TTOST_WECS_MASK     = 0x40000000U;   /** @brief Wait for external clock synchronization */
    static const uint32_t FDCANx_FDCAN_TTOST_SPL_MASK      = 0x80000000U;   /** @brief Schedule phase lock */
    static const uint32_t FDCANx_FDCAN_TURNA_NAV_MASK      = 0x0003FFFFU;   /** @brief Numerator actual value */
    static const uint32_t FDCANx_FDCAN_TTLGT_LT_MASK       = 0x0000FFFFU;   /** @brief Local time */
    static const uint32_t FDCANx_FDCAN_TTLGT_GT_MASK       = 0xFFFF0000U;   /** @brief Global time */
    static const uint32_t FDCANx_FDCAN_TTCTC_CT_MASK       = 0x0000FFFFU;   /** @brief Cycle time */
    static const uint32_t FDCANx_FDCAN_TTCTC_CC_MASK       = 0x003F0000U;   /** @brief Cycle count */
    static const uint32_t FDCANx_FDCAN_TTCPT_CT_MASK       = 0x0000003FU;   /** @brief Cycle count value */
    static const uint32_t FDCANx_FDCAN_TTCPT_SWV_MASK      = 0xFFFF0000U;   /** @brief Stop watch value */
    static const uint32_t FDCANx_FDCAN_TTCSM_CSM_MASK      = 0x0000FFFFU;   /** @brief Cycle sync mark */
    static const uint32_t FDCANx_FDCAN_TTTS_SWTDEL_MASK    = 0x00000003U;   /** @brief Stop watch trigger input selection */
    static const uint32_t FDCANx_FDCAN_TTTS_EVTSEL_MASK    = 0x00000030U;   /** @brief Event trigger input selection */

    /**** @subsection Enumerated FDCANx Register Field Masks ****/

    static const uint32_t FDCANx_FDCAN_DBTP_DTSEGx_MASK[3] = {
      [1] = 0x00001F00U,   /** @brief Data time segment after sample point */
      [2] = 0x000000F0U,   /** @brief Data time segment after sample point */
    };

    static const uint32_t FDCANx_FDCAN_IR_RFxN_MASK[2] = {
      [0] = 0x00000001U,   /** @brief Rx FIFO 0 new message */
      [1] = 0x00000010U,   /** @brief Rx FIFO 1 new message */
    };

    static const uint32_t FDCANx_FDCAN_IR_RFxW_MASK[2] = {
      [0] = 0x00000002U,   /** @brief Rx FIFO 0 full */
      [1] = 0x00000020U,   /** @brief Rx FIFO 1 watermark reached */
    };

    static const uint32_t FDCANx_FDCAN_IR_RFxF_MASK[2] = {
      [0] = 0x00000004U,   /** @brief Rx FIFO 0 full */
      [1] = 0x00000040U,   /** @brief Rx FIFO 1 watermark reached */
    };

    static const uint32_t FDCANx_FDCAN_IR_RFxL_MASK[2] = {
      [0] = 0x00000008U,   /** @brief Rx FIFO 0 message lost */
      [1] = 0x00000080U,   /** @brief Rx FIFO 1 message lost */
    };

    static const uint32_t FDCANx_FDCAN_IE_RFxNE_MASK[2] = {
      [0] = 0x00000001U,   /** @brief Rx FIFO 0 new message enable */
      [1] = 0x00000010U,   /** @brief Rx FIFO 1 new message enable */
    };

    static const uint32_t FDCANx_FDCAN_IE_RFxWE_MASK[2] = {
      [0] = 0x00000002U,   /** @brief Rx FIFO 0 full enable */
      [1] = 0x00000020U,   /** @brief Rx FIFO 1 watermark reached enable */
    };

    static const uint32_t FDCANx_FDCAN_IE_RFxFE_MASK[2] = {
      [0] = 0x00000004U,   /** @brief Rx FIFO 0 full enable */
      [1] = 0x00000040U,   /** @brief Rx FIFO 1 watermark reached enable */
    };

    static const uint32_t FDCANx_FDCAN_IE_RFxLE_MASK[2] = {
      [0] = 0x00000008U,   /** @brief Rx FIFO 0 message lost enable */
      [1] = 0x00000080U,   /** @brief Rx FIFO 1 message lost enable */
    };

    static const uint32_t FDCANx_FDCAN_ILS_RFxNL_MASK[2] = {
      [0] = 0x00000001U,   /** @brief Rx FIFO 0 new message interrupt line */
      [1] = 0x00000010U,   /** @brief Rx FIFO 1 new message interrupt line */
    };

    static const uint32_t FDCANx_FDCAN_ILS_RFxWL_MASK[2] = {
      [0] = 0x00000002U,   /** @brief Rx FIFO 0 watermark reached interrupt line */
      [1] = 0x00000020U,   /** @brief Rx FIFO 1 watermark reached interrupt line */
    };

    static const uint32_t FDCANx_FDCAN_ILS_RFxFL_MASK[2] = {
      [0] = 0x00000004U,   /** @brief Rx FIFO 0 full interrupt line */
      [1] = 0x00000040U,   /** @brief Rx FIFO 1 full interrupt line */
    };

    static const uint32_t FDCANx_FDCAN_ILS_RFxLL_MASK[2] = {
      [0] = 0x00000008U,   /** @brief Rx FIFO 0 message lost interrupt line */
      [1] = 0x00000080U,   /** @brief Rx FIFO 1 message lost interrupt line */
    };

    static const uint32_t FDCANx_FDCAN_ILE_EINTx_MASK[2] = {
      [0] = 0x00000001U,   /** @brief Enable interrupt line 0 */
      [1] = 0x00000002U,   /** @brief Enable interrupt line 1 */
    };

    static const uint32_t FDCANx_FDCAN_NDAT1_NDx_MASK[32] = {
      [0]  = 0x00000001U,   /** @brief New data */
      [1]  = 0x00000002U,   /** @brief New data */
      [2]  = 0x00000004U,   /** @brief New data */
      [3]  = 0x00000008U,   /** @brief New data */
      [4]  = 0x00000010U,   /** @brief New data */
      [5]  = 0x00000020U,   /** @brief New data */
      [6]  = 0x00000040U,   /** @brief New data */
      [7]  = 0x00000080U,   /** @brief New data */
      [8]  = 0x00000100U,   /** @brief New data */
      [9]  = 0x00000200U,   /** @brief New data */
      [10] = 0x00000400U,   /** @brief New data */
      [11] = 0x00000800U,   /** @brief New data */
      [12] = 0x00001000U,   /** @brief New data */
      [13] = 0x00002000U,   /** @brief New data */
      [14] = 0x00004000U,   /** @brief New data */
      [15] = 0x00008000U,   /** @brief New data */
      [16] = 0x00010000U,   /** @brief New data */
      [17] = 0x00020000U,   /** @brief New data */
      [18] = 0x00040000U,   /** @brief New data */
      [19] = 0x00080000U,   /** @brief New data */
      [20] = 0x00100000U,   /** @brief New data */
      [21] = 0x00200000U,   /** @brief New data */
      [22] = 0x00400000U,   /** @brief New data */
      [23] = 0x00800000U,   /** @brief New data */
      [24] = 0x01000000U,   /** @brief New data */
      [25] = 0x02000000U,   /** @brief New data */
      [26] = 0x04000000U,   /** @brief New data */
      [27] = 0x08000000U,   /** @brief New data */
      [28] = 0x10000000U,   /** @brief New data */
      [29] = 0x20000000U,   /** @brief New data */
      [30] = 0x40000000U,   /** @brief New data */
      [31] = 0x80000000U,   /** @brief New data */
    };

    static const uint32_t FDCANx_FDCAN_NDAT2_ND3x_MASK[10] = {
      [3]  = 0x00000002U,   /** @brief New data */
      [4]  = 0x00000004U,   /** @brief New data */
      [5]  = 0x00000008U,   /** @brief New data */
      [6]  = 0x00000010U,   /** @brief New data */
      [7]  = 0x00000020U,   /** @brief New data */
      [8]  = 0x00000040U,   /** @brief New data */
      [9]  = 0x00000080U,   /** @brief New data */
    };

    static const uint32_t FDCANx_FDCAN_RXESC_FxDS_MASK[2] = {
      [0] = 0x00000007U,   /** @brief Rx FIFO 1 data field size: */
      [1] = 0x00000070U,   /** @brief Rx FIFO 0 data field size: */
    };

    static const uint32_t FDCANx_FDCAN_TTIR_SEx_MASK[3] = {
      [1] = 0x00001000U,   /** @brief Scheduling error 1 */
      [2] = 0x00002000U,   /** @brief Scheduling error 2 */
    };

    static const uint32_t FDCANx_FDCAN_TTIE_SExE_MASK[3] = {
      [1] = 0x00001000U,   /** @brief Scheduling error 1 interrupt enable */
      [2] = 0x00002000U,   /** @brief Scheduling error 2 interrupt enable */
    };

    static const uint32_t FDCANx_FDCAN_TTILS_SExL_MASK[3] = {
      [1] = 0x00001000U,   /** @brief Scheduling error 1 interrupt line */
      [2] = 0x00002000U,   /** @brief Scheduling error 2 interrupt line */
    };

    /**** @subsection FDCANx Register Field Positions ****/

    static const int32_t FDCANx_FDCAN_CREL_REL_POS       = 28;   /** @brief Core release */
    static const int32_t FDCANx_FDCAN_CREL_STEP_POS      = 24;   /** @brief Step of core release */
    static const int32_t FDCANx_FDCAN_CREL_SUBSTEP_POS   = 20;   /** @brief Sub-step of core release */
    static const int32_t FDCANx_FDCAN_CREL_YEAR_POS      = 16;   /** @brief Timestamp year */
    static const int32_t FDCANx_FDCAN_CREL_MON_POS       = 8;    /** @brief Timestamp month */
    static const int32_t FDCANx_FDCAN_CREL_DAY_POS       = 0;    /** @brief Timestamp day */
    static const int32_t FDCANx_FDCAN_DBTP_DSJW_POS      = 0;    /** @brief Synchronization jump width */
    static const int32_t FDCANx_FDCAN_DBTP_DBRP_POS      = 16;   /** @brief Data bit rate prescaler */
    static const int32_t FDCANx_FDCAN_DBTP_TDC_POS       = 23;   /** @brief Transceiver delay compensation */
    static const int32_t FDCANx_FDCAN_TEST_LBCK_POS      = 4;    /** @brief Loop back mode */
    static const int32_t FDCANx_FDCAN_TEST_TX_POS        = 5;    /** @brief Loop back mode */
    static const int32_t FDCANx_FDCAN_TEST_RX_POS        = 7;    /** @brief Control of transmit pin */
    static const int32_t FDCANx_FDCAN_RWD_WDV_POS        = 8;    /** @brief Watchdog value */
    static const int32_t FDCANx_FDCAN_RWD_WDC_POS        = 0;    /** @brief Watchdog configuration */
    static const int32_t FDCANx_FDCAN_CCCR_INIT_POS      = 0;    /** @brief Initialization */
    static const int32_t FDCANx_FDCAN_CCCR_CCE_POS       = 1;    /** @brief Configuration change enable */
    static const int32_t FDCANx_FDCAN_CCCR_ASM_POS       = 2;    /** @brief ASM restricted operation mode */
    static const int32_t FDCANx_FDCAN_CCCR_CSA_POS       = 3;    /** @brief Clock stop acknowledge */
    static const int32_t FDCANx_FDCAN_CCCR_CSR_POS       = 4;    /** @brief Clock stop request */
    static const int32_t FDCANx_FDCAN_CCCR_MON_POS       = 5;    /** @brief Bus monitoring mode */
    static const int32_t FDCANx_FDCAN_CCCR_DAR_POS       = 6;    /** @brief Disable automatic retransmission */
    static const int32_t FDCANx_FDCAN_CCCR_TEST_POS      = 7;    /** @brief Test mode enable */
    static const int32_t FDCANx_FDCAN_CCCR_FDOE_POS      = 8;    /** @brief FD operation enable */
    static const int32_t FDCANx_FDCAN_CCCR_BSE_POS       = 9;    /** @brief FDCAN bit rate switching */
    static const int32_t FDCANx_FDCAN_CCCR_PXHD_POS      = 12;   /** @brief Protocol exception handling disable */
    static const int32_t FDCANx_FDCAN_CCCR_EFBI_POS      = 13;   /** @brief Edge filtering during bus integration */
    static const int32_t FDCANx_FDCAN_CCCR_TXP_POS       = 14;   /** @brief TXP */
    static const int32_t FDCANx_FDCAN_CCCR_NISO_POS      = 15;   /** @brief Non ISO operation */
    static const int32_t FDCANx_FDCAN_NBTP_NSJW_POS      = 25;   /** @brief NSJW: nominal (re)synchronization jump width */
    static const int32_t FDCANx_FDCAN_NBTP_NBRP_POS      = 16;   /** @brief Bit rate prescaler */
    static const int32_t FDCANx_FDCAN_NBTP_NTSEG1_POS    = 8;    /** @brief Nominal time segment before sample point */
    static const int32_t FDCANx_FDCAN_NBTP_TSEG2_POS     = 0;    /** @brief Nominal time segment after sample point */
    static const int32_t FDCANx_FDCAN_TSCC_TCP_POS       = 16;   /** @brief Timestamp counter prescaler */
    static const int32_t FDCANx_FDCAN_TSCC_TSS_POS       = 0;    /** @brief Timestamp select */
    static const int32_t FDCANx_FDCAN_TSCV_TSC_POS       = 0;    /** @brief Timestamp counter */
    static const int32_t FDCANx_FDCAN_TOCC_ETOC_POS      = 0;    /** @brief Enable timeout counter */
    static const int32_t FDCANx_FDCAN_TOCC_TOS_POS       = 1;    /** @brief Timeout select */
    static const int32_t FDCANx_FDCAN_TOCC_TOP_POS       = 16;   /** @brief Timeout period */
    static const int32_t FDCANx_FDCAN_TOCV_TOC_POS       = 0;    /** @brief Timeout counter */
    static const int32_t FDCANx_FDCAN_ECR_CEL_POS        = 16;   /** @brief AN error logging */
    static const int32_t FDCANx_FDCAN_ECR_RP_POS         = 15;   /** @brief Receive error passive */
    static const int32_t FDCANx_FDCAN_ECR_TREC_POS       = 8;    /** @brief Receive error counter */
    static const int32_t FDCANx_FDCAN_ECR_TEC_POS        = 0;    /** @brief Transmit error counter */
    static const int32_t FDCANx_FDCAN_PSR_LEC_POS        = 0;    /** @brief Last error code */
    static const int32_t FDCANx_FDCAN_PSR_ACT_POS        = 3;    /** @brief Activity */
    static const int32_t FDCANx_FDCAN_PSR_EP_POS         = 5;    /** @brief Error passive */
    static const int32_t FDCANx_FDCAN_PSR_EW_POS         = 6;    /** @brief Warning status */
    static const int32_t FDCANx_FDCAN_PSR_BO_POS         = 7;    /** @brief Bus_Off status */
    static const int32_t FDCANx_FDCAN_PSR_DLEC_POS       = 8;    /** @brief Data last error code */
    static const int32_t FDCANx_FDCAN_PSR_RESI_POS       = 11;   /** @brief ESI flag of last received FDCAN message */
    static const int32_t FDCANx_FDCAN_PSR_RBRS_POS       = 12;   /** @brief BRS flag of last received FDCAN message */
    static const int32_t FDCANx_FDCAN_PSR_REDL_POS       = 13;   /** @brief Received FDCAN message */
    static const int32_t FDCANx_FDCAN_PSR_PXE_POS        = 14;   /** @brief Protocol exception event */
    static const int32_t FDCANx_FDCAN_PSR_TDCV_POS       = 16;   /** @brief Transmitter delay compensation value */
    static const int32_t FDCANx_FDCAN_TDCR_TDCF_POS      = 0;    /** @brief Transmitter delay compensation filter window length */
    static const int32_t FDCANx_FDCAN_TDCR_TDCO_POS      = 8;    /** @brief Transmitter delay compensation offset */
    static const int32_t FDCANx_FDCAN_IR_HPM_POS         = 8;    /** @brief High priority message */
    static const int32_t FDCANx_FDCAN_IR_TC_POS          = 9;    /** @brief Transmission completed */
    static const int32_t FDCANx_FDCAN_IR_TCF_POS         = 10;   /** @brief Transmission cancellation finished */
    static const int32_t FDCANx_FDCAN_IR_TEF_POS         = 11;   /** @brief Tx FIFO empty */
    static const int32_t FDCANx_FDCAN_IR_TEFN_POS        = 12;   /** @brief Tx event FIFO new entry */
    static const int32_t FDCANx_FDCAN_IR_TEFW_POS        = 13;   /** @brief Tx event FIFO watermark reached */
    static const int32_t FDCANx_FDCAN_IR_TEFF_POS        = 14;   /** @brief Tx event FIFO full */
    static const int32_t FDCANx_FDCAN_IR_TEFL_POS        = 15;   /** @brief Tx event FIFO element lost */
    static const int32_t FDCANx_FDCAN_IR_TSW_POS         = 16;   /** @brief Timestamp wraparound */
    static const int32_t FDCANx_FDCAN_IR_MRAF_POS        = 17;   /** @brief Message RAM access failure */
    static const int32_t FDCANx_FDCAN_IR_TOO_POS         = 18;   /** @brief Timeout occurred */
    static const int32_t FDCANx_FDCAN_IR_DRX_POS         = 19;   /** @brief Message stored to dedicated rx buffer */
    static const int32_t FDCANx_FDCAN_IR_ELO_POS         = 22;   /** @brief Error logging overflow */
    static const int32_t FDCANx_FDCAN_IR_EP_POS          = 23;   /** @brief Error passive */
    static const int32_t FDCANx_FDCAN_IR_EW_POS          = 24;   /** @brief Warning status */
    static const int32_t FDCANx_FDCAN_IR_BO_POS          = 25;   /** @brief Bus_Off status */
    static const int32_t FDCANx_FDCAN_IR_WDI_POS         = 26;   /** @brief Watchdog interrupt */
    static const int32_t FDCANx_FDCAN_IR_PEA_POS         = 27;   /** @brief Protocol error in arbitration phase (nominal bit time is used) */
    static const int32_t FDCANx_FDCAN_IR_PED_POS         = 28;   /** @brief Protocol error in data phase (data bit time is used) */
    static const int32_t FDCANx_FDCAN_IR_ARA_POS         = 29;   /** @brief Access to reserved address */
    static const int32_t FDCANx_FDCAN_IE_HPME_POS        = 8;    /** @brief High priority message enable */
    static const int32_t FDCANx_FDCAN_IE_TCE_POS         = 9;    /** @brief Transmission completed enable */
    static const int32_t FDCANx_FDCAN_IE_TCFE_POS        = 10;   /** @brief Transmission cancellation finished enable */
    static const int32_t FDCANx_FDCAN_IE_TEFE_POS        = 11;   /** @brief Tx FIFO empty enable */
    static const int32_t FDCANx_FDCAN_IE_TEFNE_POS       = 12;   /** @brief Tx event FIFO new entry enable */
    static const int32_t FDCANx_FDCAN_IE_TEFWE_POS       = 13;   /** @brief Tx event FIFO watermark reached enable */
    static const int32_t FDCANx_FDCAN_IE_TEFFE_POS       = 14;   /** @brief Tx event FIFO full enable */
    static const int32_t FDCANx_FDCAN_IE_TEFLE_POS       = 15;   /** @brief Tx event FIFO element lost enable */
    static const int32_t FDCANx_FDCAN_IE_TSWE_POS        = 16;   /** @brief Timestamp wraparound enable */
    static const int32_t FDCANx_FDCAN_IE_MRAFE_POS       = 17;   /** @brief Message RAM access failure enable */
    static const int32_t FDCANx_FDCAN_IE_TOOE_POS        = 18;   /** @brief Timeout occurred enable */
    static const int32_t FDCANx_FDCAN_IE_DRXE_POS        = 19;   /** @brief Message stored to dedicated rx buffer enable */
    static const int32_t FDCANx_FDCAN_IE_BECE_POS        = 20;   /** @brief Bit error corrected interrupt enable */
    static const int32_t FDCANx_FDCAN_IE_BEUE_POS        = 21;   /** @brief Bit error uncorrected interrupt enable */
    static const int32_t FDCANx_FDCAN_IE_ELOE_POS        = 22;   /** @brief Error logging overflow enable */
    static const int32_t FDCANx_FDCAN_IE_EPE_POS         = 23;   /** @brief Error passive enable */
    static const int32_t FDCANx_FDCAN_IE_EWE_POS         = 24;   /** @brief Warning status enable */
    static const int32_t FDCANx_FDCAN_IE_BOE_POS         = 25;   /** @brief Bus_Off status enable */
    static const int32_t FDCANx_FDCAN_IE_WDIE_POS        = 26;   /** @brief Watchdog interrupt enable */
    static const int32_t FDCANx_FDCAN_IE_PEAE_POS        = 27;   /** @brief Protocol error in arbitration phase enable */
    static const int32_t FDCANx_FDCAN_IE_PEDE_POS        = 28;   /** @brief Protocol error in data phase enable */
    static const int32_t FDCANx_FDCAN_IE_ARAE_POS        = 29;   /** @brief Access to reserved address enable */
    static const int32_t FDCANx_FDCAN_ILS_HPML_POS       = 8;    /** @brief High priority message interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TCL_POS        = 9;    /** @brief Transmission completed interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TCFL_POS       = 10;   /** @brief Transmission cancellation finished interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TEFL_POS       = 11;   /** @brief Tx FIFO empty interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TEFNL_POS      = 12;   /** @brief Tx event FIFO new entry interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TEFWL_POS      = 13;   /** @brief Tx event FIFO watermark reached interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TEFFL_POS      = 14;   /** @brief Tx event FIFO full interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TEFLL_POS      = 15;   /** @brief Tx event FIFO element lost interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TSWL_POS       = 16;   /** @brief Timestamp wraparound interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_MRAFL_POS      = 17;   /** @brief Message RAM access failure interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_TOOL_POS       = 18;   /** @brief Timeout occurred interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_DRXL_POS       = 19;   /** @brief Message stored to dedicated rx buffer interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_BECL_POS       = 20;   /** @brief Bit error corrected interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_BEUL_POS       = 21;   /** @brief Bit error uncorrected interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_ELOL_POS       = 22;   /** @brief Error logging overflow interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_EPL_POS        = 23;   /** @brief Error passive interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_EWL_POS        = 24;   /** @brief Warning status interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_BOL_POS        = 25;   /** @brief Bus_Off status */
    static const int32_t FDCANx_FDCAN_ILS_WDIL_POS       = 26;   /** @brief Watchdog interrupt line */
    static const int32_t FDCANx_FDCAN_ILS_PEAL_POS       = 27;   /** @brief Protocol error in arbitration phase line */
    static const int32_t FDCANx_FDCAN_ILS_PEDL_POS       = 28;   /** @brief Protocol error in data phase line */
    static const int32_t FDCANx_FDCAN_ILS_ARAL_POS       = 29;   /** @brief Access to reserved address line */
    static const int32_t FDCANx_FDCAN_GFC_RRFE_POS       = 0;    /** @brief Reject remote frames extended */
    static const int32_t FDCANx_FDCAN_GFC_RRFS_POS       = 1;    /** @brief Reject remote frames standard */
    static const int32_t FDCANx_FDCAN_GFC_ANFE_POS       = 2;    /** @brief Accept non-matching frames extended */
    static const int32_t FDCANx_FDCAN_GFC_ANFS_POS       = 4;    /** @brief Accept non-matching frames standard */
    static const int32_t FDCANx_FDCAN_SIDFC_FLSSA_POS    = 2;    /** @brief Filter list standard start address */
    static const int32_t FDCANx_FDCAN_SIDFC_LSS_POS      = 16;   /** @brief List size standard */
    static const int32_t FDCANx_FDCAN_XIDFC_FLESA_POS    = 2;    /** @brief Filter list standard start address */
    static const int32_t FDCANx_FDCAN_XIDFC_LSE_POS      = 16;   /** @brief List size extended */
    static const int32_t FDCANx_FDCAN_XIDAM_EIDM_POS     = 0;    /** @brief Extended ID mask */
    static const int32_t FDCANx_FDCAN_HPMS_BIDX_POS      = 0;    /** @brief Buffer index */
    static const int32_t FDCANx_FDCAN_HPMS_MSI_POS       = 6;    /** @brief Message storage indicator */
    static const int32_t FDCANx_FDCAN_HPMS_FIDX_POS      = 8;    /** @brief Filter index */
    static const int32_t FDCANx_FDCAN_HPMS_FLST_POS      = 15;   /** @brief Filter list */
    static const int32_t FDCANx_FDCAN_RXF0C_F0SA_POS     = 2;    /** @brief Rx FIFO 0 start address */
    static const int32_t FDCANx_FDCAN_RXF0C_F0S_POS      = 16;   /** @brief Rx FIFO 0 size */
    static const int32_t FDCANx_FDCAN_RXF0C_F0WM_POS     = 24;   /** @brief FIFO 0 watermark */
    static const int32_t FDCANx_FDCAN_RXF0S_F0FL_POS     = 0;    /** @brief Rx FIFO 0 fill level */
    static const int32_t FDCANx_FDCAN_RXF0S_F0G_POS      = 8;    /** @brief Rx FIFO 0 get index */
    static const int32_t FDCANx_FDCAN_RXF0S_F0P_POS      = 16;   /** @brief Rx FIFO 0 put index */
    static const int32_t FDCANx_FDCAN_RXF0S_F0F_POS      = 24;   /** @brief Rx FIFO 0 full */
    static const int32_t FDCANx_FDCAN_RXF0S_RF0L_POS     = 25;   /** @brief Rx FIFO 0 message lost */
    static const int32_t FDCANx_FDCAN_RXF0A_FA01_POS     = 0;    /** @brief Rx FIFO 0 acknowledge index */
    static const int32_t FDCANx_FDCAN_RXBC_RBSA_POS      = 2;    /** @brief Rx buffer start address */
    static const int32_t FDCANx_FDCAN_RXF1C_F1SA_POS     = 2;    /** @brief Rx FIFO 1 start address */
    static const int32_t FDCANx_FDCAN_RXF1C_F1S_POS      = 16;   /** @brief Rx FIFO 1 size */
    static const int32_t FDCANx_FDCAN_RXF1C_F1WM_POS     = 24;   /** @brief Rx FIFO 1 watermark */
    static const int32_t FDCANx_FDCAN_RXF1S_F1FL_POS     = 0;    /** @brief Rx FIFO 1 fill level */
    static const int32_t FDCANx_FDCAN_RXF1S_F1GI_POS     = 8;    /** @brief Rx FIFO 1 get index */
    static const int32_t FDCANx_FDCAN_RXF1S_F1PI_POS     = 16;   /** @brief Rx FIFO 1 put index */
    static const int32_t FDCANx_FDCAN_RXF1S_F1F_POS      = 24;   /** @brief Rx FIFO 1 full */
    static const int32_t FDCANx_FDCAN_RXF1S_RF1L_POS     = 25;   /** @brief Rx FIFO 1 message lost */
    static const int32_t FDCANx_FDCAN_RXF1S_DMS_POS      = 30;   /** @brief Debug message status */
    static const int32_t FDCANx_FDCAN_RXF1A_F1AI_POS     = 0;    /** @brief Rx FIFO 1 acknowledge index */
    static const int32_t FDCANx_FDCAN_RXESC_RBDS_POS     = 8;    /** @brief Rx buffer data field size: */
    static const int32_t FDCANx_FDCAN_TXBC_TBSA_POS      = 2;    /** @brief Tx buffers start address */
    static const int32_t FDCANx_FDCAN_TXBC_NDTB_POS      = 16;   /** @brief Number of dedicated transmit buffers */
    static const int32_t FDCANx_FDCAN_TXBC_TFQS_POS      = 24;   /** @brief Transmit fifo/queue size */
    static const int32_t FDCANx_FDCAN_TXBC_TFQM_POS      = 30;   /** @brief Tx fifo/queue mode */
    static const int32_t FDCANx_FDCAN_TXFQS_TFFL_POS     = 0;    /** @brief Tx FIFO free level */
    static const int32_t FDCANx_FDCAN_TXFQS_TFGI_POS     = 8;    /** @brief TFGI */
    static const int32_t FDCANx_FDCAN_TXFQS_TFQPI_POS    = 16;   /** @brief Tx fifo/queue put index */
    static const int32_t FDCANx_FDCAN_TXFQS_TFQF_POS     = 21;   /** @brief Tx fifo/queue full */
    static const int32_t FDCANx_FDCAN_TXESC_TBDS_POS     = 0;    /** @brief Tx buffer data field size: */
    static const int32_t FDCANx_FDCAN_TXEFC_EFSA_POS     = 2;    /** @brief Event FIFO start address */
    static const int32_t FDCANx_FDCAN_TXEFC_EFS_POS      = 16;   /** @brief Event FIFO size */
    static const int32_t FDCANx_FDCAN_TXEFC_EFWM_POS     = 24;   /** @brief Event FIFO watermark */
    static const int32_t FDCANx_FDCAN_TXEFS_EFFL_POS     = 0;    /** @brief Event FIFO fill level */
    static const int32_t FDCANx_FDCAN_TXEFS_EFGI_POS     = 8;    /** @brief Event FIFO get index. */
    static const int32_t FDCANx_FDCAN_TXEFS_EFF_POS      = 24;   /** @brief Event FIFO full. */
    static const int32_t FDCANx_FDCAN_TXEFS_TEFL_POS     = 25;   /** @brief Tx event FIFO element lost. */
    static const int32_t FDCANx_FDCAN_TXEFA_EFAI_POS     = 0;    /** @brief Event FIFO acknowledge index */
    static const int32_t FDCANx_FDCAN_TTTMC_TMSA_POS     = 2;    /** @brief Trigger memory start address */
    static const int32_t FDCANx_FDCAN_TTTMC_TME_POS      = 16;   /** @brief Trigger memory elements */
    static const int32_t FDCANx_FDCAN_TTRMC_RID_POS      = 0;    /** @brief Reference identifier. */
    static const int32_t FDCANx_FDCAN_TTRMC_XTD_POS      = 30;   /** @brief Extended identifier */
    static const int32_t FDCANx_FDCAN_TTRMC_RMPS_POS     = 31;   /** @brief Reference message payload select */
    static const int32_t FDCANx_FDCAN_TTOCF_OM_POS       = 0;    /** @brief Operation mode */
    static const int32_t FDCANx_FDCAN_TTOCF_GEN_POS      = 3;    /** @brief Gap enable */
    static const int32_t FDCANx_FDCAN_TTOCF_TM_POS       = 4;    /** @brief Time master */
    static const int32_t FDCANx_FDCAN_TTOCF_LDSDL_POS    = 5;    /** @brief LD of synchronization deviation limit */
    static const int32_t FDCANx_FDCAN_TTOCF_IRTO_POS     = 8;    /** @brief Initial reference trigger offset */
    static const int32_t FDCANx_FDCAN_TTOCF_EECS_POS     = 15;   /** @brief Enable external clock synchronization */
    static const int32_t FDCANx_FDCAN_TTOCF_AWL_POS      = 16;   /** @brief Application watchdog limit */
    static const int32_t FDCANx_FDCAN_TTOCF_EGTF_POS     = 24;   /** @brief Enable global time filtering */
    static const int32_t FDCANx_FDCAN_TTOCF_ECC_POS      = 25;   /** @brief Enable clock calibration */
    static const int32_t FDCANx_FDCAN_TTOCF_EVTP_POS     = 26;   /** @brief Event trigger polarity */
    static const int32_t FDCANx_FDCAN_TTMLM_CCM_POS      = 0;    /** @brief Cycle count max */
    static const int32_t FDCANx_FDCAN_TTMLM_CSS_POS      = 6;    /** @brief Cycle start synchronization */
    static const int32_t FDCANx_FDCAN_TTMLM_TXEW_POS     = 8;    /** @brief Tx enable window */
    static const int32_t FDCANx_FDCAN_TTMLM_ENTT_POS     = 16;   /** @brief Expected number of tx triggers */
    static const int32_t FDCANx_FDCAN_TURCF_NCL_POS      = 0;    /** @brief Numerator configuration low. */
    static const int32_t FDCANx_FDCAN_TURCF_DC_POS       = 16;   /** @brief Denominator configuration. */
    static const int32_t FDCANx_FDCAN_TURCF_ELT_POS      = 31;   /** @brief Enable local time */
    static const int32_t FDCANx_FDCAN_TTOCN_SGT_POS      = 0;    /** @brief Set global time */
    static const int32_t FDCANx_FDCAN_TTOCN_ECS_POS      = 1;    /** @brief External clock synchronization */
    static const int32_t FDCANx_FDCAN_TTOCN_SWP_POS      = 2;    /** @brief Stop watch polarity */
    static const int32_t FDCANx_FDCAN_TTOCN_SWS_POS      = 3;    /** @brief Stop watch source. */
    static const int32_t FDCANx_FDCAN_TTOCN_RTIE_POS     = 5;    /** @brief Register time mark interrupt pulse enable */
    static const int32_t FDCANx_FDCAN_TTOCN_TMC_POS      = 6;    /** @brief Register time mark compare */
    static const int32_t FDCANx_FDCAN_TTOCN_TTIE_POS     = 8;    /** @brief Trigger time mark interrupt pulse enable */
    static const int32_t FDCANx_FDCAN_TTOCN_GCS_POS      = 9;    /** @brief Gap control select */
    static const int32_t FDCANx_FDCAN_TTOCN_FGP_POS      = 10;   /** @brief Finish gap. */
    static const int32_t FDCANx_FDCAN_TTOCN_TMG_POS      = 11;   /** @brief Time mark gap */
    static const int32_t FDCANx_FDCAN_TTOCN_NIG_POS      = 12;   /** @brief Next is gap */
    static const int32_t FDCANx_FDCAN_TTOCN_ESCN_POS     = 13;   /** @brief External synchronization control */
    static const int32_t FDCANx_FDCAN_TTOCN_LCKC_POS     = 15;   /** @brief TT operation control register locked */
    static const int32_t FDCANx_CAN_TTGTP_NCL_POS        = 0;    /** @brief Time preset */
    static const int32_t FDCANx_CAN_TTGTP_CTP_POS        = 16;   /** @brief Cycle time target phase */
    static const int32_t FDCANx_FDCAN_TTTMK_TM_POS       = 0;    /** @brief Time mark */
    static const int32_t FDCANx_FDCAN_TTTMK_TICC_POS     = 16;   /** @brief Time mark cycle code */
    static const int32_t FDCANx_FDCAN_TTTMK_LCKM_POS     = 31;   /** @brief TT time mark register locked */
    static const int32_t FDCANx_FDCAN_TTIR_SBC_POS       = 0;    /** @brief Start of basic cycle */
    static const int32_t FDCANx_FDCAN_TTIR_SMC_POS       = 1;    /** @brief Start of matrix cycle */
    static const int32_t FDCANx_FDCAN_TTIR_CSM_POS       = 2;    /** @brief Change of synchronization mode */
    static const int32_t FDCANx_FDCAN_TTIR_SOG_POS       = 3;    /** @brief Start of gap */
    static const int32_t FDCANx_FDCAN_TTIR_RTMI_POS      = 4;    /** @brief Register time mark interrupt. */
    static const int32_t FDCANx_FDCAN_TTIR_TTMI_POS      = 5;    /** @brief Trigger time mark event internal */
    static const int32_t FDCANx_FDCAN_TTIR_SWE_POS       = 6;    /** @brief Stop watch event */
    static const int32_t FDCANx_FDCAN_TTIR_GTW_POS       = 7;    /** @brief Global time wrap */
    static const int32_t FDCANx_FDCAN_TTIR_GTD_POS       = 8;    /** @brief Global time discontinuity */
    static const int32_t FDCANx_FDCAN_TTIR_GTE_POS       = 9;    /** @brief Global time error */
    static const int32_t FDCANx_FDCAN_TTIR_TXU_POS       = 10;   /** @brief Tx count underflow */
    static const int32_t FDCANx_FDCAN_TTIR_TXO_POS       = 11;   /** @brief Tx count overflow */
    static const int32_t FDCANx_FDCAN_TTIR_ELC_POS       = 14;   /** @brief Error level changed. */
    static const int32_t FDCANx_FDCAN_TTIR_IWTG_POS      = 15;   /** @brief Initialization watch trigger */
    static const int32_t FDCANx_FDCAN_TTIR_WT_POS        = 16;   /** @brief Watch trigger */
    static const int32_t FDCANx_FDCAN_TTIR_AW_POS        = 17;   /** @brief Application watchdog */
    static const int32_t FDCANx_FDCAN_TTIR_CER_POS       = 18;   /** @brief Configuration error */
    static const int32_t FDCANx_FDCAN_TTIE_SBCE_POS      = 0;    /** @brief Start of basic cycle interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_SMCE_POS      = 1;    /** @brief Start of matrix cycle interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_CSME_POS      = 2;    /** @brief Change of synchronization mode interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_SOGE_POS      = 3;    /** @brief Start of gap interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_RTMIE_POS     = 4;    /** @brief Register time mark interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_TTMIE_POS     = 5;    /** @brief Trigger time mark event internal interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_SWEE_POS      = 6;    /** @brief Stop watch event interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_GTWE_POS      = 7;    /** @brief Global time wrap interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_GTDE_POS      = 8;    /** @brief Global time discontinuity interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_GTEE_POS      = 9;    /** @brief Global time error interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_TXUE_POS      = 10;   /** @brief Tx count underflow interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_TXOE_POS      = 11;   /** @brief Tx count overflow interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_ELCE_POS      = 14;   /** @brief Change error level interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_IWTGE_POS     = 15;   /** @brief Initialization watch trigger interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_WTE_POS       = 16;   /** @brief Watch trigger interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_AWE_POS       = 17;   /** @brief Application watchdog interrupt enable */
    static const int32_t FDCANx_FDCAN_TTIE_CERE_POS      = 18;   /** @brief Configuration error interrupt enable */
    static const int32_t FDCANx_FDCAN_TTILS_SBCL_POS     = 0;    /** @brief Start of basic cycle interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_SMCL_POS     = 1;    /** @brief Start of matrix cycle interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_CSML_POS     = 2;    /** @brief Change of synchronization mode interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_SOGL_POS     = 3;    /** @brief Start of gap interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_RTMIL_POS    = 4;    /** @brief Register time mark interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_TTMIL_POS    = 5;    /** @brief Trigger time mark event internal interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_SWEL_POS     = 6;    /** @brief Stop watch event interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_GTWL_POS     = 7;    /** @brief Global time wrap interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_GTDL_POS     = 8;    /** @brief Global time discontinuity interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_GTEL_POS     = 9;    /** @brief Global time error interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_TXUL_POS     = 10;   /** @brief Tx count underflow interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_TXOL_POS     = 11;   /** @brief Tx count overflow interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_ELCL_POS     = 14;   /** @brief Change error level interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_IWTGL_POS    = 15;   /** @brief Initialization watch trigger interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_WTL_POS      = 16;   /** @brief Watch trigger interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_AWL_POS      = 17;   /** @brief Application watchdog interrupt line */
    static const int32_t FDCANx_FDCAN_TTILS_CERL_POS     = 18;   /** @brief Configuration error interrupt line */
    static const int32_t FDCANx_FDCAN_TTOST_EL_POS       = 0;    /** @brief Error level */
    static const int32_t FDCANx_FDCAN_TTOST_MS_POS       = 2;    /** @brief Master state. */
    static const int32_t FDCANx_FDCAN_TTOST_SYS_POS      = 4;    /** @brief Synchronization state */
    static const int32_t FDCANx_FDCAN_TTOST_GTP_POS      = 6;    /** @brief Quality of global time phase */
    static const int32_t FDCANx_FDCAN_TTOST_QCS_POS      = 7;    /** @brief Quality of clock speed */
    static const int32_t FDCANx_FDCAN_TTOST_RTO_POS      = 8;    /** @brief Reference trigger offset */
    static const int32_t FDCANx_FDCAN_TTOST_WGTD_POS     = 22;   /** @brief Wait for global time discontinuity */
    static const int32_t FDCANx_FDCAN_TTOST_GFI_POS      = 23;   /** @brief Gap finished indicator. */
    static const int32_t FDCANx_FDCAN_TTOST_TMP_POS      = 24;   /** @brief Time master priority */
    static const int32_t FDCANx_FDCAN_TTOST_GSI_POS      = 27;   /** @brief Gap started indicator. */
    static const int32_t FDCANx_FDCAN_TTOST_WFE_POS      = 28;   /** @brief Wait for event */
    static const int32_t FDCANx_FDCAN_TTOST_AWE_POS      = 29;   /** @brief Application watchdog event */
    static const int32_t FDCANx_FDCAN_TTOST_WECS_POS     = 30;   /** @brief Wait for external clock synchronization */
    static const int32_t FDCANx_FDCAN_TTOST_SPL_POS      = 31;   /** @brief Schedule phase lock */
    static const int32_t FDCANx_FDCAN_TURNA_NAV_POS      = 0;    /** @brief Numerator actual value */
    static const int32_t FDCANx_FDCAN_TTLGT_LT_POS       = 0;    /** @brief Local time */
    static const int32_t FDCANx_FDCAN_TTLGT_GT_POS       = 16;   /** @brief Global time */
    static const int32_t FDCANx_FDCAN_TTCTC_CT_POS       = 0;    /** @brief Cycle time */
    static const int32_t FDCANx_FDCAN_TTCTC_CC_POS       = 16;   /** @brief Cycle count */
    static const int32_t FDCANx_FDCAN_TTCPT_CT_POS       = 0;    /** @brief Cycle count value */
    static const int32_t FDCANx_FDCAN_TTCPT_SWV_POS      = 16;   /** @brief Stop watch value */
    static const int32_t FDCANx_FDCAN_TTCSM_CSM_POS      = 0;    /** @brief Cycle sync mark */
    static const int32_t FDCANx_FDCAN_TTTS_SWTDEL_POS    = 0;    /** @brief Stop watch trigger input selection */
    static const int32_t FDCANx_FDCAN_TTTS_EVTSEL_POS    = 4;    /** @brief Event trigger input selection */

    /**** @subsection Enumerated FDCANx Register Field Positions ****/

    static const int32_t FDCANx_FDCAN_DBTP_DTSEGx_POS[3] = {
      [1] = 8,   /** @brief Data time segment after sample point */
      [2] = 4,   /** @brief Data time segment after sample point */
    };

    static const int32_t FDCANx_FDCAN_IR_RFxN_POS[2] = {
      [0] = 0,   /** @brief Rx FIFO 0 new message */
      [1] = 4,   /** @brief Rx FIFO 1 new message */
    };

    static const int32_t FDCANx_FDCAN_IR_RFxW_POS[2] = {
      [0] = 1,   /** @brief Rx FIFO 0 full */
      [1] = 5,   /** @brief Rx FIFO 1 watermark reached */
    };

    static const int32_t FDCANx_FDCAN_IR_RFxF_POS[2] = {
      [0] = 2,   /** @brief Rx FIFO 0 full */
      [1] = 6,   /** @brief Rx FIFO 1 watermark reached */
    };

    static const int32_t FDCANx_FDCAN_IR_RFxL_POS[2] = {
      [0] = 3,   /** @brief Rx FIFO 0 message lost */
      [1] = 7,   /** @brief Rx FIFO 1 message lost */
    };

    static const int32_t FDCANx_FDCAN_IE_RFxNE_POS[2] = {
      [0] = 0,   /** @brief Rx FIFO 0 new message enable */
      [1] = 4,   /** @brief Rx FIFO 1 new message enable */
    };

    static const int32_t FDCANx_FDCAN_IE_RFxWE_POS[2] = {
      [0] = 1,   /** @brief Rx FIFO 0 full enable */
      [1] = 5,   /** @brief Rx FIFO 1 watermark reached enable */
    };

    static const int32_t FDCANx_FDCAN_IE_RFxFE_POS[2] = {
      [0] = 2,   /** @brief Rx FIFO 0 full enable */
      [1] = 6,   /** @brief Rx FIFO 1 watermark reached enable */
    };

    static const int32_t FDCANx_FDCAN_IE_RFxLE_POS[2] = {
      [0] = 3,   /** @brief Rx FIFO 0 message lost enable */
      [1] = 7,   /** @brief Rx FIFO 1 message lost enable */
    };

    static const int32_t FDCANx_FDCAN_ILS_RFxNL_POS[2] = {
      [0] = 0,   /** @brief Rx FIFO 0 new message interrupt line */
      [1] = 4,   /** @brief Rx FIFO 1 new message interrupt line */
    };

    static const int32_t FDCANx_FDCAN_ILS_RFxWL_POS[2] = {
      [0] = 1,   /** @brief Rx FIFO 0 watermark reached interrupt line */
      [1] = 5,   /** @brief Rx FIFO 1 watermark reached interrupt line */
    };

    static const int32_t FDCANx_FDCAN_ILS_RFxFL_POS[2] = {
      [0] = 2,   /** @brief Rx FIFO 0 full interrupt line */
      [1] = 6,   /** @brief Rx FIFO 1 full interrupt line */
    };

    static const int32_t FDCANx_FDCAN_ILS_RFxLL_POS[2] = {
      [0] = 3,   /** @brief Rx FIFO 0 message lost interrupt line */
      [1] = 7,   /** @brief Rx FIFO 1 message lost interrupt line */
    };

    static const int32_t FDCANx_FDCAN_ILE_EINTx_POS[2] = {
      [0] = 0,   /** @brief Enable interrupt line 0 */
      [1] = 1,   /** @brief Enable interrupt line 1 */
    };

    static const int32_t FDCANx_FDCAN_NDAT1_NDx_POS[32] = {
      [0]  = 0,    /** @brief New data */
      [1]  = 1,    /** @brief New data */
      [2]  = 2,    /** @brief New data */
      [3]  = 3,    /** @brief New data */
      [4]  = 4,    /** @brief New data */
      [5]  = 5,    /** @brief New data */
      [6]  = 6,    /** @brief New data */
      [7]  = 7,    /** @brief New data */
      [8]  = 8,    /** @brief New data */
      [9]  = 9,    /** @brief New data */
      [10] = 10,   /** @brief New data */
      [11] = 11,   /** @brief New data */
      [12] = 12,   /** @brief New data */
      [13] = 13,   /** @brief New data */
      [14] = 14,   /** @brief New data */
      [15] = 15,   /** @brief New data */
      [16] = 16,   /** @brief New data */
      [17] = 17,   /** @brief New data */
      [18] = 18,   /** @brief New data */
      [19] = 19,   /** @brief New data */
      [20] = 20,   /** @brief New data */
      [21] = 21,   /** @brief New data */
      [22] = 22,   /** @brief New data */
      [23] = 23,   /** @brief New data */
      [24] = 24,   /** @brief New data */
      [25] = 25,   /** @brief New data */
      [26] = 26,   /** @brief New data */
      [27] = 27,   /** @brief New data */
      [28] = 28,   /** @brief New data */
      [29] = 29,   /** @brief New data */
      [30] = 30,   /** @brief New data */
      [31] = 31,   /** @brief New data */
    };

    static const int32_t FDCANx_FDCAN_NDAT2_ND3x_POS[10] = {
      [3]  = 1,   /** @brief New data */
      [4]  = 2,   /** @brief New data */
      [5]  = 3,   /** @brief New data */
      [6]  = 4,   /** @brief New data */
      [7]  = 5,   /** @brief New data */
      [8]  = 6,   /** @brief New data */
      [9]  = 7,   /** @brief New data */
    };

    static const int32_t FDCANx_FDCAN_RXESC_FxDS_POS[2] = {
      [0] = 0,   /** @brief Rx FIFO 1 data field size: */
      [1] = 4,   /** @brief Rx FIFO 0 data field size: */
    };

    static const int32_t FDCANx_FDCAN_TTIR_SEx_POS[3] = {
      [1] = 12,   /** @brief Scheduling error 1 */
      [2] = 13,   /** @brief Scheduling error 2 */
    };

    static const int32_t FDCANx_FDCAN_TTIE_SExE_POS[3] = {
      [1] = 12,   /** @brief Scheduling error 1 interrupt enable */
      [2] = 13,   /** @brief Scheduling error 2 interrupt enable */
    };

    static const int32_t FDCANx_FDCAN_TTILS_SExL_POS[3] = {
      [1] = 12,   /** @brief Scheduling error 1 interrupt line */
      [2] = 13,   /** @brief Scheduling error 2 interrupt line */
    };

    /**********************************************************************************************
     * @section CAN_CCU Register Information
     **********************************************************************************************/

    /**** @subsection CAN_CCU Register Pointers ****/

    static RW_ uint32_t* const CAN_CCU_CREL_PTR    = (RW_ uint32_t* const)0x4000A800U;   /** @brief Clock calibration unit core release register */
    static RW_ uint32_t* const CAN_CCU_CCFG_PTR    = (RW_ uint32_t* const)0x4000A804U;   /** @brief Calibration configuration register */
    static RW_ uint32_t* const CAN_CCU_CSTAT_PTR   = (RW_ uint32_t* const)0x4000A808U;   /** @brief Calibration status register */
    static RW_ uint32_t* const CAN_CCU_CWD_PTR     = (RW_ uint32_t* const)0x4000A80CU;   /** @brief Calibration watchdog register */
    static RW_ uint32_t* const CAN_CCU_IR_PTR      = (RW_ uint32_t* const)0x4000A810U;   /** @brief Clock calibration unit interrupt register */
    static RW_ uint32_t* const CAN_CCU_IE_PTR      = (RW_ uint32_t* const)0x4000A814U;   /** @brief Clock calibration unit interrupt enable register */

    /**** @subsection CAN_CCU Register Reset Values ****/

    static const uint32_t CAN_CCU_CREL_RST    = 0x00000000U;   /** @brief CREL register reset value. */
    static const uint32_t CAN_CCU_CCFG_RST    = 0x00000000U;   /** @brief CCFG register reset value. */
    static const uint32_t CAN_CCU_CSTAT_RST   = 0x00000000U;   /** @brief CSTAT register reset value. */
    static const uint32_t CAN_CCU_CWD_RST     = 0x00000000U;   /** @brief CWD register reset value. */
    static const uint32_t CAN_CCU_IR_RST      = 0x00000000U;   /** @brief IR register reset value. */
    static const uint32_t CAN_CCU_IE_RST      = 0x00000000U;   /** @brief IE register reset value. */

    /**** @subsection Enumerated CAN_CCU Register Value Types ****/

    typedef uint32_t CAN_CCU_CREL_t;    /** @brief CREL register value type. */
    typedef uint32_t CAN_CCU_CCFG_t;    /** @brief CCFG register value type. */
    typedef uint32_t CAN_CCU_CSTAT_t;   /** @brief CSTAT register value type. */
    typedef uint32_t CAN_CCU_CWD_t;     /** @brief CWD register value type. */
    typedef uint32_t CAN_CCU_IR_t;      /** @brief IR register value type. */
    typedef uint32_t CAN_CCU_IE_t;      /** @brief IE register value type. */

    /**** @subsection Enumerated CAN_CCU Register Pointer Types ****/

    typedef uint32_t* const CAN_CCU_CREL_PTR_t;    /** @brief CREL register pointer type. */
    typedef uint32_t* const CAN_CCU_CCFG_PTR_t;    /** @brief CCFG register pointer type. */
    typedef uint32_t* const CAN_CCU_CSTAT_PTR_t;   /** @brief CSTAT register pointer type. */
    typedef uint32_t* const CAN_CCU_CWD_PTR_t;     /** @brief CWD register pointer type. */
    typedef uint32_t* const CAN_CCU_IR_PTR_t;      /** @brief IR register pointer type. */
    typedef uint32_t* const CAN_CCU_IE_PTR_t;      /** @brief IE register pointer type. */

    /**** @subsection CAN_CCU Register Field Masks ****/

    static const uint32_t CAN_CCU_CREL_DAY_MASK       = 0x000000FFU;   /** @brief Time stamp day */
    static const uint32_t CAN_CCU_CREL_MON_MASK       = 0x0000FF00U;   /** @brief Time stamp month */
    static const uint32_t CAN_CCU_CREL_YEAR_MASK      = 0x000F0000U;   /** @brief Time stamp year */
    static const uint32_t CAN_CCU_CREL_SUBSTEP_MASK   = 0x00F00000U;   /** @brief Sub-step of core release */
    static const uint32_t CAN_CCU_CREL_STEP_MASK      = 0x0F000000U;   /** @brief Step of core release */
    static const uint32_t CAN_CCU_CREL_REL_MASK       = 0xF0000000U;   /** @brief Core release */
    static const uint32_t CAN_CCU_CCFG_TQBT_MASK      = 0x0000001FU;   /** @brief Time quanta per bit time */
    static const uint32_t CAN_CCU_CCFG_BCC_MASK       = 0x00000040U;   /** @brief Bypass clock calibration */
    static const uint32_t CAN_CCU_CCFG_CFL_MASK       = 0x00000080U;   /** @brief Calibration field length */
    static const uint32_t CAN_CCU_CCFG_OCPM_MASK      = 0x0000FF00U;   /** @brief Oscillator clock periods minimum */
    static const uint32_t CAN_CCU_CCFG_CDIV_MASK      = 0x000F0000U;   /** @brief Clock divider */
    static const uint32_t CAN_CCU_CCFG_SWR_MASK       = 0x80000000U;   /** @brief Software reset */
    static const uint32_t CAN_CCU_CSTAT_OCPC_MASK     = 0x0003FFFFU;   /** @brief Oscillator clock period counter */
    static const uint32_t CAN_CCU_CSTAT_TQC_MASK      = 0x1FFC0000U;   /** @brief Time quanta counter */
    static const uint32_t CAN_CCU_CSTAT_CALS_MASK     = 0xC0000000U;   /** @brief Calibration state */
    static const uint32_t CAN_CCU_CWD_WDC_MASK        = 0x0000FFFFU;   /** @brief WDC */
    static const uint32_t CAN_CCU_CWD_WDV_MASK        = 0xFFFF0000U;   /** @brief WDV */
    static const uint32_t CAN_CCU_IR_CWE_MASK         = 0x00000001U;   /** @brief Calibration watchdog event */
    static const uint32_t CAN_CCU_IR_CSC_MASK         = 0x00000002U;   /** @brief Calibration state changed */
    static const uint32_t CAN_CCU_IE_CWEE_MASK        = 0x00000001U;   /** @brief Calibration watchdog event enable */
    static const uint32_t CAN_CCU_IE_CSCE_MASK        = 0x00000002U;   /** @brief Calibration state changed enable */

    /**** @subsection CAN_CCU Register Field Positions ****/

    static const int32_t CAN_CCU_CREL_DAY_POS       = 0;    /** @brief Time stamp day */
    static const int32_t CAN_CCU_CREL_MON_POS       = 8;    /** @brief Time stamp month */
    static const int32_t CAN_CCU_CREL_YEAR_POS      = 16;   /** @brief Time stamp year */
    static const int32_t CAN_CCU_CREL_SUBSTEP_POS   = 20;   /** @brief Sub-step of core release */
    static const int32_t CAN_CCU_CREL_STEP_POS      = 24;   /** @brief Step of core release */
    static const int32_t CAN_CCU_CREL_REL_POS       = 28;   /** @brief Core release */
    static const int32_t CAN_CCU_CCFG_TQBT_POS      = 0;    /** @brief Time quanta per bit time */
    static const int32_t CAN_CCU_CCFG_BCC_POS       = 6;    /** @brief Bypass clock calibration */
    static const int32_t CAN_CCU_CCFG_CFL_POS       = 7;    /** @brief Calibration field length */
    static const int32_t CAN_CCU_CCFG_OCPM_POS      = 8;    /** @brief Oscillator clock periods minimum */
    static const int32_t CAN_CCU_CCFG_CDIV_POS      = 16;   /** @brief Clock divider */
    static const int32_t CAN_CCU_CCFG_SWR_POS       = 31;   /** @brief Software reset */
    static const int32_t CAN_CCU_CSTAT_OCPC_POS     = 0;    /** @brief Oscillator clock period counter */
    static const int32_t CAN_CCU_CSTAT_TQC_POS      = 18;   /** @brief Time quanta counter */
    static const int32_t CAN_CCU_CSTAT_CALS_POS     = 30;   /** @brief Calibration state */
    static const int32_t CAN_CCU_CWD_WDC_POS        = 0;    /** @brief WDC */
    static const int32_t CAN_CCU_CWD_WDV_POS        = 16;   /** @brief WDV */
    static const int32_t CAN_CCU_IR_CWE_POS         = 0;    /** @brief Calibration watchdog event */
    static const int32_t CAN_CCU_IR_CSC_POS         = 1;    /** @brief Calibration state changed */
    static const int32_t CAN_CCU_IE_CWEE_POS        = 0;    /** @brief Calibration watchdog event enable */
    static const int32_t CAN_CCU_IE_CSCE_POS        = 1;    /** @brief Calibration state changed enable */

    /**********************************************************************************************
     * @section MDIOS Register Information
     **********************************************************************************************/

    /**** @subsection MDIOS Register Pointers ****/

    static RW_ uint32_t* const MDIOS_MDIOS_CR_PTR      = (RW_ uint32_t* const)0x40009400U;   /** @brief MDIOS configuration register */
    static RO_ uint32_t* const MDIOS_MDIOS_WRFR_PTR    = (RO_ uint32_t* const)0x40009404U;   /** @brief MDIOS write flag register */
    static RW_ uint32_t* const MDIOS_MDIOS_CWRFR_PTR   = (RW_ uint32_t* const)0x40009408U;   /** @brief MDIOS clear write flag register */
    static RO_ uint32_t* const MDIOS_MDIOS_RDFR_PTR    = (RO_ uint32_t* const)0x4000940CU;   /** @brief MDIOS read flag register */
    static RW_ uint32_t* const MDIOS_MDIOS_CRDFR_PTR   = (RW_ uint32_t* const)0x40009410U;   /** @brief MDIOS clear read flag register */
    static RO_ uint32_t* const MDIOS_MDIOS_SR_PTR      = (RO_ uint32_t* const)0x40009414U;   /** @brief MDIOS status register */
    static RW_ uint32_t* const MDIOS_MDIOS_CLRFR_PTR   = (RW_ uint32_t* const)0x40009418U;   /** @brief MDIOS clear flag register */

    /**** @subsection Enumerated MDIOS Register Pointers ****/

    static RO_ uint32_t* const MDIOS_MDIOS_DINRx_PTR[32] = {
      [0]  = (RO_ uint32_t* const)0x4000941CU,   /** @brief MDIOS input data register 0 */
      [1]  = (RO_ uint32_t* const)0x40009420U,   /** @brief MDIOS input data register 1 */
      [2]  = (RO_ uint32_t* const)0x40009424U,   /** @brief MDIOS input data register 2 */
      [3]  = (RO_ uint32_t* const)0x40009428U,   /** @brief MDIOS input data register 3 */
      [4]  = (RO_ uint32_t* const)0x4000942CU,   /** @brief MDIOS input data register 4 */
      [5]  = (RO_ uint32_t* const)0x40009430U,   /** @brief MDIOS input data register 5 */
      [6]  = (RO_ uint32_t* const)0x40009434U,   /** @brief MDIOS input data register 6 */
      [7]  = (RO_ uint32_t* const)0x40009438U,   /** @brief MDIOS input data register 7 */
      [8]  = (RO_ uint32_t* const)0x4000943CU,   /** @brief MDIOS input data register 8 */
      [9]  = (RO_ uint32_t* const)0x40009440U,   /** @brief MDIOS input data register 9 */
      [10] = (RO_ uint32_t* const)0x40009444U,   /** @brief MDIOS input data register 10 */
      [11] = (RO_ uint32_t* const)0x40009448U,   /** @brief MDIOS input data register 11 */
      [12] = (RO_ uint32_t* const)0x4000944CU,   /** @brief MDIOS input data register 12 */
      [13] = (RO_ uint32_t* const)0x40009450U,   /** @brief MDIOS input data register 13 */
      [14] = (RO_ uint32_t* const)0x40009454U,   /** @brief MDIOS input data register 14 */
      [15] = (RO_ uint32_t* const)0x40009458U,   /** @brief MDIOS input data register 15 */
      [16] = (RO_ uint32_t* const)0x4000945CU,   /** @brief MDIOS input data register 16 */
      [17] = (RO_ uint32_t* const)0x40009460U,   /** @brief MDIOS input data register 17 */
      [18] = (RO_ uint32_t* const)0x40009464U,   /** @brief MDIOS input data register 18 */
      [19] = (RO_ uint32_t* const)0x40009468U,   /** @brief MDIOS input data register 19 */
      [20] = (RO_ uint32_t* const)0x4000946CU,   /** @brief MDIOS input data register 20 */
      [21] = (RO_ uint32_t* const)0x40009470U,   /** @brief MDIOS input data register 21 */
      [22] = (RO_ uint32_t* const)0x40009474U,   /** @brief MDIOS input data register 22 */
      [23] = (RO_ uint32_t* const)0x40009478U,   /** @brief MDIOS input data register 23 */
      [24] = (RO_ uint32_t* const)0x4000947CU,   /** @brief MDIOS input data register 24 */
      [25] = (RO_ uint32_t* const)0x40009480U,   /** @brief MDIOS input data register 25 */
      [26] = (RO_ uint32_t* const)0x40009484U,   /** @brief MDIOS input data register 26 */
      [27] = (RO_ uint32_t* const)0x40009488U,   /** @brief MDIOS input data register 27 */
      [28] = (RO_ uint32_t* const)0x4000948CU,   /** @brief MDIOS input data register 28 */
      [29] = (RO_ uint32_t* const)0x40009490U,   /** @brief MDIOS input data register 29 */
      [30] = (RO_ uint32_t* const)0x40009494U,   /** @brief MDIOS input data register 30 */
      [31] = (RO_ uint32_t* const)0x40009498U,   /** @brief MDIOS input data register 31 */
    };

    static RW_ uint32_t* const MDIOS_MDIOS_DOUTRx_PTR[32] = {
      [0]  = (RW_ uint32_t* const)0x4000949CU,   /** @brief MDIOS output data register 0 */
      [1]  = (RW_ uint32_t* const)0x400094A0U,   /** @brief MDIOS output data register 1 */
      [2]  = (RW_ uint32_t* const)0x400094A4U,   /** @brief MDIOS output data register 2 */
      [3]  = (RW_ uint32_t* const)0x400094A8U,   /** @brief MDIOS output data register 3 */
      [4]  = (RW_ uint32_t* const)0x400094ACU,   /** @brief MDIOS output data register 4 */
      [5]  = (RW_ uint32_t* const)0x400094B0U,   /** @brief MDIOS output data register 5 */
      [6]  = (RW_ uint32_t* const)0x400094B4U,   /** @brief MDIOS output data register 6 */
      [7]  = (RW_ uint32_t* const)0x400094B8U,   /** @brief MDIOS output data register 7 */
      [8]  = (RW_ uint32_t* const)0x400094BCU,   /** @brief MDIOS output data register 8 */
      [9]  = (RW_ uint32_t* const)0x400094C0U,   /** @brief MDIOS output data register 9 */
      [10] = (RW_ uint32_t* const)0x400094C4U,   /** @brief MDIOS output data register 10 */
      [11] = (RW_ uint32_t* const)0x400094C8U,   /** @brief MDIOS output data register 11 */
      [12] = (RW_ uint32_t* const)0x400094CCU,   /** @brief MDIOS output data register 12 */
      [13] = (RW_ uint32_t* const)0x400094D0U,   /** @brief MDIOS output data register 13 */
      [14] = (RW_ uint32_t* const)0x400094D4U,   /** @brief MDIOS output data register 14 */
      [15] = (RW_ uint32_t* const)0x400094D8U,   /** @brief MDIOS output data register 15 */
      [16] = (RW_ uint32_t* const)0x400094DCU,   /** @brief MDIOS output data register 16 */
      [17] = (RW_ uint32_t* const)0x400094E0U,   /** @brief MDIOS output data register 17 */
      [18] = (RW_ uint32_t* const)0x400094E4U,   /** @brief MDIOS output data register 18 */
      [19] = (RW_ uint32_t* const)0x400094E8U,   /** @brief MDIOS output data register 19 */
      [20] = (RW_ uint32_t* const)0x400094ECU,   /** @brief MDIOS output data register 20 */
      [21] = (RW_ uint32_t* const)0x400094F0U,   /** @brief MDIOS output data register 21 */
      [22] = (RW_ uint32_t* const)0x400094F4U,   /** @brief MDIOS output data register 22 */
      [23] = (RW_ uint32_t* const)0x400094F8U,   /** @brief MDIOS output data register 23 */
      [24] = (RW_ uint32_t* const)0x400094FCU,   /** @brief MDIOS output data register 24 */
      [25] = (RW_ uint32_t* const)0x40009500U,   /** @brief MDIOS output data register 25 */
      [26] = (RW_ uint32_t* const)0x40009504U,   /** @brief MDIOS output data register 26 */
      [27] = (RW_ uint32_t* const)0x40009508U,   /** @brief MDIOS output data register 27 */
      [28] = (RW_ uint32_t* const)0x4000950CU,   /** @brief MDIOS output data register 28 */
      [29] = (RW_ uint32_t* const)0x40009510U,   /** @brief MDIOS output data register 29 */
      [30] = (RW_ uint32_t* const)0x40009514U,   /** @brief MDIOS output data register 30 */
      [31] = (RW_ uint32_t* const)0x40009518U,   /** @brief MDIOS output data register 31 */
    };

    /**** @subsection MDIOS Register Reset Values ****/

    static const uint32_t MDIOS_MDIOS_CR_RST      = 0x00000000U;   /** @brief MDIOS_CR register reset value. */
    static const uint32_t MDIOS_MDIOS_WRFR_RST    = 0x00000000U;   /** @brief MDIOS_WRFR register reset value. */
    static const uint32_t MDIOS_MDIOS_CWRFR_RST   = 0x00000000U;   /** @brief MDIOS_CWRFR register reset value. */
    static const uint32_t MDIOS_MDIOS_RDFR_RST    = 0x00000000U;   /** @brief MDIOS_RDFR register reset value. */
    static const uint32_t MDIOS_MDIOS_CRDFR_RST   = 0x00000000U;   /** @brief MDIOS_CRDFR register reset value. */
    static const uint32_t MDIOS_MDIOS_SR_RST      = 0x00000000U;   /** @brief MDIOS_SR register reset value. */
    static const uint32_t MDIOS_MDIOS_CLRFR_RST   = 0x00000000U;   /** @brief MDIOS_CLRFR register reset value. */

    /**** @subsection Enumerated MDIOS Register Reset Values ****/

    static const uint32_t MDIOS_MDIOS_DINRx_RST[32] = {
      [0]  = 0x00000000U,   /** @brief MDIOS_DINR0 register reset value. */
      [1]  = 0x00000000U,   /** @brief MDIOS_DINR1 register reset value. */
      [2]  = 0x00000000U,   /** @brief MDIOS_DINR2 register reset value. */
      [3]  = 0x00000000U,   /** @brief MDIOS_DINR3 register reset value. */
      [4]  = 0x00000000U,   /** @brief MDIOS_DINR4 register reset value. */
      [5]  = 0x00000000U,   /** @brief MDIOS_DINR5 register reset value. */
      [6]  = 0x00000000U,   /** @brief MDIOS_DINR6 register reset value. */
      [7]  = 0x00000000U,   /** @brief MDIOS_DINR7 register reset value. */
      [8]  = 0x00000000U,   /** @brief MDIOS_DINR8 register reset value. */
      [9]  = 0x00000000U,   /** @brief MDIOS_DINR9 register reset value. */
      [10] = 0x00000000U,   /** @brief MDIOS_DINR10 register reset value. */
      [11] = 0x00000000U,   /** @brief MDIOS_DINR11 register reset value. */
      [12] = 0x00000000U,   /** @brief MDIOS_DINR12 register reset value. */
      [13] = 0x00000000U,   /** @brief MDIOS_DINR13 register reset value. */
      [14] = 0x00000000U,   /** @brief MDIOS_DINR14 register reset value. */
      [15] = 0x00000000U,   /** @brief MDIOS_DINR15 register reset value. */
      [16] = 0x00000000U,   /** @brief MDIOS_DINR16 register reset value. */
      [17] = 0x00000000U,   /** @brief MDIOS_DINR17 register reset value. */
      [18] = 0x00000000U,   /** @brief MDIOS_DINR18 register reset value. */
      [19] = 0x00000000U,   /** @brief MDIOS_DINR19 register reset value. */
      [20] = 0x00000000U,   /** @brief MDIOS_DINR20 register reset value. */
      [21] = 0x00000000U,   /** @brief MDIOS_DINR21 register reset value. */
      [22] = 0x00000000U,   /** @brief MDIOS_DINR22 register reset value. */
      [23] = 0x00000000U,   /** @brief MDIOS_DINR23 register reset value. */
      [24] = 0x00000000U,   /** @brief MDIOS_DINR24 register reset value. */
      [25] = 0x00000000U,   /** @brief MDIOS_DINR25 register reset value. */
      [26] = 0x00000000U,   /** @brief MDIOS_DINR26 register reset value. */
      [27] = 0x00000000U,   /** @brief MDIOS_DINR27 register reset value. */
      [28] = 0x00000000U,   /** @brief MDIOS_DINR28 register reset value. */
      [29] = 0x00000000U,   /** @brief MDIOS_DINR29 register reset value. */
      [30] = 0x00000000U,   /** @brief MDIOS_DINR30 register reset value. */
      [31] = 0x00000000U,   /** @brief MDIOS_DINR31 register reset value. */
    };

    static const uint32_t MDIOS_MDIOS_DOUTRx_RST[32] = {
      [0]  = 0x00000000U,   /** @brief MDIOS_DOUTR0 register reset value. */
      [1]  = 0x00000000U,   /** @brief MDIOS_DOUTR1 register reset value. */
      [2]  = 0x00000000U,   /** @brief MDIOS_DOUTR2 register reset value. */
      [3]  = 0x00000000U,   /** @brief MDIOS_DOUTR3 register reset value. */
      [4]  = 0x00000000U,   /** @brief MDIOS_DOUTR4 register reset value. */
      [5]  = 0x00000000U,   /** @brief MDIOS_DOUTR5 register reset value. */
      [6]  = 0x00000000U,   /** @brief MDIOS_DOUTR6 register reset value. */
      [7]  = 0x00000000U,   /** @brief MDIOS_DOUTR7 register reset value. */
      [8]  = 0x00000000U,   /** @brief MDIOS_DOUTR8 register reset value. */
      [9]  = 0x00000000U,   /** @brief MDIOS_DOUTR9 register reset value. */
      [10] = 0x00000000U,   /** @brief MDIOS_DOUTR10 register reset value. */
      [11] = 0x00000000U,   /** @brief MDIOS_DOUTR11 register reset value. */
      [12] = 0x00000000U,   /** @brief MDIOS_DOUTR12 register reset value. */
      [13] = 0x00000000U,   /** @brief MDIOS_DOUTR13 register reset value. */
      [14] = 0x00000000U,   /** @brief MDIOS_DOUTR14 register reset value. */
      [15] = 0x00000000U,   /** @brief MDIOS_DOUTR15 register reset value. */
      [16] = 0x00000000U,   /** @brief MDIOS_DOUTR16 register reset value. */
      [17] = 0x00000000U,   /** @brief MDIOS_DOUTR17 register reset value. */
      [18] = 0x00000000U,   /** @brief MDIOS_DOUTR18 register reset value. */
      [19] = 0x00000000U,   /** @brief MDIOS_DOUTR19 register reset value. */
      [20] = 0x00000000U,   /** @brief MDIOS_DOUTR20 register reset value. */
      [21] = 0x00000000U,   /** @brief MDIOS_DOUTR21 register reset value. */
      [22] = 0x00000000U,   /** @brief MDIOS_DOUTR22 register reset value. */
      [23] = 0x00000000U,   /** @brief MDIOS_DOUTR23 register reset value. */
      [24] = 0x00000000U,   /** @brief MDIOS_DOUTR24 register reset value. */
      [25] = 0x00000000U,   /** @brief MDIOS_DOUTR25 register reset value. */
      [26] = 0x00000000U,   /** @brief MDIOS_DOUTR26 register reset value. */
      [27] = 0x00000000U,   /** @brief MDIOS_DOUTR27 register reset value. */
      [28] = 0x00000000U,   /** @brief MDIOS_DOUTR28 register reset value. */
      [29] = 0x00000000U,   /** @brief MDIOS_DOUTR29 register reset value. */
      [30] = 0x00000000U,   /** @brief MDIOS_DOUTR30 register reset value. */
      [31] = 0x00000000U,   /** @brief MDIOS_DOUTR31 register reset value. */
    };

    /**** @subsection Enumerated MDIOS Register Value Types ****/

    typedef uint32_t MDIOS_MDIOS_CR_t;       /** @brief MDIOS_CR register value type. */
    typedef uint32_t MDIOS_MDIOS_WRFR_t;     /** @brief MDIOS_WRFR register value type. */
    typedef uint32_t MDIOS_MDIOS_CWRFR_t;    /** @brief MDIOS_CWRFR register value type. */
    typedef uint32_t MDIOS_MDIOS_RDFR_t;     /** @brief MDIOS_RDFR register value type. */
    typedef uint32_t MDIOS_MDIOS_CRDFR_t;    /** @brief MDIOS_CRDFR register value type. */
    typedef uint32_t MDIOS_MDIOS_SR_t;       /** @brief MDIOS_SR register value type. */
    typedef uint32_t MDIOS_MDIOS_CLRFR_t;    /** @brief MDIOS_CLRFR register value type. */
    typedef uint32_t MDIOS_MDIOS_DINRx_t;    /** @brief MDIOS_DINRx register value type. */
    typedef uint32_t MDIOS_MDIOS_DOUTRx_t;   /** @brief MDIOS_DOUTRx register value type. */

    /**** @subsection Enumerated MDIOS Register Pointer Types ****/

    typedef uint32_t* const MDIOS_MDIOS_CR_PTR_t;       /** @brief MDIOS_CR register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_WRFR_PTR_t;     /** @brief MDIOS_WRFR register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_CWRFR_PTR_t;    /** @brief MDIOS_CWRFR register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_RDFR_PTR_t;     /** @brief MDIOS_RDFR register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_CRDFR_PTR_t;    /** @brief MDIOS_CRDFR register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_SR_PTR_t;       /** @brief MDIOS_SR register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_CLRFR_PTR_t;    /** @brief MDIOS_CLRFR register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_DINRx_PTR_t;    /** @brief MDIOS_DINRx register pointer type. */
    typedef uint32_t* const MDIOS_MDIOS_DOUTRx_PTR_t;   /** @brief MDIOS_DOUTRx register pointer type. */

    /**** @subsection MDIOS Register Field Masks ****/

    static const uint32_t MDIOS_MDIOS_CR_EN_MASK             = 0x00000001U;   /** @brief Peripheral enable */
    static const uint32_t MDIOS_MDIOS_CR_WRIE_MASK           = 0x00000002U;   /** @brief Register write interrupt enable */
    static const uint32_t MDIOS_MDIOS_CR_RDIE_MASK           = 0x00000004U;   /** @brief Register read interrupt enable */
    static const uint32_t MDIOS_MDIOS_CR_EIE_MASK            = 0x00000008U;   /** @brief Error interrupt enable */
    static const uint32_t MDIOS_MDIOS_CR_DPC_MASK            = 0x00000080U;   /** @brief Disable preamble check */
    static const uint32_t MDIOS_MDIOS_CR_PORT_ADDRESS_MASK   = 0x00001F00U;   /** @brief Slaves's address */
    static const uint32_t MDIOS_MDIOS_SR_PERF_MASK           = 0x00000001U;   /** @brief Preamble error flag */
    static const uint32_t MDIOS_MDIOS_SR_SERF_MASK           = 0x00000002U;   /** @brief Start error flag */
    static const uint32_t MDIOS_MDIOS_SR_TERF_MASK           = 0x00000004U;   /** @brief Turnaround error flag */
    static const uint32_t MDIOS_MDIOS_CLRFR_CPERF_MASK       = 0x00000001U;   /** @brief Clear the preamble error flag */
    static const uint32_t MDIOS_MDIOS_CLRFR_CSERF_MASK       = 0x00000002U;   /** @brief Clear the start error flag */
    static const uint32_t MDIOS_MDIOS_CLRFR_CTERF_MASK       = 0x00000004U;   /** @brief Clear the turnaround error flag */
    static const uint32_t MDIOS_MDIOS_DINRx_DIN0_MASK        = 0x0000FFFFU;   /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_MDIOS_DOUTRx_DOUT0_MASK      = 0x0000FFFFU;   /** @brief Output data sent to MDIO master during read frames */

    /**** @subsection MDIOS Register Field Positions ****/

    static const int32_t MDIOS_MDIOS_CR_EN_POS             = 0;   /** @brief Peripheral enable */
    static const int32_t MDIOS_MDIOS_CR_WRIE_POS           = 1;   /** @brief Register write interrupt enable */
    static const int32_t MDIOS_MDIOS_CR_RDIE_POS           = 2;   /** @brief Register read interrupt enable */
    static const int32_t MDIOS_MDIOS_CR_EIE_POS            = 3;   /** @brief Error interrupt enable */
    static const int32_t MDIOS_MDIOS_CR_DPC_POS            = 7;   /** @brief Disable preamble check */
    static const int32_t MDIOS_MDIOS_CR_PORT_ADDRESS_POS   = 8;   /** @brief Slaves's address */
    static const int32_t MDIOS_MDIOS_SR_PERF_POS           = 0;   /** @brief Preamble error flag */
    static const int32_t MDIOS_MDIOS_SR_SERF_POS           = 1;   /** @brief Start error flag */
    static const int32_t MDIOS_MDIOS_SR_TERF_POS           = 2;   /** @brief Turnaround error flag */
    static const int32_t MDIOS_MDIOS_CLRFR_CPERF_POS       = 0;   /** @brief Clear the preamble error flag */
    static const int32_t MDIOS_MDIOS_CLRFR_CSERF_POS       = 1;   /** @brief Clear the start error flag */
    static const int32_t MDIOS_MDIOS_CLRFR_CTERF_POS       = 2;   /** @brief Clear the turnaround error flag */
    static const int32_t MDIOS_MDIOS_DINRx_DIN0_POS        = 0;   /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_MDIOS_DOUTRx_DOUT0_POS      = 0;   /** @brief Output data sent to MDIO master during read frames */

    /**********************************************************************************************
     * @section OPAMP Register Information
     **********************************************************************************************/

    /**** @subsection OPAMP Register Pointers ****/

    static RW_ uint32_t* const OPAMP_OPAMP1_CSR_PTR   = (RW_ uint32_t* const)0x40009000U;   /** @brief OPAMP1 control/status register */
    static RW_ uint32_t* const OPAMP_OPAMP2_CSR_PTR   = (RW_ uint32_t* const)0x40009010U;   /** @brief OPAMP2 control/status register */

    /**** @subsection Enumerated OPAMP Register Pointers ****/

    static RW_ uint32_t* const OPAMP_OPAMPx_OTR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40009004U,   /** @brief OPAMP1 offset trimming register in normal mode */
      [2] = (RW_ uint32_t* const)0x40009014U,   /** @brief OPAMP2 offset trimming register in normal mode */
    };

    static RW_ uint32_t* const OPAMP_OPAMPx_HSOTR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x40009008U,   /** @brief OPAMP1 offset trimming register in low-power mode */
      [2] = (RW_ uint32_t* const)0x40009018U,   /** @brief OPAMP2 offset trimming register in low-power mode */
    };

    /**** @subsection OPAMP Register Reset Values ****/

    static const uint32_t OPAMP_OPAMP1_CSR_RST   = 0x00000000U;   /** @brief OPAMP1_CSR register reset value. */
    static const uint32_t OPAMP_OPAMP2_CSR_RST   = 0x00000000U;   /** @brief OPAMP2_CSR register reset value. */

    /**** @subsection Enumerated OPAMP Register Reset Values ****/

    static const uint32_t OPAMP_OPAMPx_OTR_RST[3] = {
      [1] = 0x00000000U,   /** @brief OPAMP1_OTR register reset value. */
      [2] = 0x00000000U,   /** @brief OPAMP2_OTR register reset value. */
    };

    static const uint32_t OPAMP_OPAMPx_HSOTR_RST[3] = {
      [1] = 0x00000000U,   /** @brief OPAMP1_HSOTR register reset value. */
      [2] = 0x00000000U,   /** @brief OPAMP2_HSOTR register reset value. */
    };

    /**** @subsection Enumerated OPAMP Register Value Types ****/

    typedef uint32_t OPAMP_OPAMP1_CSR_t;     /** @brief OPAMP1_CSR register value type. */
    typedef uint32_t OPAMP_OPAMPx_OTR_t;     /** @brief OPAMPx_OTR register value type. */
    typedef uint32_t OPAMP_OPAMPx_HSOTR_t;   /** @brief OPAMPx_HSOTR register value type. */
    typedef uint32_t OPAMP_OPAMP2_CSR_t;     /** @brief OPAMP2_CSR register value type. */

    /**** @subsection Enumerated OPAMP Register Pointer Types ****/

    typedef uint32_t* const OPAMP_OPAMP1_CSR_PTR_t;     /** @brief OPAMP1_CSR register pointer type. */
    typedef uint32_t* const OPAMP_OPAMPx_OTR_PTR_t;     /** @brief OPAMPx_OTR register pointer type. */
    typedef uint32_t* const OPAMP_OPAMPx_HSOTR_PTR_t;   /** @brief OPAMPx_HSOTR register pointer type. */
    typedef uint32_t* const OPAMP_OPAMP2_CSR_PTR_t;     /** @brief OPAMP2_CSR register pointer type. */

    /**** @subsection OPAMP Register Field Masks ****/

    static const uint32_t OPAMP_OPAMP1_CSR_OPAEN_MASK             = 0x00000001U;   /** @brief Operational amplifier enable */
    static const uint32_t OPAMP_OPAMP1_CSR_FORCE_VP_MASK          = 0x00000002U;   /** @brief Force internal reference on VP (reserved for test */
    static const uint32_t OPAMP_OPAMP1_CSR_VP_SEL_MASK            = 0x0000000CU;   /** @brief Operational amplifier PGA mode */
    static const uint32_t OPAMP_OPAMP1_CSR_VM_SEL_MASK            = 0x00000060U;   /** @brief Inverting input selection */
    static const uint32_t OPAMP_OPAMP1_CSR_OPAHSM_MASK            = 0x00000100U;   /** @brief Operational amplifier high-speed mode */
    static const uint32_t OPAMP_OPAMP1_CSR_CALON_MASK             = 0x00000800U;   /** @brief Calibration mode enabled */
    static const uint32_t OPAMP_OPAMP1_CSR_CALSEL_MASK            = 0x00003000U;   /** @brief Calibration selection */
    static const uint32_t OPAMP_OPAMP1_CSR_PGA_GAIN_MASK          = 0x0003C000U;   /** @brief Allows to switch from AOP offset trimmed values to AOP offset */
    static const uint32_t OPAMP_OPAMP1_CSR_USERTRIM_MASK          = 0x00040000U;   /** @brief User trimming enable */
    static const uint32_t OPAMP_OPAMP1_CSR_TSTREF_MASK            = 0x20000000U;   /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const uint32_t OPAMP_OPAMP1_CSR_CALOUT_MASK            = 0x40000000U;   /** @brief Operational amplifier calibration output */
    static const uint32_t OPAMP_OPAMPx_OTR_TRIMOFFSETN_MASK       = 0x0000001FU;   /** @brief Trim for NMOS differential pairs */
    static const uint32_t OPAMP_OPAMPx_OTR_TRIMOFFSETP_MASK       = 0x00001F00U;   /** @brief Trim for PMOS differential pairs */
    static const uint32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETN_MASK   = 0x0000001FU;   /** @brief Trim for NMOS differential pairs */
    static const uint32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETP_MASK   = 0x00001F00U;   /** @brief Trim for PMOS differential pairs */
    static const uint32_t OPAMP_OPAMP2_CSR_OPAEN_MASK             = 0x00000001U;   /** @brief Operational amplifier enable */
    static const uint32_t OPAMP_OPAMP2_CSR_FORCE_VP_MASK          = 0x00000002U;   /** @brief Force internal reference on VP (reserved for test) */
    static const uint32_t OPAMP_OPAMP2_CSR_VM_SEL_MASK            = 0x00000060U;   /** @brief Inverting input selection */
    static const uint32_t OPAMP_OPAMP2_CSR_OPAHSM_MASK            = 0x00000100U;   /** @brief Operational amplifier high-speed mode */
    static const uint32_t OPAMP_OPAMP2_CSR_CALON_MASK             = 0x00000800U;   /** @brief Calibration mode enabled */
    static const uint32_t OPAMP_OPAMP2_CSR_CALSEL_MASK            = 0x00003000U;   /** @brief Calibration selection */
    static const uint32_t OPAMP_OPAMP2_CSR_PGA_GAIN_MASK          = 0x0003C000U;   /** @brief Operational amplifier programmable amplifier gain value */
    static const uint32_t OPAMP_OPAMP2_CSR_USERTRIM_MASK          = 0x00040000U;   /** @brief User trimming enable */
    static const uint32_t OPAMP_OPAMP2_CSR_TSTREF_MASK            = 0x20000000U;   /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const uint32_t OPAMP_OPAMP2_CSR_CALOUT_MASK            = 0x40000000U;   /** @brief Operational amplifier calibration output */

    /**** @subsection OPAMP Register Field Positions ****/

    static const int32_t OPAMP_OPAMP1_CSR_OPAEN_POS             = 0;    /** @brief Operational amplifier enable */
    static const int32_t OPAMP_OPAMP1_CSR_FORCE_VP_POS          = 1;    /** @brief Force internal reference on VP (reserved for test */
    static const int32_t OPAMP_OPAMP1_CSR_VP_SEL_POS            = 2;    /** @brief Operational amplifier PGA mode */
    static const int32_t OPAMP_OPAMP1_CSR_VM_SEL_POS            = 5;    /** @brief Inverting input selection */
    static const int32_t OPAMP_OPAMP1_CSR_OPAHSM_POS            = 8;    /** @brief Operational amplifier high-speed mode */
    static const int32_t OPAMP_OPAMP1_CSR_CALON_POS             = 11;   /** @brief Calibration mode enabled */
    static const int32_t OPAMP_OPAMP1_CSR_CALSEL_POS            = 12;   /** @brief Calibration selection */
    static const int32_t OPAMP_OPAMP1_CSR_PGA_GAIN_POS          = 14;   /** @brief Allows to switch from AOP offset trimmed values to AOP offset */
    static const int32_t OPAMP_OPAMP1_CSR_USERTRIM_POS          = 18;   /** @brief User trimming enable */
    static const int32_t OPAMP_OPAMP1_CSR_TSTREF_POS            = 29;   /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const int32_t OPAMP_OPAMP1_CSR_CALOUT_POS            = 30;   /** @brief Operational amplifier calibration output */
    static const int32_t OPAMP_OPAMPx_OTR_TRIMOFFSETN_POS       = 0;    /** @brief Trim for NMOS differential pairs */
    static const int32_t OPAMP_OPAMPx_OTR_TRIMOFFSETP_POS       = 8;    /** @brief Trim for PMOS differential pairs */
    static const int32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETN_POS   = 0;    /** @brief Trim for NMOS differential pairs */
    static const int32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETP_POS   = 8;    /** @brief Trim for PMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_CSR_OPAEN_POS             = 0;    /** @brief Operational amplifier enable */
    static const int32_t OPAMP_OPAMP2_CSR_FORCE_VP_POS          = 1;    /** @brief Force internal reference on VP (reserved for test) */
    static const int32_t OPAMP_OPAMP2_CSR_VM_SEL_POS            = 5;    /** @brief Inverting input selection */
    static const int32_t OPAMP_OPAMP2_CSR_OPAHSM_POS            = 8;    /** @brief Operational amplifier high-speed mode */
    static const int32_t OPAMP_OPAMP2_CSR_CALON_POS             = 11;   /** @brief Calibration mode enabled */
    static const int32_t OPAMP_OPAMP2_CSR_CALSEL_POS            = 12;   /** @brief Calibration selection */
    static const int32_t OPAMP_OPAMP2_CSR_PGA_GAIN_POS          = 14;   /** @brief Operational amplifier programmable amplifier gain value */
    static const int32_t OPAMP_OPAMP2_CSR_USERTRIM_POS          = 18;   /** @brief User trimming enable */
    static const int32_t OPAMP_OPAMP2_CSR_TSTREF_POS            = 29;   /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const int32_t OPAMP_OPAMP2_CSR_CALOUT_POS            = 30;   /** @brief Operational amplifier calibration output */

    /**********************************************************************************************
     * @section SWPMI Register Information
     **********************************************************************************************/

    /**** @subsection SWPMI Register Pointers ****/

    static RW_ uint32_t* const SWPMI_CR_PTR    = (RW_ uint32_t* const)0x40008800U;   /** @brief SWPMI configuration/control register */
    static RW_ uint32_t* const SWPMI_BRR_PTR   = (RW_ uint32_t* const)0x40008804U;   /** @brief SWPMI bitrate register */
    static RO_ uint32_t* const SWPMI_ISR_PTR   = (RO_ uint32_t* const)0x4000880CU;   /** @brief SWPMI interrupt and status register */
    static RW_ uint32_t* const SWPMI_ICR_PTR   = (RW_ uint32_t* const)0x40008810U;   /** @brief SWPMI interrupt flag clear register */
    static RW_ uint32_t* const SWPMI_IER_PTR   = (RW_ uint32_t* const)0x40008814U;   /** @brief SWPMI interrupt enable register */
    static RO_ uint32_t* const SWPMI_RFL_PTR   = (RO_ uint32_t* const)0x40008818U;   /** @brief SWPMI receive frame length register */
    static RW_ uint32_t* const SWPMI_TDR_PTR   = (RW_ uint32_t* const)0x4000881CU;   /** @brief SWPMI transmit data register */
    static RO_ uint32_t* const SWPMI_RDR_PTR   = (RO_ uint32_t* const)0x40008820U;   /** @brief SWPMI receive data register */
    static RW_ uint32_t* const SWPMI_OR_PTR    = (RW_ uint32_t* const)0x40008824U;   /** @brief SWPMI option register */

    /**** @subsection SWPMI Register Reset Values ****/

    static const uint32_t SWPMI_CR_RST    = 0x00000000U;   /** @brief CR register reset value. */
    static const uint32_t SWPMI_BRR_RST   = 0x00000001U;   /** @brief BRR register reset value. */
    static const uint32_t SWPMI_ISR_RST   = 0x000002C2U;   /** @brief ISR register reset value. */
    static const uint32_t SWPMI_ICR_RST   = 0x00000000U;   /** @brief ICR register reset value. */
    static const uint32_t SWPMI_IER_RST   = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t SWPMI_RFL_RST   = 0x00000000U;   /** @brief RFL register reset value. */
    static const uint32_t SWPMI_TDR_RST   = 0x00000000U;   /** @brief TDR register reset value. */
    static const uint32_t SWPMI_RDR_RST   = 0x00000000U;   /** @brief RDR register reset value. */
    static const uint32_t SWPMI_OR_RST    = 0x00000000U;   /** @brief OR register reset value. */

    /**** @subsection Enumerated SWPMI Register Value Types ****/

    typedef uint32_t SWPMI_CR_t;    /** @brief CR register value type. */
    typedef uint32_t SWPMI_BRR_t;   /** @brief BRR register value type. */
    typedef uint32_t SWPMI_ISR_t;   /** @brief ISR register value type. */
    typedef uint32_t SWPMI_ICR_t;   /** @brief ICR register value type. */
    typedef uint32_t SWPMI_IER_t;   /** @brief IER register value type. */
    typedef uint32_t SWPMI_RFL_t;   /** @brief RFL register value type. */
    typedef uint32_t SWPMI_TDR_t;   /** @brief TDR register value type. */
    typedef uint32_t SWPMI_RDR_t;   /** @brief RDR register value type. */
    typedef uint32_t SWPMI_OR_t;    /** @brief OR register value type. */

    /**** @subsection Enumerated SWPMI Register Pointer Types ****/

    typedef uint32_t* const SWPMI_CR_PTR_t;    /** @brief CR register pointer type. */
    typedef uint32_t* const SWPMI_BRR_PTR_t;   /** @brief BRR register pointer type. */
    typedef uint32_t* const SWPMI_ISR_PTR_t;   /** @brief ISR register pointer type. */
    typedef uint32_t* const SWPMI_ICR_PTR_t;   /** @brief ICR register pointer type. */
    typedef uint32_t* const SWPMI_IER_PTR_t;   /** @brief IER register pointer type. */
    typedef uint32_t* const SWPMI_RFL_PTR_t;   /** @brief RFL register pointer type. */
    typedef uint32_t* const SWPMI_TDR_PTR_t;   /** @brief TDR register pointer type. */
    typedef uint32_t* const SWPMI_RDR_PTR_t;   /** @brief RDR register pointer type. */
    typedef uint32_t* const SWPMI_OR_PTR_t;    /** @brief OR register pointer type. */

    /**** @subsection SWPMI Register Field Masks ****/

    static const uint32_t SWPMI_CR_RXDMA_MASK       = 0x00000001U;   /** @brief Reception DMA enable */
    static const uint32_t SWPMI_CR_TXDMA_MASK       = 0x00000002U;   /** @brief Transmission DMA enable */
    static const uint32_t SWPMI_CR_RXMODE_MASK      = 0x00000004U;   /** @brief Reception buffering mode */
    static const uint32_t SWPMI_CR_TXMODE_MASK      = 0x00000008U;   /** @brief Transmission buffering mode */
    static const uint32_t SWPMI_CR_LPBK_MASK        = 0x00000010U;   /** @brief Loopback mode enable */
    static const uint32_t SWPMI_CR_SWPACT_MASK      = 0x00000020U;   /** @brief Single wire protocol master interface activate */
    static const uint32_t SWPMI_CR_DEACT_MASK       = 0x00000400U;   /** @brief Single wire protocol master interface deactivate */
    static const uint32_t SWPMI_CR_SWPTEN_MASK      = 0x00000800U;   /** @brief Single wire protocol master transceiver enable */
    static const uint32_t SWPMI_BRR_BR_MASK         = 0x000000FFU;   /** @brief Bitrate prescaler */
    static const uint32_t SWPMI_ISR_RXBFF_MASK      = 0x00000001U;   /** @brief Receive buffer full flag */
    static const uint32_t SWPMI_ISR_TXBEF_MASK      = 0x00000002U;   /** @brief Transmit buffer empty flag */
    static const uint32_t SWPMI_ISR_RXBERF_MASK     = 0x00000004U;   /** @brief Receive CRC error flag */
    static const uint32_t SWPMI_ISR_RXOVRF_MASK     = 0x00000008U;   /** @brief Receive overrun error flag */
    static const uint32_t SWPMI_ISR_TXUNRF_MASK     = 0x00000010U;   /** @brief Transmit underrun error flag */
    static const uint32_t SWPMI_ISR_RXNE_MASK       = 0x00000020U;   /** @brief Receive data register not empty */
    static const uint32_t SWPMI_ISR_TXE_MASK        = 0x00000040U;   /** @brief Transmit data register empty */
    static const uint32_t SWPMI_ISR_TCF_MASK        = 0x00000080U;   /** @brief Transfer complete flag */
    static const uint32_t SWPMI_ISR_SRF_MASK        = 0x00000100U;   /** @brief Slave resume flag */
    static const uint32_t SWPMI_ISR_SUSP_MASK       = 0x00000200U;   /** @brief SUSPEND flag */
    static const uint32_t SWPMI_ISR_DEACTF_MASK     = 0x00000400U;   /** @brief DEACTIVATED flag */
    static const uint32_t SWPMI_ISR_RDYF_MASK       = 0x00000800U;   /** @brief Transceiver ready flag */
    static const uint32_t SWPMI_ICR_CRXBFF_MASK     = 0x00000001U;   /** @brief Clear receive buffer full flag */
    static const uint32_t SWPMI_ICR_CTXBEF_MASK     = 0x00000002U;   /** @brief Clear transmit buffer empty flag */
    static const uint32_t SWPMI_ICR_CRXBERF_MASK    = 0x00000004U;   /** @brief Clear receive CRC error flag */
    static const uint32_t SWPMI_ICR_CRXOVRF_MASK    = 0x00000008U;   /** @brief Clear receive overrun error flag */
    static const uint32_t SWPMI_ICR_CTXUNRF_MASK    = 0x00000010U;   /** @brief Clear transmit underrun error flag */
    static const uint32_t SWPMI_ICR_CTCF_MASK       = 0x00000080U;   /** @brief Clear transfer complete flag */
    static const uint32_t SWPMI_ICR_CSRF_MASK       = 0x00000100U;   /** @brief Clear slave resume flag */
    static const uint32_t SWPMI_ICR_CRDYF_MASK      = 0x00000800U;   /** @brief Clear transceiver ready flag */
    static const uint32_t SWPMI_IER_RXBFIE_MASK     = 0x00000001U;   /** @brief Receive buffer full interrupt enable */
    static const uint32_t SWPMI_IER_TXBEIE_MASK     = 0x00000002U;   /** @brief Transmit buffer empty interrupt enable */
    static const uint32_t SWPMI_IER_RXBERIE_MASK    = 0x00000004U;   /** @brief Receive CRC error interrupt enable */
    static const uint32_t SWPMI_IER_RXOVRIE_MASK    = 0x00000008U;   /** @brief Receive overrun error interrupt enable */
    static const uint32_t SWPMI_IER_TXUNRIE_MASK    = 0x00000010U;   /** @brief Transmit underrun error interrupt enable */
    static const uint32_t SWPMI_IER_RIE_MASK        = 0x00000020U;   /** @brief Receive interrupt enable */
    static const uint32_t SWPMI_IER_TIE_MASK        = 0x00000040U;   /** @brief Transmit interrupt enable */
    static const uint32_t SWPMI_IER_TCIE_MASK       = 0x00000080U;   /** @brief Transmit complete interrupt enable */
    static const uint32_t SWPMI_IER_SRIE_MASK       = 0x00000100U;   /** @brief Slave resume interrupt enable */
    static const uint32_t SWPMI_IER_RDYIE_MASK      = 0x00000800U;   /** @brief Transceiver ready interrupt enable */
    static const uint32_t SWPMI_RFL_RFL_MASK        = 0x0000001FU;   /** @brief Receive frame length */
    static const uint32_t SWPMI_OR_SWP_TBYP_MASK    = 0x00000001U;   /** @brief SWP transceiver bypass */
    static const uint32_t SWPMI_OR_SWP_CLASS_MASK   = 0x00000002U;   /** @brief SWP class selection */

    /**** @subsection SWPMI Register Field Positions ****/

    static const int32_t SWPMI_CR_RXDMA_POS       = 0;    /** @brief Reception DMA enable */
    static const int32_t SWPMI_CR_TXDMA_POS       = 1;    /** @brief Transmission DMA enable */
    static const int32_t SWPMI_CR_RXMODE_POS      = 2;    /** @brief Reception buffering mode */
    static const int32_t SWPMI_CR_TXMODE_POS      = 3;    /** @brief Transmission buffering mode */
    static const int32_t SWPMI_CR_LPBK_POS        = 4;    /** @brief Loopback mode enable */
    static const int32_t SWPMI_CR_SWPACT_POS      = 5;    /** @brief Single wire protocol master interface activate */
    static const int32_t SWPMI_CR_DEACT_POS       = 10;   /** @brief Single wire protocol master interface deactivate */
    static const int32_t SWPMI_CR_SWPTEN_POS      = 11;   /** @brief Single wire protocol master transceiver enable */
    static const int32_t SWPMI_BRR_BR_POS         = 0;    /** @brief Bitrate prescaler */
    static const int32_t SWPMI_ISR_RXBFF_POS      = 0;    /** @brief Receive buffer full flag */
    static const int32_t SWPMI_ISR_TXBEF_POS      = 1;    /** @brief Transmit buffer empty flag */
    static const int32_t SWPMI_ISR_RXBERF_POS     = 2;    /** @brief Receive CRC error flag */
    static const int32_t SWPMI_ISR_RXOVRF_POS     = 3;    /** @brief Receive overrun error flag */
    static const int32_t SWPMI_ISR_TXUNRF_POS     = 4;    /** @brief Transmit underrun error flag */
    static const int32_t SWPMI_ISR_RXNE_POS       = 5;    /** @brief Receive data register not empty */
    static const int32_t SWPMI_ISR_TXE_POS        = 6;    /** @brief Transmit data register empty */
    static const int32_t SWPMI_ISR_TCF_POS        = 7;    /** @brief Transfer complete flag */
    static const int32_t SWPMI_ISR_SRF_POS        = 8;    /** @brief Slave resume flag */
    static const int32_t SWPMI_ISR_SUSP_POS       = 9;    /** @brief SUSPEND flag */
    static const int32_t SWPMI_ISR_DEACTF_POS     = 10;   /** @brief DEACTIVATED flag */
    static const int32_t SWPMI_ISR_RDYF_POS       = 11;   /** @brief Transceiver ready flag */
    static const int32_t SWPMI_ICR_CRXBFF_POS     = 0;    /** @brief Clear receive buffer full flag */
    static const int32_t SWPMI_ICR_CTXBEF_POS     = 1;    /** @brief Clear transmit buffer empty flag */
    static const int32_t SWPMI_ICR_CRXBERF_POS    = 2;    /** @brief Clear receive CRC error flag */
    static const int32_t SWPMI_ICR_CRXOVRF_POS    = 3;    /** @brief Clear receive overrun error flag */
    static const int32_t SWPMI_ICR_CTXUNRF_POS    = 4;    /** @brief Clear transmit underrun error flag */
    static const int32_t SWPMI_ICR_CTCF_POS       = 7;    /** @brief Clear transfer complete flag */
    static const int32_t SWPMI_ICR_CSRF_POS       = 8;    /** @brief Clear slave resume flag */
    static const int32_t SWPMI_ICR_CRDYF_POS      = 11;   /** @brief Clear transceiver ready flag */
    static const int32_t SWPMI_IER_RXBFIE_POS     = 0;    /** @brief Receive buffer full interrupt enable */
    static const int32_t SWPMI_IER_TXBEIE_POS     = 1;    /** @brief Transmit buffer empty interrupt enable */
    static const int32_t SWPMI_IER_RXBERIE_POS    = 2;    /** @brief Receive CRC error interrupt enable */
    static const int32_t SWPMI_IER_RXOVRIE_POS    = 3;    /** @brief Receive overrun error interrupt enable */
    static const int32_t SWPMI_IER_TXUNRIE_POS    = 4;    /** @brief Transmit underrun error interrupt enable */
    static const int32_t SWPMI_IER_RIE_POS        = 5;    /** @brief Receive interrupt enable */
    static const int32_t SWPMI_IER_TIE_POS        = 6;    /** @brief Transmit interrupt enable */
    static const int32_t SWPMI_IER_TCIE_POS       = 7;    /** @brief Transmit complete interrupt enable */
    static const int32_t SWPMI_IER_SRIE_POS       = 8;    /** @brief Slave resume interrupt enable */
    static const int32_t SWPMI_IER_RDYIE_POS      = 11;   /** @brief Transceiver ready interrupt enable */
    static const int32_t SWPMI_RFL_RFL_POS        = 0;    /** @brief Receive frame length */
    static const int32_t SWPMI_OR_SWP_TBYP_POS    = 0;    /** @brief SWP transceiver bypass */
    static const int32_t SWPMI_OR_SWP_CLASS_POS   = 1;    /** @brief SWP class selection */

    /**********************************************************************************************
     * @section G_TIM2 Register Information
     **********************************************************************************************/

    /**** @subsection G_TIM2 Register Pointers ****/

    static RW_ uint32_t* const G_TIM2_CR1_PTR            = (RW_ uint32_t* const)0x40000000U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G_TIM2_CR2_PTR            = (RW_ uint32_t* const)0x40000004U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G_TIM2_SMCR_PTR           = (RW_ uint32_t* const)0x40000008U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const G_TIM2_DIER_PTR           = (RW_ uint32_t* const)0x4000000CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G_TIM2_SR_PTR             = (RW_ uint32_t* const)0x40000010U;   /** @brief Status register */
    static RW_ uint32_t* const G_TIM2_EGR_PTR            = (RW_ uint32_t* const)0x40000014U;   /** @brief Event generation register */
    static RW_ uint32_t* const G_TIM2_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40000018U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const G_TIM2_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40000018U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G_TIM2_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x4000001CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const G_TIM2_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x4000001CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const G_TIM2_CCER_PTR           = (RW_ uint32_t* const)0x40000020U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G_TIM2_CNT_PTR            = (RW_ uint32_t* const)0x40000024U;   /** @brief Counter */
    static RW_ uint32_t* const G_TIM2_PSC_PTR            = (RW_ uint32_t* const)0x40000028U;   /** @brief Prescaler */
    static RW_ uint32_t* const G_TIM2_ARR_PTR            = (RW_ uint32_t* const)0x4000002CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G_TIM2_DCR_PTR            = (RW_ uint32_t* const)0x40000048U;   /** @brief DMA control register */
    static RW_ uint32_t* const G_TIM2_DMAR_PTR           = (RW_ uint32_t* const)0x4000004CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G_TIM2_AF1_PTR            = (RW_ uint32_t* const)0x40000060U;   /** @brief TIM alternate function option register 1 */
    static RW_ uint32_t* const G_TIM2_TISEL_PTR          = (RW_ uint32_t* const)0x40000068U;   /** @brief TIM timer input selection register */

    /**** @subsection Enumerated G_TIM2 Register Pointers ****/

    static RW_ uint32_t* const G_TIM2_CCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40000034U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000038U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000003CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000040U,   /** @brief Capture/compare register 4 */
    };

    /**** @subsection G_TIM2 Register Reset Values ****/

    static const uint32_t G_TIM2_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G_TIM2_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G_TIM2_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t G_TIM2_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G_TIM2_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G_TIM2_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G_TIM2_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G_TIM2_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G_TIM2_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t G_TIM2_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t G_TIM2_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G_TIM2_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G_TIM2_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G_TIM2_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G_TIM2_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G_TIM2_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G_TIM2_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t G_TIM2_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated G_TIM2 Register Reset Values ****/

    static const uint32_t G_TIM2_CCRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
    };

    /**** @subsection Enumerated G_TIM2 Register Value Types ****/

    typedef uint32_t G_TIM2_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G_TIM2_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G_TIM2_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t G_TIM2_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G_TIM2_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G_TIM2_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G_TIM2_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G_TIM2_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G_TIM2_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t G_TIM2_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t G_TIM2_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G_TIM2_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G_TIM2_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G_TIM2_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G_TIM2_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t G_TIM2_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G_TIM2_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G_TIM2_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t G_TIM2_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated G_TIM2 Register Pointer Types ****/

    typedef uint32_t* const G_TIM2_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G_TIM2_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G_TIM2_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const G_TIM2_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G_TIM2_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G_TIM2_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G_TIM2_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM2_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G_TIM2_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM2_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const G_TIM2_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G_TIM2_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G_TIM2_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G_TIM2_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G_TIM2_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const G_TIM2_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G_TIM2_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G_TIM2_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const G_TIM2_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection G_TIM2 Register Field Masks ****/

    static const uint32_t G_TIM2_CR1_UIFREMAP_MASK         = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G_TIM2_CR1_CKD_MASK              = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G_TIM2_CR1_ARPE_MASK             = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G_TIM2_CR1_CMS_MASK              = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t G_TIM2_CR1_DIR_MASK              = 0x00000010U;   /** @brief Direction */
    static const uint32_t G_TIM2_CR1_OPM_MASK              = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G_TIM2_CR1_URS_MASK              = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G_TIM2_CR1_UDIS_MASK             = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G_TIM2_CR1_CEN_MASK              = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G_TIM2_CR2_TI1S_MASK             = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t G_TIM2_CR2_MMS_MASK              = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t G_TIM2_CR2_CCDS_MASK             = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G_TIM2_SMCR_TS_4_3_MASK          = 0x00300000U;   /** @brief Trigger selection */
    static const uint32_t G_TIM2_SMCR_SMS_3_MASK           = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t G_TIM2_SMCR_ETP_MASK             = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t G_TIM2_SMCR_ECE_MASK             = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t G_TIM2_SMCR_ETPS_MASK            = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t G_TIM2_SMCR_ETF_MASK             = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t G_TIM2_SMCR_MSM_MASK             = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t G_TIM2_SMCR_TS_MASK              = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t G_TIM2_SMCR_SMS_MASK             = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t G_TIM2_DIER_TDE_MASK             = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t G_TIM2_DIER_UDE_MASK             = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G_TIM2_DIER_TIE_MASK             = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t G_TIM2_DIER_UIE_MASK             = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G_TIM2_SR_TIF_MASK               = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t G_TIM2_SR_UIF_MASK               = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G_TIM2_EGR_TG_MASK               = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t G_TIM2_EGR_UG_MASK               = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G_TIM2_CCMR1_INPUT_IC2PCS_MASK   = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t G_TIM2_CCMR1_INPUT_ICPCS_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G_TIM2_CCMR2_OUTPUT_O24CE_MASK   = 0x00008000U;   /** @brief O24CE */
    static const uint32_t G_TIM2_CCMR2_OUTPUT_OC3CE_MASK   = 0x00000080U;   /** @brief OC3CE */
    static const uint32_t G_TIM2_CNT_CNT_L_MASK            = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t G_TIM2_CNT_CNT_H_MASK            = 0xFFFF0000U;   /** @brief High counter value */
    static const uint32_t G_TIM2_PSC_PSC_MASK              = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G_TIM2_ARR_ARR_H_MASK            = 0xFFFF0000U;   /** @brief High auto-reload value */
    static const uint32_t G_TIM2_ARR_ARR_L_MASK            = 0x0000FFFFU;   /** @brief Low auto-reload value */
    static const uint32_t G_TIM2_CCRx_CCR1_H_MASK          = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
    static const uint32_t G_TIM2_CCRx_CCR1_L_MASK          = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
    static const uint32_t G_TIM2_DCR_DBL_MASK              = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G_TIM2_DCR_DBA_MASK              = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G_TIM2_DMAR_DMAB_MASK            = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G_TIM2_AF1_ETRSEL_MASK           = 0x0003C000U;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM2 Register Field Masks ****/

    static const uint32_t G_TIM2_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t G_TIM2_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t G_TIM2_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t G_TIM2_SR_CCxIF_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const uint32_t G_TIM2_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t G_TIM2_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief CC1S */
      [2] = 0x00000300U,   /** @brief CC2S */
    };

    static const uint32_t G_TIM2_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief OC1FE */
      [2] = 0x00000400U,   /** @brief OC2FE */
    };

    static const uint32_t G_TIM2_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief OC1PE */
      [2] = 0x00000800U,   /** @brief OC2PE */
    };

    static const uint32_t G_TIM2_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief OC1M */
      [2] = 0x00007000U,   /** @brief OC2M */
    };

    static const uint32_t G_TIM2_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief OC1CE */
      [2] = 0x00008000U,   /** @brief OC2CE */
    };

    static const uint32_t G_TIM2_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t G_TIM2_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t G_TIM2_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t G_TIM2_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
    };

    static const uint32_t G_TIM2_CCER_CCxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    };

    static const uint32_t G_TIM2_CCER_CCxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    };

    static const uint32_t G_TIM2_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
      [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
      [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**** @subsection G_TIM2 Register Field Positions ****/

    static const int32_t G_TIM2_CR1_UIFREMAP_POS         = 11;   /** @brief UIF status bit remapping */
    static const int32_t G_TIM2_CR1_CKD_POS              = 8;    /** @brief Clock division */
    static const int32_t G_TIM2_CR1_ARPE_POS             = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G_TIM2_CR1_CMS_POS              = 5;    /** @brief Center-aligned mode selection */
    static const int32_t G_TIM2_CR1_DIR_POS              = 4;    /** @brief Direction */
    static const int32_t G_TIM2_CR1_OPM_POS              = 3;    /** @brief One-pulse mode */
    static const int32_t G_TIM2_CR1_URS_POS              = 2;    /** @brief Update request source */
    static const int32_t G_TIM2_CR1_UDIS_POS             = 1;    /** @brief Update disable */
    static const int32_t G_TIM2_CR1_CEN_POS              = 0;    /** @brief Counter enable */
    static const int32_t G_TIM2_CR2_TI1S_POS             = 7;    /** @brief TI1 selection */
    static const int32_t G_TIM2_CR2_MMS_POS              = 4;    /** @brief Master mode selection */
    static const int32_t G_TIM2_CR2_CCDS_POS             = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G_TIM2_SMCR_TS_4_3_POS          = 20;   /** @brief Trigger selection */
    static const int32_t G_TIM2_SMCR_SMS_3_POS           = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t G_TIM2_SMCR_ETP_POS             = 15;   /** @brief External trigger polarity */
    static const int32_t G_TIM2_SMCR_ECE_POS             = 14;   /** @brief External clock enable */
    static const int32_t G_TIM2_SMCR_ETPS_POS            = 12;   /** @brief External trigger prescaler */
    static const int32_t G_TIM2_SMCR_ETF_POS             = 8;    /** @brief External trigger filter */
    static const int32_t G_TIM2_SMCR_MSM_POS             = 7;    /** @brief Master/Slave mode */
    static const int32_t G_TIM2_SMCR_TS_POS              = 4;    /** @brief Trigger selection */
    static const int32_t G_TIM2_SMCR_SMS_POS             = 0;    /** @brief Slave mode selection */
    static const int32_t G_TIM2_DIER_TDE_POS             = 14;   /** @brief Trigger DMA request enable */
    static const int32_t G_TIM2_DIER_UDE_POS             = 8;    /** @brief Update DMA request enable */
    static const int32_t G_TIM2_DIER_TIE_POS             = 6;    /** @brief Trigger interrupt enable */
    static const int32_t G_TIM2_DIER_UIE_POS             = 0;    /** @brief Update interrupt enable */
    static const int32_t G_TIM2_SR_TIF_POS               = 6;    /** @brief Trigger interrupt flag */
    static const int32_t G_TIM2_SR_UIF_POS               = 0;    /** @brief Update interrupt flag */
    static const int32_t G_TIM2_EGR_TG_POS               = 6;    /** @brief Trigger generation */
    static const int32_t G_TIM2_EGR_UG_POS               = 0;    /** @brief Update generation */
    static const int32_t G_TIM2_CCMR1_INPUT_IC2PCS_POS   = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t G_TIM2_CCMR1_INPUT_ICPCS_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G_TIM2_CCMR2_OUTPUT_O24CE_POS   = 15;   /** @brief O24CE */
    static const int32_t G_TIM2_CCMR2_OUTPUT_OC3CE_POS   = 7;    /** @brief OC3CE */
    static const int32_t G_TIM2_CNT_CNT_L_POS            = 0;    /** @brief Low counter value */
    static const int32_t G_TIM2_CNT_CNT_H_POS            = 16;   /** @brief High counter value */
    static const int32_t G_TIM2_PSC_PSC_POS              = 0;    /** @brief Prescaler value */
    static const int32_t G_TIM2_ARR_ARR_H_POS            = 16;   /** @brief High auto-reload value */
    static const int32_t G_TIM2_ARR_ARR_L_POS            = 0;    /** @brief Low auto-reload value */
    static const int32_t G_TIM2_CCRx_CCR1_H_POS          = 16;   /** @brief High capture/compare 1 value */
    static const int32_t G_TIM2_CCRx_CCR1_L_POS          = 0;    /** @brief Low capture/compare 1 value */
    static const int32_t G_TIM2_DCR_DBL_POS              = 8;    /** @brief DMA burst length */
    static const int32_t G_TIM2_DCR_DBA_POS              = 0;    /** @brief DMA base address */
    static const int32_t G_TIM2_DMAR_DMAB_POS            = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G_TIM2_AF1_ETRSEL_POS           = 14;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM2 Register Field Positions ****/

    static const int32_t G_TIM2_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t G_TIM2_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t G_TIM2_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t G_TIM2_SR_CCxIF_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const int32_t G_TIM2_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t G_TIM2_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief CC1S */
      [2] = 8,   /** @brief CC2S */
    };

    static const int32_t G_TIM2_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief OC1FE */
      [2] = 10,   /** @brief OC2FE */
    };

    static const int32_t G_TIM2_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief OC1PE */
      [2] = 11,   /** @brief OC2PE */
    };

    static const int32_t G_TIM2_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief OC1M */
      [2] = 12,   /** @brief OC2M */
    };

    static const int32_t G_TIM2_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief OC1CE */
      [2] = 15,   /** @brief OC2CE */
    };

    static const int32_t G_TIM2_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t G_TIM2_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t G_TIM2_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t G_TIM2_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 output polarity */
    };

    static const int32_t G_TIM2_CCER_CCxP_POS[5] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    };

    static const int32_t G_TIM2_CCER_CCxE_POS[5] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
    };

    static const int32_t G_TIM2_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
      [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
      [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**********************************************************************************************
     * @section G_TIM3 Register Information
     **********************************************************************************************/

    /**** @subsection G_TIM3 Register Pointers ****/

    static RW_ uint32_t* const G_TIM3_CR1_PTR            = (RW_ uint32_t* const)0x40000400U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G_TIM3_CR2_PTR            = (RW_ uint32_t* const)0x40000404U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G_TIM3_SMCR_PTR           = (RW_ uint32_t* const)0x40000408U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const G_TIM3_DIER_PTR           = (RW_ uint32_t* const)0x4000040CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G_TIM3_SR_PTR             = (RW_ uint32_t* const)0x40000410U;   /** @brief Status register */
    static RW_ uint32_t* const G_TIM3_EGR_PTR            = (RW_ uint32_t* const)0x40000414U;   /** @brief Event generation register */
    static RW_ uint32_t* const G_TIM3_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40000418U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const G_TIM3_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40000418U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G_TIM3_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x4000041CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const G_TIM3_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x4000041CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const G_TIM3_CCER_PTR           = (RW_ uint32_t* const)0x40000420U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G_TIM3_CNT_PTR            = (RW_ uint32_t* const)0x40000424U;   /** @brief Counter */
    static RW_ uint32_t* const G_TIM3_PSC_PTR            = (RW_ uint32_t* const)0x40000428U;   /** @brief Prescaler */
    static RW_ uint32_t* const G_TIM3_ARR_PTR            = (RW_ uint32_t* const)0x4000042CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G_TIM3_DCR_PTR            = (RW_ uint32_t* const)0x40000448U;   /** @brief DMA control register */
    static RW_ uint32_t* const G_TIM3_DMAR_PTR           = (RW_ uint32_t* const)0x4000044CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G_TIM3_AF1_PTR            = (RW_ uint32_t* const)0x40000460U;   /** @brief TIM alternate function option register 1 */
    static RW_ uint32_t* const G_TIM3_TISEL_PTR          = (RW_ uint32_t* const)0x40000468U;   /** @brief TIM timer input selection register */

    /**** @subsection Enumerated G_TIM3 Register Pointers ****/

    static RW_ uint32_t* const G_TIM3_CCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40000434U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000438U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000043CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000440U,   /** @brief Capture/compare register 4 */
    };

    /**** @subsection G_TIM3 Register Reset Values ****/

    static const uint32_t G_TIM3_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G_TIM3_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G_TIM3_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t G_TIM3_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G_TIM3_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G_TIM3_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G_TIM3_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G_TIM3_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G_TIM3_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t G_TIM3_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t G_TIM3_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G_TIM3_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G_TIM3_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G_TIM3_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G_TIM3_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G_TIM3_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G_TIM3_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t G_TIM3_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated G_TIM3 Register Reset Values ****/

    static const uint32_t G_TIM3_CCRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
    };

    /**** @subsection Enumerated G_TIM3 Register Value Types ****/

    typedef uint32_t G_TIM3_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G_TIM3_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G_TIM3_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t G_TIM3_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G_TIM3_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G_TIM3_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G_TIM3_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G_TIM3_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G_TIM3_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t G_TIM3_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t G_TIM3_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G_TIM3_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G_TIM3_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G_TIM3_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G_TIM3_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t G_TIM3_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G_TIM3_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G_TIM3_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t G_TIM3_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated G_TIM3 Register Pointer Types ****/

    typedef uint32_t* const G_TIM3_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G_TIM3_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G_TIM3_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const G_TIM3_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G_TIM3_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G_TIM3_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G_TIM3_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM3_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G_TIM3_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM3_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const G_TIM3_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G_TIM3_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G_TIM3_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G_TIM3_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G_TIM3_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const G_TIM3_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G_TIM3_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G_TIM3_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const G_TIM3_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection G_TIM3 Register Field Masks ****/

    static const uint32_t G_TIM3_CR1_UIFREMAP_MASK         = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G_TIM3_CR1_CKD_MASK              = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G_TIM3_CR1_ARPE_MASK             = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G_TIM3_CR1_CMS_MASK              = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t G_TIM3_CR1_DIR_MASK              = 0x00000010U;   /** @brief Direction */
    static const uint32_t G_TIM3_CR1_OPM_MASK              = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G_TIM3_CR1_URS_MASK              = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G_TIM3_CR1_UDIS_MASK             = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G_TIM3_CR1_CEN_MASK              = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G_TIM3_CR2_TI1S_MASK             = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t G_TIM3_CR2_MMS_MASK              = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t G_TIM3_CR2_CCDS_MASK             = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G_TIM3_SMCR_TS_4_3_MASK          = 0x00300000U;   /** @brief Trigger selection */
    static const uint32_t G_TIM3_SMCR_SMS_3_MASK           = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t G_TIM3_SMCR_ETP_MASK             = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t G_TIM3_SMCR_ECE_MASK             = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t G_TIM3_SMCR_ETPS_MASK            = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t G_TIM3_SMCR_ETF_MASK             = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t G_TIM3_SMCR_MSM_MASK             = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t G_TIM3_SMCR_TS_MASK              = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t G_TIM3_SMCR_SMS_MASK             = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t G_TIM3_DIER_TDE_MASK             = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t G_TIM3_DIER_UDE_MASK             = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G_TIM3_DIER_TIE_MASK             = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t G_TIM3_DIER_UIE_MASK             = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G_TIM3_SR_TIF_MASK               = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t G_TIM3_SR_UIF_MASK               = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G_TIM3_EGR_TG_MASK               = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t G_TIM3_EGR_UG_MASK               = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G_TIM3_CCMR1_INPUT_IC2PCS_MASK   = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t G_TIM3_CCMR1_INPUT_ICPCS_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G_TIM3_CCMR2_OUTPUT_O24CE_MASK   = 0x00008000U;   /** @brief O24CE */
    static const uint32_t G_TIM3_CCMR2_OUTPUT_OC3CE_MASK   = 0x00000080U;   /** @brief OC3CE */
    static const uint32_t G_TIM3_CNT_CNT_L_MASK            = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t G_TIM3_CNT_CNT_H_MASK            = 0xFFFF0000U;   /** @brief High counter value */
    static const uint32_t G_TIM3_PSC_PSC_MASK              = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G_TIM3_ARR_ARR_H_MASK            = 0xFFFF0000U;   /** @brief High auto-reload value */
    static const uint32_t G_TIM3_ARR_ARR_L_MASK            = 0x0000FFFFU;   /** @brief Low auto-reload value */
    static const uint32_t G_TIM3_CCRx_CCR1_H_MASK          = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
    static const uint32_t G_TIM3_CCRx_CCR1_L_MASK          = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
    static const uint32_t G_TIM3_DCR_DBL_MASK              = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G_TIM3_DCR_DBA_MASK              = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G_TIM3_DMAR_DMAB_MASK            = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G_TIM3_AF1_ETRSEL_MASK           = 0x0003C000U;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM3 Register Field Masks ****/

    static const uint32_t G_TIM3_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t G_TIM3_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t G_TIM3_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t G_TIM3_SR_CCxIF_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const uint32_t G_TIM3_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t G_TIM3_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief CC1S */
      [2] = 0x00000300U,   /** @brief CC2S */
    };

    static const uint32_t G_TIM3_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief OC1FE */
      [2] = 0x00000400U,   /** @brief OC2FE */
    };

    static const uint32_t G_TIM3_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief OC1PE */
      [2] = 0x00000800U,   /** @brief OC2PE */
    };

    static const uint32_t G_TIM3_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief OC1M */
      [2] = 0x00007000U,   /** @brief OC2M */
    };

    static const uint32_t G_TIM3_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief OC1CE */
      [2] = 0x00008000U,   /** @brief OC2CE */
    };

    static const uint32_t G_TIM3_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t G_TIM3_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t G_TIM3_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t G_TIM3_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
    };

    static const uint32_t G_TIM3_CCER_CCxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    };

    static const uint32_t G_TIM3_CCER_CCxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    };

    static const uint32_t G_TIM3_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
      [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
      [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**** @subsection G_TIM3 Register Field Positions ****/

    static const int32_t G_TIM3_CR1_UIFREMAP_POS         = 11;   /** @brief UIF status bit remapping */
    static const int32_t G_TIM3_CR1_CKD_POS              = 8;    /** @brief Clock division */
    static const int32_t G_TIM3_CR1_ARPE_POS             = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G_TIM3_CR1_CMS_POS              = 5;    /** @brief Center-aligned mode selection */
    static const int32_t G_TIM3_CR1_DIR_POS              = 4;    /** @brief Direction */
    static const int32_t G_TIM3_CR1_OPM_POS              = 3;    /** @brief One-pulse mode */
    static const int32_t G_TIM3_CR1_URS_POS              = 2;    /** @brief Update request source */
    static const int32_t G_TIM3_CR1_UDIS_POS             = 1;    /** @brief Update disable */
    static const int32_t G_TIM3_CR1_CEN_POS              = 0;    /** @brief Counter enable */
    static const int32_t G_TIM3_CR2_TI1S_POS             = 7;    /** @brief TI1 selection */
    static const int32_t G_TIM3_CR2_MMS_POS              = 4;    /** @brief Master mode selection */
    static const int32_t G_TIM3_CR2_CCDS_POS             = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G_TIM3_SMCR_TS_4_3_POS          = 20;   /** @brief Trigger selection */
    static const int32_t G_TIM3_SMCR_SMS_3_POS           = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t G_TIM3_SMCR_ETP_POS             = 15;   /** @brief External trigger polarity */
    static const int32_t G_TIM3_SMCR_ECE_POS             = 14;   /** @brief External clock enable */
    static const int32_t G_TIM3_SMCR_ETPS_POS            = 12;   /** @brief External trigger prescaler */
    static const int32_t G_TIM3_SMCR_ETF_POS             = 8;    /** @brief External trigger filter */
    static const int32_t G_TIM3_SMCR_MSM_POS             = 7;    /** @brief Master/Slave mode */
    static const int32_t G_TIM3_SMCR_TS_POS              = 4;    /** @brief Trigger selection */
    static const int32_t G_TIM3_SMCR_SMS_POS             = 0;    /** @brief Slave mode selection */
    static const int32_t G_TIM3_DIER_TDE_POS             = 14;   /** @brief Trigger DMA request enable */
    static const int32_t G_TIM3_DIER_UDE_POS             = 8;    /** @brief Update DMA request enable */
    static const int32_t G_TIM3_DIER_TIE_POS             = 6;    /** @brief Trigger interrupt enable */
    static const int32_t G_TIM3_DIER_UIE_POS             = 0;    /** @brief Update interrupt enable */
    static const int32_t G_TIM3_SR_TIF_POS               = 6;    /** @brief Trigger interrupt flag */
    static const int32_t G_TIM3_SR_UIF_POS               = 0;    /** @brief Update interrupt flag */
    static const int32_t G_TIM3_EGR_TG_POS               = 6;    /** @brief Trigger generation */
    static const int32_t G_TIM3_EGR_UG_POS               = 0;    /** @brief Update generation */
    static const int32_t G_TIM3_CCMR1_INPUT_IC2PCS_POS   = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t G_TIM3_CCMR1_INPUT_ICPCS_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G_TIM3_CCMR2_OUTPUT_O24CE_POS   = 15;   /** @brief O24CE */
    static const int32_t G_TIM3_CCMR2_OUTPUT_OC3CE_POS   = 7;    /** @brief OC3CE */
    static const int32_t G_TIM3_CNT_CNT_L_POS            = 0;    /** @brief Low counter value */
    static const int32_t G_TIM3_CNT_CNT_H_POS            = 16;   /** @brief High counter value */
    static const int32_t G_TIM3_PSC_PSC_POS              = 0;    /** @brief Prescaler value */
    static const int32_t G_TIM3_ARR_ARR_H_POS            = 16;   /** @brief High auto-reload value */
    static const int32_t G_TIM3_ARR_ARR_L_POS            = 0;    /** @brief Low auto-reload value */
    static const int32_t G_TIM3_CCRx_CCR1_H_POS          = 16;   /** @brief High capture/compare 1 value */
    static const int32_t G_TIM3_CCRx_CCR1_L_POS          = 0;    /** @brief Low capture/compare 1 value */
    static const int32_t G_TIM3_DCR_DBL_POS              = 8;    /** @brief DMA burst length */
    static const int32_t G_TIM3_DCR_DBA_POS              = 0;    /** @brief DMA base address */
    static const int32_t G_TIM3_DMAR_DMAB_POS            = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G_TIM3_AF1_ETRSEL_POS           = 14;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM3 Register Field Positions ****/

    static const int32_t G_TIM3_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t G_TIM3_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t G_TIM3_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t G_TIM3_SR_CCxIF_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const int32_t G_TIM3_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t G_TIM3_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief CC1S */
      [2] = 8,   /** @brief CC2S */
    };

    static const int32_t G_TIM3_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief OC1FE */
      [2] = 10,   /** @brief OC2FE */
    };

    static const int32_t G_TIM3_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief OC1PE */
      [2] = 11,   /** @brief OC2PE */
    };

    static const int32_t G_TIM3_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief OC1M */
      [2] = 12,   /** @brief OC2M */
    };

    static const int32_t G_TIM3_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief OC1CE */
      [2] = 15,   /** @brief OC2CE */
    };

    static const int32_t G_TIM3_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t G_TIM3_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t G_TIM3_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t G_TIM3_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 output polarity */
    };

    static const int32_t G_TIM3_CCER_CCxP_POS[5] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    };

    static const int32_t G_TIM3_CCER_CCxE_POS[5] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
    };

    static const int32_t G_TIM3_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
      [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
      [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**********************************************************************************************
     * @section G_TIM4 Register Information
     **********************************************************************************************/

    /**** @subsection G_TIM4 Register Pointers ****/

    static RW_ uint32_t* const G_TIM4_CR1_PTR            = (RW_ uint32_t* const)0x40000800U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G_TIM4_CR2_PTR            = (RW_ uint32_t* const)0x40000804U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G_TIM4_SMCR_PTR           = (RW_ uint32_t* const)0x40000808U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const G_TIM4_DIER_PTR           = (RW_ uint32_t* const)0x4000080CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G_TIM4_SR_PTR             = (RW_ uint32_t* const)0x40000810U;   /** @brief Status register */
    static RW_ uint32_t* const G_TIM4_EGR_PTR            = (RW_ uint32_t* const)0x40000814U;   /** @brief Event generation register */
    static RW_ uint32_t* const G_TIM4_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40000818U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const G_TIM4_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40000818U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G_TIM4_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x4000081CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const G_TIM4_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x4000081CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const G_TIM4_CCER_PTR           = (RW_ uint32_t* const)0x40000820U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G_TIM4_CNT_PTR            = (RW_ uint32_t* const)0x40000824U;   /** @brief Counter */
    static RW_ uint32_t* const G_TIM4_PSC_PTR            = (RW_ uint32_t* const)0x40000828U;   /** @brief Prescaler */
    static RW_ uint32_t* const G_TIM4_ARR_PTR            = (RW_ uint32_t* const)0x4000082CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G_TIM4_DCR_PTR            = (RW_ uint32_t* const)0x40000848U;   /** @brief DMA control register */
    static RW_ uint32_t* const G_TIM4_DMAR_PTR           = (RW_ uint32_t* const)0x4000084CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G_TIM4_AF1_PTR            = (RW_ uint32_t* const)0x40000860U;   /** @brief TIM alternate function option register 1 */
    static RW_ uint32_t* const G_TIM4_TISEL_PTR          = (RW_ uint32_t* const)0x40000868U;   /** @brief TIM timer input selection register */

    /**** @subsection Enumerated G_TIM4 Register Pointers ****/

    static RW_ uint32_t* const G_TIM4_CCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40000834U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000838U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000083CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000840U,   /** @brief Capture/compare register 4 */
    };

    /**** @subsection G_TIM4 Register Reset Values ****/

    static const uint32_t G_TIM4_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G_TIM4_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G_TIM4_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t G_TIM4_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G_TIM4_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G_TIM4_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G_TIM4_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G_TIM4_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G_TIM4_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t G_TIM4_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t G_TIM4_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G_TIM4_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G_TIM4_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G_TIM4_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G_TIM4_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G_TIM4_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G_TIM4_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t G_TIM4_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated G_TIM4 Register Reset Values ****/

    static const uint32_t G_TIM4_CCRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
    };

    /**** @subsection Enumerated G_TIM4 Register Value Types ****/

    typedef uint32_t G_TIM4_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G_TIM4_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G_TIM4_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t G_TIM4_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G_TIM4_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G_TIM4_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G_TIM4_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G_TIM4_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G_TIM4_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t G_TIM4_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t G_TIM4_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G_TIM4_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G_TIM4_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G_TIM4_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G_TIM4_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t G_TIM4_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G_TIM4_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G_TIM4_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t G_TIM4_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated G_TIM4 Register Pointer Types ****/

    typedef uint32_t* const G_TIM4_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G_TIM4_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G_TIM4_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const G_TIM4_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G_TIM4_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G_TIM4_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G_TIM4_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM4_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G_TIM4_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM4_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const G_TIM4_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G_TIM4_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G_TIM4_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G_TIM4_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G_TIM4_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const G_TIM4_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G_TIM4_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G_TIM4_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const G_TIM4_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection G_TIM4 Register Field Masks ****/

    static const uint32_t G_TIM4_CR1_UIFREMAP_MASK         = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G_TIM4_CR1_CKD_MASK              = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G_TIM4_CR1_ARPE_MASK             = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G_TIM4_CR1_CMS_MASK              = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t G_TIM4_CR1_DIR_MASK              = 0x00000010U;   /** @brief Direction */
    static const uint32_t G_TIM4_CR1_OPM_MASK              = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G_TIM4_CR1_URS_MASK              = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G_TIM4_CR1_UDIS_MASK             = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G_TIM4_CR1_CEN_MASK              = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G_TIM4_CR2_TI1S_MASK             = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t G_TIM4_CR2_MMS_MASK              = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t G_TIM4_CR2_CCDS_MASK             = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G_TIM4_SMCR_TS_4_3_MASK          = 0x00300000U;   /** @brief Trigger selection */
    static const uint32_t G_TIM4_SMCR_SMS_3_MASK           = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t G_TIM4_SMCR_ETP_MASK             = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t G_TIM4_SMCR_ECE_MASK             = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t G_TIM4_SMCR_ETPS_MASK            = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t G_TIM4_SMCR_ETF_MASK             = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t G_TIM4_SMCR_MSM_MASK             = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t G_TIM4_SMCR_TS_MASK              = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t G_TIM4_SMCR_SMS_MASK             = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t G_TIM4_DIER_TDE_MASK             = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t G_TIM4_DIER_UDE_MASK             = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G_TIM4_DIER_TIE_MASK             = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t G_TIM4_DIER_UIE_MASK             = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G_TIM4_SR_TIF_MASK               = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t G_TIM4_SR_UIF_MASK               = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G_TIM4_EGR_TG_MASK               = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t G_TIM4_EGR_UG_MASK               = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G_TIM4_CCMR1_INPUT_IC2PCS_MASK   = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t G_TIM4_CCMR1_INPUT_ICPCS_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G_TIM4_CCMR2_OUTPUT_O24CE_MASK   = 0x00008000U;   /** @brief O24CE */
    static const uint32_t G_TIM4_CCMR2_OUTPUT_OC3CE_MASK   = 0x00000080U;   /** @brief OC3CE */
    static const uint32_t G_TIM4_CNT_CNT_L_MASK            = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t G_TIM4_CNT_CNT_H_MASK            = 0xFFFF0000U;   /** @brief High counter value */
    static const uint32_t G_TIM4_PSC_PSC_MASK              = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G_TIM4_ARR_ARR_H_MASK            = 0xFFFF0000U;   /** @brief High auto-reload value */
    static const uint32_t G_TIM4_ARR_ARR_L_MASK            = 0x0000FFFFU;   /** @brief Low auto-reload value */
    static const uint32_t G_TIM4_CCRx_CCR1_H_MASK          = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
    static const uint32_t G_TIM4_CCRx_CCR1_L_MASK          = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
    static const uint32_t G_TIM4_DCR_DBL_MASK              = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G_TIM4_DCR_DBA_MASK              = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G_TIM4_DMAR_DMAB_MASK            = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G_TIM4_AF1_ETRSEL_MASK           = 0x0003C000U;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM4 Register Field Masks ****/

    static const uint32_t G_TIM4_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t G_TIM4_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t G_TIM4_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t G_TIM4_SR_CCxIF_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const uint32_t G_TIM4_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t G_TIM4_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief CC1S */
      [2] = 0x00000300U,   /** @brief CC2S */
    };

    static const uint32_t G_TIM4_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief OC1FE */
      [2] = 0x00000400U,   /** @brief OC2FE */
    };

    static const uint32_t G_TIM4_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief OC1PE */
      [2] = 0x00000800U,   /** @brief OC2PE */
    };

    static const uint32_t G_TIM4_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief OC1M */
      [2] = 0x00007000U,   /** @brief OC2M */
    };

    static const uint32_t G_TIM4_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief OC1CE */
      [2] = 0x00008000U,   /** @brief OC2CE */
    };

    static const uint32_t G_TIM4_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t G_TIM4_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t G_TIM4_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t G_TIM4_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
    };

    static const uint32_t G_TIM4_CCER_CCxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    };

    static const uint32_t G_TIM4_CCER_CCxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    };

    static const uint32_t G_TIM4_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
      [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
      [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**** @subsection G_TIM4 Register Field Positions ****/

    static const int32_t G_TIM4_CR1_UIFREMAP_POS         = 11;   /** @brief UIF status bit remapping */
    static const int32_t G_TIM4_CR1_CKD_POS              = 8;    /** @brief Clock division */
    static const int32_t G_TIM4_CR1_ARPE_POS             = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G_TIM4_CR1_CMS_POS              = 5;    /** @brief Center-aligned mode selection */
    static const int32_t G_TIM4_CR1_DIR_POS              = 4;    /** @brief Direction */
    static const int32_t G_TIM4_CR1_OPM_POS              = 3;    /** @brief One-pulse mode */
    static const int32_t G_TIM4_CR1_URS_POS              = 2;    /** @brief Update request source */
    static const int32_t G_TIM4_CR1_UDIS_POS             = 1;    /** @brief Update disable */
    static const int32_t G_TIM4_CR1_CEN_POS              = 0;    /** @brief Counter enable */
    static const int32_t G_TIM4_CR2_TI1S_POS             = 7;    /** @brief TI1 selection */
    static const int32_t G_TIM4_CR2_MMS_POS              = 4;    /** @brief Master mode selection */
    static const int32_t G_TIM4_CR2_CCDS_POS             = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G_TIM4_SMCR_TS_4_3_POS          = 20;   /** @brief Trigger selection */
    static const int32_t G_TIM4_SMCR_SMS_3_POS           = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t G_TIM4_SMCR_ETP_POS             = 15;   /** @brief External trigger polarity */
    static const int32_t G_TIM4_SMCR_ECE_POS             = 14;   /** @brief External clock enable */
    static const int32_t G_TIM4_SMCR_ETPS_POS            = 12;   /** @brief External trigger prescaler */
    static const int32_t G_TIM4_SMCR_ETF_POS             = 8;    /** @brief External trigger filter */
    static const int32_t G_TIM4_SMCR_MSM_POS             = 7;    /** @brief Master/Slave mode */
    static const int32_t G_TIM4_SMCR_TS_POS              = 4;    /** @brief Trigger selection */
    static const int32_t G_TIM4_SMCR_SMS_POS             = 0;    /** @brief Slave mode selection */
    static const int32_t G_TIM4_DIER_TDE_POS             = 14;   /** @brief Trigger DMA request enable */
    static const int32_t G_TIM4_DIER_UDE_POS             = 8;    /** @brief Update DMA request enable */
    static const int32_t G_TIM4_DIER_TIE_POS             = 6;    /** @brief Trigger interrupt enable */
    static const int32_t G_TIM4_DIER_UIE_POS             = 0;    /** @brief Update interrupt enable */
    static const int32_t G_TIM4_SR_TIF_POS               = 6;    /** @brief Trigger interrupt flag */
    static const int32_t G_TIM4_SR_UIF_POS               = 0;    /** @brief Update interrupt flag */
    static const int32_t G_TIM4_EGR_TG_POS               = 6;    /** @brief Trigger generation */
    static const int32_t G_TIM4_EGR_UG_POS               = 0;    /** @brief Update generation */
    static const int32_t G_TIM4_CCMR1_INPUT_IC2PCS_POS   = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t G_TIM4_CCMR1_INPUT_ICPCS_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G_TIM4_CCMR2_OUTPUT_O24CE_POS   = 15;   /** @brief O24CE */
    static const int32_t G_TIM4_CCMR2_OUTPUT_OC3CE_POS   = 7;    /** @brief OC3CE */
    static const int32_t G_TIM4_CNT_CNT_L_POS            = 0;    /** @brief Low counter value */
    static const int32_t G_TIM4_CNT_CNT_H_POS            = 16;   /** @brief High counter value */
    static const int32_t G_TIM4_PSC_PSC_POS              = 0;    /** @brief Prescaler value */
    static const int32_t G_TIM4_ARR_ARR_H_POS            = 16;   /** @brief High auto-reload value */
    static const int32_t G_TIM4_ARR_ARR_L_POS            = 0;    /** @brief Low auto-reload value */
    static const int32_t G_TIM4_CCRx_CCR1_H_POS          = 16;   /** @brief High capture/compare 1 value */
    static const int32_t G_TIM4_CCRx_CCR1_L_POS          = 0;    /** @brief Low capture/compare 1 value */
    static const int32_t G_TIM4_DCR_DBL_POS              = 8;    /** @brief DMA burst length */
    static const int32_t G_TIM4_DCR_DBA_POS              = 0;    /** @brief DMA base address */
    static const int32_t G_TIM4_DMAR_DMAB_POS            = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G_TIM4_AF1_ETRSEL_POS           = 14;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM4 Register Field Positions ****/

    static const int32_t G_TIM4_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t G_TIM4_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t G_TIM4_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t G_TIM4_SR_CCxIF_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const int32_t G_TIM4_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t G_TIM4_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief CC1S */
      [2] = 8,   /** @brief CC2S */
    };

    static const int32_t G_TIM4_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief OC1FE */
      [2] = 10,   /** @brief OC2FE */
    };

    static const int32_t G_TIM4_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief OC1PE */
      [2] = 11,   /** @brief OC2PE */
    };

    static const int32_t G_TIM4_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief OC1M */
      [2] = 12,   /** @brief OC2M */
    };

    static const int32_t G_TIM4_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief OC1CE */
      [2] = 15,   /** @brief OC2CE */
    };

    static const int32_t G_TIM4_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t G_TIM4_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t G_TIM4_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t G_TIM4_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 output polarity */
    };

    static const int32_t G_TIM4_CCER_CCxP_POS[5] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    };

    static const int32_t G_TIM4_CCER_CCxE_POS[5] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
    };

    static const int32_t G_TIM4_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
      [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
      [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**********************************************************************************************
     * @section G_TIM5 Register Information
     **********************************************************************************************/

    /**** @subsection G_TIM5 Register Pointers ****/

    static RW_ uint32_t* const G_TIM5_CR1_PTR            = (RW_ uint32_t* const)0x40000C00U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G_TIM5_CR2_PTR            = (RW_ uint32_t* const)0x40000C04U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G_TIM5_SMCR_PTR           = (RW_ uint32_t* const)0x40000C08U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const G_TIM5_DIER_PTR           = (RW_ uint32_t* const)0x40000C0CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G_TIM5_SR_PTR             = (RW_ uint32_t* const)0x40000C10U;   /** @brief Status register */
    static RW_ uint32_t* const G_TIM5_EGR_PTR            = (RW_ uint32_t* const)0x40000C14U;   /** @brief Event generation register */
    static RW_ uint32_t* const G_TIM5_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40000C18U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const G_TIM5_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40000C18U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G_TIM5_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x40000C1CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const G_TIM5_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x40000C1CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const G_TIM5_CCER_PTR           = (RW_ uint32_t* const)0x40000C20U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G_TIM5_CNT_PTR            = (RW_ uint32_t* const)0x40000C24U;   /** @brief Counter */
    static RW_ uint32_t* const G_TIM5_PSC_PTR            = (RW_ uint32_t* const)0x40000C28U;   /** @brief Prescaler */
    static RW_ uint32_t* const G_TIM5_ARR_PTR            = (RW_ uint32_t* const)0x40000C2CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G_TIM5_DCR_PTR            = (RW_ uint32_t* const)0x40000C48U;   /** @brief DMA control register */
    static RW_ uint32_t* const G_TIM5_DMAR_PTR           = (RW_ uint32_t* const)0x40000C4CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G_TIM5_AF1_PTR            = (RW_ uint32_t* const)0x40000C60U;   /** @brief TIM alternate function option register 1 */
    static RW_ uint32_t* const G_TIM5_TISEL_PTR          = (RW_ uint32_t* const)0x40000C68U;   /** @brief TIM timer input selection register */

    /**** @subsection Enumerated G_TIM5 Register Pointers ****/

    static RW_ uint32_t* const G_TIM5_CCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40000C34U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000C38U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x40000C3CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000C40U,   /** @brief Capture/compare register 4 */
    };

    /**** @subsection G_TIM5 Register Reset Values ****/

    static const uint32_t G_TIM5_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G_TIM5_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G_TIM5_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t G_TIM5_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G_TIM5_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G_TIM5_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G_TIM5_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G_TIM5_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G_TIM5_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t G_TIM5_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t G_TIM5_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G_TIM5_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G_TIM5_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G_TIM5_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G_TIM5_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G_TIM5_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G_TIM5_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t G_TIM5_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated G_TIM5 Register Reset Values ****/

    static const uint32_t G_TIM5_CCRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
    };

    /**** @subsection Enumerated G_TIM5 Register Value Types ****/

    typedef uint32_t G_TIM5_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G_TIM5_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G_TIM5_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t G_TIM5_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G_TIM5_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G_TIM5_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G_TIM5_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G_TIM5_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G_TIM5_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t G_TIM5_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t G_TIM5_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G_TIM5_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G_TIM5_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G_TIM5_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G_TIM5_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t G_TIM5_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G_TIM5_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G_TIM5_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t G_TIM5_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated G_TIM5 Register Pointer Types ****/

    typedef uint32_t* const G_TIM5_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G_TIM5_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G_TIM5_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const G_TIM5_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G_TIM5_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G_TIM5_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G_TIM5_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM5_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G_TIM5_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM5_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const G_TIM5_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G_TIM5_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G_TIM5_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G_TIM5_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G_TIM5_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const G_TIM5_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G_TIM5_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G_TIM5_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const G_TIM5_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection G_TIM5 Register Field Masks ****/

    static const uint32_t G_TIM5_CR1_UIFREMAP_MASK         = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G_TIM5_CR1_CKD_MASK              = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G_TIM5_CR1_ARPE_MASK             = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G_TIM5_CR1_CMS_MASK              = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t G_TIM5_CR1_DIR_MASK              = 0x00000010U;   /** @brief Direction */
    static const uint32_t G_TIM5_CR1_OPM_MASK              = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G_TIM5_CR1_URS_MASK              = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G_TIM5_CR1_UDIS_MASK             = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G_TIM5_CR1_CEN_MASK              = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G_TIM5_CR2_TI1S_MASK             = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t G_TIM5_CR2_MMS_MASK              = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t G_TIM5_CR2_CCDS_MASK             = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G_TIM5_SMCR_TS_4_3_MASK          = 0x00300000U;   /** @brief Trigger selection */
    static const uint32_t G_TIM5_SMCR_SMS_3_MASK           = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t G_TIM5_SMCR_ETP_MASK             = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t G_TIM5_SMCR_ECE_MASK             = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t G_TIM5_SMCR_ETPS_MASK            = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t G_TIM5_SMCR_ETF_MASK             = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t G_TIM5_SMCR_MSM_MASK             = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t G_TIM5_SMCR_TS_MASK              = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t G_TIM5_SMCR_SMS_MASK             = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t G_TIM5_DIER_TDE_MASK             = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t G_TIM5_DIER_UDE_MASK             = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G_TIM5_DIER_TIE_MASK             = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t G_TIM5_DIER_UIE_MASK             = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G_TIM5_SR_TIF_MASK               = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t G_TIM5_SR_UIF_MASK               = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G_TIM5_EGR_TG_MASK               = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t G_TIM5_EGR_UG_MASK               = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G_TIM5_CCMR1_INPUT_IC2PCS_MASK   = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t G_TIM5_CCMR1_INPUT_ICPCS_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G_TIM5_CCMR2_OUTPUT_O24CE_MASK   = 0x00008000U;   /** @brief O24CE */
    static const uint32_t G_TIM5_CCMR2_OUTPUT_OC3CE_MASK   = 0x00000080U;   /** @brief OC3CE */
    static const uint32_t G_TIM5_CNT_CNT_L_MASK            = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t G_TIM5_CNT_CNT_H_MASK            = 0xFFFF0000U;   /** @brief High counter value */
    static const uint32_t G_TIM5_PSC_PSC_MASK              = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G_TIM5_ARR_ARR_H_MASK            = 0xFFFF0000U;   /** @brief High auto-reload value */
    static const uint32_t G_TIM5_ARR_ARR_L_MASK            = 0x0000FFFFU;   /** @brief Low auto-reload value */
    static const uint32_t G_TIM5_CCRx_CCR1_H_MASK          = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
    static const uint32_t G_TIM5_CCRx_CCR1_L_MASK          = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
    static const uint32_t G_TIM5_DCR_DBL_MASK              = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G_TIM5_DCR_DBA_MASK              = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G_TIM5_DMAR_DMAB_MASK            = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G_TIM5_AF1_ETRSEL_MASK           = 0x0003C000U;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM5 Register Field Masks ****/

    static const uint32_t G_TIM5_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t G_TIM5_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t G_TIM5_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t G_TIM5_SR_CCxIF_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const uint32_t G_TIM5_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t G_TIM5_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief CC1S */
      [2] = 0x00000300U,   /** @brief CC2S */
    };

    static const uint32_t G_TIM5_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief OC1FE */
      [2] = 0x00000400U,   /** @brief OC2FE */
    };

    static const uint32_t G_TIM5_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief OC1PE */
      [2] = 0x00000800U,   /** @brief OC2PE */
    };

    static const uint32_t G_TIM5_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief OC1M */
      [2] = 0x00007000U,   /** @brief OC2M */
    };

    static const uint32_t G_TIM5_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief OC1CE */
      [2] = 0x00008000U,   /** @brief OC2CE */
    };

    static const uint32_t G_TIM5_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t G_TIM5_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t G_TIM5_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t G_TIM5_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
    };

    static const uint32_t G_TIM5_CCER_CCxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    };

    static const uint32_t G_TIM5_CCER_CCxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    };

    static const uint32_t G_TIM5_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
      [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
      [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**** @subsection G_TIM5 Register Field Positions ****/

    static const int32_t G_TIM5_CR1_UIFREMAP_POS         = 11;   /** @brief UIF status bit remapping */
    static const int32_t G_TIM5_CR1_CKD_POS              = 8;    /** @brief Clock division */
    static const int32_t G_TIM5_CR1_ARPE_POS             = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G_TIM5_CR1_CMS_POS              = 5;    /** @brief Center-aligned mode selection */
    static const int32_t G_TIM5_CR1_DIR_POS              = 4;    /** @brief Direction */
    static const int32_t G_TIM5_CR1_OPM_POS              = 3;    /** @brief One-pulse mode */
    static const int32_t G_TIM5_CR1_URS_POS              = 2;    /** @brief Update request source */
    static const int32_t G_TIM5_CR1_UDIS_POS             = 1;    /** @brief Update disable */
    static const int32_t G_TIM5_CR1_CEN_POS              = 0;    /** @brief Counter enable */
    static const int32_t G_TIM5_CR2_TI1S_POS             = 7;    /** @brief TI1 selection */
    static const int32_t G_TIM5_CR2_MMS_POS              = 4;    /** @brief Master mode selection */
    static const int32_t G_TIM5_CR2_CCDS_POS             = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G_TIM5_SMCR_TS_4_3_POS          = 20;   /** @brief Trigger selection */
    static const int32_t G_TIM5_SMCR_SMS_3_POS           = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t G_TIM5_SMCR_ETP_POS             = 15;   /** @brief External trigger polarity */
    static const int32_t G_TIM5_SMCR_ECE_POS             = 14;   /** @brief External clock enable */
    static const int32_t G_TIM5_SMCR_ETPS_POS            = 12;   /** @brief External trigger prescaler */
    static const int32_t G_TIM5_SMCR_ETF_POS             = 8;    /** @brief External trigger filter */
    static const int32_t G_TIM5_SMCR_MSM_POS             = 7;    /** @brief Master/Slave mode */
    static const int32_t G_TIM5_SMCR_TS_POS              = 4;    /** @brief Trigger selection */
    static const int32_t G_TIM5_SMCR_SMS_POS             = 0;    /** @brief Slave mode selection */
    static const int32_t G_TIM5_DIER_TDE_POS             = 14;   /** @brief Trigger DMA request enable */
    static const int32_t G_TIM5_DIER_UDE_POS             = 8;    /** @brief Update DMA request enable */
    static const int32_t G_TIM5_DIER_TIE_POS             = 6;    /** @brief Trigger interrupt enable */
    static const int32_t G_TIM5_DIER_UIE_POS             = 0;    /** @brief Update interrupt enable */
    static const int32_t G_TIM5_SR_TIF_POS               = 6;    /** @brief Trigger interrupt flag */
    static const int32_t G_TIM5_SR_UIF_POS               = 0;    /** @brief Update interrupt flag */
    static const int32_t G_TIM5_EGR_TG_POS               = 6;    /** @brief Trigger generation */
    static const int32_t G_TIM5_EGR_UG_POS               = 0;    /** @brief Update generation */
    static const int32_t G_TIM5_CCMR1_INPUT_IC2PCS_POS   = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t G_TIM5_CCMR1_INPUT_ICPCS_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G_TIM5_CCMR2_OUTPUT_O24CE_POS   = 15;   /** @brief O24CE */
    static const int32_t G_TIM5_CCMR2_OUTPUT_OC3CE_POS   = 7;    /** @brief OC3CE */
    static const int32_t G_TIM5_CNT_CNT_L_POS            = 0;    /** @brief Low counter value */
    static const int32_t G_TIM5_CNT_CNT_H_POS            = 16;   /** @brief High counter value */
    static const int32_t G_TIM5_PSC_PSC_POS              = 0;    /** @brief Prescaler value */
    static const int32_t G_TIM5_ARR_ARR_H_POS            = 16;   /** @brief High auto-reload value */
    static const int32_t G_TIM5_ARR_ARR_L_POS            = 0;    /** @brief Low auto-reload value */
    static const int32_t G_TIM5_CCRx_CCR1_H_POS          = 16;   /** @brief High capture/compare 1 value */
    static const int32_t G_TIM5_CCRx_CCR1_L_POS          = 0;    /** @brief Low capture/compare 1 value */
    static const int32_t G_TIM5_DCR_DBL_POS              = 8;    /** @brief DMA burst length */
    static const int32_t G_TIM5_DCR_DBA_POS              = 0;    /** @brief DMA base address */
    static const int32_t G_TIM5_DMAR_DMAB_POS            = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G_TIM5_AF1_ETRSEL_POS           = 14;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM5 Register Field Positions ****/

    static const int32_t G_TIM5_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t G_TIM5_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t G_TIM5_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t G_TIM5_SR_CCxIF_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const int32_t G_TIM5_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t G_TIM5_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief CC1S */
      [2] = 8,   /** @brief CC2S */
    };

    static const int32_t G_TIM5_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief OC1FE */
      [2] = 10,   /** @brief OC2FE */
    };

    static const int32_t G_TIM5_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief OC1PE */
      [2] = 11,   /** @brief OC2PE */
    };

    static const int32_t G_TIM5_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief OC1M */
      [2] = 12,   /** @brief OC2M */
    };

    static const int32_t G_TIM5_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief OC1CE */
      [2] = 15,   /** @brief OC2CE */
    };

    static const int32_t G_TIM5_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t G_TIM5_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t G_TIM5_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t G_TIM5_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 output polarity */
    };

    static const int32_t G_TIM5_CCER_CCxP_POS[5] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    };

    static const int32_t G_TIM5_CCER_CCxE_POS[5] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
    };

    static const int32_t G_TIM5_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
      [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
      [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**********************************************************************************************
     * @section G_TIM12 Register Information
     **********************************************************************************************/

    /**** @subsection G_TIM12 Register Pointers ****/

    static RW_ uint32_t* const G_TIM12_CR1_PTR            = (RW_ uint32_t* const)0x40001800U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G_TIM12_CR2_PTR            = (RW_ uint32_t* const)0x40001804U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G_TIM12_SMCR_PTR           = (RW_ uint32_t* const)0x40001808U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const G_TIM12_DIER_PTR           = (RW_ uint32_t* const)0x4000180CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G_TIM12_SR_PTR             = (RW_ uint32_t* const)0x40001810U;   /** @brief Status register */
    static RW_ uint32_t* const G_TIM12_EGR_PTR            = (RW_ uint32_t* const)0x40001814U;   /** @brief Event generation register */
    static RW_ uint32_t* const G_TIM12_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40001818U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const G_TIM12_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40001818U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G_TIM12_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x4000181CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const G_TIM12_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x4000181CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const G_TIM12_CCER_PTR           = (RW_ uint32_t* const)0x40001820U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G_TIM12_CNT_PTR            = (RW_ uint32_t* const)0x40001824U;   /** @brief Counter */
    static RW_ uint32_t* const G_TIM12_PSC_PTR            = (RW_ uint32_t* const)0x40001828U;   /** @brief Prescaler */
    static RW_ uint32_t* const G_TIM12_ARR_PTR            = (RW_ uint32_t* const)0x4000182CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G_TIM12_DCR_PTR            = (RW_ uint32_t* const)0x40001848U;   /** @brief DMA control register */
    static RW_ uint32_t* const G_TIM12_DMAR_PTR           = (RW_ uint32_t* const)0x4000184CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G_TIM12_AF1_PTR            = (RW_ uint32_t* const)0x40001860U;   /** @brief TIM alternate function option register 1 */
    static RW_ uint32_t* const G_TIM12_TISEL_PTR          = (RW_ uint32_t* const)0x40001868U;   /** @brief TIM timer input selection register */

    /**** @subsection Enumerated G_TIM12 Register Pointers ****/

    static RW_ uint32_t* const G_TIM12_CCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40001834U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40001838U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000183CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40001840U,   /** @brief Capture/compare register 4 */
    };

    /**** @subsection G_TIM12 Register Reset Values ****/

    static const uint32_t G_TIM12_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G_TIM12_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G_TIM12_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t G_TIM12_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G_TIM12_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G_TIM12_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G_TIM12_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G_TIM12_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G_TIM12_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t G_TIM12_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t G_TIM12_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G_TIM12_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G_TIM12_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G_TIM12_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G_TIM12_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G_TIM12_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G_TIM12_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t G_TIM12_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated G_TIM12 Register Reset Values ****/

    static const uint32_t G_TIM12_CCRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
    };

    /**** @subsection Enumerated G_TIM12 Register Value Types ****/

    typedef uint32_t G_TIM12_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G_TIM12_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G_TIM12_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t G_TIM12_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G_TIM12_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G_TIM12_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G_TIM12_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G_TIM12_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G_TIM12_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t G_TIM12_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t G_TIM12_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G_TIM12_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G_TIM12_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G_TIM12_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G_TIM12_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t G_TIM12_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G_TIM12_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G_TIM12_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t G_TIM12_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated G_TIM12 Register Pointer Types ****/

    typedef uint32_t* const G_TIM12_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G_TIM12_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G_TIM12_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const G_TIM12_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G_TIM12_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G_TIM12_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G_TIM12_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM12_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G_TIM12_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM12_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const G_TIM12_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G_TIM12_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G_TIM12_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G_TIM12_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G_TIM12_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const G_TIM12_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G_TIM12_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G_TIM12_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const G_TIM12_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection G_TIM12 Register Field Masks ****/

    static const uint32_t G_TIM12_CR1_UIFREMAP_MASK         = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G_TIM12_CR1_CKD_MASK              = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G_TIM12_CR1_ARPE_MASK             = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G_TIM12_CR1_CMS_MASK              = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t G_TIM12_CR1_DIR_MASK              = 0x00000010U;   /** @brief Direction */
    static const uint32_t G_TIM12_CR1_OPM_MASK              = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G_TIM12_CR1_URS_MASK              = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G_TIM12_CR1_UDIS_MASK             = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G_TIM12_CR1_CEN_MASK              = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G_TIM12_CR2_TI1S_MASK             = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t G_TIM12_CR2_MMS_MASK              = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t G_TIM12_CR2_CCDS_MASK             = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G_TIM12_SMCR_TS_4_3_MASK          = 0x00300000U;   /** @brief Trigger selection */
    static const uint32_t G_TIM12_SMCR_SMS_3_MASK           = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t G_TIM12_SMCR_ETP_MASK             = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t G_TIM12_SMCR_ECE_MASK             = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t G_TIM12_SMCR_ETPS_MASK            = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t G_TIM12_SMCR_ETF_MASK             = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t G_TIM12_SMCR_MSM_MASK             = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t G_TIM12_SMCR_TS_MASK              = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t G_TIM12_SMCR_SMS_MASK             = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t G_TIM12_DIER_TDE_MASK             = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t G_TIM12_DIER_UDE_MASK             = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G_TIM12_DIER_TIE_MASK             = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t G_TIM12_DIER_UIE_MASK             = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G_TIM12_SR_TIF_MASK               = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t G_TIM12_SR_UIF_MASK               = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G_TIM12_EGR_TG_MASK               = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t G_TIM12_EGR_UG_MASK               = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G_TIM12_CCMR1_INPUT_IC2PCS_MASK   = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t G_TIM12_CCMR1_INPUT_ICPCS_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G_TIM12_CCMR2_OUTPUT_O24CE_MASK   = 0x00008000U;   /** @brief O24CE */
    static const uint32_t G_TIM12_CCMR2_OUTPUT_OC3CE_MASK   = 0x00000080U;   /** @brief OC3CE */
    static const uint32_t G_TIM12_CNT_CNT_L_MASK            = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t G_TIM12_CNT_CNT_H_MASK            = 0xFFFF0000U;   /** @brief High counter value */
    static const uint32_t G_TIM12_PSC_PSC_MASK              = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G_TIM12_ARR_ARR_H_MASK            = 0xFFFF0000U;   /** @brief High auto-reload value */
    static const uint32_t G_TIM12_ARR_ARR_L_MASK            = 0x0000FFFFU;   /** @brief Low auto-reload value */
    static const uint32_t G_TIM12_CCRx_CCR1_H_MASK          = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
    static const uint32_t G_TIM12_CCRx_CCR1_L_MASK          = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
    static const uint32_t G_TIM12_DCR_DBL_MASK              = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G_TIM12_DCR_DBA_MASK              = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G_TIM12_DMAR_DMAB_MASK            = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G_TIM12_AF1_ETRSEL_MASK           = 0x0003C000U;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM12 Register Field Masks ****/

    static const uint32_t G_TIM12_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t G_TIM12_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t G_TIM12_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t G_TIM12_SR_CCxIF_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const uint32_t G_TIM12_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t G_TIM12_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief CC1S */
      [2] = 0x00000300U,   /** @brief CC2S */
    };

    static const uint32_t G_TIM12_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief OC1FE */
      [2] = 0x00000400U,   /** @brief OC2FE */
    };

    static const uint32_t G_TIM12_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief OC1PE */
      [2] = 0x00000800U,   /** @brief OC2PE */
    };

    static const uint32_t G_TIM12_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief OC1M */
      [2] = 0x00007000U,   /** @brief OC2M */
    };

    static const uint32_t G_TIM12_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief OC1CE */
      [2] = 0x00008000U,   /** @brief OC2CE */
    };

    static const uint32_t G_TIM12_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t G_TIM12_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t G_TIM12_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t G_TIM12_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
    };

    static const uint32_t G_TIM12_CCER_CCxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    };

    static const uint32_t G_TIM12_CCER_CCxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    };

    static const uint32_t G_TIM12_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
      [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
      [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**** @subsection G_TIM12 Register Field Positions ****/

    static const int32_t G_TIM12_CR1_UIFREMAP_POS         = 11;   /** @brief UIF status bit remapping */
    static const int32_t G_TIM12_CR1_CKD_POS              = 8;    /** @brief Clock division */
    static const int32_t G_TIM12_CR1_ARPE_POS             = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G_TIM12_CR1_CMS_POS              = 5;    /** @brief Center-aligned mode selection */
    static const int32_t G_TIM12_CR1_DIR_POS              = 4;    /** @brief Direction */
    static const int32_t G_TIM12_CR1_OPM_POS              = 3;    /** @brief One-pulse mode */
    static const int32_t G_TIM12_CR1_URS_POS              = 2;    /** @brief Update request source */
    static const int32_t G_TIM12_CR1_UDIS_POS             = 1;    /** @brief Update disable */
    static const int32_t G_TIM12_CR1_CEN_POS              = 0;    /** @brief Counter enable */
    static const int32_t G_TIM12_CR2_TI1S_POS             = 7;    /** @brief TI1 selection */
    static const int32_t G_TIM12_CR2_MMS_POS              = 4;    /** @brief Master mode selection */
    static const int32_t G_TIM12_CR2_CCDS_POS             = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G_TIM12_SMCR_TS_4_3_POS          = 20;   /** @brief Trigger selection */
    static const int32_t G_TIM12_SMCR_SMS_3_POS           = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t G_TIM12_SMCR_ETP_POS             = 15;   /** @brief External trigger polarity */
    static const int32_t G_TIM12_SMCR_ECE_POS             = 14;   /** @brief External clock enable */
    static const int32_t G_TIM12_SMCR_ETPS_POS            = 12;   /** @brief External trigger prescaler */
    static const int32_t G_TIM12_SMCR_ETF_POS             = 8;    /** @brief External trigger filter */
    static const int32_t G_TIM12_SMCR_MSM_POS             = 7;    /** @brief Master/Slave mode */
    static const int32_t G_TIM12_SMCR_TS_POS              = 4;    /** @brief Trigger selection */
    static const int32_t G_TIM12_SMCR_SMS_POS             = 0;    /** @brief Slave mode selection */
    static const int32_t G_TIM12_DIER_TDE_POS             = 14;   /** @brief Trigger DMA request enable */
    static const int32_t G_TIM12_DIER_UDE_POS             = 8;    /** @brief Update DMA request enable */
    static const int32_t G_TIM12_DIER_TIE_POS             = 6;    /** @brief Trigger interrupt enable */
    static const int32_t G_TIM12_DIER_UIE_POS             = 0;    /** @brief Update interrupt enable */
    static const int32_t G_TIM12_SR_TIF_POS               = 6;    /** @brief Trigger interrupt flag */
    static const int32_t G_TIM12_SR_UIF_POS               = 0;    /** @brief Update interrupt flag */
    static const int32_t G_TIM12_EGR_TG_POS               = 6;    /** @brief Trigger generation */
    static const int32_t G_TIM12_EGR_UG_POS               = 0;    /** @brief Update generation */
    static const int32_t G_TIM12_CCMR1_INPUT_IC2PCS_POS   = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t G_TIM12_CCMR1_INPUT_ICPCS_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G_TIM12_CCMR2_OUTPUT_O24CE_POS   = 15;   /** @brief O24CE */
    static const int32_t G_TIM12_CCMR2_OUTPUT_OC3CE_POS   = 7;    /** @brief OC3CE */
    static const int32_t G_TIM12_CNT_CNT_L_POS            = 0;    /** @brief Low counter value */
    static const int32_t G_TIM12_CNT_CNT_H_POS            = 16;   /** @brief High counter value */
    static const int32_t G_TIM12_PSC_PSC_POS              = 0;    /** @brief Prescaler value */
    static const int32_t G_TIM12_ARR_ARR_H_POS            = 16;   /** @brief High auto-reload value */
    static const int32_t G_TIM12_ARR_ARR_L_POS            = 0;    /** @brief Low auto-reload value */
    static const int32_t G_TIM12_CCRx_CCR1_H_POS          = 16;   /** @brief High capture/compare 1 value */
    static const int32_t G_TIM12_CCRx_CCR1_L_POS          = 0;    /** @brief Low capture/compare 1 value */
    static const int32_t G_TIM12_DCR_DBL_POS              = 8;    /** @brief DMA burst length */
    static const int32_t G_TIM12_DCR_DBA_POS              = 0;    /** @brief DMA base address */
    static const int32_t G_TIM12_DMAR_DMAB_POS            = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G_TIM12_AF1_ETRSEL_POS           = 14;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM12 Register Field Positions ****/

    static const int32_t G_TIM12_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t G_TIM12_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t G_TIM12_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t G_TIM12_SR_CCxIF_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const int32_t G_TIM12_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t G_TIM12_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief CC1S */
      [2] = 8,   /** @brief CC2S */
    };

    static const int32_t G_TIM12_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief OC1FE */
      [2] = 10,   /** @brief OC2FE */
    };

    static const int32_t G_TIM12_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief OC1PE */
      [2] = 11,   /** @brief OC2PE */
    };

    static const int32_t G_TIM12_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief OC1M */
      [2] = 12,   /** @brief OC2M */
    };

    static const int32_t G_TIM12_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief OC1CE */
      [2] = 15,   /** @brief OC2CE */
    };

    static const int32_t G_TIM12_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t G_TIM12_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t G_TIM12_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t G_TIM12_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 output polarity */
    };

    static const int32_t G_TIM12_CCER_CCxP_POS[5] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    };

    static const int32_t G_TIM12_CCER_CCxE_POS[5] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
    };

    static const int32_t G_TIM12_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
      [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
      [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**********************************************************************************************
     * @section G_TIM13 Register Information
     **********************************************************************************************/

    /**** @subsection G_TIM13 Register Pointers ****/

    static RW_ uint32_t* const G_TIM13_CR1_PTR            = (RW_ uint32_t* const)0x40001C00U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G_TIM13_CR2_PTR            = (RW_ uint32_t* const)0x40001C04U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G_TIM13_SMCR_PTR           = (RW_ uint32_t* const)0x40001C08U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const G_TIM13_DIER_PTR           = (RW_ uint32_t* const)0x40001C0CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G_TIM13_SR_PTR             = (RW_ uint32_t* const)0x40001C10U;   /** @brief Status register */
    static RW_ uint32_t* const G_TIM13_EGR_PTR            = (RW_ uint32_t* const)0x40001C14U;   /** @brief Event generation register */
    static RW_ uint32_t* const G_TIM13_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40001C18U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const G_TIM13_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40001C18U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G_TIM13_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x40001C1CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const G_TIM13_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x40001C1CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const G_TIM13_CCER_PTR           = (RW_ uint32_t* const)0x40001C20U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G_TIM13_CNT_PTR            = (RW_ uint32_t* const)0x40001C24U;   /** @brief Counter */
    static RW_ uint32_t* const G_TIM13_PSC_PTR            = (RW_ uint32_t* const)0x40001C28U;   /** @brief Prescaler */
    static RW_ uint32_t* const G_TIM13_ARR_PTR            = (RW_ uint32_t* const)0x40001C2CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G_TIM13_DCR_PTR            = (RW_ uint32_t* const)0x40001C48U;   /** @brief DMA control register */
    static RW_ uint32_t* const G_TIM13_DMAR_PTR           = (RW_ uint32_t* const)0x40001C4CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G_TIM13_AF1_PTR            = (RW_ uint32_t* const)0x40001C60U;   /** @brief TIM alternate function option register 1 */
    static RW_ uint32_t* const G_TIM13_TISEL_PTR          = (RW_ uint32_t* const)0x40001C68U;   /** @brief TIM timer input selection register */

    /**** @subsection Enumerated G_TIM13 Register Pointers ****/

    static RW_ uint32_t* const G_TIM13_CCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40001C34U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40001C38U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x40001C3CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40001C40U,   /** @brief Capture/compare register 4 */
    };

    /**** @subsection G_TIM13 Register Reset Values ****/

    static const uint32_t G_TIM13_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G_TIM13_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G_TIM13_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t G_TIM13_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G_TIM13_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G_TIM13_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G_TIM13_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G_TIM13_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G_TIM13_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t G_TIM13_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t G_TIM13_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G_TIM13_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G_TIM13_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G_TIM13_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G_TIM13_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G_TIM13_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G_TIM13_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t G_TIM13_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated G_TIM13 Register Reset Values ****/

    static const uint32_t G_TIM13_CCRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
    };

    /**** @subsection Enumerated G_TIM13 Register Value Types ****/

    typedef uint32_t G_TIM13_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G_TIM13_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G_TIM13_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t G_TIM13_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G_TIM13_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G_TIM13_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G_TIM13_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G_TIM13_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G_TIM13_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t G_TIM13_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t G_TIM13_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G_TIM13_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G_TIM13_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G_TIM13_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G_TIM13_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t G_TIM13_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G_TIM13_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G_TIM13_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t G_TIM13_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated G_TIM13 Register Pointer Types ****/

    typedef uint32_t* const G_TIM13_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G_TIM13_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G_TIM13_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const G_TIM13_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G_TIM13_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G_TIM13_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G_TIM13_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM13_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G_TIM13_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM13_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const G_TIM13_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G_TIM13_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G_TIM13_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G_TIM13_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G_TIM13_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const G_TIM13_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G_TIM13_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G_TIM13_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const G_TIM13_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection G_TIM13 Register Field Masks ****/

    static const uint32_t G_TIM13_CR1_UIFREMAP_MASK         = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G_TIM13_CR1_CKD_MASK              = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G_TIM13_CR1_ARPE_MASK             = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G_TIM13_CR1_CMS_MASK              = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t G_TIM13_CR1_DIR_MASK              = 0x00000010U;   /** @brief Direction */
    static const uint32_t G_TIM13_CR1_OPM_MASK              = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G_TIM13_CR1_URS_MASK              = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G_TIM13_CR1_UDIS_MASK             = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G_TIM13_CR1_CEN_MASK              = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G_TIM13_CR2_TI1S_MASK             = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t G_TIM13_CR2_MMS_MASK              = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t G_TIM13_CR2_CCDS_MASK             = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G_TIM13_SMCR_TS_4_3_MASK          = 0x00300000U;   /** @brief Trigger selection */
    static const uint32_t G_TIM13_SMCR_SMS_3_MASK           = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t G_TIM13_SMCR_ETP_MASK             = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t G_TIM13_SMCR_ECE_MASK             = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t G_TIM13_SMCR_ETPS_MASK            = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t G_TIM13_SMCR_ETF_MASK             = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t G_TIM13_SMCR_MSM_MASK             = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t G_TIM13_SMCR_TS_MASK              = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t G_TIM13_SMCR_SMS_MASK             = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t G_TIM13_DIER_TDE_MASK             = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t G_TIM13_DIER_UDE_MASK             = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G_TIM13_DIER_TIE_MASK             = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t G_TIM13_DIER_UIE_MASK             = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G_TIM13_SR_TIF_MASK               = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t G_TIM13_SR_UIF_MASK               = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G_TIM13_EGR_TG_MASK               = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t G_TIM13_EGR_UG_MASK               = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G_TIM13_CCMR1_INPUT_IC2PCS_MASK   = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t G_TIM13_CCMR1_INPUT_ICPCS_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G_TIM13_CCMR2_OUTPUT_O24CE_MASK   = 0x00008000U;   /** @brief O24CE */
    static const uint32_t G_TIM13_CCMR2_OUTPUT_OC3CE_MASK   = 0x00000080U;   /** @brief OC3CE */
    static const uint32_t G_TIM13_CNT_CNT_L_MASK            = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t G_TIM13_CNT_CNT_H_MASK            = 0xFFFF0000U;   /** @brief High counter value */
    static const uint32_t G_TIM13_PSC_PSC_MASK              = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G_TIM13_ARR_ARR_H_MASK            = 0xFFFF0000U;   /** @brief High auto-reload value */
    static const uint32_t G_TIM13_ARR_ARR_L_MASK            = 0x0000FFFFU;   /** @brief Low auto-reload value */
    static const uint32_t G_TIM13_CCRx_CCR1_H_MASK          = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
    static const uint32_t G_TIM13_CCRx_CCR1_L_MASK          = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
    static const uint32_t G_TIM13_DCR_DBL_MASK              = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G_TIM13_DCR_DBA_MASK              = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G_TIM13_DMAR_DMAB_MASK            = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G_TIM13_AF1_ETRSEL_MASK           = 0x0003C000U;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM13 Register Field Masks ****/

    static const uint32_t G_TIM13_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t G_TIM13_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t G_TIM13_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t G_TIM13_SR_CCxIF_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const uint32_t G_TIM13_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t G_TIM13_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief CC1S */
      [2] = 0x00000300U,   /** @brief CC2S */
    };

    static const uint32_t G_TIM13_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief OC1FE */
      [2] = 0x00000400U,   /** @brief OC2FE */
    };

    static const uint32_t G_TIM13_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief OC1PE */
      [2] = 0x00000800U,   /** @brief OC2PE */
    };

    static const uint32_t G_TIM13_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief OC1M */
      [2] = 0x00007000U,   /** @brief OC2M */
    };

    static const uint32_t G_TIM13_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief OC1CE */
      [2] = 0x00008000U,   /** @brief OC2CE */
    };

    static const uint32_t G_TIM13_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t G_TIM13_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t G_TIM13_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t G_TIM13_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
    };

    static const uint32_t G_TIM13_CCER_CCxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    };

    static const uint32_t G_TIM13_CCER_CCxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    };

    static const uint32_t G_TIM13_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
      [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
      [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**** @subsection G_TIM13 Register Field Positions ****/

    static const int32_t G_TIM13_CR1_UIFREMAP_POS         = 11;   /** @brief UIF status bit remapping */
    static const int32_t G_TIM13_CR1_CKD_POS              = 8;    /** @brief Clock division */
    static const int32_t G_TIM13_CR1_ARPE_POS             = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G_TIM13_CR1_CMS_POS              = 5;    /** @brief Center-aligned mode selection */
    static const int32_t G_TIM13_CR1_DIR_POS              = 4;    /** @brief Direction */
    static const int32_t G_TIM13_CR1_OPM_POS              = 3;    /** @brief One-pulse mode */
    static const int32_t G_TIM13_CR1_URS_POS              = 2;    /** @brief Update request source */
    static const int32_t G_TIM13_CR1_UDIS_POS             = 1;    /** @brief Update disable */
    static const int32_t G_TIM13_CR1_CEN_POS              = 0;    /** @brief Counter enable */
    static const int32_t G_TIM13_CR2_TI1S_POS             = 7;    /** @brief TI1 selection */
    static const int32_t G_TIM13_CR2_MMS_POS              = 4;    /** @brief Master mode selection */
    static const int32_t G_TIM13_CR2_CCDS_POS             = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G_TIM13_SMCR_TS_4_3_POS          = 20;   /** @brief Trigger selection */
    static const int32_t G_TIM13_SMCR_SMS_3_POS           = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t G_TIM13_SMCR_ETP_POS             = 15;   /** @brief External trigger polarity */
    static const int32_t G_TIM13_SMCR_ECE_POS             = 14;   /** @brief External clock enable */
    static const int32_t G_TIM13_SMCR_ETPS_POS            = 12;   /** @brief External trigger prescaler */
    static const int32_t G_TIM13_SMCR_ETF_POS             = 8;    /** @brief External trigger filter */
    static const int32_t G_TIM13_SMCR_MSM_POS             = 7;    /** @brief Master/Slave mode */
    static const int32_t G_TIM13_SMCR_TS_POS              = 4;    /** @brief Trigger selection */
    static const int32_t G_TIM13_SMCR_SMS_POS             = 0;    /** @brief Slave mode selection */
    static const int32_t G_TIM13_DIER_TDE_POS             = 14;   /** @brief Trigger DMA request enable */
    static const int32_t G_TIM13_DIER_UDE_POS             = 8;    /** @brief Update DMA request enable */
    static const int32_t G_TIM13_DIER_TIE_POS             = 6;    /** @brief Trigger interrupt enable */
    static const int32_t G_TIM13_DIER_UIE_POS             = 0;    /** @brief Update interrupt enable */
    static const int32_t G_TIM13_SR_TIF_POS               = 6;    /** @brief Trigger interrupt flag */
    static const int32_t G_TIM13_SR_UIF_POS               = 0;    /** @brief Update interrupt flag */
    static const int32_t G_TIM13_EGR_TG_POS               = 6;    /** @brief Trigger generation */
    static const int32_t G_TIM13_EGR_UG_POS               = 0;    /** @brief Update generation */
    static const int32_t G_TIM13_CCMR1_INPUT_IC2PCS_POS   = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t G_TIM13_CCMR1_INPUT_ICPCS_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G_TIM13_CCMR2_OUTPUT_O24CE_POS   = 15;   /** @brief O24CE */
    static const int32_t G_TIM13_CCMR2_OUTPUT_OC3CE_POS   = 7;    /** @brief OC3CE */
    static const int32_t G_TIM13_CNT_CNT_L_POS            = 0;    /** @brief Low counter value */
    static const int32_t G_TIM13_CNT_CNT_H_POS            = 16;   /** @brief High counter value */
    static const int32_t G_TIM13_PSC_PSC_POS              = 0;    /** @brief Prescaler value */
    static const int32_t G_TIM13_ARR_ARR_H_POS            = 16;   /** @brief High auto-reload value */
    static const int32_t G_TIM13_ARR_ARR_L_POS            = 0;    /** @brief Low auto-reload value */
    static const int32_t G_TIM13_CCRx_CCR1_H_POS          = 16;   /** @brief High capture/compare 1 value */
    static const int32_t G_TIM13_CCRx_CCR1_L_POS          = 0;    /** @brief Low capture/compare 1 value */
    static const int32_t G_TIM13_DCR_DBL_POS              = 8;    /** @brief DMA burst length */
    static const int32_t G_TIM13_DCR_DBA_POS              = 0;    /** @brief DMA base address */
    static const int32_t G_TIM13_DMAR_DMAB_POS            = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G_TIM13_AF1_ETRSEL_POS           = 14;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM13 Register Field Positions ****/

    static const int32_t G_TIM13_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t G_TIM13_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t G_TIM13_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t G_TIM13_SR_CCxIF_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const int32_t G_TIM13_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t G_TIM13_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief CC1S */
      [2] = 8,   /** @brief CC2S */
    };

    static const int32_t G_TIM13_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief OC1FE */
      [2] = 10,   /** @brief OC2FE */
    };

    static const int32_t G_TIM13_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief OC1PE */
      [2] = 11,   /** @brief OC2PE */
    };

    static const int32_t G_TIM13_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief OC1M */
      [2] = 12,   /** @brief OC2M */
    };

    static const int32_t G_TIM13_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief OC1CE */
      [2] = 15,   /** @brief OC2CE */
    };

    static const int32_t G_TIM13_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t G_TIM13_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t G_TIM13_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t G_TIM13_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 output polarity */
    };

    static const int32_t G_TIM13_CCER_CCxP_POS[5] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    };

    static const int32_t G_TIM13_CCER_CCxE_POS[5] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
    };

    static const int32_t G_TIM13_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
      [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
      [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**********************************************************************************************
     * @section G_TIM14 Register Information
     **********************************************************************************************/

    /**** @subsection G_TIM14 Register Pointers ****/

    static RW_ uint32_t* const G_TIM14_CR1_PTR            = (RW_ uint32_t* const)0x40002000U;   /** @brief Control register 1 */
    static RW_ uint32_t* const G_TIM14_CR2_PTR            = (RW_ uint32_t* const)0x40002004U;   /** @brief Control register 2 */
    static RW_ uint32_t* const G_TIM14_SMCR_PTR           = (RW_ uint32_t* const)0x40002008U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const G_TIM14_DIER_PTR           = (RW_ uint32_t* const)0x4000200CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const G_TIM14_SR_PTR             = (RW_ uint32_t* const)0x40002010U;   /** @brief Status register */
    static RW_ uint32_t* const G_TIM14_EGR_PTR            = (RW_ uint32_t* const)0x40002014U;   /** @brief Event generation register */
    static RW_ uint32_t* const G_TIM14_CCMR1_OUTPUT_PTR   = (RW_ uint32_t* const)0x40002018U;   /** @brief Capture/compare mode register 1 (output mode) */
    static RW_ uint32_t* const G_TIM14_CCMR1_INPUT_PTR    = (RW_ uint32_t* const)0x40002018U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const G_TIM14_CCMR2_OUTPUT_PTR   = (RW_ uint32_t* const)0x4000201CU;   /** @brief Capture/compare mode register 2 (output mode) */
    static RW_ uint32_t* const G_TIM14_CCMR2_INPUT_PTR    = (RW_ uint32_t* const)0x4000201CU;   /** @brief Capture/compare mode register 2 (input mode) */
    static RW_ uint32_t* const G_TIM14_CCER_PTR           = (RW_ uint32_t* const)0x40002020U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const G_TIM14_CNT_PTR            = (RW_ uint32_t* const)0x40002024U;   /** @brief Counter */
    static RW_ uint32_t* const G_TIM14_PSC_PTR            = (RW_ uint32_t* const)0x40002028U;   /** @brief Prescaler */
    static RW_ uint32_t* const G_TIM14_ARR_PTR            = (RW_ uint32_t* const)0x4000202CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const G_TIM14_DCR_PTR            = (RW_ uint32_t* const)0x40002048U;   /** @brief DMA control register */
    static RW_ uint32_t* const G_TIM14_DMAR_PTR           = (RW_ uint32_t* const)0x4000204CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const G_TIM14_AF1_PTR            = (RW_ uint32_t* const)0x40002060U;   /** @brief TIM alternate function option register 1 */
    static RW_ uint32_t* const G_TIM14_TISEL_PTR          = (RW_ uint32_t* const)0x40002068U;   /** @brief TIM timer input selection register */

    /**** @subsection Enumerated G_TIM14 Register Pointers ****/

    static RW_ uint32_t* const G_TIM14_CCRx_PTR[5] = {
      [1] = (RW_ uint32_t* const)0x40002034U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40002038U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000203CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40002040U,   /** @brief Capture/compare register 4 */
    };

    /**** @subsection G_TIM14 Register Reset Values ****/

    static const uint32_t G_TIM14_CR1_RST            = 0x00000000U;   /** @brief CR1 register reset value. */
    static const uint32_t G_TIM14_CR2_RST            = 0x00000000U;   /** @brief CR2 register reset value. */
    static const uint32_t G_TIM14_SMCR_RST           = 0x00000000U;   /** @brief SMCR register reset value. */
    static const uint32_t G_TIM14_DIER_RST           = 0x00000000U;   /** @brief DIER register reset value. */
    static const uint32_t G_TIM14_SR_RST             = 0x00000000U;   /** @brief SR register reset value. */
    static const uint32_t G_TIM14_EGR_RST            = 0x00000000U;   /** @brief EGR register reset value. */
    static const uint32_t G_TIM14_CCMR1_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR1_OUTPUT register reset value. */
    static const uint32_t G_TIM14_CCMR1_INPUT_RST    = 0x00000000U;   /** @brief CCMR1_INPUT register reset value. */
    static const uint32_t G_TIM14_CCMR2_OUTPUT_RST   = 0x00000000U;   /** @brief CCMR2_OUTPUT register reset value. */
    static const uint32_t G_TIM14_CCMR2_INPUT_RST    = 0x00000000U;   /** @brief CCMR2_INPUT register reset value. */
    static const uint32_t G_TIM14_CCER_RST           = 0x00000000U;   /** @brief CCER register reset value. */
    static const uint32_t G_TIM14_CNT_RST            = 0x00000000U;   /** @brief CNT register reset value. */
    static const uint32_t G_TIM14_PSC_RST            = 0x00000000U;   /** @brief PSC register reset value. */
    static const uint32_t G_TIM14_ARR_RST            = 0x00000000U;   /** @brief ARR register reset value. */
    static const uint32_t G_TIM14_DCR_RST            = 0x00000000U;   /** @brief DCR register reset value. */
    static const uint32_t G_TIM14_DMAR_RST           = 0x00000000U;   /** @brief DMAR register reset value. */
    static const uint32_t G_TIM14_AF1_RST            = 0x00000000U;   /** @brief AF1 register reset value. */
    static const uint32_t G_TIM14_TISEL_RST          = 0x00000000U;   /** @brief TISEL register reset value. */

    /**** @subsection Enumerated G_TIM14 Register Reset Values ****/

    static const uint32_t G_TIM14_CCRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief CCR1 register reset value. */
      [2] = 0x00000000U,   /** @brief CCR2 register reset value. */
      [3] = 0x00000000U,   /** @brief CCR3 register reset value. */
      [4] = 0x00000000U,   /** @brief CCR4 register reset value. */
    };

    /**** @subsection Enumerated G_TIM14 Register Value Types ****/

    typedef uint32_t G_TIM14_CR1_t;            /** @brief CR1 register value type. */
    typedef uint32_t G_TIM14_CR2_t;            /** @brief CR2 register value type. */
    typedef uint32_t G_TIM14_SMCR_t;           /** @brief SMCR register value type. */
    typedef uint32_t G_TIM14_DIER_t;           /** @brief DIER register value type. */
    typedef uint32_t G_TIM14_SR_t;             /** @brief SR register value type. */
    typedef uint32_t G_TIM14_EGR_t;            /** @brief EGR register value type. */
    typedef uint32_t G_TIM14_CCMR1_OUTPUT_t;   /** @brief CCMR1_OUTPUT register value type. */
    typedef uint32_t G_TIM14_CCMR1_INPUT_t;    /** @brief CCMR1_INPUT register value type. */
    typedef uint32_t G_TIM14_CCMR2_OUTPUT_t;   /** @brief CCMR2_OUTPUT register value type. */
    typedef uint32_t G_TIM14_CCMR2_INPUT_t;    /** @brief CCMR2_INPUT register value type. */
    typedef uint32_t G_TIM14_CCER_t;           /** @brief CCER register value type. */
    typedef uint32_t G_TIM14_CNT_t;            /** @brief CNT register value type. */
    typedef uint32_t G_TIM14_PSC_t;            /** @brief PSC register value type. */
    typedef uint32_t G_TIM14_ARR_t;            /** @brief ARR register value type. */
    typedef uint32_t G_TIM14_CCRx_t;           /** @brief CCRx register value type. */
    typedef uint32_t G_TIM14_DCR_t;            /** @brief DCR register value type. */
    typedef uint32_t G_TIM14_DMAR_t;           /** @brief DMAR register value type. */
    typedef uint32_t G_TIM14_AF1_t;            /** @brief AF1 register value type. */
    typedef uint32_t G_TIM14_TISEL_t;          /** @brief TISEL register value type. */

    /**** @subsection Enumerated G_TIM14 Register Pointer Types ****/

    typedef uint32_t* const G_TIM14_CR1_PTR_t;            /** @brief CR1 register pointer type. */
    typedef uint32_t* const G_TIM14_CR2_PTR_t;            /** @brief CR2 register pointer type. */
    typedef uint32_t* const G_TIM14_SMCR_PTR_t;           /** @brief SMCR register pointer type. */
    typedef uint32_t* const G_TIM14_DIER_PTR_t;           /** @brief DIER register pointer type. */
    typedef uint32_t* const G_TIM14_SR_PTR_t;             /** @brief SR register pointer type. */
    typedef uint32_t* const G_TIM14_EGR_PTR_t;            /** @brief EGR register pointer type. */
    typedef uint32_t* const G_TIM14_CCMR1_OUTPUT_PTR_t;   /** @brief CCMR1_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM14_CCMR1_INPUT_PTR_t;    /** @brief CCMR1_INPUT register pointer type. */
    typedef uint32_t* const G_TIM14_CCMR2_OUTPUT_PTR_t;   /** @brief CCMR2_OUTPUT register pointer type. */
    typedef uint32_t* const G_TIM14_CCMR2_INPUT_PTR_t;    /** @brief CCMR2_INPUT register pointer type. */
    typedef uint32_t* const G_TIM14_CCER_PTR_t;           /** @brief CCER register pointer type. */
    typedef uint32_t* const G_TIM14_CNT_PTR_t;            /** @brief CNT register pointer type. */
    typedef uint32_t* const G_TIM14_PSC_PTR_t;            /** @brief PSC register pointer type. */
    typedef uint32_t* const G_TIM14_ARR_PTR_t;            /** @brief ARR register pointer type. */
    typedef uint32_t* const G_TIM14_CCRx_PTR_t;           /** @brief CCRx register pointer type. */
    typedef uint32_t* const G_TIM14_DCR_PTR_t;            /** @brief DCR register pointer type. */
    typedef uint32_t* const G_TIM14_DMAR_PTR_t;           /** @brief DMAR register pointer type. */
    typedef uint32_t* const G_TIM14_AF1_PTR_t;            /** @brief AF1 register pointer type. */
    typedef uint32_t* const G_TIM14_TISEL_PTR_t;          /** @brief TISEL register pointer type. */

    /**** @subsection G_TIM14 Register Field Masks ****/

    static const uint32_t G_TIM14_CR1_UIFREMAP_MASK         = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t G_TIM14_CR1_CKD_MASK              = 0x00000300U;   /** @brief Clock division */
    static const uint32_t G_TIM14_CR1_ARPE_MASK             = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t G_TIM14_CR1_CMS_MASK              = 0x00000060U;   /** @brief Center-aligned mode selection */
    static const uint32_t G_TIM14_CR1_DIR_MASK              = 0x00000010U;   /** @brief Direction */
    static const uint32_t G_TIM14_CR1_OPM_MASK              = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t G_TIM14_CR1_URS_MASK              = 0x00000004U;   /** @brief Update request source */
    static const uint32_t G_TIM14_CR1_UDIS_MASK             = 0x00000002U;   /** @brief Update disable */
    static const uint32_t G_TIM14_CR1_CEN_MASK              = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t G_TIM14_CR2_TI1S_MASK             = 0x00000080U;   /** @brief TI1 selection */
    static const uint32_t G_TIM14_CR2_MMS_MASK              = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t G_TIM14_CR2_CCDS_MASK             = 0x00000008U;   /** @brief Capture/compare DMA selection */
    static const uint32_t G_TIM14_SMCR_TS_4_3_MASK          = 0x00300000U;   /** @brief Trigger selection */
    static const uint32_t G_TIM14_SMCR_SMS_3_MASK           = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
    static const uint32_t G_TIM14_SMCR_ETP_MASK             = 0x00008000U;   /** @brief External trigger polarity */
    static const uint32_t G_TIM14_SMCR_ECE_MASK             = 0x00004000U;   /** @brief External clock enable */
    static const uint32_t G_TIM14_SMCR_ETPS_MASK            = 0x00003000U;   /** @brief External trigger prescaler */
    static const uint32_t G_TIM14_SMCR_ETF_MASK             = 0x00000F00U;   /** @brief External trigger filter */
    static const uint32_t G_TIM14_SMCR_MSM_MASK             = 0x00000080U;   /** @brief Master/Slave mode */
    static const uint32_t G_TIM14_SMCR_TS_MASK              = 0x00000070U;   /** @brief Trigger selection */
    static const uint32_t G_TIM14_SMCR_SMS_MASK             = 0x00000007U;   /** @brief Slave mode selection */
    static const uint32_t G_TIM14_DIER_TDE_MASK             = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t G_TIM14_DIER_UDE_MASK             = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t G_TIM14_DIER_TIE_MASK             = 0x00000040U;   /** @brief Trigger interrupt enable */
    static const uint32_t G_TIM14_DIER_UIE_MASK             = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t G_TIM14_SR_TIF_MASK               = 0x00000040U;   /** @brief Trigger interrupt flag */
    static const uint32_t G_TIM14_SR_UIF_MASK               = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t G_TIM14_EGR_TG_MASK               = 0x00000040U;   /** @brief Trigger generation */
    static const uint32_t G_TIM14_EGR_UG_MASK               = 0x00000001U;   /** @brief Update generation */
    static const uint32_t G_TIM14_CCMR1_INPUT_IC2PCS_MASK   = 0x00000C00U;   /** @brief Input capture 2 prescaler */
    static const uint32_t G_TIM14_CCMR1_INPUT_ICPCS_MASK    = 0x0000000CU;   /** @brief Input capture 1 prescaler */
    static const uint32_t G_TIM14_CCMR2_OUTPUT_O24CE_MASK   = 0x00008000U;   /** @brief O24CE */
    static const uint32_t G_TIM14_CCMR2_OUTPUT_OC3CE_MASK   = 0x00000080U;   /** @brief OC3CE */
    static const uint32_t G_TIM14_CNT_CNT_L_MASK            = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t G_TIM14_CNT_CNT_H_MASK            = 0xFFFF0000U;   /** @brief High counter value */
    static const uint32_t G_TIM14_PSC_PSC_MASK              = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t G_TIM14_ARR_ARR_H_MASK            = 0xFFFF0000U;   /** @brief High auto-reload value */
    static const uint32_t G_TIM14_ARR_ARR_L_MASK            = 0x0000FFFFU;   /** @brief Low auto-reload value */
    static const uint32_t G_TIM14_CCRx_CCR1_H_MASK          = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
    static const uint32_t G_TIM14_CCRx_CCR1_L_MASK          = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
    static const uint32_t G_TIM14_DCR_DBL_MASK              = 0x00001F00U;   /** @brief DMA burst length */
    static const uint32_t G_TIM14_DCR_DBA_MASK              = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t G_TIM14_DMAR_DMAB_MASK            = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
    static const uint32_t G_TIM14_AF1_ETRSEL_MASK           = 0x0003C000U;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM14 Register Field Masks ****/

    static const uint32_t G_TIM14_DIER_CCxDE_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
      [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t G_TIM14_DIER_CCxIE_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t G_TIM14_SR_CCxOF_MASK[5] = {
      [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
      [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t G_TIM14_SR_CCxIF_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const uint32_t G_TIM14_EGR_CCxG_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
      [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
      [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
      [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t G_TIM14_CCMR1_OUTPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief CC1S */
      [2] = 0x00000300U,   /** @brief CC2S */
    };

    static const uint32_t G_TIM14_CCMR1_OUTPUT_OCxFE_MASK[3] = {
      [1] = 0x00000004U,   /** @brief OC1FE */
      [2] = 0x00000400U,   /** @brief OC2FE */
    };

    static const uint32_t G_TIM14_CCMR1_OUTPUT_OCxPE_MASK[3] = {
      [1] = 0x00000008U,   /** @brief OC1PE */
      [2] = 0x00000800U,   /** @brief OC2PE */
    };

    static const uint32_t G_TIM14_CCMR1_OUTPUT_OCxM_MASK[3] = {
      [1] = 0x00000070U,   /** @brief OC1M */
      [2] = 0x00007000U,   /** @brief OC2M */
    };

    static const uint32_t G_TIM14_CCMR1_OUTPUT_OCxCE_MASK[3] = {
      [1] = 0x00000080U,   /** @brief OC1CE */
      [2] = 0x00008000U,   /** @brief OC2CE */
    };

    static const uint32_t G_TIM14_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const uint32_t G_TIM14_CCMR1_INPUT_ICxF_MASK[3] = {
      [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
      [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
    };

    static const uint32_t G_TIM14_CCMR2_INPUT_ICxPSC_MASK[5] = {
      [3] = 0x0000000CU,   /** @brief Input capture 3 prescaler */
      [4] = 0x00000C00U,   /** @brief Input capture 4 prescaler */
    };

    static const uint32_t G_TIM14_CCER_CCxNP_MASK[5] = {
      [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
    };

    static const uint32_t G_TIM14_CCER_CCxP_MASK[5] = {
      [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
      [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
      [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
      [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    };

    static const uint32_t G_TIM14_CCER_CCxE_MASK[5] = {
      [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
      [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
      [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    };

    static const uint32_t G_TIM14_TISEL_TIxSEL_MASK[5] = {
      [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
      [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
      [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**** @subsection G_TIM14 Register Field Positions ****/

    static const int32_t G_TIM14_CR1_UIFREMAP_POS         = 11;   /** @brief UIF status bit remapping */
    static const int32_t G_TIM14_CR1_CKD_POS              = 8;    /** @brief Clock division */
    static const int32_t G_TIM14_CR1_ARPE_POS             = 7;    /** @brief Auto-reload preload enable */
    static const int32_t G_TIM14_CR1_CMS_POS              = 5;    /** @brief Center-aligned mode selection */
    static const int32_t G_TIM14_CR1_DIR_POS              = 4;    /** @brief Direction */
    static const int32_t G_TIM14_CR1_OPM_POS              = 3;    /** @brief One-pulse mode */
    static const int32_t G_TIM14_CR1_URS_POS              = 2;    /** @brief Update request source */
    static const int32_t G_TIM14_CR1_UDIS_POS             = 1;    /** @brief Update disable */
    static const int32_t G_TIM14_CR1_CEN_POS              = 0;    /** @brief Counter enable */
    static const int32_t G_TIM14_CR2_TI1S_POS             = 7;    /** @brief TI1 selection */
    static const int32_t G_TIM14_CR2_MMS_POS              = 4;    /** @brief Master mode selection */
    static const int32_t G_TIM14_CR2_CCDS_POS             = 3;    /** @brief Capture/compare DMA selection */
    static const int32_t G_TIM14_SMCR_TS_4_3_POS          = 20;   /** @brief Trigger selection */
    static const int32_t G_TIM14_SMCR_SMS_3_POS           = 16;   /** @brief Slave mode selection - bit 3 */
    static const int32_t G_TIM14_SMCR_ETP_POS             = 15;   /** @brief External trigger polarity */
    static const int32_t G_TIM14_SMCR_ECE_POS             = 14;   /** @brief External clock enable */
    static const int32_t G_TIM14_SMCR_ETPS_POS            = 12;   /** @brief External trigger prescaler */
    static const int32_t G_TIM14_SMCR_ETF_POS             = 8;    /** @brief External trigger filter */
    static const int32_t G_TIM14_SMCR_MSM_POS             = 7;    /** @brief Master/Slave mode */
    static const int32_t G_TIM14_SMCR_TS_POS              = 4;    /** @brief Trigger selection */
    static const int32_t G_TIM14_SMCR_SMS_POS             = 0;    /** @brief Slave mode selection */
    static const int32_t G_TIM14_DIER_TDE_POS             = 14;   /** @brief Trigger DMA request enable */
    static const int32_t G_TIM14_DIER_UDE_POS             = 8;    /** @brief Update DMA request enable */
    static const int32_t G_TIM14_DIER_TIE_POS             = 6;    /** @brief Trigger interrupt enable */
    static const int32_t G_TIM14_DIER_UIE_POS             = 0;    /** @brief Update interrupt enable */
    static const int32_t G_TIM14_SR_TIF_POS               = 6;    /** @brief Trigger interrupt flag */
    static const int32_t G_TIM14_SR_UIF_POS               = 0;    /** @brief Update interrupt flag */
    static const int32_t G_TIM14_EGR_TG_POS               = 6;    /** @brief Trigger generation */
    static const int32_t G_TIM14_EGR_UG_POS               = 0;    /** @brief Update generation */
    static const int32_t G_TIM14_CCMR1_INPUT_IC2PCS_POS   = 10;   /** @brief Input capture 2 prescaler */
    static const int32_t G_TIM14_CCMR1_INPUT_ICPCS_POS    = 2;    /** @brief Input capture 1 prescaler */
    static const int32_t G_TIM14_CCMR2_OUTPUT_O24CE_POS   = 15;   /** @brief O24CE */
    static const int32_t G_TIM14_CCMR2_OUTPUT_OC3CE_POS   = 7;    /** @brief OC3CE */
    static const int32_t G_TIM14_CNT_CNT_L_POS            = 0;    /** @brief Low counter value */
    static const int32_t G_TIM14_CNT_CNT_H_POS            = 16;   /** @brief High counter value */
    static const int32_t G_TIM14_PSC_PSC_POS              = 0;    /** @brief Prescaler value */
    static const int32_t G_TIM14_ARR_ARR_H_POS            = 16;   /** @brief High auto-reload value */
    static const int32_t G_TIM14_ARR_ARR_L_POS            = 0;    /** @brief Low auto-reload value */
    static const int32_t G_TIM14_CCRx_CCR1_H_POS          = 16;   /** @brief High capture/compare 1 value */
    static const int32_t G_TIM14_CCRx_CCR1_L_POS          = 0;    /** @brief Low capture/compare 1 value */
    static const int32_t G_TIM14_DCR_DBL_POS              = 8;    /** @brief DMA burst length */
    static const int32_t G_TIM14_DCR_DBA_POS              = 0;    /** @brief DMA base address */
    static const int32_t G_TIM14_DMAR_DMAB_POS            = 0;    /** @brief DMA register for burst accesses */
    static const int32_t G_TIM14_AF1_ETRSEL_POS           = 14;   /** @brief ETR source selection */

    /**** @subsection Enumerated G_TIM14 Register Field Positions ****/

    static const int32_t G_TIM14_DIER_CCxDE_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
      [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
      [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
      [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t G_TIM14_DIER_CCxIE_POS[5] = {
      [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t G_TIM14_SR_CCxOF_POS[5] = {
      [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
      [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
      [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
      [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t G_TIM14_SR_CCxIF_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
      [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
      [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
      [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
    };

    static const int32_t G_TIM14_EGR_CCxG_POS[5] = {
      [1] = 1,   /** @brief Capture/compare 1 generation */
      [2] = 2,   /** @brief Capture/compare 2 generation */
      [3] = 3,   /** @brief Capture/compare 3 generation */
      [4] = 4,   /** @brief Capture/compare 4 generation */
    };

    static const int32_t G_TIM14_CCMR1_OUTPUT_CCxS_POS[3] = {
      [1] = 0,   /** @brief CC1S */
      [2] = 8,   /** @brief CC2S */
    };

    static const int32_t G_TIM14_CCMR1_OUTPUT_OCxFE_POS[3] = {
      [1] = 2,    /** @brief OC1FE */
      [2] = 10,   /** @brief OC2FE */
    };

    static const int32_t G_TIM14_CCMR1_OUTPUT_OCxPE_POS[3] = {
      [1] = 3,    /** @brief OC1PE */
      [2] = 11,   /** @brief OC2PE */
    };

    static const int32_t G_TIM14_CCMR1_OUTPUT_OCxM_POS[3] = {
      [1] = 4,    /** @brief OC1M */
      [2] = 12,   /** @brief OC2M */
    };

    static const int32_t G_TIM14_CCMR1_OUTPUT_OCxCE_POS[3] = {
      [1] = 7,    /** @brief OC1CE */
      [2] = 15,   /** @brief OC2CE */
    };

    static const int32_t G_TIM14_CCMR1_OUTPUT_OCxM_3_POS[3] = {
      [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
      [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
    };

    static const int32_t G_TIM14_CCMR1_INPUT_ICxF_POS[3] = {
      [1] = 4,    /** @brief Input capture 1 filter */
      [2] = 12,   /** @brief Input capture 2 filter */
    };

    static const int32_t G_TIM14_CCMR2_INPUT_ICxPSC_POS[5] = {
      [3] = 2,    /** @brief Input capture 3 prescaler */
      [4] = 10,   /** @brief Input capture 4 prescaler */
    };

    static const int32_t G_TIM14_CCER_CCxNP_POS[5] = {
      [1] = 3,    /** @brief Capture/Compare 1 output polarity */
      [2] = 7,    /** @brief Capture/Compare 2 output polarity */
      [3] = 11,   /** @brief Capture/Compare 3 output polarity */
      [4] = 15,   /** @brief Capture/Compare 4 output polarity */
    };

    static const int32_t G_TIM14_CCER_CCxP_POS[5] = {
      [1] = 1,    /** @brief Capture/Compare 1 output polarity */
      [2] = 5,    /** @brief Capture/Compare 2 output polarity */
      [3] = 9,    /** @brief Capture/Compare 3 output polarity */
      [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    };

    static const int32_t G_TIM14_CCER_CCxE_POS[5] = {
      [1] = 0,    /** @brief Capture/Compare 1 output enable */
      [2] = 4,    /** @brief Capture/Compare 2 output enable */
      [3] = 8,    /** @brief Capture/Compare 3 output enable */
      [4] = 12,   /** @brief Capture/Compare 4 output enable */
    };

    static const int32_t G_TIM14_TISEL_TIxSEL_POS[5] = {
      [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
      [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
      [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
      [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
    };

    /**********************************************************************************************
     * @section B_TIMx Register Information
     **********************************************************************************************/

    /**** @subsection Enumerated B_TIMx Register Pointers ****/

    static RW_ uint32_t* const B_TIMx_CR1_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x40001000U,   /** @brief Control register 1 */
      [7] = (RW_ uint32_t* const)0x40001400U,   /** @brief Control register 1 */
    };

    static RW_ uint32_t* const B_TIMx_CR2_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x40001004U,   /** @brief Control register 2 */
      [7] = (RW_ uint32_t* const)0x40001404U,   /** @brief Control register 2 */
    };

    static RW_ uint32_t* const B_TIMx_DIER_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x4000100CU,   /** @brief DMA/Interrupt enable register */
      [7] = (RW_ uint32_t* const)0x4000140CU,   /** @brief DMA/Interrupt enable register */
    };

    static RW_ uint32_t* const B_TIMx_SR_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x40001010U,   /** @brief Status register */
      [7] = (RW_ uint32_t* const)0x40001410U,   /** @brief Status register */
    };

    static RW_ uint32_t* const B_TIMx_EGR_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x40001014U,   /** @brief Event generation register */
      [7] = (RW_ uint32_t* const)0x40001414U,   /** @brief Event generation register */
    };

    static RW_ uint32_t* const B_TIMx_CNT_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x40001024U,   /** @brief Counter */
      [7] = (RW_ uint32_t* const)0x40001424U,   /** @brief Counter */
    };

    static RW_ uint32_t* const B_TIMx_PSC_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x40001028U,   /** @brief Prescaler */
      [7] = (RW_ uint32_t* const)0x40001428U,   /** @brief Prescaler */
    };

    static RW_ uint32_t* const B_TIMx_ARR_PTR[8] = {
      [6] = (RW_ uint32_t* const)0x4000102CU,   /** @brief Auto-reload register */
      [7] = (RW_ uint32_t* const)0x4000142CU,   /** @brief Auto-reload register */
    };

    /**** @subsection Enumerated B_TIMx Register Reset Values ****/

    static const uint32_t B_TIMx_CR1_RST[8] = {
      [6] = 0x00000000U,   /** @brief CR1 register reset value */
      [7] = 0x00000000U,   /** @brief CR1 register reset value */
    };

    static const uint32_t B_TIMx_CR2_RST[8] = {
      [6] = 0x00000000U,   /** @brief CR2 register reset value */
      [7] = 0x00000000U,   /** @brief CR2 register reset value */
    };

    static const uint32_t B_TIMx_DIER_RST[8] = {
      [6] = 0x00000000U,   /** @brief DIER register reset value */
      [7] = 0x00000000U,   /** @brief DIER register reset value */
    };

    static const uint32_t B_TIMx_SR_RST[8] = {
      [6] = 0x00000000U,   /** @brief SR register reset value */
      [7] = 0x00000000U,   /** @brief SR register reset value */
    };

    static const uint32_t B_TIMx_EGR_RST[8] = {
      [6] = 0x00000000U,   /** @brief EGR register reset value */
      [7] = 0x00000000U,   /** @brief EGR register reset value */
    };

    static const uint32_t B_TIMx_CNT_RST[8] = {
      [6] = 0x00000000U,   /** @brief CNT register reset value */
      [7] = 0x00000000U,   /** @brief CNT register reset value */
    };

    static const uint32_t B_TIMx_PSC_RST[8] = {
      [6] = 0x00000000U,   /** @brief PSC register reset value */
      [7] = 0x00000000U,   /** @brief PSC register reset value */
    };

    static const uint32_t B_TIMx_ARR_RST[8] = {
      [6] = 0x00000000U,   /** @brief ARR register reset value */
      [7] = 0x00000000U,   /** @brief ARR register reset value */
    };

    /**** @subsection Enumerated B_TIMx Register Value Types ****/

    typedef uint32_t B_TIMx_CR1_t;    /** @brief CR1 register value type. */
    typedef uint32_t B_TIMx_CR2_t;    /** @brief CR2 register value type. */
    typedef uint32_t B_TIMx_DIER_t;   /** @brief DIER register value type. */
    typedef uint32_t B_TIMx_SR_t;     /** @brief SR register value type. */
    typedef uint32_t B_TIMx_EGR_t;    /** @brief EGR register value type. */
    typedef uint32_t B_TIMx_CNT_t;    /** @brief CNT register value type. */
    typedef uint32_t B_TIMx_PSC_t;    /** @brief PSC register value type. */
    typedef uint32_t B_TIMx_ARR_t;    /** @brief ARR register value type. */

    /**** @subsection Enumerated B_TIMx Register Pointer Types ****/

    typedef uint32_t* const B_TIMx_CR1_PTR_t;    /** @brief CR1 register pointer type. */
    typedef uint32_t* const B_TIMx_CR2_PTR_t;    /** @brief CR2 register pointer type. */
    typedef uint32_t* const B_TIMx_DIER_PTR_t;   /** @brief DIER register pointer type. */
    typedef uint32_t* const B_TIMx_SR_PTR_t;     /** @brief SR register pointer type. */
    typedef uint32_t* const B_TIMx_EGR_PTR_t;    /** @brief EGR register pointer type. */
    typedef uint32_t* const B_TIMx_CNT_PTR_t;    /** @brief CNT register pointer type. */
    typedef uint32_t* const B_TIMx_PSC_PTR_t;    /** @brief PSC register pointer type. */
    typedef uint32_t* const B_TIMx_ARR_PTR_t;    /** @brief ARR register pointer type. */

    /**** @subsection B_TIMx Register Field Masks ****/

    static const uint32_t B_TIMx_CR1_UIFREMAP_MASK   = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t B_TIMx_CR1_ARPE_MASK       = 0x00000080U;   /** @brief Auto-reload preload enable */
    static const uint32_t B_TIMx_CR1_OPM_MASK        = 0x00000008U;   /** @brief One-pulse mode */
    static const uint32_t B_TIMx_CR1_URS_MASK        = 0x00000004U;   /** @brief Update request source */
    static const uint32_t B_TIMx_CR1_UDIS_MASK       = 0x00000002U;   /** @brief Update disable */
    static const uint32_t B_TIMx_CR1_CEN_MASK        = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t B_TIMx_CR2_MMS_MASK        = 0x00000070U;   /** @brief Master mode selection */
    static const uint32_t B_TIMx_DIER_UDE_MASK       = 0x00000100U;   /** @brief Update DMA request enable */
    static const uint32_t B_TIMx_DIER_UIE_MASK       = 0x00000001U;   /** @brief Update interrupt enable */
    static const uint32_t B_TIMx_SR_UIF_MASK         = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t B_TIMx_EGR_UG_MASK         = 0x00000001U;   /** @brief Update generation */
    static const uint32_t B_TIMx_CNT_CNT_MASK        = 0x0000FFFFU;   /** @brief Low counter value */
    static const uint32_t B_TIMx_CNT_UIFCPY_MASK     = 0x80000000U;   /** @brief UIF copy */
    static const uint32_t B_TIMx_PSC_PSC_MASK        = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t B_TIMx_ARR_ARR_MASK        = 0x0000FFFFU;   /** @brief Low auto-reload value */

    /**** @subsection B_TIMx Register Field Positions ****/

    static const int32_t B_TIMx_CR1_UIFREMAP_POS   = 11;   /** @brief UIF status bit remapping */
    static const int32_t B_TIMx_CR1_ARPE_POS       = 7;    /** @brief Auto-reload preload enable */
    static const int32_t B_TIMx_CR1_OPM_POS        = 3;    /** @brief One-pulse mode */
    static const int32_t B_TIMx_CR1_URS_POS        = 2;    /** @brief Update request source */
    static const int32_t B_TIMx_CR1_UDIS_POS       = 1;    /** @brief Update disable */
    static const int32_t B_TIMx_CR1_CEN_POS        = 0;    /** @brief Counter enable */
    static const int32_t B_TIMx_CR2_MMS_POS        = 4;    /** @brief Master mode selection */
    static const int32_t B_TIMx_DIER_UDE_POS       = 8;    /** @brief Update DMA request enable */
    static const int32_t B_TIMx_DIER_UIE_POS       = 0;    /** @brief Update interrupt enable */
    static const int32_t B_TIMx_SR_UIF_POS         = 0;    /** @brief Update interrupt flag */
    static const int32_t B_TIMx_EGR_UG_POS         = 0;    /** @brief Update generation */
    static const int32_t B_TIMx_CNT_CNT_POS        = 0;    /** @brief Low counter value */
    static const int32_t B_TIMx_CNT_UIFCPY_POS     = 31;   /** @brief UIF copy */
    static const int32_t B_TIMx_PSC_PSC_POS        = 0;    /** @brief Prescaler value */
    static const int32_t B_TIMx_ARR_ARR_POS        = 0;    /** @brief Low auto-reload value */

    /**********************************************************************************************
     * @section NVIC Register Information
     **********************************************************************************************/

    /**** @subsection NVIC Register Pointers ****/

    static RW_ uint32_t* const NVIC_ISER0_PTR   = (RW_ uint32_t* const)0xE000E100U;   /** @brief Interrupt set-enable register */
    static RW_ uint32_t* const NVIC_ISER1_PTR   = (RW_ uint32_t* const)0xE000E104U;   /** @brief Interrupt set-enable register */
    static RW_ uint32_t* const NVIC_ISER2_PTR   = (RW_ uint32_t* const)0xE000E108U;   /** @brief Interrupt set-enable register */
    static RW_ uint32_t* const NVIC_ICER0_PTR   = (RW_ uint32_t* const)0xE000E180U;   /** @brief Interrupt clear-enable register */
    static RW_ uint32_t* const NVIC_ICER1_PTR   = (RW_ uint32_t* const)0xE000E184U;   /** @brief Interrupt clear-enable register */
    static RW_ uint32_t* const NVIC_ICER2_PTR   = (RW_ uint32_t* const)0xE000E188U;   /** @brief Interrupt clear-enable register */
    static RW_ uint32_t* const NVIC_ISPR0_PTR   = (RW_ uint32_t* const)0xE000E200U;   /** @brief Interrupt set-pending register */
    static RW_ uint32_t* const NVIC_ISPR1_PTR   = (RW_ uint32_t* const)0xE000E204U;   /** @brief Interrupt set-pending register */
    static RW_ uint32_t* const NVIC_ISPR2_PTR   = (RW_ uint32_t* const)0xE000E208U;   /** @brief Interrupt set-pending register */
    static RW_ uint32_t* const NVIC_ICPR0_PTR   = (RW_ uint32_t* const)0xE000E280U;   /** @brief Interrupt clear-pending register */
    static RW_ uint32_t* const NVIC_ICPR1_PTR   = (RW_ uint32_t* const)0xE000E284U;   /** @brief Interrupt clear-pending register */
    static RW_ uint32_t* const NVIC_ICPR2_PTR   = (RW_ uint32_t* const)0xE000E288U;   /** @brief Interrupt clear-pending register */
    static RO_ uint32_t* const NVIC_IABR0_PTR   = (RO_ uint32_t* const)0xE000E300U;   /** @brief Interrupt active bit register */
    static RO_ uint32_t* const NVIC_IABR1_PTR   = (RO_ uint32_t* const)0xE000E304U;   /** @brief Interrupt active bit register */
    static RO_ uint32_t* const NVIC_IABR2_PTR   = (RO_ uint32_t* const)0xE000E308U;   /** @brief Interrupt active bit register */
    static RW_ uint32_t* const NVIC_ISER3_PTR   = (RW_ uint32_t* const)0xE000E10CU;   /** @brief Interrupt set-enable register */
    static RW_ uint32_t* const NVIC_ICER3_PTR   = (RW_ uint32_t* const)0xE000E18CU;   /** @brief Interrupt clear-enable register */
    static RW_ uint32_t* const NVIC_ISPR3_PTR   = (RW_ uint32_t* const)0xE000E20CU;   /** @brief Interrupt set-pending register */
    static RW_ uint32_t* const NVIC_ICPR3_PTR   = (RW_ uint32_t* const)0xE000E2C0U;   /** @brief Interrupt clear-pending register */
    static RW_ uint32_t* const NVIC_IABR3_PTR   = (RW_ uint32_t* const)0xE000E30CU;   /** @brief Interrupt active bit register */

    /**** @subsection Enumerated NVIC Register Pointers ****/

    static RW_ uint32_t* const NVIC_IPRx_PTR[39] = {
      [0]  = (RW_ uint32_t* const)0xE000E400U,   /** @brief Interrupt priority register */
      [1]  = (RW_ uint32_t* const)0xE000E404U,   /** @brief Interrupt priority register */
      [2]  = (RW_ uint32_t* const)0xE000E408U,   /** @brief Interrupt priority register */
      [3]  = (RW_ uint32_t* const)0xE000E40CU,   /** @brief Interrupt priority register */
      [4]  = (RW_ uint32_t* const)0xE000E410U,   /** @brief Interrupt priority register */
      [5]  = (RW_ uint32_t* const)0xE000E414U,   /** @brief Interrupt priority register */
      [6]  = (RW_ uint32_t* const)0xE000E418U,   /** @brief Interrupt priority register */
      [7]  = (RW_ uint32_t* const)0xE000E41CU,   /** @brief Interrupt priority register */
      [8]  = (RW_ uint32_t* const)0xE000E420U,   /** @brief Interrupt priority register */
      [9]  = (RW_ uint32_t* const)0xE000E424U,   /** @brief Interrupt priority register */
      [10] = (RW_ uint32_t* const)0xE000E428U,   /** @brief Interrupt priority register */
      [11] = (RW_ uint32_t* const)0xE000E42CU,   /** @brief Interrupt priority register */
      [12] = (RW_ uint32_t* const)0xE000E430U,   /** @brief Interrupt priority register */
      [13] = (RW_ uint32_t* const)0xE000E434U,   /** @brief Interrupt priority register */
      [14] = (RW_ uint32_t* const)0xE000E438U,   /** @brief Interrupt priority register */
      [15] = (RW_ uint32_t* const)0xE000E43CU,   /** @brief Interrupt priority register */
      [16] = (RW_ uint32_t* const)0xE000E440U,   /** @brief Interrupt priority register */
      [17] = (RW_ uint32_t* const)0xE000E444U,   /** @brief Interrupt priority register */
      [18] = (RW_ uint32_t* const)0xE000E448U,   /** @brief Interrupt priority register */
      [19] = (RW_ uint32_t* const)0xE000E44CU,   /** @brief Interrupt priority register */
      [20] = (RW_ uint32_t* const)0xE000E450U,   /** @brief Interrupt priority register */
      [21] = (RW_ uint32_t* const)0xE000E454U,   /** @brief Interrupt priority register */
      [22] = (RW_ uint32_t* const)0xE000E458U,   /** @brief Interrupt priority register */
      [23] = (RW_ uint32_t* const)0xE000E45CU,   /** @brief Interrupt priority register */
      [24] = (RW_ uint32_t* const)0xE000E460U,   /** @brief Interrupt priority register */
      [25] = (RW_ uint32_t* const)0xE000E464U,   /** @brief Interrupt priority register */
      [26] = (RW_ uint32_t* const)0xE000E468U,   /** @brief Interrupt priority register */
      [27] = (RW_ uint32_t* const)0xE000E46CU,   /** @brief Interrupt priority register */
      [28] = (RW_ uint32_t* const)0xE000E470U,   /** @brief Interrupt priority register */
      [29] = (RW_ uint32_t* const)0xE000E474U,   /** @brief Interrupt priority register */
      [30] = (RW_ uint32_t* const)0xE000E478U,   /** @brief Interrupt priority register */
      [31] = (RW_ uint32_t* const)0xE000E47CU,   /** @brief Interrupt priority register */
      [32] = (RW_ uint32_t* const)0xE000E480U,   /** @brief Interrupt priority register */
      [33] = (RW_ uint32_t* const)0xE000E484U,   /** @brief Interrupt priority register */
      [34] = (RW_ uint32_t* const)0xE000E488U,   /** @brief Interrupt priority register */
      [35] = (RW_ uint32_t* const)0xE000E48CU,   /** @brief Interrupt priority register */
      [36] = (RW_ uint32_t* const)0xE000E490U,   /** @brief Interrupt priority register */
      [37] = (RW_ uint32_t* const)0xE000E494U,   /** @brief Interrupt priority register */
      [38] = (RW_ uint32_t* const)0xE000E498U,   /** @brief Interrupt priority register */
    };

    /**** @subsection NVIC Register Reset Values ****/

    static const uint32_t NVIC_ISER0_RST   = 0x00000000U;   /** @brief ISER0 register reset value. */
    static const uint32_t NVIC_ISER1_RST   = 0x00000000U;   /** @brief ISER1 register reset value. */
    static const uint32_t NVIC_ISER2_RST   = 0x00000000U;   /** @brief ISER2 register reset value. */
    static const uint32_t NVIC_ICER0_RST   = 0x00000000U;   /** @brief ICER0 register reset value. */
    static const uint32_t NVIC_ICER1_RST   = 0x00000000U;   /** @brief ICER1 register reset value. */
    static const uint32_t NVIC_ICER2_RST   = 0x00000000U;   /** @brief ICER2 register reset value. */
    static const uint32_t NVIC_ISPR0_RST   = 0x00000000U;   /** @brief ISPR0 register reset value. */
    static const uint32_t NVIC_ISPR1_RST   = 0x00000000U;   /** @brief ISPR1 register reset value. */
    static const uint32_t NVIC_ISPR2_RST   = 0x00000000U;   /** @brief ISPR2 register reset value. */
    static const uint32_t NVIC_ICPR0_RST   = 0x00000000U;   /** @brief ICPR0 register reset value. */
    static const uint32_t NVIC_ICPR1_RST   = 0x00000000U;   /** @brief ICPR1 register reset value. */
    static const uint32_t NVIC_ICPR2_RST   = 0x00000000U;   /** @brief ICPR2 register reset value. */
    static const uint32_t NVIC_IABR0_RST   = 0x00000000U;   /** @brief IABR0 register reset value. */
    static const uint32_t NVIC_IABR1_RST   = 0x00000000U;   /** @brief IABR1 register reset value. */
    static const uint32_t NVIC_IABR2_RST   = 0x00000000U;   /** @brief IABR2 register reset value. */
    static const uint32_t NVIC_ISER3_RST   = 0x00000000U;   /** @brief ISER3 register reset value. */
    static const uint32_t NVIC_ICER3_RST   = 0x00000000U;   /** @brief ICER3 register reset value. */
    static const uint32_t NVIC_ISPR3_RST   = 0x00000000U;   /** @brief ISPR3 register reset value. */
    static const uint32_t NVIC_ICPR3_RST   = 0x00000000U;   /** @brief ICPR3 register reset value. */
    static const uint32_t NVIC_IABR3_RST   = 0x00000000U;   /** @brief IABR3 register reset value. */

    /**** @subsection Enumerated NVIC Register Reset Values ****/

    static const uint32_t NVIC_IPRx_RST[39] = {
      [0]  = 0x00000000U,   /** @brief IPR0 register reset value. */
      [1]  = 0x00000000U,   /** @brief IPR1 register reset value. */
      [2]  = 0x00000000U,   /** @brief IPR2 register reset value. */
      [3]  = 0x00000000U,   /** @brief IPR3 register reset value. */
      [4]  = 0x00000000U,   /** @brief IPR4 register reset value. */
      [5]  = 0x00000000U,   /** @brief IPR5 register reset value. */
      [6]  = 0x00000000U,   /** @brief IPR6 register reset value. */
      [7]  = 0x00000000U,   /** @brief IPR7 register reset value. */
      [8]  = 0x00000000U,   /** @brief IPR8 register reset value. */
      [9]  = 0x00000000U,   /** @brief IPR9 register reset value. */
      [10] = 0x00000000U,   /** @brief IPR10 register reset value. */
      [11] = 0x00000000U,   /** @brief IPR11 register reset value. */
      [12] = 0x00000000U,   /** @brief IPR12 register reset value. */
      [13] = 0x00000000U,   /** @brief IPR13 register reset value. */
      [14] = 0x00000000U,   /** @brief IPR14 register reset value. */
      [15] = 0x00000000U,   /** @brief IPR15 register reset value. */
      [16] = 0x00000000U,   /** @brief IPR16 register reset value. */
      [17] = 0x00000000U,   /** @brief IPR17 register reset value. */
      [18] = 0x00000000U,   /** @brief IPR18 register reset value. */
      [19] = 0x00000000U,   /** @brief IPR19 register reset value. */
      [20] = 0x00000000U,   /** @brief IPR20 register reset value. */
      [21] = 0x00000000U,   /** @brief IPR21 register reset value. */
      [22] = 0x00000000U,   /** @brief IPR22 register reset value. */
      [23] = 0x00000000U,   /** @brief IPR23 register reset value. */
      [24] = 0x00000000U,   /** @brief IPR24 register reset value. */
      [25] = 0x00000000U,   /** @brief IPR25 register reset value. */
      [26] = 0x00000000U,   /** @brief IPR26 register reset value. */
      [27] = 0x00000000U,   /** @brief IPR27 register reset value. */
      [28] = 0x00000000U,   /** @brief IPR28 register reset value. */
      [29] = 0x00000000U,   /** @brief IPR29 register reset value. */
      [30] = 0x00000000U,   /** @brief IPR30 register reset value. */
      [31] = 0x00000000U,   /** @brief IPR31 register reset value. */
      [32] = 0x00000000U,   /** @brief IPR32 register reset value. */
      [33] = 0x00000000U,   /** @brief IPR33 register reset value. */
      [34] = 0x00000000U,   /** @brief IPR34 register reset value. */
      [35] = 0x00000000U,   /** @brief IPR35 register reset value. */
      [36] = 0x00000000U,   /** @brief IPR36 register reset value. */
      [37] = 0x00000000U,   /** @brief IPR37 register reset value. */
      [38] = 0x00000000U,   /** @brief IPR38 register reset value. */
    };

    /**** @subsection Enumerated NVIC Register Value Types ****/

    typedef uint32_t NVIC_ISER0_t;   /** @brief ISER0 register value type. */
    typedef uint32_t NVIC_ISER1_t;   /** @brief ISER1 register value type. */
    typedef uint32_t NVIC_ISER2_t;   /** @brief ISER2 register value type. */
    typedef uint32_t NVIC_ICER0_t;   /** @brief ICER0 register value type. */
    typedef uint32_t NVIC_ICER1_t;   /** @brief ICER1 register value type. */
    typedef uint32_t NVIC_ICER2_t;   /** @brief ICER2 register value type. */
    typedef uint32_t NVIC_ISPR0_t;   /** @brief ISPR0 register value type. */
    typedef uint32_t NVIC_ISPR1_t;   /** @brief ISPR1 register value type. */
    typedef uint32_t NVIC_ISPR2_t;   /** @brief ISPR2 register value type. */
    typedef uint32_t NVIC_ICPR0_t;   /** @brief ICPR0 register value type. */
    typedef uint32_t NVIC_ICPR1_t;   /** @brief ICPR1 register value type. */
    typedef uint32_t NVIC_ICPR2_t;   /** @brief ICPR2 register value type. */
    typedef uint32_t NVIC_IABR0_t;   /** @brief IABR0 register value type. */
    typedef uint32_t NVIC_IABR1_t;   /** @brief IABR1 register value type. */
    typedef uint32_t NVIC_IABR2_t;   /** @brief IABR2 register value type. */
    typedef uint32_t NVIC_IPRx_t;    /** @brief IPRx register value type. */
    typedef uint32_t NVIC_ISER3_t;   /** @brief ISER3 register value type. */
    typedef uint32_t NVIC_ICER3_t;   /** @brief ICER3 register value type. */
    typedef uint32_t NVIC_ISPR3_t;   /** @brief ISPR3 register value type. */
    typedef uint32_t NVIC_ICPR3_t;   /** @brief ICPR3 register value type. */
    typedef uint32_t NVIC_IABR3_t;   /** @brief IABR3 register value type. */

    /**** @subsection Enumerated NVIC Register Pointer Types ****/

    typedef uint32_t* const NVIC_ISER0_PTR_t;   /** @brief ISER0 register pointer type. */
    typedef uint32_t* const NVIC_ISER1_PTR_t;   /** @brief ISER1 register pointer type. */
    typedef uint32_t* const NVIC_ISER2_PTR_t;   /** @brief ISER2 register pointer type. */
    typedef uint32_t* const NVIC_ICER0_PTR_t;   /** @brief ICER0 register pointer type. */
    typedef uint32_t* const NVIC_ICER1_PTR_t;   /** @brief ICER1 register pointer type. */
    typedef uint32_t* const NVIC_ICER2_PTR_t;   /** @brief ICER2 register pointer type. */
    typedef uint32_t* const NVIC_ISPR0_PTR_t;   /** @brief ISPR0 register pointer type. */
    typedef uint32_t* const NVIC_ISPR1_PTR_t;   /** @brief ISPR1 register pointer type. */
    typedef uint32_t* const NVIC_ISPR2_PTR_t;   /** @brief ISPR2 register pointer type. */
    typedef uint32_t* const NVIC_ICPR0_PTR_t;   /** @brief ICPR0 register pointer type. */
    typedef uint32_t* const NVIC_ICPR1_PTR_t;   /** @brief ICPR1 register pointer type. */
    typedef uint32_t* const NVIC_ICPR2_PTR_t;   /** @brief ICPR2 register pointer type. */
    typedef uint32_t* const NVIC_IABR0_PTR_t;   /** @brief IABR0 register pointer type. */
    typedef uint32_t* const NVIC_IABR1_PTR_t;   /** @brief IABR1 register pointer type. */
    typedef uint32_t* const NVIC_IABR2_PTR_t;   /** @brief IABR2 register pointer type. */
    typedef uint32_t* const NVIC_IPRx_PTR_t;    /** @brief IPRx register pointer type. */
    typedef uint32_t* const NVIC_ISER3_PTR_t;   /** @brief ISER3 register pointer type. */
    typedef uint32_t* const NVIC_ICER3_PTR_t;   /** @brief ICER3 register pointer type. */
    typedef uint32_t* const NVIC_ISPR3_PTR_t;   /** @brief ISPR3 register pointer type. */
    typedef uint32_t* const NVIC_ICPR3_PTR_t;   /** @brief ICPR3 register pointer type. */
    typedef uint32_t* const NVIC_IABR3_PTR_t;   /** @brief IABR3 register pointer type. */

    /**** @subsection Enumerated NVIC Register Field Masks ****/

    static const uint32_t NVIC_IPRx_IPR_Nx_MASK[4] = {
      [0] = 0x000000FFU,   /** @brief IPR_N0 */
      [1] = 0x0000FF00U,   /** @brief IPR_N1 */
      [2] = 0x00FF0000U,   /** @brief IPR_N2 */
      [3] = 0xFF000000U,   /** @brief IPR_N3 */
    };

    /**** @subsection Enumerated NVIC Register Field Positions ****/

    static const int32_t NVIC_IPRx_IPR_Nx_POS[4] = {
      [0] = 0,    /** @brief IPR_N0 */
      [1] = 8,    /** @brief IPR_N1 */
      [2] = 16,   /** @brief IPR_N2 */
      [3] = 24,   /** @brief IPR_N3 */
    };

    /**********************************************************************************************
     * @section MPU Register Information
     **********************************************************************************************/

    /**** @subsection MPU Register Pointers ****/

    static RO_ uint32_t* const MPU_MPU_TYPER_PTR   = (RO_ uint32_t* const)0xE000ED90U;   /** @brief MPU type register */
    static RO_ uint32_t* const MPU_MPU_CTRL_PTR    = (RO_ uint32_t* const)0xE000ED94U;   /** @brief MPU control register */
    static RW_ uint32_t* const MPU_MPU_RNR_PTR     = (RW_ uint32_t* const)0xE000ED98U;   /** @brief MPU region number register */
    static RW_ uint32_t* const MPU_MPU_RBAR_PTR    = (RW_ uint32_t* const)0xE000ED9CU;   /** @brief MPU region base address register */
    static RW_ uint32_t* const MPU_MPU_RASR_PTR    = (RW_ uint32_t* const)0xE000EDA0U;   /** @brief MPU region attribute and size register */

    /**** @subsection MPU Register Reset Values ****/

    static const uint32_t MPU_MPU_TYPER_RST   = 0x00000800U;   /** @brief MPU_TYPER register reset value. */
    static const uint32_t MPU_MPU_CTRL_RST    = 0x00000000U;   /** @brief MPU_CTRL register reset value. */
    static const uint32_t MPU_MPU_RNR_RST     = 0x00000000U;   /** @brief MPU_RNR register reset value. */
    static const uint32_t MPU_MPU_RBAR_RST    = 0x00000000U;   /** @brief MPU_RBAR register reset value. */
    static const uint32_t MPU_MPU_RASR_RST    = 0x00000000U;   /** @brief MPU_RASR register reset value. */

    /**** @subsection Enumerated MPU Register Value Types ****/

    typedef uint32_t MPU_MPU_TYPER_t;   /** @brief MPU_TYPER register value type. */
    typedef uint32_t MPU_MPU_CTRL_t;    /** @brief MPU_CTRL register value type. */
    typedef uint32_t MPU_MPU_RNR_t;     /** @brief MPU_RNR register value type. */
    typedef uint32_t MPU_MPU_RBAR_t;    /** @brief MPU_RBAR register value type. */
    typedef uint32_t MPU_MPU_RASR_t;    /** @brief MPU_RASR register value type. */

    /**** @subsection Enumerated MPU Register Pointer Types ****/

    typedef uint32_t* const MPU_MPU_TYPER_PTR_t;   /** @brief MPU_TYPER register pointer type. */
    typedef uint32_t* const MPU_MPU_CTRL_PTR_t;    /** @brief MPU_CTRL register pointer type. */
    typedef uint32_t* const MPU_MPU_RNR_PTR_t;     /** @brief MPU_RNR register pointer type. */
    typedef uint32_t* const MPU_MPU_RBAR_PTR_t;    /** @brief MPU_RBAR register pointer type. */
    typedef uint32_t* const MPU_MPU_RASR_PTR_t;    /** @brief MPU_RASR register pointer type. */

    /**** @subsection MPU Register Field Masks ****/

    static const uint32_t MPU_MPU_TYPER_SEPARATE_MASK    = 0x00000001U;   /** @brief Separate flag */
    static const uint32_t MPU_MPU_TYPER_DREGION_MASK     = 0x0000FF00U;   /** @brief Number of MPU data regions */
    static const uint32_t MPU_MPU_TYPER_IREGION_MASK     = 0x00FF0000U;   /** @brief Number of MPU instruction regions */
    static const uint32_t MPU_MPU_CTRL_ENABLE_MASK       = 0x00000001U;   /** @brief Enables the MPU */
    static const uint32_t MPU_MPU_CTRL_HFNMIENA_MASK     = 0x00000002U;   /** @brief Enables the operation of MPU during hard fault */
    static const uint32_t MPU_MPU_CTRL_PRIVDEFENA_MASK   = 0x00000004U;   /** @brief Enable priviliged software access to default memory map */
    static const uint32_t MPU_MPU_RNR_REGION_MASK        = 0x000000FFU;   /** @brief MPU region */
    static const uint32_t MPU_MPU_RBAR_REGION_MASK       = 0x0000000FU;   /** @brief MPU region field */
    static const uint32_t MPU_MPU_RBAR_VALID_MASK        = 0x00000010U;   /** @brief MPU region number valid */
    static const uint32_t MPU_MPU_RBAR_ADDR_MASK         = 0xFFFFFFE0U;   /** @brief Region base address field */
    static const uint32_t MPU_MPU_RASR_ENABLE_MASK       = 0x00000001U;   /** @brief Region enable bit. */
    static const uint32_t MPU_MPU_RASR_SIZE_MASK         = 0x0000003EU;   /** @brief Size of the MPU protection region */
    static const uint32_t MPU_MPU_RASR_SRD_MASK          = 0x0000FF00U;   /** @brief Subregion disable bits */
    static const uint32_t MPU_MPU_RASR_B_MASK            = 0x00010000U;   /** @brief Memory attribute */
    static const uint32_t MPU_MPU_RASR_C_MASK            = 0x00020000U;   /** @brief Memory attribute */
    static const uint32_t MPU_MPU_RASR_S_MASK            = 0x00040000U;   /** @brief Shareable memory attribute */
    static const uint32_t MPU_MPU_RASR_TEX_MASK          = 0x00380000U;   /** @brief Memory attribute */
    static const uint32_t MPU_MPU_RASR_AP_MASK           = 0x07000000U;   /** @brief Access permission */
    static const uint32_t MPU_MPU_RASR_XN_MASK           = 0x10000000U;   /** @brief Instruction access disable bit */

    /**** @subsection MPU Register Field Positions ****/

    static const int32_t MPU_MPU_TYPER_SEPARATE_POS    = 0;    /** @brief Separate flag */
    static const int32_t MPU_MPU_TYPER_DREGION_POS     = 8;    /** @brief Number of MPU data regions */
    static const int32_t MPU_MPU_TYPER_IREGION_POS     = 16;   /** @brief Number of MPU instruction regions */
    static const int32_t MPU_MPU_CTRL_ENABLE_POS       = 0;    /** @brief Enables the MPU */
    static const int32_t MPU_MPU_CTRL_HFNMIENA_POS     = 1;    /** @brief Enables the operation of MPU during hard fault */
    static const int32_t MPU_MPU_CTRL_PRIVDEFENA_POS   = 2;    /** @brief Enable priviliged software access to default memory map */
    static const int32_t MPU_MPU_RNR_REGION_POS        = 0;    /** @brief MPU region */
    static const int32_t MPU_MPU_RBAR_REGION_POS       = 0;    /** @brief MPU region field */
    static const int32_t MPU_MPU_RBAR_VALID_POS        = 4;    /** @brief MPU region number valid */
    static const int32_t MPU_MPU_RBAR_ADDR_POS         = 5;    /** @brief Region base address field */
    static const int32_t MPU_MPU_RASR_ENABLE_POS       = 0;    /** @brief Region enable bit. */
    static const int32_t MPU_MPU_RASR_SIZE_POS         = 1;    /** @brief Size of the MPU protection region */
    static const int32_t MPU_MPU_RASR_SRD_POS          = 8;    /** @brief Subregion disable bits */
    static const int32_t MPU_MPU_RASR_B_POS            = 16;   /** @brief Memory attribute */
    static const int32_t MPU_MPU_RASR_C_POS            = 17;   /** @brief Memory attribute */
    static const int32_t MPU_MPU_RASR_S_POS            = 18;   /** @brief Shareable memory attribute */
    static const int32_t MPU_MPU_RASR_TEX_POS          = 19;   /** @brief Memory attribute */
    static const int32_t MPU_MPU_RASR_AP_POS           = 24;   /** @brief Access permission */
    static const int32_t MPU_MPU_RASR_XN_POS           = 28;   /** @brief Instruction access disable bit */

    /**********************************************************************************************
     * @section STK Register Information
     **********************************************************************************************/

    /**** @subsection STK Register Pointers ****/

    static RW_ uint32_t* const STK_CSR_PTR     = (RW_ uint32_t* const)0xE000E010U;   /** @brief SysTick control and status register */
    static RW_ uint32_t* const STK_RVR_PTR     = (RW_ uint32_t* const)0xE000E014U;   /** @brief SysTick reload value register */
    static RW_ uint32_t* const STK_CVR_PTR     = (RW_ uint32_t* const)0xE000E018U;   /** @brief SysTick current value register */
    static RW_ uint32_t* const STK_CALIB_PTR   = (RW_ uint32_t* const)0xE000E01CU;   /** @brief SysTick calibration value register */

    /**** @subsection STK Register Reset Values ****/

    static const uint32_t STK_CSR_RST     = 0x00000000U;   /** @brief CSR register reset value. */
    static const uint32_t STK_RVR_RST     = 0x00000000U;   /** @brief RVR register reset value. */
    static const uint32_t STK_CVR_RST     = 0x00000000U;   /** @brief CVR register reset value. */
    static const uint32_t STK_CALIB_RST   = 0x00000000U;   /** @brief CALIB register reset value. */

    /**** @subsection Enumerated STK Register Value Types ****/

    typedef uint32_t STK_CSR_t;     /** @brief CSR register value type. */
    typedef uint32_t STK_RVR_t;     /** @brief RVR register value type. */
    typedef uint32_t STK_CVR_t;     /** @brief CVR register value type. */
    typedef uint32_t STK_CALIB_t;   /** @brief CALIB register value type. */

    /**** @subsection Enumerated STK Register Pointer Types ****/

    typedef uint32_t* const STK_CSR_PTR_t;     /** @brief CSR register pointer type. */
    typedef uint32_t* const STK_RVR_PTR_t;     /** @brief RVR register pointer type. */
    typedef uint32_t* const STK_CVR_PTR_t;     /** @brief CVR register pointer type. */
    typedef uint32_t* const STK_CALIB_PTR_t;   /** @brief CALIB register pointer type. */

    /**** @subsection STK Register Field Masks ****/

    static const uint32_t STK_CSR_ENABLE_MASK      = 0x00000001U;   /** @brief Counter enable */
    static const uint32_t STK_CSR_TICKINT_MASK     = 0x00000002U;   /** @brief SysTick exception request enable */
    static const uint32_t STK_CSR_CLKSOURCE_MASK   = 0x00000004U;   /** @brief Clock source selection */
    static const uint32_t STK_CSR_COUNTFLAG_MASK   = 0x00010000U;   /** @brief COUNTFLAG */
    static const uint32_t STK_RVR_RELOAD_MASK      = 0x00FFFFFFU;   /** @brief RELOAD value */
    static const uint32_t STK_CVR_CURRENT_MASK     = 0x00FFFFFFU;   /** @brief Current counter value */
    static const uint32_t STK_CALIB_TENMS_MASK     = 0x00FFFFFFU;   /** @brief Calibration value */
    static const uint32_t STK_CALIB_SKEW_MASK      = 0x40000000U;   /** @brief SKEW flag: indicates whether the TENMS value is exact */
    static const uint32_t STK_CALIB_NOREF_MASK     = 0x80000000U;   /** @brief NOREF flag. Reads as zero */

    /**** @subsection STK Register Field Positions ****/

    static const int32_t STK_CSR_ENABLE_POS      = 0;    /** @brief Counter enable */
    static const int32_t STK_CSR_TICKINT_POS     = 1;    /** @brief SysTick exception request enable */
    static const int32_t STK_CSR_CLKSOURCE_POS   = 2;    /** @brief Clock source selection */
    static const int32_t STK_CSR_COUNTFLAG_POS   = 16;   /** @brief COUNTFLAG */
    static const int32_t STK_RVR_RELOAD_POS      = 0;    /** @brief RELOAD value */
    static const int32_t STK_CVR_CURRENT_POS     = 0;    /** @brief Current counter value */
    static const int32_t STK_CALIB_TENMS_POS     = 0;    /** @brief Calibration value */
    static const int32_t STK_CALIB_SKEW_POS      = 30;   /** @brief SKEW flag: indicates whether the TENMS value is exact */
    static const int32_t STK_CALIB_NOREF_POS     = 31;   /** @brief NOREF flag. Reads as zero */

    /**********************************************************************************************
     * @section NVIC_STIR Register Information
     **********************************************************************************************/

    /**** @subsection NVIC_STIR Register Pointers ****/

    static RW_ uint32_t* const NVIC_STIR_STIR_PTR   = (RW_ uint32_t* const)0xE000EF00U;   /** @brief Software trigger interrupt register */

    /**** @subsection NVIC_STIR Register Reset Values ****/

    static const uint32_t NVIC_STIR_STIR_RST   = 0x00000000U;   /** @brief STIR register reset value. */

    /**** @subsection Enumerated NVIC_STIR Register Value Types ****/

    typedef uint32_t NVIC_STIR_STIR_t;   /** @brief STIR register value type. */

    /**** @subsection Enumerated NVIC_STIR Register Pointer Types ****/

    typedef uint32_t* const NVIC_STIR_STIR_PTR_t;   /** @brief STIR register pointer type. */

    /**** @subsection NVIC_STIR Register Field Masks ****/

    static const uint32_t NVIC_STIR_STIR_INTID_MASK   = 0x000001FFU;   /** @brief Software generated interrupt ID */

    /**** @subsection NVIC_STIR Register Field Positions ****/

    static const int32_t NVIC_STIR_STIR_INTID_POS   = 0;   /** @brief Software generated interrupt ID */

    /**********************************************************************************************
     * @section FPU_CPACR Register Information
     **********************************************************************************************/

    /**** @subsection FPU_CPACR Register Pointers ****/

    static RW_ uint32_t* const FPU_CPACR_CPACR_PTR   = (RW_ uint32_t* const)0xE000ED88U;   /** @brief Coprocessor access control register */

    /**** @subsection FPU_CPACR Register Reset Values ****/

    static const uint32_t FPU_CPACR_CPACR_RST   = 0x00000000U;   /** @brief CPACR register reset value. */

    /**** @subsection Enumerated FPU_CPACR Register Value Types ****/

    typedef uint32_t FPU_CPACR_CPACR_t;   /** @brief CPACR register value type. */

    /**** @subsection Enumerated FPU_CPACR Register Pointer Types ****/

    typedef uint32_t* const FPU_CPACR_CPACR_PTR_t;   /** @brief CPACR register pointer type. */

    /**** @subsection FPU_CPACR Register Field Masks ****/

    static const uint32_t FPU_CPACR_CPACR_CP_MASK   = 0x00F00000U;   /** @brief CP */

    /**** @subsection FPU_CPACR Register Field Positions ****/

    static const int32_t FPU_CPACR_CPACR_CP_POS   = 20;   /** @brief CP */

    /**********************************************************************************************
     * @section SCB_ACTRL Register Information
     **********************************************************************************************/

    /**** @subsection SCB_ACTRL Register Pointers ****/

    static RW_ uint32_t* const SCB_ACTRL_ACTRL_PTR   = (RW_ uint32_t* const)0xE000E008U;   /** @brief Auxiliary control register */

    /**** @subsection SCB_ACTRL Register Reset Values ****/

    static const uint32_t SCB_ACTRL_ACTRL_RST   = 0x00000000U;   /** @brief ACTRL register reset value. */

    /**** @subsection Enumerated SCB_ACTRL Register Value Types ****/

    typedef uint32_t SCB_ACTRL_ACTRL_t;   /** @brief ACTRL register value type. */

    /**** @subsection Enumerated SCB_ACTRL Register Pointer Types ****/

    typedef uint32_t* const SCB_ACTRL_ACTRL_PTR_t;   /** @brief ACTRL register pointer type. */

    /**** @subsection SCB_ACTRL Register Field Masks ****/

    static const uint32_t SCB_ACTRL_ACTRL_DISFOLD_MASK          = 0x00000004U;   /** @brief DISFOLD */
    static const uint32_t SCB_ACTRL_ACTRL_FPEXCODIS_MASK        = 0x00000400U;   /** @brief FPEXCODIS */
    static const uint32_t SCB_ACTRL_ACTRL_DISRAMODE_MASK        = 0x00000800U;   /** @brief DISRAMODE */
    static const uint32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH_MASK   = 0x00001000U;   /** @brief DISITMATBFLUSH */

    /**** @subsection SCB_ACTRL Register Field Positions ****/

    static const int32_t SCB_ACTRL_ACTRL_DISFOLD_POS          = 2;    /** @brief DISFOLD */
    static const int32_t SCB_ACTRL_ACTRL_FPEXCODIS_POS        = 10;   /** @brief FPEXCODIS */
    static const int32_t SCB_ACTRL_ACTRL_DISRAMODE_POS        = 11;   /** @brief DISRAMODE */
    static const int32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH_POS   = 12;   /** @brief DISITMATBFLUSH */

    /**********************************************************************************************
     * @section FPU Register Information
     **********************************************************************************************/

    /**** @subsection FPU Register Pointers ****/

    static RW_ uint32_t* const FPU_FPCCR_PTR   = (RW_ uint32_t* const)0xE000EF34U;   /** @brief Floating-point context control register */
    static RW_ uint32_t* const FPU_FPCAR_PTR   = (RW_ uint32_t* const)0xE000EF38U;   /** @brief Floating-point context address register */
    static RW_ uint32_t* const FPU_FPSCR_PTR   = (RW_ uint32_t* const)0xE000EF3CU;   /** @brief Floating-point status control register */

    /**** @subsection FPU Register Reset Values ****/

    static const uint32_t FPU_FPCCR_RST   = 0x00000000U;   /** @brief FPCCR register reset value. */
    static const uint32_t FPU_FPCAR_RST   = 0x00000000U;   /** @brief FPCAR register reset value. */
    static const uint32_t FPU_FPSCR_RST   = 0x00000000U;   /** @brief FPSCR register reset value. */

    /**** @subsection Enumerated FPU Register Value Types ****/

    typedef uint32_t FPU_FPCCR_t;   /** @brief FPCCR register value type. */
    typedef uint32_t FPU_FPCAR_t;   /** @brief FPCAR register value type. */
    typedef uint32_t FPU_FPSCR_t;   /** @brief FPSCR register value type. */

    /**** @subsection Enumerated FPU Register Pointer Types ****/

    typedef uint32_t* const FPU_FPCCR_PTR_t;   /** @brief FPCCR register pointer type. */
    typedef uint32_t* const FPU_FPCAR_PTR_t;   /** @brief FPCAR register pointer type. */
    typedef uint32_t* const FPU_FPSCR_PTR_t;   /** @brief FPSCR register pointer type. */

    /**** @subsection FPU Register Field Masks ****/

    static const uint32_t FPU_FPCCR_LSPACT_MASK    = 0x00000001U;   /** @brief LSPACT */
    static const uint32_t FPU_FPCCR_USER_MASK      = 0x00000002U;   /** @brief USER */
    static const uint32_t FPU_FPCCR_THREAD_MASK    = 0x00000008U;   /** @brief THREAD */
    static const uint32_t FPU_FPCCR_HFRDY_MASK     = 0x00000010U;   /** @brief HFRDY */
    static const uint32_t FPU_FPCCR_MMRDY_MASK     = 0x00000020U;   /** @brief MMRDY */
    static const uint32_t FPU_FPCCR_BFRDY_MASK     = 0x00000040U;   /** @brief BFRDY */
    static const uint32_t FPU_FPCCR_MONRDY_MASK    = 0x00000100U;   /** @brief MONRDY */
    static const uint32_t FPU_FPCCR_LSPEN_MASK     = 0x40000000U;   /** @brief LSPEN */
    static const uint32_t FPU_FPCCR_ASPEN_MASK     = 0x80000000U;   /** @brief ASPEN */
    static const uint32_t FPU_FPCAR_ADDRESS_MASK   = 0xFFFFFFF8U;   /** @brief Location of unpopulated floating-point */
    static const uint32_t FPU_FPSCR_IOC_MASK       = 0x00000001U;   /** @brief Invalid operation cumulative exception bit */
    static const uint32_t FPU_FPSCR_DZC_MASK       = 0x00000002U;   /** @brief Division by zero cumulative exception bit. */
    static const uint32_t FPU_FPSCR_OFC_MASK       = 0x00000004U;   /** @brief Overflow cumulative exception bit */
    static const uint32_t FPU_FPSCR_UFC_MASK       = 0x00000008U;   /** @brief Underflow cumulative exception bit */
    static const uint32_t FPU_FPSCR_IXC_MASK       = 0x00000010U;   /** @brief Inexact cumulative exception bit */
    static const uint32_t FPU_FPSCR_IDC_MASK       = 0x00000080U;   /** @brief Input denormal cumulative exception bit. */
    static const uint32_t FPU_FPSCR_RMODE_MASK     = 0x00C00000U;   /** @brief Rounding mode control field */
    static const uint32_t FPU_FPSCR_FZ_MASK        = 0x01000000U;   /** @brief Flush-to-zero mode control bit: */
    static const uint32_t FPU_FPSCR_DN_MASK        = 0x02000000U;   /** @brief Default nan mode control bit */
    static const uint32_t FPU_FPSCR_AHP_MASK       = 0x04000000U;   /** @brief Alternative half-precision control bit */
    static const uint32_t FPU_FPSCR_V_MASK         = 0x10000000U;   /** @brief Overflow condition code flag */
    static const uint32_t FPU_FPSCR_C_MASK         = 0x20000000U;   /** @brief Carry condition code flag */
    static const uint32_t FPU_FPSCR_Z_MASK         = 0x40000000U;   /** @brief Zero condition code flag */
    static const uint32_t FPU_FPSCR_N_MASK         = 0x80000000U;   /** @brief Negative condition code flag */

    /**** @subsection FPU Register Field Positions ****/

    static const int32_t FPU_FPCCR_LSPACT_POS    = 0;    /** @brief LSPACT */
    static const int32_t FPU_FPCCR_USER_POS      = 1;    /** @brief USER */
    static const int32_t FPU_FPCCR_THREAD_POS    = 3;    /** @brief THREAD */
    static const int32_t FPU_FPCCR_HFRDY_POS     = 4;    /** @brief HFRDY */
    static const int32_t FPU_FPCCR_MMRDY_POS     = 5;    /** @brief MMRDY */
    static const int32_t FPU_FPCCR_BFRDY_POS     = 6;    /** @brief BFRDY */
    static const int32_t FPU_FPCCR_MONRDY_POS    = 8;    /** @brief MONRDY */
    static const int32_t FPU_FPCCR_LSPEN_POS     = 30;   /** @brief LSPEN */
    static const int32_t FPU_FPCCR_ASPEN_POS     = 31;   /** @brief ASPEN */
    static const int32_t FPU_FPCAR_ADDRESS_POS   = 3;    /** @brief Location of unpopulated floating-point */
    static const int32_t FPU_FPSCR_IOC_POS       = 0;    /** @brief Invalid operation cumulative exception bit */
    static const int32_t FPU_FPSCR_DZC_POS       = 1;    /** @brief Division by zero cumulative exception bit. */
    static const int32_t FPU_FPSCR_OFC_POS       = 2;    /** @brief Overflow cumulative exception bit */
    static const int32_t FPU_FPSCR_UFC_POS       = 3;    /** @brief Underflow cumulative exception bit */
    static const int32_t FPU_FPSCR_IXC_POS       = 4;    /** @brief Inexact cumulative exception bit */
    static const int32_t FPU_FPSCR_IDC_POS       = 7;    /** @brief Input denormal cumulative exception bit. */
    static const int32_t FPU_FPSCR_RMODE_POS     = 22;   /** @brief Rounding mode control field */
    static const int32_t FPU_FPSCR_FZ_POS        = 24;   /** @brief Flush-to-zero mode control bit: */
    static const int32_t FPU_FPSCR_DN_POS        = 25;   /** @brief Default nan mode control bit */
    static const int32_t FPU_FPSCR_AHP_POS       = 26;   /** @brief Alternative half-precision control bit */
    static const int32_t FPU_FPSCR_V_POS         = 28;   /** @brief Overflow condition code flag */
    static const int32_t FPU_FPSCR_C_POS         = 29;   /** @brief Carry condition code flag */
    static const int32_t FPU_FPSCR_Z_POS         = 30;   /** @brief Zero condition code flag */
    static const int32_t FPU_FPSCR_N_POS         = 31;   /** @brief Negative condition code flag */

    /**********************************************************************************************
     * @section SCB Register Information
     **********************************************************************************************/

    /**** @subsection SCB Register Pointers ****/

    static RO_ uint32_t* const SCB_CPUID_PTR                  = (RO_ uint32_t* const)0xE000ED00U;   /** @brief CPUID base register */
    static RW_ uint32_t* const SCB_ICSR_PTR                   = (RW_ uint32_t* const)0xE000ED04U;   /** @brief Interrupt control and state register */
    static RW_ uint32_t* const SCB_VTOR_PTR                   = (RW_ uint32_t* const)0xE000ED08U;   /** @brief Vector table offset register */
    static RW_ uint32_t* const SCB_AIRCR_PTR                  = (RW_ uint32_t* const)0xE000ED0CU;   /** @brief Application interrupt and reset control register */
    static RW_ uint32_t* const SCB_SCR_PTR                    = (RW_ uint32_t* const)0xE000ED10U;   /** @brief System control register */
    static RW_ uint32_t* const SCB_CCR_PTR                    = (RW_ uint32_t* const)0xE000ED14U;   /** @brief Configuration and control register */
    static RW_ uint32_t* const SCB_SHPR1_PTR                  = (RW_ uint32_t* const)0xE000ED18U;   /** @brief System handler priority registers */
    static RW_ uint32_t* const SCB_SHPR2_PTR                  = (RW_ uint32_t* const)0xE000ED1CU;   /** @brief System handler priority registers */
    static RW_ uint32_t* const SCB_SHPR3_PTR                  = (RW_ uint32_t* const)0xE000ED20U;   /** @brief System handler priority registers */
    static RW_ uint32_t* const SCB_SHCRS_PTR                  = (RW_ uint32_t* const)0xE000ED24U;   /** @brief System handler control and state register */
    static RW_ uint32_t* const SCB_CFSR_UFSR_BFSR_MMFSR_PTR   = (RW_ uint32_t* const)0xE000ED28U;   /** @brief Configurable fault status register */
    static RW_ uint32_t* const SCB_HFSR_PTR                   = (RW_ uint32_t* const)0xE000ED2CU;   /** @brief Hard fault status register */
    static RW_ uint32_t* const SCB_MMFAR_PTR                  = (RW_ uint32_t* const)0xE000ED34U;   /** @brief Memory management fault address register */
    static RW_ uint32_t* const SCB_BFAR_PTR                   = (RW_ uint32_t* const)0xE000ED38U;   /** @brief Bus fault address register */

    /**** @subsection SCB Register Reset Values ****/

    static const uint32_t SCB_CPUID_RST                  = 0x410FC241U;   /** @brief CPUID register reset value. */
    static const uint32_t SCB_ICSR_RST                   = 0x00000000U;   /** @brief ICSR register reset value. */
    static const uint32_t SCB_VTOR_RST                   = 0x00000000U;   /** @brief VTOR register reset value. */
    static const uint32_t SCB_AIRCR_RST                  = 0x00000000U;   /** @brief AIRCR register reset value. */
    static const uint32_t SCB_SCR_RST                    = 0x00000000U;   /** @brief SCR register reset value. */
    static const uint32_t SCB_CCR_RST                    = 0x00000000U;   /** @brief CCR register reset value. */
    static const uint32_t SCB_SHPR1_RST                  = 0x00000000U;   /** @brief SHPR1 register reset value. */
    static const uint32_t SCB_SHPR2_RST                  = 0x00000000U;   /** @brief SHPR2 register reset value. */
    static const uint32_t SCB_SHPR3_RST                  = 0x00000000U;   /** @brief SHPR3 register reset value. */
    static const uint32_t SCB_SHCRS_RST                  = 0x00000000U;   /** @brief SHCRS register reset value. */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_RST   = 0x00000000U;   /** @brief CFSR_UFSR_BFSR_MMFSR register reset value. */
    static const uint32_t SCB_HFSR_RST                   = 0x00000000U;   /** @brief HFSR register reset value. */
    static const uint32_t SCB_MMFAR_RST                  = 0x00000000U;   /** @brief MMFAR register reset value. */
    static const uint32_t SCB_BFAR_RST                   = 0x00000000U;   /** @brief BFAR register reset value. */

    /**** @subsection Enumerated SCB Register Value Types ****/

    typedef uint32_t SCB_CPUID_t;                  /** @brief CPUID register value type. */
    typedef uint32_t SCB_ICSR_t;                   /** @brief ICSR register value type. */
    typedef uint32_t SCB_VTOR_t;                   /** @brief VTOR register value type. */
    typedef uint32_t SCB_AIRCR_t;                  /** @brief AIRCR register value type. */
    typedef uint32_t SCB_SCR_t;                    /** @brief SCR register value type. */
    typedef uint32_t SCB_CCR_t;                    /** @brief CCR register value type. */
    typedef uint32_t SCB_SHPR1_t;                  /** @brief SHPR1 register value type. */
    typedef uint32_t SCB_SHPR2_t;                  /** @brief SHPR2 register value type. */
    typedef uint32_t SCB_SHPR3_t;                  /** @brief SHPR3 register value type. */
    typedef uint32_t SCB_SHCRS_t;                  /** @brief SHCRS register value type. */
    typedef uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_t;   /** @brief CFSR_UFSR_BFSR_MMFSR register value type. */
    typedef uint32_t SCB_HFSR_t;                   /** @brief HFSR register value type. */
    typedef uint32_t SCB_MMFAR_t;                  /** @brief MMFAR register value type. */
    typedef uint32_t SCB_BFAR_t;                   /** @brief BFAR register value type. */

    /**** @subsection Enumerated SCB Register Pointer Types ****/

    typedef uint32_t* const SCB_CPUID_PTR_t;                  /** @brief CPUID register pointer type. */
    typedef uint32_t* const SCB_ICSR_PTR_t;                   /** @brief ICSR register pointer type. */
    typedef uint32_t* const SCB_VTOR_PTR_t;                   /** @brief VTOR register pointer type. */
    typedef uint32_t* const SCB_AIRCR_PTR_t;                  /** @brief AIRCR register pointer type. */
    typedef uint32_t* const SCB_SCR_PTR_t;                    /** @brief SCR register pointer type. */
    typedef uint32_t* const SCB_CCR_PTR_t;                    /** @brief CCR register pointer type. */
    typedef uint32_t* const SCB_SHPR1_PTR_t;                  /** @brief SHPR1 register pointer type. */
    typedef uint32_t* const SCB_SHPR2_PTR_t;                  /** @brief SHPR2 register pointer type. */
    typedef uint32_t* const SCB_SHPR3_PTR_t;                  /** @brief SHPR3 register pointer type. */
    typedef uint32_t* const SCB_SHCRS_PTR_t;                  /** @brief SHCRS register pointer type. */
    typedef uint32_t* const SCB_CFSR_UFSR_BFSR_MMFSR_PTR_t;   /** @brief CFSR_UFSR_BFSR_MMFSR register pointer type. */
    typedef uint32_t* const SCB_HFSR_PTR_t;                   /** @brief HFSR register pointer type. */
    typedef uint32_t* const SCB_MMFAR_PTR_t;                  /** @brief MMFAR register pointer type. */
    typedef uint32_t* const SCB_BFAR_PTR_t;                   /** @brief BFAR register pointer type. */

    /**** @subsection SCB Register Field Masks ****/

    static const uint32_t SCB_CPUID_REVISION_MASK                     = 0x0000000FU;   /** @brief Revision number */
    static const uint32_t SCB_CPUID_PARTNO_MASK                       = 0x0000FFF0U;   /** @brief Part number of the processor */
    static const uint32_t SCB_CPUID_CONSTANT_MASK                     = 0x000F0000U;   /** @brief Reads as 0xf */
    static const uint32_t SCB_CPUID_VARIANT_MASK                      = 0x00F00000U;   /** @brief Variant number */
    static const uint32_t SCB_CPUID_IMPLEMENTER_MASK                  = 0xFF000000U;   /** @brief Implementer code */
    static const uint32_t SCB_ICSR_VECTACTIVE_MASK                    = 0x000001FFU;   /** @brief Active vector */
    static const uint32_t SCB_ICSR_RETTOBASE_MASK                     = 0x00000800U;   /** @brief Return to base level */
    static const uint32_t SCB_ICSR_VECTPENDING_MASK                   = 0x0007F000U;   /** @brief Pending vector */
    static const uint32_t SCB_ICSR_ISRPENDING_MASK                    = 0x00400000U;   /** @brief Interrupt pending flag */
    static const uint32_t SCB_ICSR_PENDSTCLR_MASK                     = 0x02000000U;   /** @brief SysTick exception clear-pending bit */
    static const uint32_t SCB_ICSR_PENDSTSET_MASK                     = 0x04000000U;   /** @brief SysTick exception set-pending bit */
    static const uint32_t SCB_ICSR_PENDSVCLR_MASK                     = 0x08000000U;   /** @brief PendSV clear-pending bit */
    static const uint32_t SCB_ICSR_PENDSVSET_MASK                     = 0x10000000U;   /** @brief PendSV set-pending bit */
    static const uint32_t SCB_ICSR_NMIPENDSET_MASK                    = 0x80000000U;   /** @brief NMI set-pending bit. */
    static const uint32_t SCB_VTOR_TBLOFF_MASK                        = 0x3FFFFE00U;   /** @brief Vector table base offset field */
    static const uint32_t SCB_AIRCR_VECTRESET_MASK                    = 0x00000001U;   /** @brief VECTRESET */
    static const uint32_t SCB_AIRCR_VECTCLRACTIVE_MASK                = 0x00000002U;   /** @brief VECTCLRACTIVE */
    static const uint32_t SCB_AIRCR_SYSRESETREQ_MASK                  = 0x00000004U;   /** @brief SYSRESETREQ */
    static const uint32_t SCB_AIRCR_PRIGROUP_MASK                     = 0x00000700U;   /** @brief PRIGROUP */
    static const uint32_t SCB_AIRCR_ENDIANESS_MASK                    = 0x00008000U;   /** @brief ENDIANESS */
    static const uint32_t SCB_AIRCR_VECTKEYSTAT_MASK                  = 0xFFFF0000U;   /** @brief Register key */
    static const uint32_t SCB_SCR_SLEEPONEXIT_MASK                    = 0x00000002U;   /** @brief SLEEPONEXIT */
    static const uint32_t SCB_SCR_SLEEPDEEP_MASK                      = 0x00000004U;   /** @brief SLEEPDEEP */
    static const uint32_t SCB_SCR_SEVEONPEND_MASK                     = 0x00000010U;   /** @brief Send event on pending bit */
    static const uint32_t SCB_CCR_NONBASETHRDENA_MASK                 = 0x00000001U;   /** @brief Configures how the processor enters thread mode */
    static const uint32_t SCB_CCR_USERSETMPEND_MASK                   = 0x00000002U;   /** @brief USERSETMPEND */
    static const uint32_t SCB_CCR_UNALIGN__TRP_MASK                   = 0x00000008U;   /** @brief UNALIGN_ TRP */
    static const uint32_t SCB_CCR_DIV_0_TRP_MASK                      = 0x00000010U;   /** @brief DIV_0_TRP */
    static const uint32_t SCB_CCR_BFHFNMIGN_MASK                      = 0x00000100U;   /** @brief BFHFNMIGN */
    static const uint32_t SCB_CCR_STKALIGN_MASK                       = 0x00000200U;   /** @brief STKALIGN */
    static const uint32_t SCB_CCR_DC_MASK                             = 0x00010000U;   /** @brief DC */
    static const uint32_t SCB_CCR_IC_MASK                             = 0x00020000U;   /** @brief IC */
    static const uint32_t SCB_CCR_BP_MASK                             = 0x00040000U;   /** @brief BP */
    static const uint32_t SCB_SHPR2_PRI_11_MASK                       = 0xFF000000U;   /** @brief Priority of system handler 11 */
    static const uint32_t SCB_SHCRS_MEMFAULTACT_MASK                  = 0x00000001U;   /** @brief Memory management fault exception active bit */
    static const uint32_t SCB_SHCRS_BUSFAULTACT_MASK                  = 0x00000002U;   /** @brief Bus fault exception active bit */
    static const uint32_t SCB_SHCRS_USGFAULTACT_MASK                  = 0x00000008U;   /** @brief Usage fault exception active bit */
    static const uint32_t SCB_SHCRS_SVCALLACT_MASK                    = 0x00000080U;   /** @brief SVC call active bit */
    static const uint32_t SCB_SHCRS_MONITORACT_MASK                   = 0x00000100U;   /** @brief Debug monitor active bit */
    static const uint32_t SCB_SHCRS_PENDSVACT_MASK                    = 0x00000400U;   /** @brief PendSV exception active bit */
    static const uint32_t SCB_SHCRS_SYSTICKACT_MASK                   = 0x00000800U;   /** @brief SysTick exception active bit */
    static const uint32_t SCB_SHCRS_USGFAULTPENDED_MASK               = 0x00001000U;   /** @brief Usage fault exception pending bit */
    static const uint32_t SCB_SHCRS_MEMFAULTPENDED_MASK               = 0x00002000U;   /** @brief Memory management fault exception pending bit */
    static const uint32_t SCB_SHCRS_BUSFAULTPENDED_MASK               = 0x00004000U;   /** @brief Bus fault exception pending bit */
    static const uint32_t SCB_SHCRS_SVCALLPENDED_MASK                 = 0x00008000U;   /** @brief SVC call pending bit */
    static const uint32_t SCB_SHCRS_MEMFAULTENA_MASK                  = 0x00010000U;   /** @brief Memory management fault enable bit */
    static const uint32_t SCB_SHCRS_BUSFAULTENA_MASK                  = 0x00020000U;   /** @brief Bus fault enable bit */
    static const uint32_t SCB_SHCRS_USGFAULTENA_MASK                  = 0x00040000U;   /** @brief Usage fault enable bit */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_MASK      = 0x00000001U;   /** @brief IACCVIOL */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL_MASK      = 0x00000002U;   /** @brief DACCVIOL */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_MASK     = 0x00000008U;   /** @brief MUNSTKERR */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_MASK       = 0x00000010U;   /** @brief MSTKERR */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_MASK       = 0x00000020U;   /** @brief MLSPERR */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_MASK     = 0x00000080U;   /** @brief MMARVALID */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_MASK       = 0x00000100U;   /** @brief Instruction bus error */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_MASK     = 0x00000200U;   /** @brief Precise data bus error */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_MASK   = 0x00000400U;   /** @brief Imprecise data bus error */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_MASK      = 0x00000800U;   /** @brief Bus fault on unstacking for a return from exception */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_MASK        = 0x00001000U;   /** @brief Bus fault on stacking for exception entry */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_MASK        = 0x00002000U;   /** @brief Bus fault on floating-point lazy state preservation */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_MASK     = 0x00008000U;   /** @brief Bus fault address register (BFAR) valid flag */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_MASK    = 0x00010000U;   /** @brief Undefined instruction usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_MASK      = 0x00020000U;   /** @brief Invalid state usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_MASK         = 0x00040000U;   /** @brief Invalid PC load usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_MASK          = 0x00080000U;   /** @brief No coprocessor usage fault. */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_MASK     = 0x01000000U;   /** @brief Unaligned access usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_MASK     = 0x02000000U;   /** @brief Divide by zero usage fault */
    static const uint32_t SCB_HFSR_VECTTBL_MASK                       = 0x00000002U;   /** @brief Vector table hard fault */
    static const uint32_t SCB_HFSR_FORCED_MASK                        = 0x40000000U;   /** @brief Forced hard fault */
    static const uint32_t SCB_HFSR_DEBUG_VT_MASK                      = 0x80000000U;   /** @brief Reserved for debug use */

    /**** @subsection Enumerated SCB Register Field Masks ****/

    static const uint32_t SCB_SHPR1_PRI_x_MASK[7] = {
      [4] = 0x000000FFU,   /** @brief Priority of system handler 4 */
      [5] = 0x0000FF00U,   /** @brief Priority of system handler 5 */
      [6] = 0x00FF0000U,   /** @brief Priority of system handler 6 */
    };

    static const uint32_t SCB_SHPR3_PRI_1x_MASK[6] = {
      [4] = 0x00FF0000U,   /** @brief Priority of system handler 14 */
      [5] = 0xFF000000U,   /** @brief Priority of system handler 15 */
    };

    /**** @subsection SCB Register Field Positions ****/

    static const int32_t SCB_CPUID_REVISION_POS                     = 0;    /** @brief Revision number */
    static const int32_t SCB_CPUID_PARTNO_POS                       = 4;    /** @brief Part number of the processor */
    static const int32_t SCB_CPUID_CONSTANT_POS                     = 16;   /** @brief Reads as 0xf */
    static const int32_t SCB_CPUID_VARIANT_POS                      = 20;   /** @brief Variant number */
    static const int32_t SCB_CPUID_IMPLEMENTER_POS                  = 24;   /** @brief Implementer code */
    static const int32_t SCB_ICSR_VECTACTIVE_POS                    = 0;    /** @brief Active vector */
    static const int32_t SCB_ICSR_RETTOBASE_POS                     = 11;   /** @brief Return to base level */
    static const int32_t SCB_ICSR_VECTPENDING_POS                   = 12;   /** @brief Pending vector */
    static const int32_t SCB_ICSR_ISRPENDING_POS                    = 22;   /** @brief Interrupt pending flag */
    static const int32_t SCB_ICSR_PENDSTCLR_POS                     = 25;   /** @brief SysTick exception clear-pending bit */
    static const int32_t SCB_ICSR_PENDSTSET_POS                     = 26;   /** @brief SysTick exception set-pending bit */
    static const int32_t SCB_ICSR_PENDSVCLR_POS                     = 27;   /** @brief PendSV clear-pending bit */
    static const int32_t SCB_ICSR_PENDSVSET_POS                     = 28;   /** @brief PendSV set-pending bit */
    static const int32_t SCB_ICSR_NMIPENDSET_POS                    = 31;   /** @brief NMI set-pending bit. */
    static const int32_t SCB_VTOR_TBLOFF_POS                        = 9;    /** @brief Vector table base offset field */
    static const int32_t SCB_AIRCR_VECTRESET_POS                    = 0;    /** @brief VECTRESET */
    static const int32_t SCB_AIRCR_VECTCLRACTIVE_POS                = 1;    /** @brief VECTCLRACTIVE */
    static const int32_t SCB_AIRCR_SYSRESETREQ_POS                  = 2;    /** @brief SYSRESETREQ */
    static const int32_t SCB_AIRCR_PRIGROUP_POS                     = 8;    /** @brief PRIGROUP */
    static const int32_t SCB_AIRCR_ENDIANESS_POS                    = 15;   /** @brief ENDIANESS */
    static const int32_t SCB_AIRCR_VECTKEYSTAT_POS                  = 16;   /** @brief Register key */
    static const int32_t SCB_SCR_SLEEPONEXIT_POS                    = 1;    /** @brief SLEEPONEXIT */
    static const int32_t SCB_SCR_SLEEPDEEP_POS                      = 2;    /** @brief SLEEPDEEP */
    static const int32_t SCB_SCR_SEVEONPEND_POS                     = 4;    /** @brief Send event on pending bit */
    static const int32_t SCB_CCR_NONBASETHRDENA_POS                 = 0;    /** @brief Configures how the processor enters thread mode */
    static const int32_t SCB_CCR_USERSETMPEND_POS                   = 1;    /** @brief USERSETMPEND */
    static const int32_t SCB_CCR_UNALIGN__TRP_POS                   = 3;    /** @brief UNALIGN_ TRP */
    static const int32_t SCB_CCR_DIV_0_TRP_POS                      = 4;    /** @brief DIV_0_TRP */
    static const int32_t SCB_CCR_BFHFNMIGN_POS                      = 8;    /** @brief BFHFNMIGN */
    static const int32_t SCB_CCR_STKALIGN_POS                       = 9;    /** @brief STKALIGN */
    static const int32_t SCB_CCR_DC_POS                             = 16;   /** @brief DC */
    static const int32_t SCB_CCR_IC_POS                             = 17;   /** @brief IC */
    static const int32_t SCB_CCR_BP_POS                             = 18;   /** @brief BP */
    static const int32_t SCB_SHPR2_PRI_11_POS                       = 24;   /** @brief Priority of system handler 11 */
    static const int32_t SCB_SHCRS_MEMFAULTACT_POS                  = 0;    /** @brief Memory management fault exception active bit */
    static const int32_t SCB_SHCRS_BUSFAULTACT_POS                  = 1;    /** @brief Bus fault exception active bit */
    static const int32_t SCB_SHCRS_USGFAULTACT_POS                  = 3;    /** @brief Usage fault exception active bit */
    static const int32_t SCB_SHCRS_SVCALLACT_POS                    = 7;    /** @brief SVC call active bit */
    static const int32_t SCB_SHCRS_MONITORACT_POS                   = 8;    /** @brief Debug monitor active bit */
    static const int32_t SCB_SHCRS_PENDSVACT_POS                    = 10;   /** @brief PendSV exception active bit */
    static const int32_t SCB_SHCRS_SYSTICKACT_POS                   = 11;   /** @brief SysTick exception active bit */
    static const int32_t SCB_SHCRS_USGFAULTPENDED_POS               = 12;   /** @brief Usage fault exception pending bit */
    static const int32_t SCB_SHCRS_MEMFAULTPENDED_POS               = 13;   /** @brief Memory management fault exception pending bit */
    static const int32_t SCB_SHCRS_BUSFAULTPENDED_POS               = 14;   /** @brief Bus fault exception pending bit */
    static const int32_t SCB_SHCRS_SVCALLPENDED_POS                 = 15;   /** @brief SVC call pending bit */
    static const int32_t SCB_SHCRS_MEMFAULTENA_POS                  = 16;   /** @brief Memory management fault enable bit */
    static const int32_t SCB_SHCRS_BUSFAULTENA_POS                  = 17;   /** @brief Bus fault enable bit */
    static const int32_t SCB_SHCRS_USGFAULTENA_POS                  = 18;   /** @brief Usage fault enable bit */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_POS      = 0;    /** @brief IACCVIOL */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL_POS      = 1;    /** @brief DACCVIOL */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_POS     = 3;    /** @brief MUNSTKERR */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_POS       = 4;    /** @brief MSTKERR */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_POS       = 5;    /** @brief MLSPERR */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_POS     = 7;    /** @brief MMARVALID */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_POS       = 8;    /** @brief Instruction bus error */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_POS     = 9;    /** @brief Precise data bus error */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_POS   = 10;   /** @brief Imprecise data bus error */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_POS      = 11;   /** @brief Bus fault on unstacking for a return from exception */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_POS        = 12;   /** @brief Bus fault on stacking for exception entry */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_POS        = 13;   /** @brief Bus fault on floating-point lazy state preservation */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_POS     = 15;   /** @brief Bus fault address register (BFAR) valid flag */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_POS    = 16;   /** @brief Undefined instruction usage fault */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_POS      = 17;   /** @brief Invalid state usage fault */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_POS         = 18;   /** @brief Invalid PC load usage fault */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_POS          = 19;   /** @brief No coprocessor usage fault. */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_POS     = 24;   /** @brief Unaligned access usage fault */
    static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_POS     = 25;   /** @brief Divide by zero usage fault */
    static const int32_t SCB_HFSR_VECTTBL_POS                       = 1;    /** @brief Vector table hard fault */
    static const int32_t SCB_HFSR_FORCED_POS                        = 30;   /** @brief Forced hard fault */
    static const int32_t SCB_HFSR_DEBUG_VT_POS                      = 31;   /** @brief Reserved for debug use */

    /**** @subsection Enumerated SCB Register Field Positions ****/

    static const int32_t SCB_SHPR1_PRI_x_POS[7] = {
      [4] = 0,    /** @brief Priority of system handler 4 */
      [5] = 8,    /** @brief Priority of system handler 5 */
      [6] = 16,   /** @brief Priority of system handler 6 */
    };

    static const int32_t SCB_SHPR3_PRI_1x_POS[6] = {
      [4] = 16,   /** @brief Priority of system handler 14 */
      [5] = 24,   /** @brief Priority of system handler 15 */
    };

    /**********************************************************************************************
     * @section PF Register Information
     **********************************************************************************************/

    /**** @subsection PF Register Pointers ****/

    static RO_ uint32_t* const PF_CLIDR_PTR    = (RO_ uint32_t* const)0xE000ED78U;   /** @brief Cache level ID register */
    static RO_ uint32_t* const PF_CTR_PTR      = (RO_ uint32_t* const)0xE000ED7CU;   /** @brief Cache type register */
    static RO_ uint32_t* const PF_CCSIDR_PTR   = (RO_ uint32_t* const)0xE000ED80U;   /** @brief Cache size ID register */

    /**** @subsection PF Register Reset Values ****/

    static const uint32_t PF_CLIDR_RST    = 0x09000003U;   /** @brief CLIDR register reset value. */
    static const uint32_t PF_CTR_RST      = 0x8303C003U;   /** @brief CTR register reset value. */
    static const uint32_t PF_CCSIDR_RST   = 0x00000000U;   /** @brief CCSIDR register reset value. */

    /**** @subsection Enumerated PF Register Value Types ****/

    typedef uint32_t PF_CLIDR_t;    /** @brief CLIDR register value type. */
    typedef uint32_t PF_CTR_t;      /** @brief CTR register value type. */
    typedef uint32_t PF_CCSIDR_t;   /** @brief CCSIDR register value type. */

    /**** @subsection Enumerated PF Register Pointer Types ****/

    typedef uint32_t* const PF_CLIDR_PTR_t;    /** @brief CLIDR register pointer type. */
    typedef uint32_t* const PF_CTR_PTR_t;      /** @brief CTR register pointer type. */
    typedef uint32_t* const PF_CCSIDR_PTR_t;   /** @brief CCSIDR register pointer type. */

    /**** @subsection PF Register Field Masks ****/

    static const uint32_t PF_CLIDR_LOUIS_MASK            = 0x00E00000U;   /** @brief LoUIS */
    static const uint32_t PF_CLIDR_LOC_MASK              = 0x07000000U;   /** @brief LoC */
    static const uint32_t PF_CLIDR_LOU_MASK              = 0x38000000U;   /** @brief LoU */
    static const uint32_t PF_CTR__IMINLINE_MASK          = 0x0000000FU;   /** @brief IminLine */
    static const uint32_t PF_CTR_DMINLINE_MASK           = 0x000F0000U;   /** @brief DMinLine */
    static const uint32_t PF_CTR_ERG_MASK                = 0x00F00000U;   /** @brief ERG */
    static const uint32_t PF_CTR_CWG_MASK                = 0x0F000000U;   /** @brief CWG */
    static const uint32_t PF_CTR_FORMAT_MASK             = 0xE0000000U;   /** @brief Format */
    static const uint32_t PF_CCSIDR_LINESIZE_MASK        = 0x00000007U;   /** @brief LineSize */
    static const uint32_t PF_CCSIDR_ASSOCIATIVITY_MASK   = 0x00001FF8U;   /** @brief Associativity */
    static const uint32_t PF_CCSIDR_NUMSETS_MASK         = 0x0FFFE000U;   /** @brief NumSets */
    static const uint32_t PF_CCSIDR_WA_MASK              = 0x10000000U;   /** @brief WA */
    static const uint32_t PF_CCSIDR_RA_MASK              = 0x20000000U;   /** @brief RA */
    static const uint32_t PF_CCSIDR_WB_MASK              = 0x40000000U;   /** @brief WB */
    static const uint32_t PF_CCSIDR_WT_MASK              = 0x80000000U;   /** @brief WT */

    /**** @subsection Enumerated PF Register Field Masks ****/

    static const uint32_t PF_CLIDR_CLx_MASK[8] = {
      [1] = 0x00000007U,   /** @brief CL1 */
      [2] = 0x00000038U,   /** @brief CL2 */
      [3] = 0x000001C0U,   /** @brief CL3 */
      [4] = 0x00000E00U,   /** @brief CL4 */
      [5] = 0x00007000U,   /** @brief CL5 */
      [6] = 0x00038000U,   /** @brief CL6 */
      [7] = 0x001C0000U,   /** @brief CL7 */
    };

    /**** @subsection PF Register Field Positions ****/

    static const int32_t PF_CLIDR_LOUIS_POS            = 21;   /** @brief LoUIS */
    static const int32_t PF_CLIDR_LOC_POS              = 24;   /** @brief LoC */
    static const int32_t PF_CLIDR_LOU_POS              = 27;   /** @brief LoU */
    static const int32_t PF_CTR__IMINLINE_POS          = 0;    /** @brief IminLine */
    static const int32_t PF_CTR_DMINLINE_POS           = 16;   /** @brief DMinLine */
    static const int32_t PF_CTR_ERG_POS                = 20;   /** @brief ERG */
    static const int32_t PF_CTR_CWG_POS                = 24;   /** @brief CWG */
    static const int32_t PF_CTR_FORMAT_POS             = 29;   /** @brief Format */
    static const int32_t PF_CCSIDR_LINESIZE_POS        = 0;    /** @brief LineSize */
    static const int32_t PF_CCSIDR_ASSOCIATIVITY_POS   = 3;    /** @brief Associativity */
    static const int32_t PF_CCSIDR_NUMSETS_POS         = 13;   /** @brief NumSets */
    static const int32_t PF_CCSIDR_WA_POS              = 28;   /** @brief WA */
    static const int32_t PF_CCSIDR_RA_POS              = 29;   /** @brief RA */
    static const int32_t PF_CCSIDR_WB_POS              = 30;   /** @brief WB */
    static const int32_t PF_CCSIDR_WT_POS              = 31;   /** @brief WT */

    /**** @subsection Enumerated PF Register Field Positions ****/

    static const int32_t PF_CLIDR_CLx_POS[8] = {
      [1] = 0,    /** @brief CL1 */
      [2] = 3,    /** @brief CL2 */
      [3] = 6,    /** @brief CL3 */
      [4] = 9,    /** @brief CL4 */
      [5] = 12,   /** @brief CL5 */
      [6] = 15,   /** @brief CL6 */
      [7] = 18,   /** @brief CL7 */
    };

    /**********************************************************************************************
     * @section AC Register Information
     **********************************************************************************************/

    /**** @subsection AC Register Pointers ****/

    static RW_ uint32_t* const AC_ITCMCR_PTR   = (RW_ uint32_t* const)0xE000EF90U;   /** @brief Instruction and data tightly-coupled memory control registers */
    static RW_ uint32_t* const AC_DTCMCR_PTR   = (RW_ uint32_t* const)0xE000EF94U;   /** @brief Instruction and data tightly-coupled memory control registers */
    static RW_ uint32_t* const AC_AHBPCR_PTR   = (RW_ uint32_t* const)0xE000EF98U;   /** @brief AHBP control register */
    static RW_ uint32_t* const AC_CACR_PTR     = (RW_ uint32_t* const)0xE000EF9CU;   /** @brief Auxiliary cache control register */
    static RW_ uint32_t* const AC_AHBSCR_PTR   = (RW_ uint32_t* const)0xE000EFA0U;   /** @brief AHB slave control register */
    static RW_ uint32_t* const AC_ABFSR_PTR    = (RW_ uint32_t* const)0xE000EFA8U;   /** @brief Auxiliary bus fault status register */

    /**** @subsection AC Register Reset Values ****/

    static const uint32_t AC_ITCMCR_RST   = 0x00000000U;   /** @brief ITCMCR register reset value. */
    static const uint32_t AC_DTCMCR_RST   = 0x00000000U;   /** @brief DTCMCR register reset value. */
    static const uint32_t AC_AHBPCR_RST   = 0x00000000U;   /** @brief AHBPCR register reset value. */
    static const uint32_t AC_CACR_RST     = 0x00000000U;   /** @brief CACR register reset value. */
    static const uint32_t AC_AHBSCR_RST   = 0x00000000U;   /** @brief AHBSCR register reset value. */
    static const uint32_t AC_ABFSR_RST    = 0x00000000U;   /** @brief ABFSR register reset value. */

    /**** @subsection Enumerated AC Register Value Types ****/

    typedef uint32_t AC_ITCMCR_t;   /** @brief ITCMCR register value type. */
    typedef uint32_t AC_DTCMCR_t;   /** @brief DTCMCR register value type. */
    typedef uint32_t AC_AHBPCR_t;   /** @brief AHBPCR register value type. */
    typedef uint32_t AC_CACR_t;     /** @brief CACR register value type. */
    typedef uint32_t AC_AHBSCR_t;   /** @brief AHBSCR register value type. */
    typedef uint32_t AC_ABFSR_t;    /** @brief ABFSR register value type. */

    /**** @subsection Enumerated AC Register Pointer Types ****/

    typedef uint32_t* const AC_ITCMCR_PTR_t;   /** @brief ITCMCR register pointer type. */
    typedef uint32_t* const AC_DTCMCR_PTR_t;   /** @brief DTCMCR register pointer type. */
    typedef uint32_t* const AC_AHBPCR_PTR_t;   /** @brief AHBPCR register pointer type. */
    typedef uint32_t* const AC_CACR_PTR_t;     /** @brief CACR register pointer type. */
    typedef uint32_t* const AC_AHBSCR_PTR_t;   /** @brief AHBSCR register pointer type. */
    typedef uint32_t* const AC_ABFSR_PTR_t;    /** @brief ABFSR register pointer type. */

    /**** @subsection AC Register Field Masks ****/

    static const uint32_t AC_ITCMCR_EN_MASK          = 0x00000001U;   /** @brief EN */
    static const uint32_t AC_ITCMCR_RMW_MASK         = 0x00000002U;   /** @brief RMW */
    static const uint32_t AC_ITCMCR_RETEN_MASK       = 0x00000004U;   /** @brief RETEN */
    static const uint32_t AC_ITCMCR_SZ_MASK          = 0x00000078U;   /** @brief SZ */
    static const uint32_t AC_DTCMCR_EN_MASK          = 0x00000001U;   /** @brief EN */
    static const uint32_t AC_DTCMCR_RMW_MASK         = 0x00000002U;   /** @brief RMW */
    static const uint32_t AC_DTCMCR_RETEN_MASK       = 0x00000004U;   /** @brief RETEN */
    static const uint32_t AC_DTCMCR_SZ_MASK          = 0x00000078U;   /** @brief SZ */
    static const uint32_t AC_AHBPCR_EN_MASK          = 0x00000001U;   /** @brief EN */
    static const uint32_t AC_AHBPCR_SZ_MASK          = 0x0000000EU;   /** @brief SZ */
    static const uint32_t AC_CACR_SIWT_MASK          = 0x00000001U;   /** @brief SIWT */
    static const uint32_t AC_CACR_ECCEN_MASK         = 0x00000002U;   /** @brief ECCEN */
    static const uint32_t AC_CACR_FORCEWT_MASK       = 0x00000004U;   /** @brief FORCEWT */
    static const uint32_t AC_AHBSCR_CTL_MASK         = 0x00000003U;   /** @brief CTL */
    static const uint32_t AC_AHBSCR_TPRI_MASK        = 0x000007FCU;   /** @brief TPRI */
    static const uint32_t AC_AHBSCR_INITCOUNT_MASK   = 0x0000F800U;   /** @brief INITCOUNT */
    static const uint32_t AC_ABFSR_ITCM_MASK         = 0x00000001U;   /** @brief ITCM */
    static const uint32_t AC_ABFSR_DTCM_MASK         = 0x00000002U;   /** @brief DTCM */
    static const uint32_t AC_ABFSR_AHBP_MASK         = 0x00000004U;   /** @brief AHBP */
    static const uint32_t AC_ABFSR_AXIM_MASK         = 0x00000008U;   /** @brief AXIM */
    static const uint32_t AC_ABFSR_EPPB_MASK         = 0x00000010U;   /** @brief EPPB */
    static const uint32_t AC_ABFSR_AXIMTYPE_MASK     = 0x00000300U;   /** @brief AXIMTYPE */

    /**** @subsection AC Register Field Positions ****/

    static const int32_t AC_ITCMCR_EN_POS          = 0;    /** @brief EN */
    static const int32_t AC_ITCMCR_RMW_POS         = 1;    /** @brief RMW */
    static const int32_t AC_ITCMCR_RETEN_POS       = 2;    /** @brief RETEN */
    static const int32_t AC_ITCMCR_SZ_POS          = 3;    /** @brief SZ */
    static const int32_t AC_DTCMCR_EN_POS          = 0;    /** @brief EN */
    static const int32_t AC_DTCMCR_RMW_POS         = 1;    /** @brief RMW */
    static const int32_t AC_DTCMCR_RETEN_POS       = 2;    /** @brief RETEN */
    static const int32_t AC_DTCMCR_SZ_POS          = 3;    /** @brief SZ */
    static const int32_t AC_AHBPCR_EN_POS          = 0;    /** @brief EN */
    static const int32_t AC_AHBPCR_SZ_POS          = 1;    /** @brief SZ */
    static const int32_t AC_CACR_SIWT_POS          = 0;    /** @brief SIWT */
    static const int32_t AC_CACR_ECCEN_POS         = 1;    /** @brief ECCEN */
    static const int32_t AC_CACR_FORCEWT_POS       = 2;    /** @brief FORCEWT */
    static const int32_t AC_AHBSCR_CTL_POS         = 0;    /** @brief CTL */
    static const int32_t AC_AHBSCR_TPRI_POS        = 2;    /** @brief TPRI */
    static const int32_t AC_AHBSCR_INITCOUNT_POS   = 11;   /** @brief INITCOUNT */
    static const int32_t AC_ABFSR_ITCM_POS         = 0;    /** @brief ITCM */
    static const int32_t AC_ABFSR_DTCM_POS         = 1;    /** @brief DTCM */
    static const int32_t AC_ABFSR_AHBP_POS         = 2;    /** @brief AHBP */
    static const int32_t AC_ABFSR_AXIM_POS         = 3;    /** @brief AXIM */
    static const int32_t AC_ABFSR_EPPB_POS         = 4;    /** @brief EPPB */
    static const int32_t AC_ABFSR_AXIMTYPE_POS     = 8;    /** @brief AXIMTYPE */

    /**********************************************************************************************
     * @section RAMECC1 Register Information
     **********************************************************************************************/

    /**** @subsection RAMECC1 Register Pointers ****/

    static RW_ uint32_t* const RAMECC1_IER_PTR      = (RW_ uint32_t* const)0x52009000U;   /** @brief RAMECC interrupt enable register */
    static RW_ uint32_t* const RAMECC1_M1CR_PTR     = (RW_ uint32_t* const)0x52009020U;   /** @brief RAMECC monitor x configuration register */
    static RW_ uint32_t* const RAMECC1_M1SR_PTR     = (RW_ uint32_t* const)0x52009024U;   /** @brief RAMECC monitor x status register */
    static RW_ uint32_t* const RAMECC1_M1FAR_PTR    = (RW_ uint32_t* const)0x52009028U;   /** @brief RAMECC monitor x failing address register */
    static RW_ uint32_t* const RAMECC1_M1FDRL_PTR   = (RW_ uint32_t* const)0x5200902CU;   /** @brief RAMECC monitor x failing data low register */
    static RW_ uint32_t* const RAMECC1_M1FDRH_PTR   = (RW_ uint32_t* const)0x52009030U;   /** @brief RAMECC monitor x failing data high register */
    static RW_ uint32_t* const RAMECC1_M1FECR_PTR   = (RW_ uint32_t* const)0x52009034U;   /** @brief RAMECC monitor x failing ECC error code register */
    static RW_ uint32_t* const RAMECC1_M2CR_PTR     = (RW_ uint32_t* const)0x52009040U;   /** @brief RAMECC monitor x configuration register */
    static RW_ uint32_t* const RAMECC1_M2SR_PTR     = (RW_ uint32_t* const)0x52009044U;   /** @brief RAMECC monitor x status register */
    static RW_ uint32_t* const RAMECC1_M2FAR_PTR    = (RW_ uint32_t* const)0x52009048U;   /** @brief RAMECC monitor x failing address register */
    static RW_ uint32_t* const RAMECC1_M2FDRL_PTR   = (RW_ uint32_t* const)0x5200904CU;   /** @brief RAMECC monitor x failing data low register */
    static RO_ uint32_t* const RAMECC1_M2FDRH_PTR   = (RO_ uint32_t* const)0x52009050U;   /** @brief RAMECC monitor x failing data high register */
    static RO_ uint32_t* const RAMECC1_M2FECR_PTR   = (RO_ uint32_t* const)0x52009058U;   /** @brief RAMECC monitor x failing ECC error code register */
    static RO_ uint32_t* const RAMECC1_M3CR_PTR     = (RO_ uint32_t* const)0x52009060U;   /** @brief RAMECC monitor x configuration register */
    static RO_ uint32_t* const RAMECC1_M3SR_PTR     = (RO_ uint32_t* const)0x52009064U;   /** @brief RAMECC monitor x status register */
    static RW_ uint32_t* const RAMECC1_M3FAR_PTR    = (RW_ uint32_t* const)0x52009068U;   /** @brief RAMECC monitor x failing address register */
    static RO_ uint32_t* const RAMECC1_M3FDRL_PTR   = (RO_ uint32_t* const)0x5200906CU;   /** @brief RAMECC monitor x failing data low register */
    static RO_ uint32_t* const RAMECC1_M3FDRH_PTR   = (RO_ uint32_t* const)0x52009070U;   /** @brief RAMECC monitor x failing data high register */
    static RO_ uint32_t* const RAMECC1_M3FECR_PTR   = (RO_ uint32_t* const)0x5200907CU;   /** @brief RAMECC monitor x failing ECC error code register */
    static RO_ uint32_t* const RAMECC1_M4CR_PTR     = (RO_ uint32_t* const)0x52009080U;   /** @brief RAMECC monitor x configuration register */
    static RO_ uint32_t* const RAMECC1_M4SR_PTR     = (RO_ uint32_t* const)0x52009084U;   /** @brief RAMECC monitor x status register */
    static RO_ uint32_t* const RAMECC1_M4FAR_PTR    = (RO_ uint32_t* const)0x52009088U;   /** @brief RAMECC monitor x failing address register */
    static RW_ uint32_t* const RAMECC1_M4FDRL_PTR   = (RW_ uint32_t* const)0x5200908CU;   /** @brief RAMECC monitor x failing data low register */
    static RO_ uint32_t* const RAMECC1_M4FDRH_PTR   = (RO_ uint32_t* const)0x52009090U;   /** @brief RAMECC monitor x failing data high register */
    static RO_ uint32_t* const RAMECC1_M4FECR_PTR   = (RO_ uint32_t* const)0x52009090U;   /** @brief RAMECC monitor x failing ECC error code register */
    static RO_ uint32_t* const RAMECC1_M5CR_PTR     = (RO_ uint32_t* const)0x520090A0U;   /** @brief RAMECC monitor x configuration register */
    static RW_ uint32_t* const RAMECC1_M5SR_PTR     = (RW_ uint32_t* const)0x520090A4U;   /** @brief RAMECC monitor x status register */
    static RW_ uint32_t* const RAMECC1_M5FAR_PTR    = (RW_ uint32_t* const)0x520090A8U;   /** @brief RAMECC monitor x failing address register */
    static RO_ uint32_t* const RAMECC1_M5FDRL_PTR   = (RO_ uint32_t* const)0x520090ACU;   /** @brief RAMECC monitor x failing data low register */
    static RO_ uint32_t* const RAMECC1_M5FDRH_PTR   = (RO_ uint32_t* const)0x520090B0U;   /** @brief RAMECC monitor x failing data high register */
    static RO_ uint32_t* const RAMECC1_M5FECR_PTR   = (RO_ uint32_t* const)0x520090B4U;   /** @brief RAMECC monitor x failing ECC error code register */

    /**** @subsection RAMECC1 Register Reset Values ****/

    static const uint32_t RAMECC1_IER_RST      = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t RAMECC1_M1CR_RST     = 0x00000000U;   /** @brief M1CR register reset value. */
    static const uint32_t RAMECC1_M1SR_RST     = 0x00000000U;   /** @brief M1SR register reset value. */
    static const uint32_t RAMECC1_M1FAR_RST    = 0x00000000U;   /** @brief M1FAR register reset value. */
    static const uint32_t RAMECC1_M1FDRL_RST   = 0x00000000U;   /** @brief M1FDRL register reset value. */
    static const uint32_t RAMECC1_M1FDRH_RST   = 0x00000000U;   /** @brief M1FDRH register reset value. */
    static const uint32_t RAMECC1_M1FECR_RST   = 0x00000000U;   /** @brief M1FECR register reset value. */
    static const uint32_t RAMECC1_M2CR_RST     = 0x00000000U;   /** @brief M2CR register reset value. */
    static const uint32_t RAMECC1_M2SR_RST     = 0x00000000U;   /** @brief M2SR register reset value. */
    static const uint32_t RAMECC1_M2FAR_RST    = 0x00000000U;   /** @brief M2FAR register reset value. */
    static const uint32_t RAMECC1_M2FDRL_RST   = 0x00000000U;   /** @brief M2FDRL register reset value. */
    static const uint32_t RAMECC1_M2FDRH_RST   = 0x00000000U;   /** @brief M2FDRH register reset value. */
    static const uint32_t RAMECC1_M2FECR_RST   = 0x00000000U;   /** @brief M2FECR register reset value. */
    static const uint32_t RAMECC1_M3CR_RST     = 0x00000000U;   /** @brief M3CR register reset value. */
    static const uint32_t RAMECC1_M3SR_RST     = 0x00000000U;   /** @brief M3SR register reset value. */
    static const uint32_t RAMECC1_M3FAR_RST    = 0x00000000U;   /** @brief M3FAR register reset value. */
    static const uint32_t RAMECC1_M3FDRL_RST   = 0x00000000U;   /** @brief M3FDRL register reset value. */
    static const uint32_t RAMECC1_M3FDRH_RST   = 0x00000000U;   /** @brief M3FDRH register reset value. */
    static const uint32_t RAMECC1_M3FECR_RST   = 0x00000000U;   /** @brief M3FECR register reset value. */
    static const uint32_t RAMECC1_M4CR_RST     = 0x00000000U;   /** @brief M4CR register reset value. */
    static const uint32_t RAMECC1_M4SR_RST     = 0x00000000U;   /** @brief M4SR register reset value. */
    static const uint32_t RAMECC1_M4FAR_RST    = 0x00000000U;   /** @brief M4FAR register reset value. */
    static const uint32_t RAMECC1_M4FDRL_RST   = 0x00000000U;   /** @brief M4FDRL register reset value. */
    static const uint32_t RAMECC1_M4FDRH_RST   = 0x00000000U;   /** @brief M4FDRH register reset value. */
    static const uint32_t RAMECC1_M4FECR_RST   = 0x00000000U;   /** @brief M4FECR register reset value. */
    static const uint32_t RAMECC1_M5CR_RST     = 0x00000000U;   /** @brief M5CR register reset value. */
    static const uint32_t RAMECC1_M5SR_RST     = 0x00000000U;   /** @brief M5SR register reset value. */
    static const uint32_t RAMECC1_M5FAR_RST    = 0x00000000U;   /** @brief M5FAR register reset value. */
    static const uint32_t RAMECC1_M5FDRL_RST   = 0x00000000U;   /** @brief M5FDRL register reset value. */
    static const uint32_t RAMECC1_M5FDRH_RST   = 0x00000000U;   /** @brief M5FDRH register reset value. */
    static const uint32_t RAMECC1_M5FECR_RST   = 0x00000000U;   /** @brief M5FECR register reset value. */

    /**** @subsection Enumerated RAMECC1 Register Value Types ****/

    typedef uint32_t RAMECC1_IER_t;      /** @brief IER register value type. */
    typedef uint32_t RAMECC1_M1CR_t;     /** @brief M1CR register value type. */
    typedef uint32_t RAMECC1_M1SR_t;     /** @brief M1SR register value type. */
    typedef uint32_t RAMECC1_M1FAR_t;    /** @brief M1FAR register value type. */
    typedef uint32_t RAMECC1_M1FDRL_t;   /** @brief M1FDRL register value type. */
    typedef uint32_t RAMECC1_M1FDRH_t;   /** @brief M1FDRH register value type. */
    typedef uint32_t RAMECC1_M1FECR_t;   /** @brief M1FECR register value type. */
    typedef uint32_t RAMECC1_M2CR_t;     /** @brief M2CR register value type. */
    typedef uint32_t RAMECC1_M2SR_t;     /** @brief M2SR register value type. */
    typedef uint32_t RAMECC1_M2FAR_t;    /** @brief M2FAR register value type. */
    typedef uint32_t RAMECC1_M2FDRL_t;   /** @brief M2FDRL register value type. */
    typedef uint32_t RAMECC1_M2FDRH_t;   /** @brief M2FDRH register value type. */
    typedef uint32_t RAMECC1_M2FECR_t;   /** @brief M2FECR register value type. */
    typedef uint32_t RAMECC1_M3CR_t;     /** @brief M3CR register value type. */
    typedef uint32_t RAMECC1_M3SR_t;     /** @brief M3SR register value type. */
    typedef uint32_t RAMECC1_M3FAR_t;    /** @brief M3FAR register value type. */
    typedef uint32_t RAMECC1_M3FDRL_t;   /** @brief M3FDRL register value type. */
    typedef uint32_t RAMECC1_M3FDRH_t;   /** @brief M3FDRH register value type. */
    typedef uint32_t RAMECC1_M3FECR_t;   /** @brief M3FECR register value type. */
    typedef uint32_t RAMECC1_M4CR_t;     /** @brief M4CR register value type. */
    typedef uint32_t RAMECC1_M4SR_t;     /** @brief M4SR register value type. */
    typedef uint32_t RAMECC1_M4FAR_t;    /** @brief M4FAR register value type. */
    typedef uint32_t RAMECC1_M4FDRL_t;   /** @brief M4FDRL register value type. */
    typedef uint32_t RAMECC1_M4FDRH_t;   /** @brief M4FDRH register value type. */
    typedef uint32_t RAMECC1_M4FECR_t;   /** @brief M4FECR register value type. */
    typedef uint32_t RAMECC1_M5CR_t;     /** @brief M5CR register value type. */
    typedef uint32_t RAMECC1_M5SR_t;     /** @brief M5SR register value type. */
    typedef uint32_t RAMECC1_M5FAR_t;    /** @brief M5FAR register value type. */
    typedef uint32_t RAMECC1_M5FDRL_t;   /** @brief M5FDRL register value type. */
    typedef uint32_t RAMECC1_M5FDRH_t;   /** @brief M5FDRH register value type. */
    typedef uint32_t RAMECC1_M5FECR_t;   /** @brief M5FECR register value type. */

    /**** @subsection Enumerated RAMECC1 Register Pointer Types ****/

    typedef uint32_t* const RAMECC1_IER_PTR_t;      /** @brief IER register pointer type. */
    typedef uint32_t* const RAMECC1_M1CR_PTR_t;     /** @brief M1CR register pointer type. */
    typedef uint32_t* const RAMECC1_M1SR_PTR_t;     /** @brief M1SR register pointer type. */
    typedef uint32_t* const RAMECC1_M1FAR_PTR_t;    /** @brief M1FAR register pointer type. */
    typedef uint32_t* const RAMECC1_M1FDRL_PTR_t;   /** @brief M1FDRL register pointer type. */
    typedef uint32_t* const RAMECC1_M1FDRH_PTR_t;   /** @brief M1FDRH register pointer type. */
    typedef uint32_t* const RAMECC1_M1FECR_PTR_t;   /** @brief M1FECR register pointer type. */
    typedef uint32_t* const RAMECC1_M2CR_PTR_t;     /** @brief M2CR register pointer type. */
    typedef uint32_t* const RAMECC1_M2SR_PTR_t;     /** @brief M2SR register pointer type. */
    typedef uint32_t* const RAMECC1_M2FAR_PTR_t;    /** @brief M2FAR register pointer type. */
    typedef uint32_t* const RAMECC1_M2FDRL_PTR_t;   /** @brief M2FDRL register pointer type. */
    typedef uint32_t* const RAMECC1_M2FDRH_PTR_t;   /** @brief M2FDRH register pointer type. */
    typedef uint32_t* const RAMECC1_M2FECR_PTR_t;   /** @brief M2FECR register pointer type. */
    typedef uint32_t* const RAMECC1_M3CR_PTR_t;     /** @brief M3CR register pointer type. */
    typedef uint32_t* const RAMECC1_M3SR_PTR_t;     /** @brief M3SR register pointer type. */
    typedef uint32_t* const RAMECC1_M3FAR_PTR_t;    /** @brief M3FAR register pointer type. */
    typedef uint32_t* const RAMECC1_M3FDRL_PTR_t;   /** @brief M3FDRL register pointer type. */
    typedef uint32_t* const RAMECC1_M3FDRH_PTR_t;   /** @brief M3FDRH register pointer type. */
    typedef uint32_t* const RAMECC1_M3FECR_PTR_t;   /** @brief M3FECR register pointer type. */
    typedef uint32_t* const RAMECC1_M4CR_PTR_t;     /** @brief M4CR register pointer type. */
    typedef uint32_t* const RAMECC1_M4SR_PTR_t;     /** @brief M4SR register pointer type. */
    typedef uint32_t* const RAMECC1_M4FAR_PTR_t;    /** @brief M4FAR register pointer type. */
    typedef uint32_t* const RAMECC1_M4FDRL_PTR_t;   /** @brief M4FDRL register pointer type. */
    typedef uint32_t* const RAMECC1_M4FDRH_PTR_t;   /** @brief M4FDRH register pointer type. */
    typedef uint32_t* const RAMECC1_M4FECR_PTR_t;   /** @brief M4FECR register pointer type. */
    typedef uint32_t* const RAMECC1_M5CR_PTR_t;     /** @brief M5CR register pointer type. */
    typedef uint32_t* const RAMECC1_M5SR_PTR_t;     /** @brief M5SR register pointer type. */
    typedef uint32_t* const RAMECC1_M5FAR_PTR_t;    /** @brief M5FAR register pointer type. */
    typedef uint32_t* const RAMECC1_M5FDRL_PTR_t;   /** @brief M5FDRL register pointer type. */
    typedef uint32_t* const RAMECC1_M5FDRH_PTR_t;   /** @brief M5FDRH register pointer type. */
    typedef uint32_t* const RAMECC1_M5FECR_PTR_t;   /** @brief M5FECR register pointer type. */

    /**** @subsection RAMECC1 Register Field Masks ****/

    static const uint32_t RAMECC1_IER_GIE_MASK            = 0x00000001U;   /** @brief Global interrupt enable */
    static const uint32_t RAMECC1_IER_GECCSEIE__MASK      = 0x00000002U;   /** @brief Global ECC single error interrupt enable */
    static const uint32_t RAMECC1_IER_GECCDEIE_MASK       = 0x00000004U;   /** @brief Global ECC double error interrupt enable */
    static const uint32_t RAMECC1_IER_GECCDEBWIE_MASK     = 0x00000008U;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCSEIE_MASK       = 0x00000004U;   /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCDEIE_MASK       = 0x00000008U;   /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCDEBWIE_MASK     = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCELEN_MASK       = 0x00000020U;   /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1SR_ECCSEIE_MASK       = 0x00000004U;   /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1SR_ECCDEIE_MASK       = 0x00000008U;   /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1SR_ECCDEBWIE_MASK     = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1SR_ECCELEN_MASK       = 0x00000020U;   /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FAR_ECCSEIE_MASK      = 0x00000004U;   /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1FAR_ECCDEIE_MASK      = 0x00000008U;   /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1FAR_ECCDEBWIE_MASK    = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1FAR_ECCELEN_MASK      = 0x00000020U;   /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FDRL_ECCSEIE_MASK     = 0x00000004U;   /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1FDRL_ECCDEIE_MASK     = 0x00000008U;   /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1FDRL_ECCDEBWIE_MASK   = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1FDRL_ECCELEN_MASK     = 0x00000020U;   /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FDRH_ECCSEIE_MASK     = 0x00000004U;   /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1FDRH_ECCDEIE_MASK     = 0x00000008U;   /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1FDRH_ECCDEBWIE_MASK   = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1FDRH_ECCELEN_MASK     = 0x00000020U;   /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FECR_SEDCF_MASK       = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M1FECR_DEDF_MASK        = 0x00000002U;   /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M1FECR_DEBWDF_MASK      = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2CR_SEDCF_MASK         = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2CR_DEDF_MASK          = 0x00000002U;   /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2CR_DEBWDF_MASK        = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2SR_SEDCF_MASK         = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2SR_DEDF_MASK          = 0x00000002U;   /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2SR_DEBWDF_MASK        = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2FAR_SEDCF_MASK        = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2FAR_DEDF_MASK         = 0x00000002U;   /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2FAR_DEBWDF_MASK       = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2FDRL_SEDCF_MASK       = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2FDRL_DEDF_MASK        = 0x00000002U;   /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2FDRL_DEBWDF_MASK      = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */

    /**** @subsection RAMECC1 Register Field Positions ****/

    static const int32_t RAMECC1_IER_GIE_POS            = 0;   /** @brief Global interrupt enable */
    static const int32_t RAMECC1_IER_GECCSEIE__POS      = 1;   /** @brief Global ECC single error interrupt enable */
    static const int32_t RAMECC1_IER_GECCDEIE_POS       = 2;   /** @brief Global ECC double error interrupt enable */
    static const int32_t RAMECC1_IER_GECCDEBWIE_POS     = 3;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_M1CR_ECCSEIE_POS       = 2;   /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_M1CR_ECCDEIE_POS       = 3;   /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_M1CR_ECCDEBWIE_POS     = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_M1CR_ECCELEN_POS       = 5;   /** @brief ECC error latching enable */
    static const int32_t RAMECC1_M1SR_ECCSEIE_POS       = 2;   /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_M1SR_ECCDEIE_POS       = 3;   /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_M1SR_ECCDEBWIE_POS     = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_M1SR_ECCELEN_POS       = 5;   /** @brief ECC error latching enable */
    static const int32_t RAMECC1_M1FAR_ECCSEIE_POS      = 2;   /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_M1FAR_ECCDEIE_POS      = 3;   /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_M1FAR_ECCDEBWIE_POS    = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_M1FAR_ECCELEN_POS      = 5;   /** @brief ECC error latching enable */
    static const int32_t RAMECC1_M1FDRL_ECCSEIE_POS     = 2;   /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_M1FDRL_ECCDEIE_POS     = 3;   /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_M1FDRL_ECCDEBWIE_POS   = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_M1FDRL_ECCELEN_POS     = 5;   /** @brief ECC error latching enable */
    static const int32_t RAMECC1_M1FDRH_ECCSEIE_POS     = 2;   /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_M1FDRH_ECCDEIE_POS     = 3;   /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_M1FDRH_ECCDEBWIE_POS   = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_M1FDRH_ECCELEN_POS     = 5;   /** @brief ECC error latching enable */
    static const int32_t RAMECC1_M1FECR_SEDCF_POS       = 0;   /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_M1FECR_DEDF_POS        = 1;   /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_M1FECR_DEBWDF_POS      = 2;   /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_M2CR_SEDCF_POS         = 0;   /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_M2CR_DEDF_POS          = 1;   /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_M2CR_DEBWDF_POS        = 2;   /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_M2SR_SEDCF_POS         = 0;   /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_M2SR_DEDF_POS          = 1;   /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_M2SR_DEBWDF_POS        = 2;   /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_M2FAR_SEDCF_POS        = 0;   /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_M2FAR_DEDF_POS         = 1;   /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_M2FAR_DEBWDF_POS       = 2;   /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_M2FDRL_SEDCF_POS       = 0;   /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_M2FDRL_DEDF_POS        = 1;   /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_M2FDRL_DEBWDF_POS      = 2;   /** @brief ECC double error on byte write (BW) detected flag */

    /**********************************************************************************************
     * @section RAMECC2 Register Information
     **********************************************************************************************/

    /**** @subsection RAMECC2 Register Pointers ****/

    static RW_ uint32_t* const RAMECC2_IER_PTR      = (RW_ uint32_t* const)0x48023000U;   /** @brief RAMECC interrupt enable register */
    static RO_ uint32_t* const RAMECC2_M1FAR_PTR    = (RO_ uint32_t* const)0x48023028U;   /** @brief RAMECC monitor x failing address register */
    static RO_ uint32_t* const RAMECC2_M2FAR_PTR    = (RO_ uint32_t* const)0x48023048U;   /** @brief RAMECC monitor x failing address register */
    static RO_ uint32_t* const RAMECC2_M3FAR_PTR    = (RO_ uint32_t* const)0x48023068U;   /** @brief RAMECC monitor x failing address register */
    static RO_ uint32_t* const RAMECC2_M4FAR_PTR    = (RO_ uint32_t* const)0x48023088U;   /** @brief RAMECC monitor x failing address register */
    static RW_ uint32_t* const RAMECC2_M5FAR_PTR    = (RW_ uint32_t* const)0x480230A8U;   /** @brief RAMECC monitor x failing address register */
    static RO_ uint32_t* const RAMECC2_M1FDRH_PTR   = (RO_ uint32_t* const)0x48023030U;   /** @brief RAMECC monitor x failing data high register */
    static RW_ uint32_t* const RAMECC2_M2FDRH_PTR   = (RW_ uint32_t* const)0x48023050U;   /** @brief RAMECC monitor x failing data high register */
    static RO_ uint32_t* const RAMECC2_M3FDRH_PTR   = (RO_ uint32_t* const)0x48023070U;   /** @brief RAMECC monitor x failing data high register */
    static RO_ uint32_t* const RAMECC2_M4FDRH_PTR   = (RO_ uint32_t* const)0x48023090U;   /** @brief RAMECC monitor x failing data high register */
    static RO_ uint32_t* const RAMECC2_M5FDRH_PTR   = (RO_ uint32_t* const)0x480230B0U;   /** @brief RAMECC monitor x failing data high register */
    static RW_ uint32_t* const RAMECC2_M1FECR_PTR   = (RW_ uint32_t* const)0x48023034U;   /** @brief RAMECC monitor x failing ECC error code register */
    static RW_ uint32_t* const RAMECC2_M2FECR_PTR   = (RW_ uint32_t* const)0x48023058U;   /** @brief RAMECC monitor x failing ECC error code register */
    static RO_ uint32_t* const RAMECC2_M3FECR_PTR   = (RO_ uint32_t* const)0x4802307CU;   /** @brief RAMECC monitor x failing ECC error code register */
    static RO_ uint32_t* const RAMECC2_M4FECR_PTR   = (RO_ uint32_t* const)0x48023090U;   /** @brief RAMECC monitor x failing ECC error code register */
    static RO_ uint32_t* const RAMECC2_M5FECR_PTR   = (RO_ uint32_t* const)0x480230B4U;   /** @brief RAMECC monitor x failing ECC error code register */

    /**** @subsection Enumerated RAMECC2 Register Pointers ****/

    static RW_ uint32_t* const RAMECC2_MxCR_PTR[6] = {
      [1] = (RW_ uint32_t* const)0x48023020U,   /** @brief RAMECC monitor x configuration register */
      [2] = (RW_ uint32_t* const)0x48023040U,   /** @brief RAMECC monitor x configuration register */
      [3] = (RW_ uint32_t* const)0x48023060U,   /** @brief RAMECC monitor x configuration register */
      [4] = (RW_ uint32_t* const)0x48023080U,   /** @brief RAMECC monitor x configuration register */
      [5] = (RW_ uint32_t* const)0x480230A0U,   /** @brief RAMECC monitor x configuration register */
    };

    static RW_ uint32_t* const RAMECC2_MxSR_PTR[6] = {
      [1] = (RW_ uint32_t* const)0x48023024U,   /** @brief RAMECC monitor x status register */
      [2] = (RW_ uint32_t* const)0x48023044U,   /** @brief RAMECC monitor x status register */
      [3] = (RW_ uint32_t* const)0x48023064U,   /** @brief RAMECC monitor x status register */
      [4] = (RW_ uint32_t* const)0x48023084U,   /** @brief RAMECC monitor x status register */
      [5] = (RW_ uint32_t* const)0x480230A4U,   /** @brief RAMECC monitor x status register */
    };

    static RO_ uint32_t* const RAMECC2_MxFDRL_PTR[6] = {
      [1] = (RO_ uint32_t* const)0x4802302CU,   /** @brief RAMECC monitor x failing data low register */
      [2] = (RO_ uint32_t* const)0x4802304CU,   /** @brief RAMECC monitor x failing data low register */
      [3] = (RO_ uint32_t* const)0x4802306CU,   /** @brief RAMECC monitor x failing data low register */
      [4] = (RO_ uint32_t* const)0x4802308CU,   /** @brief RAMECC monitor x failing data low register */
      [5] = (RO_ uint32_t* const)0x480230ACU,   /** @brief RAMECC monitor x failing data low register */
    };

    /**** @subsection RAMECC2 Register Reset Values ****/

    static const uint32_t RAMECC2_IER_RST      = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t RAMECC2_M1FAR_RST    = 0x00000000U;   /** @brief M1FAR register reset value. */
    static const uint32_t RAMECC2_M2FAR_RST    = 0x00000000U;   /** @brief M2FAR register reset value. */
    static const uint32_t RAMECC2_M3FAR_RST    = 0x00000000U;   /** @brief M3FAR register reset value. */
    static const uint32_t RAMECC2_M4FAR_RST    = 0x00000000U;   /** @brief M4FAR register reset value. */
    static const uint32_t RAMECC2_M5FAR_RST    = 0x00000000U;   /** @brief M5FAR register reset value. */
    static const uint32_t RAMECC2_M1FDRH_RST   = 0x00000000U;   /** @brief M1FDRH register reset value. */
    static const uint32_t RAMECC2_M2FDRH_RST   = 0x00000000U;   /** @brief M2FDRH register reset value. */
    static const uint32_t RAMECC2_M3FDRH_RST   = 0x00000000U;   /** @brief M3FDRH register reset value. */
    static const uint32_t RAMECC2_M4FDRH_RST   = 0x00000000U;   /** @brief M4FDRH register reset value. */
    static const uint32_t RAMECC2_M5FDRH_RST   = 0x00000000U;   /** @brief M5FDRH register reset value. */
    static const uint32_t RAMECC2_M1FECR_RST   = 0x00000000U;   /** @brief M1FECR register reset value. */
    static const uint32_t RAMECC2_M2FECR_RST   = 0x00000000U;   /** @brief M2FECR register reset value. */
    static const uint32_t RAMECC2_M3FECR_RST   = 0x00000000U;   /** @brief M3FECR register reset value. */
    static const uint32_t RAMECC2_M4FECR_RST   = 0x00000000U;   /** @brief M4FECR register reset value. */
    static const uint32_t RAMECC2_M5FECR_RST   = 0x00000000U;   /** @brief M5FECR register reset value. */

    /**** @subsection Enumerated RAMECC2 Register Reset Values ****/

    static const uint32_t RAMECC2_MxCR_RST[6] = {
      [1] = 0x00000000U,   /** @brief M1CR register reset value. */
      [2] = 0x00000000U,   /** @brief M2CR register reset value. */
      [3] = 0x00000000U,   /** @brief M3CR register reset value. */
      [4] = 0x00000000U,   /** @brief M4CR register reset value. */
      [5] = 0x00000000U,   /** @brief M5CR register reset value. */
    };

    static const uint32_t RAMECC2_MxSR_RST[6] = {
      [1] = 0x00000000U,   /** @brief M1SR register reset value. */
      [2] = 0x00000000U,   /** @brief M2SR register reset value. */
      [3] = 0x00000000U,   /** @brief M3SR register reset value. */
      [4] = 0x00000000U,   /** @brief M4SR register reset value. */
      [5] = 0x00000000U,   /** @brief M5SR register reset value. */
    };

    static const uint32_t RAMECC2_MxFDRL_RST[6] = {
      [1] = 0x00000000U,   /** @brief M1FDRL register reset value. */
      [2] = 0x00000000U,   /** @brief M2FDRL register reset value. */
      [3] = 0x00000000U,   /** @brief M3FDRL register reset value. */
      [4] = 0x00000000U,   /** @brief M4FDRL register reset value. */
      [5] = 0x00000000U,   /** @brief M5FDRL register reset value. */
    };

    /**** @subsection Enumerated RAMECC2 Register Value Types ****/

    typedef uint32_t RAMECC2_IER_t;      /** @brief IER register value type. */
    typedef uint32_t RAMECC2_MxCR_t;     /** @brief MxCR register value type. */
    typedef uint32_t RAMECC2_MxSR_t;     /** @brief MxSR register value type. */
    typedef uint32_t RAMECC2_M1FAR_t;    /** @brief M1FAR register value type. */
    typedef uint32_t RAMECC2_M2FAR_t;    /** @brief M2FAR register value type. */
    typedef uint32_t RAMECC2_M3FAR_t;    /** @brief M3FAR register value type. */
    typedef uint32_t RAMECC2_M4FAR_t;    /** @brief M4FAR register value type. */
    typedef uint32_t RAMECC2_M5FAR_t;    /** @brief M5FAR register value type. */
    typedef uint32_t RAMECC2_MxFDRL_t;   /** @brief MxFDRL register value type. */
    typedef uint32_t RAMECC2_M1FDRH_t;   /** @brief M1FDRH register value type. */
    typedef uint32_t RAMECC2_M2FDRH_t;   /** @brief M2FDRH register value type. */
    typedef uint32_t RAMECC2_M3FDRH_t;   /** @brief M3FDRH register value type. */
    typedef uint32_t RAMECC2_M4FDRH_t;   /** @brief M4FDRH register value type. */
    typedef uint32_t RAMECC2_M5FDRH_t;   /** @brief M5FDRH register value type. */
    typedef uint32_t RAMECC2_M1FECR_t;   /** @brief M1FECR register value type. */
    typedef uint32_t RAMECC2_M2FECR_t;   /** @brief M2FECR register value type. */
    typedef uint32_t RAMECC2_M3FECR_t;   /** @brief M3FECR register value type. */
    typedef uint32_t RAMECC2_M4FECR_t;   /** @brief M4FECR register value type. */
    typedef uint32_t RAMECC2_M5FECR_t;   /** @brief M5FECR register value type. */

    /**** @subsection Enumerated RAMECC2 Register Pointer Types ****/

    typedef uint32_t* const RAMECC2_IER_PTR_t;      /** @brief IER register pointer type. */
    typedef uint32_t* const RAMECC2_MxCR_PTR_t;     /** @brief MxCR register pointer type. */
    typedef uint32_t* const RAMECC2_MxSR_PTR_t;     /** @brief MxSR register pointer type. */
    typedef uint32_t* const RAMECC2_M1FAR_PTR_t;    /** @brief M1FAR register pointer type. */
    typedef uint32_t* const RAMECC2_M2FAR_PTR_t;    /** @brief M2FAR register pointer type. */
    typedef uint32_t* const RAMECC2_M3FAR_PTR_t;    /** @brief M3FAR register pointer type. */
    typedef uint32_t* const RAMECC2_M4FAR_PTR_t;    /** @brief M4FAR register pointer type. */
    typedef uint32_t* const RAMECC2_M5FAR_PTR_t;    /** @brief M5FAR register pointer type. */
    typedef uint32_t* const RAMECC2_MxFDRL_PTR_t;   /** @brief MxFDRL register pointer type. */
    typedef uint32_t* const RAMECC2_M1FDRH_PTR_t;   /** @brief M1FDRH register pointer type. */
    typedef uint32_t* const RAMECC2_M2FDRH_PTR_t;   /** @brief M2FDRH register pointer type. */
    typedef uint32_t* const RAMECC2_M3FDRH_PTR_t;   /** @brief M3FDRH register pointer type. */
    typedef uint32_t* const RAMECC2_M4FDRH_PTR_t;   /** @brief M4FDRH register pointer type. */
    typedef uint32_t* const RAMECC2_M5FDRH_PTR_t;   /** @brief M5FDRH register pointer type. */
    typedef uint32_t* const RAMECC2_M1FECR_PTR_t;   /** @brief M1FECR register pointer type. */
    typedef uint32_t* const RAMECC2_M2FECR_PTR_t;   /** @brief M2FECR register pointer type. */
    typedef uint32_t* const RAMECC2_M3FECR_PTR_t;   /** @brief M3FECR register pointer type. */
    typedef uint32_t* const RAMECC2_M4FECR_PTR_t;   /** @brief M4FECR register pointer type. */
    typedef uint32_t* const RAMECC2_M5FECR_PTR_t;   /** @brief M5FECR register pointer type. */

    /**** @subsection RAMECC2 Register Field Masks ****/

    static const uint32_t RAMECC2_IER_GIE_MASK          = 0x00000001U;   /** @brief Global interrupt enable */
    static const uint32_t RAMECC2_IER_GECCSEIE__MASK    = 0x00000002U;   /** @brief Global ECC single error interrupt enable */
    static const uint32_t RAMECC2_IER_GECCDEIE_MASK     = 0x00000004U;   /** @brief Global ECC double error interrupt enable */
    static const uint32_t RAMECC2_IER_GECCDEBWIE_MASK   = 0x00000008U;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MxCR_ECCSEIE_MASK     = 0x00000004U;   /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC2_MxCR_ECCDEIE_MASK     = 0x00000008U;   /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC2_MxCR_ECCDEBWIE_MASK   = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MxCR_ECCELEN_MASK     = 0x00000020U;   /** @brief ECC error latching enable */
    static const uint32_t RAMECC2_MxSR_SEDCF_MASK       = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC2_MxSR_DEDF_MASK        = 0x00000002U;   /** @brief ECC double error detected flag */
    static const uint32_t RAMECC2_MxSR_DEBWDF_MASK      = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */

    /**** @subsection RAMECC2 Register Field Positions ****/

    static const int32_t RAMECC2_IER_GIE_POS          = 0;   /** @brief Global interrupt enable */
    static const int32_t RAMECC2_IER_GECCSEIE__POS    = 1;   /** @brief Global ECC single error interrupt enable */
    static const int32_t RAMECC2_IER_GECCDEIE_POS     = 2;   /** @brief Global ECC double error interrupt enable */
    static const int32_t RAMECC2_IER_GECCDEBWIE_POS   = 3;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MxCR_ECCSEIE_POS     = 2;   /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC2_MxCR_ECCDEIE_POS     = 3;   /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC2_MxCR_ECCDEBWIE_POS   = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MxCR_ECCELEN_POS     = 5;   /** @brief ECC error latching enable */
    static const int32_t RAMECC2_MxSR_SEDCF_POS       = 0;   /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC2_MxSR_DEDF_POS        = 1;   /** @brief ECC double error detected flag */
    static const int32_t RAMECC2_MxSR_DEBWDF_POS      = 2;   /** @brief ECC double error on byte write (BW) detected flag */

    /**********************************************************************************************
     * @section RAMECC3 Register Information
     **********************************************************************************************/

    /**** @subsection RAMECC3 Register Pointers ****/

    static RW_ uint32_t* const RAMECC3_IER_PTR      = (RW_ uint32_t* const)0x58027000U;   /** @brief RAMECC interrupt enable register */
    static RO_ uint32_t* const RAMECC3_M1FDRH_PTR   = (RO_ uint32_t* const)0x58027030U;   /** @brief RAMECC monitor x failing data high register */
    static RW_ uint32_t* const RAMECC3_M2FDRH_PTR   = (RW_ uint32_t* const)0x58027050U;   /** @brief RAMECC monitor x failing data high register */

    /**** @subsection Enumerated RAMECC3 Register Pointers ****/

    static RW_ uint32_t* const RAMECC3_MxCR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x58027020U,   /** @brief RAMECC monitor x configuration register */
      [2] = (RW_ uint32_t* const)0x58027040U,   /** @brief RAMECC monitor x configuration register */
    };

    static RW_ uint32_t* const RAMECC3_MxSR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x58027024U,   /** @brief RAMECC monitor x status register */
      [2] = (RW_ uint32_t* const)0x58027044U,   /** @brief RAMECC monitor x status register */
    };

    static RO_ uint32_t* const RAMECC3_MxFAR_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x58027028U,   /** @brief RAMECC monitor x failing address register */
      [2] = (RO_ uint32_t* const)0x58027048U,   /** @brief RAMECC monitor x failing address register */
    };

    static RO_ uint32_t* const RAMECC3_MxFDRL_PTR[3] = {
      [1] = (RO_ uint32_t* const)0x5802702CU,   /** @brief RAMECC monitor x failing data low register */
      [2] = (RO_ uint32_t* const)0x5802704CU,   /** @brief RAMECC monitor x failing data low register */
    };

    static RW_ uint32_t* const RAMECC3_MxFECR_PTR[3] = {
      [1] = (RW_ uint32_t* const)0x58027034U,   /** @brief RAMECC monitor x failing ECC error code register */
      [2] = (RW_ uint32_t* const)0x58027058U,   /** @brief RAMECC monitor x failing ECC error code register */
    };

    /**** @subsection RAMECC3 Register Reset Values ****/

    static const uint32_t RAMECC3_IER_RST      = 0x00000000U;   /** @brief IER register reset value. */
    static const uint32_t RAMECC3_M1FDRH_RST   = 0x00000000U;   /** @brief M1FDRH register reset value. */
    static const uint32_t RAMECC3_M2FDRH_RST   = 0x00000000U;   /** @brief M2FDRH register reset value. */

    /**** @subsection Enumerated RAMECC3 Register Reset Values ****/

    static const uint32_t RAMECC3_MxCR_RST[3] = {
      [1] = 0x00000000U,   /** @brief M1CR register reset value. */
      [2] = 0x00000000U,   /** @brief M2CR register reset value. */
    };

    static const uint32_t RAMECC3_MxSR_RST[3] = {
      [1] = 0x00000000U,   /** @brief M1SR register reset value. */
      [2] = 0x00000000U,   /** @brief M2SR register reset value. */
    };

    static const uint32_t RAMECC3_MxFAR_RST[3] = {
      [1] = 0x00000000U,   /** @brief M1FAR register reset value. */
      [2] = 0x00000000U,   /** @brief M2FAR register reset value. */
    };

    static const uint32_t RAMECC3_MxFDRL_RST[3] = {
      [1] = 0x00000000U,   /** @brief M1FDRL register reset value. */
      [2] = 0x00000000U,   /** @brief M2FDRL register reset value. */
    };

    static const uint32_t RAMECC3_MxFECR_RST[3] = {
      [1] = 0x00000000U,   /** @brief M1FECR register reset value. */
      [2] = 0x00000000U,   /** @brief M2FECR register reset value. */
    };

    /**** @subsection Enumerated RAMECC3 Register Value Types ****/

    typedef uint32_t RAMECC3_IER_t;      /** @brief IER register value type. */
    typedef uint32_t RAMECC3_MxCR_t;     /** @brief MxCR register value type. */
    typedef uint32_t RAMECC3_MxSR_t;     /** @brief MxSR register value type. */
    typedef uint32_t RAMECC3_MxFAR_t;    /** @brief MxFAR register value type. */
    typedef uint32_t RAMECC3_MxFDRL_t;   /** @brief MxFDRL register value type. */
    typedef uint32_t RAMECC3_M1FDRH_t;   /** @brief M1FDRH register value type. */
    typedef uint32_t RAMECC3_M2FDRH_t;   /** @brief M2FDRH register value type. */
    typedef uint32_t RAMECC3_MxFECR_t;   /** @brief MxFECR register value type. */

    /**** @subsection Enumerated RAMECC3 Register Pointer Types ****/

    typedef uint32_t* const RAMECC3_IER_PTR_t;      /** @brief IER register pointer type. */
    typedef uint32_t* const RAMECC3_MxCR_PTR_t;     /** @brief MxCR register pointer type. */
    typedef uint32_t* const RAMECC3_MxSR_PTR_t;     /** @brief MxSR register pointer type. */
    typedef uint32_t* const RAMECC3_MxFAR_PTR_t;    /** @brief MxFAR register pointer type. */
    typedef uint32_t* const RAMECC3_MxFDRL_PTR_t;   /** @brief MxFDRL register pointer type. */
    typedef uint32_t* const RAMECC3_M1FDRH_PTR_t;   /** @brief M1FDRH register pointer type. */
    typedef uint32_t* const RAMECC3_M2FDRH_PTR_t;   /** @brief M2FDRH register pointer type. */
    typedef uint32_t* const RAMECC3_MxFECR_PTR_t;   /** @brief MxFECR register pointer type. */

    /**** @subsection RAMECC3 Register Field Masks ****/

    static const uint32_t RAMECC3_IER_GIE_MASK          = 0x00000001U;   /** @brief Global interrupt enable */
    static const uint32_t RAMECC3_IER_GECCSEIE__MASK    = 0x00000002U;   /** @brief Global ECC single error interrupt enable */
    static const uint32_t RAMECC3_IER_GECCDEIE_MASK     = 0x00000004U;   /** @brief Global ECC double error interrupt enable */
    static const uint32_t RAMECC3_IER_GECCDEBWIE_MASK   = 0x00000008U;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC3_MxCR_ECCSEIE_MASK     = 0x00000004U;   /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC3_MxCR_ECCDEIE_MASK     = 0x00000008U;   /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC3_MxCR_ECCDEBWIE_MASK   = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC3_MxCR_ECCELEN_MASK     = 0x00000020U;   /** @brief ECC error latching enable */
    static const uint32_t RAMECC3_MxSR_SEDCF_MASK       = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC3_MxSR_DEDF_MASK        = 0x00000002U;   /** @brief ECC double error detected flag */
    static const uint32_t RAMECC3_MxSR_DEBWDF_MASK      = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */

    /**** @subsection RAMECC3 Register Field Positions ****/

    static const int32_t RAMECC3_IER_GIE_POS          = 0;   /** @brief Global interrupt enable */
    static const int32_t RAMECC3_IER_GECCSEIE__POS    = 1;   /** @brief Global ECC single error interrupt enable */
    static const int32_t RAMECC3_IER_GECCDEIE_POS     = 2;   /** @brief Global ECC double error interrupt enable */
    static const int32_t RAMECC3_IER_GECCDEBWIE_POS   = 3;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC3_MxCR_ECCSEIE_POS     = 2;   /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC3_MxCR_ECCDEIE_POS     = 3;   /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC3_MxCR_ECCDEBWIE_POS   = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC3_MxCR_ECCELEN_POS     = 5;   /** @brief ECC error latching enable */
    static const int32_t RAMECC3_MxSR_SEDCF_POS       = 0;   /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC3_MxSR_DEDF_POS        = 1;   /** @brief ECC double error detected flag */
    static const int32_t RAMECC3_MxSR_DEBWDF_POS      = 2;   /** @brief ECC double error on byte write (BW) detected flag */

    /**********************************************************************************************
     * @section ART Register Information
     **********************************************************************************************/

    /**** @subsection ART Register Pointers ****/

    static RW_ uint32_t* const ART_CTR_PTR   = (RW_ uint32_t* const)0x40024400U;   /** @brief Control register */

    /**** @subsection ART Register Reset Values ****/

    static const uint32_t ART_CTR_RST   = 0x00000004U;   /** @brief CTR register reset value. */

    /**** @subsection Enumerated ART Register Value Types ****/

    typedef uint32_t ART_CTR_t;   /** @brief CTR register value type. */

    /**** @subsection Enumerated ART Register Pointer Types ****/

    typedef uint32_t* const ART_CTR_PTR_t;   /** @brief CTR register pointer type. */

    /**** @subsection ART Register Field Masks ****/

    static const uint32_t ART_CTR_EN_MASK           = 0x00000001U;   /** @brief Cache enable */
    static const uint32_t ART_CTR_PCACHEADDR_MASK   = 0x000FFF00U;   /** @brief Cacheable page index */

    /**** @subsection ART Register Field Positions ****/

    static const int32_t ART_CTR_EN_POS           = 0;   /** @brief Cache enable */
    static const int32_t ART_CTR_PCACHEADDR_POS   = 8;   /** @brief Cacheable page index */

