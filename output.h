    #include <stdint.h>

    #define _RO const volatile
    #define _RW volatile
    /**********************************************************************************************
     * @section COMP1 Definitions
     **********************************************************************************************/

    /** @subsection COMP1 IRQ interrupt definitions */

    static const int32_t COMP_IRQ = INT32_C(137);   /** @brief COMP1 and COMP2 */

    /** @subsection COMP1 register definitions */

    static _RO uint32_t* const COMP1_SR_REG = (_RO uint32_t* const)UINT32_C(0x58003800);      /** @brief Comparator status register */
    static _RW uint32_t* const COMP1_ICFR_REG = (_RW uint32_t* const)UINT32_C(0x58003804);    /** @brief Comparator interrupt clear flag register */
    static _RW uint32_t* const COMP1_OR_REG = (_RW uint32_t* const)UINT32_C(0x58003808);      /** @brief Comparator option register */
    static _RW uint32_t* const COMP1_CFGR1_REG = (_RW uint32_t* const)UINT32_C(0x5800380C);   /** @brief Comparator configuration register 1 */
    static _RW uint32_t* const COMP1_CFGR2_REG = (_RW uint32_t* const)UINT32_C(0x58003810);   /** @brief Comparator configuration register 2 */

    /** @subsection COMP1 field mask definitions */

    static const uint32_t COMP1_SR_C1VAL_MASK = UINT32_C(0x00000001);         /** @brief COMP channel 1 output status bit */
    static const uint32_t COMP1_SR_C2VAL_MASK = UINT32_C(0x00000002);         /** @brief COMP channel 2 output status bit */
    static const uint32_t COMP1_SR_C1IF_MASK = UINT32_C(0x00010000);          /** @brief COMP channel 1 interrupt flag */
    static const uint32_t COMP1_SR_C2IF_MASK = UINT32_C(0x00020000);          /** @brief COMP channel 2 interrupt flag */
    static const uint32_t COMP1_ICFR_CC1IF_MASK = UINT32_C(0x00010000);       /** @brief Clear COMP channel 1 interrupt flag */
    static const uint32_t COMP1_ICFR_CC2IF_MASK = UINT32_C(0x00020000);       /** @brief Clear COMP channel 2 interrupt flag */
    static const uint32_t COMP1_OR_AFOP_MASK = UINT32_C(0x000007FF);          /** @brief Selection of source for alternate function of output ports */
    static const uint32_t COMP1_OR_OR_MASK = UINT32_C(0xFFFFF800);            /** @brief Option register */
    static const uint32_t COMP1_CFGR1_EN_MASK = UINT32_C(0x00000001);         /** @brief COMP channel 1 enable bit */
    static const uint32_t COMP1_CFGR1_BRGEN_MASK = UINT32_C(0x00000002);      /** @brief Scaler bridge enable */
    static const uint32_t COMP1_CFGR1_SCALEN_MASK = UINT32_C(0x00000004);     /** @brief Voltage scaler enable bit */
    static const uint32_t COMP1_CFGR1_POLARITY_MASK = UINT32_C(0x00000008);   /** @brief COMP channel 1 polarity selection bit */
    static const uint32_t COMP1_CFGR1_ITEN_MASK = UINT32_C(0x00000040);       /** @brief COMP channel 1 interrupt enable */
    static const uint32_t COMP1_CFGR1_HYST_MASK = UINT32_C(0x00000300);       /** @brief COMP channel 1 hysteresis selection bits */
    static const uint32_t COMP1_CFGR1_PWRMODE_MASK = UINT32_C(0x00003000);    /** @brief Power mode of the COMP channel 1 */
    static const uint32_t COMP1_CFGR1_INMSEL_MASK = UINT32_C(0x00070000);     /** @brief COMP channel 1 inverting input selection field */
    static const uint32_t COMP1_CFGR1_INPSEL_MASK = UINT32_C(0x00100000);     /** @brief COMP channel 1 non-inverting input selection bit */
    static const uint32_t COMP1_CFGR1_BLANKING_MASK = UINT32_C(0x0F000000);   /** @brief COMP channel 1 blanking source selection bits */
    static const uint32_t COMP1_CFGR1_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock bit */
    static const uint32_t COMP1_CFGR2_EN_MASK = UINT32_C(0x00000001);         /** @brief COMP channel 1 enable bit */
    static const uint32_t COMP1_CFGR2_BRGEN_MASK = UINT32_C(0x00000002);      /** @brief Scaler bridge enable */
    static const uint32_t COMP1_CFGR2_SCALEN_MASK = UINT32_C(0x00000004);     /** @brief Voltage scaler enable bit */
    static const uint32_t COMP1_CFGR2_POLARITY_MASK = UINT32_C(0x00000008);   /** @brief COMP channel 1 polarity selection bit */
    static const uint32_t COMP1_CFGR2_WINMODE_MASK = UINT32_C(0x00000010);    /** @brief Window comparator mode selection bit */
    static const uint32_t COMP1_CFGR2_ITEN_MASK = UINT32_C(0x00000040);       /** @brief COMP channel 1 interrupt enable */
    static const uint32_t COMP1_CFGR2_HYST_MASK = UINT32_C(0x00000300);       /** @brief COMP channel 1 hysteresis selection bits */
    static const uint32_t COMP1_CFGR2_PWRMODE_MASK = UINT32_C(0x00003000);    /** @brief Power mode of the COMP channel 1 */
    static const uint32_t COMP1_CFGR2_INMSEL_MASK = UINT32_C(0x00070000);     /** @brief COMP channel 1 inverting input selection field */
    static const uint32_t COMP1_CFGR2_INPSEL_MASK = UINT32_C(0x00100000);     /** @brief COMP channel 1 non-inverting input selection bit */
    static const uint32_t COMP1_CFGR2_BLANKING_MASK = UINT32_C(0x0F000000);   /** @brief COMP channel 1 blanking source selection bits */
    static const uint32_t COMP1_CFGR2_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock bit */

    /** @subsection COMP1 field position definitions */

    static const int32_t COMP1_CFGR2_C1VAL_POS = INT32_C(0);       /** @brief COMP channel 1 output status bit */
    static const int32_t COMP1_CFGR2_C2VAL_POS = INT32_C(1);       /** @brief COMP channel 2 output status bit */
    static const int32_t COMP1_CFGR2_C1IF_POS = INT32_C(16);       /** @brief COMP channel 1 interrupt flag */
    static const int32_t COMP1_CFGR2_C2IF_POS = INT32_C(17);       /** @brief COMP channel 2 interrupt flag */
    static const int32_t COMP1_CFGR2_CC1IF_POS = INT32_C(16);      /** @brief Clear COMP channel 1 interrupt flag */
    static const int32_t COMP1_CFGR2_CC2IF_POS = INT32_C(17);      /** @brief Clear COMP channel 2 interrupt flag */
    static const int32_t COMP1_CFGR2_AFOP_POS = INT32_C(0);        /** @brief Selection of source for alternate function of output ports */
    static const int32_t COMP1_CFGR2_OR_POS = INT32_C(11);         /** @brief Option register */
    static const int32_t COMP1_CFGR2_EN_POS = INT32_C(0);          /** @brief COMP channel 1 enable bit */
    static const int32_t COMP1_CFGR2_BRGEN_POS = INT32_C(1);       /** @brief Scaler bridge enable */
    static const int32_t COMP1_CFGR2_SCALEN_POS = INT32_C(2);      /** @brief Voltage scaler enable bit */
    static const int32_t COMP1_CFGR2_POLARITY_POS = INT32_C(3);    /** @brief COMP channel 1 polarity selection bit */
    static const int32_t COMP1_CFGR2_ITEN_POS = INT32_C(6);        /** @brief COMP channel 1 interrupt enable */
    static const int32_t COMP1_CFGR2_HYST_POS = INT32_C(8);        /** @brief COMP channel 1 hysteresis selection bits */
    static const int32_t COMP1_CFGR2_PWRMODE_POS = INT32_C(12);    /** @brief Power mode of the COMP channel 1 */
    static const int32_t COMP1_CFGR2_INMSEL_POS = INT32_C(16);     /** @brief COMP channel 1 inverting input selection field */
    static const int32_t COMP1_CFGR2_INPSEL_POS = INT32_C(20);     /** @brief COMP channel 1 non-inverting input selection bit */
    static const int32_t COMP1_CFGR2_BLANKING_POS = INT32_C(24);   /** @brief COMP channel 1 blanking source selection bits */
    static const int32_t COMP1_CFGR2_LOCK_POS = INT32_C(31);       /** @brief Lock bit */
    static const int32_t COMP1_CFGR2_EN_POS = INT32_C(0);          /** @brief COMP channel 1 enable bit */
    static const int32_t COMP1_CFGR2_BRGEN_POS = INT32_C(1);       /** @brief Scaler bridge enable */
    static const int32_t COMP1_CFGR2_SCALEN_POS = INT32_C(2);      /** @brief Voltage scaler enable bit */
    static const int32_t COMP1_CFGR2_POLARITY_POS = INT32_C(3);    /** @brief COMP channel 1 polarity selection bit */
    static const int32_t COMP1_CFGR2_WINMODE_POS = INT32_C(4);     /** @brief Window comparator mode selection bit */
    static const int32_t COMP1_CFGR2_ITEN_POS = INT32_C(6);        /** @brief COMP channel 1 interrupt enable */
    static const int32_t COMP1_CFGR2_HYST_POS = INT32_C(8);        /** @brief COMP channel 1 hysteresis selection bits */
    static const int32_t COMP1_CFGR2_PWRMODE_POS = INT32_C(12);    /** @brief Power mode of the COMP channel 1 */
    static const int32_t COMP1_CFGR2_INMSEL_POS = INT32_C(16);     /** @brief COMP channel 1 inverting input selection field */
    static const int32_t COMP1_CFGR2_INPSEL_POS = INT32_C(20);     /** @brief COMP channel 1 non-inverting input selection bit */
    static const int32_t COMP1_CFGR2_BLANKING_POS = INT32_C(24);   /** @brief COMP channel 1 blanking source selection bits */
    static const int32_t COMP1_CFGR2_LOCK_POS = INT32_C(31);       /** @brief Lock bit */

    /**********************************************************************************************
     * @section CRS Definitions
     **********************************************************************************************/

    /** @subsection CRS IRQ interrupt definitions */

    static const int32_t CRS_IRQ = INT32_C(144);   /** @brief Clock recovery system globa */

    /** @subsection CRS register definitions */

    static _RW uint32_t* const CRS_CR_REG = (_RW uint32_t* const)UINT32_C(0x40008400);     /** @brief CRS control register */
    static _RW uint32_t* const CRS_CFGR_REG = (_RW uint32_t* const)UINT32_C(0x40008404);   /** @brief This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected. */
    static _RO uint32_t* const CRS_ISR_REG = (_RO uint32_t* const)UINT32_C(0x40008408);    /** @brief CRS interrupt and status register */
    static _RW uint32_t* const CRS_ICR_REG = (_RW uint32_t* const)UINT32_C(0x4000840C);    /** @brief CRS interrupt flag clear register */

    /** @subsection CRS field mask definitions */

    static const uint32_t CRS_CR_SYNCOKIE_MASK = UINT32_C(0x00000001);     /** @brief SYNC event OK interrupt enable */
    static const uint32_t CRS_CR_SYNCWARNIE_MASK = UINT32_C(0x00000002);   /** @brief SYNC warning interrupt enable */
    static const uint32_t CRS_CR_ERRIE_MASK = UINT32_C(0x00000004);        /** @brief Synchronization or trimming error interrupt enable */
    static const uint32_t CRS_CR_ESYNCIE_MASK = UINT32_C(0x00000008);      /** @brief Expected SYNC interrupt enable */
    static const uint32_t CRS_CR_CEN_MASK = UINT32_C(0x00000020);          /** @brief Frequency error counter enable this bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified. */
    static const uint32_t CRS_CR_AUTOTRIMEN_MASK = UINT32_C(0x00000040);   /** @brief Automatic trimming enable this bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details. */
    static const uint32_t CRS_CR_SWSYNC_MASK = UINT32_C(0x00000080);       /** @brief Generate software SYNC event this bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware. */
    static const uint32_t CRS_CR_TRIM_MASK = UINT32_C(0x00003F00);         /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
    static const uint32_t CRS_CFGR_RELOAD_MASK = UINT32_C(0x0000FFFF);     /** @brief Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to section7.3.3: frequency error measurement for more details about counter behavior. */
    static const uint32_t CRS_CFGR_FELIM_MASK = UINT32_C(0x00FF0000);      /** @brief Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP evaluation. */
    static const uint32_t CRS_CFGR_SYNCDIV_MASK = UINT32_C(0x07000000);    /** @brief SYNC divider these bits are set and cleared by software to control the division factor of the SYNC signal. */
    static const uint32_t CRS_CFGR_SYNCSRC_MASK = UINT32_C(0x30000000);    /** @brief SYNC signal source selection these bits are set and cleared by software to select the SYNC signal source. Note: when using USB LPM (link power management) and the device is in sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from sleep mode, the LSE or reference clock on the gpios should be used as SYNC signal. */
    static const uint32_t CRS_CFGR_SYNCPOL_MASK = UINT32_C(0x80000000);    /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
    static const uint32_t CRS_ISR_SYNCOKF_MASK = UINT32_C(0x00000001);     /** @brief SYNC event OK flag this flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_SYNCWARNF_MASK = UINT32_C(0x00000002);   /** @brief SYNC warning flag this flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_ERRF_MASK = UINT32_C(0x00000004);        /** @brief Error flag this flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits. */
    static const uint32_t CRS_ISR_ESYNCF_MASK = UINT32_C(0x00000008);      /** @brief Expected SYNC flag this flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_SYNCERR_MASK = UINT32_C(0x00000100);     /** @brief SYNC error this flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_SYNCMISS_MASK = UINT32_C(0x00000200);    /** @brief SYNC missed this flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_TRIMOVF_MASK = UINT32_C(0x00000400);     /** @brief Trimming overflow or underflow this flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const uint32_t CRS_ISR_FEDIR_MASK = UINT32_C(0x00008000);       /** @brief Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target. */
    static const uint32_t CRS_ISR_FECAP_MASK = UINT32_C(0xFFFF0000);       /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
    static const uint32_t CRS_ICR_SYNCOKC_MASK = UINT32_C(0x00000001);     /** @brief SYNC event OK clear flag writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register. */
    static const uint32_t CRS_ICR_SYNCWARNC_MASK = UINT32_C(0x00000002);   /** @brief SYNC warning clear flag writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register. */
    static const uint32_t CRS_ICR_ERRC_MASK = UINT32_C(0x00000004);        /** @brief Error clear flag writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register. */
    static const uint32_t CRS_ICR_ESYNCC_MASK = UINT32_C(0x00000008);      /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

    /** @subsection CRS field position definitions */

    static const int32_t CRS_ICR_SYNCOKIE_POS = INT32_C(0);      /** @brief SYNC event OK interrupt enable */
    static const int32_t CRS_ICR_SYNCWARNIE_POS = INT32_C(1);    /** @brief SYNC warning interrupt enable */
    static const int32_t CRS_ICR_ERRIE_POS = INT32_C(2);         /** @brief Synchronization or trimming error interrupt enable */
    static const int32_t CRS_ICR_ESYNCIE_POS = INT32_C(3);       /** @brief Expected SYNC interrupt enable */
    static const int32_t CRS_ICR_CEN_POS = INT32_C(5);           /** @brief Frequency error counter enable this bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified. */
    static const int32_t CRS_ICR_AUTOTRIMEN_POS = INT32_C(6);    /** @brief Automatic trimming enable this bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details. */
    static const int32_t CRS_ICR_SWSYNC_POS = INT32_C(7);        /** @brief Generate software SYNC event this bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware. */
    static const int32_t CRS_ICR_TRIM_POS = INT32_C(8);          /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
    static const int32_t CRS_ICR_RELOAD_POS = INT32_C(0);        /** @brief Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to section7.3.3: frequency error measurement for more details about counter behavior. */
    static const int32_t CRS_ICR_FELIM_POS = INT32_C(16);        /** @brief Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP evaluation. */
    static const int32_t CRS_ICR_SYNCDIV_POS = INT32_C(24);      /** @brief SYNC divider these bits are set and cleared by software to control the division factor of the SYNC signal. */
    static const int32_t CRS_ICR_SYNCSRC_POS = INT32_C(28);      /** @brief SYNC signal source selection these bits are set and cleared by software to select the SYNC signal source. Note: when using USB LPM (link power management) and the device is in sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from sleep mode, the LSE or reference clock on the gpios should be used as SYNC signal. */
    static const int32_t CRS_ICR_SYNCPOL_POS = INT32_C(31);      /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
    static const int32_t CRS_ICR_SYNCOKF_POS = INT32_C(0);       /** @brief SYNC event OK flag this flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register. */
    static const int32_t CRS_ICR_SYNCWARNF_POS = INT32_C(1);     /** @brief SYNC warning flag this flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register. */
    static const int32_t CRS_ICR_ERRF_POS = INT32_C(2);          /** @brief Error flag this flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits. */
    static const int32_t CRS_ICR_ESYNCF_POS = INT32_C(3);        /** @brief Expected SYNC flag this flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register. */
    static const int32_t CRS_ICR_SYNCERR_POS = INT32_C(8);       /** @brief SYNC error this flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const int32_t CRS_ICR_SYNCMISS_POS = INT32_C(9);      /** @brief SYNC missed this flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const int32_t CRS_ICR_TRIMOVF_POS = INT32_C(10);      /** @brief Trimming overflow or underflow this flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
    static const int32_t CRS_ICR_FEDIR_POS = INT32_C(15);        /** @brief Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target. */
    static const int32_t CRS_ICR_FECAP_POS = INT32_C(16);        /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
    static const int32_t CRS_ICR_SYNCOKC_POS = INT32_C(0);       /** @brief SYNC event OK clear flag writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register. */
    static const int32_t CRS_ICR_SYNCWARNC_POS = INT32_C(1);     /** @brief SYNC warning clear flag writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register. */
    static const int32_t CRS_ICR_ERRC_POS = INT32_C(2);          /** @brief Error clear flag writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register. */
    static const int32_t CRS_ICR_ESYNCC_POS = INT32_C(3);        /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

    /**********************************************************************************************
     * @section DAC Definitions
     **********************************************************************************************/

    /** @subsection DAC register definitions */

    static _RW uint32_t* const DAC_CR_REG = (_RW uint32_t* const)UINT32_C(0x40007400);        /** @brief DAC control register */
    static _RW uint32_t* const DAC_SWTRGR_REG = (_RW uint32_t* const)UINT32_C(0x40007404);    /** @brief DAC software trigger register */
    static _RW uint32_t* const DAC_DHR12R1_REG = (_RW uint32_t* const)UINT32_C(0x40007408);   /** @brief DAC channel1 12-bit right-aligned data holding register */
    static _RW uint32_t* const DAC_DHR12L1_REG = (_RW uint32_t* const)UINT32_C(0x4000740C);   /** @brief DAC channel1 12-bit left aligned data holding register */
    static _RW uint32_t* const DAC_DHR8R1_REG = (_RW uint32_t* const)UINT32_C(0x40007410);    /** @brief DAC channel1 8-bit right aligned data holding register */
    static _RW uint32_t* const DAC_DHR12R2_REG = (_RW uint32_t* const)UINT32_C(0x40007414);   /** @brief DAC channel2 12-bit right aligned data holding register */
    static _RW uint32_t* const DAC_DHR12L2_REG = (_RW uint32_t* const)UINT32_C(0x40007418);   /** @brief DAC channel2 12-bit left aligned data holding register */
    static _RW uint32_t* const DAC_DHR8R2_REG = (_RW uint32_t* const)UINT32_C(0x4000741C);    /** @brief DAC channel2 8-bit right-aligned data holding register */
    static _RW uint32_t* const DAC_DHR12RD_REG = (_RW uint32_t* const)UINT32_C(0x40007420);   /** @brief Dual DAC 12-bit right-aligned data holding register */
    static _RW uint32_t* const DAC_DHR12LD_REG = (_RW uint32_t* const)UINT32_C(0x40007424);   /** @brief DUAL DAC 12-bit left aligned data holding register */
    static _RW uint32_t* const DAC_DHR8RD_REG = (_RW uint32_t* const)UINT32_C(0x40007428);    /** @brief DUAL DAC 8-bit right aligned data holding register */
    static _RO uint32_t* const DAC_DOR1_REG = (_RO uint32_t* const)UINT32_C(0x4000742C);      /** @brief DAC channel1 data output register */
    static _RO uint32_t* const DAC_DOR2_REG = (_RO uint32_t* const)UINT32_C(0x40007430);      /** @brief DAC channel2 data output register */
    static _RW uint32_t* const DAC_SR_REG = (_RW uint32_t* const)UINT32_C(0x40007434);        /** @brief DAC status register */
    static _RW uint32_t* const DAC_CCR_REG = (_RW uint32_t* const)UINT32_C(0x40007438);       /** @brief DAC calibration control register */
    static _RW uint32_t* const DAC_MCR_REG = (_RW uint32_t* const)UINT32_C(0x4000743C);       /** @brief DAC mode control register */
    static _RW uint32_t* const DAC_SHSR1_REG = (_RW uint32_t* const)UINT32_C(0x40007440);     /** @brief DAC sample and hold sample time register 1 */
    static _RW uint32_t* const DAC_SHSR2_REG = (_RW uint32_t* const)UINT32_C(0x40007444);     /** @brief DAC sample and hold sample time register 2 */
    static _RW uint32_t* const DAC_SHHR_REG = (_RW uint32_t* const)UINT32_C(0x40007448);      /** @brief DAC sample and hold hold time register */
    static _RW uint32_t* const DAC_SHRR_REG = (_RW uint32_t* const)UINT32_C(0x4000744C);      /** @brief DAC sample and hold refresh time register */

    /** @subsection DAC field mask definitions */

    static const uint32_t DAC_CR_EN1_MASK = UINT32_C(0x00000001);             /** @brief DAC channel1 enable this bit is set and cleared by software to enable/disable DAC channel1. */
    static const uint32_t DAC_CR_TEN1_MASK = UINT32_C(0x00000002);            /** @brief DAC channel1 trigger enable */
    static const uint32_t DAC_CR_TSEL1_MASK = UINT32_C(0x0000001C);           /** @brief DAC channel1 trigger selection these bits select the external event used to trigger DAC channel1. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    static const uint32_t DAC_CR_WAVE1_MASK = UINT32_C(0x000000C0);           /** @brief DAC channel1 noise/triangle wave generation enable these bits are set and cleared by software. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    static const uint32_t DAC_CR_MAMP1_MASK = UINT32_C(0x00000F00);           /** @brief DAC channel1 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    static const uint32_t DAC_CR_DMAEN1_MASK = UINT32_C(0x00001000);          /** @brief DAC channel1 DMA enable this bit is set and cleared by software. */
    static const uint32_t DAC_CR_DMAUDRIE1_MASK = UINT32_C(0x00002000);       /** @brief DAC channel1 DMA underrun interrupt enable this bit is set and cleared by software. */
    static const uint32_t DAC_CR_CEN1_MASK = UINT32_C(0x00004000);            /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    static const uint32_t DAC_CR_EN2_MASK = UINT32_C(0x00010000);             /** @brief DAC channel2 enable this bit is set and cleared by software to enable/disable DAC channel2. */
    static const uint32_t DAC_CR_TEN2_MASK = UINT32_C(0x00020000);            /** @brief DAC channel2 trigger enable */
    static const uint32_t DAC_CR_TSEL2_MASK = UINT32_C(0x001C0000);           /** @brief DAC channel2 trigger selection these bits select the external event used to trigger DAC channel2 note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
    static const uint32_t DAC_CR_WAVE2_MASK = UINT32_C(0x00C00000);           /** @brief DAC channel2 noise/triangle wave generation enable these bits are set/reset by software. 1x: triangle wave generation enabled note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled) */
    static const uint32_t DAC_CR_MAMP2_MASK = UINT32_C(0x0F000000);           /** @brief DAC channel2 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    static const uint32_t DAC_CR_DMAEN2_MASK = UINT32_C(0x10000000);          /** @brief DAC channel2 DMA enable this bit is set and cleared by software. */
    static const uint32_t DAC_CR_DMAUDRIE2_MASK = UINT32_C(0x20000000);       /** @brief DAC channel2 DMA underrun interrupt enable this bit is set and cleared by software. */
    static const uint32_t DAC_CR_CEN2_MASK = UINT32_C(0x40000000);            /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    static const uint32_t DAC_SWTRGR_SWTRIG1_MASK = UINT32_C(0x00000001);     /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
    static const uint32_t DAC_SWTRGR_SWTRIG2_MASK = UINT32_C(0x00000002);     /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
    static const uint32_t DAC_DHR12R1_DACC1DHR_MASK = UINT32_C(0x00000FFF);   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const uint32_t DAC_DHR12L1_DACC1DHR_MASK = UINT32_C(0x0000FFF0);   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const uint32_t DAC_DHR8R1_DACC1DHR_MASK = UINT32_C(0x000000FF);    /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
    static const uint32_t DAC_DHR12R2_DACC2DHR_MASK = UINT32_C(0x00000FFF);   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    static const uint32_t DAC_DHR12L2_DACC2DHR_MASK = UINT32_C(0x0000FFF0);   /** @brief DAC channel2 12-bit left-aligned data these bits are written by software which specify 12-bit data for DAC channel2. */
    static const uint32_t DAC_DHR8R2_DACC2DHR_MASK = UINT32_C(0x000000FF);    /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
    static const uint32_t DAC_DHR12RD_DACC1DHR_MASK = UINT32_C(0x00000FFF);   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const uint32_t DAC_DHR12RD_DACC2DHR_MASK = UINT32_C(0x0FFF0000);   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    static const uint32_t DAC_DHR12LD_DACC1DHR_MASK = UINT32_C(0x0000FFF0);   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const uint32_t DAC_DHR12LD_DACC2DHR_MASK = UINT32_C(0xFFF00000);   /** @brief DAC channel2 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    static const uint32_t DAC_DHR8RD_DACC1DHR_MASK = UINT32_C(0x000000FF);    /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
    static const uint32_t DAC_DHR8RD_DACC2DHR_MASK = UINT32_C(0x0000FF00);    /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
    static const uint32_t DAC_DOR1_DACC1DOR_MASK = UINT32_C(0x00000FFF);      /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
    static const uint32_t DAC_DOR2_DACC2DOR_MASK = UINT32_C(0x00000FFF);      /** @brief DAC channel2 data output these bits are read-only, they contain data output for DAC channel2. */
    static const uint32_t DAC_SR_DMAUDR1_MASK = UINT32_C(0x00002000);         /** @brief DAC channel1 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    static const uint32_t DAC_SR_CAL_FLAG1_MASK = UINT32_C(0x00004000);       /** @brief DAC channel 1 calibration offset status this bit is set and cleared by hardware */
    static const uint32_t DAC_SR_BWST1_MASK = UINT32_C(0x00008000);           /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
    static const uint32_t DAC_SR_DMAUDR2_MASK = UINT32_C(0x20000000);         /** @brief DAC channel2 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    static const uint32_t DAC_SR_CAL_FLAG2_MASK = UINT32_C(0x40000000);       /** @brief DAC channel 2 calibration offset status this bit is set and cleared by hardware */
    static const uint32_t DAC_SR_BWST2_MASK = UINT32_C(0x80000000);           /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
    static const uint32_t DAC_CCR_OTRIM1_MASK = UINT32_C(0x0000001F);         /** @brief DAC channel 1 offset trimming value */
    static const uint32_t DAC_CCR_OTRIM2_MASK = UINT32_C(0x001F0000);         /** @brief DAC channel 2 offset trimming value */
    static const uint32_t DAC_MCR_MODE1_MASK = UINT32_C(0x00000007);          /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode */
    static const uint32_t DAC_MCR_MODE2_MASK = UINT32_C(0x00070000);          /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode */
    static const uint32_t DAC_SHSR1_TSAMPLE1_MASK = UINT32_C(0x000003FF);     /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */
    static const uint32_t DAC_SHSR2_TSAMPLE2_MASK = UINT32_C(0x000003FF);     /** @brief DAC channel 2 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel2 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */
    static const uint32_t DAC_SHHR_THOLD1_MASK = UINT32_C(0x000003FF);        /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI */
    static const uint32_t DAC_SHHR_THOLD2_MASK = UINT32_C(0x03FF0000);        /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI */
    static const uint32_t DAC_SHRR_TREFRESH1_MASK = UINT32_C(0x000000FF);     /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
    static const uint32_t DAC_SHRR_TREFRESH2_MASK = UINT32_C(0x00FF0000);     /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */

    /** @subsection DAC field position definitions */

    static const int32_t DAC_SHRR_EN1_POS = INT32_C(0);          /** @brief DAC channel1 enable this bit is set and cleared by software to enable/disable DAC channel1. */
    static const int32_t DAC_SHRR_TEN1_POS = INT32_C(1);         /** @brief DAC channel1 trigger enable */
    static const int32_t DAC_SHRR_TSEL1_POS = INT32_C(2);        /** @brief DAC channel1 trigger selection these bits select the external event used to trigger DAC channel1. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    static const int32_t DAC_SHRR_WAVE1_POS = INT32_C(6);        /** @brief DAC channel1 noise/triangle wave generation enable these bits are set and cleared by software. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    static const int32_t DAC_SHRR_MAMP1_POS = INT32_C(8);        /** @brief DAC channel1 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    static const int32_t DAC_SHRR_DMAEN1_POS = INT32_C(12);      /** @brief DAC channel1 DMA enable this bit is set and cleared by software. */
    static const int32_t DAC_SHRR_DMAUDRIE1_POS = INT32_C(13);   /** @brief DAC channel1 DMA underrun interrupt enable this bit is set and cleared by software. */
    static const int32_t DAC_SHRR_CEN1_POS = INT32_C(14);        /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    static const int32_t DAC_SHRR_EN2_POS = INT32_C(16);         /** @brief DAC channel2 enable this bit is set and cleared by software to enable/disable DAC channel2. */
    static const int32_t DAC_SHRR_TEN2_POS = INT32_C(17);        /** @brief DAC channel2 trigger enable */
    static const int32_t DAC_SHRR_TSEL2_POS = INT32_C(18);       /** @brief DAC channel2 trigger selection these bits select the external event used to trigger DAC channel2 note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
    static const int32_t DAC_SHRR_WAVE2_POS = INT32_C(22);       /** @brief DAC channel2 noise/triangle wave generation enable these bits are set/reset by software. 1x: triangle wave generation enabled note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled) */
    static const int32_t DAC_SHRR_MAMP2_POS = INT32_C(24);       /** @brief DAC channel2 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    static const int32_t DAC_SHRR_DMAEN2_POS = INT32_C(28);      /** @brief DAC channel2 DMA enable this bit is set and cleared by software. */
    static const int32_t DAC_SHRR_DMAUDRIE2_POS = INT32_C(29);   /** @brief DAC channel2 DMA underrun interrupt enable this bit is set and cleared by software. */
    static const int32_t DAC_SHRR_CEN2_POS = INT32_C(30);        /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    static const int32_t DAC_SHRR_SWTRIG1_POS = INT32_C(0);      /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
    static const int32_t DAC_SHRR_SWTRIG2_POS = INT32_C(1);      /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
    static const int32_t DAC_SHRR_DACC1DHR_POS = INT32_C(0);     /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const int32_t DAC_SHRR_DACC1DHR_POS = INT32_C(4);     /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const int32_t DAC_SHRR_DACC1DHR_POS = INT32_C(0);     /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
    static const int32_t DAC_SHRR_DACC2DHR_POS = INT32_C(0);     /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    static const int32_t DAC_SHRR_DACC2DHR_POS = INT32_C(4);     /** @brief DAC channel2 12-bit left-aligned data these bits are written by software which specify 12-bit data for DAC channel2. */
    static const int32_t DAC_SHRR_DACC2DHR_POS = INT32_C(0);     /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
    static const int32_t DAC_SHRR_DACC1DHR_POS = INT32_C(0);     /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const int32_t DAC_SHRR_DACC2DHR_POS = INT32_C(16);    /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    static const int32_t DAC_SHRR_DACC1DHR_POS = INT32_C(4);     /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    static const int32_t DAC_SHRR_DACC2DHR_POS = INT32_C(20);    /** @brief DAC channel2 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
    static const int32_t DAC_SHRR_DACC1DHR_POS = INT32_C(0);     /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
    static const int32_t DAC_SHRR_DACC2DHR_POS = INT32_C(8);     /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
    static const int32_t DAC_SHRR_DACC1DOR_POS = INT32_C(0);     /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
    static const int32_t DAC_SHRR_DACC2DOR_POS = INT32_C(0);     /** @brief DAC channel2 data output these bits are read-only, they contain data output for DAC channel2. */
    static const int32_t DAC_SHRR_DMAUDR1_POS = INT32_C(13);     /** @brief DAC channel1 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    static const int32_t DAC_SHRR_CAL_FLAG1_POS = INT32_C(14);   /** @brief DAC channel 1 calibration offset status this bit is set and cleared by hardware */
    static const int32_t DAC_SHRR_BWST1_POS = INT32_C(15);       /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
    static const int32_t DAC_SHRR_DMAUDR2_POS = INT32_C(29);     /** @brief DAC channel2 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    static const int32_t DAC_SHRR_CAL_FLAG2_POS = INT32_C(30);   /** @brief DAC channel 2 calibration offset status this bit is set and cleared by hardware */
    static const int32_t DAC_SHRR_BWST2_POS = INT32_C(31);       /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
    static const int32_t DAC_SHRR_OTRIM1_POS = INT32_C(0);       /** @brief DAC channel 1 offset trimming value */
    static const int32_t DAC_SHRR_OTRIM2_POS = INT32_C(16);      /** @brief DAC channel 2 offset trimming value */
    static const int32_t DAC_SHRR_MODE1_POS = INT32_C(0);        /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode */
    static const int32_t DAC_SHRR_MODE2_POS = INT32_C(16);       /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode */
    static const int32_t DAC_SHRR_TSAMPLE1_POS = INT32_C(0);     /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */
    static const int32_t DAC_SHRR_TSAMPLE2_POS = INT32_C(0);     /** @brief DAC channel 2 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel2 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */
    static const int32_t DAC_SHRR_THOLD1_POS = INT32_C(0);       /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI */
    static const int32_t DAC_SHRR_THOLD2_POS = INT32_C(16);      /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI */
    static const int32_t DAC_SHRR_TREFRESH1_POS = INT32_C(0);    /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
    static const int32_t DAC_SHRR_TREFRESH2_POS = INT32_C(16);   /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */

    /**********************************************************************************************
     * @section BDMA Definitions
     **********************************************************************************************/

    /** @subsection BDMA IRQ interrupt array definitions */

    static const int32_t BDMA_CHX_IRQ[9] = {
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(129),    /** @brief BDMA channel 1 interrupt */
      INT32_C(130),    /** @brief BDMA channel 2 interrupt */
      INT32_C(131),    /** @brief BDMA channel 3 interrupt */
      INT32_C(132),    /** @brief BDMA channel 4 interrupt */
      INT32_C(133),    /** @brief BDMA channel 5 interrupt */
      INT32_C(134),    /** @brief BDMA channel 6 interrupt */
      INT32_C(135),    /** @brief BDMA channel 7 interrupt */
      INT32_C(136),    /** @brief BDMA channel 8 interrupt */
    };

    /** @subsection BDMA register array definitions */

    static _RW uint32_t* const BDMA_CCRX_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58025408),   /** @brief DMA channel x configuration register */
      (_RW uint32_t* const)UINT32_C(0x5802541C),   /** @brief DMA channel x configuration register */
      (_RW uint32_t* const)UINT32_C(0x58025430),   /** @brief DMA channel x configuration register */
      (_RW uint32_t* const)UINT32_C(0x58025444),   /** @brief DMA channel x configuration register */
      (_RW uint32_t* const)UINT32_C(0x58025458),   /** @brief DMA channel x configuration register */
      (_RW uint32_t* const)UINT32_C(0x5802546C),   /** @brief DMA channel x configuration register */
      (_RW uint32_t* const)UINT32_C(0x58025480),   /** @brief DMA channel x configuration register */
      (_RW uint32_t* const)UINT32_C(0x58025494),   /** @brief DMA channel x configuration register */
    };

    static _RW uint32_t* const BDMA_CNDTRX_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x5802540C),   /** @brief DMA channel x number of data register */
      (_RW uint32_t* const)UINT32_C(0x58025420),   /** @brief DMA channel x number of data register */
      (_RW uint32_t* const)UINT32_C(0x58025434),   /** @brief DMA channel x number of data register */
      (_RW uint32_t* const)UINT32_C(0x58025448),   /** @brief DMA channel x number of data register */
      (_RW uint32_t* const)UINT32_C(0x5802545C),   /** @brief DMA channel x number of data register */
      (_RW uint32_t* const)UINT32_C(0x58025470),   /** @brief DMA channel x number of data register */
      (_RW uint32_t* const)UINT32_C(0x58025484),   /** @brief DMA channel x number of data register */
      (_RW uint32_t* const)UINT32_C(0x58025498),   /** @brief DMA channel x number of data register */
    };

    static _RW uint32_t* const BDMA_CPARX_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58025410),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025424),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025438),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x5802544C),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025460),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025474),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025488),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x5802549C),   /** @brief This register must not be written when the channel is enabled. */
    };

    static _RW uint32_t* const BDMA_CMARX_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58025414),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025428),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x5802543C),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025450),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025464),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x58025478),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x5802548C),   /** @brief This register must not be written when the channel is enabled. */
      (_RW uint32_t* const)UINT32_C(0x580254A0),   /** @brief This register must not be written when the channel is enabled. */
    };

    /** @subsection BDMA register definitions */

    static _RO uint32_t* const BDMA_ISR_REG = (_RO uint32_t* const)UINT32_C(0x58025400);    /** @brief DMA interrupt status register */
    static _RW uint32_t* const BDMA_IFCR_REG = (_RW uint32_t* const)UINT32_C(0x58025404);   /** @brief DMA interrupt flag clear register */

    /** @subsection BDMA field mask array definitions */

    static const uint32_t BDMA_ISR_GIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000010),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000100),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00001000),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00010000),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00100000),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x01000000),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x10000000),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_ISR_TCIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000020),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000200),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00002000),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00020000),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00200000),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x02000000),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x20000000),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_ISR_HTIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000004),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000040),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000400),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00004000),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00040000),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00400000),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x04000000),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x40000000),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_ISR_TEIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000080),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00000800),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00008000),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00080000),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x00800000),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x08000000),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      UINT32_C(0x80000000),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_IFCR_CGIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      UINT32_C(0x00000010),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      UINT32_C(0x00000100),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      UINT32_C(0x00001000),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      UINT32_C(0x00010000),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      UINT32_C(0x00100000),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      UINT32_C(0x01000000),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      UINT32_C(0x10000000),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_IFCR_CTCIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      UINT32_C(0x00000020),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      UINT32_C(0x00000200),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      UINT32_C(0x00002000),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      UINT32_C(0x00020000),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      UINT32_C(0x00200000),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      UINT32_C(0x02000000),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      UINT32_C(0x20000000),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_IFCR_CHTIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000004),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      UINT32_C(0x00000040),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      UINT32_C(0x00000400),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      UINT32_C(0x00004000),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      UINT32_C(0x00040000),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      UINT32_C(0x00400000),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      UINT32_C(0x04000000),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      UINT32_C(0x40000000),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_IFCR_CTEIFX_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      UINT32_C(0x00000080),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      UINT32_C(0x00000800),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      UINT32_C(0x00008000),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      UINT32_C(0x00080000),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      UINT32_C(0x00800000),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      UINT32_C(0x08000000),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      UINT32_C(0x80000000),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    };

    /** @subsection BDMA field mask definitions */

    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const uint32_t BDMA_CCRX_EN_MASK = UINT32_C(0x00000001);        /** @brief Channel enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TCIE_MASK = UINT32_C(0x00000002);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_HTIE_MASK = UINT32_C(0x00000004);      /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_TEIE_MASK = UINT32_C(0x00000008);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_DIR_MASK = UINT32_C(0x00000010);       /** @brief Data transfer direction this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_CIRC_MASK = UINT32_C(0x00000020);      /** @brief Circular mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PINC_MASK = UINT32_C(0x00000040);      /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_MINC_MASK = UINT32_C(0x00000080);      /** @brief Memory increment mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CCRX_PSIZE_MASK = UINT32_C(0x00000300);     /** @brief Peripheral size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MSIZE_MASK = UINT32_C(0x00000C00);     /** @brief Memory size these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_PL_MASK = UINT32_C(0x00003000);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const uint32_t BDMA_CCRX_MEM2MEM_MASK = UINT32_C(0x00004000);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const uint32_t BDMA_CNDTRX_NDT_MASK = UINT32_C(0x0000FFFF);     /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */

    /** @subsection BDMA field position array definitions */

    static const int32_t BDMA_CMARX_GIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(4),    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(8),    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(12),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(16),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(20),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(24),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(28),   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_CMARX_TCIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(5),    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(9),    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(13),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(17),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(21),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(25),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(29),   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_CMARX_HTIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(2),    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(6),    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(10),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(14),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(18),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(22),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(26),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(30),   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_CMARX_TEIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(7),    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(11),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(15),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(19),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(23),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(27),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      INT32_C(31),   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const int32_t BDMA_CMARX_CGIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      INT32_C(4),    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      INT32_C(8),    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      INT32_C(12),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      INT32_C(16),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      INT32_C(20),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      INT32_C(24),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
      INT32_C(28),   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    };

    static const int32_t BDMA_CMARX_CTCIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      INT32_C(5),    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      INT32_C(9),    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      INT32_C(13),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      INT32_C(17),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      INT32_C(21),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      INT32_C(25),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
      INT32_C(29),   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    };

    static const int32_t BDMA_CMARX_CHTIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(2),    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      INT32_C(6),    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      INT32_C(10),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      INT32_C(14),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      INT32_C(18),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      INT32_C(22),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      INT32_C(26),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
      INT32_C(30),   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    };

    static const int32_t BDMA_CMARX_CTEIFX_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      INT32_C(7),    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      INT32_C(11),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      INT32_C(15),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      INT32_C(19),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      INT32_C(23),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      INT32_C(27),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      INT32_C(31),   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    };

    /** @subsection BDMA field position definitions */

    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    static const int32_t BDMA_CMARX_EN_POS = INT32_C(0);         /** @brief Channel enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TCIE_POS = INT32_C(1);       /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_HTIE_POS = INT32_C(2);       /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_TEIE_POS = INT32_C(3);       /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_DIR_POS = INT32_C(4);        /** @brief Data transfer direction this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_CIRC_POS = INT32_C(5);       /** @brief Circular mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PINC_POS = INT32_C(6);       /** @brief Peripheral increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_MINC_POS = INT32_C(7);       /** @brief Memory increment mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_PSIZE_POS = INT32_C(8);      /** @brief Peripheral size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MSIZE_POS = INT32_C(10);     /** @brief Memory size these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_PL_POS = INT32_C(12);        /** @brief Channel priority level these bits are set and cleared by software. */
    static const int32_t BDMA_CMARX_MEM2MEM_POS = INT32_C(14);   /** @brief Memory to memory mode this bit is set and cleared by software. */
    static const int32_t BDMA_CMARX_NDT_POS = INT32_C(0);        /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */

    /**********************************************************************************************
     * @section DMA2D Definitions
     **********************************************************************************************/

    /** @subsection DMA2D IRQ interrupt definitions */

    static const int32_t DMA2D_IRQ = INT32_C(90);   /** @brief DMA2D global interrupt */

    /** @subsection DMA2D register definitions */

    static _RW uint32_t* const DMA2D_CR_REG = (_RW uint32_t* const)UINT32_C(0x52001000);        /** @brief DMA2D control register */
    static _RO uint32_t* const DMA2D_ISR_REG = (_RO uint32_t* const)UINT32_C(0x52001004);       /** @brief DMA2D interrupt status register */
    static _RW uint32_t* const DMA2D_IFCR_REG = (_RW uint32_t* const)UINT32_C(0x52001008);      /** @brief DMA2D interrupt flag clear register */
    static _RW uint32_t* const DMA2D_FGMAR_REG = (_RW uint32_t* const)UINT32_C(0x5200100C);     /** @brief DMA2D foreground memory address register */
    static _RW uint32_t* const DMA2D_FGOR_REG = (_RW uint32_t* const)UINT32_C(0x52001010);      /** @brief DMA2D foreground offset register */
    static _RW uint32_t* const DMA2D_BGMAR_REG = (_RW uint32_t* const)UINT32_C(0x52001014);     /** @brief DMA2D background memory address register */
    static _RW uint32_t* const DMA2D_BGOR_REG = (_RW uint32_t* const)UINT32_C(0x52001018);      /** @brief DMA2D background offset register */
    static _RW uint32_t* const DMA2D_FGPFCCR_REG = (_RW uint32_t* const)UINT32_C(0x5200101C);   /** @brief DMA2D foreground PFC control register */
    static _RW uint32_t* const DMA2D_FGCOLR_REG = (_RW uint32_t* const)UINT32_C(0x52001020);    /** @brief DMA2D foreground color register */
    static _RW uint32_t* const DMA2D_BGPFCCR_REG = (_RW uint32_t* const)UINT32_C(0x52001024);   /** @brief DMA2D background PFC control register */
    static _RW uint32_t* const DMA2D_BGCOLR_REG = (_RW uint32_t* const)UINT32_C(0x52001028);    /** @brief DMA2D background color register */
    static _RW uint32_t* const DMA2D_FGCMAR_REG = (_RW uint32_t* const)UINT32_C(0x5200102C);    /** @brief DMA2D foreground CLUT memory address register */
    static _RW uint32_t* const DMA2D_BGCMAR_REG = (_RW uint32_t* const)UINT32_C(0x52001030);    /** @brief DMA2D background CLUT memory address register */
    static _RW uint32_t* const DMA2D_OPFCCR_REG = (_RW uint32_t* const)UINT32_C(0x52001034);    /** @brief DMA2D output PFC control register */
    static _RW uint32_t* const DMA2D_OCOLR_REG = (_RW uint32_t* const)UINT32_C(0x52001038);     /** @brief DMA2D output color register */
    static _RW uint32_t* const DMA2D_OMAR_REG = (_RW uint32_t* const)UINT32_C(0x5200103C);      /** @brief DMA2D output memory address register */
    static _RW uint32_t* const DMA2D_OOR_REG = (_RW uint32_t* const)UINT32_C(0x52001040);       /** @brief DMA2D output offset register */
    static _RW uint32_t* const DMA2D_NLR_REG = (_RW uint32_t* const)UINT32_C(0x52001044);       /** @brief DMA2D number of line register */
    static _RW uint32_t* const DMA2D_LWR_REG = (_RW uint32_t* const)UINT32_C(0x52001048);       /** @brief DMA2D line watermark register */
    static _RW uint32_t* const DMA2D_AMTCR_REG = (_RW uint32_t* const)UINT32_C(0x5200104C);     /** @brief DMA2D AXI master timer configuration register */

    /** @subsection DMA2D field mask definitions */

    static const uint32_t DMA2D_CR_START_MASK = UINT32_C(0x00000001);        /** @brief Start this bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers */
    static const uint32_t DMA2D_CR_SUSP_MASK = UINT32_C(0x00000002);         /** @brief Suspend this bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset. */
    static const uint32_t DMA2D_CR_ABORT_MASK = UINT32_C(0x00000004);        /** @brief Abort this bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset. */
    static const uint32_t DMA2D_CR_TEIE_MASK = UINT32_C(0x00000100);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_TCIE_MASK = UINT32_C(0x00000200);         /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_TWIE_MASK = UINT32_C(0x00000400);         /** @brief Transfer watermark interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_CAEIE_MASK = UINT32_C(0x00000800);        /** @brief CLUT access error interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_CTCIE_MASK = UINT32_C(0x00001000);        /** @brief CLUT transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_CEIE_MASK = UINT32_C(0x00002000);         /** @brief Configuration error interrupt enable this bit is set and cleared by software. */
    static const uint32_t DMA2D_CR_MODE_MASK = UINT32_C(0x00030000);         /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
    static const uint32_t DMA2D_ISR_TEIF_MASK = UINT32_C(0x00000001);        /** @brief Transfer error interrupt flag this bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading). */
    static const uint32_t DMA2D_ISR_TCIF_MASK = UINT32_C(0x00000002);        /** @brief Transfer complete interrupt flag this bit is set when a DMA2D transfer operation is complete (data transfer only). */
    static const uint32_t DMA2D_ISR_TWIF_MASK = UINT32_C(0x00000004);        /** @brief Transfer watermark interrupt flag this bit is set when the last pixel of the watermarked line has been transferred. */
    static const uint32_t DMA2D_ISR_CAEIF_MASK = UINT32_C(0x00000008);       /** @brief CLUT access error interrupt flag this bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D. */
    static const uint32_t DMA2D_ISR_CTCIF_MASK = UINT32_C(0x00000010);       /** @brief CLUT transfer complete interrupt flag this bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete. */
    static const uint32_t DMA2D_ISR_CEIF_MASK = UINT32_C(0x00000020);        /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
    static const uint32_t DMA2D_IFCR_CTEIF_MASK = UINT32_C(0x00000001);      /** @brief Clear transfer error interrupt flag programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CTCIF_MASK = UINT32_C(0x00000002);      /** @brief Clear transfer complete interrupt flag programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CTWIF_MASK = UINT32_C(0x00000004);      /** @brief Clear transfer watermark interrupt flag programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CAECIF_MASK = UINT32_C(0x00000008);     /** @brief Clear CLUT access error interrupt flag programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CCTCIF_MASK = UINT32_C(0x00000010);     /** @brief Clear CLUT transfer complete interrupt flag programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_IFCR_CCEIF_MASK = UINT32_C(0x00000020);      /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_FGOR_LO_MASK = UINT32_C(0x00003FFF);         /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const uint32_t DMA2D_BGOR_LO_MASK = UINT32_C(0x00003FFF);         /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const uint32_t DMA2D_FGPFCCR_CM_MASK = UINT32_C(0x0000000F);      /** @brief Color mode these bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_FGPFCCR_CCM_MASK = UINT32_C(0x00000010);     /** @brief CLUT color mode this bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_FGPFCCR_START_MASK = UINT32_C(0x00000020);   /** @brief Start this bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer). */
    static const uint32_t DMA2D_FGPFCCR_CS_MASK = UINT32_C(0x0000FF00);      /** @brief CLUT size these bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const uint32_t DMA2D_FGPFCCR_AM_MASK = UINT32_C(0x00030000);      /** @brief Alpha mode these bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. Other configurations are meaningless */
    static const uint32_t DMA2D_FGPFCCR_CSS_MASK = UINT32_C(0x000C0000);     /** @brief Chroma sub-sampling these bits define the chroma sub-sampling mode for ycbcr color mode. Once the transfer has started, these bits are read-only. Others: meaningless */
    static const uint32_t DMA2D_FGPFCCR_AI_MASK = UINT32_C(0x00100000);      /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_FGPFCCR_RBS_MASK = UINT32_C(0x00200000);     /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_FGPFCCR_ALPHA_MASK = UINT32_C(0xFF000000);   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
    static const uint32_t DMA2D_FGCOLR_BLUE_MASK = UINT32_C(0x000000FF);     /** @brief Blue value these bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_FGCOLR_GREEN_MASK = UINT32_C(0x0000FF00);    /** @brief Green value these bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_FGCOLR_RED_MASK = UINT32_C(0x00FF0000);      /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGPFCCR_CM_MASK = UINT32_C(0x0000000F);      /** @brief Color mode these bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_BGPFCCR_CCM_MASK = UINT32_C(0x00000010);     /** @brief CLUT color mode these bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_BGPFCCR_START_MASK = UINT32_C(0x00000020);   /** @brief Start this bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic background CLUT transfer). */
    static const uint32_t DMA2D_BGPFCCR_CS_MASK = UINT32_C(0x0000FF00);      /** @brief CLUT size these bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const uint32_t DMA2D_BGPFCCR_AM_MASK = UINT32_C(0x00030000);      /** @brief Alpha mode these bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_BGPFCCR_AI_MASK = UINT32_C(0x00100000);      /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_BGPFCCR_RBS_MASK = UINT32_C(0x00200000);     /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_BGPFCCR_ALPHA_MASK = UINT32_C(0xFF000000);   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGCOLR_BLUE_MASK = UINT32_C(0x000000FF);     /** @brief Blue value these bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGCOLR_GREEN_MASK = UINT32_C(0x0000FF00);    /** @brief Green value these bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGCOLR_RED_MASK = UINT32_C(0x00FF0000);      /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OPFCCR_CM_MASK = UINT32_C(0x00000007);       /** @brief Color mode these bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const uint32_t DMA2D_OPFCCR_AI_MASK = UINT32_C(0x00100000);       /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_OPFCCR_RBS_MASK = UINT32_C(0x00200000);      /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_OCOLR_BLUE_MASK = UINT32_C(0x000000FF);      /** @brief Blue value these bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OCOLR_GREEN_MASK = UINT32_C(0x0000FF00);     /** @brief Green value these bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OCOLR_RED_MASK = UINT32_C(0x00FF0000);       /** @brief Red value these bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OCOLR_ALPHA_MASK = UINT32_C(0xFF000000);     /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OOR_LO_MASK = UINT32_C(0x00003FFF);          /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_NLR_NL_MASK = UINT32_C(0x0000FFFF);          /** @brief Number of lines number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_NLR_PL_MASK = UINT32_C(0x3FFF0000);          /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
    static const uint32_t DMA2D_LWR_LW_MASK = UINT32_C(0x0000FFFF);          /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_AMTCR_EN_MASK = UINT32_C(0x00000001);        /** @brief Enable enables the dead time functionality. */
    static const uint32_t DMA2D_AMTCR_DT_MASK = UINT32_C(0x0000FF00);        /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

    /** @subsection DMA2D field position definitions */

    static const int32_t DMA2D_AMTCR_START_POS = INT32_C(0);     /** @brief Start this bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers */
    static const int32_t DMA2D_AMTCR_SUSP_POS = INT32_C(1);      /** @brief Suspend this bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset. */
    static const int32_t DMA2D_AMTCR_ABORT_POS = INT32_C(2);     /** @brief Abort this bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset. */
    static const int32_t DMA2D_AMTCR_TEIE_POS = INT32_C(8);      /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_AMTCR_TCIE_POS = INT32_C(9);      /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_AMTCR_TWIE_POS = INT32_C(10);     /** @brief Transfer watermark interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_AMTCR_CAEIE_POS = INT32_C(11);    /** @brief CLUT access error interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_AMTCR_CTCIE_POS = INT32_C(12);    /** @brief CLUT transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_AMTCR_CEIE_POS = INT32_C(13);     /** @brief Configuration error interrupt enable this bit is set and cleared by software. */
    static const int32_t DMA2D_AMTCR_MODE_POS = INT32_C(16);     /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
    static const int32_t DMA2D_AMTCR_TEIF_POS = INT32_C(0);      /** @brief Transfer error interrupt flag this bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading). */
    static const int32_t DMA2D_AMTCR_TCIF_POS = INT32_C(1);      /** @brief Transfer complete interrupt flag this bit is set when a DMA2D transfer operation is complete (data transfer only). */
    static const int32_t DMA2D_AMTCR_TWIF_POS = INT32_C(2);      /** @brief Transfer watermark interrupt flag this bit is set when the last pixel of the watermarked line has been transferred. */
    static const int32_t DMA2D_AMTCR_CAEIF_POS = INT32_C(3);     /** @brief CLUT access error interrupt flag this bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D. */
    static const int32_t DMA2D_AMTCR_CTCIF_POS = INT32_C(4);     /** @brief CLUT transfer complete interrupt flag this bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete. */
    static const int32_t DMA2D_AMTCR_CEIF_POS = INT32_C(5);      /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
    static const int32_t DMA2D_AMTCR_CTEIF_POS = INT32_C(0);     /** @brief Clear transfer error interrupt flag programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_AMTCR_CTCIF_POS = INT32_C(1);     /** @brief Clear transfer complete interrupt flag programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_AMTCR_CTWIF_POS = INT32_C(2);     /** @brief Clear transfer watermark interrupt flag programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_AMTCR_CAECIF_POS = INT32_C(3);    /** @brief Clear CLUT access error interrupt flag programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_AMTCR_CCTCIF_POS = INT32_C(4);    /** @brief Clear CLUT transfer complete interrupt flag programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_AMTCR_CCEIF_POS = INT32_C(5);     /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register */
    static const int32_t DMA2D_AMTCR_LO_POS = INT32_C(0);        /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const int32_t DMA2D_AMTCR_LO_POS = INT32_C(0);        /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const int32_t DMA2D_AMTCR_CM_POS = INT32_C(0);        /** @brief Color mode these bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_AMTCR_CCM_POS = INT32_C(4);       /** @brief CLUT color mode this bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_START_POS = INT32_C(5);     /** @brief Start this bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer). */
    static const int32_t DMA2D_AMTCR_CS_POS = INT32_C(8);        /** @brief CLUT size these bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const int32_t DMA2D_AMTCR_AM_POS = INT32_C(16);       /** @brief Alpha mode these bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. Other configurations are meaningless */
    static const int32_t DMA2D_AMTCR_CSS_POS = INT32_C(18);      /** @brief Chroma sub-sampling these bits define the chroma sub-sampling mode for ycbcr color mode. Once the transfer has started, these bits are read-only. Others: meaningless */
    static const int32_t DMA2D_AMTCR_AI_POS = INT32_C(20);       /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_RBS_POS = INT32_C(21);      /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_ALPHA_POS = INT32_C(24);    /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
    static const int32_t DMA2D_AMTCR_BLUE_POS = INT32_C(0);      /** @brief Blue value these bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_GREEN_POS = INT32_C(8);     /** @brief Green value these bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_RED_POS = INT32_C(16);      /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_CM_POS = INT32_C(0);        /** @brief Color mode these bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_AMTCR_CCM_POS = INT32_C(4);       /** @brief CLUT color mode these bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_START_POS = INT32_C(5);     /** @brief Start this bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic background CLUT transfer). */
    static const int32_t DMA2D_AMTCR_CS_POS = INT32_C(8);        /** @brief CLUT size these bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
    static const int32_t DMA2D_AMTCR_AM_POS = INT32_C(16);       /** @brief Alpha mode these bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_AMTCR_AI_POS = INT32_C(20);       /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_RBS_POS = INT32_C(21);      /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_ALPHA_POS = INT32_C(24);    /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_BLUE_POS = INT32_C(0);      /** @brief Blue value these bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_GREEN_POS = INT32_C(8);     /** @brief Green value these bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_RED_POS = INT32_C(16);      /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_CM_POS = INT32_C(0);        /** @brief Color mode these bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
    static const int32_t DMA2D_AMTCR_AI_POS = INT32_C(20);       /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_RBS_POS = INT32_C(21);      /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const int32_t DMA2D_AMTCR_BLUE_POS = INT32_C(0);      /** @brief Blue value these bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_GREEN_POS = INT32_C(8);     /** @brief Green value these bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_RED_POS = INT32_C(16);      /** @brief Red value these bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_ALPHA_POS = INT32_C(24);    /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_LO_POS = INT32_C(0);        /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_NL_POS = INT32_C(0);        /** @brief Number of lines number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_PL_POS = INT32_C(16);       /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
    static const int32_t DMA2D_AMTCR_LW_POS = INT32_C(0);        /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const int32_t DMA2D_AMTCR_EN_POS = INT32_C(0);        /** @brief Enable enables the dead time functionality. */
    static const int32_t DMA2D_AMTCR_DT_POS = INT32_C(8);        /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

    /**********************************************************************************************
     * @section DMAMUX2 Definitions
     **********************************************************************************************/

    /** @subsection DMAMUX2 IRQ interrupt definitions */

    static const int32_t DMAMUX2_OVR_IRQ = INT32_C(128);   /** @brief DMAMUX2 overrun interrupt */

    /** @subsection DMAMUX2 register array definitions */

    static _RW uint32_t* const DMAMUX2_CXCR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x58025800),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025804),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025808),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x5802580C),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025810),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025814),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025818),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x5802581C),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
    };

    static _RW uint32_t* const DMAMUX2_RGXCR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x58025900),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025904),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025908),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x5802590C),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025910),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025914),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x58025918),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x5802591C),   /** @brief DMAMux - DMA request generator channel x control register */
    };

    /** @subsection DMAMUX2 register definitions */

    static _RO uint32_t* const DMAMUX2_RGSR_REG = (_RO uint32_t* const)UINT32_C(0x58025940);    /** @brief DMAMux - DMA request generator status register */
    static _RW uint32_t* const DMAMUX2_RGCFR_REG = (_RW uint32_t* const)UINT32_C(0x58025944);   /** @brief DMAMux - DMA request generator clear flag register */
    static _RO uint32_t* const DMAMUX2_CSR_REG = (_RO uint32_t* const)UINT32_C(0x58025880);     /** @brief DMAMUX request line multiplexer interrupt channel status register */
    static _RW uint32_t* const DMAMUX2_CFR_REG = (_RW uint32_t* const)UINT32_C(0x58025884);     /** @brief DMAMUX request line multiplexer interrupt clear flag register */

    /** @subsection DMAMUX2 field mask definitions */

    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX2_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX2_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX2_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX2_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX2_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX2_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX2_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX2_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX2_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX2_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX2_RGSR_OF_MASK = UINT32_C(0x000000FF);          /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const uint32_t DMAMUX2_RGCFR_COF_MASK = UINT32_C(0x000000FF);        /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const uint32_t DMAMUX2_CSR_SOF_MASK = UINT32_C(0x0000FFFF);          /** @brief Synchronization overrun event flag */
    static const uint32_t DMAMUX2_CFR_CSOF_MASK = UINT32_C(0x0000FFFF);         /** @brief Clear synchronization overrun event flag */

    /** @subsection DMAMUX2 field position definitions */

    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX2_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX2_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX2_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX2_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX2_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX2_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX2_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX2_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX2_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX2_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX2_CFR_OF_POS = INT32_C(0);           /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const int32_t DMAMUX2_CFR_COF_POS = INT32_C(0);          /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const int32_t DMAMUX2_CFR_SOF_POS = INT32_C(0);          /** @brief Synchronization overrun event flag */
    static const int32_t DMAMUX2_CFR_CSOF_POS = INT32_C(0);         /** @brief Clear synchronization overrun event flag */

    /**********************************************************************************************
     * @section FMC Definitions
     **********************************************************************************************/

    /** @subsection FMC IRQ interrupt definitions */

    static const int32_t FMC_IRQ = INT32_C(48);   /** @brief FMC global interrupt */

    /** @subsection FMC register array definitions */

    static _RW uint32_t* const FMC_BCRX_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52004000),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      (_RW uint32_t* const)UINT32_C(0x52004008),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      (_RW uint32_t* const)UINT32_C(0x52004010),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      (_RW uint32_t* const)UINT32_C(0x52004018),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    };

    static _RW uint32_t* const FMC_BTRX_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52004004),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      (_RW uint32_t* const)UINT32_C(0x5200400C),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      (_RW uint32_t* const)UINT32_C(0x52004014),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      (_RW uint32_t* const)UINT32_C(0x5200401C),   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    };

    static _RW uint32_t* const FMC_BWTRX_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52004104),   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      (_RW uint32_t* const)UINT32_C(0x5200410C),   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      (_RW uint32_t* const)UINT32_C(0x52004114),   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      (_RW uint32_t* const)UINT32_C(0x5200411C),   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    };

    /** @subsection FMC register definitions */

    static _RW uint32_t* const FMC_PCR_REG = (_RW uint32_t* const)UINT32_C(0x52004080);     /** @brief NAND flash control registers */
    static _RW uint32_t* const FMC_SR_REG = (_RW uint32_t* const)UINT32_C(0x52004084);      /** @brief This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.this is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.the ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty. */
    static _RW uint32_t* const FMC_PMEM_REG = (_RW uint32_t* const)UINT32_C(0x52004088);    /** @brief The FMC_PMEM read/write register contains the timing information for NAND flash memory bank. This information is used to access either the common memory space of the NAND flash for command, address write access and data read/write access. */
    static _RW uint32_t* const FMC_PATT_REG = (_RW uint32_t* const)UINT32_C(0x5200408C);    /** @brief The FMC_PATT read/write register contains the timing information for NAND flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND flash for the last address write access if the timing must differ from that of previous accesses (for ready/busy management, refer to section20.8.5: NAND flash prewait feature). */
    static _RO uint32_t* const FMC_ECCR_REG = (_RO uint32_t* const)UINT32_C(0x52004094);    /** @brief This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND flash memory page at the correct address (refer to section20.8.6: computation of the error correction code (ECC) in NAND flash memory), the data read/written from/to the NAND flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1. */
    static _RW uint32_t* const FMC_SDCR1_REG = (_RW uint32_t* const)UINT32_C(0x52004140);   /** @brief This register contains the control parameters for each SDRAM memory bank */
    static _RW uint32_t* const FMC_SDCR2_REG = (_RW uint32_t* const)UINT32_C(0x52004144);   /** @brief This register contains the control parameters for each SDRAM memory bank */
    static _RW uint32_t* const FMC_SDTR1_REG = (_RW uint32_t* const)UINT32_C(0x52004148);   /** @brief This register contains the timing parameters of each SDRAM bank */
    static _RW uint32_t* const FMC_SDTR2_REG = (_RW uint32_t* const)UINT32_C(0x5200414C);   /** @brief This register contains the timing parameters of each SDRAM bank */
    static _RW uint32_t* const FMC_SDCMR_REG = (_RW uint32_t* const)UINT32_C(0x52004150);   /** @brief This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the self-refresh and the power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks. */
    static _RW uint32_t* const FMC_SDRTR_REG = (_RW uint32_t* const)UINT32_C(0x52004154);   /** @brief This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the refresh timer count value.examplewhere 64 ms is the SDRAM refresh period.the refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.as soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.if a memory access is in progress, the auto-refresh request is delayed. However, if the memory access and auto-refresh requests are generated simultaneously, the auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.this register is common to SDRAM bank 1 and bank 2. */
    static _RO uint32_t* const FMC_SDSR_REG = (_RO uint32_t* const)UINT32_C(0x52004158);    /** @brief SDRAM status register */

    /** @subsection FMC field mask definitions */

    static const uint32_t FMC_BCRX_MBKEN_MASK = UINT32_C(0x00000001);       /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const uint32_t FMC_BCRX_MUXEN_MASK = UINT32_C(0x00000002);       /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const uint32_t FMC_BCRX_MTYP_MASK = UINT32_C(0x0000000C);        /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const uint32_t FMC_BCRX_MWID_MASK = UINT32_C(0x00000030);        /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const uint32_t FMC_BCRX_FACCEN_MASK = UINT32_C(0x00000040);      /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const uint32_t FMC_BCRX_BURSTEN_MASK = UINT32_C(0x00000100);     /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const uint32_t FMC_BCRX_WAITPOL_MASK = UINT32_C(0x00000200);     /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const uint32_t FMC_BCRX_WAITCFG_MASK = UINT32_C(0x00000800);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const uint32_t FMC_BCRX_WREN_MASK = UINT32_C(0x00001000);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const uint32_t FMC_BCRX_WAITEN_MASK = UINT32_C(0x00002000);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const uint32_t FMC_BCRX_EXTMOD_MASK = UINT32_C(0x00004000);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const uint32_t FMC_BCRX_ASYNCWAIT_MASK = UINT32_C(0x00008000);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const uint32_t FMC_BCRX_CPSIZE_MASK = UINT32_C(0x00070000);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const uint32_t FMC_BCRX_CBURSTRW_MASK = UINT32_C(0x00080000);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const uint32_t FMC_BCRX_CCLKEN_MASK = UINT32_C(0x00100000);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const uint32_t FMC_BCRX_WFDIS_MASK = UINT32_C(0x00200000);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_BMAP_MASK = UINT32_C(0x03000000);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_FMCEN_MASK = UINT32_C(0x80000000);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BTRX_ADDSET_MASK = UINT32_C(0x0000000F);      /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const uint32_t FMC_BTRX_ADDHLD_MASK = UINT32_C(0x000000F0);      /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const uint32_t FMC_BTRX_DATAST_MASK = UINT32_C(0x0000FF00);      /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const uint32_t FMC_BTRX_BUSTURN_MASK = UINT32_C(0x000F0000);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 126. ... */
    static const uint32_t FMC_BTRX_CLKDIV_MASK = UINT32_C(0x00F00000);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const uint32_t FMC_BTRX_DATLAT_MASK = UINT32_C(0x0F000000);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const uint32_t FMC_BTRX_ACCMOD_MASK = UINT32_C(0x30000000);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_BCRX_MBKEN_MASK = UINT32_C(0x00000001);       /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const uint32_t FMC_BCRX_MUXEN_MASK = UINT32_C(0x00000002);       /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const uint32_t FMC_BCRX_MTYP_MASK = UINT32_C(0x0000000C);        /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const uint32_t FMC_BCRX_MWID_MASK = UINT32_C(0x00000030);        /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const uint32_t FMC_BCRX_FACCEN_MASK = UINT32_C(0x00000040);      /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const uint32_t FMC_BCRX_BURSTEN_MASK = UINT32_C(0x00000100);     /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const uint32_t FMC_BCRX_WAITPOL_MASK = UINT32_C(0x00000200);     /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const uint32_t FMC_BCRX_WAITCFG_MASK = UINT32_C(0x00000800);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const uint32_t FMC_BCRX_WREN_MASK = UINT32_C(0x00001000);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const uint32_t FMC_BCRX_WAITEN_MASK = UINT32_C(0x00002000);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const uint32_t FMC_BCRX_EXTMOD_MASK = UINT32_C(0x00004000);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const uint32_t FMC_BCRX_ASYNCWAIT_MASK = UINT32_C(0x00008000);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const uint32_t FMC_BCRX_CPSIZE_MASK = UINT32_C(0x00070000);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const uint32_t FMC_BCRX_CBURSTRW_MASK = UINT32_C(0x00080000);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const uint32_t FMC_BCRX_CCLKEN_MASK = UINT32_C(0x00100000);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const uint32_t FMC_BCRX_WFDIS_MASK = UINT32_C(0x00200000);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_BMAP_MASK = UINT32_C(0x03000000);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_FMCEN_MASK = UINT32_C(0x80000000);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BTRX_ADDSET_MASK = UINT32_C(0x0000000F);      /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const uint32_t FMC_BTRX_ADDHLD_MASK = UINT32_C(0x000000F0);      /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const uint32_t FMC_BTRX_DATAST_MASK = UINT32_C(0x0000FF00);      /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const uint32_t FMC_BTRX_BUSTURN_MASK = UINT32_C(0x000F0000);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 1. ... */
    static const uint32_t FMC_BTRX_CLKDIV_MASK = UINT32_C(0x00F00000);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const uint32_t FMC_BTRX_DATLAT_MASK = UINT32_C(0x0F000000);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const uint32_t FMC_BTRX_ACCMOD_MASK = UINT32_C(0x30000000);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_BCRX_MBKEN_MASK = UINT32_C(0x00000001);       /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const uint32_t FMC_BCRX_MUXEN_MASK = UINT32_C(0x00000002);       /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const uint32_t FMC_BCRX_MTYP_MASK = UINT32_C(0x0000000C);        /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const uint32_t FMC_BCRX_MWID_MASK = UINT32_C(0x00000030);        /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const uint32_t FMC_BCRX_FACCEN_MASK = UINT32_C(0x00000040);      /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const uint32_t FMC_BCRX_BURSTEN_MASK = UINT32_C(0x00000100);     /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const uint32_t FMC_BCRX_WAITPOL_MASK = UINT32_C(0x00000200);     /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const uint32_t FMC_BCRX_WAITCFG_MASK = UINT32_C(0x00000800);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const uint32_t FMC_BCRX_WREN_MASK = UINT32_C(0x00001000);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const uint32_t FMC_BCRX_WAITEN_MASK = UINT32_C(0x00002000);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const uint32_t FMC_BCRX_EXTMOD_MASK = UINT32_C(0x00004000);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const uint32_t FMC_BCRX_ASYNCWAIT_MASK = UINT32_C(0x00008000);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const uint32_t FMC_BCRX_CPSIZE_MASK = UINT32_C(0x00070000);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const uint32_t FMC_BCRX_CBURSTRW_MASK = UINT32_C(0x00080000);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const uint32_t FMC_BCRX_CCLKEN_MASK = UINT32_C(0x00100000);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const uint32_t FMC_BCRX_WFDIS_MASK = UINT32_C(0x00200000);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_BMAP_MASK = UINT32_C(0x03000000);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_FMCEN_MASK = UINT32_C(0x80000000);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BTRX_ADDSET_MASK = UINT32_C(0x0000000F);      /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const uint32_t FMC_BTRX_ADDHLD_MASK = UINT32_C(0x000000F0);      /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const uint32_t FMC_BTRX_DATAST_MASK = UINT32_C(0x0000FF00);      /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const uint32_t FMC_BTRX_BUSTURN_MASK = UINT32_C(0x000F0000);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD =1. ... */
    static const uint32_t FMC_BTRX_CLKDIV_MASK = UINT32_C(0x00F00000);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const uint32_t FMC_BTRX_DATLAT_MASK = UINT32_C(0x0F000000);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const uint32_t FMC_BTRX_ACCMOD_MASK = UINT32_C(0x30000000);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_BCRX_MBKEN_MASK = UINT32_C(0x00000001);       /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const uint32_t FMC_BCRX_MUXEN_MASK = UINT32_C(0x00000002);       /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const uint32_t FMC_BCRX_MTYP_MASK = UINT32_C(0x0000000C);        /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const uint32_t FMC_BCRX_MWID_MASK = UINT32_C(0x00000030);        /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const uint32_t FMC_BCRX_FACCEN_MASK = UINT32_C(0x00000040);      /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const uint32_t FMC_BCRX_BURSTEN_MASK = UINT32_C(0x00000100);     /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const uint32_t FMC_BCRX_WAITPOL_MASK = UINT32_C(0x00000200);     /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const uint32_t FMC_BCRX_WAITCFG_MASK = UINT32_C(0x00000800);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const uint32_t FMC_BCRX_WREN_MASK = UINT32_C(0x00001000);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const uint32_t FMC_BCRX_WAITEN_MASK = UINT32_C(0x00002000);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const uint32_t FMC_BCRX_EXTMOD_MASK = UINT32_C(0x00004000);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const uint32_t FMC_BCRX_ASYNCWAIT_MASK = UINT32_C(0x00008000);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const uint32_t FMC_BCRX_CPSIZE_MASK = UINT32_C(0x00070000);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const uint32_t FMC_BCRX_CBURSTRW_MASK = UINT32_C(0x00080000);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const uint32_t FMC_BCRX_CCLKEN_MASK = UINT32_C(0x00100000);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const uint32_t FMC_BCRX_WFDIS_MASK = UINT32_C(0x00200000);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_BMAP_MASK = UINT32_C(0x03000000);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BCRX_FMCEN_MASK = UINT32_C(0x80000000);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const uint32_t FMC_BTRX_ADDSET_MASK = UINT32_C(0x0000000F);      /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const uint32_t FMC_BTRX_ADDHLD_MASK = UINT32_C(0x000000F0);      /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const uint32_t FMC_BTRX_DATAST_MASK = UINT32_C(0x0000FF00);      /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const uint32_t FMC_BTRX_BUSTURN_MASK = UINT32_C(0x000F0000);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD =1. ... */
    static const uint32_t FMC_BTRX_CLKDIV_MASK = UINT32_C(0x00F00000);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const uint32_t FMC_BTRX_DATLAT_MASK = UINT32_C(0x0F000000);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const uint32_t FMC_BTRX_ACCMOD_MASK = UINT32_C(0x30000000);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_PCR_PWAITEN_MASK = UINT32_C(0x00000002);      /** @brief Wait feature enable bit. This bit enables the wait feature for the NAND flash memory bank: */
    static const uint32_t FMC_PCR_PBKEN_MASK = UINT32_C(0x00000004);        /** @brief NAND flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus */
    static const uint32_t FMC_PCR_PWID_MASK = UINT32_C(0x00000030);         /** @brief Data bus width. These bits define the external memory device width. */
    static const uint32_t FMC_PCR_ECCEN_MASK = UINT32_C(0x00000040);        /** @brief ECC computation logic enable bit */
    static const uint32_t FMC_PCR_TCLR_MASK = UINT32_C(0x00001E00);         /** @brief CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const uint32_t FMC_PCR_TAR_MASK = UINT32_C(0x0001E000);          /** @brief ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const uint32_t FMC_PCR_ECCPS_MASK = UINT32_C(0x000E0000);        /** @brief ECC page size. These bits define the page size for the extended ECC: */
    static const uint32_t FMC_SR_IRS_MASK = UINT32_C(0x00000001);           /** @brief Interrupt rising edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const uint32_t FMC_SR_ILS_MASK = UINT32_C(0x00000002);           /** @brief Interrupt high-level status the flag is set by hardware and reset by software. */
    static const uint32_t FMC_SR_IFS_MASK = UINT32_C(0x00000004);           /** @brief Interrupt falling edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const uint32_t FMC_SR_IREN_MASK = UINT32_C(0x00000008);          /** @brief Interrupt rising edge detection enable bit */
    static const uint32_t FMC_SR_ILEN_MASK = UINT32_C(0x00000010);          /** @brief Interrupt high-level detection enable bit */
    static const uint32_t FMC_SR_IFEN_MASK = UINT32_C(0x00000020);          /** @brief Interrupt falling edge detection enable bit */
    static const uint32_t FMC_SR_FEMPT_MASK = UINT32_C(0x00000040);         /** @brief FIFO empty. Read-only bit that provides the status of the FIFO */
    static const uint32_t FMC_PMEM_MEMSET_MASK = UINT32_C(0x000000FF);      /** @brief Common memory x setup time these bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const uint32_t FMC_PMEM_MEMWAIT_MASK = UINT32_C(0x0000FF00);     /** @brief Common memory wait time these bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const uint32_t FMC_PMEM_MEMHOLD_MASK = UINT32_C(0x00FF0000);     /** @brief Common memory hold time these bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const uint32_t FMC_PMEM_MEMHIZ_MASK = UINT32_C(0xFF000000);      /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions: */
    static const uint32_t FMC_PATT_ATTSET_MASK = UINT32_C(0x000000FF);      /** @brief Attribute memory setup time these bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const uint32_t FMC_PATT_ATTWAIT_MASK = UINT32_C(0x0000FF00);     /** @brief Attribute memory wait time these bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const uint32_t FMC_PATT_ATTHOLD_MASK = UINT32_C(0x00FF0000);     /** @brief Attribute memory hold time these bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const uint32_t FMC_PATT_ATTHIZ_MASK = UINT32_C(0xFF000000);      /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction: */
    static const uint32_t FMC_BWTRX_ADDSET_MASK = UINT32_C(0x0000000F);     /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const uint32_t FMC_BWTRX_ADDHLD_MASK = UINT32_C(0x000000F0);     /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const uint32_t FMC_BWTRX_DATAST_MASK = UINT32_C(0x0000FF00);     /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const uint32_t FMC_BWTRX_BUSTURN_MASK = UINT32_C(0x000F0000);    /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const uint32_t FMC_BWTRX_ACCMOD_MASK = UINT32_C(0x30000000);     /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_BWTRX_ADDSET_MASK = UINT32_C(0x0000000F);     /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const uint32_t FMC_BWTRX_ADDHLD_MASK = UINT32_C(0x000000F0);     /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const uint32_t FMC_BWTRX_DATAST_MASK = UINT32_C(0x0000FF00);     /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const uint32_t FMC_BWTRX_BUSTURN_MASK = UINT32_C(0x000F0000);    /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const uint32_t FMC_BWTRX_ACCMOD_MASK = UINT32_C(0x30000000);     /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_BWTRX_ADDSET_MASK = UINT32_C(0x0000000F);     /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const uint32_t FMC_BWTRX_ADDHLD_MASK = UINT32_C(0x000000F0);     /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const uint32_t FMC_BWTRX_DATAST_MASK = UINT32_C(0x0000FF00);     /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const uint32_t FMC_BWTRX_BUSTURN_MASK = UINT32_C(0x000F0000);    /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const uint32_t FMC_BWTRX_ACCMOD_MASK = UINT32_C(0x30000000);     /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_BWTRX_ADDSET_MASK = UINT32_C(0x0000000F);     /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const uint32_t FMC_BWTRX_ADDHLD_MASK = UINT32_C(0x000000F0);     /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const uint32_t FMC_BWTRX_DATAST_MASK = UINT32_C(0x0000FF00);     /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const uint32_t FMC_BWTRX_BUSTURN_MASK = UINT32_C(0x000F0000);    /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const uint32_t FMC_BWTRX_ACCMOD_MASK = UINT32_C(0x30000000);     /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const uint32_t FMC_SDCR1_NC_MASK = UINT32_C(0x00000003);         /** @brief Number of column address bits these bits define the number of bits of a column address. */
    static const uint32_t FMC_SDCR1_NR_MASK = UINT32_C(0x0000000C);         /** @brief Number of row address bits these bits define the number of bits of a row address. */
    static const uint32_t FMC_SDCR1_MWID_MASK = UINT32_C(0x00000030);       /** @brief Memory data bus width. These bits define the memory device width. */
    static const uint32_t FMC_SDCR1_NB_MASK = UINT32_C(0x00000040);         /** @brief Number of internal banks this bit sets the number of internal banks. */
    static const uint32_t FMC_SDCR1_CAS_MASK = UINT32_C(0x00000180);        /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
    static const uint32_t FMC_SDCR1_WP_MASK = UINT32_C(0x00000200);         /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
    static const uint32_t FMC_SDCR1_SDCLK_MASK = UINT32_C(0x00000C00);      /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDCR1_RBURST_MASK = UINT32_C(0x00001000);     /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDCR1_RPIPE_MASK = UINT32_C(0x00006000);      /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDCR2_NC_MASK = UINT32_C(0x00000003);         /** @brief Number of column address bits these bits define the number of bits of a column address. */
    static const uint32_t FMC_SDCR2_NR_MASK = UINT32_C(0x0000000C);         /** @brief Number of row address bits these bits define the number of bits of a row address. */
    static const uint32_t FMC_SDCR2_MWID_MASK = UINT32_C(0x00000030);       /** @brief Memory data bus width. These bits define the memory device width. */
    static const uint32_t FMC_SDCR2_NB_MASK = UINT32_C(0x00000040);         /** @brief Number of internal banks this bit sets the number of internal banks. */
    static const uint32_t FMC_SDCR2_CAS_MASK = UINT32_C(0x00000180);        /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
    static const uint32_t FMC_SDCR2_WP_MASK = UINT32_C(0x00000200);         /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
    static const uint32_t FMC_SDCR2_SDCLK_MASK = UINT32_C(0x00000C00);      /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDCR2_RBURST_MASK = UINT32_C(0x00001000);     /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDCR2_RPIPE_MASK = UINT32_C(0x00006000);      /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const uint32_t FMC_SDTR1_TMRD_MASK = UINT32_C(0x0000000F);       /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
    static const uint32_t FMC_SDTR1_TXSR_MASK = UINT32_C(0x000000F0);       /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
    static const uint32_t FMC_SDTR1_TRAS_MASK = UINT32_C(0x00000F00);       /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
    static const uint32_t FMC_SDTR1_TRC_MASK = UINT32_C(0x0000F000);        /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const uint32_t FMC_SDTR1_TWR_MASK = UINT32_C(0x000F0000);        /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
    static const uint32_t FMC_SDTR1_TRP_MASK = UINT32_C(0x00F00000);        /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const uint32_t FMC_SDTR1_TRCD_MASK = UINT32_C(0x0F000000);       /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
    static const uint32_t FMC_SDTR2_TMRD_MASK = UINT32_C(0x0000000F);       /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
    static const uint32_t FMC_SDTR2_TXSR_MASK = UINT32_C(0x000000F0);       /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
    static const uint32_t FMC_SDTR2_TRAS_MASK = UINT32_C(0x00000F00);       /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
    static const uint32_t FMC_SDTR2_TRC_MASK = UINT32_C(0x0000F000);        /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const uint32_t FMC_SDTR2_TWR_MASK = UINT32_C(0x000F0000);        /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
    static const uint32_t FMC_SDTR2_TRP_MASK = UINT32_C(0x00F00000);        /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const uint32_t FMC_SDTR2_TRCD_MASK = UINT32_C(0x0F000000);       /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
    static const uint32_t FMC_SDCMR_MODE_MASK = UINT32_C(0x00000007);       /** @brief Command mode these bits define the command issued to the SDRAM device. Note: when a command is issued, at least one command target bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: if two SDRAM banks are used, the auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: if only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. */
    static const uint32_t FMC_SDCMR_CTB2_MASK = UINT32_C(0x00000008);       /** @brief Command target bank 2 this bit indicates whether the command will be issued to SDRAM bank 2 or not. */
    static const uint32_t FMC_SDCMR_CTB1_MASK = UINT32_C(0x00000010);       /** @brief Command target bank 1 this bit indicates whether the command will be issued to SDRAM bank 1 or not. */
    static const uint32_t FMC_SDCMR_NRFS_MASK = UINT32_C(0x000001E0);       /** @brief Number of auto-refresh these bits define the number of consecutive auto-refresh commands issued when MODE = 011. .... */
    static const uint32_t FMC_SDCMR_MRD_MASK = UINT32_C(0x007FFE00);        /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
    static const uint32_t FMC_SDRTR_CRE_MASK = UINT32_C(0x00000001);        /** @brief Clear refresh error flag this bit is used to clear the refresh error flag (RE) in the status register. */
    static const uint32_t FMC_SDRTR_COUNT_MASK = UINT32_C(0x00003FFE);      /** @brief Refresh timer count this 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / number of rows) - 20 */
    static const uint32_t FMC_SDRTR_REIE_MASK = UINT32_C(0x00004000);       /** @brief RES interrupt enable */
    static const uint32_t FMC_SDSR_RE_MASK = UINT32_C(0x00000001);          /** @brief Refresh error flag an interrupt is generated if REIE = 1 and RE = 1 */
    static const uint32_t FMC_SDSR_MODES1_MASK = UINT32_C(0x00000006);      /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
    static const uint32_t FMC_SDSR_MODES2_MASK = UINT32_C(0x00000018);      /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */

    /** @subsection FMC field position definitions */

    static const int32_t FMC_SDSR_MBKEN_POS = INT32_C(0);        /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const int32_t FMC_SDSR_MUXEN_POS = INT32_C(1);        /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const int32_t FMC_SDSR_MTYP_POS = INT32_C(2);         /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const int32_t FMC_SDSR_MWID_POS = INT32_C(4);         /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const int32_t FMC_SDSR_FACCEN_POS = INT32_C(6);       /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const int32_t FMC_SDSR_BURSTEN_POS = INT32_C(8);      /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const int32_t FMC_SDSR_WAITPOL_POS = INT32_C(9);      /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const int32_t FMC_SDSR_WAITCFG_POS = INT32_C(11);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const int32_t FMC_SDSR_WREN_POS = INT32_C(12);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const int32_t FMC_SDSR_WAITEN_POS = INT32_C(13);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const int32_t FMC_SDSR_EXTMOD_POS = INT32_C(14);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const int32_t FMC_SDSR_ASYNCWAIT_POS = INT32_C(15);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const int32_t FMC_SDSR_CPSIZE_POS = INT32_C(16);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const int32_t FMC_SDSR_CBURSTRW_POS = INT32_C(19);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const int32_t FMC_SDSR_CCLKEN_POS = INT32_C(20);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const int32_t FMC_SDSR_WFDIS_POS = INT32_C(21);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_BMAP_POS = INT32_C(24);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_FMCEN_POS = INT32_C(31);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 126. ... */
    static const int32_t FMC_SDSR_CLKDIV_POS = INT32_C(20);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const int32_t FMC_SDSR_DATLAT_POS = INT32_C(24);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_MBKEN_POS = INT32_C(0);        /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const int32_t FMC_SDSR_MUXEN_POS = INT32_C(1);        /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const int32_t FMC_SDSR_MTYP_POS = INT32_C(2);         /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const int32_t FMC_SDSR_MWID_POS = INT32_C(4);         /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const int32_t FMC_SDSR_FACCEN_POS = INT32_C(6);       /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const int32_t FMC_SDSR_BURSTEN_POS = INT32_C(8);      /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const int32_t FMC_SDSR_WAITPOL_POS = INT32_C(9);      /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const int32_t FMC_SDSR_WAITCFG_POS = INT32_C(11);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const int32_t FMC_SDSR_WREN_POS = INT32_C(12);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const int32_t FMC_SDSR_WAITEN_POS = INT32_C(13);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const int32_t FMC_SDSR_EXTMOD_POS = INT32_C(14);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const int32_t FMC_SDSR_ASYNCWAIT_POS = INT32_C(15);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const int32_t FMC_SDSR_CPSIZE_POS = INT32_C(16);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const int32_t FMC_SDSR_CBURSTRW_POS = INT32_C(19);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const int32_t FMC_SDSR_CCLKEN_POS = INT32_C(20);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const int32_t FMC_SDSR_WFDIS_POS = INT32_C(21);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_BMAP_POS = INT32_C(24);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_FMCEN_POS = INT32_C(31);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 1. ... */
    static const int32_t FMC_SDSR_CLKDIV_POS = INT32_C(20);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const int32_t FMC_SDSR_DATLAT_POS = INT32_C(24);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_MBKEN_POS = INT32_C(0);        /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const int32_t FMC_SDSR_MUXEN_POS = INT32_C(1);        /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const int32_t FMC_SDSR_MTYP_POS = INT32_C(2);         /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const int32_t FMC_SDSR_MWID_POS = INT32_C(4);         /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const int32_t FMC_SDSR_FACCEN_POS = INT32_C(6);       /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const int32_t FMC_SDSR_BURSTEN_POS = INT32_C(8);      /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const int32_t FMC_SDSR_WAITPOL_POS = INT32_C(9);      /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const int32_t FMC_SDSR_WAITCFG_POS = INT32_C(11);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const int32_t FMC_SDSR_WREN_POS = INT32_C(12);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const int32_t FMC_SDSR_WAITEN_POS = INT32_C(13);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const int32_t FMC_SDSR_EXTMOD_POS = INT32_C(14);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const int32_t FMC_SDSR_ASYNCWAIT_POS = INT32_C(15);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const int32_t FMC_SDSR_CPSIZE_POS = INT32_C(16);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const int32_t FMC_SDSR_CBURSTRW_POS = INT32_C(19);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const int32_t FMC_SDSR_CCLKEN_POS = INT32_C(20);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const int32_t FMC_SDSR_WFDIS_POS = INT32_C(21);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_BMAP_POS = INT32_C(24);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_FMCEN_POS = INT32_C(31);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD =1. ... */
    static const int32_t FMC_SDSR_CLKDIV_POS = INT32_C(20);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const int32_t FMC_SDSR_DATLAT_POS = INT32_C(24);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_MBKEN_POS = INT32_C(0);        /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
    static const int32_t FMC_SDSR_MUXEN_POS = INT32_C(1);        /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
    static const int32_t FMC_SDSR_MTYP_POS = INT32_C(2);         /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
    static const int32_t FMC_SDSR_MWID_POS = INT32_C(4);         /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
    static const int32_t FMC_SDSR_FACCEN_POS = INT32_C(6);       /** @brief Flash access enable this bit enables NOR flash memory access operations. */
    static const int32_t FMC_SDSR_BURSTEN_POS = INT32_C(8);      /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
    static const int32_t FMC_SDSR_WAITPOL_POS = INT32_C(9);      /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
    static const int32_t FMC_SDSR_WAITCFG_POS = INT32_C(11);     /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
    static const int32_t FMC_SDSR_WREN_POS = INT32_C(12);        /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
    static const int32_t FMC_SDSR_WAITEN_POS = INT32_C(13);      /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
    static const int32_t FMC_SDSR_EXTMOD_POS = INT32_C(14);      /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
    static const int32_t FMC_SDSR_ASYNCWAIT_POS = INT32_C(15);   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
    static const int32_t FMC_SDSR_CPSIZE_POS = INT32_C(16);      /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
    static const int32_t FMC_SDSR_CBURSTRW_POS = INT32_C(19);    /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
    static const int32_t FMC_SDSR_CCLKEN_POS = INT32_C(20);      /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
    static const int32_t FMC_SDSR_WFDIS_POS = INT32_C(21);       /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_BMAP_POS = INT32_C(24);        /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_FMCEN_POS = INT32_C(31);       /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD =1. ... */
    static const int32_t FMC_SDSR_CLKDIV_POS = INT32_C(20);      /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
    static const int32_t FMC_SDSR_DATLAT_POS = INT32_C(24);      /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_PWAITEN_POS = INT32_C(1);      /** @brief Wait feature enable bit. This bit enables the wait feature for the NAND flash memory bank: */
    static const int32_t FMC_SDSR_PBKEN_POS = INT32_C(2);        /** @brief NAND flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus */
    static const int32_t FMC_SDSR_PWID_POS = INT32_C(4);         /** @brief Data bus width. These bits define the external memory device width. */
    static const int32_t FMC_SDSR_ECCEN_POS = INT32_C(6);        /** @brief ECC computation logic enable bit */
    static const int32_t FMC_SDSR_TCLR_POS = INT32_C(9);         /** @brief CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const int32_t FMC_SDSR_TAR_POS = INT32_C(13);         /** @brief ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
    static const int32_t FMC_SDSR_ECCPS_POS = INT32_C(17);       /** @brief ECC page size. These bits define the page size for the extended ECC: */
    static const int32_t FMC_SDSR_IRS_POS = INT32_C(0);          /** @brief Interrupt rising edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const int32_t FMC_SDSR_ILS_POS = INT32_C(1);          /** @brief Interrupt high-level status the flag is set by hardware and reset by software. */
    static const int32_t FMC_SDSR_IFS_POS = INT32_C(2);          /** @brief Interrupt falling edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
    static const int32_t FMC_SDSR_IREN_POS = INT32_C(3);         /** @brief Interrupt rising edge detection enable bit */
    static const int32_t FMC_SDSR_ILEN_POS = INT32_C(4);         /** @brief Interrupt high-level detection enable bit */
    static const int32_t FMC_SDSR_IFEN_POS = INT32_C(5);         /** @brief Interrupt falling edge detection enable bit */
    static const int32_t FMC_SDSR_FEMPT_POS = INT32_C(6);        /** @brief FIFO empty. Read-only bit that provides the status of the FIFO */
    static const int32_t FMC_SDSR_MEMSET_POS = INT32_C(0);       /** @brief Common memory x setup time these bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const int32_t FMC_SDSR_MEMWAIT_POS = INT32_C(8);      /** @brief Common memory wait time these bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const int32_t FMC_SDSR_MEMHOLD_POS = INT32_C(16);     /** @brief Common memory hold time these bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND flash read or write access to common memory space: */
    static const int32_t FMC_SDSR_MEMHIZ_POS = INT32_C(24);      /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions: */
    static const int32_t FMC_SDSR_ATTSET_POS = INT32_C(0);       /** @brief Attribute memory setup time these bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const int32_t FMC_SDSR_ATTWAIT_POS = INT32_C(8);      /** @brief Attribute memory wait time these bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
    static const int32_t FMC_SDSR_ATTHOLD_POS = INT32_C(16);     /** @brief Attribute memory hold time these bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
    static const int32_t FMC_SDSR_ATTHIZ_POS = INT32_C(24);      /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction: */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_ADDSET_POS = INT32_C(0);       /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
    static const int32_t FMC_SDSR_ADDHLD_POS = INT32_C(4);       /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
    static const int32_t FMC_SDSR_DATAST_POS = INT32_C(8);       /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
    static const int32_t FMC_SDSR_BUSTURN_POS = INT32_C(16);     /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
    static const int32_t FMC_SDSR_ACCMOD_POS = INT32_C(28);      /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    static const int32_t FMC_SDSR_NC_POS = INT32_C(0);           /** @brief Number of column address bits these bits define the number of bits of a column address. */
    static const int32_t FMC_SDSR_NR_POS = INT32_C(2);           /** @brief Number of row address bits these bits define the number of bits of a row address. */
    static const int32_t FMC_SDSR_MWID_POS = INT32_C(4);         /** @brief Memory data bus width. These bits define the memory device width. */
    static const int32_t FMC_SDSR_NB_POS = INT32_C(6);           /** @brief Number of internal banks this bit sets the number of internal banks. */
    static const int32_t FMC_SDSR_CAS_POS = INT32_C(7);          /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
    static const int32_t FMC_SDSR_WP_POS = INT32_C(9);           /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
    static const int32_t FMC_SDSR_SDCLK_POS = INT32_C(10);       /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDSR_RBURST_POS = INT32_C(12);      /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDSR_RPIPE_POS = INT32_C(13);       /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDSR_NC_POS = INT32_C(0);           /** @brief Number of column address bits these bits define the number of bits of a column address. */
    static const int32_t FMC_SDSR_NR_POS = INT32_C(2);           /** @brief Number of row address bits these bits define the number of bits of a row address. */
    static const int32_t FMC_SDSR_MWID_POS = INT32_C(4);         /** @brief Memory data bus width. These bits define the memory device width. */
    static const int32_t FMC_SDSR_NB_POS = INT32_C(6);           /** @brief Number of internal banks this bit sets the number of internal banks. */
    static const int32_t FMC_SDSR_CAS_POS = INT32_C(7);          /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
    static const int32_t FMC_SDSR_WP_POS = INT32_C(9);           /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
    static const int32_t FMC_SDSR_SDCLK_POS = INT32_C(10);       /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDSR_RBURST_POS = INT32_C(12);      /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDSR_RPIPE_POS = INT32_C(13);       /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    static const int32_t FMC_SDSR_TMRD_POS = INT32_C(0);         /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
    static const int32_t FMC_SDSR_TXSR_POS = INT32_C(4);         /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
    static const int32_t FMC_SDSR_TRAS_POS = INT32_C(8);         /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
    static const int32_t FMC_SDSR_TRC_POS = INT32_C(12);         /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const int32_t FMC_SDSR_TWR_POS = INT32_C(16);         /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
    static const int32_t FMC_SDSR_TRP_POS = INT32_C(20);         /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const int32_t FMC_SDSR_TRCD_POS = INT32_C(24);        /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
    static const int32_t FMC_SDSR_TMRD_POS = INT32_C(0);         /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
    static const int32_t FMC_SDSR_TXSR_POS = INT32_C(4);         /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
    static const int32_t FMC_SDSR_TRAS_POS = INT32_C(8);         /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
    static const int32_t FMC_SDSR_TRC_POS = INT32_C(12);         /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const int32_t FMC_SDSR_TWR_POS = INT32_C(16);         /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
    static const int32_t FMC_SDSR_TRP_POS = INT32_C(20);         /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
    static const int32_t FMC_SDSR_TRCD_POS = INT32_C(24);        /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
    static const int32_t FMC_SDSR_MODE_POS = INT32_C(0);         /** @brief Command mode these bits define the command issued to the SDRAM device. Note: when a command is issued, at least one command target bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: if two SDRAM banks are used, the auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: if only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. */
    static const int32_t FMC_SDSR_CTB2_POS = INT32_C(3);         /** @brief Command target bank 2 this bit indicates whether the command will be issued to SDRAM bank 2 or not. */
    static const int32_t FMC_SDSR_CTB1_POS = INT32_C(4);         /** @brief Command target bank 1 this bit indicates whether the command will be issued to SDRAM bank 1 or not. */
    static const int32_t FMC_SDSR_NRFS_POS = INT32_C(5);         /** @brief Number of auto-refresh these bits define the number of consecutive auto-refresh commands issued when MODE = 011. .... */
    static const int32_t FMC_SDSR_MRD_POS = INT32_C(9);          /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
    static const int32_t FMC_SDSR_CRE_POS = INT32_C(0);          /** @brief Clear refresh error flag this bit is used to clear the refresh error flag (RE) in the status register. */
    static const int32_t FMC_SDSR_COUNT_POS = INT32_C(1);        /** @brief Refresh timer count this 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / number of rows) - 20 */
    static const int32_t FMC_SDSR_REIE_POS = INT32_C(14);        /** @brief RES interrupt enable */
    static const int32_t FMC_SDSR_RE_POS = INT32_C(0);           /** @brief Refresh error flag an interrupt is generated if REIE = 1 and RE = 1 */
    static const int32_t FMC_SDSR_MODES1_POS = INT32_C(1);       /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
    static const int32_t FMC_SDSR_MODES2_POS = INT32_C(3);       /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */

    /**********************************************************************************************
     * @section CEC Definitions
     **********************************************************************************************/

    /** @subsection CEC IRQ interrupt definitions */

    static const int32_t CEC_IRQ = INT32_C(94);   /** @brief HDMI-CEC global interrupt */

    /** @subsection CEC register definitions */

    static _RW uint32_t* const CEC_CR_REG = (_RW uint32_t* const)UINT32_C(0x40006C00);     /** @brief CEC control register */
    static _RW uint32_t* const CEC_CFGR_REG = (_RW uint32_t* const)UINT32_C(0x40006C04);   /** @brief This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0. */
    static _RW uint32_t* const CEC_TXDR_REG = (_RW uint32_t* const)UINT32_C(0x40006C08);   /** @brief CEC tx data register */
    static _RO uint32_t* const CEC_RXDR_REG = (_RO uint32_t* const)UINT32_C(0x40006C0C);   /** @brief CEC rx data register */
    static _RW uint32_t* const CEC_ISR_REG = (_RW uint32_t* const)UINT32_C(0x40006C10);    /** @brief CEC interrupt and status register */
    static _RW uint32_t* const CEC_IER_REG = (_RW uint32_t* const)UINT32_C(0x40006C14);    /** @brief CEC interrupt enable register */

    /** @subsection CEC field mask definitions */

    static const uint32_t CEC_CR_CECEN_MASK = UINT32_C(0x00000001);        /** @brief CEC enable the CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission. */
    static const uint32_t CEC_CR_TXSOM_MASK = UINT32_C(0x00000002);        /** @brief Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR headers first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception */
    static const uint32_t CEC_CR_TXEOM_MASK = UINT32_C(0x00000004);        /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message) */
    static const uint32_t CEC_CFGR_SFT_MASK = UINT32_C(0x00000007);        /** @brief Signal free time SFT bits are set by software. In the sft=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 data-bit periods if CEC is the new bus initiator ** 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods */
    static const uint32_t CEC_CFGR_RXTOL_MASK = UINT32_C(0x00000008);      /** @brief Rx-Tolerance the RXTOL bit is set and cleared by software. ** start-bit, +/- 200 s rise, +/- 200 s fall. ** data-bit: +/- 200 s rise. +/- 350 s fall. ** start-bit: +/- 400 s rise, +/- 400 s fall ** data-bit: +/-300 s rise, +/- 500 s fall */
    static const uint32_t CEC_CFGR_BRESTP_MASK = UINT32_C(0x00000010);     /** @brief Rx-Stop on bit rising error the BRESTP bit is set and cleared by software. */
    static const uint32_t CEC_CFGR_BREGEN_MASK = UINT32_C(0x00000020);     /** @brief Generate error-bit on bit rising error the BREGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0 */
    static const uint32_t CEC_CFGR_LBPEGEN_MASK = UINT32_C(0x00000040);    /** @brief Generate error-bit on long bit period error the LBPEGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0 */
    static const uint32_t CEC_CFGR_BRDNOGEN_MASK = UINT32_C(0x00000080);   /** @brief Avoid error-bit generation in broadcast the BRDNOGEN bit is set and cleared by software. */
    static const uint32_t CEC_CFGR_SFTOPT_MASK = UINT32_C(0x00000100);     /** @brief SFT option bit the SFTOPT bit is set and cleared by software. */
    static const uint32_t CEC_CFGR_OAR_MASK = UINT32_C(0x7FFF0000);        /** @brief Own addresses configuration the OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. */
    static const uint32_t CEC_CFGR_LSTN_MASK = UINT32_C(0x80000000);       /** @brief Listen mode LSTN bit is set and cleared by software. */
    static const uint32_t CEC_TXDR_TXD_MASK = UINT32_C(0x000000FF);        /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 */
    static const uint32_t CEC_RXDR_RXD_MASK = UINT32_C(0x000000FF);        /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
    static const uint32_t CEC_ISR_RXBR_MASK = UINT32_C(0x00000001);        /** @brief Rx-Byte received the RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_RXEND_MASK = UINT32_C(0x00000002);       /** @brief End of reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1. */
    static const uint32_t CEC_ISR_RXOVR_MASK = UINT32_C(0x00000004);       /** @brief Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_BRE_MASK = UINT32_C(0x00000008);         /** @brief Rx-Bit rising error BRE is set by hardware in case a data-bit waveform is detected with bit rising error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an error-bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_SBPE_MASK = UINT32_C(0x00000010);        /** @brief Rx-Short bit period error SBPE is set by hardware in case a data-bit waveform is detected with short bit period error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an error-bit on the CEC line. SBPE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_LBPE_MASK = UINT32_C(0x00000020);        /** @brief Rx-Long bit period error LBPE is set by hardware in case a data-bit waveform is detected with long bit period error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an error-bit on the CEC line if LBPEGEN=1. In case of broadcast, error-bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_RXACKE_MASK = UINT32_C(0x00000040);      /** @brief Rx-Missing acknowledge in receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1. */
    static const uint32_t CEC_ISR_ARBLST_MASK = UINT32_C(0x00000080);      /** @brief Arbitration lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXBR_MASK = UINT32_C(0x00000100);        /** @brief Tx-Byte request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXEND_MASK = UINT32_C(0x00000200);       /** @brief End of transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXUDR_MASK = UINT32_C(0x00000400);       /** @brief Tx-Buffer underrun in transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1 */
    static const uint32_t CEC_ISR_TXERR_MASK = UINT32_C(0x00000800);       /** @brief Tx-Error in transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1. */
    static const uint32_t CEC_ISR_TXACKE_MASK = UINT32_C(0x00001000);      /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
    static const uint32_t CEC_IER_RXBRIE_MASK = UINT32_C(0x00000001);      /** @brief Rx-Byte received interrupt enable the RXBRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_RXENDIE_MASK = UINT32_C(0x00000002);     /** @brief End of reception interrupt enable the RXENDIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_RXOVRIE_MASK = UINT32_C(0x00000004);     /** @brief Rx-Buffer overrun interrupt enable the RXOVRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_BREIE_MASK = UINT32_C(0x00000008);       /** @brief Bit rising error interrupt enable the BREIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_SBPEIE_MASK = UINT32_C(0x00000010);      /** @brief Short bit period error interrupt enable the SBPEIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_LBPEIE_MASK = UINT32_C(0x00000020);      /** @brief Long bit period error interrupt enable the LBPEIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_RXACKIE_MASK = UINT32_C(0x00000040);     /** @brief Rx-Missing acknowledge error interrupt enable the RXACKIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_ARBLSTIE_MASK = UINT32_C(0x00000080);    /** @brief Arbitration lost interrupt enable the ARBLSTIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXBRIE_MASK = UINT32_C(0x00000100);      /** @brief Tx-Byte request interrupt enable the TXBRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXENDIE_MASK = UINT32_C(0x00000200);     /** @brief Tx-End of message interrupt enable the TXENDIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXUDRIE_MASK = UINT32_C(0x00000400);     /** @brief Tx-Underrun interrupt enable the TXUDRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXERRIE_MASK = UINT32_C(0x00000800);     /** @brief Tx-Error interrupt enable the TXERRIE bit is set and cleared by software. */
    static const uint32_t CEC_IER_TXACKIE_MASK = UINT32_C(0x00001000);     /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

    /** @subsection CEC field position definitions */

    static const int32_t CEC_IER_CECEN_POS = INT32_C(0);       /** @brief CEC enable the CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission. */
    static const int32_t CEC_IER_TXSOM_POS = INT32_C(1);       /** @brief Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR headers first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception */
    static const int32_t CEC_IER_TXEOM_POS = INT32_C(2);       /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message) */
    static const int32_t CEC_IER_SFT_POS = INT32_C(0);         /** @brief Signal free time SFT bits are set by software. In the sft=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 data-bit periods if CEC is the new bus initiator ** 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods */
    static const int32_t CEC_IER_RXTOL_POS = INT32_C(3);       /** @brief Rx-Tolerance the RXTOL bit is set and cleared by software. ** start-bit, +/- 200 s rise, +/- 200 s fall. ** data-bit: +/- 200 s rise. +/- 350 s fall. ** start-bit: +/- 400 s rise, +/- 400 s fall ** data-bit: +/-300 s rise, +/- 500 s fall */
    static const int32_t CEC_IER_BRESTP_POS = INT32_C(4);      /** @brief Rx-Stop on bit rising error the BRESTP bit is set and cleared by software. */
    static const int32_t CEC_IER_BREGEN_POS = INT32_C(5);      /** @brief Generate error-bit on bit rising error the BREGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0 */
    static const int32_t CEC_IER_LBPEGEN_POS = INT32_C(6);     /** @brief Generate error-bit on long bit period error the LBPEGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0 */
    static const int32_t CEC_IER_BRDNOGEN_POS = INT32_C(7);    /** @brief Avoid error-bit generation in broadcast the BRDNOGEN bit is set and cleared by software. */
    static const int32_t CEC_IER_SFTOPT_POS = INT32_C(8);      /** @brief SFT option bit the SFTOPT bit is set and cleared by software. */
    static const int32_t CEC_IER_OAR_POS = INT32_C(16);        /** @brief Own addresses configuration the OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. */
    static const int32_t CEC_IER_LSTN_POS = INT32_C(31);       /** @brief Listen mode LSTN bit is set and cleared by software. */
    static const int32_t CEC_IER_TXD_POS = INT32_C(0);         /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 */
    static const int32_t CEC_IER_RXD_POS = INT32_C(0);         /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
    static const int32_t CEC_IER_RXBR_POS = INT32_C(0);        /** @brief Rx-Byte received the RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1. */
    static const int32_t CEC_IER_RXEND_POS = INT32_C(1);       /** @brief End of reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1. */
    static const int32_t CEC_IER_RXOVR_POS = INT32_C(2);       /** @brief Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1. */
    static const int32_t CEC_IER_BRE_POS = INT32_C(3);         /** @brief Rx-Bit rising error BRE is set by hardware in case a data-bit waveform is detected with bit rising error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an error-bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1. */
    static const int32_t CEC_IER_SBPE_POS = INT32_C(4);        /** @brief Rx-Short bit period error SBPE is set by hardware in case a data-bit waveform is detected with short bit period error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an error-bit on the CEC line. SBPE is cleared by software write at 1. */
    static const int32_t CEC_IER_LBPE_POS = INT32_C(5);        /** @brief Rx-Long bit period error LBPE is set by hardware in case a data-bit waveform is detected with long bit period error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an error-bit on the CEC line if LBPEGEN=1. In case of broadcast, error-bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1. */
    static const int32_t CEC_IER_RXACKE_POS = INT32_C(6);      /** @brief Rx-Missing acknowledge in receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1. */
    static const int32_t CEC_IER_ARBLST_POS = INT32_C(7);      /** @brief Arbitration lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1. */
    static const int32_t CEC_IER_TXBR_POS = INT32_C(8);        /** @brief Tx-Byte request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1. */
    static const int32_t CEC_IER_TXEND_POS = INT32_C(9);       /** @brief End of transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1. */
    static const int32_t CEC_IER_TXUDR_POS = INT32_C(10);      /** @brief Tx-Buffer underrun in transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1 */
    static const int32_t CEC_IER_TXERR_POS = INT32_C(11);      /** @brief Tx-Error in transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1. */
    static const int32_t CEC_IER_TXACKE_POS = INT32_C(12);     /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
    static const int32_t CEC_IER_RXBRIE_POS = INT32_C(0);      /** @brief Rx-Byte received interrupt enable the RXBRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_RXENDIE_POS = INT32_C(1);     /** @brief End of reception interrupt enable the RXENDIE bit is set and cleared by software. */
    static const int32_t CEC_IER_RXOVRIE_POS = INT32_C(2);     /** @brief Rx-Buffer overrun interrupt enable the RXOVRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_BREIE_POS = INT32_C(3);       /** @brief Bit rising error interrupt enable the BREIE bit is set and cleared by software. */
    static const int32_t CEC_IER_SBPEIE_POS = INT32_C(4);      /** @brief Short bit period error interrupt enable the SBPEIE bit is set and cleared by software. */
    static const int32_t CEC_IER_LBPEIE_POS = INT32_C(5);      /** @brief Long bit period error interrupt enable the LBPEIE bit is set and cleared by software. */
    static const int32_t CEC_IER_RXACKIE_POS = INT32_C(6);     /** @brief Rx-Missing acknowledge error interrupt enable the RXACKIE bit is set and cleared by software. */
    static const int32_t CEC_IER_ARBLSTIE_POS = INT32_C(7);    /** @brief Arbitration lost interrupt enable the ARBLSTIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXBRIE_POS = INT32_C(8);      /** @brief Tx-Byte request interrupt enable the TXBRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXENDIE_POS = INT32_C(9);     /** @brief Tx-End of message interrupt enable the TXENDIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXUDRIE_POS = INT32_C(10);    /** @brief Tx-Underrun interrupt enable the TXUDRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXERRIE_POS = INT32_C(11);    /** @brief Tx-Error interrupt enable the TXERRIE bit is set and cleared by software. */
    static const int32_t CEC_IER_TXACKIE_POS = INT32_C(12);    /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

    /**********************************************************************************************
     * @section HSEM Definitions
     **********************************************************************************************/

    /** @subsection HSEM IRQ interrupt definitions */

    static const int32_t HSEM0_IRQ = INT32_C(125);   /** @brief HSEM global interrupt 1 */

    /** @subsection HSEM register array definitions */

    static _RW uint32_t* const HSEM_RX_REG[32] = {
      (_RW uint32_t* const)UINT32_C(0x58026400),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026404),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026408),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802640C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026410),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026414),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026418),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802641C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026420),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026424),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026428),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802642C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026430),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026434),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026438),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802643C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026440),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026444),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026448),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802644C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026450),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026454),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026458),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802645C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026460),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026464),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026468),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802646C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026470),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026474),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x58026478),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      (_RW uint32_t* const)UINT32_C(0x5802647C),   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    };

    static _RO uint32_t* const HSEM_RLRX_REG[32] = {
      (_RO uint32_t* const)UINT32_C(0x58026480),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x58026484),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x58026488),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x5802648C),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x58026490),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x58026494),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x58026498),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x5802649C),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264A0),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264A4),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264A8),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264AC),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264B0),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264B4),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264B8),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264BC),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264C0),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264C4),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264C8),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264CC),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264D0),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264D4),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264D8),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264DC),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264E0),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264E4),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264E8),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264EC),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264F0),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264F4),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264F8),   /** @brief HSEM read lock register */
      (_RO uint32_t* const)UINT32_C(0x580264FC),   /** @brief HSEM read lock register */
    };

    /** @subsection HSEM register definitions */

    static _RW uint32_t* const HSEM_IER_REG = (_RW uint32_t* const)UINT32_C(0x58026500);/** @brief HSEM interrupt enable register */
    static _RO uint32_t* const HSEM_ICR_REG = (_RO uint32_t* const)UINT32_C(0x58026504);/** @brief HSEM interrupt clear register */
    static _RO uint32_t* const HSEM_ISR_REG = (_RO uint32_t* const)UINT32_C(0x58026508);/** @brief HSEM interrupt status register */
    static _RO uint32_t* const HSEM_MISR_REG = (_RO uint32_t* const)UINT32_C(0x5802650C);/** @brief HSEM masked interrupt status register */
    static _RW uint32_t* const HSEM_CR_REG = (_RW uint32_t* const)UINT32_C(0x58026540);/** @brief HSEM clear register */
    static _RW uint32_t* const HSEM_KEYR_REG = (_RW uint32_t* const)UINT32_C(0x58026544);/** @brief HSEM interrupt clear register */

    /** @subsection HSEM field mask array definitions */

    static const uint32_t HSEM_IER_ISEMX_MASK[32] = {
      UINT32_C(0x00000001),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000002),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000004),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000008),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000010),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000020),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000040),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000080),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000100),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000200),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000400),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00000800),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00001000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00002000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00004000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00008000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00010000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00020000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00040000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00080000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00100000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00200000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00400000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x00800000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x01000000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x02000000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x04000000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x08000000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x10000000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x20000000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x40000000),   /** @brief Interrupt semaphore n enable bit */
      UINT32_C(0x80000000),   /** @brief Interrupt(N) semaphore n enable bit. */
    };

    /** @subsection HSEM field mask definitions */

    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RX_PROCID_MASK = UINT32_C(0x000000FF);       /** @brief Semaphore processid */
    static const uint32_t HSEM_RX_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief Semaphore masterid */
    static const uint32_t HSEM_RX_LOCK_MASK = UINT32_C(0x80000000);         /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_RLRX_PROCID_MASK = UINT32_C(0x000000FF);     /** @brief Semaphore processid */
    static const uint32_t HSEM_RLRX_MASTERID_MASK = UINT32_C(0x0000FF00);   /** @brief Semaphore masterid */
    static const uint32_t HSEM_RLRX_LOCK_MASK = UINT32_C(0x80000000);       /** @brief Lock indication */
    static const uint32_t HSEM_CR_MASTERID_MASK = UINT32_C(0x0000FF00);     /** @brief MasterID of semaphores to be cleared */
    static const uint32_t HSEM_CR_KEY_MASK = UINT32_C(0xFFFF0000);          /** @brief Semaphore clear key */
    static const uint32_t HSEM_KEYR_KEY_MASK = UINT32_C(0xFFFF0000);        /** @brief Semaphore clear key */

    /** @subsection HSEM field position array definitions */

    static const int32_t HSEM_KEYR_ISEMX_POS[32] = {
      INT32_C(0),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(1),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(2),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(3),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(4),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(5),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(6),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(7),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(8),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(9),    /** @brief Interrupt semaphore n enable bit */
      INT32_C(10),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(11),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(12),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(13),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(14),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(15),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(16),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(17),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(18),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(19),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(20),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(21),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(22),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(23),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(24),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(25),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(26),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(27),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(28),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(29),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(30),   /** @brief Interrupt semaphore n enable bit */
      INT32_C(31),   /** @brief Interrupt(N) semaphore n enable bit. */
    };

    /** @subsection HSEM field position definitions */

    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_PROCID_POS = INT32_C(0);      /** @brief Semaphore processid */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief Semaphore masterid */
    static const int32_t HSEM_KEYR_LOCK_POS = INT32_C(31);       /** @brief Lock indication */
    static const int32_t HSEM_KEYR_MASTERID_POS = INT32_C(8);    /** @brief MasterID of semaphores to be cleared */
    static const int32_t HSEM_KEYR_KEY_POS = INT32_C(16);        /** @brief Semaphore clear key */
    static const int32_t HSEM_KEYR_KEY_POS = INT32_C(16);        /** @brief Semaphore clear key */

    /**********************************************************************************************
     * @section I2CX Definitions
     **********************************************************************************************/

    /** @subsection I2CX IRQ interrupt array definitions */

    static const int32_t I2CX_EV_IRQ[5] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(31),    /** @brief I2C1 event interrupt */
      INT32_C(33),    /** @brief I2C2 event interrupt */
      INT32_C(72),    /** @brief I2C3 event interrupt */
      INT32_C(95),    /** @brief I2C4 event interrupt */
    };

    static const int32_t I2CX_ER_IRQ[5] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(32),    /** @brief I2C1 error interrupt */
      INT32_C(34),    /** @brief I2C2 error interrupt */
      INT32_C(73),    /** @brief I2C3 error interrupt */
      INT32_C(96),    /** @brief I2C4 error interrupt */
    };

    /** @subsection I2CX register array definitions */

    static _RW uint32_t* const I2CX_CR1_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40005400),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005800),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005C00),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x58001C00),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static _RW uint32_t* const I2CX_CR2_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40005404),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005804),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005C04),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x58001C04),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static _RW uint32_t* const I2CX_OAR1_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40005408),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005808),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005C08),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x58001C08),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static _RW uint32_t* const I2CX_OAR2_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000540C),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x4000580C),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005C0C),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x58001C0C),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static _RW uint32_t* const I2CX_TIMINGR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40005410),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x40005810),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x40005C10),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x58001C10),   /** @brief Access: no wait states */
    };

    static _RW uint32_t* const I2CX_TIMEOUTR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40005414),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005814),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x40005C14),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      (_RW uint32_t* const)UINT32_C(0x58001C14),   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static _RW uint32_t* const I2CX_ISR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40005418),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x40005818),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x40005C18),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x58001C18),   /** @brief Access: no wait states */
    };

    static _RW uint32_t* const I2CX_ICR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000541C),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x4000581C),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x40005C1C),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x58001C1C),   /** @brief Access: no wait states */
    };

    static _RO uint32_t* const I2CX_PECR_REG[5] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40005420),   /** @brief Access: no wait states */
      (_RO uint32_t* const)UINT32_C(0x40005820),   /** @brief Access: no wait states */
      (_RO uint32_t* const)UINT32_C(0x40005C20),   /** @brief Access: no wait states */
      (_RO uint32_t* const)UINT32_C(0x58001C20),   /** @brief Access: no wait states */
    };

    static _RO uint32_t* const I2CX_RXDR_REG[5] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40005424),   /** @brief Access: no wait states */
      (_RO uint32_t* const)UINT32_C(0x40005824),   /** @brief Access: no wait states */
      (_RO uint32_t* const)UINT32_C(0x40005C24),   /** @brief Access: no wait states */
      (_RO uint32_t* const)UINT32_C(0x58001C24),   /** @brief Access: no wait states */
    };

    static _RW uint32_t* const I2CX_TXDR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40005428),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x40005828),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x40005C28),   /** @brief Access: no wait states */
      (_RW uint32_t* const)UINT32_C(0x58001C28),   /** @brief Access: no wait states */
    };

    /** @subsection I2CX field mask array definitions */

    static const uint32_t I2CX_CR2_SADDX_MASK[10] = {
      UINT32_C(0x00000001),   /** @brief Slave address bit 0 (master mode) in 7-bit addressing mode (ADD10 = 0): this bit is dont care in 10-bit addressing mode (ADD10 = 1): this bit should be written with bit 0 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000002),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000004),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000008),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000010),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000020),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000040),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000080),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000100),   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      UINT32_C(0x00000200),   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
    };

    /** @subsection I2CX field mask definitions */

    static const uint32_t I2CX_CR1_PE_MASK = UINT32_C(0x00000001);              /** @brief Peripheral enable note: when PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles. */
    static const uint32_t I2CX_CR1_TXIE_MASK = UINT32_C(0x00000002);            /** @brief TX interrupt enable */
    static const uint32_t I2CX_CR1_RXIE_MASK = UINT32_C(0x00000004);            /** @brief RX interrupt enable */
    static const uint32_t I2CX_CR1_ADDRIE_MASK = UINT32_C(0x00000008);          /** @brief Address match interrupt enable (slave only) */
    static const uint32_t I2CX_CR1_NACKIE_MASK = UINT32_C(0x00000010);          /** @brief Not acknowledge received interrupt enable */
    static const uint32_t I2CX_CR1_STOPIE_MASK = UINT32_C(0x00000020);          /** @brief STOP detection interrupt enable */
    static const uint32_t I2CX_CR1_TCIE_MASK = UINT32_C(0x00000040);            /** @brief Transfer complete interrupt enable note: any of these events will generate an interrupt: transfer complete (TC) transfer complete reload (TCR) */
    static const uint32_t I2CX_CR1_ERRIE_MASK = UINT32_C(0x00000080);           /** @brief Error interrupts enable note: any of these errors generate an interrupt: arbitration loss (ARLO) bus error detection (BERR) overrun/underrun (OVR) timeout detection (TIMEOUT) PEC error detection (PECERR) alert pin event detection (ALERT) */
    static const uint32_t I2CX_CR1_DNF_MASK = UINT32_C(0x00000F00);             /** @brief Digital noise filter these bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * ti2cclk ... Note: if the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). */
    static const uint32_t I2CX_CR1_ANFOFF_MASK = UINT32_C(0x00001000);          /** @brief Analog noise filter OFF note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const uint32_t I2CX_CR1_TXDMAEN_MASK = UINT32_C(0x00004000);         /** @brief DMA transmission requests enable */
    static const uint32_t I2CX_CR1_RXDMAEN_MASK = UINT32_C(0x00008000);         /** @brief DMA reception requests enable */
    static const uint32_t I2CX_CR1_SBC_MASK = UINT32_C(0x00010000);             /** @brief Slave byte control this bit is used to enable hardware byte control in slave mode. */
    static const uint32_t I2CX_CR1_NOSTRETCH_MASK = UINT32_C(0x00020000);       /** @brief Clock stretching disable this bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const uint32_t I2CX_CR1_WUPEN_MASK = UINT32_C(0x00040000);           /** @brief Wakeup from stop mode enable note: if the wakeup from stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000 */
    static const uint32_t I2CX_CR1_GCEN_MASK = UINT32_C(0x00080000);            /** @brief General call enable */
    static const uint32_t I2CX_CR1_SMBHEN_MASK = UINT32_C(0x00100000);          /** @brief SMBus host address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_CR1_SMBDEN_MASK = UINT32_C(0x00200000);          /** @brief SMBus device default address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_CR1_ALERTEN_MASK = UINT32_C(0x00400000);         /** @brief SMBus alert enable device mode (SMBHEN=0): host mode (SMBHEN=1): note: when ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_CR1_PECEN_MASK = UINT32_C(0x00800000);           /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_CR2_RD_WRN_MASK = UINT32_C(0x00000400);          /** @brief Transfer direction (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const uint32_t I2CX_CR2_ADD10_MASK = UINT32_C(0x00000800);           /** @brief 10-bit addressing mode (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const uint32_t I2CX_CR2_HEAD10R_MASK = UINT32_C(0x00001000);         /** @brief 10-bit address header only read direction (master receiver mode) note: changing this bit when the START bit is set is not allowed. */
    static const uint32_t I2CX_CR2_START_MASK = UINT32_C(0x00002000);           /** @brief Start generation this bit is set by software, and cleared by hardware after the start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a repeated start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set. */
    static const uint32_t I2CX_CR2_STOP_MASK = UINT32_C(0x00004000);            /** @brief Stop generation (master mode) the bit is set by software, cleared by hardware when a stop condition is detected, or when PE = 0. In master mode: note: writing 0 to this bit has no effect. */
    static const uint32_t I2CX_CR2_NACK_MASK = UINT32_C(0x00008000);            /** @brief NACK generation (slave mode) the bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an address matched is received, or when PE=0. Note: writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value. */
    static const uint32_t I2CX_CR2_NBYTES_MASK = UINT32_C(0x00FF0000);          /** @brief Number of bytes the number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: changing these bits when the START bit is set is not allowed. */
    static const uint32_t I2CX_CR2_RELOAD_MASK = UINT32_C(0x01000000);          /** @brief NBYTES reload mode this bit is set and cleared by software. */
    static const uint32_t I2CX_CR2_AUTOEND_MASK = UINT32_C(0x02000000);         /** @brief Automatic end mode (master mode) this bit is set and cleared by software. Note: this bit has no effect in slave mode or when the RELOAD bit is set. */
    static const uint32_t I2CX_CR2_PECBYTE_MASK = UINT32_C(0x04000000);         /** @brief Packet error checking byte this bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an address matched is received, also when PE=0. Note: writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_OAR1_OA1_MASK = UINT32_C(0x000003FF);            /** @brief Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address note: these bits can be written only when OA1EN=0. OA1[7:1]: interface address bits 7:1 of address note: these bits can be written only when OA1EN=0. OA1[0]: interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address note: this bit can be written only when OA1EN=0. */
    static const uint32_t I2CX_OAR1_OA1MODE_MASK = UINT32_C(0x00000400);        /** @brief Own address 1 10-bit mode note: this bit can be written only when OA1EN=0. */
    static const uint32_t I2CX_OAR1_OA1EN_MASK = UINT32_C(0x00008000);          /** @brief Own address 1 enable */
    static const uint32_t I2CX_OAR2_OA2_MASK = UINT32_C(0x000000FE);            /** @brief Interface address bits 7:1 of address note: these bits can be written only when OA2EN=0. */
    static const uint32_t I2CX_OAR2_OA2MSK_MASK = UINT32_C(0x00000700);         /** @brief Own address 2 masks note: these bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. */
    static const uint32_t I2CX_OAR2_OA2EN_MASK = UINT32_C(0x00008000);          /** @brief Own address 2 enable */
    static const uint32_t I2CX_TIMINGR_SCLL_MASK = UINT32_C(0x000000FF);        /** @brief SCL low period (master mode) this field is used to generate the SCL low period in master mode. TSCLL = (SCLL+1) x tpresc note: SCLL is also used to generate tbuf and tsu:sta timings. */
    static const uint32_t I2CX_TIMINGR_SCLH_MASK = UINT32_C(0x0000FF00);        /** @brief SCL high period (master mode) this field is used to generate the SCL high period in master mode. TSCLH = (SCLH+1) x tpresc note: SCLH is also used to generate tsu:sto and thd:sta timing. */
    static const uint32_t I2CX_TIMINGR_SDADEL_MASK = UINT32_C(0x000F0000);      /** @brief Data hold time this field is used to generate the delay tsdadel between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsdadel. TSDADEL= SDADEL x tpresc note: SDADEL is used to generate thd:dat timing. */
    static const uint32_t I2CX_TIMINGR_SCLDEL_MASK = UINT32_C(0x00F00000);      /** @brief Data setup time this field is used to generate a delay tscldel between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tscldel. TSCLDEL = (SCLDEL+1) x tpresc note: tscldel is used to generate tsu:dat timing. */
    static const uint32_t I2CX_TIMINGR_PRESC_MASK = UINT32_C(0xF0000000);       /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
    static const uint32_t I2CX_TIMEOUTR_TIMEOUTA_MASK = UINT32_C(0x00000FFF);   /** @brief Bus timeout A this field is used to configure: the SCL low timeout condition ttimeout when TIDLE=0 ttimeout= (TIMEOUTA+1) x 2048 x ti2cclk the bus idle condition (both SCL and SDA high) when TIDLE=1 tidle= (TIMEOUTA+1) x 4 x ti2cclk note: these bits can be written only when TIMOUTEN=0. */
    static const uint32_t I2CX_TIMEOUTR_TIDLE_MASK = UINT32_C(0x00001000);      /** @brief Idle clock timeout detection note: this bit can be written only when TIMOUTEN=0. */
    static const uint32_t I2CX_TIMEOUTR_TIMOUTEN_MASK = UINT32_C(0x00008000);   /** @brief Clock timeout enable */
    static const uint32_t I2CX_TIMEOUTR_TIMEOUTB_MASK = UINT32_C(0x0FFF0000);   /** @brief Bus timeout B this field is used to configure the cumulative clock extension timeout: in master mode, the master cumulative clock low extend time (tlow:mext) is detected in slave mode, the slave cumulative clock low extend time (tlow:sext) is detected tlow:ext= (TIMEOUTB+1) x 2048 x ti2cclk note: these bits can be written only when TEXTEN=0. */
    static const uint32_t I2CX_TIMEOUTR_TEXTEN_MASK = UINT32_C(0x80000000);     /** @brief Extended clock timeout enable */
    static const uint32_t I2CX_ISR_TXE_MASK = UINT32_C(0x00000001);             /** @brief Transmit data register empty (transmitters) this bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: this bit is set by hardware when PE=0. */
    static const uint32_t I2CX_ISR_TXIS_MASK = UINT32_C(0x00000002);            /** @brief Transmit interrupt status (transmitters) this bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_RXNE_MASK = UINT32_C(0x00000004);            /** @brief Receive data register not empty (receivers) this bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_ADDR_MASK = UINT32_C(0x00000008);            /** @brief Address matched (slave mode) this bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_NACKF_MASK = UINT32_C(0x00000010);           /** @brief Not acknowledge received flag this flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_STOPF_MASK = UINT32_C(0x00000020);           /** @brief Stop detection flag this flag is set by hardware when a stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. Or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_TC_MASK = UINT32_C(0x00000040);              /** @brief Transfer complete (master mode) this flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_TCR_MASK = UINT32_C(0x00000080);             /** @brief Transfer complete reload this flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: this bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set. */
    static const uint32_t I2CX_ISR_BERR_MASK = UINT32_C(0x00000100);            /** @brief Bus error this flag is set by hardware when a misplaced start or stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_ARLO_MASK = UINT32_C(0x00000200);            /** @brief Arbitration lost this flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_OVR_MASK = UINT32_C(0x00000400);             /** @brief Overrun/Underrun (slave mode) this flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const uint32_t I2CX_ISR_PECERR_MASK = UINT32_C(0x00000800);          /** @brief PEC error in reception this flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_ISR_TIMEOUT_MASK = UINT32_C(0x00001000);         /** @brief Timeout or tlow detection flag this flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_ISR_ALERT_MASK = UINT32_C(0x00002000);           /** @brief SMBus alert this flag is set by hardware when SMBHEN=1 (smbus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_ISR_BUSY_MASK = UINT32_C(0x00008000);            /** @brief Bus busy this flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a stop condition is detected, or when PE=0. */
    static const uint32_t I2CX_ISR_DIR_MASK = UINT32_C(0x00010000);             /** @brief Transfer direction (slave mode) this flag is updated when an address match event occurs (ADDR=1). */
    static const uint32_t I2CX_ISR_ADDCODE_MASK = UINT32_C(0x00FE0000);         /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
    static const uint32_t I2CX_ICR_ADDRCF_MASK = UINT32_C(0x00000008);          /** @brief Address matched flag clear writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register. */
    static const uint32_t I2CX_ICR_NACKCF_MASK = UINT32_C(0x00000010);          /** @brief Not acknowledge flag clear writing 1 to this bit clears the ACKF flag in I2C_ISR register. */
    static const uint32_t I2CX_ICR_STOPCF_MASK = UINT32_C(0x00000020);          /** @brief Stop detection flag clear writing 1 to this bit clears the STOPF flag in the I2C_ISR register. */
    static const uint32_t I2CX_ICR_BERRCF_MASK = UINT32_C(0x00000100);          /** @brief Bus error flag clear writing 1 to this bit clears the BERRF flag in the I2C_ISR register. */
    static const uint32_t I2CX_ICR_ARLOCF_MASK = UINT32_C(0x00000200);          /** @brief Arbitration lost flag clear writing 1 to this bit clears the ARLO flag in the I2C_ISR register. */
    static const uint32_t I2CX_ICR_OVRCF_MASK = UINT32_C(0x00000400);           /** @brief Overrun/Underrun flag clear writing 1 to this bit clears the OVR flag in the I2C_ISR register. */
    static const uint32_t I2CX_ICR_PECCF_MASK = UINT32_C(0x00000800);           /** @brief PEC error flag clear writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_ICR_TIMOUTCF_MASK = UINT32_C(0x00001000);        /** @brief Timeout detection flag clear writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_ICR_ALERTCF_MASK = UINT32_C(0x00002000);         /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const uint32_t I2CX_PECR_PEC_MASK = UINT32_C(0x000000FF);            /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
    static const uint32_t I2CX_RXDR_RXDATA_MASK = UINT32_C(0x000000FF);         /** @brief 8-bit receive data data byte received from the I2C bus. */
    static const uint32_t I2CX_TXDR_TXDATA_MASK = UINT32_C(0x000000FF);         /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */

    /** @subsection I2CX field position array definitions */

    static const int32_t I2CX_TXDR_SADDX_POS[10] = {
      INT32_C(0),   /** @brief Slave address bit 0 (master mode) in 7-bit addressing mode (ADD10 = 0): this bit is dont care in 10-bit addressing mode (ADD10 = 1): this bit should be written with bit 0 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      INT32_C(1),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      INT32_C(2),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      INT32_C(3),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      INT32_C(4),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      INT32_C(5),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      INT32_C(6),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      INT32_C(7),   /** @brief Slave address bit 7:1 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits should be written with the 7-bit slave address to be sent in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 7:1 of the slave address to be sent. Note: changing these bits when the START bit is set is not allowed. */
      INT32_C(8),   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
      INT32_C(9),   /** @brief Slave address bit 9:8 (master mode) in 7-bit addressing mode (ADD10 = 0): these bits are dont care in 10-bit addressing mode (ADD10 = 1): these bits should be written with bits 9:8 of the slave address to be sent note: changing these bits when the START bit is set is not allowed. */
    };

    /** @subsection I2CX field position definitions */

    static const int32_t I2CX_TXDR_PE_POS = INT32_C(0);           /** @brief Peripheral enable note: when PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles. */
    static const int32_t I2CX_TXDR_TXIE_POS = INT32_C(1);         /** @brief TX interrupt enable */
    static const int32_t I2CX_TXDR_RXIE_POS = INT32_C(2);         /** @brief RX interrupt enable */
    static const int32_t I2CX_TXDR_ADDRIE_POS = INT32_C(3);       /** @brief Address match interrupt enable (slave only) */
    static const int32_t I2CX_TXDR_NACKIE_POS = INT32_C(4);       /** @brief Not acknowledge received interrupt enable */
    static const int32_t I2CX_TXDR_STOPIE_POS = INT32_C(5);       /** @brief STOP detection interrupt enable */
    static const int32_t I2CX_TXDR_TCIE_POS = INT32_C(6);         /** @brief Transfer complete interrupt enable note: any of these events will generate an interrupt: transfer complete (TC) transfer complete reload (TCR) */
    static const int32_t I2CX_TXDR_ERRIE_POS = INT32_C(7);        /** @brief Error interrupts enable note: any of these errors generate an interrupt: arbitration loss (ARLO) bus error detection (BERR) overrun/underrun (OVR) timeout detection (TIMEOUT) PEC error detection (PECERR) alert pin event detection (ALERT) */
    static const int32_t I2CX_TXDR_DNF_POS = INT32_C(8);          /** @brief Digital noise filter these bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * ti2cclk ... Note: if the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). */
    static const int32_t I2CX_TXDR_ANFOFF_POS = INT32_C(12);      /** @brief Analog noise filter OFF note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const int32_t I2CX_TXDR_TXDMAEN_POS = INT32_C(14);     /** @brief DMA transmission requests enable */
    static const int32_t I2CX_TXDR_RXDMAEN_POS = INT32_C(15);     /** @brief DMA reception requests enable */
    static const int32_t I2CX_TXDR_SBC_POS = INT32_C(16);         /** @brief Slave byte control this bit is used to enable hardware byte control in slave mode. */
    static const int32_t I2CX_TXDR_NOSTRETCH_POS = INT32_C(17);   /** @brief Clock stretching disable this bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: this bit can only be programmed when the I2C is disabled (PE = 0). */
    static const int32_t I2CX_TXDR_WUPEN_POS = INT32_C(18);       /** @brief Wakeup from stop mode enable note: if the wakeup from stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000 */
    static const int32_t I2CX_TXDR_GCEN_POS = INT32_C(19);        /** @brief General call enable */
    static const int32_t I2CX_TXDR_SMBHEN_POS = INT32_C(20);      /** @brief SMBus host address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_SMBDEN_POS = INT32_C(21);      /** @brief SMBus device default address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_ALERTEN_POS = INT32_C(22);     /** @brief SMBus alert enable device mode (SMBHEN=0): host mode (SMBHEN=1): note: when ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_PECEN_POS = INT32_C(23);       /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_RD_WRN_POS = INT32_C(10);      /** @brief Transfer direction (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const int32_t I2CX_TXDR_ADD10_POS = INT32_C(11);       /** @brief 10-bit addressing mode (master mode) note: changing this bit when the START bit is set is not allowed. */
    static const int32_t I2CX_TXDR_HEAD10R_POS = INT32_C(12);     /** @brief 10-bit address header only read direction (master receiver mode) note: changing this bit when the START bit is set is not allowed. */
    static const int32_t I2CX_TXDR_START_POS = INT32_C(13);       /** @brief Start generation this bit is set by software, and cleared by hardware after the start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a repeated start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set. */
    static const int32_t I2CX_TXDR_STOP_POS = INT32_C(14);        /** @brief Stop generation (master mode) the bit is set by software, cleared by hardware when a stop condition is detected, or when PE = 0. In master mode: note: writing 0 to this bit has no effect. */
    static const int32_t I2CX_TXDR_NACK_POS = INT32_C(15);        /** @brief NACK generation (slave mode) the bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an address matched is received, or when PE=0. Note: writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value. */
    static const int32_t I2CX_TXDR_NBYTES_POS = INT32_C(16);      /** @brief Number of bytes the number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: changing these bits when the START bit is set is not allowed. */
    static const int32_t I2CX_TXDR_RELOAD_POS = INT32_C(24);      /** @brief NBYTES reload mode this bit is set and cleared by software. */
    static const int32_t I2CX_TXDR_AUTOEND_POS = INT32_C(25);     /** @brief Automatic end mode (master mode) this bit is set and cleared by software. Note: this bit has no effect in slave mode or when the RELOAD bit is set. */
    static const int32_t I2CX_TXDR_PECBYTE_POS = INT32_C(26);     /** @brief Packet error checking byte this bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an address matched is received, also when PE=0. Note: writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_OA1_POS = INT32_C(0);          /** @brief Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address note: these bits can be written only when OA1EN=0. OA1[7:1]: interface address bits 7:1 of address note: these bits can be written only when OA1EN=0. OA1[0]: interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address note: this bit can be written only when OA1EN=0. */
    static const int32_t I2CX_TXDR_OA1MODE_POS = INT32_C(10);     /** @brief Own address 1 10-bit mode note: this bit can be written only when OA1EN=0. */
    static const int32_t I2CX_TXDR_OA1EN_POS = INT32_C(15);       /** @brief Own address 1 enable */
    static const int32_t I2CX_TXDR_OA2_POS = INT32_C(1);          /** @brief Interface address bits 7:1 of address note: these bits can be written only when OA2EN=0. */
    static const int32_t I2CX_TXDR_OA2MSK_POS = INT32_C(8);       /** @brief Own address 2 masks note: these bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches. */
    static const int32_t I2CX_TXDR_OA2EN_POS = INT32_C(15);       /** @brief Own address 2 enable */
    static const int32_t I2CX_TXDR_SCLL_POS = INT32_C(0);         /** @brief SCL low period (master mode) this field is used to generate the SCL low period in master mode. TSCLL = (SCLL+1) x tpresc note: SCLL is also used to generate tbuf and tsu:sta timings. */
    static const int32_t I2CX_TXDR_SCLH_POS = INT32_C(8);         /** @brief SCL high period (master mode) this field is used to generate the SCL high period in master mode. TSCLH = (SCLH+1) x tpresc note: SCLH is also used to generate tsu:sto and thd:sta timing. */
    static const int32_t I2CX_TXDR_SDADEL_POS = INT32_C(16);      /** @brief Data hold time this field is used to generate the delay tsdadel between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsdadel. TSDADEL= SDADEL x tpresc note: SDADEL is used to generate thd:dat timing. */
    static const int32_t I2CX_TXDR_SCLDEL_POS = INT32_C(20);      /** @brief Data setup time this field is used to generate a delay tscldel between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tscldel. TSCLDEL = (SCLDEL+1) x tpresc note: tscldel is used to generate tsu:dat timing. */
    static const int32_t I2CX_TXDR_PRESC_POS = INT32_C(28);       /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
    static const int32_t I2CX_TXDR_TIMEOUTA_POS = INT32_C(0);     /** @brief Bus timeout A this field is used to configure: the SCL low timeout condition ttimeout when TIDLE=0 ttimeout= (TIMEOUTA+1) x 2048 x ti2cclk the bus idle condition (both SCL and SDA high) when TIDLE=1 tidle= (TIMEOUTA+1) x 4 x ti2cclk note: these bits can be written only when TIMOUTEN=0. */
    static const int32_t I2CX_TXDR_TIDLE_POS = INT32_C(12);       /** @brief Idle clock timeout detection note: this bit can be written only when TIMOUTEN=0. */
    static const int32_t I2CX_TXDR_TIMOUTEN_POS = INT32_C(15);    /** @brief Clock timeout enable */
    static const int32_t I2CX_TXDR_TIMEOUTB_POS = INT32_C(16);    /** @brief Bus timeout B this field is used to configure the cumulative clock extension timeout: in master mode, the master cumulative clock low extend time (tlow:mext) is detected in slave mode, the slave cumulative clock low extend time (tlow:sext) is detected tlow:ext= (TIMEOUTB+1) x 2048 x ti2cclk note: these bits can be written only when TEXTEN=0. */
    static const int32_t I2CX_TXDR_TEXTEN_POS = INT32_C(31);      /** @brief Extended clock timeout enable */
    static const int32_t I2CX_TXDR_TXE_POS = INT32_C(0);          /** @brief Transmit data register empty (transmitters) this bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: this bit is set by hardware when PE=0. */
    static const int32_t I2CX_TXDR_TXIS_POS = INT32_C(1);         /** @brief Transmit interrupt status (transmitters) this bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_RXNE_POS = INT32_C(2);         /** @brief Receive data register not empty (receivers) this bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_ADDR_POS = INT32_C(3);         /** @brief Address matched (slave mode) this bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_NACKF_POS = INT32_C(4);        /** @brief Not acknowledge received flag this flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_STOPF_POS = INT32_C(5);        /** @brief Stop detection flag this flag is set by hardware when a stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. Or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_TC_POS = INT32_C(6);           /** @brief Transfer complete (master mode) this flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_TCR_POS = INT32_C(7);          /** @brief Transfer complete reload this flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: this bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set. */
    static const int32_t I2CX_TXDR_BERR_POS = INT32_C(8);         /** @brief Bus error this flag is set by hardware when a misplaced start or stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_ARLO_POS = INT32_C(9);         /** @brief Arbitration lost this flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_OVR_POS = INT32_C(10);         /** @brief Overrun/Underrun (slave mode) this flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: this bit is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_PECERR_POS = INT32_C(11);      /** @brief PEC error in reception this flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_TIMEOUT_POS = INT32_C(12);     /** @brief Timeout or tlow detection flag this flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_ALERT_POS = INT32_C(13);       /** @brief SMBus alert this flag is set by hardware when SMBHEN=1 (smbus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_BUSY_POS = INT32_C(15);        /** @brief Bus busy this flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a stop condition is detected, or when PE=0. */
    static const int32_t I2CX_TXDR_DIR_POS = INT32_C(16);         /** @brief Transfer direction (slave mode) this flag is updated when an address match event occurs (ADDR=1). */
    static const int32_t I2CX_TXDR_ADDCODE_POS = INT32_C(17);     /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
    static const int32_t I2CX_TXDR_ADDRCF_POS = INT32_C(3);       /** @brief Address matched flag clear writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register. */
    static const int32_t I2CX_TXDR_NACKCF_POS = INT32_C(4);       /** @brief Not acknowledge flag clear writing 1 to this bit clears the ACKF flag in I2C_ISR register. */
    static const int32_t I2CX_TXDR_STOPCF_POS = INT32_C(5);       /** @brief Stop detection flag clear writing 1 to this bit clears the STOPF flag in the I2C_ISR register. */
    static const int32_t I2CX_TXDR_BERRCF_POS = INT32_C(8);       /** @brief Bus error flag clear writing 1 to this bit clears the BERRF flag in the I2C_ISR register. */
    static const int32_t I2CX_TXDR_ARLOCF_POS = INT32_C(9);       /** @brief Arbitration lost flag clear writing 1 to this bit clears the ARLO flag in the I2C_ISR register. */
    static const int32_t I2CX_TXDR_OVRCF_POS = INT32_C(10);       /** @brief Overrun/Underrun flag clear writing 1 to this bit clears the OVR flag in the I2C_ISR register. */
    static const int32_t I2CX_TXDR_PECCF_POS = INT32_C(11);       /** @brief PEC error flag clear writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_TIMOUTCF_POS = INT32_C(12);    /** @brief Timeout detection flag clear writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_ALERTCF_POS = INT32_C(13);     /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    static const int32_t I2CX_TXDR_PEC_POS = INT32_C(0);          /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
    static const int32_t I2CX_TXDR_RXDATA_POS = INT32_C(0);       /** @brief 8-bit receive data data byte received from the I2C bus. */
    static const int32_t I2CX_TXDR_TXDATA_POS = INT32_C(0);       /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */

    /**********************************************************************************************
     * @section GPIOX Definitions
     **********************************************************************************************/

    /** @subsection GPIOX register array definitions */

    static _RW uint32_t* const GPIOX_MODER_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x58020000),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58020400),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58020800),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58020C00),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58021000),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58021400),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58021800),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58021C00),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58022000),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58022400),   /** @brief GPIO port mode register */
      (_RW uint32_t* const)UINT32_C(0x58022800),   /** @brief GPIO port mode register */
    };

    static _RW uint32_t* const GPIOX_OTYPER_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x58020004),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58020404),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58020804),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58020C04),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58021004),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58021404),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58021804),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58021C04),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58022004),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58022404),   /** @brief GPIO port output type register */
      (_RW uint32_t* const)UINT32_C(0x58022804),   /** @brief GPIO port output type register */
    };

    static _RW uint32_t* const GPIOX_OSPEEDR_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x58020008),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58020408),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58020808),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58020C08),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58021008),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58021408),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58021808),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58021C08),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58022008),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58022408),   /** @brief GPIO port output speed register */
      (_RW uint32_t* const)UINT32_C(0x58022808),   /** @brief GPIO port output speed register */
    };

    static _RW uint32_t* const GPIOX_PUPDR_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x5802000C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802040C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802080C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x58020C0C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802100C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802140C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802180C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x58021C0C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802200C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802240C),   /** @brief GPIO port pull-up/pull-down register */
      (_RW uint32_t* const)UINT32_C(0x5802280C),   /** @brief GPIO port pull-up/pull-down register */
    };

    static _RO uint32_t* const GPIOX_IDR_REG[11] = {
      (_RO uint32_t* const)UINT32_C(0x58020010),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58020410),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58020810),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58020C10),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58021010),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58021410),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58021810),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58021C10),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58022010),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58022410),   /** @brief GPIO port input data register */
      (_RO uint32_t* const)UINT32_C(0x58022810),   /** @brief GPIO port input data register */
    };

    static _RW uint32_t* const GPIOX_ODR_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x58020014),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58020414),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58020814),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58020C14),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58021014),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58021414),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58021814),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58021C14),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58022014),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58022414),   /** @brief GPIO port output data register */
      (_RW uint32_t* const)UINT32_C(0x58022814),   /** @brief GPIO port output data register */
    };

    static _RW uint32_t* const GPIOX_BSRR_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x58020018),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58020418),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58020818),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58020C18),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58021018),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58021418),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58021818),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58021C18),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58022018),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58022418),   /** @brief GPIO port bit set/reset register */
      (_RW uint32_t* const)UINT32_C(0x58022818),   /** @brief GPIO port bit set/reset register */
    };

    static _RW uint32_t* const GPIOX_LCKR_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x5802001C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802041C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802081C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x58020C1C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802101C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802141C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802181C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x58021C1C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802201C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802241C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
      (_RW uint32_t* const)UINT32_C(0x5802281C),   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    };

    static _RW uint32_t* const GPIOX_AFRL_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x58020020),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58020420),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58020820),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58020C20),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58021020),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58021420),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58021820),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58021C20),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58022020),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58022420),   /** @brief GPIO alternate function low register */
      (_RW uint32_t* const)UINT32_C(0x58022820),   /** @brief GPIO alternate function low register */
    };

    static _RW uint32_t* const GPIOX_AFRH_REG[11] = {
      (_RW uint32_t* const)UINT32_C(0x58020024),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58020424),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58020824),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58020C24),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58021024),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58021424),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58021824),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58021C24),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58022024),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58022424),   /** @brief GPIO alternate function high register */
      (_RW uint32_t* const)UINT32_C(0x58022824),   /** @brief GPIO alternate function high register */
    };

    /** @subsection GPIOX field mask array definitions */

    static const uint32_t GPIOX_MODER_MODEX_MASK[16] = {
      UINT32_C(0x00000003),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x0000000C),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x00000030),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x000000C0),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x00000300),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x00000C00),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x00003000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x0000C000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x00030000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x000C0000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x00300000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x00C00000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x03000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x0C000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0x30000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      UINT32_C(0xC0000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOX_OTYPER_OTX_MASK[16] = {
      UINT32_C(0x00000001),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000002),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000004),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000008),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000010),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000020),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000040),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000080),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000100),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000200),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000400),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00000800),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00001000),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00002000),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00004000),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      UINT32_C(0x00008000),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOX_OSPEEDR_OSPEEDX_MASK[16] = {
      UINT32_C(0x00000003),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x0000000C),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x00000030),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x000000C0),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x00000300),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x00000C00),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x00003000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x0000C000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x00030000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x000C0000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x00300000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x00C00000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x03000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x0C000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0x30000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      UINT32_C(0xC0000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOX_PUPDR_PUPDX_MASK[16] = {
      UINT32_C(0x00000003),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x0000000C),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x00000030),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x000000C0),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x00000300),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x00000C00),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x00003000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x0000C000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x00030000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x000C0000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x00300000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x00C00000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x03000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x0C000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0x30000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      UINT32_C(0xC0000000),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOX_IDR_IDX_MASK[16] = {
      UINT32_C(0x00000001),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000002),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000004),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000008),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000010),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000020),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000040),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000080),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000100),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000200),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000400),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00000800),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00001000),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00002000),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00004000),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      UINT32_C(0x00008000),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOX_ODR_ODX_MASK[16] = {
      UINT32_C(0x00000001),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000002),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000004),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000008),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000010),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000020),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000040),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000080),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000100),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000200),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000400),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00000800),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00001000),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00002000),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00004000),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      UINT32_C(0x00008000),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOX_BSRR_BSX_MASK[16] = {
      UINT32_C(0x00000001),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000002),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000004),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000008),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000010),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000020),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000040),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000080),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000100),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000200),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000400),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00000800),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00001000),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00002000),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00004000),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      UINT32_C(0x00008000),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    };

    static const uint32_t GPIOX_BSRR_BRX_MASK[16] = {
      UINT32_C(0x00010000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x00020000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x00040000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x00080000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x00100000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x00200000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x00400000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x00800000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x01000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x02000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x04000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x08000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x10000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x20000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x40000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      UINT32_C(0x80000000),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOX_LCKR_LCKX_MASK[16] = {
      UINT32_C(0x00000001),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000002),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000004),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000008),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000010),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000020),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000040),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000080),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000100),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000200),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000400),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00000800),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00001000),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00002000),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00004000),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      UINT32_C(0x00008000),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    };

    static const uint32_t GPIOX_AFRL_AFSELX_MASK[8] = {
      UINT32_C(0x0000000F),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      UINT32_C(0x000000F0),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      UINT32_C(0x00000F00),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      UINT32_C(0x0000F000),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      UINT32_C(0x000F0000),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      UINT32_C(0x00F00000),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      UINT32_C(0x0F000000),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      UINT32_C(0xF0000000),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    /** @subsection GPIOX field mask definitions */

    static const uint32_t GPIOX_LCKR_LCKK_MASK = UINT32_C(0x00010000);   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    /** @subsection GPIOX field position array definitions */

    static const int32_t GPIOX_AFRH_MODEX_POS[16] = {
      INT32_C(0),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(2),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(4),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(6),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(8),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(10),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(12),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(14),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(16),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(18),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(20),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(22),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(24),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(26),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(28),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      INT32_C(30),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const int32_t GPIOX_AFRH_OTX_POS[16] = {
      INT32_C(0),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(1),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(2),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(3),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(4),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(5),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(6),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(7),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(8),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(9),    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(10),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(11),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(12),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(13),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(14),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      INT32_C(15),   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const int32_t GPIOX_AFRH_OSPEEDX_POS[16] = {
      INT32_C(0),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(2),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(4),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(6),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(8),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(10),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(12),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(14),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(16),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(18),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(20),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(22),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(24),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(26),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(28),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      INT32_C(30),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const int32_t GPIOX_AFRH_PUPDX_POS[16] = {
      INT32_C(0),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(2),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(4),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(6),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(8),    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(10),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(12),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(14),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(16),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(18),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(20),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(22),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(24),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(26),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(28),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      INT32_C(30),   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const int32_t GPIOX_AFRH_IDX_POS[16] = {
      INT32_C(0),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(1),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(2),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(3),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(4),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(5),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(6),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(7),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(8),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(9),    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(10),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(11),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(12),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(13),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(14),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      INT32_C(15),   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const int32_t GPIOX_AFRH_ODX_POS[16] = {
      INT32_C(0),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(1),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(2),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(3),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(4),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(5),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(6),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(7),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(8),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(9),    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(10),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(11),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(12),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(13),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(14),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      INT32_C(15),   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const int32_t GPIOX_AFRH_BSX_POS[16] = {
      INT32_C(0),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(1),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(2),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(3),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(4),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(5),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(6),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(7),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(8),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(9),    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(10),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(11),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(12),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(13),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(14),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
      INT32_C(15),   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    };

    static const int32_t GPIOX_AFRH_BRX_POS[16] = {
      INT32_C(16),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(17),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(18),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(19),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(20),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(21),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(22),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(23),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(24),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(25),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(26),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(27),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(28),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(29),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(30),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      INT32_C(31),   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const int32_t GPIOX_AFRH_LCKX_POS[16] = {
      INT32_C(0),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(1),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(2),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(3),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(4),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(5),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(6),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(7),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(8),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(9),    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(10),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(11),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(12),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(13),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(14),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
      INT32_C(15),   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    };

    static const int32_t GPIOX_AFRH_AFSELX_POS[8] = {
      INT32_C(0),    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      INT32_C(4),    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      INT32_C(8),    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      INT32_C(12),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      INT32_C(16),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      INT32_C(20),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      INT32_C(24),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      INT32_C(28),   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    /** @subsection GPIOX field position definitions */

    static const int32_t GPIOX_AFRH_LCKK_POS = INT32_C(16);   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    /**********************************************************************************************
     * @section JPEG Definitions
     **********************************************************************************************/

    /** @subsection JPEG IRQ interrupt definitions */

    static const int32_t JPEG_IRQ = INT32_C(121);   /** @brief JPEG global interrupt */

    /** @subsection JPEG register array definitions */

    static _RW uint32_t* const JPEG_CONFRNX_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52003010),   /** @brief JPEG codec configuration register 4-7 */
      (_RW uint32_t* const)UINT32_C(0x52003014),   /** @brief JPEG codec configuration register 4-7 */
      (_RW uint32_t* const)UINT32_C(0x52003018),   /** @brief JPEG codec configuration register 4-7 */
      (_RW uint32_t* const)UINT32_C(0x5200301C),   /** @brief JPEG codec configuration register 4-7 */
    };

    /** @subsection JPEG register definitions */

    static _RW uint32_t* const JPEG_CONFR0_REG = (_RW uint32_t* const)UINT32_C(0x52003000);   /** @brief JPEG codec control register */
    static _RW uint32_t* const JPEG_CONFR1_REG = (_RW uint32_t* const)UINT32_C(0x52003004);   /** @brief JPEG codec configuration register 1 */
    static _RW uint32_t* const JPEG_CONFR2_REG = (_RW uint32_t* const)UINT32_C(0x52003008);   /** @brief JPEG codec configuration register 2 */
    static _RW uint32_t* const JPEG_CONFR3_REG = (_RW uint32_t* const)UINT32_C(0x5200300C);   /** @brief JPEG codec configuration register 3 */
    static _RW uint32_t* const JPEG_CR_REG = (_RW uint32_t* const)UINT32_C(0x52003030);       /** @brief JPEG control register */
    static _RO uint32_t* const JPEG_SR_REG = (_RO uint32_t* const)UINT32_C(0x52003034);       /** @brief JPEG status register */
    static _RW uint32_t* const JPEG_CFR_REG = (_RW uint32_t* const)UINT32_C(0x52003038);      /** @brief JPEG clear flag register */
    static _RW uint32_t* const JPEG_DIR_REG = (_RW uint32_t* const)UINT32_C(0x52003040);      /** @brief JPEG data input register */
    static _RO uint32_t* const JPEG_DOR_REG = (_RO uint32_t* const)UINT32_C(0x52003044);      /** @brief JPEG data output register */

    /** @subsection JPEG field mask definitions */

    static const uint32_t JPEG_CONFR0_START_MASK = UINT32_C(0x00000001);        /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
    static const uint32_t JPEG_CONFR1_NF_MASK = UINT32_C(0x00000003);           /** @brief Number of color components this field defines the number of color components minus 1. */
    static const uint32_t JPEG_CONFR1_DE_MASK = UINT32_C(0x00000008);           /** @brief Decoding enable this bit selects the coding or decoding process */
    static const uint32_t JPEG_CONFR1_COLORSPACE_MASK = UINT32_C(0x00000030);   /** @brief Color space this filed defines the number of quantization tables minus 1 to insert in the output stream. */
    static const uint32_t JPEG_CONFR1_NS_MASK = UINT32_C(0x000000C0);           /** @brief Number of components for scan this field defines the number of components minus 1 for scan header marker segment. */
    static const uint32_t JPEG_CONFR1_HDR_MASK = UINT32_C(0x00000100);          /** @brief Header processing this bit enable the header processing (generation/parsing). */
    static const uint32_t JPEG_CONFR1_YSIZE_MASK = UINT32_C(0xFFFF0000);        /** @brief Y size this field defines the number of lines in source image. */
    static const uint32_t JPEG_CONFR2_NMCU_MASK = UINT32_C(0x03FFFFFF);         /** @brief Number of MCU for encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated. */
    static const uint32_t JPEG_CONFR3_XSIZE_MASK = UINT32_C(0xFFFF0000);        /** @brief X size this field defines the number of pixels per line. */
    static const uint32_t JPEG_CONFRNX_HD_MASK = UINT32_C(0x00000001);          /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const uint32_t JPEG_CONFRNX_HA_MASK = UINT32_C(0x00000002);          /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const uint32_t JPEG_CONFRNX_QT_MASK = UINT32_C(0x0000000C);          /** @brief Quantization table selects quantization table associated with a color component. */
    static const uint32_t JPEG_CONFRNX_NB_MASK = UINT32_C(0x000000F0);          /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const uint32_t JPEG_CONFRNX_VSF_MASK = UINT32_C(0x00000F00);         /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const uint32_t JPEG_CONFRNX_HSF_MASK = UINT32_C(0x0000F000);         /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const uint32_t JPEG_CONFRNX_HD_MASK = UINT32_C(0x00000001);          /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const uint32_t JPEG_CONFRNX_HA_MASK = UINT32_C(0x00000002);          /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const uint32_t JPEG_CONFRNX_QT_MASK = UINT32_C(0x0000000C);          /** @brief Quantization table selects quantization table associated with a color component. */
    static const uint32_t JPEG_CONFRNX_NB_MASK = UINT32_C(0x000000F0);          /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const uint32_t JPEG_CONFRNX_VSF_MASK = UINT32_C(0x00000F00);         /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const uint32_t JPEG_CONFRNX_HSF_MASK = UINT32_C(0x0000F000);         /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const uint32_t JPEG_CONFRNX_HD_MASK = UINT32_C(0x00000001);          /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const uint32_t JPEG_CONFRNX_HA_MASK = UINT32_C(0x00000002);          /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const uint32_t JPEG_CONFRNX_QT_MASK = UINT32_C(0x0000000C);          /** @brief Quantization table selects quantization table associated with a color component. */
    static const uint32_t JPEG_CONFRNX_NB_MASK = UINT32_C(0x000000F0);          /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const uint32_t JPEG_CONFRNX_VSF_MASK = UINT32_C(0x00000F00);         /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const uint32_t JPEG_CONFRNX_HSF_MASK = UINT32_C(0x0000F000);         /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const uint32_t JPEG_CONFRNX_HD_MASK = UINT32_C(0x00000001);          /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const uint32_t JPEG_CONFRNX_HA_MASK = UINT32_C(0x00000002);          /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const uint32_t JPEG_CONFRNX_QT_MASK = UINT32_C(0x0000000C);          /** @brief Quantization table selects quantization table associated with a color component. */
    static const uint32_t JPEG_CONFRNX_NB_MASK = UINT32_C(0x000000F0);          /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const uint32_t JPEG_CONFRNX_VSF_MASK = UINT32_C(0x00000F00);         /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const uint32_t JPEG_CONFRNX_HSF_MASK = UINT32_C(0x0000F000);         /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const uint32_t JPEG_CR_JCEN_MASK = UINT32_C(0x00000001);             /** @brief JPEG core enable enable the JPEG codec core. */
    static const uint32_t JPEG_CR_IFTIE_MASK = UINT32_C(0x00000002);            /** @brief Input FIFO threshold interrupt enable this bit enables the interrupt generation when input FIFO reach the threshold. */
    static const uint32_t JPEG_CR_IFNFIE_MASK = UINT32_C(0x00000004);           /** @brief Input FIFO not full interrupt enable this bit enables the interrupt generation when input FIFO is not empty. */
    static const uint32_t JPEG_CR_OFTIE_MASK = UINT32_C(0x00000008);            /** @brief Output FIFO threshold interrupt enable this bit enables the interrupt generation when output FIFO reach the threshold. */
    static const uint32_t JPEG_CR_OFNEIE_MASK = UINT32_C(0x00000010);           /** @brief Output FIFO not empty interrupt enable this bit enables the interrupt generation when output FIFO is not empty. */
    static const uint32_t JPEG_CR_EOCIE_MASK = UINT32_C(0x00000020);            /** @brief End of conversion interrupt enable this bit enables the interrupt generation on the end of conversion. */
    static const uint32_t JPEG_CR_HPDIE_MASK = UINT32_C(0x00000040);            /** @brief Header parsing done interrupt enable this bit enables the interrupt generation on the header parsing operation. */
    static const uint32_t JPEG_CR_IDMAEN_MASK = UINT32_C(0x00000800);           /** @brief Input DMA enable enable the DMA request generation for the input FIFO. */
    static const uint32_t JPEG_CR_ODMAEN_MASK = UINT32_C(0x00001000);           /** @brief Output DMA enable enable the DMA request generation for the output FIFO. */
    static const uint32_t JPEG_CR_IFF_MASK = UINT32_C(0x00002000);              /** @brief Input FIFO flush this bit flush the input FIFO. This bit is always read as 0. */
    static const uint32_t JPEG_CR_OFF_MASK = UINT32_C(0x00004000);              /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
    static const uint32_t JPEG_SR_IFTF_MASK = UINT32_C(0x00000002);             /** @brief Input FIFO threshold flag this bit is set when the input FIFO is not full and is bellow its threshold. */
    static const uint32_t JPEG_SR_IFNFF_MASK = UINT32_C(0x00000004);            /** @brief Input FIFO not full flag this bit is set when the input FIFO is not full (a data can be written). */
    static const uint32_t JPEG_SR_OFTF_MASK = UINT32_C(0x00000008);             /** @brief Output FIFO threshold flag this bit is set when the output FIFO is not empty and has reach its threshold. */
    static const uint32_t JPEG_SR_OFNEF_MASK = UINT32_C(0x00000010);            /** @brief Output FIFO not empty flag this bit is set when the output FIFO is not empty (a data is available). */
    static const uint32_t JPEG_SR_EOCF_MASK = UINT32_C(0x00000020);             /** @brief End of conversion flag this bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO. */
    static const uint32_t JPEG_SR_HPDF_MASK = UINT32_C(0x00000040);             /** @brief Header parsing done flag this bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated. */
    static const uint32_t JPEG_SR_COF_MASK = UINT32_C(0x00000080);              /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
    static const uint32_t JPEG_CFR_CEOCF_MASK = UINT32_C(0x00000020);           /** @brief Clear end of conversion flag writing 1 clears the end of conversion flag of the JPEG status register. */
    static const uint32_t JPEG_CFR_CHPDF_MASK = UINT32_C(0x00000040);           /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */

    /** @subsection JPEG field position definitions */

    static const int32_t JPEG_DOR_START_POS = INT32_C(0);         /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
    static const int32_t JPEG_DOR_NF_POS = INT32_C(0);            /** @brief Number of color components this field defines the number of color components minus 1. */
    static const int32_t JPEG_DOR_DE_POS = INT32_C(3);            /** @brief Decoding enable this bit selects the coding or decoding process */
    static const int32_t JPEG_DOR_COLORSPACE_POS = INT32_C(4);    /** @brief Color space this filed defines the number of quantization tables minus 1 to insert in the output stream. */
    static const int32_t JPEG_DOR_NS_POS = INT32_C(6);            /** @brief Number of components for scan this field defines the number of components minus 1 for scan header marker segment. */
    static const int32_t JPEG_DOR_HDR_POS = INT32_C(8);           /** @brief Header processing this bit enable the header processing (generation/parsing). */
    static const int32_t JPEG_DOR_YSIZE_POS = INT32_C(16);        /** @brief Y size this field defines the number of lines in source image. */
    static const int32_t JPEG_DOR_NMCU_POS = INT32_C(0);          /** @brief Number of MCU for encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated. */
    static const int32_t JPEG_DOR_XSIZE_POS = INT32_C(16);        /** @brief X size this field defines the number of pixels per line. */
    static const int32_t JPEG_DOR_HD_POS = INT32_C(0);            /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const int32_t JPEG_DOR_HA_POS = INT32_C(1);            /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const int32_t JPEG_DOR_QT_POS = INT32_C(2);            /** @brief Quantization table selects quantization table associated with a color component. */
    static const int32_t JPEG_DOR_NB_POS = INT32_C(4);            /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const int32_t JPEG_DOR_VSF_POS = INT32_C(8);           /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const int32_t JPEG_DOR_HSF_POS = INT32_C(12);          /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const int32_t JPEG_DOR_HD_POS = INT32_C(0);            /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const int32_t JPEG_DOR_HA_POS = INT32_C(1);            /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const int32_t JPEG_DOR_QT_POS = INT32_C(2);            /** @brief Quantization table selects quantization table associated with a color component. */
    static const int32_t JPEG_DOR_NB_POS = INT32_C(4);            /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const int32_t JPEG_DOR_VSF_POS = INT32_C(8);           /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const int32_t JPEG_DOR_HSF_POS = INT32_C(12);          /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const int32_t JPEG_DOR_HD_POS = INT32_C(0);            /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const int32_t JPEG_DOR_HA_POS = INT32_C(1);            /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const int32_t JPEG_DOR_QT_POS = INT32_C(2);            /** @brief Quantization table selects quantization table associated with a color component. */
    static const int32_t JPEG_DOR_NB_POS = INT32_C(4);            /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const int32_t JPEG_DOR_VSF_POS = INT32_C(8);           /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const int32_t JPEG_DOR_HSF_POS = INT32_C(12);          /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const int32_t JPEG_DOR_HD_POS = INT32_C(0);            /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
    static const int32_t JPEG_DOR_HA_POS = INT32_C(1);            /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
    static const int32_t JPEG_DOR_QT_POS = INT32_C(2);            /** @brief Quantization table selects quantization table associated with a color component. */
    static const int32_t JPEG_DOR_NB_POS = INT32_C(4);            /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
    static const int32_t JPEG_DOR_VSF_POS = INT32_C(8);           /** @brief Vertical sampling factor vertical sampling factor for component i. */
    static const int32_t JPEG_DOR_HSF_POS = INT32_C(12);          /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    static const int32_t JPEG_DOR_JCEN_POS = INT32_C(0);          /** @brief JPEG core enable enable the JPEG codec core. */
    static const int32_t JPEG_DOR_IFTIE_POS = INT32_C(1);         /** @brief Input FIFO threshold interrupt enable this bit enables the interrupt generation when input FIFO reach the threshold. */
    static const int32_t JPEG_DOR_IFNFIE_POS = INT32_C(2);        /** @brief Input FIFO not full interrupt enable this bit enables the interrupt generation when input FIFO is not empty. */
    static const int32_t JPEG_DOR_OFTIE_POS = INT32_C(3);         /** @brief Output FIFO threshold interrupt enable this bit enables the interrupt generation when output FIFO reach the threshold. */
    static const int32_t JPEG_DOR_OFNEIE_POS = INT32_C(4);        /** @brief Output FIFO not empty interrupt enable this bit enables the interrupt generation when output FIFO is not empty. */
    static const int32_t JPEG_DOR_EOCIE_POS = INT32_C(5);         /** @brief End of conversion interrupt enable this bit enables the interrupt generation on the end of conversion. */
    static const int32_t JPEG_DOR_HPDIE_POS = INT32_C(6);         /** @brief Header parsing done interrupt enable this bit enables the interrupt generation on the header parsing operation. */
    static const int32_t JPEG_DOR_IDMAEN_POS = INT32_C(11);       /** @brief Input DMA enable enable the DMA request generation for the input FIFO. */
    static const int32_t JPEG_DOR_ODMAEN_POS = INT32_C(12);       /** @brief Output DMA enable enable the DMA request generation for the output FIFO. */
    static const int32_t JPEG_DOR_IFF_POS = INT32_C(13);          /** @brief Input FIFO flush this bit flush the input FIFO. This bit is always read as 0. */
    static const int32_t JPEG_DOR_OFF_POS = INT32_C(14);          /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
    static const int32_t JPEG_DOR_IFTF_POS = INT32_C(1);          /** @brief Input FIFO threshold flag this bit is set when the input FIFO is not full and is bellow its threshold. */
    static const int32_t JPEG_DOR_IFNFF_POS = INT32_C(2);         /** @brief Input FIFO not full flag this bit is set when the input FIFO is not full (a data can be written). */
    static const int32_t JPEG_DOR_OFTF_POS = INT32_C(3);          /** @brief Output FIFO threshold flag this bit is set when the output FIFO is not empty and has reach its threshold. */
    static const int32_t JPEG_DOR_OFNEF_POS = INT32_C(4);         /** @brief Output FIFO not empty flag this bit is set when the output FIFO is not empty (a data is available). */
    static const int32_t JPEG_DOR_EOCF_POS = INT32_C(5);          /** @brief End of conversion flag this bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO. */
    static const int32_t JPEG_DOR_HPDF_POS = INT32_C(6);          /** @brief Header parsing done flag this bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated. */
    static const int32_t JPEG_DOR_COF_POS = INT32_C(7);           /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
    static const int32_t JPEG_DOR_CEOCF_POS = INT32_C(5);         /** @brief Clear end of conversion flag writing 1 clears the end of conversion flag of the JPEG status register. */
    static const int32_t JPEG_DOR_CHPDF_POS = INT32_C(6);         /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */

    /**********************************************************************************************
     * @section MDMA Definitions
     **********************************************************************************************/

    /** @subsection MDMA IRQ interrupt definitions */

    static const int32_t MDMA_IRQ = INT32_C(122);   /** @brief MDMA */

    /** @subsection MDMA register array definitions */

    static _RO uint32_t* const MDMA_CXISR_REG[16] = {
      (_RO uint32_t* const)UINT32_C(0x52000040),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000080),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x520000C0),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000100),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000140),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000180),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x520001C0),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000200),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000240),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000280),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x520002C0),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000300),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000340),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000380),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x520003C0),   /** @brief MDMA channel x interrupt/status register */
      (_RO uint32_t* const)UINT32_C(0x52000400),   /** @brief MDMA channel x interrupt/status register */
    };

    static _RW uint32_t* const MDMA_CXIFCR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000044),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000084),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x520000C4),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000104),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000144),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000184),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x520001C4),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000204),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000244),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000284),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x520002C4),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000304),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000344),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000384),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x520003C4),   /** @brief MDMA channel x interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x52000404),   /** @brief MDMA channel x interrupt flag clear register */
    };

    static _RO uint32_t* const MDMA_CXESR_REG[16] = {
      (_RO uint32_t* const)UINT32_C(0x52000048),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000088),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x520000C8),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000108),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000148),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000188),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x520001C8),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000208),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000248),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000288),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x520002C8),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000308),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000348),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000388),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x520003C8),   /** @brief MDMA channel x error status register */
      (_RO uint32_t* const)UINT32_C(0x52000408),   /** @brief MDMA channel x error status register */
    };

    static _RW uint32_t* const MDMA_CXCR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x5200004C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200008C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520000CC),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200010C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200014C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200018C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520001CC),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200020C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200024C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200028C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520002CC),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200030C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200034C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200038C),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520003CC),   /** @brief This register is used to control the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x5200040C),   /** @brief This register is used to control the concerned channel. */
    };

    static _RW uint32_t* const MDMA_CXTCR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000050),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000090),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520000D0),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000110),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000150),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000190),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520001D0),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000210),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000250),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000290),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520002D0),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000310),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000350),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000390),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x520003D0),   /** @brief This register is used to configure the concerned channel. */
      (_RW uint32_t* const)UINT32_C(0x52000410),   /** @brief This register is used to configure the concerned channel. */
    };

    static _RW uint32_t* const MDMA_CXBNDTR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000054),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000094),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x520000D4),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000114),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000154),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000194),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x520001D4),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000214),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000254),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000294),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x520002D4),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000314),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000354),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000394),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x520003D4),   /** @brief MDMA channel x block number of data register */
      (_RW uint32_t* const)UINT32_C(0x52000414),   /** @brief MDMA channel x block number of data register */
    };

    static _RW uint32_t* const MDMA_CXSAR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000058),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000098),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x520000D8),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000118),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000158),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000198),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x520001D8),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000218),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000258),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000298),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x520002D8),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000318),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000358),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000398),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x520003D8),   /** @brief MDMA channel x source address register */
      (_RW uint32_t* const)UINT32_C(0x52000418),   /** @brief MDMA channel x source address register */
    };

    static _RW uint32_t* const MDMA_CXDAR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x5200005C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200009C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x520000DC),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200011C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200015C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200019C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x520001DC),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200021C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200025C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200029C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x520002DC),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200031C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200035C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200039C),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x520003DC),   /** @brief MDMA channel x destination address register */
      (_RW uint32_t* const)UINT32_C(0x5200041C),   /** @brief MDMA channel x destination address register */
    };

    static _RW uint32_t* const MDMA_CXBRUR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000060),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520000A0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520000E0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x52000120),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x52000160),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520001A0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520001E0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x52000220),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x52000260),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520002A0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520002E0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x52000320),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x52000360),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520003A0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x520003E0),   /** @brief MDMA channel x block repeat address update register */
      (_RW uint32_t* const)UINT32_C(0x52000420),   /** @brief MDMA channel x block repeat address update register */
    };

    static _RW uint32_t* const MDMA_CXLAR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000064),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520000A4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520000E4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x52000124),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x52000164),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520001A4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520001E4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x52000224),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x52000264),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520002A4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520002E4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x52000324),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x52000364),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520003A4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x520003E4),   /** @brief MDMA channel x link address register */
      (_RW uint32_t* const)UINT32_C(0x52000424),   /** @brief MDMA channel x link address register */
    };

    static _RW uint32_t* const MDMA_CXTBR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000068),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520000A8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520000E8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x52000128),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x52000168),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520001A8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520001E8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x52000228),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x52000268),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520002A8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520002E8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x52000328),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x52000368),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520003A8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x520003E8),   /** @brief MDMA channel x trigger and bus selection register */
      (_RW uint32_t* const)UINT32_C(0x52000428),   /** @brief MDMA channel x trigger and bus selection register */
    };

    static _RW uint32_t* const MDMA_CXMAR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000070),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520000B0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520000F0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x52000130),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x52000170),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520001B0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520001F0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x52000230),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x52000270),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520002B0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520002F0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x52000330),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x52000370),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520003B0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x520003F0),   /** @brief MDMA channel x mask address register */
      (_RW uint32_t* const)UINT32_C(0x52000430),   /** @brief MDMA channel x mask address register */
    };

    static _RW uint32_t* const MDMA_CXMDR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x52000074),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520000B4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520000F4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x52000134),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x52000174),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520001B4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520001F4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x52000234),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x52000274),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520002B4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520002F4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x52000334),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x52000374),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520003B4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x520003F4),   /** @brief MDMA channel x mask data register */
      (_RW uint32_t* const)UINT32_C(0x52000434),   /** @brief MDMA channel x mask data register */
    };

    /** @subsection MDMA register definitions */

    static _RO uint32_t* const MDMA_GISR0_REG = (_RO uint32_t* const)UINT32_C(0x52000000);   /** @brief MDMA global interrupt/status register */

    /** @subsection MDMA field mask array definitions */

    static const uint32_t MDMA_GISR0_GIFX_MASK[16] = {
      UINT32_C(0x00000001),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000002),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000004),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000008),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000010),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000020),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000040),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000080),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000100),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000200),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000400),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00000800),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00001000),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00002000),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00004000),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      UINT32_C(0x00008000),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
    };

    /** @subsection MDMA field mask definitions */

    static const uint32_t MDMA_CXISR_TEIF0_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF0_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF0_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF0_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF0_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA0_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF0_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF0_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF0_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF0_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF0_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF1_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF1_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF1_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF1_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF1_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA1_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF1_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF1_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF1_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF1_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF1_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF2_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF2_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF2_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF2_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF2_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA2_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF2_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF2_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF2_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF2_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF2_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF3_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF3_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF3_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF3_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF3_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA3_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF3_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF3_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF3_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF3_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF3_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF4_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF4_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF4_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF4_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF4_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA4_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF4_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF4_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF4_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF4_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF4_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF5_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF5_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF5_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF5_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF5_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA5_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF5_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF5_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF5_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF5_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF5_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF6_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF6_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF6_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF6_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF6_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA6_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF6_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF6_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF6_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF6_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF6_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF7_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF7_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF7_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF7_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF7_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA7_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF7_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF7_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF7_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF7_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF7_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF8_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF8_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF8_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF8_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF8_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA8_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF8_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF8_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF8_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF8_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF8_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF9_MASK = UINT32_C(0x00000001);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF9_MASK = UINT32_C(0x00000002);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF9_MASK = UINT32_C(0x00000004);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF9_MASK = UINT32_C(0x00000008);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF9_MASK = UINT32_C(0x00000010);       /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA9_MASK = UINT32_C(0x00010000);       /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF9_MASK = UINT32_C(0x00000001);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF9_MASK = UINT32_C(0x00000002);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF9_MASK = UINT32_C(0x00000004);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF9_MASK = UINT32_C(0x00000008);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF9_MASK = UINT32_C(0x00000010);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF10_MASK = UINT32_C(0x00000001);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF10_MASK = UINT32_C(0x00000002);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF10_MASK = UINT32_C(0x00000004);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF10_MASK = UINT32_C(0x00000008);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF10_MASK = UINT32_C(0x00000010);      /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA10_MASK = UINT32_C(0x00010000);      /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF10_MASK = UINT32_C(0x00000001);    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF10_MASK = UINT32_C(0x00000002);   /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF10_MASK = UINT32_C(0x00000004);   /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF10_MASK = UINT32_C(0x00000008);    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF10_MASK = UINT32_C(0x00000010);   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF11_MASK = UINT32_C(0x00000001);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF11_MASK = UINT32_C(0x00000002);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF11_MASK = UINT32_C(0x00000004);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF11_MASK = UINT32_C(0x00000008);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF11_MASK = UINT32_C(0x00000010);      /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA11_MASK = UINT32_C(0x00010000);      /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF11_MASK = UINT32_C(0x00000001);    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF11_MASK = UINT32_C(0x00000002);   /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF11_MASK = UINT32_C(0x00000004);   /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF11_MASK = UINT32_C(0x00000008);    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF11_MASK = UINT32_C(0x00000010);   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF12_MASK = UINT32_C(0x00000001);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF12_MASK = UINT32_C(0x00000002);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF12_MASK = UINT32_C(0x00000004);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF12_MASK = UINT32_C(0x00000008);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF12_MASK = UINT32_C(0x00000010);      /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA12_MASK = UINT32_C(0x00010000);      /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF12_MASK = UINT32_C(0x00000001);    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF12_MASK = UINT32_C(0x00000002);   /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF12_MASK = UINT32_C(0x00000004);   /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF12_MASK = UINT32_C(0x00000008);    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF12_MASK = UINT32_C(0x00000010);   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF13_MASK = UINT32_C(0x00000001);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF13_MASK = UINT32_C(0x00000002);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF13_MASK = UINT32_C(0x00000004);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF13_MASK = UINT32_C(0x00000008);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF13_MASK = UINT32_C(0x00000010);      /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA13_MASK = UINT32_C(0x00010000);      /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF13_MASK = UINT32_C(0x00000001);    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF13_MASK = UINT32_C(0x00000002);   /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF13_MASK = UINT32_C(0x00000004);   /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF13_MASK = UINT32_C(0x00000008);    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF13_MASK = UINT32_C(0x00000010);   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF14_MASK = UINT32_C(0x00000001);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF14_MASK = UINT32_C(0x00000002);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF14_MASK = UINT32_C(0x00000004);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF14_MASK = UINT32_C(0x00000008);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF14_MASK = UINT32_C(0x00000010);      /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA14_MASK = UINT32_C(0x00010000);      /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF14_MASK = UINT32_C(0x00000001);    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF14_MASK = UINT32_C(0x00000002);   /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF14_MASK = UINT32_C(0x00000004);   /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF14_MASK = UINT32_C(0x00000008);    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF14_MASK = UINT32_C(0x00000010);   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXISR_TEIF15_MASK = UINT32_C(0x00000001);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_CTCIF15_MASK = UINT32_C(0x00000002);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const uint32_t MDMA_CXISR_BRTIF15_MASK = UINT32_C(0x00000004);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_BTIF15_MASK = UINT32_C(0x00000008);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXISR_TCIF15_MASK = UINT32_C(0x00000010);      /** @brief Channel x buffer transfer complete */
    static const uint32_t MDMA_CXISR_CRQA15_MASK = UINT32_C(0x00010000);      /** @brief Channel x request active flag */
    static const uint32_t MDMA_CXIFCR_CTEIF15_MASK = UINT32_C(0x00000001);    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CCTCIF15_MASK = UINT32_C(0x00000002);   /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBRTIF15_MASK = UINT32_C(0x00000004);   /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CBTIF15_MASK = UINT32_C(0x00000008);    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const uint32_t MDMA_CXIFCR_CLTCIF15_MASK = UINT32_C(0x00000010);   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const uint32_t MDMA_CXESR_TEA_MASK = UINT32_C(0x0000007F);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const uint32_t MDMA_CXESR_TED_MASK = UINT32_C(0x00000080);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const uint32_t MDMA_CXESR_TELD_MASK = UINT32_C(0x00000100);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_TEMD_MASK = UINT32_C(0x00000200);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_ASE_MASK = UINT32_C(0x00000400);         /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXESR_BSE_MASK = UINT32_C(0x00000800);         /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const uint32_t MDMA_CXCR_EN_MASK = UINT32_C(0x00000001);           /** @brief Channel enable */
    static const uint32_t MDMA_CXCR_TEIE_MASK = UINT32_C(0x00000002);         /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_CTCIE_MASK = UINT32_C(0x00000004);        /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BRTIE_MASK = UINT32_C(0x00000008);        /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_BTIE_MASK = UINT32_C(0x00000010);         /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_TCIE_MASK = UINT32_C(0x00000020);         /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const uint32_t MDMA_CXCR_PL_MASK = UINT32_C(0x000000C0);           /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXCR_BEX_MASK = UINT32_C(0x00001000);          /** @brief Byte endianness exchange */
    static const uint32_t MDMA_CXCR_HEX_MASK = UINT32_C(0x00002000);          /** @brief Half word endianes exchange */
    static const uint32_t MDMA_CXCR_WEX_MASK = UINT32_C(0x00004000);          /** @brief Word endianness exchange */
    static const uint32_t MDMA_CXCR_SWRQ_MASK = UINT32_C(0x00010000);         /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const uint32_t MDMA_CXTCR_SINC_MASK = UINT32_C(0x00000003);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const uint32_t MDMA_CXTCR_DINC_MASK = UINT32_C(0x0000000C);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const uint32_t MDMA_CXTCR_SSIZE_MASK = UINT32_C(0x00000030);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const uint32_t MDMA_CXTCR_DSIZE_MASK = UINT32_C(0x000000C0);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const uint32_t MDMA_CXTCR_SINCOS_MASK = UINT32_C(0x00000300);      /** @brief Source increment offset size */
    static const uint32_t MDMA_CXTCR_DINCOS_MASK = UINT32_C(0x00000C00);      /** @brief Destination increment offset */
    static const uint32_t MDMA_CXTCR_SBURST_MASK = UINT32_C(0x00007000);      /** @brief Source burst transfer configuration */
    static const uint32_t MDMA_CXTCR_DBURST_MASK = UINT32_C(0x00038000);      /** @brief Destination burst transfer configuration */
    static const uint32_t MDMA_CXTCR_TLEN_MASK = UINT32_C(0x01FC0000);        /** @brief Buffer transfer lengh */
    static const uint32_t MDMA_CXTCR_PKE_MASK = UINT32_C(0x02000000);         /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_PAM_MASK = UINT32_C(0x0C000000);         /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const uint32_t MDMA_CXTCR_TRGM_MASK = UINT32_C(0x30000000);        /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_SWRM_MASK = UINT32_C(0x40000000);        /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTCR_BWM_MASK = UINT32_C(0x80000000);         /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const uint32_t MDMA_CXBNDTR_BNDT_MASK = UINT32_C(0x0001FFFF);      /** @brief Block number of data to transfer */
    static const uint32_t MDMA_CXBNDTR_BRSUM_MASK = UINT32_C(0x00040000);     /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRDUM_MASK = UINT32_C(0x00080000);     /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBNDTR_BRC_MASK = UINT32_C(0xFFF00000);       /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXBRUR_SUV_MASK = UINT32_C(0x0000FFFF);        /** @brief Source adresse update value */
    static const uint32_t MDMA_CXBRUR_DUV_MASK = UINT32_C(0xFFFF0000);        /** @brief Destination address update */
    static const uint32_t MDMA_CXTBR_TSEL_MASK = UINT32_C(0x0000003F);        /** @brief Trigger selection */
    static const uint32_t MDMA_CXTBR_SBUS_MASK = UINT32_C(0x00010000);        /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const uint32_t MDMA_CXTBR_DBUS_MASK = UINT32_C(0x00020000);        /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */

    /** @subsection MDMA field position array definitions */

    static const int32_t MDMA_CXMDR_GIFX_POS[16] = {
      INT32_C(0),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(1),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(2),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(3),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(4),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(5),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(6),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(7),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(8),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(9),    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(10),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(11),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(12),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(13),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(14),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      INT32_C(15),   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
    };

    /** @subsection MDMA field position definitions */

    static const int32_t MDMA_CXMDR_TEIF0_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF0_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF0_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF0_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF0_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA0_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF0_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF0_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF0_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF0_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF0_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF1_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF1_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF1_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF1_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF1_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA1_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF1_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF1_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF1_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF1_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF1_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF2_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF2_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF2_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF2_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF2_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA2_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF2_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF2_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF2_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF2_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF2_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF3_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF3_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF3_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF3_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF3_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA3_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF3_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF3_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF3_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF3_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF3_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF4_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF4_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF4_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF4_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF4_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA4_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF4_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF4_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF4_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF4_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF4_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF5_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF5_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF5_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF5_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF5_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA5_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF5_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF5_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF5_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF5_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF5_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF6_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF6_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF6_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF6_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF6_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA6_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF6_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF6_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF6_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF6_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF6_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF7_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF7_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF7_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF7_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF7_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA7_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF7_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF7_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF7_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF7_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF7_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF8_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF8_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF8_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF8_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF8_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA8_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF8_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF8_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF8_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF8_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF8_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF9_POS = INT32_C(0);       /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF9_POS = INT32_C(1);      /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF9_POS = INT32_C(2);      /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF9_POS = INT32_C(3);       /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF9_POS = INT32_C(4);       /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA9_POS = INT32_C(16);      /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF9_POS = INT32_C(0);      /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF9_POS = INT32_C(1);     /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF9_POS = INT32_C(2);     /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF9_POS = INT32_C(3);      /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF9_POS = INT32_C(4);     /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF10_POS = INT32_C(0);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF10_POS = INT32_C(1);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF10_POS = INT32_C(2);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF10_POS = INT32_C(3);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF10_POS = INT32_C(4);      /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA10_POS = INT32_C(16);     /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF10_POS = INT32_C(0);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF10_POS = INT32_C(1);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF10_POS = INT32_C(2);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF10_POS = INT32_C(3);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF10_POS = INT32_C(4);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF11_POS = INT32_C(0);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF11_POS = INT32_C(1);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF11_POS = INT32_C(2);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF11_POS = INT32_C(3);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF11_POS = INT32_C(4);      /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA11_POS = INT32_C(16);     /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF11_POS = INT32_C(0);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF11_POS = INT32_C(1);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF11_POS = INT32_C(2);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF11_POS = INT32_C(3);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF11_POS = INT32_C(4);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF12_POS = INT32_C(0);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF12_POS = INT32_C(1);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF12_POS = INT32_C(2);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF12_POS = INT32_C(3);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF12_POS = INT32_C(4);      /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA12_POS = INT32_C(16);     /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF12_POS = INT32_C(0);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF12_POS = INT32_C(1);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF12_POS = INT32_C(2);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF12_POS = INT32_C(3);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF12_POS = INT32_C(4);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF13_POS = INT32_C(0);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF13_POS = INT32_C(1);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF13_POS = INT32_C(2);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF13_POS = INT32_C(3);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF13_POS = INT32_C(4);      /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA13_POS = INT32_C(16);     /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF13_POS = INT32_C(0);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF13_POS = INT32_C(1);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF13_POS = INT32_C(2);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF13_POS = INT32_C(3);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF13_POS = INT32_C(4);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF14_POS = INT32_C(0);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF14_POS = INT32_C(1);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF14_POS = INT32_C(2);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF14_POS = INT32_C(3);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF14_POS = INT32_C(4);      /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA14_POS = INT32_C(16);     /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF14_POS = INT32_C(0);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF14_POS = INT32_C(1);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF14_POS = INT32_C(2);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF14_POS = INT32_C(3);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF14_POS = INT32_C(4);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_TEIF15_POS = INT32_C(0);      /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_CTCIF15_POS = INT32_C(1);     /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
    static const int32_t MDMA_CXMDR_BRTIF15_POS = INT32_C(2);     /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BTIF15_POS = INT32_C(3);      /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TCIF15_POS = INT32_C(4);      /** @brief Channel x buffer transfer complete */
    static const int32_t MDMA_CXMDR_CRQA15_POS = INT32_C(16);     /** @brief Channel x request active flag */
    static const int32_t MDMA_CXMDR_CTEIF15_POS = INT32_C(0);     /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CCTCIF15_POS = INT32_C(1);    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBRTIF15_POS = INT32_C(2);    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CBTIF15_POS = INT32_C(3);     /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_CLTCIF15_POS = INT32_C(4);    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    static const int32_t MDMA_CXMDR_TEA_POS = INT32_C(0);         /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
    static const int32_t MDMA_CXMDR_TED_POS = INT32_C(7);         /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
    static const int32_t MDMA_CXMDR_TELD_POS = INT32_C(8);        /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_TEMD_POS = INT32_C(9);        /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_ASE_POS = INT32_C(10);        /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_BSE_POS = INT32_C(11);        /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    static const int32_t MDMA_CXMDR_EN_POS = INT32_C(0);          /** @brief Channel enable */
    static const int32_t MDMA_CXMDR_TEIE_POS = INT32_C(1);        /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_CTCIE_POS = INT32_C(2);       /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BRTIE_POS = INT32_C(3);       /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_BTIE_POS = INT32_C(4);        /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_TCIE_POS = INT32_C(5);        /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
    static const int32_t MDMA_CXMDR_PL_POS = INT32_C(6);          /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BEX_POS = INT32_C(12);        /** @brief Byte endianness exchange */
    static const int32_t MDMA_CXMDR_HEX_POS = INT32_C(13);        /** @brief Half word endianes exchange */
    static const int32_t MDMA_CXMDR_WEX_POS = INT32_C(14);        /** @brief Word endianness exchange */
    static const int32_t MDMA_CXMDR_SWRQ_POS = INT32_C(16);       /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    static const int32_t MDMA_CXMDR_SINC_POS = INT32_C(0);        /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
    static const int32_t MDMA_CXMDR_DINC_POS = INT32_C(2);        /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
    static const int32_t MDMA_CXMDR_SSIZE_POS = INT32_C(4);       /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
    static const int32_t MDMA_CXMDR_DSIZE_POS = INT32_C(6);       /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
    static const int32_t MDMA_CXMDR_SINCOS_POS = INT32_C(8);      /** @brief Source increment offset size */
    static const int32_t MDMA_CXMDR_DINCOS_POS = INT32_C(10);     /** @brief Destination increment offset */
    static const int32_t MDMA_CXMDR_SBURST_POS = INT32_C(12);     /** @brief Source burst transfer configuration */
    static const int32_t MDMA_CXMDR_DBURST_POS = INT32_C(15);     /** @brief Destination burst transfer configuration */
    static const int32_t MDMA_CXMDR_TLEN_POS = INT32_C(18);       /** @brief Buffer transfer lengh */
    static const int32_t MDMA_CXMDR_PKE_POS = INT32_C(25);        /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_PAM_POS = INT32_C(26);        /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0 */
    static const int32_t MDMA_CXMDR_TRGM_POS = INT32_C(28);       /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SWRM_POS = INT32_C(30);       /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BWM_POS = INT32_C(31);        /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    static const int32_t MDMA_CXMDR_BNDT_POS = INT32_C(0);        /** @brief Block number of data to transfer */
    static const int32_t MDMA_CXMDR_BRSUM_POS = INT32_C(18);      /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRDUM_POS = INT32_C(19);      /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_BRC_POS = INT32_C(20);        /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_SUV_POS = INT32_C(0);         /** @brief Source adresse update value */
    static const int32_t MDMA_CXMDR_DUV_POS = INT32_C(16);        /** @brief Destination address update */
    static const int32_t MDMA_CXMDR_TSEL_POS = INT32_C(0);        /** @brief Trigger selection */
    static const int32_t MDMA_CXMDR_SBUS_POS = INT32_C(16);       /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
    static const int32_t MDMA_CXMDR_DBUS_POS = INT32_C(17);       /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */

    /**********************************************************************************************
     * @section QUADSPI Definitions
     **********************************************************************************************/

    /** @subsection QUADSPI IRQ interrupt definitions */

    static const int32_t QUADSPI_IRQ = INT32_C(92);   /** @brief QuadSPI global interrupt */

    /** @subsection QUADSPI register definitions */

    static _RW uint32_t* const QUADSPI_CR_REG = (_RW uint32_t* const)UINT32_C(0x52005000);      /** @brief QUADSPI control register */
    static _RW uint32_t* const QUADSPI_DCR_REG = (_RW uint32_t* const)UINT32_C(0x52005004);     /** @brief QUADSPI device configuration register */
    static _RO uint32_t* const QUADSPI_SR_REG = (_RO uint32_t* const)UINT32_C(0x52005008);      /** @brief QUADSPI status register */
    static _RW uint32_t* const QUADSPI_FCR_REG = (_RW uint32_t* const)UINT32_C(0x5200500C);     /** @brief QUADSPI flag clear register */
    static _RW uint32_t* const QUADSPI_DLR_REG = (_RW uint32_t* const)UINT32_C(0x52005010);     /** @brief QUADSPI data length register */
    static _RW uint32_t* const QUADSPI_CCR_REG = (_RW uint32_t* const)UINT32_C(0x52005014);     /** @brief QUADSPI communication configuration register */
    static _RW uint32_t* const QUADSPI_AR_REG = (_RW uint32_t* const)UINT32_C(0x52005018);      /** @brief QUADSPI address register */
    static _RW uint32_t* const QUADSPI_ABR_REG = (_RW uint32_t* const)UINT32_C(0x5200501C);     /** @brief QUADSPI alternate bytes registers */
    static _RW uint32_t* const QUADSPI_DR_REG = (_RW uint32_t* const)UINT32_C(0x52005020);      /** @brief QUADSPI data register */
    static _RW uint32_t* const QUADSPI_PSMKR_REG = (_RW uint32_t* const)UINT32_C(0x52005024);   /** @brief QUADSPI polling status mask register */
    static _RW uint32_t* const QUADSPI_PSMAR_REG = (_RW uint32_t* const)UINT32_C(0x52005028);   /** @brief QUADSPI polling status match register */
    static _RW uint32_t* const QUADSPI_PIR_REG = (_RW uint32_t* const)UINT32_C(0x5200502C);     /** @brief QUADSPI polling interval register */
    static _RW uint32_t* const QUADSPI_LPTR_REG = (_RW uint32_t* const)UINT32_C(0x52005030);    /** @brief QUADSPI low-power timeout register */

    /** @subsection QUADSPI field mask definitions */

    static const uint32_t QUADSPI_CR_EN_MASK = UINT32_C(0x00000001);             /** @brief Enable enable the QUADSPI. */
    static const uint32_t QUADSPI_CR_ABORT_MASK = UINT32_C(0x00000002);          /** @brief Abort request this bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit. */
    static const uint32_t QUADSPI_CR_DMAEN_MASK = UINT32_C(0x00000004);          /** @brief DMA enable in indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set. */
    static const uint32_t QUADSPI_CR_TCEN_MASK = UINT32_C(0x00000008);           /** @brief Timeout counter enable this bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (ncs) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with ncs maintained low, even if no access to the flash memory occurs for a long time. Since flash memories tend to consume more when ncs is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that ncs is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_SSHIFT_MASK = UINT32_C(0x00000010);         /** @brief Sample shift by default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_DFM_MASK = UINT32_C(0x00000040);            /** @brief Dual-flash mode this bit activates dual-flash mode, where two external flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_FSEL_MASK = UINT32_C(0x00000080);           /** @brief Flash memory selection this bit selects the flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1. */
    static const uint32_t QUADSPI_CR_FTHRES_MASK = UINT32_C(0x00001F00);         /** @brief FIFO threshold level defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. */
    static const uint32_t QUADSPI_CR_TEIE_MASK = UINT32_C(0x00010000);           /** @brief Transfer error interrupt enable this bit enables the transfer error interrupt. */
    static const uint32_t QUADSPI_CR_TCIE_MASK = UINT32_C(0x00020000);           /** @brief Transfer complete interrupt enable this bit enables the transfer complete interrupt. */
    static const uint32_t QUADSPI_CR_FTIE_MASK = UINT32_C(0x00040000);           /** @brief FIFO threshold interrupt enable this bit enables the FIFO threshold interrupt. */
    static const uint32_t QUADSPI_CR_SMIE_MASK = UINT32_C(0x00080000);           /** @brief Status match interrupt enable this bit enables the status match interrupt. */
    static const uint32_t QUADSPI_CR_TOIE_MASK = UINT32_C(0x00100000);           /** @brief TimeOut interrupt enable this bit enables the timeout interrupt. */
    static const uint32_t QUADSPI_CR_APMS_MASK = UINT32_C(0x00400000);           /** @brief Automatic poll mode stop this bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_PMM_MASK = UINT32_C(0x00800000);            /** @brief Polling match mode this bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_CR_PRESCALER_MASK = UINT32_C(0xFF000000);      /** @brief Clock prescaler */
    static const uint32_t QUADSPI_DCR_CKMODE_MASK = UINT32_C(0x00000001);        /** @brief Indicates the level that clk takes between command */
    static const uint32_t QUADSPI_DCR_CSHT_MASK = UINT32_C(0x00000700);          /** @brief Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (ncs) must remain high between commands issued to the flash memory. ... This field can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_DCR_FSIZE_MASK = UINT32_C(0x001F0000);         /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_SR_TEF_MASK = UINT32_C(0x00000001);            /** @brief Transfer error flag this bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF. */
    static const uint32_t QUADSPI_SR_TCF_MASK = UINT32_C(0x00000002);            /** @brief Transfer complete flag this bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.it is cleared by writing 1 to CTCF. */
    static const uint32_t QUADSPI_SR_FTF_MASK = UINT32_C(0x00000004);            /** @brief FIFO threshold flag in indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read. */
    static const uint32_t QUADSPI_SR_SMF_MASK = UINT32_C(0x00000008);            /** @brief Status match flag this bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF. */
    static const uint32_t QUADSPI_SR_TOF_MASK = UINT32_C(0x00000010);            /** @brief Timeout flag this bit is set when timeout occurs. It is cleared by writing 1 to CTOF. */
    static const uint32_t QUADSPI_SR_BUSY_MASK = UINT32_C(0x00000020);           /** @brief Busy this bit is set when an operation is on going. This bit clears automatically when the operation with the flash memory is finished and the FIFO is empty. */
    static const uint32_t QUADSPI_SR_FLEVEL_MASK = UINT32_C(0x00003F00);         /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
    static const uint32_t QUADSPI_FCR_CTEF_MASK = UINT32_C(0x00000001);          /** @brief Clear transfer error flag writing 1 clears the TEF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_FCR_CTCF_MASK = UINT32_C(0x00000002);          /** @brief Clear transfer complete flag writing 1 clears the TCF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_FCR_CSMF_MASK = UINT32_C(0x00000008);          /** @brief Clear status match flag writing 1 clears the SMF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_FCR_CTOF_MASK = UINT32_C(0x00000010);          /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_CCR_INSTRUCTION_MASK = UINT32_C(0x000000FF);   /** @brief Instruction instruction to be send to the external SPI device. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_IMODE_MASK = UINT32_C(0x00000300);         /** @brief Instruction mode this field defines the instruction phase mode of operation: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ADMODE_MASK = UINT32_C(0x00000C00);        /** @brief Address mode this field defines the address phase mode of operation: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ADSIZE_MASK = UINT32_C(0x00003000);        /** @brief Address size this bit defines address size: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ABMODE_MASK = UINT32_C(0x0000C000);        /** @brief Alternate bytes mode this field defines the alternate-bytes phase mode of operation: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_ABSIZE_MASK = UINT32_C(0x00030000);        /** @brief Alternate bytes size this bit defines alternate bytes size: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DCYC_MASK = UINT32_C(0x007C0000);          /** @brief Number of dummy cycles this field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DMODE_MASK = UINT32_C(0x03000000);         /** @brief Data mode this field defines the data phases mode of operation: this field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_FMODE_MASK = UINT32_C(0x0C000000);         /** @brief Functional mode this field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_SIOO_MASK = UINT32_C(0x10000000);          /** @brief Send instruction only once mode see section15.3.11: sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DHHC_MASK = UINT32_C(0x40000000);          /** @brief DDR hold delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: this feature is only active in DDR mode. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DDRM_MASK = UINT32_C(0x80000000);          /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_PIR_INTERVAL_MASK = UINT32_C(0x0000FFFF);      /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_LPTR_TIMEOUT_MASK = UINT32_C(0x0000FFFF);      /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

    /** @subsection QUADSPI field position definitions */

    static const int32_t QUADSPI_LPTR_EN_POS = INT32_C(0);             /** @brief Enable enable the QUADSPI. */
    static const int32_t QUADSPI_LPTR_ABORT_POS = INT32_C(1);          /** @brief Abort request this bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit. */
    static const int32_t QUADSPI_LPTR_DMAEN_POS = INT32_C(2);          /** @brief DMA enable in indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set. */
    static const int32_t QUADSPI_LPTR_TCEN_POS = INT32_C(3);           /** @brief Timeout counter enable this bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (ncs) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with ncs maintained low, even if no access to the flash memory occurs for a long time. Since flash memories tend to consume more when ncs is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that ncs is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_SSHIFT_POS = INT32_C(4);         /** @brief Sample shift by default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_DFM_POS = INT32_C(6);            /** @brief Dual-flash mode this bit activates dual-flash mode, where two external flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_FSEL_POS = INT32_C(7);           /** @brief Flash memory selection this bit selects the flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1. */
    static const int32_t QUADSPI_LPTR_FTHRES_POS = INT32_C(8);         /** @brief FIFO threshold level defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. */
    static const int32_t QUADSPI_LPTR_TEIE_POS = INT32_C(16);          /** @brief Transfer error interrupt enable this bit enables the transfer error interrupt. */
    static const int32_t QUADSPI_LPTR_TCIE_POS = INT32_C(17);          /** @brief Transfer complete interrupt enable this bit enables the transfer complete interrupt. */
    static const int32_t QUADSPI_LPTR_FTIE_POS = INT32_C(18);          /** @brief FIFO threshold interrupt enable this bit enables the FIFO threshold interrupt. */
    static const int32_t QUADSPI_LPTR_SMIE_POS = INT32_C(19);          /** @brief Status match interrupt enable this bit enables the status match interrupt. */
    static const int32_t QUADSPI_LPTR_TOIE_POS = INT32_C(20);          /** @brief TimeOut interrupt enable this bit enables the timeout interrupt. */
    static const int32_t QUADSPI_LPTR_APMS_POS = INT32_C(22);          /** @brief Automatic poll mode stop this bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_PMM_POS = INT32_C(23);           /** @brief Polling match mode this bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_PRESCALER_POS = INT32_C(24);     /** @brief Clock prescaler */
    static const int32_t QUADSPI_LPTR_CKMODE_POS = INT32_C(0);         /** @brief Indicates the level that clk takes between command */
    static const int32_t QUADSPI_LPTR_CSHT_POS = INT32_C(8);           /** @brief Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (ncs) must remain high between commands issued to the flash memory. ... This field can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_FSIZE_POS = INT32_C(16);         /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_TEF_POS = INT32_C(0);            /** @brief Transfer error flag this bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF. */
    static const int32_t QUADSPI_LPTR_TCF_POS = INT32_C(1);            /** @brief Transfer complete flag this bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.it is cleared by writing 1 to CTCF. */
    static const int32_t QUADSPI_LPTR_FTF_POS = INT32_C(2);            /** @brief FIFO threshold flag in indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read. */
    static const int32_t QUADSPI_LPTR_SMF_POS = INT32_C(3);            /** @brief Status match flag this bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF. */
    static const int32_t QUADSPI_LPTR_TOF_POS = INT32_C(4);            /** @brief Timeout flag this bit is set when timeout occurs. It is cleared by writing 1 to CTOF. */
    static const int32_t QUADSPI_LPTR_BUSY_POS = INT32_C(5);           /** @brief Busy this bit is set when an operation is on going. This bit clears automatically when the operation with the flash memory is finished and the FIFO is empty. */
    static const int32_t QUADSPI_LPTR_FLEVEL_POS = INT32_C(8);         /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
    static const int32_t QUADSPI_LPTR_CTEF_POS = INT32_C(0);           /** @brief Clear transfer error flag writing 1 clears the TEF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_LPTR_CTCF_POS = INT32_C(1);           /** @brief Clear transfer complete flag writing 1 clears the TCF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_LPTR_CSMF_POS = INT32_C(3);           /** @brief Clear status match flag writing 1 clears the SMF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_LPTR_CTOF_POS = INT32_C(4);           /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register */
    static const int32_t QUADSPI_LPTR_INSTRUCTION_POS = INT32_C(0);    /** @brief Instruction instruction to be send to the external SPI device. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_IMODE_POS = INT32_C(8);          /** @brief Instruction mode this field defines the instruction phase mode of operation: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_ADMODE_POS = INT32_C(10);        /** @brief Address mode this field defines the address phase mode of operation: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_ADSIZE_POS = INT32_C(12);        /** @brief Address size this bit defines address size: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_ABMODE_POS = INT32_C(14);        /** @brief Alternate bytes mode this field defines the alternate-bytes phase mode of operation: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_ABSIZE_POS = INT32_C(16);        /** @brief Alternate bytes size this bit defines alternate bytes size: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_DCYC_POS = INT32_C(18);          /** @brief Number of dummy cycles this field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_DMODE_POS = INT32_C(24);         /** @brief Data mode this field defines the data phases mode of operation: this field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_FMODE_POS = INT32_C(26);         /** @brief Functional mode this field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_SIOO_POS = INT32_C(28);          /** @brief Send instruction only once mode see section15.3.11: sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_DHHC_POS = INT32_C(30);          /** @brief DDR hold delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: this feature is only active in DDR mode. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_DDRM_POS = INT32_C(31);          /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_INTERVAL_POS = INT32_C(0);       /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
    static const int32_t QUADSPI_LPTR_TIMEOUT_POS = INT32_C(0);        /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

    /**********************************************************************************************
     * @section RNG Definitions
     **********************************************************************************************/

    /** @subsection RNG register definitions */

    static _RW uint32_t* const RNG_CR_REG = (_RW uint32_t* const)UINT32_C(0x48021800);   /** @brief RNG control register */
    static _RW uint32_t* const RNG_SR_REG = (_RW uint32_t* const)UINT32_C(0x48021804);   /** @brief RNG status register */
    static _RO uint32_t* const RNG_DR_REG = (_RO uint32_t* const)UINT32_C(0x48021808);   /** @brief The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0. */

    /** @subsection RNG field mask definitions */

    static const uint32_t RNG_CR_RNGEN_MASK = UINT32_C(0x00000004);   /** @brief Random number generator enable */
    static const uint32_t RNG_CR_IE_MASK = UINT32_C(0x00000008);      /** @brief Interrupt enable */
    static const uint32_t RNG_CR_CED_MASK = UINT32_C(0x00000020);     /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
    static const uint32_t RNG_SR_DRDY_MASK = UINT32_C(0x00000001);    /** @brief Data ready note: if IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated. */
    static const uint32_t RNG_SR_CECS_MASK = UINT32_C(0x00000002);    /** @brief Clock error current status note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const uint32_t RNG_SR_SECS_MASK = UINT32_C(0x00000004);    /** @brief Seed error current status ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) */
    static const uint32_t RNG_SR_CEIS_MASK = UINT32_C(0x00000020);    /** @brief Clock error interrupt status this bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const uint32_t RNG_SR_SEIS_MASK = UINT32_C(0x00000040);    /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */

    /** @subsection RNG field position definitions */

    static const int32_t RNG_DR_RNGEN_POS = INT32_C(2);   /** @brief Random number generator enable */
    static const int32_t RNG_DR_IE_POS = INT32_C(3);      /** @brief Interrupt enable */
    static const int32_t RNG_DR_CED_POS = INT32_C(5);     /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
    static const int32_t RNG_DR_DRDY_POS = INT32_C(0);    /** @brief Data ready note: if IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated. */
    static const int32_t RNG_DR_CECS_POS = INT32_C(1);    /** @brief Clock error current status note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const int32_t RNG_DR_SECS_POS = INT32_C(2);    /** @brief Seed error current status ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) */
    static const int32_t RNG_DR_CEIS_POS = INT32_C(5);    /** @brief Clock error interrupt status this bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
    static const int32_t RNG_DR_SEIS_POS = INT32_C(6);    /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */

    /**********************************************************************************************
     * @section RTC Definitions
     **********************************************************************************************/

    /** @subsection RTC IRQ interrupt definitions */

    static const int32_t RTC_TAMP_STAMP_CSS_LSE_IRQ = INT32_C(2);    /** @brief RTC tamper, timestamp */
    static const int32_t RTC_WKUP_IRQ = INT32_C(3);                  /** @brief RTC wakeup interrupt */
    static const int32_t RTC_ALARM_IRQ = INT32_C(41);                /** @brief RTC alarms (A and B) */

    /** @subsection RTC register array definitions */

    static _RW uint32_t* const RTC_BKPXR_REG[32] = {
      (_RW uint32_t* const)UINT32_C(0x58004050),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004054),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004058),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x5800405C),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004060),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004064),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004068),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x5800406C),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004070),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004074),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004078),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x5800407C),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004080),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004084),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004088),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x5800408C),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004090),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004094),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x58004098),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x5800409C),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040A0),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040A4),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040A8),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040AC),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040B0),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040B4),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040B8),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040BC),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040C0),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040C4),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040C8),   /** @brief RTC backup registers */
      (_RW uint32_t* const)UINT32_C(0x580040CC),   /** @brief RTC backup registers */
    };

    /** @subsection RTC register definitions */

    static _RW uint32_t* const RTC_TR_REG = (_RW uint32_t* const)UINT32_C(0x58004000);         /** @brief The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_DR_REG = (_RW uint32_t* const)UINT32_C(0x58004004);         /** @brief The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_CR_REG = (_RW uint32_t* const)UINT32_C(0x58004008);         /** @brief RTC control register */
    static _RW uint32_t* const RTC_ISR_REG = (_RW uint32_t* const)UINT32_C(0x5800400C);        /** @brief This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_PRER_REG = (_RW uint32_t* const)UINT32_C(0x58004010);       /** @brief This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to calendar initialization and configuration on page9.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_WUTR_REG = (_RW uint32_t* const)UINT32_C(0x58004014);       /** @brief This register can be written only when WUTWF is set to 1 in rtc_isr.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_ALRMAR_REG = (_RW uint32_t* const)UINT32_C(0x5800401C);     /** @brief This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_ALRMBR_REG = (_RW uint32_t* const)UINT32_C(0x58004020);     /** @brief This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_WPR_REG = (_RW uint32_t* const)UINT32_C(0x58004024);        /** @brief RTC write protection register */
    static _RO uint32_t* const RTC_SSR_REG = (_RO uint32_t* const)UINT32_C(0x58004028);        /** @brief RTC sub second register */
    static _RW uint32_t* const RTC_SHIFTR_REG = (_RW uint32_t* const)UINT32_C(0x5800402C);     /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RO uint32_t* const RTC_TSTR_REG = (_RO uint32_t* const)UINT32_C(0x58004030);       /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static _RO uint32_t* const RTC_TSDR_REG = (_RO uint32_t* const)UINT32_C(0x58004034);       /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static _RO uint32_t* const RTC_TSSSR_REG = (_RO uint32_t* const)UINT32_C(0x58004038);      /** @brief The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset. */
    static _RW uint32_t* const RTC_CALR_REG = (_RW uint32_t* const)UINT32_C(0x5800403C);       /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static _RW uint32_t* const RTC_TAMPCR_REG = (_RW uint32_t* const)UINT32_C(0x58004040);     /** @brief RTC tamper and alternate function configuration register */
    static _RW uint32_t* const RTC_ALRMASSR_REG = (_RW uint32_t* const)UINT32_C(0x58004044);   /** @brief This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9 */
    static _RW uint32_t* const RTC_ALRMBSSR_REG = (_RW uint32_t* const)UINT32_C(0x58004048);   /** @brief This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.this register is write protected.the write access procedure is described in section: RTC register write protection. */
    static _RW uint32_t* const RTC_OR_REG = (_RW uint32_t* const)UINT32_C(0x5800404C);         /** @brief RTC option register */

    /** @subsection RTC field mask array definitions */

    static const uint32_t RTC_ISR_TAMPXF_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00002000),   /** @brief RTC_TAMP1 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0 */
      UINT32_C(0x00004000),   /** @brief RTC_TAMP2 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0 */
      UINT32_C(0x00008000),   /** @brief RTC_TAMP3 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0 */
    };

    static const uint32_t RTC_ALRMAR_MSKX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000080),   /** @brief Alarm A seconds mask */
      UINT32_C(0x00008000),   /** @brief Alarm A minutes mask */
      UINT32_C(0x00800000),   /** @brief Alarm A hours mask */
      UINT32_C(0x80000000),   /** @brief Alarm A date mask */
    };

    static const uint32_t RTC_TAMPCR_TAMPXE_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief RTC_TAMP1 input detection enable */
      UINT32_C(0x00000008),   /** @brief RTC_TAMP2 input detection enable */
      UINT32_C(0x00000020),   /** @brief RTC_TAMP3 detection enable */
    };

    static const uint32_t RTC_TAMPCR_TAMPXTRG_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief Active level for RTC_TAMP1 input if TAMPFLT != 00 if TAMPFLT = 00: */
      UINT32_C(0x00000010),   /** @brief Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00: */
      UINT32_C(0x00000040),   /** @brief Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00: */
    };

    static const uint32_t RTC_TAMPCR_TAMPXIE_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief Tamper 1 interrupt enable */
      UINT32_C(0x00080000),   /** @brief Tamper 2 interrupt enable */
      UINT32_C(0x00400000),   /** @brief Tamper 3 interrupt enable */
    };

    static const uint32_t RTC_TAMPCR_TAMPXNOERASE_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00020000),   /** @brief Tamper 1 no erase */
      UINT32_C(0x00100000),   /** @brief Tamper 2 no erase */
      UINT32_C(0x00800000),   /** @brief Tamper 3 no erase */
    };

    static const uint32_t RTC_TAMPCR_TAMPXMF_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00040000),   /** @brief Tamper 1 mask flag */
      UINT32_C(0x00200000),   /** @brief Tamper 2 mask flag */
      UINT32_C(0x01000000),   /** @brief Tamper 3 mask flag */
    };

    /** @subsection RTC field mask definitions */

    static const uint32_t RTC_TR_SU_MASK = UINT32_C(0x0000000F);               /** @brief Second units in BCD format */
    static const uint32_t RTC_TR_ST_MASK = UINT32_C(0x00000070);               /** @brief Second tens in BCD format */
    static const uint32_t RTC_TR_MNU_MASK = UINT32_C(0x00000F00);              /** @brief Minute units in BCD format */
    static const uint32_t RTC_TR_MNT_MASK = UINT32_C(0x00007000);              /** @brief Minute tens in BCD format */
    static const uint32_t RTC_TR_HU_MASK = UINT32_C(0x000F0000);               /** @brief Hour units in BCD format */
    static const uint32_t RTC_TR_HT_MASK = UINT32_C(0x00300000);               /** @brief Hour tens in BCD format */
    static const uint32_t RTC_TR_PM_MASK = UINT32_C(0x00400000);               /** @brief AM/PM notation */
    static const uint32_t RTC_DR_DU_MASK = UINT32_C(0x0000000F);               /** @brief Date units in BCD format */
    static const uint32_t RTC_DR_DT_MASK = UINT32_C(0x00000030);               /** @brief Date tens in BCD format */
    static const uint32_t RTC_DR_MU_MASK = UINT32_C(0x00000F00);               /** @brief Month units in BCD format */
    static const uint32_t RTC_DR_MT_MASK = UINT32_C(0x00001000);               /** @brief Month tens in BCD format */
    static const uint32_t RTC_DR_WDU_MASK = UINT32_C(0x0000E000);              /** @brief Week day units */
    static const uint32_t RTC_DR_YU_MASK = UINT32_C(0x000F0000);               /** @brief Year units in BCD format */
    static const uint32_t RTC_DR_YT_MASK = UINT32_C(0x00F00000);               /** @brief Year tens in BCD format */
    static const uint32_t RTC_CR_WUCKSEL_MASK = UINT32_C(0x00000007);          /** @brief Wakeup clock selection */
    static const uint32_t RTC_CR_TSEDGE_MASK = UINT32_C(0x00000008);           /** @brief Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting. */
    static const uint32_t RTC_CR_REFCKON_MASK = UINT32_C(0x00000010);          /** @brief RTC_REFIN reference clock detection enable (50 or 60hz) note: PREDIV_S must be 0x00ff. */
    static const uint32_t RTC_CR_BYPSHAD_MASK = UINT32_C(0x00000020);          /** @brief Bypass the shadow registers note: if the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1. */
    static const uint32_t RTC_CR_FMT_MASK = UINT32_C(0x00000040);              /** @brief Hour format */
    static const uint32_t RTC_CR_ALRAE_MASK = UINT32_C(0x00000100);            /** @brief Alarm A enable */
    static const uint32_t RTC_CR_ALRBE_MASK = UINT32_C(0x00000200);            /** @brief Alarm B enable */
    static const uint32_t RTC_CR_WUTE_MASK = UINT32_C(0x00000400);             /** @brief Wakeup timer enable */
    static const uint32_t RTC_CR_TSE_MASK = UINT32_C(0x00000800);              /** @brief Timestamp enable */
    static const uint32_t RTC_CR_ALRAIE_MASK = UINT32_C(0x00001000);           /** @brief Alarm A interrupt enable */
    static const uint32_t RTC_CR_ALRBIE_MASK = UINT32_C(0x00002000);           /** @brief Alarm B interrupt enable */
    static const uint32_t RTC_CR_WUTIE_MASK = UINT32_C(0x00004000);            /** @brief Wakeup timer interrupt enable */
    static const uint32_t RTC_CR_TSIE_MASK = UINT32_C(0x00008000);             /** @brief Time-stamp interrupt enable */
    static const uint32_t RTC_CR_ADD1H_MASK = UINT32_C(0x00010000);            /** @brief Add 1 hour (summer time change) when this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0. */
    static const uint32_t RTC_CR_SUB1H_MASK = UINT32_C(0x00020000);            /** @brief Subtract 1 hour (winter time change) when this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0. */
    static const uint32_t RTC_CR_BKP_MASK = UINT32_C(0x00040000);              /** @brief Backup this bit can be written by the user to memorize whether the daylight saving time change has been performed or not. */
    static const uint32_t RTC_CR_COSEL_MASK = UINT32_C(0x00080000);            /** @brief Calibration output selection when COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 khz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to section24.3.15: calibration clock output */
    static const uint32_t RTC_CR_POL_MASK = UINT32_C(0x00100000);              /** @brief Output polarity this bit is used to configure the polarity of RTC_ALARM output */
    static const uint32_t RTC_CR_OSEL_MASK = UINT32_C(0x00600000);             /** @brief Output selection these bits are used to select the flag to be routed to RTC_ALARM output */
    static const uint32_t RTC_CR_COE_MASK = UINT32_C(0x00800000);              /** @brief Calibration output enable this bit enables the RTC_CALIB output */
    static const uint32_t RTC_CR_ITSE_MASK = UINT32_C(0x01000000);             /** @brief Timestamp on internal event enable */
    static const uint32_t RTC_ISR_ALRAWF_MASK = UINT32_C(0x00000001);          /** @brief Alarm A write flag this bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const uint32_t RTC_ISR_ALRBWF_MASK = UINT32_C(0x00000002);          /** @brief Alarm B write flag this bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const uint32_t RTC_ISR_WUTWF_MASK = UINT32_C(0x00000004);           /** @brief Wakeup timer write flag this bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set. */
    static const uint32_t RTC_ISR_SHPF_MASK = UINT32_C(0x00000008);            /** @brief Shift operation pending this flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect. */
    static const uint32_t RTC_ISR_INITS_MASK = UINT32_C(0x00000010);           /** @brief Initialization status flag this bit is set by hardware when the calendar year field is different from 0 (backup domain reset state). */
    static const uint32_t RTC_ISR_RSF_MASK = UINT32_C(0x00000020);             /** @brief Registers synchronization flag this bit is set by hardware each time the calendar registers are copied into the shadow registers (rtc_ssrx, rtc_trx and rtc_drx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode. */
    static const uint32_t RTC_ISR_INITF_MASK = UINT32_C(0x00000040);           /** @brief Initialization flag when this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated. */
    static const uint32_t RTC_ISR_INIT_MASK = UINT32_C(0x00000080);            /** @brief Initialization mode */
    static const uint32_t RTC_ISR_ALRAF_MASK = UINT32_C(0x00000100);           /** @brief Alarm A flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0. */
    static const uint32_t RTC_ISR_ALRBF_MASK = UINT32_C(0x00000200);           /** @brief Alarm B flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0. */
    static const uint32_t RTC_ISR_WUTF_MASK = UINT32_C(0x00000400);            /** @brief Wakeup timer flag this flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again. */
    static const uint32_t RTC_ISR_TSF_MASK = UINT32_C(0x00000800);             /** @brief Time-stamp flag this flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0. */
    static const uint32_t RTC_ISR_TSOVF_MASK = UINT32_C(0x00001000);           /** @brief Time-stamp overflow flag this flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared. */
    static const uint32_t RTC_ISR_RECALPF_MASK = UINT32_C(0x00010000);         /** @brief Recalibration pending flag the RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to re-calibration on-the-fly. */
    static const uint32_t RTC_ISR_ITSF_MASK = UINT32_C(0x00020000);            /** @brief Internal ttime-stamp flag */
    static const uint32_t RTC_PRER_PREDIV_S_MASK = UINT32_C(0x00007FFF);       /** @brief Synchronous prescaler factor this is the synchronous division factor: ck_spre frequency = ck_apre frequency/(prediv_s+1) */
    static const uint32_t RTC_PRER_PREDIV_A_MASK = UINT32_C(0x007F0000);       /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1) */
    static const uint32_t RTC_WUTR_WUT_MASK = UINT32_C(0x0000FFFF);            /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
    static const uint32_t RTC_ALRMAR_SU_MASK = UINT32_C(0x0000000F);           /** @brief Second units in BCD format. */
    static const uint32_t RTC_ALRMAR_ST_MASK = UINT32_C(0x00000070);           /** @brief Second tens in BCD format. */
    static const uint32_t RTC_ALRMAR_MNU_MASK = UINT32_C(0x00000F00);          /** @brief Minute units in BCD format. */
    static const uint32_t RTC_ALRMAR_MNT_MASK = UINT32_C(0x00007000);          /** @brief Minute tens in BCD format. */
    static const uint32_t RTC_ALRMAR_HU_MASK = UINT32_C(0x000F0000);           /** @brief Hour units in BCD format. */
    static const uint32_t RTC_ALRMAR_HT_MASK = UINT32_C(0x00300000);           /** @brief Hour tens in BCD format. */
    static const uint32_t RTC_ALRMAR_PM_MASK = UINT32_C(0x00400000);           /** @brief AM/PM notation */
    static const uint32_t RTC_ALRMAR_DU_MASK = UINT32_C(0x0F000000);           /** @brief Date units or day in BCD format. */
    static const uint32_t RTC_ALRMAR_DT_MASK = UINT32_C(0x30000000);           /** @brief Date tens in BCD format. */
    static const uint32_t RTC_ALRMAR_WDSEL_MASK = UINT32_C(0x40000000);        /** @brief Week day selection */
    static const uint32_t RTC_ALRMBR_SU_MASK = UINT32_C(0x0000000F);           /** @brief Second units in BCD format */
    static const uint32_t RTC_ALRMBR_ST_MASK = UINT32_C(0x00000070);           /** @brief Second tens in BCD format */
    static const uint32_t RTC_ALRMBR_MNU_MASK = UINT32_C(0x00000F00);          /** @brief Minute units in BCD format */
    static const uint32_t RTC_ALRMBR_MNT_MASK = UINT32_C(0x00007000);          /** @brief Minute tens in BCD format */
    static const uint32_t RTC_ALRMBR_HU_MASK = UINT32_C(0x000F0000);           /** @brief Hour units in BCD format */
    static const uint32_t RTC_ALRMBR_HT_MASK = UINT32_C(0x00300000);           /** @brief Hour tens in BCD format */
    static const uint32_t RTC_ALRMBR_PM_MASK = UINT32_C(0x00400000);           /** @brief AM/PM notation */
    static const uint32_t RTC_ALRMBR_DU_MASK = UINT32_C(0x0F000000);           /** @brief Date units or day in BCD format */
    static const uint32_t RTC_ALRMBR_DT_MASK = UINT32_C(0x30000000);           /** @brief Date tens in BCD format */
    static const uint32_t RTC_ALRMBR_WDSEL_MASK = UINT32_C(0x40000000);        /** @brief Week day selection */
    static const uint32_t RTC_WPR_KEY_MASK = UINT32_C(0x000000FF);             /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
    static const uint32_t RTC_SSR_SS_MASK = UINT32_C(0x0000FFFF);              /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
    static const uint32_t RTC_SHIFTR_SUBFS_MASK = UINT32_C(0x00007FFF);        /** @brief Subtract a fraction of a second these bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. */
    static const uint32_t RTC_SHIFTR_ADD1S_MASK = UINT32_C(0x80000000);        /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
    static const uint32_t RTC_TSTR_SU_MASK = UINT32_C(0x0000000F);             /** @brief Second units in BCD format. */
    static const uint32_t RTC_TSTR_ST_MASK = UINT32_C(0x00000070);             /** @brief Second tens in BCD format. */
    static const uint32_t RTC_TSTR_MNU_MASK = UINT32_C(0x00000F00);            /** @brief Minute units in BCD format. */
    static const uint32_t RTC_TSTR_MNT_MASK = UINT32_C(0x00007000);            /** @brief Minute tens in BCD format. */
    static const uint32_t RTC_TSTR_HU_MASK = UINT32_C(0x000F0000);             /** @brief Hour units in BCD format. */
    static const uint32_t RTC_TSTR_HT_MASK = UINT32_C(0x00300000);             /** @brief Hour tens in BCD format. */
    static const uint32_t RTC_TSTR_PM_MASK = UINT32_C(0x00400000);             /** @brief AM/PM notation */
    static const uint32_t RTC_TSDR_DU_MASK = UINT32_C(0x0000000F);             /** @brief Date units in BCD format */
    static const uint32_t RTC_TSDR_DT_MASK = UINT32_C(0x00000030);             /** @brief Date tens in BCD format */
    static const uint32_t RTC_TSDR_MU_MASK = UINT32_C(0x00000F00);             /** @brief Month units in BCD format */
    static const uint32_t RTC_TSDR_MT_MASK = UINT32_C(0x00001000);             /** @brief Month tens in BCD format */
    static const uint32_t RTC_TSDR_WDU_MASK = UINT32_C(0x0000E000);            /** @brief Week day units */
    static const uint32_t RTC_TSSSR_SS_MASK = UINT32_C(0x0000FFFF);            /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
    static const uint32_t RTC_CALR_CALM_MASK = UINT32_C(0x000001FF);           /** @brief Calibration minus the frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See section24.3.12: RTC smooth digital calibration on page13. */
    static const uint32_t RTC_CALR_CALW16_MASK = UINT32_C(0x00002000);         /** @brief Use a 16-second calibration cycle period when CALW16 is set to 1, the 16-second calibration cycle period is selected.this bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    static const uint32_t RTC_CALR_CALW8_MASK = UINT32_C(0x00004000);          /** @brief Use an 8-second calibration cycle period when CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    static const uint32_t RTC_CALR_CALP_MASK = UINT32_C(0x00008000);           /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
    static const uint32_t RTC_TAMPCR_TAMPIE_MASK = UINT32_C(0x00000004);       /** @brief Tamper interrupt enable */
    static const uint32_t RTC_TAMPCR_TAMPTS_MASK = UINT32_C(0x00000080);       /** @brief Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register. */
    static const uint32_t RTC_TAMPCR_TAMPFREQ_MASK = UINT32_C(0x00000700);     /** @brief Tamper sampling frequency determines the frequency at which each of the rtc_tampx inputs are sampled. */
    static const uint32_t RTC_TAMPCR_TAMPFLT_MASK = UINT32_C(0x00001800);      /** @brief RTC_TAMPx filter count these bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the rtc_tampx inputs. */
    static const uint32_t RTC_TAMPCR_TAMPPRCH_MASK = UINT32_C(0x00006000);     /** @brief RTC_TAMPx precharge duration these bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the rtc_tampx inputs. */
    static const uint32_t RTC_TAMPCR_TAMPPUDIS_MASK = UINT32_C(0x00008000);    /** @brief RTC_TAMPx pull-up disable this bit determines if each of the rtc_tampx pins are pre-charged before each sample. */
    static const uint32_t RTC_ALRMASSR_SS_MASK = UINT32_C(0x00007FFF);         /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. */
    static const uint32_t RTC_ALRMASSR_MASKSS_MASK = UINT32_C(0x0F000000);     /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const uint32_t RTC_ALRMBSSR_SS_MASK = UINT32_C(0x00007FFF);         /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. */
    static const uint32_t RTC_ALRMBSSR_MASKSS_MASK = UINT32_C(0x0F000000);     /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const uint32_t RTC_OR_RTC_ALARM_TYPE_MASK = UINT32_C(0x00000001);   /** @brief RTC_ALARM output type on PC13 */
    static const uint32_t RTC_OR_RTC_OUT_RMP_MASK = UINT32_C(0x00000002);      /** @brief RTC_OUT remap */

    /** @subsection RTC field position array definitions */

    static const int32_t RTC_BKPXR_TAMPXF_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(13),   /** @brief RTC_TAMP1 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0 */
      INT32_C(14),   /** @brief RTC_TAMP2 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0 */
      INT32_C(15),   /** @brief RTC_TAMP3 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0 */
    };

    static const int32_t RTC_BKPXR_MSKX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(7),    /** @brief Alarm A seconds mask */
      INT32_C(15),   /** @brief Alarm A minutes mask */
      INT32_C(23),   /** @brief Alarm A hours mask */
      INT32_C(31),   /** @brief Alarm A date mask */
    };

    static const int32_t RTC_BKPXR_TAMPXE_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief RTC_TAMP1 input detection enable */
      INT32_C(3),    /** @brief RTC_TAMP2 input detection enable */
      INT32_C(5),    /** @brief RTC_TAMP3 detection enable */
    };

    static const int32_t RTC_BKPXR_TAMPXTRG_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief Active level for RTC_TAMP1 input if TAMPFLT != 00 if TAMPFLT = 00: */
      INT32_C(4),    /** @brief Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00: */
      INT32_C(6),    /** @brief Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00: */
    };

    static const int32_t RTC_BKPXR_TAMPXIE_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief Tamper 1 interrupt enable */
      INT32_C(19),   /** @brief Tamper 2 interrupt enable */
      INT32_C(22),   /** @brief Tamper 3 interrupt enable */
    };

    static const int32_t RTC_BKPXR_TAMPXNOERASE_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(17),   /** @brief Tamper 1 no erase */
      INT32_C(20),   /** @brief Tamper 2 no erase */
      INT32_C(23),   /** @brief Tamper 3 no erase */
    };

    static const int32_t RTC_BKPXR_TAMPXMF_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(18),   /** @brief Tamper 1 mask flag */
      INT32_C(21),   /** @brief Tamper 2 mask flag */
      INT32_C(24),   /** @brief Tamper 3 mask flag */
    };

    /** @subsection RTC field position definitions */

    static const int32_t RTC_BKPXR_SU_POS = INT32_C(0);                /** @brief Second units in BCD format */
    static const int32_t RTC_BKPXR_ST_POS = INT32_C(4);                /** @brief Second tens in BCD format */
    static const int32_t RTC_BKPXR_MNU_POS = INT32_C(8);               /** @brief Minute units in BCD format */
    static const int32_t RTC_BKPXR_MNT_POS = INT32_C(12);              /** @brief Minute tens in BCD format */
    static const int32_t RTC_BKPXR_HU_POS = INT32_C(16);               /** @brief Hour units in BCD format */
    static const int32_t RTC_BKPXR_HT_POS = INT32_C(20);               /** @brief Hour tens in BCD format */
    static const int32_t RTC_BKPXR_PM_POS = INT32_C(22);               /** @brief AM/PM notation */
    static const int32_t RTC_BKPXR_DU_POS = INT32_C(0);                /** @brief Date units in BCD format */
    static const int32_t RTC_BKPXR_DT_POS = INT32_C(4);                /** @brief Date tens in BCD format */
    static const int32_t RTC_BKPXR_MU_POS = INT32_C(8);                /** @brief Month units in BCD format */
    static const int32_t RTC_BKPXR_MT_POS = INT32_C(12);               /** @brief Month tens in BCD format */
    static const int32_t RTC_BKPXR_WDU_POS = INT32_C(13);              /** @brief Week day units */
    static const int32_t RTC_BKPXR_YU_POS = INT32_C(16);               /** @brief Year units in BCD format */
    static const int32_t RTC_BKPXR_YT_POS = INT32_C(20);               /** @brief Year tens in BCD format */
    static const int32_t RTC_BKPXR_WUCKSEL_POS = INT32_C(0);           /** @brief Wakeup clock selection */
    static const int32_t RTC_BKPXR_TSEDGE_POS = INT32_C(3);            /** @brief Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting. */
    static const int32_t RTC_BKPXR_REFCKON_POS = INT32_C(4);           /** @brief RTC_REFIN reference clock detection enable (50 or 60hz) note: PREDIV_S must be 0x00ff. */
    static const int32_t RTC_BKPXR_BYPSHAD_POS = INT32_C(5);           /** @brief Bypass the shadow registers note: if the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1. */
    static const int32_t RTC_BKPXR_FMT_POS = INT32_C(6);               /** @brief Hour format */
    static const int32_t RTC_BKPXR_ALRAE_POS = INT32_C(8);             /** @brief Alarm A enable */
    static const int32_t RTC_BKPXR_ALRBE_POS = INT32_C(9);             /** @brief Alarm B enable */
    static const int32_t RTC_BKPXR_WUTE_POS = INT32_C(10);             /** @brief Wakeup timer enable */
    static const int32_t RTC_BKPXR_TSE_POS = INT32_C(11);              /** @brief Timestamp enable */
    static const int32_t RTC_BKPXR_ALRAIE_POS = INT32_C(12);           /** @brief Alarm A interrupt enable */
    static const int32_t RTC_BKPXR_ALRBIE_POS = INT32_C(13);           /** @brief Alarm B interrupt enable */
    static const int32_t RTC_BKPXR_WUTIE_POS = INT32_C(14);            /** @brief Wakeup timer interrupt enable */
    static const int32_t RTC_BKPXR_TSIE_POS = INT32_C(15);             /** @brief Time-stamp interrupt enable */
    static const int32_t RTC_BKPXR_ADD1H_POS = INT32_C(16);            /** @brief Add 1 hour (summer time change) when this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0. */
    static const int32_t RTC_BKPXR_SUB1H_POS = INT32_C(17);            /** @brief Subtract 1 hour (winter time change) when this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0. */
    static const int32_t RTC_BKPXR_BKP_POS = INT32_C(18);              /** @brief Backup this bit can be written by the user to memorize whether the daylight saving time change has been performed or not. */
    static const int32_t RTC_BKPXR_COSEL_POS = INT32_C(19);            /** @brief Calibration output selection when COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 khz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to section24.3.15: calibration clock output */
    static const int32_t RTC_BKPXR_POL_POS = INT32_C(20);              /** @brief Output polarity this bit is used to configure the polarity of RTC_ALARM output */
    static const int32_t RTC_BKPXR_OSEL_POS = INT32_C(21);             /** @brief Output selection these bits are used to select the flag to be routed to RTC_ALARM output */
    static const int32_t RTC_BKPXR_COE_POS = INT32_C(23);              /** @brief Calibration output enable this bit enables the RTC_CALIB output */
    static const int32_t RTC_BKPXR_ITSE_POS = INT32_C(24);             /** @brief Timestamp on internal event enable */
    static const int32_t RTC_BKPXR_ALRAWF_POS = INT32_C(0);            /** @brief Alarm A write flag this bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const int32_t RTC_BKPXR_ALRBWF_POS = INT32_C(1);            /** @brief Alarm B write flag this bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
    static const int32_t RTC_BKPXR_WUTWF_POS = INT32_C(2);             /** @brief Wakeup timer write flag this bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set. */
    static const int32_t RTC_BKPXR_SHPF_POS = INT32_C(3);              /** @brief Shift operation pending this flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect. */
    static const int32_t RTC_BKPXR_INITS_POS = INT32_C(4);             /** @brief Initialization status flag this bit is set by hardware when the calendar year field is different from 0 (backup domain reset state). */
    static const int32_t RTC_BKPXR_RSF_POS = INT32_C(5);               /** @brief Registers synchronization flag this bit is set by hardware each time the calendar registers are copied into the shadow registers (rtc_ssrx, rtc_trx and rtc_drx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode. */
    static const int32_t RTC_BKPXR_INITF_POS = INT32_C(6);             /** @brief Initialization flag when this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated. */
    static const int32_t RTC_BKPXR_INIT_POS = INT32_C(7);              /** @brief Initialization mode */
    static const int32_t RTC_BKPXR_ALRAF_POS = INT32_C(8);             /** @brief Alarm A flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0. */
    static const int32_t RTC_BKPXR_ALRBF_POS = INT32_C(9);             /** @brief Alarm B flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0. */
    static const int32_t RTC_BKPXR_WUTF_POS = INT32_C(10);             /** @brief Wakeup timer flag this flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again. */
    static const int32_t RTC_BKPXR_TSF_POS = INT32_C(11);              /** @brief Time-stamp flag this flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0. */
    static const int32_t RTC_BKPXR_TSOVF_POS = INT32_C(12);            /** @brief Time-stamp overflow flag this flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared. */
    static const int32_t RTC_BKPXR_RECALPF_POS = INT32_C(16);          /** @brief Recalibration pending flag the RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to re-calibration on-the-fly. */
    static const int32_t RTC_BKPXR_ITSF_POS = INT32_C(17);             /** @brief Internal ttime-stamp flag */
    static const int32_t RTC_BKPXR_PREDIV_S_POS = INT32_C(0);          /** @brief Synchronous prescaler factor this is the synchronous division factor: ck_spre frequency = ck_apre frequency/(prediv_s+1) */
    static const int32_t RTC_BKPXR_PREDIV_A_POS = INT32_C(16);         /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1) */
    static const int32_t RTC_BKPXR_WUT_POS = INT32_C(0);               /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
    static const int32_t RTC_BKPXR_SU_POS = INT32_C(0);                /** @brief Second units in BCD format. */
    static const int32_t RTC_BKPXR_ST_POS = INT32_C(4);                /** @brief Second tens in BCD format. */
    static const int32_t RTC_BKPXR_MNU_POS = INT32_C(8);               /** @brief Minute units in BCD format. */
    static const int32_t RTC_BKPXR_MNT_POS = INT32_C(12);              /** @brief Minute tens in BCD format. */
    static const int32_t RTC_BKPXR_HU_POS = INT32_C(16);               /** @brief Hour units in BCD format. */
    static const int32_t RTC_BKPXR_HT_POS = INT32_C(20);               /** @brief Hour tens in BCD format. */
    static const int32_t RTC_BKPXR_PM_POS = INT32_C(22);               /** @brief AM/PM notation */
    static const int32_t RTC_BKPXR_DU_POS = INT32_C(24);               /** @brief Date units or day in BCD format. */
    static const int32_t RTC_BKPXR_DT_POS = INT32_C(28);               /** @brief Date tens in BCD format. */
    static const int32_t RTC_BKPXR_WDSEL_POS = INT32_C(30);            /** @brief Week day selection */
    static const int32_t RTC_BKPXR_SU_POS = INT32_C(0);                /** @brief Second units in BCD format */
    static const int32_t RTC_BKPXR_ST_POS = INT32_C(4);                /** @brief Second tens in BCD format */
    static const int32_t RTC_BKPXR_MNU_POS = INT32_C(8);               /** @brief Minute units in BCD format */
    static const int32_t RTC_BKPXR_MNT_POS = INT32_C(12);              /** @brief Minute tens in BCD format */
    static const int32_t RTC_BKPXR_HU_POS = INT32_C(16);               /** @brief Hour units in BCD format */
    static const int32_t RTC_BKPXR_HT_POS = INT32_C(20);               /** @brief Hour tens in BCD format */
    static const int32_t RTC_BKPXR_PM_POS = INT32_C(22);               /** @brief AM/PM notation */
    static const int32_t RTC_BKPXR_DU_POS = INT32_C(24);               /** @brief Date units or day in BCD format */
    static const int32_t RTC_BKPXR_DT_POS = INT32_C(28);               /** @brief Date tens in BCD format */
    static const int32_t RTC_BKPXR_WDSEL_POS = INT32_C(30);            /** @brief Week day selection */
    static const int32_t RTC_BKPXR_KEY_POS = INT32_C(0);               /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
    static const int32_t RTC_BKPXR_SS_POS = INT32_C(0);                /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
    static const int32_t RTC_BKPXR_SUBFS_POS = INT32_C(0);             /** @brief Subtract a fraction of a second these bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. */
    static const int32_t RTC_BKPXR_ADD1S_POS = INT32_C(31);            /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
    static const int32_t RTC_BKPXR_SU_POS = INT32_C(0);                /** @brief Second units in BCD format. */
    static const int32_t RTC_BKPXR_ST_POS = INT32_C(4);                /** @brief Second tens in BCD format. */
    static const int32_t RTC_BKPXR_MNU_POS = INT32_C(8);               /** @brief Minute units in BCD format. */
    static const int32_t RTC_BKPXR_MNT_POS = INT32_C(12);              /** @brief Minute tens in BCD format. */
    static const int32_t RTC_BKPXR_HU_POS = INT32_C(16);               /** @brief Hour units in BCD format. */
    static const int32_t RTC_BKPXR_HT_POS = INT32_C(20);               /** @brief Hour tens in BCD format. */
    static const int32_t RTC_BKPXR_PM_POS = INT32_C(22);               /** @brief AM/PM notation */
    static const int32_t RTC_BKPXR_DU_POS = INT32_C(0);                /** @brief Date units in BCD format */
    static const int32_t RTC_BKPXR_DT_POS = INT32_C(4);                /** @brief Date tens in BCD format */
    static const int32_t RTC_BKPXR_MU_POS = INT32_C(8);                /** @brief Month units in BCD format */
    static const int32_t RTC_BKPXR_MT_POS = INT32_C(12);               /** @brief Month tens in BCD format */
    static const int32_t RTC_BKPXR_WDU_POS = INT32_C(13);              /** @brief Week day units */
    static const int32_t RTC_BKPXR_SS_POS = INT32_C(0);                /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
    static const int32_t RTC_BKPXR_CALM_POS = INT32_C(0);              /** @brief Calibration minus the frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See section24.3.12: RTC smooth digital calibration on page13. */
    static const int32_t RTC_BKPXR_CALW16_POS = INT32_C(13);           /** @brief Use a 16-second calibration cycle period when CALW16 is set to 1, the 16-second calibration cycle period is selected.this bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    static const int32_t RTC_BKPXR_CALW8_POS = INT32_C(14);            /** @brief Use an 8-second calibration cycle period when CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    static const int32_t RTC_BKPXR_CALP_POS = INT32_C(15);             /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
    static const int32_t RTC_BKPXR_TAMPIE_POS = INT32_C(2);            /** @brief Tamper interrupt enable */
    static const int32_t RTC_BKPXR_TAMPTS_POS = INT32_C(7);            /** @brief Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register. */
    static const int32_t RTC_BKPXR_TAMPFREQ_POS = INT32_C(8);          /** @brief Tamper sampling frequency determines the frequency at which each of the rtc_tampx inputs are sampled. */
    static const int32_t RTC_BKPXR_TAMPFLT_POS = INT32_C(11);          /** @brief RTC_TAMPx filter count these bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the rtc_tampx inputs. */
    static const int32_t RTC_BKPXR_TAMPPRCH_POS = INT32_C(13);         /** @brief RTC_TAMPx precharge duration these bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the rtc_tampx inputs. */
    static const int32_t RTC_BKPXR_TAMPPUDIS_POS = INT32_C(15);        /** @brief RTC_TAMPx pull-up disable this bit determines if each of the rtc_tampx pins are pre-charged before each sample. */
    static const int32_t RTC_BKPXR_SS_POS = INT32_C(0);                /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. */
    static const int32_t RTC_BKPXR_MASKSS_POS = INT32_C(24);           /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const int32_t RTC_BKPXR_SS_POS = INT32_C(0);                /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. */
    static const int32_t RTC_BKPXR_MASKSS_POS = INT32_C(24);           /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const int32_t RTC_BKPXR_RTC_ALARM_TYPE_POS = INT32_C(0);    /** @brief RTC_ALARM output type on PC13 */
    static const int32_t RTC_BKPXR_RTC_OUT_RMP_POS = INT32_C(1);       /** @brief RTC_OUT remap */

    /**********************************************************************************************
     * @section SAIX Definitions
     **********************************************************************************************/

    /** @subsection SAIX IRQ interrupt array definitions */

    static const int32_t SAIX_IRQ[5] = {
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(87),     /** @brief SAI1 global interrupt */
      INT32_C(91),     /** @brief SAI2 global interrupt */
      INT32_C(114),    /** @brief SAI3 global interrupt */
      INT32_C(146),    /** @brief SAI4 global interrupt */
    };

    /** @subsection SAIX register array definitions */

    static _RW uint32_t* const SAIX_GCR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015800),   /** @brief Global configuration register */
      (_RW uint32_t* const)UINT32_C(0x40015C00),   /** @brief Global configuration register */
      (_RW uint32_t* const)UINT32_C(0x40016000),   /** @brief Global configuration register */
      (_RW uint32_t* const)UINT32_C(0x58005400),   /** @brief Global configuration register */
    };

    static _RW uint32_t* const SAIX_ACR1_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015804),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40015C04),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40016004),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x58005404),   /** @brief Configuration register 1 */
    };

    static _RW uint32_t* const SAIX_ACR2_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015808),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x40015C08),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x40016008),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58005408),   /** @brief Configuration register 2 */
    };

    static _RW uint32_t* const SAIX_AFRCR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001580C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x40015C0C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x4001600C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x5800540C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static _RW uint32_t* const SAIX_ASLOTR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015810),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x40015C10),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x40016010),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x58005410),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static _RW uint32_t* const SAIX_AIM_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015814),   /** @brief Interrupt mask register 2 */
      (_RW uint32_t* const)UINT32_C(0x40015C14),   /** @brief Interrupt mask register 2 */
      (_RW uint32_t* const)UINT32_C(0x40016014),   /** @brief Interrupt mask register 2 */
      (_RW uint32_t* const)UINT32_C(0x58005414),   /** @brief Interrupt mask register 2 */
    };

    static _RO uint32_t* const SAIX_ASR_REG[5] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40015818),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40015C18),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40016018),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x58005418),   /** @brief Status register */
    };

    static _RW uint32_t* const SAIX_ACLRFR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001581C),   /** @brief Clear flag register */
      (_RW uint32_t* const)UINT32_C(0x40015C1C),   /** @brief Clear flag register */
      (_RW uint32_t* const)UINT32_C(0x4001601C),   /** @brief Clear flag register */
      (_RW uint32_t* const)UINT32_C(0x5800541C),   /** @brief Clear flag register */
    };

    static _RW uint32_t* const SAIX_ADR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015820),   /** @brief Data register */
      (_RW uint32_t* const)UINT32_C(0x40015C20),   /** @brief Data register */
      (_RW uint32_t* const)UINT32_C(0x40016020),   /** @brief Data register */
      (_RW uint32_t* const)UINT32_C(0x58005420),   /** @brief Data register */
    };

    static _RW uint32_t* const SAIX_BCR1_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015824),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40015C24),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40016024),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x58005424),   /** @brief Configuration register 1 */
    };

    static _RW uint32_t* const SAIX_BCR2_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015828),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x40015C28),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x40016028),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58005428),   /** @brief Configuration register 2 */
    };

    static _RW uint32_t* const SAIX_BFRCR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001582C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x40015C2C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x4001602C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x5800542C),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static _RW uint32_t* const SAIX_BSLOTR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015830),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x40015C30),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x40016030),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      (_RW uint32_t* const)UINT32_C(0x58005430),   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static _RW uint32_t* const SAIX_BIM_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015834),   /** @brief Interrupt mask register 2 */
      (_RW uint32_t* const)UINT32_C(0x40015C34),   /** @brief Interrupt mask register 2 */
      (_RW uint32_t* const)UINT32_C(0x40016034),   /** @brief Interrupt mask register 2 */
      (_RW uint32_t* const)UINT32_C(0x58005434),   /** @brief Interrupt mask register 2 */
    };

    static _RO uint32_t* const SAIX_BSR_REG[5] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40015838),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40015C38),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40016038),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x58005438),   /** @brief Status register */
    };

    static _RW uint32_t* const SAIX_BCLRFR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001583C),   /** @brief Clear flag register */
      (_RW uint32_t* const)UINT32_C(0x40015C3C),   /** @brief Clear flag register */
      (_RW uint32_t* const)UINT32_C(0x4001603C),   /** @brief Clear flag register */
      (_RW uint32_t* const)UINT32_C(0x5800543C),   /** @brief Clear flag register */
    };

    static _RW uint32_t* const SAIX_BDR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015840),   /** @brief Data register */
      (_RW uint32_t* const)UINT32_C(0x40015C40),   /** @brief Data register */
      (_RW uint32_t* const)UINT32_C(0x40016040),   /** @brief Data register */
      (_RW uint32_t* const)UINT32_C(0x58005440),   /** @brief Data register */
    };

    static _RW uint32_t* const SAIX_PDMCR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015844),   /** @brief PDM control register */
      (_RW uint32_t* const)UINT32_C(0x40015C44),   /** @brief PDM control register */
      (_RW uint32_t* const)UINT32_C(0x40016044),   /** @brief PDM control register */
      (_RW uint32_t* const)UINT32_C(0x58005444),   /** @brief PDM control register */
    };

    static _RW uint32_t* const SAIX_PDMDLY_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40015848),   /** @brief PDM delay register */
      (_RW uint32_t* const)UINT32_C(0x40015C48),   /** @brief PDM delay register */
      (_RW uint32_t* const)UINT32_C(0x40016048),   /** @brief PDM delay register */
      (_RW uint32_t* const)UINT32_C(0x58005448),   /** @brief PDM delay register */
    };

    /** @subsection SAIX field mask array definitions */

    static const uint32_t SAIX_PDMCR_CKENX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Clock enable of bitstream clock number 1 */
      UINT32_C(0x00000200),   /** @brief Clock enable of bitstream clock number 2 */
      UINT32_C(0x00000400),   /** @brief Clock enable of bitstream clock number 3 */
      UINT32_C(0x00000800),   /** @brief Clock enable of bitstream clock number 4 */
    };

    static const uint32_t SAIX_PDMDLY_DLYMXL_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000007),   /** @brief Delay line adjust for first microphone of pair 1 */
      UINT32_C(0x00000700),   /** @brief Delay line for first microphone of pair 2 */
      UINT32_C(0x00070000),   /** @brief Delay line for first microphone of pair 3 */
      UINT32_C(0x07000000),   /** @brief Delay line for first microphone of pair 4 */
    };

    static const uint32_t SAIX_PDMDLY_DLYMXR_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000070),   /** @brief Delay line adjust for second microphone of pair 1 */
      UINT32_C(0x00007000),   /** @brief Delay line for second microphone of pair 2 */
      UINT32_C(0x00700000),   /** @brief Delay line for second microphone of pair 3 */
      UINT32_C(0x70000000),   /** @brief Delay line for second microphone of pair 4 */
    };

    /** @subsection SAIX field mask definitions */

    static const uint32_t SAIX_GCR_SYNCOUT_MASK = UINT32_C(0x00000030);       /** @brief Synchronization outputs these bits are set and cleared by software. */
    static const uint32_t SAIX_GCR_SYNCIN_MASK = UINT32_C(0x00000003);        /** @brief Synchronization inputs */
    static const uint32_t SAIX_ACR1_MODE_MASK = UINT32_C(0x00000003);         /** @brief SAIx audio block mode immediately */
    static const uint32_t SAIX_ACR1_PRTCFG_MASK = UINT32_C(0x0000000C);       /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const uint32_t SAIX_ACR1_DS_MASK = UINT32_C(0x000000E0);           /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const uint32_t SAIX_ACR1_LSBFIRST_MASK = UINT32_C(0x00000100);     /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const uint32_t SAIX_ACR1_CKSTR_MASK = UINT32_C(0x00000200);        /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const uint32_t SAIX_ACR1_SYNCEN_MASK = UINT32_C(0x00000C00);       /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const uint32_t SAIX_ACR1_MONO_MASK = UINT32_C(0x00001000);         /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const uint32_t SAIX_ACR1_OUTDRIV_MASK = UINT32_C(0x00002000);      /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const uint32_t SAIX_ACR1_SAIXEN_MASK = UINT32_C(0x00010000);       /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const uint32_t SAIX_ACR1_DMAEN_MASK = UINT32_C(0x00020000);        /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const uint32_t SAIX_ACR1_NOMCK_MASK = UINT32_C(0x00080000);        /** @brief No divider */
    static const uint32_t SAIX_ACR1_MCKDIV_MASK = UINT32_C(0x00F00000);       /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const uint32_t SAIX_ACR1_OSR_MASK = UINT32_C(0x04000000);          /** @brief Oversampling ratio for master clock */
    static const uint32_t SAIX_ACR2_FTH_MASK = UINT32_C(0x00000007);          /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const uint32_t SAIX_ACR2_FFLUSH_MASK = UINT32_C(0x00000008);       /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const uint32_t SAIX_ACR2_TRIS_MASK = UINT32_C(0x00000010);         /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const uint32_t SAIX_ACR2_MUTE_MASK = UINT32_C(0x00000020);         /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIX_ACR2_MUTEVAL_MASK = UINT32_C(0x00000040);      /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIX_ACR2_MUTECNT_MASK = UINT32_C(0x00001F80);      /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const uint32_t SAIX_ACR2_CPL_MASK = UINT32_C(0x00002000);          /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const uint32_t SAIX_ACR2_COMP_MASK = UINT32_C(0x0000C000);         /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const uint32_t SAIX_AFRCR_FRL_MASK = UINT32_C(0x000000FF);         /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const uint32_t SAIX_AFRCR_FSALL_MASK = UINT32_C(0x00007F00);       /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const uint32_t SAIX_AFRCR_FSDEF_MASK = UINT32_C(0x00010000);       /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const uint32_t SAIX_AFRCR_FSPOL_MASK = UINT32_C(0x00020000);       /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIX_AFRCR_FSOFF_MASK = UINT32_C(0x00040000);       /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIX_ASLOTR_FBOFF_MASK = UINT32_C(0x0000001F);      /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_ASLOTR_SLOTSZ_MASK = UINT32_C(0x000000C0);     /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_ASLOTR_NBSLOT_MASK = UINT32_C(0x00000F00);     /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_ASLOTR_SLOTEN_MASK = UINT32_C(0xFFFF0000);     /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_AIM_OVRUDRIE_MASK = UINT32_C(0x00000001);      /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const uint32_t SAIX_AIM_MUTEDETIE_MASK = UINT32_C(0x00000002);     /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const uint32_t SAIX_AIM_WCKCFGIE_MASK = UINT32_C(0x00000004);      /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const uint32_t SAIX_AIM_FREQIE_MASK = UINT32_C(0x00000008);        /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const uint32_t SAIX_AIM_CNRDYIE_MASK = UINT32_C(0x00000010);       /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const uint32_t SAIX_AIM_AFSDETIE_MASK = UINT32_C(0x00000020);      /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIX_AIM_LFSDETIE_MASK = UINT32_C(0x00000040);      /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIX_ASR_OVRUDR_MASK = UINT32_C(0x00000001);        /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const uint32_t SAIX_ASR_MUTEDET_MASK = UINT32_C(0x00000002);       /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const uint32_t SAIX_ASR_WCKCFG_MASK = UINT32_C(0x00000004);        /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const uint32_t SAIX_ASR_FREQ_MASK = UINT32_C(0x00000008);          /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const uint32_t SAIX_ASR_CNRDY_MASK = UINT32_C(0x00000010);         /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const uint32_t SAIX_ASR_AFSDET_MASK = UINT32_C(0x00000020);        /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const uint32_t SAIX_ASR_LFSDET_MASK = UINT32_C(0x00000040);        /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const uint32_t SAIX_ASR_FLVL_MASK = UINT32_C(0x00070000);          /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const uint32_t SAIX_ACLRFR_COVRUDR_MASK = UINT32_C(0x00000001);    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_ACLRFR_CMUTEDET_MASK = UINT32_C(0x00000002);   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_ACLRFR_CWCKCFG_MASK = UINT32_C(0x00000004);    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_ACLRFR_CCNRDY_MASK = UINT32_C(0x00000010);     /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_ACLRFR_CAFSDET_MASK = UINT32_C(0x00000020);    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_ACLRFR_CLFSDET_MASK = UINT32_C(0x00000040);    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const uint32_t SAIX_BCR1_MODE_MASK = UINT32_C(0x00000003);         /** @brief SAIx audio block mode immediately */
    static const uint32_t SAIX_BCR1_PRTCFG_MASK = UINT32_C(0x0000000C);       /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const uint32_t SAIX_BCR1_DS_MASK = UINT32_C(0x000000E0);           /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const uint32_t SAIX_BCR1_LSBFIRST_MASK = UINT32_C(0x00000100);     /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const uint32_t SAIX_BCR1_CKSTR_MASK = UINT32_C(0x00000200);        /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const uint32_t SAIX_BCR1_SYNCEN_MASK = UINT32_C(0x00000C00);       /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const uint32_t SAIX_BCR1_MONO_MASK = UINT32_C(0x00001000);         /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const uint32_t SAIX_BCR1_OUTDRIV_MASK = UINT32_C(0x00002000);      /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const uint32_t SAIX_BCR1_SAIXEN_MASK = UINT32_C(0x00010000);       /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const uint32_t SAIX_BCR1_DMAEN_MASK = UINT32_C(0x00020000);        /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const uint32_t SAIX_BCR1_NOMCK_MASK = UINT32_C(0x00080000);        /** @brief No divider */
    static const uint32_t SAIX_BCR1_MCKDIV_MASK = UINT32_C(0x00F00000);       /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const uint32_t SAIX_BCR1_OSR_MASK = UINT32_C(0x04000000);          /** @brief Oversampling ratio for master clock */
    static const uint32_t SAIX_BCR2_FTH_MASK = UINT32_C(0x00000007);          /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const uint32_t SAIX_BCR2_FFLUSH_MASK = UINT32_C(0x00000008);       /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const uint32_t SAIX_BCR2_TRIS_MASK = UINT32_C(0x00000010);         /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const uint32_t SAIX_BCR2_MUTE_MASK = UINT32_C(0x00000020);         /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIX_BCR2_MUTEVAL_MASK = UINT32_C(0x00000040);      /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const uint32_t SAIX_BCR2_MUTECNT_MASK = UINT32_C(0x00001F80);      /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const uint32_t SAIX_BCR2_CPL_MASK = UINT32_C(0x00002000);          /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const uint32_t SAIX_BCR2_COMP_MASK = UINT32_C(0x0000C000);         /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const uint32_t SAIX_BFRCR_FRL_MASK = UINT32_C(0x000000FF);         /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const uint32_t SAIX_BFRCR_FSALL_MASK = UINT32_C(0x00007F00);       /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const uint32_t SAIX_BFRCR_FSDEF_MASK = UINT32_C(0x00010000);       /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const uint32_t SAIX_BFRCR_FSPOL_MASK = UINT32_C(0x00020000);       /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIX_BFRCR_FSOFF_MASK = UINT32_C(0x00040000);       /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const uint32_t SAIX_BSLOTR_FBOFF_MASK = UINT32_C(0x0000001F);      /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_BSLOTR_SLOTSZ_MASK = UINT32_C(0x000000C0);     /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_BSLOTR_NBSLOT_MASK = UINT32_C(0x00000F00);     /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_BSLOTR_SLOTEN_MASK = UINT32_C(0xFFFF0000);     /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const uint32_t SAIX_BIM_OVRUDRIE_MASK = UINT32_C(0x00000001);      /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const uint32_t SAIX_BIM_MUTEDETIE_MASK = UINT32_C(0x00000002);     /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const uint32_t SAIX_BIM_WCKCFGIE_MASK = UINT32_C(0x00000004);      /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const uint32_t SAIX_BIM_FREQIE_MASK = UINT32_C(0x00000008);        /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const uint32_t SAIX_BIM_CNRDYIE_MASK = UINT32_C(0x00000010);       /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const uint32_t SAIX_BIM_AFSDETIE_MASK = UINT32_C(0x00000020);      /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIX_BIM_LFSDETIE_MASK = UINT32_C(0x00000040);      /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const uint32_t SAIX_BSR_OVRUDR_MASK = UINT32_C(0x00000001);        /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const uint32_t SAIX_BSR_MUTEDET_MASK = UINT32_C(0x00000002);       /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const uint32_t SAIX_BSR_WCKCFG_MASK = UINT32_C(0x00000004);        /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const uint32_t SAIX_BSR_FREQ_MASK = UINT32_C(0x00000008);          /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const uint32_t SAIX_BSR_CNRDY_MASK = UINT32_C(0x00000010);         /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const uint32_t SAIX_BSR_AFSDET_MASK = UINT32_C(0x00000020);        /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const uint32_t SAIX_BSR_LFSDET_MASK = UINT32_C(0x00000040);        /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const uint32_t SAIX_BSR_FLVL_MASK = UINT32_C(0x00070000);          /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const uint32_t SAIX_BCLRFR_COVRUDR_MASK = UINT32_C(0x00000001);    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_BCLRFR_CMUTEDET_MASK = UINT32_C(0x00000002);   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_BCLRFR_CWCKCFG_MASK = UINT32_C(0x00000004);    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_BCLRFR_CCNRDY_MASK = UINT32_C(0x00000010);     /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_BCLRFR_CAFSDET_MASK = UINT32_C(0x00000020);    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const uint32_t SAIX_BCLRFR_CLFSDET_MASK = UINT32_C(0x00000040);    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const uint32_t SAIX_PDMCR_PDMEN_MASK = UINT32_C(0x00000001);       /** @brief PDM enable */
    static const uint32_t SAIX_PDMCR_MICNBR_MASK = UINT32_C(0x00000030);      /** @brief Number of microphones */

    /** @subsection SAIX field position array definitions */

    static const int32_t SAIX_PDMDLY_CKENX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Clock enable of bitstream clock number 1 */
      INT32_C(9),    /** @brief Clock enable of bitstream clock number 2 */
      INT32_C(10),   /** @brief Clock enable of bitstream clock number 3 */
      INT32_C(11),   /** @brief Clock enable of bitstream clock number 4 */
    };

    static const int32_t SAIX_PDMDLY_DLYMXL_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Delay line adjust for first microphone of pair 1 */
      INT32_C(8),    /** @brief Delay line for first microphone of pair 2 */
      INT32_C(16),   /** @brief Delay line for first microphone of pair 3 */
      INT32_C(24),   /** @brief Delay line for first microphone of pair 4 */
    };

    static const int32_t SAIX_PDMDLY_DLYMXR_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(4),    /** @brief Delay line adjust for second microphone of pair 1 */
      INT32_C(12),   /** @brief Delay line for second microphone of pair 2 */
      INT32_C(20),   /** @brief Delay line for second microphone of pair 3 */
      INT32_C(28),   /** @brief Delay line for second microphone of pair 4 */
    };

    /** @subsection SAIX field position definitions */

    static const int32_t SAIX_PDMDLY_SYNCOUT_POS = INT32_C(4);      /** @brief Synchronization outputs these bits are set and cleared by software. */
    static const int32_t SAIX_PDMDLY_SYNCIN_POS = INT32_C(0);       /** @brief Synchronization inputs */
    static const int32_t SAIX_PDMDLY_MODE_POS = INT32_C(0);         /** @brief SAIx audio block mode immediately */
    static const int32_t SAIX_PDMDLY_PRTCFG_POS = INT32_C(2);       /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_DS_POS = INT32_C(5);           /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_LSBFIRST_POS = INT32_C(8);     /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const int32_t SAIX_PDMDLY_CKSTR_POS = INT32_C(9);        /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const int32_t SAIX_PDMDLY_SYNCEN_POS = INT32_C(10);      /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const int32_t SAIX_PDMDLY_MONO_POS = INT32_C(12);        /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const int32_t SAIX_PDMDLY_OUTDRIV_POS = INT32_C(13);     /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const int32_t SAIX_PDMDLY_SAIXEN_POS = INT32_C(16);      /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const int32_t SAIX_PDMDLY_DMAEN_POS = INT32_C(17);       /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const int32_t SAIX_PDMDLY_NOMCK_POS = INT32_C(19);       /** @brief No divider */
    static const int32_t SAIX_PDMDLY_MCKDIV_POS = INT32_C(20);      /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const int32_t SAIX_PDMDLY_OSR_POS = INT32_C(26);         /** @brief Oversampling ratio for master clock */
    static const int32_t SAIX_PDMDLY_FTH_POS = INT32_C(0);          /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const int32_t SAIX_PDMDLY_FFLUSH_POS = INT32_C(3);       /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const int32_t SAIX_PDMDLY_TRIS_POS = INT32_C(4);         /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const int32_t SAIX_PDMDLY_MUTE_POS = INT32_C(5);         /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIX_PDMDLY_MUTEVAL_POS = INT32_C(6);      /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIX_PDMDLY_MUTECNT_POS = INT32_C(7);      /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const int32_t SAIX_PDMDLY_CPL_POS = INT32_C(13);         /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const int32_t SAIX_PDMDLY_COMP_POS = INT32_C(14);        /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const int32_t SAIX_PDMDLY_FRL_POS = INT32_C(0);          /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const int32_t SAIX_PDMDLY_FSALL_POS = INT32_C(8);        /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FSDEF_POS = INT32_C(16);       /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FSPOL_POS = INT32_C(17);       /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FSOFF_POS = INT32_C(18);       /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FBOFF_POS = INT32_C(0);        /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_SLOTSZ_POS = INT32_C(6);       /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_NBSLOT_POS = INT32_C(8);       /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_SLOTEN_POS = INT32_C(16);      /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_OVRUDRIE_POS = INT32_C(0);     /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const int32_t SAIX_PDMDLY_MUTEDETIE_POS = INT32_C(1);    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const int32_t SAIX_PDMDLY_WCKCFGIE_POS = INT32_C(2);     /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const int32_t SAIX_PDMDLY_FREQIE_POS = INT32_C(3);       /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const int32_t SAIX_PDMDLY_CNRDYIE_POS = INT32_C(4);      /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const int32_t SAIX_PDMDLY_AFSDETIE_POS = INT32_C(5);     /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIX_PDMDLY_LFSDETIE_POS = INT32_C(6);     /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIX_PDMDLY_OVRUDR_POS = INT32_C(0);       /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_MUTEDET_POS = INT32_C(1);      /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_WCKCFG_POS = INT32_C(2);       /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_FREQ_POS = INT32_C(3);         /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const int32_t SAIX_PDMDLY_CNRDY_POS = INT32_C(4);        /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_AFSDET_POS = INT32_C(5);       /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_LFSDET_POS = INT32_C(6);       /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const int32_t SAIX_PDMDLY_FLVL_POS = INT32_C(16);        /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const int32_t SAIX_PDMDLY_COVRUDR_POS = INT32_C(0);      /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CMUTEDET_POS = INT32_C(1);     /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CWCKCFG_POS = INT32_C(2);      /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CCNRDY_POS = INT32_C(4);       /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CAFSDET_POS = INT32_C(5);      /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CLFSDET_POS = INT32_C(6);      /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_MODE_POS = INT32_C(0);         /** @brief SAIx audio block mode immediately */
    static const int32_t SAIX_PDMDLY_PRTCFG_POS = INT32_C(2);       /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_DS_POS = INT32_C(5);           /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_LSBFIRST_POS = INT32_C(8);     /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
    static const int32_t SAIX_PDMDLY_CKSTR_POS = INT32_C(9);        /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
    static const int32_t SAIX_PDMDLY_SYNCEN_POS = INT32_C(10);      /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
    static const int32_t SAIX_PDMDLY_MONO_POS = INT32_C(12);        /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
    static const int32_t SAIX_PDMDLY_OUTDRIV_POS = INT32_C(13);     /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
    static const int32_t SAIX_PDMDLY_SAIXEN_POS = INT32_C(16);      /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
    static const int32_t SAIX_PDMDLY_DMAEN_POS = INT32_C(17);       /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
    static const int32_t SAIX_PDMDLY_NOMCK_POS = INT32_C(19);       /** @brief No divider */
    static const int32_t SAIX_PDMDLY_MCKDIV_POS = INT32_C(20);      /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
    static const int32_t SAIX_PDMDLY_OSR_POS = INT32_C(26);         /** @brief Oversampling ratio for master clock */
    static const int32_t SAIX_PDMDLY_FTH_POS = INT32_C(0);          /** @brief FIFO threshold. This bit is set and cleared by software. */
    static const int32_t SAIX_PDMDLY_FFLUSH_POS = INT32_C(3);       /** @brief FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled. */
    static const int32_t SAIX_PDMDLY_TRIS_POS = INT32_C(4);         /** @brief Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to section: output data line management on an inactive slot for more details. */
    static const int32_t SAIX_PDMDLY_MUTE_POS = INT32_C(5);         /** @brief Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIX_PDMDLY_MUTEVAL_POS = INT32_C(6);      /** @brief Mute value. This bit is set and cleared by software.it must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. If the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to section: mute mode for more details. Note: this bit is meaningless and should not be used for SPDIF audio blocks. */
    static const int32_t SAIX_PDMDLY_MUTECNT_POS = INT32_C(7);      /** @brief Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to section: mute mode for more details. */
    static const int32_t SAIX_PDMDLY_CPL_POS = INT32_C(13);         /** @brief Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode note: this bit has effect only when the companding mode is -law algorithm or a-law algorithm. */
    static const int32_t SAIX_PDMDLY_COMP_POS = INT32_C(14);        /** @brief Companding mode. These bits are set and cleared by software. The -law and the a-law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to section: companding mode for more details. Note: companding mode is applicable only when TDM is selected. */
    static const int32_t SAIX_PDMDLY_FRL_POS = INT32_C(0);          /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
    static const int32_t SAIX_PDMDLY_FSALL_POS = INT32_C(8);        /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FSDEF_POS = INT32_C(16);       /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FSPOL_POS = INT32_C(17);       /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FSOFF_POS = INT32_C(18);       /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    static const int32_t SAIX_PDMDLY_FBOFF_POS = INT32_C(0);        /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_SLOTSZ_POS = INT32_C(6);       /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_NBSLOT_POS = INT32_C(8);       /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_SLOTEN_POS = INT32_C(16);      /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    static const int32_t SAIX_PDMDLY_OVRUDRIE_POS = INT32_C(0);     /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
    static const int32_t SAIX_PDMDLY_MUTEDETIE_POS = INT32_C(1);    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
    static const int32_t SAIX_PDMDLY_WCKCFGIE_POS = INT32_C(2);     /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
    static const int32_t SAIX_PDMDLY_FREQIE_POS = INT32_C(3);       /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
    static const int32_t SAIX_PDMDLY_CNRDYIE_POS = INT32_C(4);      /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
    static const int32_t SAIX_PDMDLY_AFSDETIE_POS = INT32_C(5);     /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIX_PDMDLY_LFSDETIE_POS = INT32_C(6);     /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    static const int32_t SAIX_PDMDLY_OVRUDR_POS = INT32_C(0);       /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_MUTEDET_POS = INT32_C(1);      /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_WCKCFG_POS = INT32_C(2);       /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_FREQ_POS = INT32_C(3);         /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
    static const int32_t SAIX_PDMDLY_CNRDY_POS = INT32_C(4);        /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_AFSDET_POS = INT32_C(5);       /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
    static const int32_t SAIX_PDMDLY_LFSDET_POS = INT32_C(6);       /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
    static const int32_t SAIX_PDMDLY_FLVL_POS = INT32_C(16);        /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    static const int32_t SAIX_PDMDLY_COVRUDR_POS = INT32_C(0);      /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CMUTEDET_POS = INT32_C(1);     /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CWCKCFG_POS = INT32_C(2);      /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CCNRDY_POS = INT32_C(4);       /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CAFSDET_POS = INT32_C(5);      /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_CLFSDET_POS = INT32_C(6);      /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    static const int32_t SAIX_PDMDLY_PDMEN_POS = INT32_C(0);        /** @brief PDM enable */
    static const int32_t SAIX_PDMDLY_MICNBR_POS = INT32_C(4);       /** @brief Number of microphones */

    /**********************************************************************************************
     * @section SDMMCX Definitions
     **********************************************************************************************/

    /** @subsection SDMMCX IRQ interrupt definitions */

    static const int32_t SDMMC1_IRQ = INT32_C(49);    /** @brief SDMMC global interrupt */
    static const int32_t SDMMC_IRQ = INT32_C(124);    /** @brief SDMMC global interrupt */

    /** @subsection SDMMCX register array definitions */

    static _RW uint32_t* const SDMMCX_POWER_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007000),   /** @brief SDMMC power control register */
      (_RW uint32_t* const)UINT32_C(0x48022400),   /** @brief SDMMC power control register */
    };

    static _RW uint32_t* const SDMMCX_CLKCR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007004),   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
      (_RW uint32_t* const)UINT32_C(0x48022404),   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
    };

    static _RW uint32_t* const SDMMCX_ARGR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007008),   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
      (_RW uint32_t* const)UINT32_C(0x48022408),   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
    };

    static _RW uint32_t* const SDMMCX_CMDR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x5200700C),   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
      (_RW uint32_t* const)UINT32_C(0x4802240C),   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
    };

    static _RO uint32_t* const SDMMCX_RESPXR_REG[3][5] = {
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x52007014),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        (_RO uint32_t* const)UINT32_C(0x52007018),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        (_RO uint32_t* const)UINT32_C(0x5200701C),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        (_RO uint32_t* const)UINT32_C(0x52007020),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      },
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x48022414),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        (_RO uint32_t* const)UINT32_C(0x48022418),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        (_RO uint32_t* const)UINT32_C(0x4802241C),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
        (_RO uint32_t* const)UINT32_C(0x48022420),   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      },
    };

    static _RW uint32_t* const SDMMCX_DTIMER_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007024),   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
      (_RW uint32_t* const)UINT32_C(0x48022424),   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
    };

    static _RW uint32_t* const SDMMCX_DLENR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007028),   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
      (_RW uint32_t* const)UINT32_C(0x48022428),   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
    };

    static _RW uint32_t* const SDMMCX_DCTRL_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x5200702C),   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
      (_RW uint32_t* const)UINT32_C(0x4802242C),   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
    };

    static _RO uint32_t* const SDMMCX_DCNTR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x52007030),   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
      (_RO uint32_t* const)UINT32_C(0x48022430),   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
    };

    static _RO uint32_t* const SDMMCX_STAR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x52007034),   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
      (_RO uint32_t* const)UINT32_C(0x48022434),   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
    };

    static _RW uint32_t* const SDMMCX_ICR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007038),   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
      (_RW uint32_t* const)UINT32_C(0x48022438),   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
    };

    static _RW uint32_t* const SDMMCX_MASKR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x5200703C),   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
      (_RW uint32_t* const)UINT32_C(0x4802243C),   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
    };

    static _RW uint32_t* const SDMMCX_ACKTIMER_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007040),   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
      (_RW uint32_t* const)UINT32_C(0x48022440),   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
    };

    static _RW uint32_t* const SDMMCX_IDMACTRLR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007050),   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
      (_RW uint32_t* const)UINT32_C(0x48022450),   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
    };

    static _RW uint32_t* const SDMMCX_IDMABSIZER_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007054),   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
      (_RW uint32_t* const)UINT32_C(0x48022454),   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
    };

    static _RW uint32_t* const SDMMCX_IDMABASE0R_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007058),   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
      (_RW uint32_t* const)UINT32_C(0x48022458),   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
    };

    static _RW uint32_t* const SDMMCX_IDMABASE1R_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x5200705C),   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
      (_RW uint32_t* const)UINT32_C(0x4802245C),   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
    };

    static _RW uint32_t* const SDMMCX_FIFOR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52007080),   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
      (_RW uint32_t* const)UINT32_C(0x48022480),   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
    };

    static _RO uint32_t* const SDMMCX_RESPCMDR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x52007010),   /** @brief SDMMC command response register */
      (_RO uint32_t* const)UINT32_C(0x48022410),   /** @brief SDMMC command response register */
    };

    /** @subsection SDMMCX field mask definitions */

    static const uint32_t SDMMCX_POWER_PWRCTRL_MASK = UINT32_C(0x00000003);         /** @brief SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: any further write will be ignored, PWRCTRL value will keep 11. */
    static const uint32_t SDMMCX_POWER_VSWITCH_MASK = UINT32_C(0x00000004);         /** @brief Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence: */
    static const uint32_t SDMMCX_POWER_VSWITCHEN_MASK = UINT32_C(0x00000008);       /** @brief Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response: */
    static const uint32_t SDMMCX_POWER_DIRPOL_MASK = UINT32_C(0x00000010);          /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
    static const uint32_t SDMMCX_CLKCR_CLKDIV_MASK = UINT32_C(0x000003FF);          /** @brief Clock divide factor this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. Xxx: etc.. */
    static const uint32_t SDMMCX_CLKCR_PWRSAV_MASK = UINT32_C(0x00001000);          /** @brief Power saving configuration bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) for power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV: */
    static const uint32_t SDMMCX_CLKCR_WIDBUS_MASK = UINT32_C(0x0000C000);          /** @brief Wide bus mode enable bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const uint32_t SDMMCX_CLKCR_NEGEDGE_MASK = UINT32_C(0x00010000);         /** @brief SDMMC_CK dephasing selection bit for data and command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. */
    static const uint32_t SDMMCX_CLKCR_HWFC_EN_MASK = UINT32_C(0x00020000);         /** @brief Hardware flow control enable this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) when hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in section56.8.11. */
    static const uint32_t SDMMCX_CLKCR_DDR_MASK = UINT32_C(0x00040000);             /** @brief Data rate signaling selection this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0) */
    static const uint32_t SDMMCX_CLKCR_BUSSPEED_MASK = UINT32_C(0x00080000);        /** @brief Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const uint32_t SDMMCX_CLKCR_SELCLKRX_MASK = UINT32_C(0x00300000);        /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const uint32_t SDMMCX_CMDR_CMDINDEX_MASK = UINT32_C(0x0000003F);         /** @brief Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. */
    static const uint32_t SDMMCX_CMDR_CMDTRANS_MASK = UINT32_C(0x00000040);         /** @brief The CPSM treats the command as a data transfer command, stops the interrupt period, and signals dataenable to the DPSM this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues dataenable signal to the DPSM when the command is sent. */
    static const uint32_t SDMMCX_CMDR_CMDSTOP_MASK = UINT32_C(0x00000080);          /** @brief The CPSM treats the command as a stop transmission command and signals abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the abort signal to the DPSM when the command is sent. */
    static const uint32_t SDMMCX_CMDR_WAITRESP_MASK = UINT32_C(0x00000300);         /** @brief Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. */
    static const uint32_t SDMMCX_CMDR_WAITINT_MASK = UINT32_C(0x00000400);          /** @brief CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (response). If this bit is cleared in the CPSM wait state, will cause the abort of the interrupt mode. */
    static const uint32_t SDMMCX_CMDR_WAITPEND_MASK = UINT32_C(0x00000800);         /** @brief CPSM waits for end of data transfer (cmdpend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card. */
    static const uint32_t SDMMCX_CMDR_CPSMEN_MASK = UINT32_C(0x00001000);           /** @brief Command path state machine (CPSM) enable bit this bit is written 1 by firmware, and cleared by hardware when the CPSM enters the idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0. */
    static const uint32_t SDMMCX_CMDR_DTHOLD_MASK = UINT32_C(0x00002000);           /** @brief Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the wait_s state to the send state or from the wait_r state to the receive state. */
    static const uint32_t SDMMCX_CMDR_BOOTMODE_MASK = UINT32_C(0x00004000);         /** @brief Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0) */
    static const uint32_t SDMMCX_CMDR_BOOTEN_MASK = UINT32_C(0x00008000);           /** @brief Enable boot mode procedure. */
    static const uint32_t SDMMCX_CMDR_CMDSUSPEND_MASK = UINT32_C(0x00010000);       /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
    static const uint32_t SDMMCX_DLENR_DATALENGTH_MASK = UINT32_C(0x01FFFFFF);      /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
    static const uint32_t SDMMCX_DCTRL_DTEN_MASK = UINT32_C(0x00000001);            /** @brief Data transfer enable bit this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. Shall not be used with SD or emmc cards. */
    static const uint32_t SDMMCX_DCTRL_DTDIR_MASK = UINT32_C(0x00000002);           /** @brief Data transfer direction selection this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCX_DCTRL_DTMODE_MASK = UINT32_C(0x0000000C);          /** @brief Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCX_DCTRL_DBLOCKSIZE_MASK = UINT32_C(0x000000F0);      /** @brief Data block size this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: when DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) when DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) */
    static const uint32_t SDMMCX_DCTRL_RWSTART_MASK = UINT32_C(0x00000100);         /** @brief Read wait start. If this bit is set, read wait operation starts. */
    static const uint32_t SDMMCX_DCTRL_RWSTOP_MASK = UINT32_C(0x00000200);          /** @brief Read wait stop this bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state. */
    static const uint32_t SDMMCX_DCTRL_RWMOD_MASK = UINT32_C(0x00000400);           /** @brief Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCX_DCTRL_SDIOEN_MASK = UINT32_C(0x00000800);          /** @brief SD I/O interrupt enable functions this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation. */
    static const uint32_t SDMMCX_DCTRL_BOOTACKEN_MASK = UINT32_C(0x00001000);       /** @brief Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCX_DCTRL_FIFORST_MASK = UINT32_C(0x00002000);         /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
    static const uint32_t SDMMCX_DCNTR_DATACOUNT_MASK = UINT32_C(0x01FFFFFF);       /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
    static const uint32_t SDMMCX_STAR_CCRCFAIL_MASK = UINT32_C(0x00000001);         /** @brief Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_DCRCFAIL_MASK = UINT32_C(0x00000002);         /** @brief Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_CTIMEOUT_MASK = UINT32_C(0x00000004);         /** @brief Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The command timeout period has a fixed value of 64 SDMMC_CK clock periods. */
    static const uint32_t SDMMCX_STAR_DTIMEOUT_MASK = UINT32_C(0x00000008);         /** @brief Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_TXUNDERR_MASK = UINT32_C(0x00000010);         /** @brief Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_RXOVERR_MASK = UINT32_C(0x00000020);          /** @brief Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_CMDREND_MASK = UINT32_C(0x00000040);          /** @brief Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_CMDSENT_MASK = UINT32_C(0x00000080);          /** @brief Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_DATAEND_MASK = UINT32_C(0x00000100);          /** @brief Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_DHOLD_MASK = UINT32_C(0x00000200);            /** @brief Data transfer hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_DBCKEND_MASK = UINT32_C(0x00000400);          /** @brief Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_DABORT_MASK = UINT32_C(0x00000800);           /** @brief Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_DPSMACT_MASK = UINT32_C(0x00001000);          /** @brief Data path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const uint32_t SDMMCX_STAR_CPSMACT_MASK = UINT32_C(0x00002000);          /** @brief Command path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const uint32_t SDMMCX_STAR_TXFIFOHE_MASK = UINT32_C(0x00004000);         /** @brief Transmit FIFO half empty at least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full. */
    static const uint32_t SDMMCX_STAR_RXFIFOHF_MASK = UINT32_C(0x00008000);         /** @brief Receive FIFO half full there are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty. */
    static const uint32_t SDMMCX_STAR_TXFIFOF_MASK = UINT32_C(0x00010000);          /** @brief Transmit FIFO full this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty. */
    static const uint32_t SDMMCX_STAR_RXFIFOF_MASK = UINT32_C(0x00020000);          /** @brief Receive FIFO full this bit is cleared when one FIFO location becomes empty. */
    static const uint32_t SDMMCX_STAR_TXFIFOE_MASK = UINT32_C(0x00040000);          /** @brief Transmit FIFO empty this bit is cleared when one FIFO location becomes full. */
    static const uint32_t SDMMCX_STAR_RXFIFOE_MASK = UINT32_C(0x00080000);          /** @brief Receive FIFO empty this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full. */
    static const uint32_t SDMMCX_STAR_BUSYD0_MASK = UINT32_C(0x00100000);           /** @brief Inverted value of SDMMC_D0 line (busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt. */
    static const uint32_t SDMMCX_STAR_BUSYD0END_MASK = UINT32_C(0x00200000);        /** @brief End of SDMMC_D0 busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_SDIOIT_MASK = UINT32_C(0x00400000);           /** @brief SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_ACKFAIL_MASK = UINT32_C(0x00800000);          /** @brief Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_ACKTIMEOUT_MASK = UINT32_C(0x01000000);       /** @brief Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_VSWEND_MASK = UINT32_C(0x02000000);           /** @brief Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_CKSTOP_MASK = UINT32_C(0x04000000);           /** @brief SDMMC_CK stopped in voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_IDMATE_MASK = UINT32_C(0x08000000);           /** @brief IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_STAR_IDMABTC_MASK = UINT32_C(0x10000000);          /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const uint32_t SDMMCX_ICR_CCRCFAILC_MASK = UINT32_C(0x00000001);         /** @brief CCRCFAIL flag clear bit set by software to clear the CCRCFAIL flag. */
    static const uint32_t SDMMCX_ICR_DCRCFAILC_MASK = UINT32_C(0x00000002);         /** @brief DCRCFAIL flag clear bit set by software to clear the DCRCFAIL flag. */
    static const uint32_t SDMMCX_ICR_CTIMEOUTC_MASK = UINT32_C(0x00000004);         /** @brief CTIMEOUT flag clear bit set by software to clear the CTIMEOUT flag. */
    static const uint32_t SDMMCX_ICR_DTIMEOUTC_MASK = UINT32_C(0x00000008);         /** @brief DTIMEOUT flag clear bit set by software to clear the DTIMEOUT flag. */
    static const uint32_t SDMMCX_ICR_TXUNDERRC_MASK = UINT32_C(0x00000010);         /** @brief TXUNDERR flag clear bit set by software to clear TXUNDERR flag. */
    static const uint32_t SDMMCX_ICR_RXOVERRC_MASK = UINT32_C(0x00000020);          /** @brief RXOVERR flag clear bit set by software to clear the RXOVERR flag. */
    static const uint32_t SDMMCX_ICR_CMDRENDC_MASK = UINT32_C(0x00000040);          /** @brief CMDREND flag clear bit set by software to clear the CMDREND flag. */
    static const uint32_t SDMMCX_ICR_CMDSENTC_MASK = UINT32_C(0x00000080);          /** @brief CMDSENT flag clear bit set by software to clear the CMDSENT flag. */
    static const uint32_t SDMMCX_ICR_DATAENDC_MASK = UINT32_C(0x00000100);          /** @brief DATAEND flag clear bit set by software to clear the DATAEND flag. */
    static const uint32_t SDMMCX_ICR_DHOLDC_MASK = UINT32_C(0x00000200);            /** @brief DHOLD flag clear bit set by software to clear the DHOLD flag. */
    static const uint32_t SDMMCX_ICR_DBCKENDC_MASK = UINT32_C(0x00000400);          /** @brief DBCKEND flag clear bit set by software to clear the DBCKEND flag. */
    static const uint32_t SDMMCX_ICR_DABORTC_MASK = UINT32_C(0x00000800);           /** @brief DABORT flag clear bit set by software to clear the DABORT flag. */
    static const uint32_t SDMMCX_ICR_BUSYD0ENDC_MASK = UINT32_C(0x00200000);        /** @brief BUSYD0END flag clear bit set by software to clear the BUSYD0END flag. */
    static const uint32_t SDMMCX_ICR_SDIOITC_MASK = UINT32_C(0x00400000);           /** @brief SDIOIT flag clear bit set by software to clear the SDIOIT flag. */
    static const uint32_t SDMMCX_ICR_ACKFAILC_MASK = UINT32_C(0x00800000);          /** @brief ACKFAIL flag clear bit set by software to clear the ACKFAIL flag. */
    static const uint32_t SDMMCX_ICR_ACKTIMEOUTC_MASK = UINT32_C(0x01000000);       /** @brief ACKTIMEOUT flag clear bit set by software to clear the ACKTIMEOUT flag. */
    static const uint32_t SDMMCX_ICR_VSWENDC_MASK = UINT32_C(0x02000000);           /** @brief VSWEND flag clear bit set by software to clear the VSWEND flag. */
    static const uint32_t SDMMCX_ICR_CKSTOPC_MASK = UINT32_C(0x04000000);           /** @brief CKSTOP flag clear bit set by software to clear the CKSTOP flag. */
    static const uint32_t SDMMCX_ICR_IDMATEC_MASK = UINT32_C(0x08000000);           /** @brief IDMA transfer error clear bit set by software to clear the IDMATE flag. */
    static const uint32_t SDMMCX_ICR_IDMABTCC_MASK = UINT32_C(0x10000000);          /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
    static const uint32_t SDMMCX_MASKR_CCRCFAILIE_MASK = UINT32_C(0x00000001);      /** @brief Command CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by command CRC failure. */
    static const uint32_t SDMMCX_MASKR_DCRCFAILIE_MASK = UINT32_C(0x00000002);      /** @brief Data CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by data CRC failure. */
    static const uint32_t SDMMCX_MASKR_CTIMEOUTIE_MASK = UINT32_C(0x00000004);      /** @brief Command timeout interrupt enable set and cleared by software to enable/disable interrupt caused by command timeout. */
    static const uint32_t SDMMCX_MASKR_DTIMEOUTIE_MASK = UINT32_C(0x00000008);      /** @brief Data timeout interrupt enable set and cleared by software to enable/disable interrupt caused by data timeout. */
    static const uint32_t SDMMCX_MASKR_TXUNDERRIE_MASK = UINT32_C(0x00000010);      /** @brief Tx FIFO underrun error interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO underrun error. */
    static const uint32_t SDMMCX_MASKR_RXOVERRIE_MASK = UINT32_C(0x00000020);       /** @brief Rx FIFO overrun error interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO overrun error. */
    static const uint32_t SDMMCX_MASKR_CMDRENDIE_MASK = UINT32_C(0x00000040);       /** @brief Command response received interrupt enable set and cleared by software to enable/disable interrupt caused by receiving command response. */
    static const uint32_t SDMMCX_MASKR_CMDSENTIE_MASK = UINT32_C(0x00000080);       /** @brief Command sent interrupt enable set and cleared by software to enable/disable interrupt caused by sending command. */
    static const uint32_t SDMMCX_MASKR_DATAENDIE_MASK = UINT32_C(0x00000100);       /** @brief Data end interrupt enable set and cleared by software to enable/disable interrupt caused by data end. */
    static const uint32_t SDMMCX_MASKR_DHOLDIE_MASK = UINT32_C(0x00000200);         /** @brief Data hold interrupt enable set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM wait_s state. */
    static const uint32_t SDMMCX_MASKR_DBCKENDIE_MASK = UINT32_C(0x00000400);       /** @brief Data block end interrupt enable set and cleared by software to enable/disable interrupt caused by data block end. */
    static const uint32_t SDMMCX_MASKR_DABORTIE_MASK = UINT32_C(0x00000800);        /** @brief Data transfer aborted interrupt enable set and cleared by software to enable/disable interrupt caused by a data transfer being aborted. */
    static const uint32_t SDMMCX_MASKR_TXFIFOHEIE_MASK = UINT32_C(0x00004000);      /** @brief Tx FIFO half empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO half empty. */
    static const uint32_t SDMMCX_MASKR_RXFIFOHFIE_MASK = UINT32_C(0x00008000);      /** @brief Rx FIFO half full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO half full. */
    static const uint32_t SDMMCX_MASKR_RXFIFOFIE_MASK = UINT32_C(0x00020000);       /** @brief Rx FIFO full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO full. */
    static const uint32_t SDMMCX_MASKR_TXFIFOEIE_MASK = UINT32_C(0x00040000);       /** @brief Tx FIFO empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO empty. */
    static const uint32_t SDMMCX_MASKR_BUSYD0ENDIE_MASK = UINT32_C(0x00200000);     /** @brief BUSYD0END interrupt enable set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response. */
    static const uint32_t SDMMCX_MASKR_SDIOITIE_MASK = UINT32_C(0x00400000);        /** @brief SDIO mode interrupt received interrupt enable set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt. */
    static const uint32_t SDMMCX_MASKR_ACKFAILIE_MASK = UINT32_C(0x00800000);       /** @brief Acknowledgment fail interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment fail. */
    static const uint32_t SDMMCX_MASKR_ACKTIMEOUTIE_MASK = UINT32_C(0x01000000);    /** @brief Acknowledgment timeout interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment timeout. */
    static const uint32_t SDMMCX_MASKR_VSWENDIE_MASK = UINT32_C(0x02000000);        /** @brief Voltage switch critical timing section completion interrupt enable set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion. */
    static const uint32_t SDMMCX_MASKR_CKSTOPIE_MASK = UINT32_C(0x04000000);        /** @brief Voltage switch clock stopped interrupt enable set and cleared by software to enable/disable interrupt caused by voltage switch clock stopped. */
    static const uint32_t SDMMCX_MASKR_IDMABTCIE_MASK = UINT32_C(0x10000000);       /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
    static const uint32_t SDMMCX_ACKTIMER_ACKTIME_MASK = UINT32_C(0x01FFFFFF);      /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
    static const uint32_t SDMMCX_IDMACTRLR_IDMAEN_MASK = UINT32_C(0x00000001);      /** @brief IDMA enable this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCX_IDMACTRLR_IDMABMODE_MASK = UINT32_C(0x00000002);   /** @brief Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCX_IDMACTRLR_IDMABACT_MASK = UINT32_C(0x00000004);    /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
    static const uint32_t SDMMCX_IDMABSIZER_IDMABNDT_MASK = UINT32_C(0x00001FE0);   /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const uint32_t SDMMCX_RESPCMDR_RESPCMD_MASK = UINT32_C(0x0000003F);      /** @brief Response command index */

    /** @subsection SDMMCX field position definitions */

    static const int32_t SDMMCX_RESPCMDR_PWRCTRL_POS = INT32_C(0);         /** @brief SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: any further write will be ignored, PWRCTRL value will keep 11. */
    static const int32_t SDMMCX_RESPCMDR_VSWITCH_POS = INT32_C(2);         /** @brief Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence: */
    static const int32_t SDMMCX_RESPCMDR_VSWITCHEN_POS = INT32_C(3);       /** @brief Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response: */
    static const int32_t SDMMCX_RESPCMDR_DIRPOL_POS = INT32_C(4);          /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
    static const int32_t SDMMCX_RESPCMDR_CLKDIV_POS = INT32_C(0);          /** @brief Clock divide factor this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. Xxx: etc.. */
    static const int32_t SDMMCX_RESPCMDR_PWRSAV_POS = INT32_C(12);         /** @brief Power saving configuration bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) for power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV: */
    static const int32_t SDMMCX_RESPCMDR_WIDBUS_POS = INT32_C(14);         /** @brief Wide bus mode enable bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const int32_t SDMMCX_RESPCMDR_NEGEDGE_POS = INT32_C(16);        /** @brief SDMMC_CK dephasing selection bit for data and command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. */
    static const int32_t SDMMCX_RESPCMDR_HWFC_EN_POS = INT32_C(17);        /** @brief Hardware flow control enable this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) when hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in section56.8.11. */
    static const int32_t SDMMCX_RESPCMDR_DDR_POS = INT32_C(18);            /** @brief Data rate signaling selection this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0) */
    static const int32_t SDMMCX_RESPCMDR_BUSSPEED_POS = INT32_C(19);       /** @brief Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const int32_t SDMMCX_RESPCMDR_SELCLKRX_POS = INT32_C(20);       /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    static const int32_t SDMMCX_RESPCMDR_CMDINDEX_POS = INT32_C(0);        /** @brief Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. */
    static const int32_t SDMMCX_RESPCMDR_CMDTRANS_POS = INT32_C(6);        /** @brief The CPSM treats the command as a data transfer command, stops the interrupt period, and signals dataenable to the DPSM this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues dataenable signal to the DPSM when the command is sent. */
    static const int32_t SDMMCX_RESPCMDR_CMDSTOP_POS = INT32_C(7);         /** @brief The CPSM treats the command as a stop transmission command and signals abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the abort signal to the DPSM when the command is sent. */
    static const int32_t SDMMCX_RESPCMDR_WAITRESP_POS = INT32_C(8);        /** @brief Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. */
    static const int32_t SDMMCX_RESPCMDR_WAITINT_POS = INT32_C(10);        /** @brief CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (response). If this bit is cleared in the CPSM wait state, will cause the abort of the interrupt mode. */
    static const int32_t SDMMCX_RESPCMDR_WAITPEND_POS = INT32_C(11);       /** @brief CPSM waits for end of data transfer (cmdpend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card. */
    static const int32_t SDMMCX_RESPCMDR_CPSMEN_POS = INT32_C(12);         /** @brief Command path state machine (CPSM) enable bit this bit is written 1 by firmware, and cleared by hardware when the CPSM enters the idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0. */
    static const int32_t SDMMCX_RESPCMDR_DTHOLD_POS = INT32_C(13);         /** @brief Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the wait_s state to the send state or from the wait_r state to the receive state. */
    static const int32_t SDMMCX_RESPCMDR_BOOTMODE_POS = INT32_C(14);       /** @brief Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0) */
    static const int32_t SDMMCX_RESPCMDR_BOOTEN_POS = INT32_C(15);         /** @brief Enable boot mode procedure. */
    static const int32_t SDMMCX_RESPCMDR_CMDSUSPEND_POS = INT32_C(16);     /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
    static const int32_t SDMMCX_RESPCMDR_DATALENGTH_POS = INT32_C(0);      /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
    static const int32_t SDMMCX_RESPCMDR_DTEN_POS = INT32_C(0);            /** @brief Data transfer enable bit this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. Shall not be used with SD or emmc cards. */
    static const int32_t SDMMCX_RESPCMDR_DTDIR_POS = INT32_C(1);           /** @brief Data transfer direction selection this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCX_RESPCMDR_DTMODE_POS = INT32_C(2);          /** @brief Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCX_RESPCMDR_DBLOCKSIZE_POS = INT32_C(4);      /** @brief Data block size this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: when DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) when DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) */
    static const int32_t SDMMCX_RESPCMDR_RWSTART_POS = INT32_C(8);         /** @brief Read wait start. If this bit is set, read wait operation starts. */
    static const int32_t SDMMCX_RESPCMDR_RWSTOP_POS = INT32_C(9);          /** @brief Read wait stop this bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state. */
    static const int32_t SDMMCX_RESPCMDR_RWMOD_POS = INT32_C(10);          /** @brief Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCX_RESPCMDR_SDIOEN_POS = INT32_C(11);         /** @brief SD I/O interrupt enable functions this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation. */
    static const int32_t SDMMCX_RESPCMDR_BOOTACKEN_POS = INT32_C(12);      /** @brief Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCX_RESPCMDR_FIFORST_POS = INT32_C(13);        /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
    static const int32_t SDMMCX_RESPCMDR_DATACOUNT_POS = INT32_C(0);       /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
    static const int32_t SDMMCX_RESPCMDR_CCRCFAIL_POS = INT32_C(0);        /** @brief Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_DCRCFAIL_POS = INT32_C(1);        /** @brief Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_CTIMEOUT_POS = INT32_C(2);        /** @brief Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The command timeout period has a fixed value of 64 SDMMC_CK clock periods. */
    static const int32_t SDMMCX_RESPCMDR_DTIMEOUT_POS = INT32_C(3);        /** @brief Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_TXUNDERR_POS = INT32_C(4);        /** @brief Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_RXOVERR_POS = INT32_C(5);         /** @brief Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_CMDREND_POS = INT32_C(6);         /** @brief Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_CMDSENT_POS = INT32_C(7);         /** @brief Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_DATAEND_POS = INT32_C(8);         /** @brief Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_DHOLD_POS = INT32_C(9);           /** @brief Data transfer hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_DBCKEND_POS = INT32_C(10);        /** @brief Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_DABORT_POS = INT32_C(11);         /** @brief Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_DPSMACT_POS = INT32_C(12);        /** @brief Data path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const int32_t SDMMCX_RESPCMDR_CPSMACT_POS = INT32_C(13);        /** @brief Command path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
    static const int32_t SDMMCX_RESPCMDR_TXFIFOHE_POS = INT32_C(14);       /** @brief Transmit FIFO half empty at least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full. */
    static const int32_t SDMMCX_RESPCMDR_RXFIFOHF_POS = INT32_C(15);       /** @brief Receive FIFO half full there are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty. */
    static const int32_t SDMMCX_RESPCMDR_TXFIFOF_POS = INT32_C(16);        /** @brief Transmit FIFO full this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty. */
    static const int32_t SDMMCX_RESPCMDR_RXFIFOF_POS = INT32_C(17);        /** @brief Receive FIFO full this bit is cleared when one FIFO location becomes empty. */
    static const int32_t SDMMCX_RESPCMDR_TXFIFOE_POS = INT32_C(18);        /** @brief Transmit FIFO empty this bit is cleared when one FIFO location becomes full. */
    static const int32_t SDMMCX_RESPCMDR_RXFIFOE_POS = INT32_C(19);        /** @brief Receive FIFO empty this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full. */
    static const int32_t SDMMCX_RESPCMDR_BUSYD0_POS = INT32_C(20);         /** @brief Inverted value of SDMMC_D0 line (busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt. */
    static const int32_t SDMMCX_RESPCMDR_BUSYD0END_POS = INT32_C(21);      /** @brief End of SDMMC_D0 busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_SDIOIT_POS = INT32_C(22);         /** @brief SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_ACKFAIL_POS = INT32_C(23);        /** @brief Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_ACKTIMEOUT_POS = INT32_C(24);     /** @brief Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_VSWEND_POS = INT32_C(25);         /** @brief Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_CKSTOP_POS = INT32_C(26);         /** @brief SDMMC_CK stopped in voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_IDMATE_POS = INT32_C(27);         /** @brief IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_IDMABTC_POS = INT32_C(28);        /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    static const int32_t SDMMCX_RESPCMDR_CCRCFAILC_POS = INT32_C(0);       /** @brief CCRCFAIL flag clear bit set by software to clear the CCRCFAIL flag. */
    static const int32_t SDMMCX_RESPCMDR_DCRCFAILC_POS = INT32_C(1);       /** @brief DCRCFAIL flag clear bit set by software to clear the DCRCFAIL flag. */
    static const int32_t SDMMCX_RESPCMDR_CTIMEOUTC_POS = INT32_C(2);       /** @brief CTIMEOUT flag clear bit set by software to clear the CTIMEOUT flag. */
    static const int32_t SDMMCX_RESPCMDR_DTIMEOUTC_POS = INT32_C(3);       /** @brief DTIMEOUT flag clear bit set by software to clear the DTIMEOUT flag. */
    static const int32_t SDMMCX_RESPCMDR_TXUNDERRC_POS = INT32_C(4);       /** @brief TXUNDERR flag clear bit set by software to clear TXUNDERR flag. */
    static const int32_t SDMMCX_RESPCMDR_RXOVERRC_POS = INT32_C(5);        /** @brief RXOVERR flag clear bit set by software to clear the RXOVERR flag. */
    static const int32_t SDMMCX_RESPCMDR_CMDRENDC_POS = INT32_C(6);        /** @brief CMDREND flag clear bit set by software to clear the CMDREND flag. */
    static const int32_t SDMMCX_RESPCMDR_CMDSENTC_POS = INT32_C(7);        /** @brief CMDSENT flag clear bit set by software to clear the CMDSENT flag. */
    static const int32_t SDMMCX_RESPCMDR_DATAENDC_POS = INT32_C(8);        /** @brief DATAEND flag clear bit set by software to clear the DATAEND flag. */
    static const int32_t SDMMCX_RESPCMDR_DHOLDC_POS = INT32_C(9);          /** @brief DHOLD flag clear bit set by software to clear the DHOLD flag. */
    static const int32_t SDMMCX_RESPCMDR_DBCKENDC_POS = INT32_C(10);       /** @brief DBCKEND flag clear bit set by software to clear the DBCKEND flag. */
    static const int32_t SDMMCX_RESPCMDR_DABORTC_POS = INT32_C(11);        /** @brief DABORT flag clear bit set by software to clear the DABORT flag. */
    static const int32_t SDMMCX_RESPCMDR_BUSYD0ENDC_POS = INT32_C(21);     /** @brief BUSYD0END flag clear bit set by software to clear the BUSYD0END flag. */
    static const int32_t SDMMCX_RESPCMDR_SDIOITC_POS = INT32_C(22);        /** @brief SDIOIT flag clear bit set by software to clear the SDIOIT flag. */
    static const int32_t SDMMCX_RESPCMDR_ACKFAILC_POS = INT32_C(23);       /** @brief ACKFAIL flag clear bit set by software to clear the ACKFAIL flag. */
    static const int32_t SDMMCX_RESPCMDR_ACKTIMEOUTC_POS = INT32_C(24);    /** @brief ACKTIMEOUT flag clear bit set by software to clear the ACKTIMEOUT flag. */
    static const int32_t SDMMCX_RESPCMDR_VSWENDC_POS = INT32_C(25);        /** @brief VSWEND flag clear bit set by software to clear the VSWEND flag. */
    static const int32_t SDMMCX_RESPCMDR_CKSTOPC_POS = INT32_C(26);        /** @brief CKSTOP flag clear bit set by software to clear the CKSTOP flag. */
    static const int32_t SDMMCX_RESPCMDR_IDMATEC_POS = INT32_C(27);        /** @brief IDMA transfer error clear bit set by software to clear the IDMATE flag. */
    static const int32_t SDMMCX_RESPCMDR_IDMABTCC_POS = INT32_C(28);       /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
    static const int32_t SDMMCX_RESPCMDR_CCRCFAILIE_POS = INT32_C(0);      /** @brief Command CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by command CRC failure. */
    static const int32_t SDMMCX_RESPCMDR_DCRCFAILIE_POS = INT32_C(1);      /** @brief Data CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by data CRC failure. */
    static const int32_t SDMMCX_RESPCMDR_CTIMEOUTIE_POS = INT32_C(2);      /** @brief Command timeout interrupt enable set and cleared by software to enable/disable interrupt caused by command timeout. */
    static const int32_t SDMMCX_RESPCMDR_DTIMEOUTIE_POS = INT32_C(3);      /** @brief Data timeout interrupt enable set and cleared by software to enable/disable interrupt caused by data timeout. */
    static const int32_t SDMMCX_RESPCMDR_TXUNDERRIE_POS = INT32_C(4);      /** @brief Tx FIFO underrun error interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO underrun error. */
    static const int32_t SDMMCX_RESPCMDR_RXOVERRIE_POS = INT32_C(5);       /** @brief Rx FIFO overrun error interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO overrun error. */
    static const int32_t SDMMCX_RESPCMDR_CMDRENDIE_POS = INT32_C(6);       /** @brief Command response received interrupt enable set and cleared by software to enable/disable interrupt caused by receiving command response. */
    static const int32_t SDMMCX_RESPCMDR_CMDSENTIE_POS = INT32_C(7);       /** @brief Command sent interrupt enable set and cleared by software to enable/disable interrupt caused by sending command. */
    static const int32_t SDMMCX_RESPCMDR_DATAENDIE_POS = INT32_C(8);       /** @brief Data end interrupt enable set and cleared by software to enable/disable interrupt caused by data end. */
    static const int32_t SDMMCX_RESPCMDR_DHOLDIE_POS = INT32_C(9);         /** @brief Data hold interrupt enable set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM wait_s state. */
    static const int32_t SDMMCX_RESPCMDR_DBCKENDIE_POS = INT32_C(10);      /** @brief Data block end interrupt enable set and cleared by software to enable/disable interrupt caused by data block end. */
    static const int32_t SDMMCX_RESPCMDR_DABORTIE_POS = INT32_C(11);       /** @brief Data transfer aborted interrupt enable set and cleared by software to enable/disable interrupt caused by a data transfer being aborted. */
    static const int32_t SDMMCX_RESPCMDR_TXFIFOHEIE_POS = INT32_C(14);     /** @brief Tx FIFO half empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO half empty. */
    static const int32_t SDMMCX_RESPCMDR_RXFIFOHFIE_POS = INT32_C(15);     /** @brief Rx FIFO half full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO half full. */
    static const int32_t SDMMCX_RESPCMDR_RXFIFOFIE_POS = INT32_C(17);      /** @brief Rx FIFO full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO full. */
    static const int32_t SDMMCX_RESPCMDR_TXFIFOEIE_POS = INT32_C(18);      /** @brief Tx FIFO empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO empty. */
    static const int32_t SDMMCX_RESPCMDR_BUSYD0ENDIE_POS = INT32_C(21);    /** @brief BUSYD0END interrupt enable set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response. */
    static const int32_t SDMMCX_RESPCMDR_SDIOITIE_POS = INT32_C(22);       /** @brief SDIO mode interrupt received interrupt enable set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt. */
    static const int32_t SDMMCX_RESPCMDR_ACKFAILIE_POS = INT32_C(23);      /** @brief Acknowledgment fail interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment fail. */
    static const int32_t SDMMCX_RESPCMDR_ACKTIMEOUTIE_POS = INT32_C(24);   /** @brief Acknowledgment timeout interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment timeout. */
    static const int32_t SDMMCX_RESPCMDR_VSWENDIE_POS = INT32_C(25);       /** @brief Voltage switch critical timing section completion interrupt enable set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion. */
    static const int32_t SDMMCX_RESPCMDR_CKSTOPIE_POS = INT32_C(26);       /** @brief Voltage switch clock stopped interrupt enable set and cleared by software to enable/disable interrupt caused by voltage switch clock stopped. */
    static const int32_t SDMMCX_RESPCMDR_IDMABTCIE_POS = INT32_C(28);      /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
    static const int32_t SDMMCX_RESPCMDR_ACKTIME_POS = INT32_C(0);         /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
    static const int32_t SDMMCX_RESPCMDR_IDMAEN_POS = INT32_C(0);          /** @brief IDMA enable this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCX_RESPCMDR_IDMABMODE_POS = INT32_C(1);       /** @brief Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCX_RESPCMDR_IDMABACT_POS = INT32_C(2);        /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
    static const int32_t SDMMCX_RESPCMDR_IDMABNDT_POS = INT32_C(5);        /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    static const int32_t SDMMCX_RESPCMDR_RESPCMD_POS = INT32_C(0);         /** @brief Response command index */

    /**********************************************************************************************
     * @section VREFBUF Definitions
     **********************************************************************************************/

    /** @subsection VREFBUF register definitions */

    static _RW uint32_t* const VREFBUF_CSR_REG = (_RW uint32_t* const)UINT32_C(0x58003C00);   /** @brief VREFBUF control and status register */
    static _RW uint32_t* const VREFBUF_CCR_REG = (_RW uint32_t* const)UINT32_C(0x58003C04);   /** @brief VREFBUF calibration control register */

    /** @subsection VREFBUF field mask definitions */

    static const uint32_t VREFBUF_CSR_ENVR_MASK = UINT32_C(0x00000001);   /** @brief Voltage reference buffer mode enable this bit is used to enable the voltage reference buffer mode. */
    static const uint32_t VREFBUF_CSR_HIZ_MASK = UINT32_C(0x00000002);    /** @brief High impedance mode this bit controls the analog switch to connect or not the VREF+ pin. Refer to table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration. */
    static const uint32_t VREFBUF_CSR_VRR_MASK = UINT32_C(0x00000008);    /** @brief Voltage reference buffer ready */
    static const uint32_t VREFBUF_CSR_VRS_MASK = UINT32_C(0x00000070);    /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved */
    static const uint32_t VREFBUF_CCR_TRIM_MASK = UINT32_C(0x0000003F);   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

    /** @subsection VREFBUF field position definitions */

    static const int32_t VREFBUF_CCR_ENVR_POS = INT32_C(0);   /** @brief Voltage reference buffer mode enable this bit is used to enable the voltage reference buffer mode. */
    static const int32_t VREFBUF_CCR_HIZ_POS = INT32_C(1);    /** @brief High impedance mode this bit controls the analog switch to connect or not the VREF+ pin. Refer to table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration. */
    static const int32_t VREFBUF_CCR_VRR_POS = INT32_C(3);    /** @brief Voltage reference buffer ready */
    static const int32_t VREFBUF_CCR_VRS_POS = INT32_C(4);    /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved */
    static const int32_t VREFBUF_CCR_TRIM_POS = INT32_C(0);   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

    /**********************************************************************************************
     * @section IWDGX Definitions
     **********************************************************************************************/

    /** @subsection IWDGX register array definitions */

    static _RW uint32_t* const IWDGX_KR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58004800),   /** @brief Key register */
      (_RW uint32_t* const)UINT32_C(0x58004C00),   /** @brief Key register */
    };

    static _RW uint32_t* const IWDGX_PR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58004804),   /** @brief Prescaler register */
      (_RW uint32_t* const)UINT32_C(0x58004C04),   /** @brief Prescaler register */
    };

    static _RW uint32_t* const IWDGX_RLR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58004808),   /** @brief Reload register */
      (_RW uint32_t* const)UINT32_C(0x58004C08),   /** @brief Reload register */
    };

    static _RO uint32_t* const IWDGX_SR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x5800480C),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x58004C0C),   /** @brief Status register */
    };

    static _RW uint32_t* const IWDGX_WINR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58004810),   /** @brief Window register */
      (_RW uint32_t* const)UINT32_C(0x58004C10),   /** @brief Window register */
    };

    /** @subsection IWDGX field mask definitions */

    static const uint32_t IWDGX_KR_KEY_MASK = UINT32_C(0x0000FFFF);     /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
    static const uint32_t IWDGX_PR_PR_MASK = UINT32_C(0x00000007);      /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
    static const uint32_t IWDGX_RLR_RL_MASK = UINT32_C(0x00000FFF);     /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
    static const uint32_t IWDGX_SR_PVU_MASK = UINT32_C(0x00000001);     /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
    static const uint32_t IWDGX_SR_RVU_MASK = UINT32_C(0x00000002);     /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
    static const uint32_t IWDGX_SR_WVU_MASK = UINT32_C(0x00000004);     /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
    static const uint32_t IWDGX_WINR_WIN_MASK = UINT32_C(0x00000FFF);   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

    /** @subsection IWDGX field position definitions */

    static const int32_t IWDGX_WINR_KEY_POS = INT32_C(0);   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
    static const int32_t IWDGX_WINR_PR_POS = INT32_C(0);    /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
    static const int32_t IWDGX_WINR_RL_POS = INT32_C(0);    /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
    static const int32_t IWDGX_WINR_PVU_POS = INT32_C(0);   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
    static const int32_t IWDGX_WINR_RVU_POS = INT32_C(1);   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
    static const int32_t IWDGX_WINR_WVU_POS = INT32_C(2);   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
    static const int32_t IWDGX_WINR_WIN_POS = INT32_C(0);   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

    /**********************************************************************************************
     * @section WWDGX Definitions
     **********************************************************************************************/

    /** @subsection WWDGX IRQ interrupt definitions */

    static const int32_t WWDG1_IRQ = INT32_C(0);   /** @brief Window watchdog interrupt */

    /** @subsection WWDGX register array definitions */

    static _RW uint32_t* const WWDGX_CR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x50003000),   /** @brief Control register */
      (_RW uint32_t* const)UINT32_C(0x40002C00),   /** @brief Control register */
    };

    static _RW uint32_t* const WWDGX_CFR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x50003004),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x40002C04),   /** @brief Configuration register */
    };

    static _RW uint32_t* const WWDGX_SR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x50003008),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40002C08),   /** @brief Status register */
    };

    /** @subsection WWDGX field mask definitions */

    static const uint32_t WWDGX_CR_T_MASK = UINT32_C(0x0000007F);        /** @brief 7-bit counter (MSB to LSB) these bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3f (T6 becomes cleared). */
    static const uint32_t WWDGX_CR_WDGA_MASK = UINT32_C(0x00000080);     /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
    static const uint32_t WWDGX_CFR_W_MASK = UINT32_C(0x0000007F);       /** @brief 7-bit window value these bits contain the window value to be compared to the downcounter. */
    static const uint32_t WWDGX_CFR_WDGTB_MASK = UINT32_C(0x00001800);   /** @brief Timer base the time base of the prescaler can be modified as follows: */
    static const uint32_t WWDGX_CFR_EWI_MASK = UINT32_C(0x00000200);     /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
    static const uint32_t WWDGX_SR_EWIF_MASK = UINT32_C(0x00000001);     /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */

    /** @subsection WWDGX field position definitions */

    static const int32_t WWDGX_SR_T_POS = INT32_C(0);        /** @brief 7-bit counter (MSB to LSB) these bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3f (T6 becomes cleared). */
    static const int32_t WWDGX_SR_WDGA_POS = INT32_C(7);     /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
    static const int32_t WWDGX_SR_W_POS = INT32_C(0);        /** @brief 7-bit window value these bits contain the window value to be compared to the downcounter. */
    static const int32_t WWDGX_SR_WDGTB_POS = INT32_C(11);   /** @brief Timer base the time base of the prescaler can be modified as follows: */
    static const int32_t WWDGX_SR_EWI_POS = INT32_C(9);      /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
    static const int32_t WWDGX_SR_EWIF_POS = INT32_C(0);     /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */

    /**********************************************************************************************
     * @section PWR Definitions
     **********************************************************************************************/

    /** @subsection PWR register definitions */

    static _RW uint32_t* const PWR_CR1_REG = (_RW uint32_t* const)UINT32_C(0x58024800);       /** @brief PWR control register 1 */
    static _RO uint32_t* const PWR_CSR1_REG = (_RO uint32_t* const)UINT32_C(0x58024804);      /** @brief PWR control status register 1 */
    static _RW uint32_t* const PWR_CR2_REG = (_RW uint32_t* const)UINT32_C(0x58024808);       /** @brief This register is not reset by wakeup from standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.after reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection. */
    static _RW uint32_t* const PWR_CR3_REG = (_RW uint32_t* const)UINT32_C(0x5802480C);       /** @brief Reset only by POR only, not reset by wakeup from standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value. */
    static _RW uint32_t* const PWR_CPUCR_REG = (_RW uint32_t* const)UINT32_C(0x58024810);     /** @brief This register allows controlling CPU1 power. */
    static _RW uint32_t* const PWR_D3CR_REG = (_RW uint32_t* const)UINT32_C(0x58024818);      /** @brief This register allows controlling D3 domain power.following reset VOSRDY will be read 1 by software */
    static _RW uint32_t* const PWR_WKUPCR_REG = (_RW uint32_t* const)UINT32_C(0x58024820);    /** @brief Reset only by system reset, not reset by wakeup from standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared). */
    static _RW uint32_t* const PWR_WKUPFR_REG = (_RW uint32_t* const)UINT32_C(0x58024824);    /** @brief Reset only by system reset, not reset by wakeup from standby mode */
    static _RW uint32_t* const PWR_WKUPEPR_REG = (_RW uint32_t* const)UINT32_C(0x58024828);   /** @brief Reset only by system reset, not reset by wakeup from standby mode */

    /** @subsection PWR field mask array definitions */

    static const uint32_t PWR_CPUCR_PDDS_DX_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief D1 domain power down deepsleep selection. This bit allows CPU1 to define the deepsleep mode for D1 domain. */
      UINT32_C(0x00000002),   /** @brief D2 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for D2 domain. */
      UINT32_C(0x00000004),   /** @brief System D3 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for system D3 domain. */
    };

    static const uint32_t PWR_WKUPFR_WKUPFX_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      UINT32_C(0x00000002),   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      UINT32_C(0x00000004),   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      UINT32_C(0x00000008),   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      UINT32_C(0x00000010),   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      UINT32_C(0x00000020),   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    };

    static const uint32_t PWR_WKUPEPR_WKUPENX_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      UINT32_C(0x00000002),   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      UINT32_C(0x00000004),   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      UINT32_C(0x00000008),   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      UINT32_C(0x00000010),   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      UINT32_C(0x00000020),   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    };

    static const uint32_t PWR_WKUPEPR_WKUPPX_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      UINT32_C(0x00000200),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      UINT32_C(0x00000400),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      UINT32_C(0x00000800),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      UINT32_C(0x00001000),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      UINT32_C(0x00002000),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    };

    static const uint32_t PWR_WKUPEPR_WKUPPUPDX_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00030000),   /** @brief Wakeup pin pull configuration */
      UINT32_C(0x000C0000),   /** @brief Wakeup pin pull configuration */
      UINT32_C(0x00300000),   /** @brief Wakeup pin pull configuration */
      UINT32_C(0x00C00000),   /** @brief Wakeup pin pull configuration */
      UINT32_C(0x03000000),   /** @brief Wakeup pin pull configuration */
      UINT32_C(0x0C000000),   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
    };

    /** @subsection PWR field mask definitions */

    static const uint32_t PWR_CR1_LPDS_MASK = UINT32_C(0x00000001);         /** @brief Low-power deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit) */
    static const uint32_t PWR_CR1_PVDE_MASK = UINT32_C(0x00000010);         /** @brief Programmable voltage detector enable */
    static const uint32_t PWR_CR1_PLS_MASK = UINT32_C(0x000000E0);          /** @brief Programmable voltage detector level selection these bits select the voltage threshold detected by the PVD. Note: refer to section electrical characteristics of the product datasheet for more details. */
    static const uint32_t PWR_CR1_DBP_MASK = UINT32_C(0x00000100);          /** @brief Disable backup domain write protection in reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers. */
    static const uint32_t PWR_CR1_FLPS_MASK = UINT32_C(0x00000200);         /** @brief Flash low-power mode in dstop mode this bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from dstop mode. When it is set, the flash memory enters low-power mode when D1 domain is in dstop mode. */
    static const uint32_t PWR_CR1_SVOS_MASK = UINT32_C(0x0000C000);         /** @brief System stop mode voltage scaling selection these bits control the VCORE voltage level in system stop mode, to obtain the best trade-off between power consumption and performance. */
    static const uint32_t PWR_CR1_AVDEN_MASK = UINT32_C(0x00010000);        /** @brief Peripheral voltage monitor on VDDA enable */
    static const uint32_t PWR_CR1_ALS_MASK = UINT32_C(0x00060000);          /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
    static const uint32_t PWR_CSR1_PVDO_MASK = UINT32_C(0x00000010);        /** @brief Programmable voltage detect output this bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the PVDE bit is set. */
    static const uint32_t PWR_CSR1_ACTVOSRDY_MASK = UINT32_C(0x00002000);   /** @brief Voltage levels ready bit for currently used VOS and SDLEVEL this bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const uint32_t PWR_CSR1_ACTVOS_MASK = UINT32_C(0x0000C000);      /** @brief VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. */
    static const uint32_t PWR_CSR1_AVDO_MASK = UINT32_C(0x00010000);        /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
    static const uint32_t PWR_CR2_BREN_MASK = UINT32_C(0x00000001);         /** @brief Backup regulator enable when set, the backup regulator (used to maintain the backup RAM content in standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in run and stop modes. However, its content will be lost in standby and VBAT modes. If BREN is set, the application must wait till the backup regulator ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in standby and VBAT modes. */
    static const uint32_t PWR_CR2_MONEN_MASK = UINT32_C(0x00000010);        /** @brief VBAT and temperature monitoring enable when set, the VBAT supply and temperature monitoring is enabled. */
    static const uint32_t PWR_CR2_BRRDY_MASK = UINT32_C(0x00010000);        /** @brief Backup regulator ready this bit is set by hardware to indicate that the backup regulator is ready. */
    static const uint32_t PWR_CR2_VBATL_MASK = UINT32_C(0x00100000);        /** @brief VBAT level monitoring versus low threshold */
    static const uint32_t PWR_CR2_VBATH_MASK = UINT32_C(0x00200000);        /** @brief VBAT level monitoring versus high threshold */
    static const uint32_t PWR_CR2_TEMPL_MASK = UINT32_C(0x00400000);        /** @brief Temperature level monitoring versus low threshold */
    static const uint32_t PWR_CR2_TEMPH_MASK = UINT32_C(0x00800000);        /** @brief Temperature level monitoring versus high threshold */
    static const uint32_t PWR_CR3_BYPASS_MASK = UINT32_C(0x00000001);       /** @brief Power management unit bypass */
    static const uint32_t PWR_CR3_LDOEN_MASK = UINT32_C(0x00000002);        /** @brief Low drop-out regulator enable */
    static const uint32_t PWR_CR3_SDEN_MASK = UINT32_C(0x00000004);         /** @brief SD converter enable */
    static const uint32_t PWR_CR3_VBE_MASK = UINT32_C(0x00000100);          /** @brief VBAT charging enable */
    static const uint32_t PWR_CR3_VBRS_MASK = UINT32_C(0x00000200);         /** @brief VBAT charging resistor selection */
    static const uint32_t PWR_CR3_USB33DEN_MASK = UINT32_C(0x01000000);     /** @brief VDD33USB voltage level detector enable. */
    static const uint32_t PWR_CR3_USBREGEN_MASK = UINT32_C(0x02000000);     /** @brief USB regulator enable. */
    static const uint32_t PWR_CR3_USB33RDY_MASK = UINT32_C(0x04000000);     /** @brief USB supply ready. */
    static const uint32_t PWR_CPUCR_STOPF_MASK = UINT32_C(0x00000020);      /** @brief STOP flag this bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit. */
    static const uint32_t PWR_CPUCR_SBF_MASK = UINT32_C(0x00000040);        /** @brief System standby flag this bit is set by hardware and cleared only by a POR (power-on reset) or by setting the CPU1 CSSF bit */
    static const uint32_t PWR_CPUCR_SBF_D1_MASK = UINT32_C(0x00000080);     /** @brief D1 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in dstandby mode. */
    static const uint32_t PWR_CPUCR_SBF_D2_MASK = UINT32_C(0x00000100);     /** @brief D2 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in dstandby mode. */
    static const uint32_t PWR_CPUCR_CSSF_MASK = UINT32_C(0x00000200);       /** @brief Clear D1 domain CPU1 standby, stop and HOLD flags (always read as 0) this bit is cleared to 0 by hardware. */
    static const uint32_t PWR_CPUCR_RUN_D3_MASK = UINT32_C(0x00000800);     /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes */
    static const uint32_t PWR_D3CR_VOSRDY_MASK = UINT32_C(0x00002000);      /** @brief VOS ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const uint32_t PWR_D3CR_VOS_MASK = UINT32_C(0x0000C000);         /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
    static const uint32_t PWR_WKUPCR_WKUPC_MASK = UINT32_C(0x0000003F);     /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

    /** @subsection PWR field position array definitions */

    static const int32_t PWR_WKUPEPR_PDDS_DX_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief D1 domain power down deepsleep selection. This bit allows CPU1 to define the deepsleep mode for D1 domain. */
      INT32_C(1),    /** @brief D2 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for D2 domain. */
      INT32_C(2),    /** @brief System D3 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for system D3 domain. */
    };

    static const int32_t PWR_WKUPEPR_WKUPFX_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      INT32_C(1),    /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      INT32_C(2),    /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      INT32_C(3),    /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      INT32_C(4),    /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      INT32_C(5),    /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    };

    static const int32_t PWR_WKUPEPR_WKUPENX_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      INT32_C(1),    /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      INT32_C(2),    /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      INT32_C(3),    /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      INT32_C(4),    /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
      INT32_C(5),    /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    };

    static const int32_t PWR_WKUPEPR_WKUPPX_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      INT32_C(9),    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      INT32_C(10),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      INT32_C(11),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      INT32_C(12),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
      INT32_C(13),   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    };

    static const int32_t PWR_WKUPEPR_WKUPPUPDX_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief Wakeup pin pull configuration */
      INT32_C(18),   /** @brief Wakeup pin pull configuration */
      INT32_C(20),   /** @brief Wakeup pin pull configuration */
      INT32_C(22),   /** @brief Wakeup pin pull configuration */
      INT32_C(24),   /** @brief Wakeup pin pull configuration */
      INT32_C(26),   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
    };

    /** @subsection PWR field position definitions */

    static const int32_t PWR_WKUPEPR_LPDS_POS = INT32_C(0);         /** @brief Low-power deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit) */
    static const int32_t PWR_WKUPEPR_PVDE_POS = INT32_C(4);         /** @brief Programmable voltage detector enable */
    static const int32_t PWR_WKUPEPR_PLS_POS = INT32_C(5);          /** @brief Programmable voltage detector level selection these bits select the voltage threshold detected by the PVD. Note: refer to section electrical characteristics of the product datasheet for more details. */
    static const int32_t PWR_WKUPEPR_DBP_POS = INT32_C(8);          /** @brief Disable backup domain write protection in reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers. */
    static const int32_t PWR_WKUPEPR_FLPS_POS = INT32_C(9);         /** @brief Flash low-power mode in dstop mode this bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from dstop mode. When it is set, the flash memory enters low-power mode when D1 domain is in dstop mode. */
    static const int32_t PWR_WKUPEPR_SVOS_POS = INT32_C(14);        /** @brief System stop mode voltage scaling selection these bits control the VCORE voltage level in system stop mode, to obtain the best trade-off between power consumption and performance. */
    static const int32_t PWR_WKUPEPR_AVDEN_POS = INT32_C(16);       /** @brief Peripheral voltage monitor on VDDA enable */
    static const int32_t PWR_WKUPEPR_ALS_POS = INT32_C(17);         /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
    static const int32_t PWR_WKUPEPR_PVDO_POS = INT32_C(4);         /** @brief Programmable voltage detect output this bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the PVDE bit is set. */
    static const int32_t PWR_WKUPEPR_ACTVOSRDY_POS = INT32_C(13);   /** @brief Voltage levels ready bit for currently used VOS and SDLEVEL this bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const int32_t PWR_WKUPEPR_ACTVOS_POS = INT32_C(14);      /** @brief VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. */
    static const int32_t PWR_WKUPEPR_AVDO_POS = INT32_C(16);        /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
    static const int32_t PWR_WKUPEPR_BREN_POS = INT32_C(0);         /** @brief Backup regulator enable when set, the backup regulator (used to maintain the backup RAM content in standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in run and stop modes. However, its content will be lost in standby and VBAT modes. If BREN is set, the application must wait till the backup regulator ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in standby and VBAT modes. */
    static const int32_t PWR_WKUPEPR_MONEN_POS = INT32_C(4);        /** @brief VBAT and temperature monitoring enable when set, the VBAT supply and temperature monitoring is enabled. */
    static const int32_t PWR_WKUPEPR_BRRDY_POS = INT32_C(16);       /** @brief Backup regulator ready this bit is set by hardware to indicate that the backup regulator is ready. */
    static const int32_t PWR_WKUPEPR_VBATL_POS = INT32_C(20);       /** @brief VBAT level monitoring versus low threshold */
    static const int32_t PWR_WKUPEPR_VBATH_POS = INT32_C(21);       /** @brief VBAT level monitoring versus high threshold */
    static const int32_t PWR_WKUPEPR_TEMPL_POS = INT32_C(22);       /** @brief Temperature level monitoring versus low threshold */
    static const int32_t PWR_WKUPEPR_TEMPH_POS = INT32_C(23);       /** @brief Temperature level monitoring versus high threshold */
    static const int32_t PWR_WKUPEPR_BYPASS_POS = INT32_C(0);       /** @brief Power management unit bypass */
    static const int32_t PWR_WKUPEPR_LDOEN_POS = INT32_C(1);        /** @brief Low drop-out regulator enable */
    static const int32_t PWR_WKUPEPR_SDEN_POS = INT32_C(2);         /** @brief SD converter enable */
    static const int32_t PWR_WKUPEPR_VBE_POS = INT32_C(8);          /** @brief VBAT charging enable */
    static const int32_t PWR_WKUPEPR_VBRS_POS = INT32_C(9);         /** @brief VBAT charging resistor selection */
    static const int32_t PWR_WKUPEPR_USB33DEN_POS = INT32_C(24);    /** @brief VDD33USB voltage level detector enable. */
    static const int32_t PWR_WKUPEPR_USBREGEN_POS = INT32_C(25);    /** @brief USB regulator enable. */
    static const int32_t PWR_WKUPEPR_USB33RDY_POS = INT32_C(26);    /** @brief USB supply ready. */
    static const int32_t PWR_WKUPEPR_STOPF_POS = INT32_C(5);        /** @brief STOP flag this bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit. */
    static const int32_t PWR_WKUPEPR_SBF_POS = INT32_C(6);          /** @brief System standby flag this bit is set by hardware and cleared only by a POR (power-on reset) or by setting the CPU1 CSSF bit */
    static const int32_t PWR_WKUPEPR_SBF_D1_POS = INT32_C(7);       /** @brief D1 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in dstandby mode. */
    static const int32_t PWR_WKUPEPR_SBF_D2_POS = INT32_C(8);       /** @brief D2 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in dstandby mode. */
    static const int32_t PWR_WKUPEPR_CSSF_POS = INT32_C(9);         /** @brief Clear D1 domain CPU1 standby, stop and HOLD flags (always read as 0) this bit is cleared to 0 by hardware. */
    static const int32_t PWR_WKUPEPR_RUN_D3_POS = INT32_C(11);      /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes */
    static const int32_t PWR_WKUPEPR_VOSRDY_POS = INT32_C(13);      /** @brief VOS ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when bypass mode is selected in PWR control register 3 (PWR_CR3). */
    static const int32_t PWR_WKUPEPR_VOS_POS = INT32_C(14);         /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
    static const int32_t PWR_WKUPEPR_WKUPC_POS = INT32_C(0);        /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

    /**********************************************************************************************
     * @section SPIX Definitions
     **********************************************************************************************/

    /** @subsection SPIX IRQ interrupt array definitions */

    static const int32_t SPIX_IRQ[7] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(35),    /** @brief SPI1 global interrupt */
      INT32_C(36),    /** @brief SPI2 global interrupt */
      INT32_C(51),    /** @brief SPI3 global interrupt */
      INT32_C(84),    /** @brief SPI4 global interrupt */
      INT32_C(85),    /** @brief SPI5 global interrupt */
      INT32_C(86),    /** @brief SPI6 global interrupt */
    };

    /** @subsection SPIX register array definitions */

    static _RW uint32_t* const SPIX_CR1_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013000),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40003800),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40003C00),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40013400),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40015000),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x58001400),   /** @brief Control register 1 */
    };

    static _RW uint32_t* const SPIX_CR2_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013004),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40003804),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40003C04),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40013404),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40015004),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x58001404),   /** @brief Control register 2 */
    };

    static _RW uint32_t* const SPIX_CFG1_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013008),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40003808),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40003C08),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40013408),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x40015008),   /** @brief Configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x58001408),   /** @brief Configuration register 1 */
    };

    static _RW uint32_t* const SPIX_CFG2_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001300C),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x4000380C),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x40003C0C),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x4001340C),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x4001500C),   /** @brief Configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x5800140C),   /** @brief Configuration register 2 */
    };

    static _RW uint32_t* const SPIX_IER_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013010),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x40003810),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x40003C10),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x40013410),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x40015010),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x58001410),   /** @brief Interrupt enable register */
    };

    static _RO uint32_t* const SPIX_SR_REG[7] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40013014),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40003814),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40003C14),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40013414),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x40015014),   /** @brief Status register */
      (_RO uint32_t* const)UINT32_C(0x58001414),   /** @brief Status register */
    };

    static _RW uint32_t* const SPIX_IFCR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013018),   /** @brief Interrupt/Status flags clear register */
      (_RW uint32_t* const)UINT32_C(0x40003818),   /** @brief Interrupt/Status flags clear register */
      (_RW uint32_t* const)UINT32_C(0x40003C18),   /** @brief Interrupt/Status flags clear register */
      (_RW uint32_t* const)UINT32_C(0x40013418),   /** @brief Interrupt/Status flags clear register */
      (_RW uint32_t* const)UINT32_C(0x40015018),   /** @brief Interrupt/Status flags clear register */
      (_RW uint32_t* const)UINT32_C(0x58001418),   /** @brief Interrupt/Status flags clear register */
    };

    static _RW uint32_t* const SPIX_TXDR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013020),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40003820),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40003C20),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40013420),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40015020),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x58001420),   /** @brief Transmit data register */
    };

    static _RO uint32_t* const SPIX_RXDR_REG[7] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40013030),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40003830),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40003C30),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40013430),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40015030),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x58001430),   /** @brief Receive data register */
    };

    static _RW uint32_t* const SPIX_CRCPOLY_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013040),   /** @brief Polynomial register */
      (_RW uint32_t* const)UINT32_C(0x40003840),   /** @brief Polynomial register */
      (_RW uint32_t* const)UINT32_C(0x40003C40),   /** @brief Polynomial register */
      (_RW uint32_t* const)UINT32_C(0x40013440),   /** @brief Polynomial register */
      (_RW uint32_t* const)UINT32_C(0x40015040),   /** @brief Polynomial register */
      (_RW uint32_t* const)UINT32_C(0x58001440),   /** @brief Polynomial register */
    };

    static _RW uint32_t* const SPIX_TXCRC_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013044),   /** @brief Transmitter CRC register */
      (_RW uint32_t* const)UINT32_C(0x40003844),   /** @brief Transmitter CRC register */
      (_RW uint32_t* const)UINT32_C(0x40003C44),   /** @brief Transmitter CRC register */
      (_RW uint32_t* const)UINT32_C(0x40013444),   /** @brief Transmitter CRC register */
      (_RW uint32_t* const)UINT32_C(0x40015044),   /** @brief Transmitter CRC register */
      (_RW uint32_t* const)UINT32_C(0x58001444),   /** @brief Transmitter CRC register */
    };

    static _RW uint32_t* const SPIX_RXCRC_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013048),   /** @brief Receiver CRC register */
      (_RW uint32_t* const)UINT32_C(0x40003848),   /** @brief Receiver CRC register */
      (_RW uint32_t* const)UINT32_C(0x40003C48),   /** @brief Receiver CRC register */
      (_RW uint32_t* const)UINT32_C(0x40013448),   /** @brief Receiver CRC register */
      (_RW uint32_t* const)UINT32_C(0x40015048),   /** @brief Receiver CRC register */
      (_RW uint32_t* const)UINT32_C(0x58001448),   /** @brief Receiver CRC register */
    };

    static _RW uint32_t* const SPIX_UDRDR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001304C),   /** @brief Underrun data register */
      (_RW uint32_t* const)UINT32_C(0x4000384C),   /** @brief Underrun data register */
      (_RW uint32_t* const)UINT32_C(0x40003C4C),   /** @brief Underrun data register */
      (_RW uint32_t* const)UINT32_C(0x4001344C),   /** @brief Underrun data register */
      (_RW uint32_t* const)UINT32_C(0x4001504C),   /** @brief Underrun data register */
      (_RW uint32_t* const)UINT32_C(0x5800144C),   /** @brief Underrun data register */
    };

    static _RW uint32_t* const SPIX_CGFR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40013050),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x40003850),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x40003C50),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x40013450),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x40015050),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x58001450),   /** @brief Configuration register */
    };

    /** @subsection SPIX field mask definitions */

    static const uint32_t SPIX_CR1_IOLOCK_MASK = UINT32_C(0x00010000);     /** @brief Locking the AF configuration of associated ios */
    static const uint32_t SPIX_CR1_TCRCI_MASK = UINT32_C(0x00008000);      /** @brief CRC calculation initialization pattern control for transmitter */
    static const uint32_t SPIX_CR1_RCRCI_MASK = UINT32_C(0x00004000);      /** @brief CRC calculation initialization pattern control for receiver */
    static const uint32_t SPIX_CR1_CRC33_17_MASK = UINT32_C(0x00002000);   /** @brief 32-bit CRC polynomial configuration */
    static const uint32_t SPIX_CR1_SSI_MASK = UINT32_C(0x00001000);        /** @brief Internal SS signal input level */
    static const uint32_t SPIX_CR1_HDDIR_MASK = UINT32_C(0x00000800);      /** @brief Rx/Tx direction at half-duplex mode */
    static const uint32_t SPIX_CR1_CSUSP_MASK = UINT32_C(0x00000400);      /** @brief Master suspend request */
    static const uint32_t SPIX_CR1_CSTART_MASK = UINT32_C(0x00000200);     /** @brief Master transfer start */
    static const uint32_t SPIX_CR1_MASRX_MASK = UINT32_C(0x00000100);      /** @brief Master automatic SUSP in receive mode */
    static const uint32_t SPIX_CR1_SPE_MASK = UINT32_C(0x00000001);        /** @brief Serial peripheral enable */
    static const uint32_t SPIX_CR2_TSER_MASK = UINT32_C(0xFFFF0000);       /** @brief Number of data transfer extension to be reload into TSIZE just when a previous */
    static const uint32_t SPIX_CR2_TSIZE_MASK = UINT32_C(0x0000FFFF);      /** @brief Number of data at current transfer */
    static const uint32_t SPIX_CFG1_MBR_MASK = UINT32_C(0x70000000);       /** @brief Master baud rate */
    static const uint32_t SPIX_CFG1_CRCEN_MASK = UINT32_C(0x00400000);     /** @brief Hardware CRC computation enable */
    static const uint32_t SPIX_CFG1_CRCSIZE_MASK = UINT32_C(0x001F0000);   /** @brief Length of CRC frame to be transacted and compared */
    static const uint32_t SPIX_CFG1_TXDMAEN_MASK = UINT32_C(0x00008000);   /** @brief Tx DMA stream enable */
    static const uint32_t SPIX_CFG1_RXDMAEN_MASK = UINT32_C(0x00004000);   /** @brief Rx DMA stream enable */
    static const uint32_t SPIX_CFG1_UDRDET_MASK = UINT32_C(0x00001800);    /** @brief Detection of underrun condition at slave transmitter */
    static const uint32_t SPIX_CFG1_UDRCFG_MASK = UINT32_C(0x00000600);    /** @brief Behavior of slave transmitter at underrun condition */
    static const uint32_t SPIX_CFG1_FTHVL_MASK = UINT32_C(0x000001E0);     /** @brief Threshold level */
    static const uint32_t SPIX_CFG1_DSIZE_MASK = UINT32_C(0x0000001F);     /** @brief Number of bits in at single SPI data frame */
    static const uint32_t SPIX_CFG2_AFCNTR_MASK = UINT32_C(0x80000000);    /** @brief Alternate function gpios control */
    static const uint32_t SPIX_CFG2_SSOM_MASK = UINT32_C(0x40000000);      /** @brief SS output management in master mode */
    static const uint32_t SPIX_CFG2_SSOE_MASK = UINT32_C(0x20000000);      /** @brief SS output enable */
    static const uint32_t SPIX_CFG2_SSIOP_MASK = UINT32_C(0x10000000);     /** @brief SS input/output polarity */
    static const uint32_t SPIX_CFG2_SSM_MASK = UINT32_C(0x04000000);       /** @brief Software management of SS signal input */
    static const uint32_t SPIX_CFG2_CPOL_MASK = UINT32_C(0x02000000);      /** @brief Clock polarity */
    static const uint32_t SPIX_CFG2_CPHA_MASK = UINT32_C(0x01000000);      /** @brief Clock phase */
    static const uint32_t SPIX_CFG2_LSBFRST_MASK = UINT32_C(0x00800000);   /** @brief Data frame format */
    static const uint32_t SPIX_CFG2_MASTER_MASK = UINT32_C(0x00400000);    /** @brief SPI master */
    static const uint32_t SPIX_CFG2_SP_MASK = UINT32_C(0x00380000);        /** @brief Serial protocol */
    static const uint32_t SPIX_CFG2_COMM_MASK = UINT32_C(0x00060000);      /** @brief SPI communication mode */
    static const uint32_t SPIX_CFG2_IOSWP_MASK = UINT32_C(0x00008000);     /** @brief Swap functionality of MISO and MOSI pins */
    static const uint32_t SPIX_CFG2_MIDI_MASK = UINT32_C(0x000000F0);      /** @brief Master inter-data idleness */
    static const uint32_t SPIX_CFG2_MSSI_MASK = UINT32_C(0x0000000F);      /** @brief Master SS idleness */
    static const uint32_t SPIX_IER_TSERFIE_MASK = UINT32_C(0x00000400);    /** @brief Additional number of transactions reload interrupt enable */
    static const uint32_t SPIX_IER_MODFIE_MASK = UINT32_C(0x00000200);     /** @brief Mode fault interrupt enable */
    static const uint32_t SPIX_IER_TIFREIE_MASK = UINT32_C(0x00000100);    /** @brief TIFRE interrupt enable */
    static const uint32_t SPIX_IER_CRCEIE_MASK = UINT32_C(0x00000080);     /** @brief CRC interrupt enable */
    static const uint32_t SPIX_IER_OVRIE_MASK = UINT32_C(0x00000040);      /** @brief OVR interrupt enable */
    static const uint32_t SPIX_IER_UDRIE_MASK = UINT32_C(0x00000020);      /** @brief UDR interrupt enable */
    static const uint32_t SPIX_IER_TXTFIE_MASK = UINT32_C(0x00000010);     /** @brief TXTFIE interrupt enable */
    static const uint32_t SPIX_IER_EOTIE_MASK = UINT32_C(0x00000008);      /** @brief EOT, SUSP and TXC interrupt enable */
    static const uint32_t SPIX_IER_DPXPIE_MASK = UINT32_C(0x00000004);     /** @brief DXP interrupt enabled */
    static const uint32_t SPIX_IER_TXPIE_MASK = UINT32_C(0x00000002);      /** @brief TXP interrupt enable */
    static const uint32_t SPIX_IER_RXPIE_MASK = UINT32_C(0x00000001);      /** @brief RXP interrupt enable */
    static const uint32_t SPIX_SR_CTSIZE_MASK = UINT32_C(0xFFFF0000);      /** @brief Number of data frames remaining in current TSIZE session */
    static const uint32_t SPIX_SR_RXWNE_MASK = UINT32_C(0x00008000);       /** @brief RxFIFO word not empty */
    static const uint32_t SPIX_SR_RXPLVL_MASK = UINT32_C(0x00006000);      /** @brief RxFIFO packing level */
    static const uint32_t SPIX_SR_TXC_MASK = UINT32_C(0x00001000);         /** @brief TxFIFO transmission complete */
    static const uint32_t SPIX_SR_SUSP_MASK = UINT32_C(0x00000800);        /** @brief SUSPend */
    static const uint32_t SPIX_SR_TSERF_MASK = UINT32_C(0x00000400);       /** @brief Additional number of SPI data to be transacted was reload */
    static const uint32_t SPIX_SR_MODF_MASK = UINT32_C(0x00000200);        /** @brief Mode fault */
    static const uint32_t SPIX_SR_TIFRE_MASK = UINT32_C(0x00000100);       /** @brief TI frame format error */
    static const uint32_t SPIX_SR_CRCE_MASK = UINT32_C(0x00000080);        /** @brief CRC error */
    static const uint32_t SPIX_SR_OVR_MASK = UINT32_C(0x00000040);         /** @brief Overrun */
    static const uint32_t SPIX_SR_UDR_MASK = UINT32_C(0x00000020);         /** @brief Underrun at slave transmission mode */
    static const uint32_t SPIX_SR_TXTF_MASK = UINT32_C(0x00000010);        /** @brief Transmission transfer filled */
    static const uint32_t SPIX_SR_EOT_MASK = UINT32_C(0x00000008);         /** @brief End of transfer */
    static const uint32_t SPIX_SR_DXP_MASK = UINT32_C(0x00000004);         /** @brief Duplex packet */
    static const uint32_t SPIX_SR_TXP_MASK = UINT32_C(0x00000002);         /** @brief Tx-Packet space available */
    static const uint32_t SPIX_SR_RXP_MASK = UINT32_C(0x00000001);         /** @brief Rx-Packet available */
    static const uint32_t SPIX_IFCR_SUSPC_MASK = UINT32_C(0x00000800);     /** @brief SUSPend flag clear */
    static const uint32_t SPIX_IFCR_TSERFC_MASK = UINT32_C(0x00000400);    /** @brief TSERFC flag clear */
    static const uint32_t SPIX_IFCR_MODFC_MASK = UINT32_C(0x00000200);     /** @brief Mode fault flag clear */
    static const uint32_t SPIX_IFCR_TIFREC_MASK = UINT32_C(0x00000100);    /** @brief TI frame format error flag clear */
    static const uint32_t SPIX_IFCR_CRCEC_MASK = UINT32_C(0x00000080);     /** @brief CRC error flag clear */
    static const uint32_t SPIX_IFCR_OVRC_MASK = UINT32_C(0x00000040);      /** @brief Overrun flag clear */
    static const uint32_t SPIX_IFCR_UDRC_MASK = UINT32_C(0x00000020);      /** @brief Underrun flag clear */
    static const uint32_t SPIX_IFCR_TXTFC_MASK = UINT32_C(0x00000010);     /** @brief Transmission transfer filled flag clear */
    static const uint32_t SPIX_IFCR_EOTC_MASK = UINT32_C(0x00000008);      /** @brief End of transfer flag clear */
    static const uint32_t SPIX_CGFR_MCKOE_MASK = UINT32_C(0x02000000);     /** @brief Master clock output enable */
    static const uint32_t SPIX_CGFR_ODD_MASK = UINT32_C(0x01000000);       /** @brief Odd factor for the prescaler */
    static const uint32_t SPIX_CGFR_I2SDIV_MASK = UINT32_C(0x00FF0000);    /** @brief I2S linear prescaler */
    static const uint32_t SPIX_CGFR_DATFMT_MASK = UINT32_C(0x00004000);    /** @brief Data format */
    static const uint32_t SPIX_CGFR_WSINV_MASK = UINT32_C(0x00002000);     /** @brief Fixed channel length in SLAVE */
    static const uint32_t SPIX_CGFR_FIXCH_MASK = UINT32_C(0x00001000);     /** @brief Word select inversion */
    static const uint32_t SPIX_CGFR_CKPOL_MASK = UINT32_C(0x00000800);     /** @brief Serial audio clock polarity */
    static const uint32_t SPIX_CGFR_CHLEN_MASK = UINT32_C(0x00000400);     /** @brief Channel length (number of bits per audio channel) */
    static const uint32_t SPIX_CGFR_DATLEN_MASK = UINT32_C(0x00000300);    /** @brief Data length to be transferred */
    static const uint32_t SPIX_CGFR_PCMSYNC_MASK = UINT32_C(0x00000080);   /** @brief PCM frame synchronization */
    static const uint32_t SPIX_CGFR_I2SSTD_MASK = UINT32_C(0x00000030);    /** @brief I2S standard selection */
    static const uint32_t SPIX_CGFR_I2SCFG_MASK = UINT32_C(0x0000000E);    /** @brief I2S configuration mode */
    static const uint32_t SPIX_CGFR_I2SMOD_MASK = UINT32_C(0x00000001);    /** @brief I2S mode selection */

    /** @subsection SPIX field position definitions */

    static const int32_t SPIX_CGFR_IOLOCK_POS = INT32_C(16);     /** @brief Locking the AF configuration of associated ios */
    static const int32_t SPIX_CGFR_TCRCI_POS = INT32_C(15);      /** @brief CRC calculation initialization pattern control for transmitter */
    static const int32_t SPIX_CGFR_RCRCI_POS = INT32_C(14);      /** @brief CRC calculation initialization pattern control for receiver */
    static const int32_t SPIX_CGFR_CRC33_17_POS = INT32_C(13);   /** @brief 32-bit CRC polynomial configuration */
    static const int32_t SPIX_CGFR_SSI_POS = INT32_C(12);        /** @brief Internal SS signal input level */
    static const int32_t SPIX_CGFR_HDDIR_POS = INT32_C(11);      /** @brief Rx/Tx direction at half-duplex mode */
    static const int32_t SPIX_CGFR_CSUSP_POS = INT32_C(10);      /** @brief Master suspend request */
    static const int32_t SPIX_CGFR_CSTART_POS = INT32_C(9);      /** @brief Master transfer start */
    static const int32_t SPIX_CGFR_MASRX_POS = INT32_C(8);       /** @brief Master automatic SUSP in receive mode */
    static const int32_t SPIX_CGFR_SPE_POS = INT32_C(0);         /** @brief Serial peripheral enable */
    static const int32_t SPIX_CGFR_TSER_POS = INT32_C(16);       /** @brief Number of data transfer extension to be reload into TSIZE just when a previous */
    static const int32_t SPIX_CGFR_TSIZE_POS = INT32_C(0);       /** @brief Number of data at current transfer */
    static const int32_t SPIX_CGFR_MBR_POS = INT32_C(28);        /** @brief Master baud rate */
    static const int32_t SPIX_CGFR_CRCEN_POS = INT32_C(22);      /** @brief Hardware CRC computation enable */
    static const int32_t SPIX_CGFR_CRCSIZE_POS = INT32_C(16);    /** @brief Length of CRC frame to be transacted and compared */
    static const int32_t SPIX_CGFR_TXDMAEN_POS = INT32_C(15);    /** @brief Tx DMA stream enable */
    static const int32_t SPIX_CGFR_RXDMAEN_POS = INT32_C(14);    /** @brief Rx DMA stream enable */
    static const int32_t SPIX_CGFR_UDRDET_POS = INT32_C(11);     /** @brief Detection of underrun condition at slave transmitter */
    static const int32_t SPIX_CGFR_UDRCFG_POS = INT32_C(9);      /** @brief Behavior of slave transmitter at underrun condition */
    static const int32_t SPIX_CGFR_FTHVL_POS = INT32_C(5);       /** @brief Threshold level */
    static const int32_t SPIX_CGFR_DSIZE_POS = INT32_C(0);       /** @brief Number of bits in at single SPI data frame */
    static const int32_t SPIX_CGFR_AFCNTR_POS = INT32_C(31);     /** @brief Alternate function gpios control */
    static const int32_t SPIX_CGFR_SSOM_POS = INT32_C(30);       /** @brief SS output management in master mode */
    static const int32_t SPIX_CGFR_SSOE_POS = INT32_C(29);       /** @brief SS output enable */
    static const int32_t SPIX_CGFR_SSIOP_POS = INT32_C(28);      /** @brief SS input/output polarity */
    static const int32_t SPIX_CGFR_SSM_POS = INT32_C(26);        /** @brief Software management of SS signal input */
    static const int32_t SPIX_CGFR_CPOL_POS = INT32_C(25);       /** @brief Clock polarity */
    static const int32_t SPIX_CGFR_CPHA_POS = INT32_C(24);       /** @brief Clock phase */
    static const int32_t SPIX_CGFR_LSBFRST_POS = INT32_C(23);    /** @brief Data frame format */
    static const int32_t SPIX_CGFR_MASTER_POS = INT32_C(22);     /** @brief SPI master */
    static const int32_t SPIX_CGFR_SP_POS = INT32_C(19);         /** @brief Serial protocol */
    static const int32_t SPIX_CGFR_COMM_POS = INT32_C(17);       /** @brief SPI communication mode */
    static const int32_t SPIX_CGFR_IOSWP_POS = INT32_C(15);      /** @brief Swap functionality of MISO and MOSI pins */
    static const int32_t SPIX_CGFR_MIDI_POS = INT32_C(4);        /** @brief Master inter-data idleness */
    static const int32_t SPIX_CGFR_MSSI_POS = INT32_C(0);        /** @brief Master SS idleness */
    static const int32_t SPIX_CGFR_TSERFIE_POS = INT32_C(10);    /** @brief Additional number of transactions reload interrupt enable */
    static const int32_t SPIX_CGFR_MODFIE_POS = INT32_C(9);      /** @brief Mode fault interrupt enable */
    static const int32_t SPIX_CGFR_TIFREIE_POS = INT32_C(8);     /** @brief TIFRE interrupt enable */
    static const int32_t SPIX_CGFR_CRCEIE_POS = INT32_C(7);      /** @brief CRC interrupt enable */
    static const int32_t SPIX_CGFR_OVRIE_POS = INT32_C(6);       /** @brief OVR interrupt enable */
    static const int32_t SPIX_CGFR_UDRIE_POS = INT32_C(5);       /** @brief UDR interrupt enable */
    static const int32_t SPIX_CGFR_TXTFIE_POS = INT32_C(4);      /** @brief TXTFIE interrupt enable */
    static const int32_t SPIX_CGFR_EOTIE_POS = INT32_C(3);       /** @brief EOT, SUSP and TXC interrupt enable */
    static const int32_t SPIX_CGFR_DPXPIE_POS = INT32_C(2);      /** @brief DXP interrupt enabled */
    static const int32_t SPIX_CGFR_TXPIE_POS = INT32_C(1);       /** @brief TXP interrupt enable */
    static const int32_t SPIX_CGFR_RXPIE_POS = INT32_C(0);       /** @brief RXP interrupt enable */
    static const int32_t SPIX_CGFR_CTSIZE_POS = INT32_C(16);     /** @brief Number of data frames remaining in current TSIZE session */
    static const int32_t SPIX_CGFR_RXWNE_POS = INT32_C(15);      /** @brief RxFIFO word not empty */
    static const int32_t SPIX_CGFR_RXPLVL_POS = INT32_C(13);     /** @brief RxFIFO packing level */
    static const int32_t SPIX_CGFR_TXC_POS = INT32_C(12);        /** @brief TxFIFO transmission complete */
    static const int32_t SPIX_CGFR_SUSP_POS = INT32_C(11);       /** @brief SUSPend */
    static const int32_t SPIX_CGFR_TSERF_POS = INT32_C(10);      /** @brief Additional number of SPI data to be transacted was reload */
    static const int32_t SPIX_CGFR_MODF_POS = INT32_C(9);        /** @brief Mode fault */
    static const int32_t SPIX_CGFR_TIFRE_POS = INT32_C(8);       /** @brief TI frame format error */
    static const int32_t SPIX_CGFR_CRCE_POS = INT32_C(7);        /** @brief CRC error */
    static const int32_t SPIX_CGFR_OVR_POS = INT32_C(6);         /** @brief Overrun */
    static const int32_t SPIX_CGFR_UDR_POS = INT32_C(5);         /** @brief Underrun at slave transmission mode */
    static const int32_t SPIX_CGFR_TXTF_POS = INT32_C(4);        /** @brief Transmission transfer filled */
    static const int32_t SPIX_CGFR_EOT_POS = INT32_C(3);         /** @brief End of transfer */
    static const int32_t SPIX_CGFR_DXP_POS = INT32_C(2);         /** @brief Duplex packet */
    static const int32_t SPIX_CGFR_TXP_POS = INT32_C(1);         /** @brief Tx-Packet space available */
    static const int32_t SPIX_CGFR_RXP_POS = INT32_C(0);         /** @brief Rx-Packet available */
    static const int32_t SPIX_CGFR_SUSPC_POS = INT32_C(11);      /** @brief SUSPend flag clear */
    static const int32_t SPIX_CGFR_TSERFC_POS = INT32_C(10);     /** @brief TSERFC flag clear */
    static const int32_t SPIX_CGFR_MODFC_POS = INT32_C(9);       /** @brief Mode fault flag clear */
    static const int32_t SPIX_CGFR_TIFREC_POS = INT32_C(8);      /** @brief TI frame format error flag clear */
    static const int32_t SPIX_CGFR_CRCEC_POS = INT32_C(7);       /** @brief CRC error flag clear */
    static const int32_t SPIX_CGFR_OVRC_POS = INT32_C(6);        /** @brief Overrun flag clear */
    static const int32_t SPIX_CGFR_UDRC_POS = INT32_C(5);        /** @brief Underrun flag clear */
    static const int32_t SPIX_CGFR_TXTFC_POS = INT32_C(4);       /** @brief Transmission transfer filled flag clear */
    static const int32_t SPIX_CGFR_EOTC_POS = INT32_C(3);        /** @brief End of transfer flag clear */
    static const int32_t SPIX_CGFR_MCKOE_POS = INT32_C(25);      /** @brief Master clock output enable */
    static const int32_t SPIX_CGFR_ODD_POS = INT32_C(24);        /** @brief Odd factor for the prescaler */
    static const int32_t SPIX_CGFR_I2SDIV_POS = INT32_C(16);     /** @brief I2S linear prescaler */
    static const int32_t SPIX_CGFR_DATFMT_POS = INT32_C(14);     /** @brief Data format */
    static const int32_t SPIX_CGFR_WSINV_POS = INT32_C(13);      /** @brief Fixed channel length in SLAVE */
    static const int32_t SPIX_CGFR_FIXCH_POS = INT32_C(12);      /** @brief Word select inversion */
    static const int32_t SPIX_CGFR_CKPOL_POS = INT32_C(11);      /** @brief Serial audio clock polarity */
    static const int32_t SPIX_CGFR_CHLEN_POS = INT32_C(10);      /** @brief Channel length (number of bits per audio channel) */
    static const int32_t SPIX_CGFR_DATLEN_POS = INT32_C(8);      /** @brief Data length to be transferred */
    static const int32_t SPIX_CGFR_PCMSYNC_POS = INT32_C(7);     /** @brief PCM frame synchronization */
    static const int32_t SPIX_CGFR_I2SSTD_POS = INT32_C(4);      /** @brief I2S standard selection */
    static const int32_t SPIX_CGFR_I2SCFG_POS = INT32_C(1);      /** @brief I2S configuration mode */
    static const int32_t SPIX_CGFR_I2SMOD_POS = INT32_C(0);      /** @brief I2S mode selection */

    /**********************************************************************************************
     * @section LTDC Definitions
     **********************************************************************************************/

    /** @subsection LTDC IRQ interrupt definitions */

    static const int32_t LTDC_IRQ = INT32_C(88);      /** @brief LCD-TFT global interrupt */
    static const int32_t LTDC_ER_IRQ = INT32_C(89);   /** @brief LCD-TFT error interrupt */

    /** @subsection LTDC register definitions */

    static _RW uint32_t* const LTDC_SSCR_REG = (_RW uint32_t* const)UINT32_C(0x50001008);       /** @brief Synchronization size configuration register */
    static _RW uint32_t* const LTDC_BPCR_REG = (_RW uint32_t* const)UINT32_C(0x5000100C);       /** @brief Back porch configuration register */
    static _RW uint32_t* const LTDC_AWCR_REG = (_RW uint32_t* const)UINT32_C(0x50001010);       /** @brief Active width configuration register */
    static _RW uint32_t* const LTDC_TWCR_REG = (_RW uint32_t* const)UINT32_C(0x50001014);       /** @brief Total width configuration register */
    static _RW uint32_t* const LTDC_GCR_REG = (_RW uint32_t* const)UINT32_C(0x50001018);        /** @brief Global control register */
    static _RW uint32_t* const LTDC_SRCR_REG = (_RW uint32_t* const)UINT32_C(0x50001024);       /** @brief Shadow reload configuration register */
    static _RW uint32_t* const LTDC_BCCR_REG = (_RW uint32_t* const)UINT32_C(0x5000102C);       /** @brief Background color configuration register */
    static _RW uint32_t* const LTDC_IER_REG = (_RW uint32_t* const)UINT32_C(0x50001034);        /** @brief Interrupt enable register */
    static _RO uint32_t* const LTDC_ISR_REG = (_RO uint32_t* const)UINT32_C(0x50001038);        /** @brief Interrupt status register */
    static _RW uint32_t* const LTDC_ICR_REG = (_RW uint32_t* const)UINT32_C(0x5000103C);        /** @brief Interrupt clear register */
    static _RW uint32_t* const LTDC_LIPCR_REG = (_RW uint32_t* const)UINT32_C(0x50001040);      /** @brief Line interrupt position configuration register */
    static _RO uint32_t* const LTDC_CPSR_REG = (_RO uint32_t* const)UINT32_C(0x50001044);       /** @brief Current position status register */
    static _RO uint32_t* const LTDC_CDSR_REG = (_RO uint32_t* const)UINT32_C(0x50001048);       /** @brief Current display status register */
    static _RW uint32_t* const LTDC_L1CR_REG = (_RW uint32_t* const)UINT32_C(0x50001084);       /** @brief Layerx control register */
    static _RW uint32_t* const LTDC_L1WHPCR_REG = (_RW uint32_t* const)UINT32_C(0x50001088);    /** @brief Layerx window horizontal position configuration register */
    static _RW uint32_t* const LTDC_L1WVPCR_REG = (_RW uint32_t* const)UINT32_C(0x5000108C);    /** @brief Layerx window vertical position configuration register */
    static _RW uint32_t* const LTDC_L1CKCR_REG = (_RW uint32_t* const)UINT32_C(0x50001090);     /** @brief Layerx color keying configuration register */
    static _RW uint32_t* const LTDC_L1PFCR_REG = (_RW uint32_t* const)UINT32_C(0x50001094);     /** @brief Layerx pixel format configuration register */
    static _RW uint32_t* const LTDC_L1CACR_REG = (_RW uint32_t* const)UINT32_C(0x50001098);     /** @brief Layerx constant alpha configuration register */
    static _RW uint32_t* const LTDC_L1DCCR_REG = (_RW uint32_t* const)UINT32_C(0x5000109C);     /** @brief Layerx default color configuration register */
    static _RW uint32_t* const LTDC_L1BFCR_REG = (_RW uint32_t* const)UINT32_C(0x500010A0);     /** @brief Layerx blending factors configuration register */
    static _RW uint32_t* const LTDC_L1CFBAR_REG = (_RW uint32_t* const)UINT32_C(0x500010AC);    /** @brief Layerx color frame buffer address register */
    static _RW uint32_t* const LTDC_L1CFBLR_REG = (_RW uint32_t* const)UINT32_C(0x500010B0);    /** @brief Layerx color frame buffer length register */
    static _RW uint32_t* const LTDC_L1CFBLNR_REG = (_RW uint32_t* const)UINT32_C(0x500010B4);   /** @brief Layerx colorframe buffer line number register */
    static _RW uint32_t* const LTDC_L1CLUTWR_REG = (_RW uint32_t* const)UINT32_C(0x500010C4);   /** @brief Layerx CLUT write register */
    static _RW uint32_t* const LTDC_L2CR_REG = (_RW uint32_t* const)UINT32_C(0x50001104);       /** @brief Layerx control register */
    static _RW uint32_t* const LTDC_L2WHPCR_REG = (_RW uint32_t* const)UINT32_C(0x50001108);    /** @brief Layerx window horizontal position configuration register */
    static _RW uint32_t* const LTDC_L2WVPCR_REG = (_RW uint32_t* const)UINT32_C(0x5000110C);    /** @brief Layerx window vertical position configuration register */
    static _RW uint32_t* const LTDC_L2CKCR_REG = (_RW uint32_t* const)UINT32_C(0x50001110);     /** @brief Layerx color keying configuration register */
    static _RW uint32_t* const LTDC_L2PFCR_REG = (_RW uint32_t* const)UINT32_C(0x50001114);     /** @brief Layerx pixel format configuration register */
    static _RW uint32_t* const LTDC_L2CACR_REG = (_RW uint32_t* const)UINT32_C(0x50001118);     /** @brief Layerx constant alpha configuration register */
    static _RW uint32_t* const LTDC_L2DCCR_REG = (_RW uint32_t* const)UINT32_C(0x5000111C);     /** @brief Layerx default color configuration register */
    static _RW uint32_t* const LTDC_L2BFCR_REG = (_RW uint32_t* const)UINT32_C(0x50001120);     /** @brief Layerx blending factors configuration register */
    static _RW uint32_t* const LTDC_L2CFBAR_REG = (_RW uint32_t* const)UINT32_C(0x5000112C);    /** @brief Layerx color frame buffer address register */
    static _RW uint32_t* const LTDC_L2CFBLR_REG = (_RW uint32_t* const)UINT32_C(0x50001130);    /** @brief Layerx color frame buffer length register */
    static _RW uint32_t* const LTDC_L2CFBLNR_REG = (_RW uint32_t* const)UINT32_C(0x50001134);   /** @brief Layerx colorframe buffer line number register */
    static _RW uint32_t* const LTDC_L2CLUTWR_REG = (_RW uint32_t* const)UINT32_C(0x50001144);   /** @brief Layerx CLUT write register */

    /** @subsection LTDC field mask definitions */

    static const uint32_t LTDC_SSCR_HSW_MASK = UINT32_C(0x03FF0000);           /** @brief Horizontal synchronization width (in units of pixel clock period) */
    static const uint32_t LTDC_SSCR_VSH_MASK = UINT32_C(0x000007FF);           /** @brief Vertical synchronization height (in units of horizontal scan line) */
    static const uint32_t LTDC_BPCR_AHBP_MASK = UINT32_C(0x0FFF0000);          /** @brief Accumulated horizontal back porch (in units of pixel clock period) */
    static const uint32_t LTDC_BPCR_AVBP_MASK = UINT32_C(0x000007FF);          /** @brief Accumulated vertical back porch (in units of horizontal scan line) */
    static const uint32_t LTDC_AWCR_AAV_MASK = UINT32_C(0x0FFF0000);           /** @brief AAV */
    static const uint32_t LTDC_AWCR_AAH_MASK = UINT32_C(0x000007FF);           /** @brief Accumulated active height (in units of horizontal scan line) */
    static const uint32_t LTDC_TWCR_TOTALW_MASK = UINT32_C(0x0FFF0000);        /** @brief Total width (in units of pixel clock period) */
    static const uint32_t LTDC_TWCR_TOTALH_MASK = UINT32_C(0x000007FF);        /** @brief Total height (in units of horizontal scan line) */
    static const uint32_t LTDC_GCR_HSPOL_MASK = UINT32_C(0x80000000);          /** @brief Horizontal synchronization polarity */
    static const uint32_t LTDC_GCR_VSPOL_MASK = UINT32_C(0x40000000);          /** @brief Vertical synchronization polarity */
    static const uint32_t LTDC_GCR_DEPOL_MASK = UINT32_C(0x20000000);          /** @brief Data enable polarity */
    static const uint32_t LTDC_GCR_PCPOL_MASK = UINT32_C(0x10000000);          /** @brief Pixel clock polarity */
    static const uint32_t LTDC_GCR_DEN_MASK = UINT32_C(0x00010000);            /** @brief Dither enable */
    static const uint32_t LTDC_GCR_DRW_MASK = UINT32_C(0x00007000);            /** @brief Dither red width */
    static const uint32_t LTDC_GCR_DGW_MASK = UINT32_C(0x00000700);            /** @brief Dither green width */
    static const uint32_t LTDC_GCR_DBW_MASK = UINT32_C(0x00000070);            /** @brief Dither blue width */
    static const uint32_t LTDC_GCR_LTDCEN_MASK = UINT32_C(0x00000001);         /** @brief LCD-TFT controller enable bit */
    static const uint32_t LTDC_SRCR_VBR_MASK = UINT32_C(0x00000002);           /** @brief Vertical blanking reload */
    static const uint32_t LTDC_SRCR_IMR_MASK = UINT32_C(0x00000001);           /** @brief Immediate reload */
    static const uint32_t LTDC_BCCR_BCBLUE_MASK = UINT32_C(0x000000FF);        /** @brief Background color blue value */
    static const uint32_t LTDC_BCCR_BCGREEN_MASK = UINT32_C(0x0000FF00);       /** @brief Background color green value */
    static const uint32_t LTDC_BCCR_BCRED_MASK = UINT32_C(0x00FF0000);         /** @brief Background color red value */
    static const uint32_t LTDC_IER_RRIE_MASK = UINT32_C(0x00000008);           /** @brief Register reload interrupt enable */
    static const uint32_t LTDC_IER_TERRIE_MASK = UINT32_C(0x00000004);         /** @brief Transfer error interrupt enable */
    static const uint32_t LTDC_IER_FUIE_MASK = UINT32_C(0x00000002);           /** @brief FIFO underrun interrupt enable */
    static const uint32_t LTDC_IER_LIE_MASK = UINT32_C(0x00000001);            /** @brief Line interrupt enable */
    static const uint32_t LTDC_ISR_RRIF_MASK = UINT32_C(0x00000008);           /** @brief Register reload interrupt flag */
    static const uint32_t LTDC_ISR_TERRIF_MASK = UINT32_C(0x00000004);         /** @brief Transfer error interrupt flag */
    static const uint32_t LTDC_ISR_FUIF_MASK = UINT32_C(0x00000002);           /** @brief FIFO underrun interrupt flag */
    static const uint32_t LTDC_ISR_LIF_MASK = UINT32_C(0x00000001);            /** @brief Line interrupt flag */
    static const uint32_t LTDC_ICR_CRRIF_MASK = UINT32_C(0x00000008);          /** @brief Clears register reload interrupt flag */
    static const uint32_t LTDC_ICR_CTERRIF_MASK = UINT32_C(0x00000004);        /** @brief Clears the transfer error interrupt flag */
    static const uint32_t LTDC_ICR_CFUIF_MASK = UINT32_C(0x00000002);          /** @brief Clears the FIFO underrun interrupt flag */
    static const uint32_t LTDC_ICR_CLIF_MASK = UINT32_C(0x00000001);           /** @brief Clears the line interrupt flag */
    static const uint32_t LTDC_LIPCR_LIPOS_MASK = UINT32_C(0x000007FF);        /** @brief Line interrupt position */
    static const uint32_t LTDC_CPSR_CXPOS_MASK = UINT32_C(0xFFFF0000);         /** @brief Current X position */
    static const uint32_t LTDC_CPSR_CYPOS_MASK = UINT32_C(0x0000FFFF);         /** @brief Current Y position */
    static const uint32_t LTDC_CDSR_HSYNCS_MASK = UINT32_C(0x00000008);        /** @brief Horizontal synchronization display status */
    static const uint32_t LTDC_CDSR_VSYNCS_MASK = UINT32_C(0x00000004);        /** @brief Vertical synchronization display status */
    static const uint32_t LTDC_CDSR_HDES_MASK = UINT32_C(0x00000002);          /** @brief Horizontal data enable display status */
    static const uint32_t LTDC_CDSR_VDES_MASK = UINT32_C(0x00000001);          /** @brief Vertical data enable display status */
    static const uint32_t LTDC_L1CR_CLUTEN_MASK = UINT32_C(0x00000010);        /** @brief Color look-up table enable */
    static const uint32_t LTDC_L1CR_COLKEN_MASK = UINT32_C(0x00000002);        /** @brief Color keying enable */
    static const uint32_t LTDC_L1CR_LEN_MASK = UINT32_C(0x00000001);           /** @brief Layer enable */
    static const uint32_t LTDC_L1WHPCR_WHSPPOS_MASK = UINT32_C(0x0FFF0000);    /** @brief Window horizontal stop position */
    static const uint32_t LTDC_L1WHPCR_WHSTPOS_MASK = UINT32_C(0x00000FFF);    /** @brief Window horizontal start position */
    static const uint32_t LTDC_L1WVPCR_WVSPPOS_MASK = UINT32_C(0x07FF0000);    /** @brief Window vertical stop position */
    static const uint32_t LTDC_L1WVPCR_WVSTPOS_MASK = UINT32_C(0x000007FF);    /** @brief Window vertical start position */
    static const uint32_t LTDC_L1CKCR_CKRED_MASK = UINT32_C(0x00FF0000);       /** @brief Color key red value */
    static const uint32_t LTDC_L1CKCR_CKGREEN_MASK = UINT32_C(0x0000FF00);     /** @brief Color key green value */
    static const uint32_t LTDC_L1CKCR_CKBLUE_MASK = UINT32_C(0x000000FF);      /** @brief Color key blue value */
    static const uint32_t LTDC_L1PFCR_PF_MASK = UINT32_C(0x00000007);          /** @brief Pixel format */
    static const uint32_t LTDC_L1CACR_CONSTA_MASK = UINT32_C(0x000000FF);      /** @brief Constant alpha */
    static const uint32_t LTDC_L1DCCR_DCALPHA_MASK = UINT32_C(0xFF000000);     /** @brief Default color alpha */
    static const uint32_t LTDC_L1DCCR_DCRED_MASK = UINT32_C(0x00FF0000);       /** @brief Default color red */
    static const uint32_t LTDC_L1DCCR_DCGREEN_MASK = UINT32_C(0x0000FF00);     /** @brief Default color green */
    static const uint32_t LTDC_L1DCCR_DCBLUE_MASK = UINT32_C(0x000000FF);      /** @brief Default color blue */
    static const uint32_t LTDC_L1BFCR_BF1_MASK = UINT32_C(0x00000700);         /** @brief Blending factor 1 */
    static const uint32_t LTDC_L1BFCR_BF2_MASK = UINT32_C(0x00000007);         /** @brief Blending factor 2 */
    static const uint32_t LTDC_L1CFBLR_CFBP_MASK = UINT32_C(0x1FFF0000);       /** @brief Color frame buffer pitch in bytes */
    static const uint32_t LTDC_L1CFBLR_CFBLL_MASK = UINT32_C(0x00001FFF);      /** @brief Color frame buffer line length */
    static const uint32_t LTDC_L1CFBLNR_CFBLNBR_MASK = UINT32_C(0x000007FF);   /** @brief Frame buffer line number */
    static const uint32_t LTDC_L1CLUTWR_CLUTADD_MASK = UINT32_C(0xFF000000);   /** @brief CLUT address */
    static const uint32_t LTDC_L1CLUTWR_RED_MASK = UINT32_C(0x00FF0000);       /** @brief Red value */
    static const uint32_t LTDC_L1CLUTWR_GREEN_MASK = UINT32_C(0x0000FF00);     /** @brief Green value */
    static const uint32_t LTDC_L1CLUTWR_BLUE_MASK = UINT32_C(0x000000FF);      /** @brief Blue value */
    static const uint32_t LTDC_L2CR_CLUTEN_MASK = UINT32_C(0x00000010);        /** @brief Color look-up table enable */
    static const uint32_t LTDC_L2CR_COLKEN_MASK = UINT32_C(0x00000002);        /** @brief Color keying enable */
    static const uint32_t LTDC_L2CR_LEN_MASK = UINT32_C(0x00000001);           /** @brief Layer enable */
    static const uint32_t LTDC_L2WHPCR_WHSPPOS_MASK = UINT32_C(0x0FFF0000);    /** @brief Window horizontal stop position */
    static const uint32_t LTDC_L2WHPCR_WHSTPOS_MASK = UINT32_C(0x00000FFF);    /** @brief Window horizontal start position */
    static const uint32_t LTDC_L2WVPCR_WVSPPOS_MASK = UINT32_C(0x07FF0000);    /** @brief Window vertical stop position */
    static const uint32_t LTDC_L2WVPCR_WVSTPOS_MASK = UINT32_C(0x000007FF);    /** @brief Window vertical start position */
    static const uint32_t LTDC_L2CKCR_CKRED_MASK = UINT32_C(0x00FF0000);       /** @brief Color key red value */
    static const uint32_t LTDC_L2CKCR_CKGREEN_MASK = UINT32_C(0x0000FF00);     /** @brief Color key green value */
    static const uint32_t LTDC_L2CKCR_CKBLUE_MASK = UINT32_C(0x000000FF);      /** @brief Color key blue value */
    static const uint32_t LTDC_L2PFCR_PF_MASK = UINT32_C(0x00000007);          /** @brief Pixel format */
    static const uint32_t LTDC_L2CACR_CONSTA_MASK = UINT32_C(0x000000FF);      /** @brief Constant alpha */
    static const uint32_t LTDC_L2DCCR_DCALPHA_MASK = UINT32_C(0xFF000000);     /** @brief Default color alpha */
    static const uint32_t LTDC_L2DCCR_DCRED_MASK = UINT32_C(0x00FF0000);       /** @brief Default color red */
    static const uint32_t LTDC_L2DCCR_DCGREEN_MASK = UINT32_C(0x0000FF00);     /** @brief Default color green */
    static const uint32_t LTDC_L2DCCR_DCBLUE_MASK = UINT32_C(0x000000FF);      /** @brief Default color blue */
    static const uint32_t LTDC_L2BFCR_BF1_MASK = UINT32_C(0x00000700);         /** @brief Blending factor 1 */
    static const uint32_t LTDC_L2BFCR_BF2_MASK = UINT32_C(0x00000007);         /** @brief Blending factor 2 */
    static const uint32_t LTDC_L2CFBLR_CFBP_MASK = UINT32_C(0x1FFF0000);       /** @brief Color frame buffer pitch in bytes */
    static const uint32_t LTDC_L2CFBLR_CFBLL_MASK = UINT32_C(0x00001FFF);      /** @brief Color frame buffer line length */
    static const uint32_t LTDC_L2CFBLNR_CFBLNBR_MASK = UINT32_C(0x000007FF);   /** @brief Frame buffer line number */
    static const uint32_t LTDC_L2CLUTWR_CLUTADD_MASK = UINT32_C(0xFF000000);   /** @brief CLUT address */
    static const uint32_t LTDC_L2CLUTWR_RED_MASK = UINT32_C(0x00FF0000);       /** @brief Red value */
    static const uint32_t LTDC_L2CLUTWR_GREEN_MASK = UINT32_C(0x0000FF00);     /** @brief Green value */
    static const uint32_t LTDC_L2CLUTWR_BLUE_MASK = UINT32_C(0x000000FF);      /** @brief Blue value */

    /** @subsection LTDC field position definitions */

    static const int32_t LTDC_L2CLUTWR_HSW_POS = INT32_C(16);       /** @brief Horizontal synchronization width (in units of pixel clock period) */
    static const int32_t LTDC_L2CLUTWR_VSH_POS = INT32_C(0);        /** @brief Vertical synchronization height (in units of horizontal scan line) */
    static const int32_t LTDC_L2CLUTWR_AHBP_POS = INT32_C(16);      /** @brief Accumulated horizontal back porch (in units of pixel clock period) */
    static const int32_t LTDC_L2CLUTWR_AVBP_POS = INT32_C(0);       /** @brief Accumulated vertical back porch (in units of horizontal scan line) */
    static const int32_t LTDC_L2CLUTWR_AAV_POS = INT32_C(16);       /** @brief AAV */
    static const int32_t LTDC_L2CLUTWR_AAH_POS = INT32_C(0);        /** @brief Accumulated active height (in units of horizontal scan line) */
    static const int32_t LTDC_L2CLUTWR_TOTALW_POS = INT32_C(16);    /** @brief Total width (in units of pixel clock period) */
    static const int32_t LTDC_L2CLUTWR_TOTALH_POS = INT32_C(0);     /** @brief Total height (in units of horizontal scan line) */
    static const int32_t LTDC_L2CLUTWR_HSPOL_POS = INT32_C(31);     /** @brief Horizontal synchronization polarity */
    static const int32_t LTDC_L2CLUTWR_VSPOL_POS = INT32_C(30);     /** @brief Vertical synchronization polarity */
    static const int32_t LTDC_L2CLUTWR_DEPOL_POS = INT32_C(29);     /** @brief Data enable polarity */
    static const int32_t LTDC_L2CLUTWR_PCPOL_POS = INT32_C(28);     /** @brief Pixel clock polarity */
    static const int32_t LTDC_L2CLUTWR_DEN_POS = INT32_C(16);       /** @brief Dither enable */
    static const int32_t LTDC_L2CLUTWR_DRW_POS = INT32_C(12);       /** @brief Dither red width */
    static const int32_t LTDC_L2CLUTWR_DGW_POS = INT32_C(8);        /** @brief Dither green width */
    static const int32_t LTDC_L2CLUTWR_DBW_POS = INT32_C(4);        /** @brief Dither blue width */
    static const int32_t LTDC_L2CLUTWR_LTDCEN_POS = INT32_C(0);     /** @brief LCD-TFT controller enable bit */
    static const int32_t LTDC_L2CLUTWR_VBR_POS = INT32_C(1);        /** @brief Vertical blanking reload */
    static const int32_t LTDC_L2CLUTWR_IMR_POS = INT32_C(0);        /** @brief Immediate reload */
    static const int32_t LTDC_L2CLUTWR_BCBLUE_POS = INT32_C(0);     /** @brief Background color blue value */
    static const int32_t LTDC_L2CLUTWR_BCGREEN_POS = INT32_C(8);    /** @brief Background color green value */
    static const int32_t LTDC_L2CLUTWR_BCRED_POS = INT32_C(16);     /** @brief Background color red value */
    static const int32_t LTDC_L2CLUTWR_RRIE_POS = INT32_C(3);       /** @brief Register reload interrupt enable */
    static const int32_t LTDC_L2CLUTWR_TERRIE_POS = INT32_C(2);     /** @brief Transfer error interrupt enable */
    static const int32_t LTDC_L2CLUTWR_FUIE_POS = INT32_C(1);       /** @brief FIFO underrun interrupt enable */
    static const int32_t LTDC_L2CLUTWR_LIE_POS = INT32_C(0);        /** @brief Line interrupt enable */
    static const int32_t LTDC_L2CLUTWR_RRIF_POS = INT32_C(3);       /** @brief Register reload interrupt flag */
    static const int32_t LTDC_L2CLUTWR_TERRIF_POS = INT32_C(2);     /** @brief Transfer error interrupt flag */
    static const int32_t LTDC_L2CLUTWR_FUIF_POS = INT32_C(1);       /** @brief FIFO underrun interrupt flag */
    static const int32_t LTDC_L2CLUTWR_LIF_POS = INT32_C(0);        /** @brief Line interrupt flag */
    static const int32_t LTDC_L2CLUTWR_CRRIF_POS = INT32_C(3);      /** @brief Clears register reload interrupt flag */
    static const int32_t LTDC_L2CLUTWR_CTERRIF_POS = INT32_C(2);    /** @brief Clears the transfer error interrupt flag */
    static const int32_t LTDC_L2CLUTWR_CFUIF_POS = INT32_C(1);      /** @brief Clears the FIFO underrun interrupt flag */
    static const int32_t LTDC_L2CLUTWR_CLIF_POS = INT32_C(0);       /** @brief Clears the line interrupt flag */
    static const int32_t LTDC_L2CLUTWR_LIPOS_POS = INT32_C(0);      /** @brief Line interrupt position */
    static const int32_t LTDC_L2CLUTWR_CXPOS_POS = INT32_C(16);     /** @brief Current X position */
    static const int32_t LTDC_L2CLUTWR_CYPOS_POS = INT32_C(0);      /** @brief Current Y position */
    static const int32_t LTDC_L2CLUTWR_HSYNCS_POS = INT32_C(3);     /** @brief Horizontal synchronization display status */
    static const int32_t LTDC_L2CLUTWR_VSYNCS_POS = INT32_C(2);     /** @brief Vertical synchronization display status */
    static const int32_t LTDC_L2CLUTWR_HDES_POS = INT32_C(1);       /** @brief Horizontal data enable display status */
    static const int32_t LTDC_L2CLUTWR_VDES_POS = INT32_C(0);       /** @brief Vertical data enable display status */
    static const int32_t LTDC_L2CLUTWR_CLUTEN_POS = INT32_C(4);     /** @brief Color look-up table enable */
    static const int32_t LTDC_L2CLUTWR_COLKEN_POS = INT32_C(1);     /** @brief Color keying enable */
    static const int32_t LTDC_L2CLUTWR_LEN_POS = INT32_C(0);        /** @brief Layer enable */
    static const int32_t LTDC_L2CLUTWR_WHSPPOS_POS = INT32_C(16);   /** @brief Window horizontal stop position */
    static const int32_t LTDC_L2CLUTWR_WHSTPOS_POS = INT32_C(0);    /** @brief Window horizontal start position */
    static const int32_t LTDC_L2CLUTWR_WVSPPOS_POS = INT32_C(16);   /** @brief Window vertical stop position */
    static const int32_t LTDC_L2CLUTWR_WVSTPOS_POS = INT32_C(0);    /** @brief Window vertical start position */
    static const int32_t LTDC_L2CLUTWR_CKRED_POS = INT32_C(16);     /** @brief Color key red value */
    static const int32_t LTDC_L2CLUTWR_CKGREEN_POS = INT32_C(8);    /** @brief Color key green value */
    static const int32_t LTDC_L2CLUTWR_CKBLUE_POS = INT32_C(0);     /** @brief Color key blue value */
    static const int32_t LTDC_L2CLUTWR_PF_POS = INT32_C(0);         /** @brief Pixel format */
    static const int32_t LTDC_L2CLUTWR_CONSTA_POS = INT32_C(0);     /** @brief Constant alpha */
    static const int32_t LTDC_L2CLUTWR_DCALPHA_POS = INT32_C(24);   /** @brief Default color alpha */
    static const int32_t LTDC_L2CLUTWR_DCRED_POS = INT32_C(16);     /** @brief Default color red */
    static const int32_t LTDC_L2CLUTWR_DCGREEN_POS = INT32_C(8);    /** @brief Default color green */
    static const int32_t LTDC_L2CLUTWR_DCBLUE_POS = INT32_C(0);     /** @brief Default color blue */
    static const int32_t LTDC_L2CLUTWR_BF1_POS = INT32_C(8);        /** @brief Blending factor 1 */
    static const int32_t LTDC_L2CLUTWR_BF2_POS = INT32_C(0);        /** @brief Blending factor 2 */
    static const int32_t LTDC_L2CLUTWR_CFBP_POS = INT32_C(16);      /** @brief Color frame buffer pitch in bytes */
    static const int32_t LTDC_L2CLUTWR_CFBLL_POS = INT32_C(0);      /** @brief Color frame buffer line length */
    static const int32_t LTDC_L2CLUTWR_CFBLNBR_POS = INT32_C(0);    /** @brief Frame buffer line number */
    static const int32_t LTDC_L2CLUTWR_CLUTADD_POS = INT32_C(24);   /** @brief CLUT address */
    static const int32_t LTDC_L2CLUTWR_RED_POS = INT32_C(16);       /** @brief Red value */
    static const int32_t LTDC_L2CLUTWR_GREEN_POS = INT32_C(8);      /** @brief Green value */
    static const int32_t LTDC_L2CLUTWR_BLUE_POS = INT32_C(0);       /** @brief Blue value */
    static const int32_t LTDC_L2CLUTWR_CLUTEN_POS = INT32_C(4);     /** @brief Color look-up table enable */
    static const int32_t LTDC_L2CLUTWR_COLKEN_POS = INT32_C(1);     /** @brief Color keying enable */
    static const int32_t LTDC_L2CLUTWR_LEN_POS = INT32_C(0);        /** @brief Layer enable */
    static const int32_t LTDC_L2CLUTWR_WHSPPOS_POS = INT32_C(16);   /** @brief Window horizontal stop position */
    static const int32_t LTDC_L2CLUTWR_WHSTPOS_POS = INT32_C(0);    /** @brief Window horizontal start position */
    static const int32_t LTDC_L2CLUTWR_WVSPPOS_POS = INT32_C(16);   /** @brief Window vertical stop position */
    static const int32_t LTDC_L2CLUTWR_WVSTPOS_POS = INT32_C(0);    /** @brief Window vertical start position */
    static const int32_t LTDC_L2CLUTWR_CKRED_POS = INT32_C(16);     /** @brief Color key red value */
    static const int32_t LTDC_L2CLUTWR_CKGREEN_POS = INT32_C(8);    /** @brief Color key green value */
    static const int32_t LTDC_L2CLUTWR_CKBLUE_POS = INT32_C(0);     /** @brief Color key blue value */
    static const int32_t LTDC_L2CLUTWR_PF_POS = INT32_C(0);         /** @brief Pixel format */
    static const int32_t LTDC_L2CLUTWR_CONSTA_POS = INT32_C(0);     /** @brief Constant alpha */
    static const int32_t LTDC_L2CLUTWR_DCALPHA_POS = INT32_C(24);   /** @brief Default color alpha */
    static const int32_t LTDC_L2CLUTWR_DCRED_POS = INT32_C(16);     /** @brief Default color red */
    static const int32_t LTDC_L2CLUTWR_DCGREEN_POS = INT32_C(8);    /** @brief Default color green */
    static const int32_t LTDC_L2CLUTWR_DCBLUE_POS = INT32_C(0);     /** @brief Default color blue */
    static const int32_t LTDC_L2CLUTWR_BF1_POS = INT32_C(8);        /** @brief Blending factor 1 */
    static const int32_t LTDC_L2CLUTWR_BF2_POS = INT32_C(0);        /** @brief Blending factor 2 */
    static const int32_t LTDC_L2CLUTWR_CFBP_POS = INT32_C(16);      /** @brief Color frame buffer pitch in bytes */
    static const int32_t LTDC_L2CLUTWR_CFBLL_POS = INT32_C(0);      /** @brief Color frame buffer line length */
    static const int32_t LTDC_L2CLUTWR_CFBLNBR_POS = INT32_C(0);    /** @brief Frame buffer line number */
    static const int32_t LTDC_L2CLUTWR_CLUTADD_POS = INT32_C(24);   /** @brief CLUT address */
    static const int32_t LTDC_L2CLUTWR_RED_POS = INT32_C(16);       /** @brief Red value */
    static const int32_t LTDC_L2CLUTWR_GREEN_POS = INT32_C(8);      /** @brief Green value */
    static const int32_t LTDC_L2CLUTWR_BLUE_POS = INT32_C(0);       /** @brief Blue value */

    /**********************************************************************************************
     * @section SPDIFRX Definitions
     **********************************************************************************************/

    /** @subsection SPDIFRX IRQ interrupt definitions */

    static const int32_t SPDIF_IRQ = INT32_C(97);   /** @brief SPDIFRX global interrupt */

    /** @subsection SPDIFRX register definitions */

    static _RW uint32_t* const SPDIFRX_CR_REG = (_RW uint32_t* const)UINT32_C(0x40004000);      /** @brief Control register */
    static _RW uint32_t* const SPDIFRX_IMR_REG = (_RW uint32_t* const)UINT32_C(0x40004004);     /** @brief Interrupt mask register */
    static _RO uint32_t* const SPDIFRX_SR_REG = (_RO uint32_t* const)UINT32_C(0x40004008);      /** @brief Status register */
    static _RW uint32_t* const SPDIFRX_IFCR_REG = (_RW uint32_t* const)UINT32_C(0x4000400C);    /** @brief Interrupt flag clear register */
    static _RO uint32_t* const SPDIFRX_DR_00_REG = (_RO uint32_t* const)UINT32_C(0x40004010);   /** @brief Data input register */
    static _RO uint32_t* const SPDIFRX_CSR_REG = (_RO uint32_t* const)UINT32_C(0x40004014);     /** @brief Channel status register */
    static _RO uint32_t* const SPDIFRX_DIR_REG = (_RO uint32_t* const)UINT32_C(0x40004018);     /** @brief Debug information register */
    static _RO uint32_t* const SPDIFRX_VERR_REG = (_RO uint32_t* const)UINT32_C(0x400043F4);    /** @brief SPDIFRX version register */
    static _RO uint32_t* const SPDIFRX_IDR_REG = (_RO uint32_t* const)UINT32_C(0x400043F8);     /** @brief SPDIFRX identification register */
    static _RO uint32_t* const SPDIFRX_SIDR_REG = (_RO uint32_t* const)UINT32_C(0x400043FC);    /** @brief SPDIFRX size identification register */
    static _RO uint32_t* const SPDIFRX_DR_01_REG = (_RO uint32_t* const)UINT32_C(0x40004010);   /** @brief Data input register */
    static _RO uint32_t* const SPDIFRX_DR_10_REG = (_RO uint32_t* const)UINT32_C(0x40004010);   /** @brief Data input register */

    /** @subsection SPDIFRX field mask definitions */

    static const uint32_t SPDIFRX_CR_SPDIFRXEN_MASK = UINT32_C(0x00000003);   /** @brief Peripheral block enable */
    static const uint32_t SPDIFRX_CR_RXDMAEN_MASK = UINT32_C(0x00000004);     /** @brief Receiver DMA enable for data flow */
    static const uint32_t SPDIFRX_CR_RXSTEO_MASK = UINT32_C(0x00000008);      /** @brief STerEO mode */
    static const uint32_t SPDIFRX_CR_DRFMT_MASK = UINT32_C(0x00000030);       /** @brief RX data format */
    static const uint32_t SPDIFRX_CR_PMSK_MASK = UINT32_C(0x00000040);        /** @brief Mask parity error bit */
    static const uint32_t SPDIFRX_CR_VMSK_MASK = UINT32_C(0x00000080);        /** @brief Mask of validity bit */
    static const uint32_t SPDIFRX_CR_CUMSK_MASK = UINT32_C(0x00000100);       /** @brief Mask of channel status and user bits */
    static const uint32_t SPDIFRX_CR_PTMSK_MASK = UINT32_C(0x00000200);       /** @brief Mask of preamble type bits */
    static const uint32_t SPDIFRX_CR_CBDMAEN_MASK = UINT32_C(0x00000400);     /** @brief Control buffer DMA enable for control flow */
    static const uint32_t SPDIFRX_CR_CHSEL_MASK = UINT32_C(0x00000800);       /** @brief Channel selection */
    static const uint32_t SPDIFRX_CR_NBTR_MASK = UINT32_C(0x00003000);        /** @brief Maximum allowed re-tries during synchronization phase */
    static const uint32_t SPDIFRX_CR_WFA_MASK = UINT32_C(0x00004000);         /** @brief Wait for activity */
    static const uint32_t SPDIFRX_CR_INSEL_MASK = UINT32_C(0x00070000);       /** @brief Input selection */
    static const uint32_t SPDIFRX_CR_CKSEN_MASK = UINT32_C(0x00100000);       /** @brief Symbol clock enable */
    static const uint32_t SPDIFRX_CR_CKSBKPEN_MASK = UINT32_C(0x00200000);    /** @brief Backup symbol clock enable */
    static const uint32_t SPDIFRX_IMR_RXNEIE_MASK = UINT32_C(0x00000001);     /** @brief RXNE interrupt enable */
    static const uint32_t SPDIFRX_IMR_CSRNEIE_MASK = UINT32_C(0x00000002);    /** @brief Control buffer ready interrupt enable */
    static const uint32_t SPDIFRX_IMR_PERRIE_MASK = UINT32_C(0x00000004);     /** @brief Parity error interrupt enable */
    static const uint32_t SPDIFRX_IMR_OVRIE_MASK = UINT32_C(0x00000008);      /** @brief Overrun error interrupt enable */
    static const uint32_t SPDIFRX_IMR_SBLKIE_MASK = UINT32_C(0x00000010);     /** @brief Synchronization block detected interrupt enable */
    static const uint32_t SPDIFRX_IMR_SYNCDIE_MASK = UINT32_C(0x00000020);    /** @brief Synchronization done */
    static const uint32_t SPDIFRX_IMR_IFEIE_MASK = UINT32_C(0x00000040);      /** @brief Serial interface error interrupt enable */
    static const uint32_t SPDIFRX_SR_RXNE_MASK = UINT32_C(0x00000001);        /** @brief Read data register not empty */
    static const uint32_t SPDIFRX_SR_CSRNE_MASK = UINT32_C(0x00000002);       /** @brief Control buffer register is not empty */
    static const uint32_t SPDIFRX_SR_PERR_MASK = UINT32_C(0x00000004);        /** @brief Parity error */
    static const uint32_t SPDIFRX_SR_OVR_MASK = UINT32_C(0x00000008);         /** @brief Overrun error */
    static const uint32_t SPDIFRX_SR_SBD_MASK = UINT32_C(0x00000010);         /** @brief Synchronization block detected */
    static const uint32_t SPDIFRX_SR_SYNCD_MASK = UINT32_C(0x00000020);       /** @brief Synchronization done */
    static const uint32_t SPDIFRX_SR_FERR_MASK = UINT32_C(0x00000040);        /** @brief Framing error */
    static const uint32_t SPDIFRX_SR_SERR_MASK = UINT32_C(0x00000080);        /** @brief Synchronization error */
    static const uint32_t SPDIFRX_SR_TERR_MASK = UINT32_C(0x00000100);        /** @brief Time-out error */
    static const uint32_t SPDIFRX_SR_WIDTH5_MASK = UINT32_C(0x7FFF0000);      /** @brief Duration of 5 symbols counted with SPDIF_CLK */
    static const uint32_t SPDIFRX_IFCR_PERRCF_MASK = UINT32_C(0x00000004);    /** @brief Clears the parity error flag */
    static const uint32_t SPDIFRX_IFCR_OVRCF_MASK = UINT32_C(0x00000008);     /** @brief Clears the overrun error flag */
    static const uint32_t SPDIFRX_IFCR_SBDCF_MASK = UINT32_C(0x00000010);     /** @brief Clears the synchronization block detected flag */
    static const uint32_t SPDIFRX_IFCR_SYNCDCF_MASK = UINT32_C(0x00000020);   /** @brief Clears the synchronization done flag */
    static const uint32_t SPDIFRX_DR_00_DR_MASK = UINT32_C(0x00FFFFFF);       /** @brief Parity error bit */
    static const uint32_t SPDIFRX_DR_00_PE_MASK = UINT32_C(0x01000000);       /** @brief Parity error bit */
    static const uint32_t SPDIFRX_DR_00_V_MASK = UINT32_C(0x02000000);        /** @brief Validity bit */
    static const uint32_t SPDIFRX_DR_00_U_MASK = UINT32_C(0x04000000);        /** @brief User bit */
    static const uint32_t SPDIFRX_DR_00_C_MASK = UINT32_C(0x08000000);        /** @brief Channel status bit */
    static const uint32_t SPDIFRX_DR_00_PT_MASK = UINT32_C(0x30000000);       /** @brief Preamble type */
    static const uint32_t SPDIFRX_CSR_USR_MASK = UINT32_C(0x0000FFFF);        /** @brief User data information */
    static const uint32_t SPDIFRX_CSR_CS_MASK = UINT32_C(0x00FF0000);         /** @brief Channel A status information */
    static const uint32_t SPDIFRX_CSR_SOB_MASK = UINT32_C(0x01000000);        /** @brief Start of block */
    static const uint32_t SPDIFRX_DIR_THI_MASK = UINT32_C(0x00001FFF);        /** @brief Threshold HIGH */
    static const uint32_t SPDIFRX_DIR_TLO_MASK = UINT32_C(0x1FFF0000);        /** @brief Threshold LOW */
    static const uint32_t SPDIFRX_VERR_MINREV_MASK = UINT32_C(0x0000000F);    /** @brief Minor revision */
    static const uint32_t SPDIFRX_VERR_MAJREV_MASK = UINT32_C(0x000000F0);    /** @brief Major revision */
    static const uint32_t SPDIFRX_DR_01_PE_MASK = UINT32_C(0x00000001);       /** @brief Parity error bit */
    static const uint32_t SPDIFRX_DR_01_V_MASK = UINT32_C(0x00000002);        /** @brief Validity bit */
    static const uint32_t SPDIFRX_DR_01_U_MASK = UINT32_C(0x00000004);        /** @brief User bit */
    static const uint32_t SPDIFRX_DR_01_C_MASK = UINT32_C(0x00000008);        /** @brief Channel status bit */
    static const uint32_t SPDIFRX_DR_01_PT_MASK = UINT32_C(0x00000030);       /** @brief Preamble type */
    static const uint32_t SPDIFRX_DR_01_DR_MASK = UINT32_C(0xFFFFFF00);       /** @brief Data value */
    static const uint32_t SPDIFRX_DR_10_DRNL1_MASK = UINT32_C(0x0000FFFF);    /** @brief Data value */
    static const uint32_t SPDIFRX_DR_10_DRNL2_MASK = UINT32_C(0xFFFF0000);    /** @brief Data value */

    /** @subsection SPDIFRX field position definitions */

    static const int32_t SPDIFRX_DR_10_SPDIFRXEN_POS = INT32_C(0);    /** @brief Peripheral block enable */
    static const int32_t SPDIFRX_DR_10_RXDMAEN_POS = INT32_C(2);      /** @brief Receiver DMA enable for data flow */
    static const int32_t SPDIFRX_DR_10_RXSTEO_POS = INT32_C(3);       /** @brief STerEO mode */
    static const int32_t SPDIFRX_DR_10_DRFMT_POS = INT32_C(4);        /** @brief RX data format */
    static const int32_t SPDIFRX_DR_10_PMSK_POS = INT32_C(6);         /** @brief Mask parity error bit */
    static const int32_t SPDIFRX_DR_10_VMSK_POS = INT32_C(7);         /** @brief Mask of validity bit */
    static const int32_t SPDIFRX_DR_10_CUMSK_POS = INT32_C(8);        /** @brief Mask of channel status and user bits */
    static const int32_t SPDIFRX_DR_10_PTMSK_POS = INT32_C(9);        /** @brief Mask of preamble type bits */
    static const int32_t SPDIFRX_DR_10_CBDMAEN_POS = INT32_C(10);     /** @brief Control buffer DMA enable for control flow */
    static const int32_t SPDIFRX_DR_10_CHSEL_POS = INT32_C(11);       /** @brief Channel selection */
    static const int32_t SPDIFRX_DR_10_NBTR_POS = INT32_C(12);        /** @brief Maximum allowed re-tries during synchronization phase */
    static const int32_t SPDIFRX_DR_10_WFA_POS = INT32_C(14);         /** @brief Wait for activity */
    static const int32_t SPDIFRX_DR_10_INSEL_POS = INT32_C(16);       /** @brief Input selection */
    static const int32_t SPDIFRX_DR_10_CKSEN_POS = INT32_C(20);       /** @brief Symbol clock enable */
    static const int32_t SPDIFRX_DR_10_CKSBKPEN_POS = INT32_C(21);    /** @brief Backup symbol clock enable */
    static const int32_t SPDIFRX_DR_10_RXNEIE_POS = INT32_C(0);       /** @brief RXNE interrupt enable */
    static const int32_t SPDIFRX_DR_10_CSRNEIE_POS = INT32_C(1);      /** @brief Control buffer ready interrupt enable */
    static const int32_t SPDIFRX_DR_10_PERRIE_POS = INT32_C(2);       /** @brief Parity error interrupt enable */
    static const int32_t SPDIFRX_DR_10_OVRIE_POS = INT32_C(3);        /** @brief Overrun error interrupt enable */
    static const int32_t SPDIFRX_DR_10_SBLKIE_POS = INT32_C(4);       /** @brief Synchronization block detected interrupt enable */
    static const int32_t SPDIFRX_DR_10_SYNCDIE_POS = INT32_C(5);      /** @brief Synchronization done */
    static const int32_t SPDIFRX_DR_10_IFEIE_POS = INT32_C(6);        /** @brief Serial interface error interrupt enable */
    static const int32_t SPDIFRX_DR_10_RXNE_POS = INT32_C(0);         /** @brief Read data register not empty */
    static const int32_t SPDIFRX_DR_10_CSRNE_POS = INT32_C(1);        /** @brief Control buffer register is not empty */
    static const int32_t SPDIFRX_DR_10_PERR_POS = INT32_C(2);         /** @brief Parity error */
    static const int32_t SPDIFRX_DR_10_OVR_POS = INT32_C(3);          /** @brief Overrun error */
    static const int32_t SPDIFRX_DR_10_SBD_POS = INT32_C(4);          /** @brief Synchronization block detected */
    static const int32_t SPDIFRX_DR_10_SYNCD_POS = INT32_C(5);        /** @brief Synchronization done */
    static const int32_t SPDIFRX_DR_10_FERR_POS = INT32_C(6);         /** @brief Framing error */
    static const int32_t SPDIFRX_DR_10_SERR_POS = INT32_C(7);         /** @brief Synchronization error */
    static const int32_t SPDIFRX_DR_10_TERR_POS = INT32_C(8);         /** @brief Time-out error */
    static const int32_t SPDIFRX_DR_10_WIDTH5_POS = INT32_C(16);      /** @brief Duration of 5 symbols counted with SPDIF_CLK */
    static const int32_t SPDIFRX_DR_10_PERRCF_POS = INT32_C(2);       /** @brief Clears the parity error flag */
    static const int32_t SPDIFRX_DR_10_OVRCF_POS = INT32_C(3);        /** @brief Clears the overrun error flag */
    static const int32_t SPDIFRX_DR_10_SBDCF_POS = INT32_C(4);        /** @brief Clears the synchronization block detected flag */
    static const int32_t SPDIFRX_DR_10_SYNCDCF_POS = INT32_C(5);      /** @brief Clears the synchronization done flag */
    static const int32_t SPDIFRX_DR_10_DR_POS = INT32_C(0);           /** @brief Parity error bit */
    static const int32_t SPDIFRX_DR_10_PE_POS = INT32_C(24);          /** @brief Parity error bit */
    static const int32_t SPDIFRX_DR_10_V_POS = INT32_C(25);           /** @brief Validity bit */
    static const int32_t SPDIFRX_DR_10_U_POS = INT32_C(26);           /** @brief User bit */
    static const int32_t SPDIFRX_DR_10_C_POS = INT32_C(27);           /** @brief Channel status bit */
    static const int32_t SPDIFRX_DR_10_PT_POS = INT32_C(28);          /** @brief Preamble type */
    static const int32_t SPDIFRX_DR_10_USR_POS = INT32_C(0);          /** @brief User data information */
    static const int32_t SPDIFRX_DR_10_CS_POS = INT32_C(16);          /** @brief Channel A status information */
    static const int32_t SPDIFRX_DR_10_SOB_POS = INT32_C(24);         /** @brief Start of block */
    static const int32_t SPDIFRX_DR_10_THI_POS = INT32_C(0);          /** @brief Threshold HIGH */
    static const int32_t SPDIFRX_DR_10_TLO_POS = INT32_C(16);         /** @brief Threshold LOW */
    static const int32_t SPDIFRX_DR_10_MINREV_POS = INT32_C(0);       /** @brief Minor revision */
    static const int32_t SPDIFRX_DR_10_MAJREV_POS = INT32_C(4);       /** @brief Major revision */
    static const int32_t SPDIFRX_DR_10_PE_POS = INT32_C(0);           /** @brief Parity error bit */
    static const int32_t SPDIFRX_DR_10_V_POS = INT32_C(1);            /** @brief Validity bit */
    static const int32_t SPDIFRX_DR_10_U_POS = INT32_C(2);            /** @brief User bit */
    static const int32_t SPDIFRX_DR_10_C_POS = INT32_C(3);            /** @brief Channel status bit */
    static const int32_t SPDIFRX_DR_10_PT_POS = INT32_C(4);           /** @brief Preamble type */
    static const int32_t SPDIFRX_DR_10_DR_POS = INT32_C(8);           /** @brief Data value */
    static const int32_t SPDIFRX_DR_10_DRNL1_POS = INT32_C(0);        /** @brief Data value */
    static const int32_t SPDIFRX_DR_10_DRNL2_POS = INT32_C(16);       /** @brief Data value */

    /**********************************************************************************************
     * @section ADCX Definitions
     **********************************************************************************************/

    /** @subsection ADCX IRQ interrupt definitions */

    static const int32_t ADC3_IRQ = INT32_C(127);   /** @brief ADC3 global interrupt */

    /** @subsection ADCX register array definitions */

    static _RW uint32_t* const ADCX_ISR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022000),   /** @brief ADC interrupt and status register */
      (_RW uint32_t* const)UINT32_C(0x40022100),   /** @brief ADC interrupt and status register */
      (_RW uint32_t* const)UINT32_C(0x58026000),   /** @brief ADC interrupt and status register */
    };

    static _RW uint32_t* const ADCX_IER_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022004),   /** @brief ADC interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x40022104),   /** @brief ADC interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x58026004),   /** @brief ADC interrupt enable register */
    };

    static _RW uint32_t* const ADCX_CR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022008),   /** @brief ADC control register */
      (_RW uint32_t* const)UINT32_C(0x40022108),   /** @brief ADC control register */
      (_RW uint32_t* const)UINT32_C(0x58026008),   /** @brief ADC control register */
    };

    static _RW uint32_t* const ADCX_CFGR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4002200C),   /** @brief ADC configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x4002210C),   /** @brief ADC configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x5802600C),   /** @brief ADC configuration register 1 */
    };

    static _RW uint32_t* const ADCX_CFGR2_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022010),   /** @brief ADC configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x40022110),   /** @brief ADC configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58026010),   /** @brief ADC configuration register 2 */
    };

    static _RW uint32_t* const ADCX_SMPR1_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022014),   /** @brief ADC sampling time register 1 */
      (_RW uint32_t* const)UINT32_C(0x40022114),   /** @brief ADC sampling time register 1 */
      (_RW uint32_t* const)UINT32_C(0x58026014),   /** @brief ADC sampling time register 1 */
    };

    static _RW uint32_t* const ADCX_SMPR2_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022018),   /** @brief ADC sampling time register 2 */
      (_RW uint32_t* const)UINT32_C(0x40022118),   /** @brief ADC sampling time register 2 */
      (_RW uint32_t* const)UINT32_C(0x58026018),   /** @brief ADC sampling time register 2 */
    };

    static _RW uint32_t* const ADCX_LTRX_REG[4][4] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40022020),   /** @brief ADC analog watchdog 1 threshold register */
        (_RW uint32_t* const)UINT32_C(0x400220B0),   /** @brief ADC watchdog lower threshold register 2 */
        (_RW uint32_t* const)UINT32_C(0x400220B8),   /** @brief ADC watchdog lower threshold register 3 */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40022120),   /** @brief ADC analog watchdog 1 threshold register */
        (_RW uint32_t* const)UINT32_C(0x400221B0),   /** @brief ADC watchdog lower threshold register 2 */
        (_RW uint32_t* const)UINT32_C(0x400221B8),   /** @brief ADC watchdog lower threshold register 3 */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x58026020),   /** @brief ADC analog watchdog 1 threshold register */
        (_RW uint32_t* const)UINT32_C(0x580260B0),   /** @brief ADC watchdog lower threshold register 2 */
        (_RW uint32_t* const)UINT32_C(0x580260B8),   /** @brief ADC watchdog lower threshold register 3 */
      },
    };

    static _RW uint32_t* const ADCX_LHTR1_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022024),   /** @brief ADC analog watchdog 2 threshold register */
      (_RW uint32_t* const)UINT32_C(0x40022124),   /** @brief ADC analog watchdog 2 threshold register */
      (_RW uint32_t* const)UINT32_C(0x58026024),   /** @brief ADC analog watchdog 2 threshold register */
    };

    static _RW uint32_t* const ADCX_SQR1_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022030),   /** @brief ADC group regular sequencer ranks register 1 */
      (_RW uint32_t* const)UINT32_C(0x40022130),   /** @brief ADC group regular sequencer ranks register 1 */
      (_RW uint32_t* const)UINT32_C(0x58026030),   /** @brief ADC group regular sequencer ranks register 1 */
    };

    static _RW uint32_t* const ADCX_SQR2_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022034),   /** @brief ADC group regular sequencer ranks register 2 */
      (_RW uint32_t* const)UINT32_C(0x40022134),   /** @brief ADC group regular sequencer ranks register 2 */
      (_RW uint32_t* const)UINT32_C(0x58026034),   /** @brief ADC group regular sequencer ranks register 2 */
    };

    static _RW uint32_t* const ADCX_SQR3_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022038),   /** @brief ADC group regular sequencer ranks register 3 */
      (_RW uint32_t* const)UINT32_C(0x40022138),   /** @brief ADC group regular sequencer ranks register 3 */
      (_RW uint32_t* const)UINT32_C(0x58026038),   /** @brief ADC group regular sequencer ranks register 3 */
    };

    static _RW uint32_t* const ADCX_SQR4_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4002203C),   /** @brief ADC group regular sequencer ranks register 4 */
      (_RW uint32_t* const)UINT32_C(0x4002213C),   /** @brief ADC group regular sequencer ranks register 4 */
      (_RW uint32_t* const)UINT32_C(0x5802603C),   /** @brief ADC group regular sequencer ranks register 4 */
    };

    static _RO uint32_t* const ADCX_DR_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40022040),   /** @brief ADC group regular conversion data register */
      (_RO uint32_t* const)UINT32_C(0x40022140),   /** @brief ADC group regular conversion data register */
      (_RO uint32_t* const)UINT32_C(0x58026040),   /** @brief ADC group regular conversion data register */
    };

    static _RW uint32_t* const ADCX_JSQR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4002204C),   /** @brief ADC group injected sequencer register */
      (_RW uint32_t* const)UINT32_C(0x4002214C),   /** @brief ADC group injected sequencer register */
      (_RW uint32_t* const)UINT32_C(0x5802604C),   /** @brief ADC group injected sequencer register */
    };

    static _RW uint32_t* const ADCX_OFRX_REG[4][5] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40022060),   /** @brief ADC offset number 1 register */
        (_RW uint32_t* const)UINT32_C(0x40022064),   /** @brief ADC offset number 2 register */
        (_RW uint32_t* const)UINT32_C(0x40022068),   /** @brief ADC offset number 3 register */
        (_RW uint32_t* const)UINT32_C(0x4002206C),   /** @brief ADC offset number 4 register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40022160),   /** @brief ADC offset number 1 register */
        (_RW uint32_t* const)UINT32_C(0x40022164),   /** @brief ADC offset number 2 register */
        (_RW uint32_t* const)UINT32_C(0x40022168),   /** @brief ADC offset number 3 register */
        (_RW uint32_t* const)UINT32_C(0x4002216C),   /** @brief ADC offset number 4 register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x58026060),   /** @brief ADC offset number 1 register */
        (_RW uint32_t* const)UINT32_C(0x58026064),   /** @brief ADC offset number 2 register */
        (_RW uint32_t* const)UINT32_C(0x58026068),   /** @brief ADC offset number 3 register */
        (_RW uint32_t* const)UINT32_C(0x5802606C),   /** @brief ADC offset number 4 register */
      },
    };

    static _RO uint32_t* const ADCX_JDRX_REG[4][5] = {
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x40022080),   /** @brief ADC group injected sequencer rank 1 register */
        (_RO uint32_t* const)UINT32_C(0x40022084),   /** @brief ADC group injected sequencer rank 2 register */
        (_RO uint32_t* const)UINT32_C(0x40022088),   /** @brief ADC group injected sequencer rank 3 register */
        (_RO uint32_t* const)UINT32_C(0x4002208C),   /** @brief ADC group injected sequencer rank 4 register */
      },
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x40022180),   /** @brief ADC group injected sequencer rank 1 register */
        (_RO uint32_t* const)UINT32_C(0x40022184),   /** @brief ADC group injected sequencer rank 2 register */
        (_RO uint32_t* const)UINT32_C(0x40022188),   /** @brief ADC group injected sequencer rank 3 register */
        (_RO uint32_t* const)UINT32_C(0x4002218C),   /** @brief ADC group injected sequencer rank 4 register */
      },
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x58026080),   /** @brief ADC group injected sequencer rank 1 register */
        (_RO uint32_t* const)UINT32_C(0x58026084),   /** @brief ADC group injected sequencer rank 2 register */
        (_RO uint32_t* const)UINT32_C(0x58026088),   /** @brief ADC group injected sequencer rank 3 register */
        (_RO uint32_t* const)UINT32_C(0x5802608C),   /** @brief ADC group injected sequencer rank 4 register */
      },
    };

    static _RW uint32_t* const ADCX_AWD2CR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400220A0),   /** @brief ADC analog watchdog 2 configuration register */
      (_RW uint32_t* const)UINT32_C(0x400221A0),   /** @brief ADC analog watchdog 2 configuration register */
      (_RW uint32_t* const)UINT32_C(0x580260A0),   /** @brief ADC analog watchdog 2 configuration register */
    };

    static _RW uint32_t* const ADCX_AWD3CR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400220A4),   /** @brief ADC analog watchdog 3 configuration register */
      (_RW uint32_t* const)UINT32_C(0x400221A4),   /** @brief ADC analog watchdog 3 configuration register */
      (_RW uint32_t* const)UINT32_C(0x580260A4),   /** @brief ADC analog watchdog 3 configuration register */
    };

    static _RW uint32_t* const ADCX_DIFSEL_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400220C0),   /** @brief ADC channel differential or single-ended mode selection register */
      (_RW uint32_t* const)UINT32_C(0x400221C0),   /** @brief ADC channel differential or single-ended mode selection register */
      (_RW uint32_t* const)UINT32_C(0x580260C0),   /** @brief ADC channel differential or single-ended mode selection register */
    };

    static _RW uint32_t* const ADCX_CALFACT_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400220C4),   /** @brief ADC calibration factors register */
      (_RW uint32_t* const)UINT32_C(0x400221C4),   /** @brief ADC calibration factors register */
      (_RW uint32_t* const)UINT32_C(0x580260C4),   /** @brief ADC calibration factors register */
    };

    static _RW uint32_t* const ADCX_PCSEL_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4002201C),   /** @brief ADC pre channel selection register */
      (_RW uint32_t* const)UINT32_C(0x4002211C),   /** @brief ADC pre channel selection register */
      (_RW uint32_t* const)UINT32_C(0x5802601C),   /** @brief ADC pre channel selection register */
    };

    static _RW uint32_t* const ADCX_HTR2_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400220B4),   /** @brief ADC watchdog higher threshold register 2 */
      (_RW uint32_t* const)UINT32_C(0x400221B4),   /** @brief ADC watchdog higher threshold register 2 */
      (_RW uint32_t* const)UINT32_C(0x580260B4),   /** @brief ADC watchdog higher threshold register 2 */
    };

    static _RW uint32_t* const ADCX_HTR3_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400220BC),   /** @brief ADC watchdog higher threshold register 3 */
      (_RW uint32_t* const)UINT32_C(0x400221BC),   /** @brief ADC watchdog higher threshold register 3 */
      (_RW uint32_t* const)UINT32_C(0x580260BC),   /** @brief ADC watchdog higher threshold register 3 */
    };

    static _RW uint32_t* const ADCX_CALFACT2_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400220C8),   /** @brief ADC calibration factor register 2 */
      (_RW uint32_t* const)UINT32_C(0x400221C8),   /** @brief ADC calibration factor register 2 */
      (_RW uint32_t* const)UINT32_C(0x580260C8),   /** @brief ADC calibration factor register 2 */
    };

    /** @subsection ADCX field mask array definitions */

    static const uint32_t ADCX_ISR_AWDX_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000080),   /** @brief ADC analog watchdog 1 flag */
      UINT32_C(0x00000100),   /** @brief ADC analog watchdog 2 flag */
      UINT32_C(0x00000200),   /** @brief ADC analog watchdog 3 flag */
    };

    static const uint32_t ADCX_IER_AWDXIE_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000080),   /** @brief ADC analog watchdog 1 interrupt */
      UINT32_C(0x00000100),   /** @brief ADC analog watchdog 2 interrupt */
      UINT32_C(0x00000200),   /** @brief ADC analog watchdog 3 interrupt */
    };

    static const uint32_t ADCX_CR_LINCALRDYWX_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief Linearity calibration ready word 1 */
      UINT32_C(0x00800000),   /** @brief Linearity calibration ready word 2 */
      UINT32_C(0x01000000),   /** @brief Linearity calibration ready word 3 */
      UINT32_C(0x02000000),   /** @brief Linearity calibration ready word 4 */
      UINT32_C(0x04000000),   /** @brief Linearity calibration ready word 5 */
      UINT32_C(0x08000000),   /** @brief Linearity calibration ready word 6 */
    };

    static const uint32_t ADCX_CFGR2_RSHIFTX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000800),   /** @brief Right-shift data after offset 1 correction */
      UINT32_C(0x00001000),   /** @brief Right-shift data after offset 2 correction */
      UINT32_C(0x00002000),   /** @brief Right-shift data after offset 3 correction */
      UINT32_C(0x00004000),   /** @brief Right-shift data after offset 4 correction */
    };

    static const uint32_t ADCX_SMPR1_SMPX_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000038),   /** @brief ADC channel 1 sampling time selection */
      UINT32_C(0x000001C0),   /** @brief ADC channel 2 sampling time selection */
      UINT32_C(0x00000E00),   /** @brief ADC channel 3 sampling time selection */
      UINT32_C(0x00007000),   /** @brief ADC channel 4 sampling time selection */
      UINT32_C(0x00038000),   /** @brief ADC channel 5 sampling time selection */
      UINT32_C(0x001C0000),   /** @brief ADC channel 6 sampling time selection */
      UINT32_C(0x00E00000),   /** @brief ADC channel 7 sampling time selection */
      UINT32_C(0x07000000),   /** @brief ADC channel 8 sampling time selection */
      UINT32_C(0x38000000),   /** @brief ADC channel 9 sampling time selection */
    };

    static const uint32_t ADCX_SMPR2_SMP1X_MASK[10] = {
      UINT32_C(0x00000007),   /** @brief ADC channel 10 sampling time selection */
      UINT32_C(0x00000038),   /** @brief ADC channel 11 sampling time selection */
      UINT32_C(0x000001C0),   /** @brief ADC channel 12 sampling time selection */
      UINT32_C(0x00000E00),   /** @brief ADC channel 13 sampling time selection */
      UINT32_C(0x00007000),   /** @brief ADC channel 14 sampling time selection */
      UINT32_C(0x00038000),   /** @brief ADC channel 15 sampling time selection */
      UINT32_C(0x001C0000),   /** @brief ADC channel 16 sampling time selection */
      UINT32_C(0x00E00000),   /** @brief ADC channel 17 sampling time selection */
      UINT32_C(0x07000000),   /** @brief ADC channel 18 sampling time selection */
      UINT32_C(0x38000000),   /** @brief ADC channel 18 sampling time selection */
    };

    static const uint32_t ADCX_SQR1_SQX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x000007C0),   /** @brief ADC group regular sequencer rank 1 */
      UINT32_C(0x0001F000),   /** @brief ADC group regular sequencer rank 2 */
      UINT32_C(0x007C0000),   /** @brief ADC group regular sequencer rank 3 */
      UINT32_C(0x1F000000),   /** @brief ADC group regular sequencer rank 4 */
    };

    static const uint32_t ADCX_SQR3_SQ1X_MASK[5] = {
      UINT32_C(0x0000001F),   /** @brief ADC group regular sequencer rank 10 */
      UINT32_C(0x000007C0),   /** @brief ADC group regular sequencer rank 11 */
      UINT32_C(0x0001F000),   /** @brief ADC group regular sequencer rank 12 */
      UINT32_C(0x007C0000),   /** @brief ADC group regular sequencer rank 13 */
      UINT32_C(0x1F000000),   /** @brief ADC group regular sequencer rank 14 */
    };

    static const uint32_t ADCX_JSQR_JSQX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00003E00),   /** @brief ADC group injected sequencer rank 1 */
      UINT32_C(0x000F8000),   /** @brief ADC group injected sequencer rank 2 */
      UINT32_C(0x03E00000),   /** @brief ADC group injected sequencer rank 3 */
      UINT32_C(0xF8000000),   /** @brief ADC group injected sequencer rank 4 */
    };

    /** @subsection ADCX field mask definitions */

    static const uint32_t ADCX_ISR_JQOVF_MASK = UINT32_C(0x00000400);             /** @brief ADC group injected contexts queue overflow flag */
    static const uint32_t ADCX_ISR_JEOS_MASK = UINT32_C(0x00000040);              /** @brief ADC group injected end of sequence conversions flag */
    static const uint32_t ADCX_ISR_JEOC_MASK = UINT32_C(0x00000020);              /** @brief ADC group injected end of unitary conversion flag */
    static const uint32_t ADCX_ISR_OVR_MASK = UINT32_C(0x00000010);               /** @brief ADC group regular overrun flag */
    static const uint32_t ADCX_ISR_EOS_MASK = UINT32_C(0x00000008);               /** @brief ADC group regular end of sequence conversions flag */
    static const uint32_t ADCX_ISR_EOC_MASK = UINT32_C(0x00000004);               /** @brief ADC group regular end of unitary conversion flag */
    static const uint32_t ADCX_ISR_EOSMP_MASK = UINT32_C(0x00000002);             /** @brief ADC group regular end of sampling flag */
    static const uint32_t ADCX_ISR_ADRDY_MASK = UINT32_C(0x00000001);             /** @brief ADC ready flag */
    static const uint32_t ADCX_IER_JQOVFIE_MASK = UINT32_C(0x00000400);           /** @brief ADC group injected contexts queue overflow interrupt */
    static const uint32_t ADCX_IER_JEOSIE_MASK = UINT32_C(0x00000040);            /** @brief ADC group injected end of sequence conversions interrupt */
    static const uint32_t ADCX_IER_JEOCIE_MASK = UINT32_C(0x00000020);            /** @brief ADC group injected end of unitary conversion interrupt */
    static const uint32_t ADCX_IER_OVRIE_MASK = UINT32_C(0x00000010);             /** @brief ADC group regular overrun interrupt */
    static const uint32_t ADCX_IER_EOSIE_MASK = UINT32_C(0x00000008);             /** @brief ADC group regular end of sequence conversions interrupt */
    static const uint32_t ADCX_IER_EOCIE_MASK = UINT32_C(0x00000004);             /** @brief ADC group regular end of unitary conversion interrupt */
    static const uint32_t ADCX_IER_EOSMPIE_MASK = UINT32_C(0x00000002);           /** @brief ADC group regular end of sampling interrupt */
    static const uint32_t ADCX_IER_ADRDYIE_MASK = UINT32_C(0x00000001);           /** @brief ADC ready interrupt */
    static const uint32_t ADCX_CR_ADCAL_MASK = UINT32_C(0x80000000);              /** @brief ADC calibration */
    static const uint32_t ADCX_CR_ADCALDIF_MASK = UINT32_C(0x40000000);           /** @brief ADC differential mode for calibration */
    static const uint32_t ADCX_CR_DEEPPWD_MASK = UINT32_C(0x20000000);            /** @brief ADC deep power down enable */
    static const uint32_t ADCX_CR_ADVREGEN_MASK = UINT32_C(0x10000000);           /** @brief ADC voltage regulator enable */
    static const uint32_t ADCX_CR_ADCALLIN_MASK = UINT32_C(0x00010000);           /** @brief Linearity calibration */
    static const uint32_t ADCX_CR_BOOST_MASK = UINT32_C(0x00000300);              /** @brief Boost mode control */
    static const uint32_t ADCX_CR_JADSTP_MASK = UINT32_C(0x00000020);             /** @brief ADC group injected conversion stop */
    static const uint32_t ADCX_CR_ADSTP_MASK = UINT32_C(0x00000010);              /** @brief ADC group regular conversion stop */
    static const uint32_t ADCX_CR_JADSTART_MASK = UINT32_C(0x00000008);           /** @brief ADC group injected conversion start */
    static const uint32_t ADCX_CR_ADSTART_MASK = UINT32_C(0x00000004);            /** @brief ADC group regular conversion start */
    static const uint32_t ADCX_CR_ADDIS_MASK = UINT32_C(0x00000002);              /** @brief ADC disable */
    static const uint32_t ADCX_CR_ADEN_MASK = UINT32_C(0x00000001);               /** @brief ADC enable */
    static const uint32_t ADCX_CFGR_JQDIS_MASK = UINT32_C(0x80000000);            /** @brief ADC group injected contexts queue disable */
    static const uint32_t ADCX_CFGR_AWDCH1CH_MASK = UINT32_C(0x7C000000);         /** @brief ADC analog watchdog 1 monitored channel selection */
    static const uint32_t ADCX_CFGR_JAUTO_MASK = UINT32_C(0x02000000);            /** @brief ADC group injected automatic trigger mode */
    static const uint32_t ADCX_CFGR_JAWD1EN_MASK = UINT32_C(0x01000000);          /** @brief ADC analog watchdog 1 enable on scope ADC group injected */
    static const uint32_t ADCX_CFGR_AWD1EN_MASK = UINT32_C(0x00800000);           /** @brief ADC analog watchdog 1 enable on scope ADC group regular */
    static const uint32_t ADCX_CFGR_AWD1SGL_MASK = UINT32_C(0x00400000);          /** @brief ADC analog watchdog 1 monitoring a single channel or all channels */
    static const uint32_t ADCX_CFGR_JQM_MASK = UINT32_C(0x00200000);              /** @brief ADC group injected contexts queue mode */
    static const uint32_t ADCX_CFGR_JDISCEN_MASK = UINT32_C(0x00100000);          /** @brief ADC group injected sequencer discontinuous mode */
    static const uint32_t ADCX_CFGR_DISCNUM_MASK = UINT32_C(0x000E0000);          /** @brief ADC group regular sequencer discontinuous number of ranks */
    static const uint32_t ADCX_CFGR_DISCEN_MASK = UINT32_C(0x00010000);           /** @brief ADC group regular sequencer discontinuous mode */
    static const uint32_t ADCX_CFGR_AUTDLY_MASK = UINT32_C(0x00004000);           /** @brief ADC low power auto wait */
    static const uint32_t ADCX_CFGR_CONT_MASK = UINT32_C(0x00002000);             /** @brief ADC group regular continuous conversion mode */
    static const uint32_t ADCX_CFGR_OVRMOD_MASK = UINT32_C(0x00001000);           /** @brief ADC group regular overrun configuration */
    static const uint32_t ADCX_CFGR_EXTEN_MASK = UINT32_C(0x00000C00);            /** @brief ADC group regular external trigger polarity */
    static const uint32_t ADCX_CFGR_EXTSEL_MASK = UINT32_C(0x000003E0);           /** @brief ADC group regular external trigger source */
    static const uint32_t ADCX_CFGR_RES_MASK = UINT32_C(0x0000001C);              /** @brief ADC data resolution */
    static const uint32_t ADCX_CFGR_DMNGT_MASK = UINT32_C(0x00000003);            /** @brief ADC DMA transfer enable */
    static const uint32_t ADCX_CFGR2_ROVSE_MASK = UINT32_C(0x00000001);           /** @brief ADC oversampler enable on scope ADC group regular */
    static const uint32_t ADCX_CFGR2_JOVSE_MASK = UINT32_C(0x00000002);           /** @brief ADC oversampler enable on scope ADC group injected */
    static const uint32_t ADCX_CFGR2_OVSS_MASK = UINT32_C(0x000001E0);            /** @brief ADC oversampling shift */
    static const uint32_t ADCX_CFGR2_TROVS_MASK = UINT32_C(0x00000200);           /** @brief ADC oversampling discontinuous mode (triggered mode) for ADC group regular */
    static const uint32_t ADCX_CFGR2_ROVSM_MASK = UINT32_C(0x00000400);           /** @brief Regular oversampling mode */
    static const uint32_t ADCX_CFGR2_OSR_MASK = UINT32_C(0x03FF0000);             /** @brief Oversampling ratio */
    static const uint32_t ADCX_CFGR2_LSHIFT_MASK = UINT32_C(0xF0000000);          /** @brief Left shift factor */
    static const uint32_t ADCX_LTRX_LTR1_MASK = UINT32_C(0x03FFFFFF);             /** @brief ADC analog watchdog 1 threshold low */
    static const uint32_t ADCX_LHTR1_LHTR1_MASK = UINT32_C(0x03FFFFFF);           /** @brief ADC analog watchdog 2 threshold low */
    static const uint32_t ADCX_SQR1_L3_MASK = UINT32_C(0x0000000F);               /** @brief L3 */
    static const uint32_t ADCX_SQR4_SQ16_MASK = UINT32_C(0x000007C0);             /** @brief ADC group regular sequencer rank 16 */
    static const uint32_t ADCX_SQR4_SQ15_MASK = UINT32_C(0x0000001F);             /** @brief ADC group regular sequencer rank 15 */
    static const uint32_t ADCX_DR_RDATA_MASK = UINT32_C(0x0000FFFF);              /** @brief ADC group regular conversion data */
    static const uint32_t ADCX_JSQR_JEXTEN_MASK = UINT32_C(0x00000180);           /** @brief ADC group injected external trigger polarity */
    static const uint32_t ADCX_JSQR_JEXTSEL_MASK = UINT32_C(0x0000007C);          /** @brief ADC group injected external trigger source */
    static const uint32_t ADCX_JSQR_JL_MASK = UINT32_C(0x00000003);               /** @brief ADC group injected sequencer scan length */
    static const uint32_t ADCX_OFRX_SSATE_MASK = UINT32_C(0x80000000);            /** @brief ADC offset number 1 enable */
    static const uint32_t ADCX_OFRX_OFFSET1_CH_MASK = UINT32_C(0x7C000000);       /** @brief ADC offset number 1 channel selection */
    static const uint32_t ADCX_OFRX_OFFSET1_MASK = UINT32_C(0x03FFFFFF);          /** @brief ADC offset number 1 offset level */
    static const uint32_t ADCX_OFRX_SSATE_MASK = UINT32_C(0x80000000);            /** @brief ADC offset number 1 enable */
    static const uint32_t ADCX_OFRX_OFFSET1_CH_MASK = UINT32_C(0x7C000000);       /** @brief ADC offset number 1 channel selection */
    static const uint32_t ADCX_OFRX_OFFSET1_MASK = UINT32_C(0x03FFFFFF);          /** @brief ADC offset number 1 offset level */
    static const uint32_t ADCX_OFRX_SSATE_MASK = UINT32_C(0x80000000);            /** @brief ADC offset number 1 enable */
    static const uint32_t ADCX_OFRX_OFFSET1_CH_MASK = UINT32_C(0x7C000000);       /** @brief ADC offset number 1 channel selection */
    static const uint32_t ADCX_OFRX_OFFSET1_MASK = UINT32_C(0x03FFFFFF);          /** @brief ADC offset number 1 offset level */
    static const uint32_t ADCX_OFRX_SSATE_MASK = UINT32_C(0x80000000);            /** @brief ADC offset number 1 enable */
    static const uint32_t ADCX_OFRX_OFFSET1_CH_MASK = UINT32_C(0x7C000000);       /** @brief ADC offset number 1 channel selection */
    static const uint32_t ADCX_OFRX_OFFSET1_MASK = UINT32_C(0x03FFFFFF);          /** @brief ADC offset number 1 offset level */
    static const uint32_t ADCX_AWD2CR_AWD2CH_MASK = UINT32_C(0x000FFFFF);         /** @brief ADC analog watchdog 2 monitored channel selection */
    static const uint32_t ADCX_AWD3CR_AWD3CH_MASK = UINT32_C(0x001FFFFE);         /** @brief ADC analog watchdog 3 monitored channel selection */
    static const uint32_t ADCX_DIFSEL_DIFSEL_MASK = UINT32_C(0x000FFFFF);         /** @brief ADC channel differential or single-ended mode for channel */
    static const uint32_t ADCX_CALFACT_CALFACT_D_MASK = UINT32_C(0x07FF0000);     /** @brief ADC calibration factor in differential mode */
    static const uint32_t ADCX_CALFACT_CALFACT_S_MASK = UINT32_C(0x000007FF);     /** @brief ADC calibration factor in single-ended mode */
    static const uint32_t ADCX_PCSEL_PCSEL_MASK = UINT32_C(0x000FFFFF);           /** @brief Channel x (vinp[i]) pre selection */
    static const uint32_t ADCX_LTRX_LTR2_MASK = UINT32_C(0x03FFFFFF);             /** @brief Analog watchdog 2 lower threshold */
    static const uint32_t ADCX_HTR2_HTR2_MASK = UINT32_C(0x03FFFFFF);             /** @brief Analog watchdog 2 higher threshold */
    static const uint32_t ADCX_LTRX_LTR3_MASK = UINT32_C(0x03FFFFFF);             /** @brief Analog watchdog 3 lower threshold */
    static const uint32_t ADCX_HTR3_HTR3_MASK = UINT32_C(0x03FFFFFF);             /** @brief Analog watchdog 3 higher threshold */
    static const uint32_t ADCX_CALFACT2_LINCALFACT_MASK = UINT32_C(0x3FFFFFFF);   /** @brief Linearity calibration factor */

    /** @subsection ADCX field position array definitions */

    static const int32_t ADCX_CALFACT2_AWDX_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(7),    /** @brief ADC analog watchdog 1 flag */
      INT32_C(8),    /** @brief ADC analog watchdog 2 flag */
      INT32_C(9),    /** @brief ADC analog watchdog 3 flag */
    };

    static const int32_t ADCX_CALFACT2_AWDXIE_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(7),    /** @brief ADC analog watchdog 1 interrupt */
      INT32_C(8),    /** @brief ADC analog watchdog 2 interrupt */
      INT32_C(9),    /** @brief ADC analog watchdog 3 interrupt */
    };

    static const int32_t ADCX_CALFACT2_LINCALRDYWX_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief Linearity calibration ready word 1 */
      INT32_C(23),   /** @brief Linearity calibration ready word 2 */
      INT32_C(24),   /** @brief Linearity calibration ready word 3 */
      INT32_C(25),   /** @brief Linearity calibration ready word 4 */
      INT32_C(26),   /** @brief Linearity calibration ready word 5 */
      INT32_C(27),   /** @brief Linearity calibration ready word 6 */
    };

    static const int32_t ADCX_CALFACT2_RSHIFTX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(11),   /** @brief Right-shift data after offset 1 correction */
      INT32_C(12),   /** @brief Right-shift data after offset 2 correction */
      INT32_C(13),   /** @brief Right-shift data after offset 3 correction */
      INT32_C(14),   /** @brief Right-shift data after offset 4 correction */
    };

    static const int32_t ADCX_CALFACT2_SMPX_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief ADC channel 1 sampling time selection */
      INT32_C(6),    /** @brief ADC channel 2 sampling time selection */
      INT32_C(9),    /** @brief ADC channel 3 sampling time selection */
      INT32_C(12),   /** @brief ADC channel 4 sampling time selection */
      INT32_C(15),   /** @brief ADC channel 5 sampling time selection */
      INT32_C(18),   /** @brief ADC channel 6 sampling time selection */
      INT32_C(21),   /** @brief ADC channel 7 sampling time selection */
      INT32_C(24),   /** @brief ADC channel 8 sampling time selection */
      INT32_C(27),   /** @brief ADC channel 9 sampling time selection */
    };

    static const int32_t ADCX_CALFACT2_SMP1X_POS[10] = {
      INT32_C(0),    /** @brief ADC channel 10 sampling time selection */
      INT32_C(3),    /** @brief ADC channel 11 sampling time selection */
      INT32_C(6),    /** @brief ADC channel 12 sampling time selection */
      INT32_C(9),    /** @brief ADC channel 13 sampling time selection */
      INT32_C(12),   /** @brief ADC channel 14 sampling time selection */
      INT32_C(15),   /** @brief ADC channel 15 sampling time selection */
      INT32_C(18),   /** @brief ADC channel 16 sampling time selection */
      INT32_C(21),   /** @brief ADC channel 17 sampling time selection */
      INT32_C(24),   /** @brief ADC channel 18 sampling time selection */
      INT32_C(27),   /** @brief ADC channel 18 sampling time selection */
    };

    static const int32_t ADCX_CALFACT2_SQX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief ADC group regular sequencer rank 1 */
      INT32_C(12),   /** @brief ADC group regular sequencer rank 2 */
      INT32_C(18),   /** @brief ADC group regular sequencer rank 3 */
      INT32_C(24),   /** @brief ADC group regular sequencer rank 4 */
    };

    static const int32_t ADCX_CALFACT2_SQ1X_POS[5] = {
      INT32_C(0),    /** @brief ADC group regular sequencer rank 10 */
      INT32_C(6),    /** @brief ADC group regular sequencer rank 11 */
      INT32_C(12),   /** @brief ADC group regular sequencer rank 12 */
      INT32_C(18),   /** @brief ADC group regular sequencer rank 13 */
      INT32_C(24),   /** @brief ADC group regular sequencer rank 14 */
    };

    static const int32_t ADCX_CALFACT2_JSQX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief ADC group injected sequencer rank 1 */
      INT32_C(15),   /** @brief ADC group injected sequencer rank 2 */
      INT32_C(21),   /** @brief ADC group injected sequencer rank 3 */
      INT32_C(27),   /** @brief ADC group injected sequencer rank 4 */
    };

    /** @subsection ADCX field position definitions */

    static const int32_t ADCX_CALFACT2_JQOVF_POS = INT32_C(10);        /** @brief ADC group injected contexts queue overflow flag */
    static const int32_t ADCX_CALFACT2_JEOS_POS = INT32_C(6);          /** @brief ADC group injected end of sequence conversions flag */
    static const int32_t ADCX_CALFACT2_JEOC_POS = INT32_C(5);          /** @brief ADC group injected end of unitary conversion flag */
    static const int32_t ADCX_CALFACT2_OVR_POS = INT32_C(4);           /** @brief ADC group regular overrun flag */
    static const int32_t ADCX_CALFACT2_EOS_POS = INT32_C(3);           /** @brief ADC group regular end of sequence conversions flag */
    static const int32_t ADCX_CALFACT2_EOC_POS = INT32_C(2);           /** @brief ADC group regular end of unitary conversion flag */
    static const int32_t ADCX_CALFACT2_EOSMP_POS = INT32_C(1);         /** @brief ADC group regular end of sampling flag */
    static const int32_t ADCX_CALFACT2_ADRDY_POS = INT32_C(0);         /** @brief ADC ready flag */
    static const int32_t ADCX_CALFACT2_JQOVFIE_POS = INT32_C(10);      /** @brief ADC group injected contexts queue overflow interrupt */
    static const int32_t ADCX_CALFACT2_JEOSIE_POS = INT32_C(6);        /** @brief ADC group injected end of sequence conversions interrupt */
    static const int32_t ADCX_CALFACT2_JEOCIE_POS = INT32_C(5);        /** @brief ADC group injected end of unitary conversion interrupt */
    static const int32_t ADCX_CALFACT2_OVRIE_POS = INT32_C(4);         /** @brief ADC group regular overrun interrupt */
    static const int32_t ADCX_CALFACT2_EOSIE_POS = INT32_C(3);         /** @brief ADC group regular end of sequence conversions interrupt */
    static const int32_t ADCX_CALFACT2_EOCIE_POS = INT32_C(2);         /** @brief ADC group regular end of unitary conversion interrupt */
    static const int32_t ADCX_CALFACT2_EOSMPIE_POS = INT32_C(1);       /** @brief ADC group regular end of sampling interrupt */
    static const int32_t ADCX_CALFACT2_ADRDYIE_POS = INT32_C(0);       /** @brief ADC ready interrupt */
    static const int32_t ADCX_CALFACT2_ADCAL_POS = INT32_C(31);        /** @brief ADC calibration */
    static const int32_t ADCX_CALFACT2_ADCALDIF_POS = INT32_C(30);     /** @brief ADC differential mode for calibration */
    static const int32_t ADCX_CALFACT2_DEEPPWD_POS = INT32_C(29);      /** @brief ADC deep power down enable */
    static const int32_t ADCX_CALFACT2_ADVREGEN_POS = INT32_C(28);     /** @brief ADC voltage regulator enable */
    static const int32_t ADCX_CALFACT2_ADCALLIN_POS = INT32_C(16);     /** @brief Linearity calibration */
    static const int32_t ADCX_CALFACT2_BOOST_POS = INT32_C(8);         /** @brief Boost mode control */
    static const int32_t ADCX_CALFACT2_JADSTP_POS = INT32_C(5);        /** @brief ADC group injected conversion stop */
    static const int32_t ADCX_CALFACT2_ADSTP_POS = INT32_C(4);         /** @brief ADC group regular conversion stop */
    static const int32_t ADCX_CALFACT2_JADSTART_POS = INT32_C(3);      /** @brief ADC group injected conversion start */
    static const int32_t ADCX_CALFACT2_ADSTART_POS = INT32_C(2);       /** @brief ADC group regular conversion start */
    static const int32_t ADCX_CALFACT2_ADDIS_POS = INT32_C(1);         /** @brief ADC disable */
    static const int32_t ADCX_CALFACT2_ADEN_POS = INT32_C(0);          /** @brief ADC enable */
    static const int32_t ADCX_CALFACT2_JQDIS_POS = INT32_C(31);        /** @brief ADC group injected contexts queue disable */
    static const int32_t ADCX_CALFACT2_AWDCH1CH_POS = INT32_C(26);     /** @brief ADC analog watchdog 1 monitored channel selection */
    static const int32_t ADCX_CALFACT2_JAUTO_POS = INT32_C(25);        /** @brief ADC group injected automatic trigger mode */
    static const int32_t ADCX_CALFACT2_JAWD1EN_POS = INT32_C(24);      /** @brief ADC analog watchdog 1 enable on scope ADC group injected */
    static const int32_t ADCX_CALFACT2_AWD1EN_POS = INT32_C(23);       /** @brief ADC analog watchdog 1 enable on scope ADC group regular */
    static const int32_t ADCX_CALFACT2_AWD1SGL_POS = INT32_C(22);      /** @brief ADC analog watchdog 1 monitoring a single channel or all channels */
    static const int32_t ADCX_CALFACT2_JQM_POS = INT32_C(21);          /** @brief ADC group injected contexts queue mode */
    static const int32_t ADCX_CALFACT2_JDISCEN_POS = INT32_C(20);      /** @brief ADC group injected sequencer discontinuous mode */
    static const int32_t ADCX_CALFACT2_DISCNUM_POS = INT32_C(17);      /** @brief ADC group regular sequencer discontinuous number of ranks */
    static const int32_t ADCX_CALFACT2_DISCEN_POS = INT32_C(16);       /** @brief ADC group regular sequencer discontinuous mode */
    static const int32_t ADCX_CALFACT2_AUTDLY_POS = INT32_C(14);       /** @brief ADC low power auto wait */
    static const int32_t ADCX_CALFACT2_CONT_POS = INT32_C(13);         /** @brief ADC group regular continuous conversion mode */
    static const int32_t ADCX_CALFACT2_OVRMOD_POS = INT32_C(12);       /** @brief ADC group regular overrun configuration */
    static const int32_t ADCX_CALFACT2_EXTEN_POS = INT32_C(10);        /** @brief ADC group regular external trigger polarity */
    static const int32_t ADCX_CALFACT2_EXTSEL_POS = INT32_C(5);        /** @brief ADC group regular external trigger source */
    static const int32_t ADCX_CALFACT2_RES_POS = INT32_C(2);           /** @brief ADC data resolution */
    static const int32_t ADCX_CALFACT2_DMNGT_POS = INT32_C(0);         /** @brief ADC DMA transfer enable */
    static const int32_t ADCX_CALFACT2_ROVSE_POS = INT32_C(0);         /** @brief ADC oversampler enable on scope ADC group regular */
    static const int32_t ADCX_CALFACT2_JOVSE_POS = INT32_C(1);         /** @brief ADC oversampler enable on scope ADC group injected */
    static const int32_t ADCX_CALFACT2_OVSS_POS = INT32_C(5);          /** @brief ADC oversampling shift */
    static const int32_t ADCX_CALFACT2_TROVS_POS = INT32_C(9);         /** @brief ADC oversampling discontinuous mode (triggered mode) for ADC group regular */
    static const int32_t ADCX_CALFACT2_ROVSM_POS = INT32_C(10);        /** @brief Regular oversampling mode */
    static const int32_t ADCX_CALFACT2_OSR_POS = INT32_C(16);          /** @brief Oversampling ratio */
    static const int32_t ADCX_CALFACT2_LSHIFT_POS = INT32_C(28);       /** @brief Left shift factor */
    static const int32_t ADCX_CALFACT2_LTR1_POS = INT32_C(0);          /** @brief ADC analog watchdog 1 threshold low */
    static const int32_t ADCX_CALFACT2_LHTR1_POS = INT32_C(0);         /** @brief ADC analog watchdog 2 threshold low */
    static const int32_t ADCX_CALFACT2_L3_POS = INT32_C(0);            /** @brief L3 */
    static const int32_t ADCX_CALFACT2_SQ16_POS = INT32_C(6);          /** @brief ADC group regular sequencer rank 16 */
    static const int32_t ADCX_CALFACT2_SQ15_POS = INT32_C(0);          /** @brief ADC group regular sequencer rank 15 */
    static const int32_t ADCX_CALFACT2_RDATA_POS = INT32_C(0);         /** @brief ADC group regular conversion data */
    static const int32_t ADCX_CALFACT2_JEXTEN_POS = INT32_C(7);        /** @brief ADC group injected external trigger polarity */
    static const int32_t ADCX_CALFACT2_JEXTSEL_POS = INT32_C(2);       /** @brief ADC group injected external trigger source */
    static const int32_t ADCX_CALFACT2_JL_POS = INT32_C(0);            /** @brief ADC group injected sequencer scan length */
    static const int32_t ADCX_CALFACT2_SSATE_POS = INT32_C(31);        /** @brief ADC offset number 1 enable */
    static const int32_t ADCX_CALFACT2_OFFSET1_CH_POS = INT32_C(26);   /** @brief ADC offset number 1 channel selection */
    static const int32_t ADCX_CALFACT2_OFFSET1_POS = INT32_C(0);       /** @brief ADC offset number 1 offset level */
    static const int32_t ADCX_CALFACT2_SSATE_POS = INT32_C(31);        /** @brief ADC offset number 1 enable */
    static const int32_t ADCX_CALFACT2_OFFSET1_CH_POS = INT32_C(26);   /** @brief ADC offset number 1 channel selection */
    static const int32_t ADCX_CALFACT2_OFFSET1_POS = INT32_C(0);       /** @brief ADC offset number 1 offset level */
    static const int32_t ADCX_CALFACT2_SSATE_POS = INT32_C(31);        /** @brief ADC offset number 1 enable */
    static const int32_t ADCX_CALFACT2_OFFSET1_CH_POS = INT32_C(26);   /** @brief ADC offset number 1 channel selection */
    static const int32_t ADCX_CALFACT2_OFFSET1_POS = INT32_C(0);       /** @brief ADC offset number 1 offset level */
    static const int32_t ADCX_CALFACT2_SSATE_POS = INT32_C(31);        /** @brief ADC offset number 1 enable */
    static const int32_t ADCX_CALFACT2_OFFSET1_CH_POS = INT32_C(26);   /** @brief ADC offset number 1 channel selection */
    static const int32_t ADCX_CALFACT2_OFFSET1_POS = INT32_C(0);       /** @brief ADC offset number 1 offset level */
    static const int32_t ADCX_CALFACT2_AWD2CH_POS = INT32_C(0);        /** @brief ADC analog watchdog 2 monitored channel selection */
    static const int32_t ADCX_CALFACT2_AWD3CH_POS = INT32_C(1);        /** @brief ADC analog watchdog 3 monitored channel selection */
    static const int32_t ADCX_CALFACT2_DIFSEL_POS = INT32_C(0);        /** @brief ADC channel differential or single-ended mode for channel */
    static const int32_t ADCX_CALFACT2_CALFACT_D_POS = INT32_C(16);    /** @brief ADC calibration factor in differential mode */
    static const int32_t ADCX_CALFACT2_CALFACT_S_POS = INT32_C(0);     /** @brief ADC calibration factor in single-ended mode */
    static const int32_t ADCX_CALFACT2_PCSEL_POS = INT32_C(0);         /** @brief Channel x (vinp[i]) pre selection */
    static const int32_t ADCX_CALFACT2_LTR2_POS = INT32_C(0);          /** @brief Analog watchdog 2 lower threshold */
    static const int32_t ADCX_CALFACT2_HTR2_POS = INT32_C(0);          /** @brief Analog watchdog 2 higher threshold */
    static const int32_t ADCX_CALFACT2_LTR3_POS = INT32_C(0);          /** @brief Analog watchdog 3 lower threshold */
    static const int32_t ADCX_CALFACT2_HTR3_POS = INT32_C(0);          /** @brief Analog watchdog 3 higher threshold */
    static const int32_t ADCX_CALFACT2_LINCALFACT_POS = INT32_C(0);    /** @brief Linearity calibration factor */

    /**********************************************************************************************
     * @section ADCX_COMMON Definitions
     **********************************************************************************************/

    /** @subsection ADCX_COMMON register array definitions */

    static _RO uint32_t* const ADCX_COMMON_CSR_REG[13] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x58026300),   /** @brief ADC common status register */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40022300),   /** @brief ADC common status register */
    };

    static _RW uint32_t* const ADCX_COMMON_CCR_REG[13] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58026308),   /** @brief ADC common control register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40022308),   /** @brief ADC common control register */
    };

    static _RO uint32_t* const ADCX_COMMON_CDR_REG[13] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x5802630C),   /** @brief ADC common regular data register for dual and triple modes */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4002230C),   /** @brief ADC common regular data register for dual and triple modes */
    };

    static _RO uint32_t* const ADCX_COMMON_CDR2_REG[13] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x58026310),   /** @brief ADC x common regular data register for 32-bit dual mode */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40022310),   /** @brief ADC x common regular data register for 32-bit dual mode */
    };

    /** @subsection ADCX_COMMON field mask array definitions */

    static const uint32_t ADCX_COMMON_CSR_AWDX_MST_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000080),   /** @brief Analog watchdog 1 flag of the master ADC */
      UINT32_C(0x00000100),   /** @brief Analog watchdog 2 flag of the master ADC */
      UINT32_C(0x00000200),   /** @brief Analog watchdog 3 flag of the master ADC */
    };

    static const uint32_t ADCX_COMMON_CSR_AWDX_SLV_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00800000),   /** @brief Analog watchdog 1 flag of the slave ADC */
      UINT32_C(0x01000000),   /** @brief Analog watchdog 2 flag of the slave ADC */
      UINT32_C(0x02000000),   /** @brief Analog watchdog 3 flag of the slave ADC */
    };

    /** @subsection ADCX_COMMON field mask definitions */

    static const uint32_t ADCX_COMMON_CSR_ADRDY_MST_MASK = UINT32_C(0x00000001);   /** @brief Master ADC ready */
    static const uint32_t ADCX_COMMON_CSR_EOSMP_MST_MASK = UINT32_C(0x00000002);   /** @brief End of sampling phase flag of the master ADC */
    static const uint32_t ADCX_COMMON_CSR_EOC_MST_MASK = UINT32_C(0x00000004);     /** @brief End of regular conversion of the master ADC */
    static const uint32_t ADCX_COMMON_CSR_EOS_MST_MASK = UINT32_C(0x00000008);     /** @brief End of regular sequence flag of the master ADC */
    static const uint32_t ADCX_COMMON_CSR_OVR_MST_MASK = UINT32_C(0x00000010);     /** @brief Overrun flag of the master ADC */
    static const uint32_t ADCX_COMMON_CSR_JEOC_MST_MASK = UINT32_C(0x00000020);    /** @brief End of injected conversion flag of the master ADC */
    static const uint32_t ADCX_COMMON_CSR_JEOS_MST_MASK = UINT32_C(0x00000040);    /** @brief End of injected sequence flag of the master ADC */
    static const uint32_t ADCX_COMMON_CSR_JQOVF_MST_MASK = UINT32_C(0x00000400);   /** @brief Injected context queue overflow flag of the master ADC */
    static const uint32_t ADCX_COMMON_CSR_ADRDY_SLV_MASK = UINT32_C(0x00010000);   /** @brief Slave ADC ready */
    static const uint32_t ADCX_COMMON_CSR_EOSMP_SLV_MASK = UINT32_C(0x00020000);   /** @brief End of sampling phase flag of the slave ADC */
    static const uint32_t ADCX_COMMON_CSR_EOC_SLV_MASK = UINT32_C(0x00040000);     /** @brief End of regular conversion of the slave ADC */
    static const uint32_t ADCX_COMMON_CSR_EOS_SLV_MASK = UINT32_C(0x00080000);     /** @brief End of regular sequence flag of the slave ADC */
    static const uint32_t ADCX_COMMON_CSR_OVR_SLV_MASK = UINT32_C(0x00100000);     /** @brief Overrun flag of the slave ADC */
    static const uint32_t ADCX_COMMON_CSR_JEOC_SLV_MASK = UINT32_C(0x00200000);    /** @brief End of injected conversion flag of the slave ADC */
    static const uint32_t ADCX_COMMON_CSR_JEOS_SLV_MASK = UINT32_C(0x00400000);    /** @brief End of injected sequence flag of the slave ADC */
    static const uint32_t ADCX_COMMON_CSR_JQOVF_SLV_MASK = UINT32_C(0x04000000);   /** @brief Injected context queue overflow flag of the slave ADC */
    static const uint32_t ADCX_COMMON_CCR_DUAL_MASK = UINT32_C(0x0000001F);        /** @brief Dual ADC mode selection */
    static const uint32_t ADCX_COMMON_CCR_DELAY_MASK = UINT32_C(0x00000F00);       /** @brief Delay between 2 sampling phases */
    static const uint32_t ADCX_COMMON_CCR_DAMDF_MASK = UINT32_C(0x0000C000);       /** @brief Dual ADC mode data format */
    static const uint32_t ADCX_COMMON_CCR_CKMODE_MASK = UINT32_C(0x00030000);      /** @brief ADC clock mode */
    static const uint32_t ADCX_COMMON_CCR_PRESC_MASK = UINT32_C(0x003C0000);       /** @brief ADC prescaler */
    static const uint32_t ADCX_COMMON_CCR_VREFEN_MASK = UINT32_C(0x00400000);      /** @brief VREFINT enable */
    static const uint32_t ADCX_COMMON_CCR_TSEN_MASK = UINT32_C(0x00800000);        /** @brief Temperature sensor enable */
    static const uint32_t ADCX_COMMON_CCR_VBATEN_MASK = UINT32_C(0x01000000);      /** @brief VBAT enable */
    static const uint32_t ADCX_COMMON_CDR_RDATA_SLV_MASK = UINT32_C(0xFFFF0000);   /** @brief Regular data of the slave ADC */
    static const uint32_t ADCX_COMMON_CDR_RDATA_MST_MASK = UINT32_C(0x0000FFFF);   /** @brief Regular data of the master ADC */

    /** @subsection ADCX_COMMON field position array definitions */

    static const int32_t ADCX_COMMON_CDR2_AWDX_MST_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(7),    /** @brief Analog watchdog 1 flag of the master ADC */
      INT32_C(8),    /** @brief Analog watchdog 2 flag of the master ADC */
      INT32_C(9),    /** @brief Analog watchdog 3 flag of the master ADC */
    };

    static const int32_t ADCX_COMMON_CDR2_AWDX_SLV_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(23),   /** @brief Analog watchdog 1 flag of the slave ADC */
      INT32_C(24),   /** @brief Analog watchdog 2 flag of the slave ADC */
      INT32_C(25),   /** @brief Analog watchdog 3 flag of the slave ADC */
    };

    /** @subsection ADCX_COMMON field position definitions */

    static const int32_t ADCX_COMMON_CDR2_ADRDY_MST_POS = INT32_C(0);    /** @brief Master ADC ready */
    static const int32_t ADCX_COMMON_CDR2_EOSMP_MST_POS = INT32_C(1);    /** @brief End of sampling phase flag of the master ADC */
    static const int32_t ADCX_COMMON_CDR2_EOC_MST_POS = INT32_C(2);      /** @brief End of regular conversion of the master ADC */
    static const int32_t ADCX_COMMON_CDR2_EOS_MST_POS = INT32_C(3);      /** @brief End of regular sequence flag of the master ADC */
    static const int32_t ADCX_COMMON_CDR2_OVR_MST_POS = INT32_C(4);      /** @brief Overrun flag of the master ADC */
    static const int32_t ADCX_COMMON_CDR2_JEOC_MST_POS = INT32_C(5);     /** @brief End of injected conversion flag of the master ADC */
    static const int32_t ADCX_COMMON_CDR2_JEOS_MST_POS = INT32_C(6);     /** @brief End of injected sequence flag of the master ADC */
    static const int32_t ADCX_COMMON_CDR2_JQOVF_MST_POS = INT32_C(10);   /** @brief Injected context queue overflow flag of the master ADC */
    static const int32_t ADCX_COMMON_CDR2_ADRDY_SLV_POS = INT32_C(16);   /** @brief Slave ADC ready */
    static const int32_t ADCX_COMMON_CDR2_EOSMP_SLV_POS = INT32_C(17);   /** @brief End of sampling phase flag of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_EOC_SLV_POS = INT32_C(18);     /** @brief End of regular conversion of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_EOS_SLV_POS = INT32_C(19);     /** @brief End of regular sequence flag of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_OVR_SLV_POS = INT32_C(20);     /** @brief Overrun flag of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_JEOC_SLV_POS = INT32_C(21);    /** @brief End of injected conversion flag of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_JEOS_SLV_POS = INT32_C(22);    /** @brief End of injected sequence flag of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_JQOVF_SLV_POS = INT32_C(26);   /** @brief Injected context queue overflow flag of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_DUAL_POS = INT32_C(0);         /** @brief Dual ADC mode selection */
    static const int32_t ADCX_COMMON_CDR2_DELAY_POS = INT32_C(8);        /** @brief Delay between 2 sampling phases */
    static const int32_t ADCX_COMMON_CDR2_DAMDF_POS = INT32_C(14);       /** @brief Dual ADC mode data format */
    static const int32_t ADCX_COMMON_CDR2_CKMODE_POS = INT32_C(16);      /** @brief ADC clock mode */
    static const int32_t ADCX_COMMON_CDR2_PRESC_POS = INT32_C(18);       /** @brief ADC prescaler */
    static const int32_t ADCX_COMMON_CDR2_VREFEN_POS = INT32_C(22);      /** @brief VREFINT enable */
    static const int32_t ADCX_COMMON_CDR2_TSEN_POS = INT32_C(23);        /** @brief Temperature sensor enable */
    static const int32_t ADCX_COMMON_CDR2_VBATEN_POS = INT32_C(24);      /** @brief VBAT enable */
    static const int32_t ADCX_COMMON_CDR2_RDATA_SLV_POS = INT32_C(16);   /** @brief Regular data of the slave ADC */
    static const int32_t ADCX_COMMON_CDR2_RDATA_MST_POS = INT32_C(0);    /** @brief Regular data of the master ADC */

    /**********************************************************************************************
     * @section DMAMUX1 Definitions
     **********************************************************************************************/

    /** @subsection DMAMUX1 IRQ interrupt definitions */

    static const int32_t DMAMUX1_OV_IRQ = INT32_C(102);   /** @brief DMAMUX1 overrun interrupt */

    /** @subsection DMAMUX1 register array definitions */

    static _RW uint32_t* const DMAMUX1_CXCR_REG[16] = {
      (_RW uint32_t* const)UINT32_C(0x40020800),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020804),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020808),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x4002080C),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020810),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020814),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020818),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x4002081C),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020820),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020824),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020828),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x4002082C),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020830),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020834),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020838),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      (_RW uint32_t* const)UINT32_C(0x4002083C),   /** @brief DMAMux - DMA request line multiplexer channel x control register */
    };

    static _RW uint32_t* const DMAMUX1_RGXCR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x40020900),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020904),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020908),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x4002090C),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020910),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020914),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x40020918),   /** @brief DMAMux - DMA request generator channel x control register */
      (_RW uint32_t* const)UINT32_C(0x4002091C),   /** @brief DMAMux - DMA request generator channel x control register */
    };

    /** @subsection DMAMUX1 register definitions */

    static _RO uint32_t* const DMAMUX1_RGSR_REG = (_RO uint32_t* const)UINT32_C(0x40020940);    /** @brief DMAMux - DMA request generator status register */
    static _RW uint32_t* const DMAMUX1_RGCFR_REG = (_RW uint32_t* const)UINT32_C(0x40020944);   /** @brief DMAMux - DMA request generator clear flag register */
    static _RO uint32_t* const DMAMUX1_CSR_REG = (_RO uint32_t* const)UINT32_C(0x40020880);     /** @brief DMAMUX request line multiplexer interrupt channel status register */
    static _RW uint32_t* const DMAMUX1_CFR_REG = (_RW uint32_t* const)UINT32_C(0x40020884);     /** @brief DMAMUX request line multiplexer interrupt clear flag register */

    /** @subsection DMAMUX1 field mask definitions */

    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_CXCR_DMAREQ_ID_MASK = UINT32_C(0x000000FF);   /** @brief Input DMA request line selected */
    static const uint32_t DMAMUX1_CXCR_SOIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at synchronization event overrun */
    static const uint32_t DMAMUX1_CXCR_EGE_MASK = UINT32_C(0x00000200);         /** @brief Event generation enable/disable */
    static const uint32_t DMAMUX1_CXCR_SE_MASK = UINT32_C(0x00010000);          /** @brief Synchronous operating mode enable/disable */
    static const uint32_t DMAMUX1_CXCR_SPOL_MASK = UINT32_C(0x00060000);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const uint32_t DMAMUX1_CXCR_NBREQ_MASK = UINT32_C(0x00F80000);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const uint32_t DMAMUX1_CXCR_SYNC_ID_MASK = UINT32_C(0x1F000000);     /** @brief Synchronization input selected */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGXCR_SIG_ID_MASK = UINT32_C(0x0000001F);     /** @brief DMA request trigger input selected */
    static const uint32_t DMAMUX1_RGXCR_OIE_MASK = UINT32_C(0x00000100);        /** @brief Interrupt enable at trigger event overrun */
    static const uint32_t DMAMUX1_RGXCR_GE_MASK = UINT32_C(0x00010000);         /** @brief DMA request generator channel enable/disable */
    static const uint32_t DMAMUX1_RGXCR_GPOL_MASK = UINT32_C(0x00060000);       /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const uint32_t DMAMUX1_RGXCR_GNBREQ_MASK = UINT32_C(0x00F80000);     /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const uint32_t DMAMUX1_RGSR_OF_MASK = UINT32_C(0x000000FF);          /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const uint32_t DMAMUX1_RGCFR_COF_MASK = UINT32_C(0x000000FF);        /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const uint32_t DMAMUX1_CSR_SOF_MASK = UINT32_C(0x0000FFFF);          /** @brief Synchronization overrun event flag */
    static const uint32_t DMAMUX1_CFR_CSOF_MASK = UINT32_C(0x0000FFFF);         /** @brief Clear synchronization overrun event flag */

    /** @subsection DMAMUX1 field position definitions */

    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_DMAREQ_ID_POS = INT32_C(0);    /** @brief Input DMA request line selected */
    static const int32_t DMAMUX1_CFR_SOIE_POS = INT32_C(8);         /** @brief Interrupt enable at synchronization event overrun */
    static const int32_t DMAMUX1_CFR_EGE_POS = INT32_C(9);          /** @brief Event generation enable/disable */
    static const int32_t DMAMUX1_CFR_SE_POS = INT32_C(16);          /** @brief Synchronous operating mode enable/disable */
    static const int32_t DMAMUX1_CFR_SPOL_POS = INT32_C(17);        /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
    static const int32_t DMAMUX1_CFR_NBREQ_POS = INT32_C(19);       /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
    static const int32_t DMAMUX1_CFR_SYNC_ID_POS = INT32_C(24);     /** @brief Synchronization input selected */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_SIG_ID_POS = INT32_C(0);       /** @brief DMA request trigger input selected */
    static const int32_t DMAMUX1_CFR_OIE_POS = INT32_C(8);          /** @brief Interrupt enable at trigger event overrun */
    static const int32_t DMAMUX1_CFR_GE_POS = INT32_C(16);          /** @brief DMA request generator channel enable/disable */
    static const int32_t DMAMUX1_CFR_GPOL_POS = INT32_C(17);        /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
    static const int32_t DMAMUX1_CFR_GNBREQ_POS = INT32_C(19);      /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
    static const int32_t DMAMUX1_CFR_OF_POS = INT32_C(0);           /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    static const int32_t DMAMUX1_CFR_COF_POS = INT32_C(0);          /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    static const int32_t DMAMUX1_CFR_SOF_POS = INT32_C(0);          /** @brief Synchronization overrun event flag */
    static const int32_t DMAMUX1_CFR_CSOF_POS = INT32_C(0);         /** @brief Clear synchronization overrun event flag */

    /**********************************************************************************************
     * @section CRC Definitions
     **********************************************************************************************/

    /** @subsection CRC register definitions */

    static _RW uint32_t* const CRC_DR_REG = (_RW uint32_t* const)UINT32_C(0x58024C00);     /** @brief Data register */
    static _RW uint32_t* const CRC_IDR_REG = (_RW uint32_t* const)UINT32_C(0x58024C04);    /** @brief Independent data register */
    static _RW uint32_t* const CRC_CR_REG = (_RW uint32_t* const)UINT32_C(0x58024C08);     /** @brief Control register */
    static _RW uint32_t* const CRC_INIT_REG = (_RW uint32_t* const)UINT32_C(0x58024C0C);   /** @brief Initial CRC value */
    static _RW uint32_t* const CRC_POL_REG = (_RW uint32_t* const)UINT32_C(0x58024C10);    /** @brief CRC polynomial */

    /** @subsection CRC field mask definitions */

    static const uint32_t CRC_CR_RESET_MASK = UINT32_C(0x00000001);      /** @brief RESET bit */
    static const uint32_t CRC_CR_POLYSIZE_MASK = UINT32_C(0x00000018);   /** @brief Polynomial size */
    static const uint32_t CRC_CR_REV_IN_MASK = UINT32_C(0x00000060);     /** @brief Reverse input data */
    static const uint32_t CRC_CR_REV_OUT_MASK = UINT32_C(0x00000080);    /** @brief Reverse output data */

    /** @subsection CRC field position definitions */

    static const int32_t CRC_POL_RESET_POS = INT32_C(0);      /** @brief RESET bit */
    static const int32_t CRC_POL_POLYSIZE_POS = INT32_C(3);   /** @brief Polynomial size */
    static const int32_t CRC_POL_REV_IN_POS = INT32_C(5);     /** @brief Reverse input data */
    static const int32_t CRC_POL_REV_OUT_POS = INT32_C(7);    /** @brief Reverse output data */

    /**********************************************************************************************
     * @section RCC Definitions
     **********************************************************************************************/

    /** @subsection RCC IRQ interrupt definitions */

    static const int32_t RCC_IRQ = INT32_C(5);   /** @brief RCC global interrupt */

    /** @subsection RCC register array definitions */

    static _RW uint32_t* const RCC_PLLXDIVR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58024430),   /** @brief RCC PLL1 dividers configuration register */
      (_RW uint32_t* const)UINT32_C(0x58024438),   /** @brief RCC PLL2 dividers configuration register */
      (_RW uint32_t* const)UINT32_C(0x58024440),   /** @brief RCC PLL3 dividers configuration register */
    };

    static _RW uint32_t* const RCC_PLLXFRACR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58024434),   /** @brief RCC PLL1 fractional divider register */
      (_RW uint32_t* const)UINT32_C(0x5802443C),   /** @brief RCC PLL2 fractional divider register */
      (_RW uint32_t* const)UINT32_C(0x58024444),   /** @brief RCC PLL3 fractional divider register */
    };

    /** @subsection RCC register definitions */

    static _RW uint32_t* const RCC_CR_REG = (_RW uint32_t* const)UINT32_C(0x58024400);              /** @brief Clock control register */
    static _RW uint32_t* const RCC_ICSCR_REG = (_RW uint32_t* const)UINT32_C(0x58024404);           /** @brief RCC internal clock source calibration register */
    static _RO uint32_t* const RCC_CRRCR_REG = (_RO uint32_t* const)UINT32_C(0x58024408);           /** @brief RCC clock recovery RC register */
    static _RW uint32_t* const RCC_CFGR_REG = (_RW uint32_t* const)UINT32_C(0x58024410);            /** @brief RCC clock configuration register */
    static _RW uint32_t* const RCC_D1CFGR_REG = (_RW uint32_t* const)UINT32_C(0x58024418);          /** @brief RCC domain 1 clock configuration register */
    static _RW uint32_t* const RCC_D2CFGR_REG = (_RW uint32_t* const)UINT32_C(0x5802441C);          /** @brief RCC domain 2 clock configuration register */
    static _RW uint32_t* const RCC_D3CFGR_REG = (_RW uint32_t* const)UINT32_C(0x58024420);          /** @brief RCC domain 3 clock configuration register */
    static _RW uint32_t* const RCC_PLLCKSELR_REG = (_RW uint32_t* const)UINT32_C(0x58024428);       /** @brief RCC plls clock source selection register */
    static _RW uint32_t* const RCC_PLLCFGR_REG = (_RW uint32_t* const)UINT32_C(0x5802442C);         /** @brief RCC plls configuration register */
    static _RW uint32_t* const RCC_D1CCIPR_REG = (_RW uint32_t* const)UINT32_C(0x5802444C);         /** @brief RCC domain 1 kernel clock configuration register */
    static _RW uint32_t* const RCC_D2CCIP1R_REG = (_RW uint32_t* const)UINT32_C(0x58024450);        /** @brief RCC domain 2 kernel clock configuration register */
    static _RW uint32_t* const RCC_D2CCIP2R_REG = (_RW uint32_t* const)UINT32_C(0x58024454);        /** @brief RCC domain 2 kernel clock configuration register */
    static _RW uint32_t* const RCC_D3CCIPR_REG = (_RW uint32_t* const)UINT32_C(0x58024458);         /** @brief RCC domain 3 kernel clock configuration register */
    static _RW uint32_t* const RCC_CIER_REG = (_RW uint32_t* const)UINT32_C(0x58024460);            /** @brief RCC clock source interrupt enable register */
    static _RW uint32_t* const RCC_CIFR_REG = (_RW uint32_t* const)UINT32_C(0x58024464);            /** @brief RCC clock source interrupt flag register */
    static _RW uint32_t* const RCC_CICR_REG = (_RW uint32_t* const)UINT32_C(0x58024468);            /** @brief RCC clock source interrupt clear register */
    static _RW uint32_t* const RCC_BDCR_REG = (_RW uint32_t* const)UINT32_C(0x58024470);            /** @brief RCC backup domain control register */
    static _RW uint32_t* const RCC_CSR_REG = (_RW uint32_t* const)UINT32_C(0x58024474);             /** @brief RCC clock control and status register */
    static _RW uint32_t* const RCC_AHB3RSTR_REG = (_RW uint32_t* const)UINT32_C(0x5802447C);        /** @brief RCC AHB3 reset register */
    static _RW uint32_t* const RCC_AHB1RSTR_REG = (_RW uint32_t* const)UINT32_C(0x58024480);        /** @brief RCC AHB1 peripheral reset register */
    static _RW uint32_t* const RCC_AHB2RSTR_REG = (_RW uint32_t* const)UINT32_C(0x58024484);        /** @brief RCC AHB2 peripheral reset register */
    static _RW uint32_t* const RCC_AHB4RSTR_REG = (_RW uint32_t* const)UINT32_C(0x58024488);        /** @brief RCC AHB4 peripheral reset register */
    static _RW uint32_t* const RCC_APB3RSTR_REG = (_RW uint32_t* const)UINT32_C(0x5802448C);        /** @brief RCC APB3 peripheral reset register */
    static _RW uint32_t* const RCC_APB1LRSTR_REG = (_RW uint32_t* const)UINT32_C(0x58024490);       /** @brief RCC APB1 peripheral reset register */
    static _RW uint32_t* const RCC_APB1HRSTR_REG = (_RW uint32_t* const)UINT32_C(0x58024494);       /** @brief RCC APB1 peripheral reset register */
    static _RW uint32_t* const RCC_APB2RSTR_REG = (_RW uint32_t* const)UINT32_C(0x58024498);        /** @brief RCC APB2 peripheral reset register */
    static _RW uint32_t* const RCC_APB4RSTR_REG = (_RW uint32_t* const)UINT32_C(0x5802449C);        /** @brief RCC APB4 peripheral reset register */
    static _RW uint32_t* const RCC_GCR_REG = (_RW uint32_t* const)UINT32_C(0x580244A0);             /** @brief RCC global control register */
    static _RW uint32_t* const RCC_D3AMR_REG = (_RW uint32_t* const)UINT32_C(0x580244A8);           /** @brief RCC D3 autonomous mode register */
    static _RW uint32_t* const RCC_RSR_REG = (_RW uint32_t* const)UINT32_C(0x580244D0);             /** @brief RCC reset status register */
    static _RW uint32_t* const RCC_C1_RSR_REG = (_RW uint32_t* const)UINT32_C(0x58024530);          /** @brief RCC reset status register */
    static _RW uint32_t* const RCC_C1_AHB3ENR_REG = (_RW uint32_t* const)UINT32_C(0x58024534);      /** @brief RCC AHB3 clock register */
    static _RW uint32_t* const RCC_AHB3ENR_REG = (_RW uint32_t* const)UINT32_C(0x580244D4);         /** @brief RCC AHB3 clock register */
    static _RW uint32_t* const RCC_AHB1ENR_REG = (_RW uint32_t* const)UINT32_C(0x580244D8);         /** @brief RCC AHB1 clock register */
    static _RW uint32_t* const RCC_C1_AHB1ENR_REG = (_RW uint32_t* const)UINT32_C(0x58024538);      /** @brief RCC AHB1 clock register */
    static _RW uint32_t* const RCC_C1_AHB2ENR_REG = (_RW uint32_t* const)UINT32_C(0x5802453C);      /** @brief RCC AHB2 clock register */
    static _RW uint32_t* const RCC_AHB2ENR_REG = (_RW uint32_t* const)UINT32_C(0x580244DC);         /** @brief RCC AHB2 clock register */
    static _RW uint32_t* const RCC_AHB4ENR_REG = (_RW uint32_t* const)UINT32_C(0x580244E0);         /** @brief RCC AHB4 clock register */
    static _RW uint32_t* const RCC_C1_AHB4ENR_REG = (_RW uint32_t* const)UINT32_C(0x58024540);      /** @brief RCC AHB4 clock register */
    static _RW uint32_t* const RCC_C1_APB3ENR_REG = (_RW uint32_t* const)UINT32_C(0x58024544);      /** @brief RCC APB3 clock register */
    static _RW uint32_t* const RCC_APB3ENR_REG = (_RW uint32_t* const)UINT32_C(0x580244E4);         /** @brief RCC APB3 clock register */
    static _RW uint32_t* const RCC_APB1LENR_REG = (_RW uint32_t* const)UINT32_C(0x580244E8);        /** @brief RCC APB1 clock register */
    static _RW uint32_t* const RCC_C1_APB1LENR_REG = (_RW uint32_t* const)UINT32_C(0x58024548);     /** @brief RCC APB1 clock register */
    static _RW uint32_t* const RCC_APB1HENR_REG = (_RW uint32_t* const)UINT32_C(0x580244EC);        /** @brief RCC APB1 clock register */
    static _RW uint32_t* const RCC_C1_APB1HENR_REG = (_RW uint32_t* const)UINT32_C(0x5802454C);     /** @brief RCC APB1 clock register */
    static _RW uint32_t* const RCC_C1_APB2ENR_REG = (_RW uint32_t* const)UINT32_C(0x58024550);      /** @brief RCC APB2 clock register */
    static _RW uint32_t* const RCC_APB2ENR_REG = (_RW uint32_t* const)UINT32_C(0x580244F0);         /** @brief RCC APB2 clock register */
    static _RW uint32_t* const RCC_APB4ENR_REG = (_RW uint32_t* const)UINT32_C(0x580244F4);         /** @brief RCC APB4 clock register */
    static _RW uint32_t* const RCC_C1_APB4ENR_REG = (_RW uint32_t* const)UINT32_C(0x58024554);      /** @brief RCC APB4 clock register */
    static _RW uint32_t* const RCC_C1_AHB3LPENR_REG = (_RW uint32_t* const)UINT32_C(0x5802455C);    /** @brief RCC AHB3 sleep clock register */
    static _RW uint32_t* const RCC_AHB3LPENR_REG = (_RW uint32_t* const)UINT32_C(0x580244FC);       /** @brief RCC AHB3 sleep clock register */
    static _RW uint32_t* const RCC_AHB1LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024500);       /** @brief RCC AHB1 sleep clock register */
    static _RW uint32_t* const RCC_C1_AHB1LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024560);    /** @brief RCC AHB1 sleep clock register */
    static _RW uint32_t* const RCC_C1_AHB2LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024564);    /** @brief RCC AHB2 sleep clock register */
    static _RW uint32_t* const RCC_AHB2LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024504);       /** @brief RCC AHB2 sleep clock register */
    static _RW uint32_t* const RCC_AHB4LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024508);       /** @brief RCC AHB4 sleep clock register */
    static _RW uint32_t* const RCC_C1_AHB4LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024568);    /** @brief RCC AHB4 sleep clock register */
    static _RW uint32_t* const RCC_C1_APB3LPENR_REG = (_RW uint32_t* const)UINT32_C(0x5802456C);    /** @brief RCC APB3 sleep clock register */
    static _RW uint32_t* const RCC_APB3LPENR_REG = (_RW uint32_t* const)UINT32_C(0x5802450C);       /** @brief RCC APB3 sleep clock register */
    static _RW uint32_t* const RCC_APB1LLPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024510);      /** @brief RCC APB1 low sleep clock register */
    static _RW uint32_t* const RCC_C1_APB1LLPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024570);   /** @brief RCC APB1 low sleep clock register */
    static _RW uint32_t* const RCC_C1_APB1HLPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024574);   /** @brief RCC APB1 high sleep clock register */
    static _RW uint32_t* const RCC_APB1HLPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024514);      /** @brief RCC APB1 high sleep clock register */
    static _RW uint32_t* const RCC_APB2LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024518);       /** @brief RCC APB2 sleep clock register */
    static _RW uint32_t* const RCC_C1_APB2LPENR_REG = (_RW uint32_t* const)UINT32_C(0x58024578);    /** @brief RCC APB2 sleep clock register */
    static _RW uint32_t* const RCC_C1_APB4LPENR_REG = (_RW uint32_t* const)UINT32_C(0x5802457C);    /** @brief RCC APB4 sleep clock register */
    static _RW uint32_t* const RCC_APB4LPENR_REG = (_RW uint32_t* const)UINT32_C(0x5802451C);       /** @brief RCC APB4 sleep clock register */

    /** @subsection RCC field mask array definitions */

    static const uint32_t RCC_CR_PLLXON_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x01000000),   /** @brief PLL1 enable */
      UINT32_C(0x04000000),   /** @brief PLL2 enable */
      UINT32_C(0x10000000),   /** @brief PLL3 enable */
    };

    static const uint32_t RCC_CR_PLLXRDY_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x02000000),   /** @brief PLL1 clock ready flag */
      UINT32_C(0x08000000),   /** @brief PLL2 clock ready flag */
      UINT32_C(0x20000000),   /** @brief PLL3 clock ready flag */
    };

    static const uint32_t RCC_PLLCKSELR_DIVMX_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x000003F0),   /** @brief Prescaler for PLL1 */
      UINT32_C(0x0003F000),   /** @brief Prescaler for PLL2 */
      UINT32_C(0x03F00000),   /** @brief Prescaler for PLL3 */
    };

    static const uint32_t RCC_PLLCFGR_PLLXFRACEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief PLL1 fractional latch enable */
      UINT32_C(0x00000010),   /** @brief PLL2 fractional latch enable */
      UINT32_C(0x00000100),   /** @brief PLL3 fractional latch enable */
    };

    static const uint32_t RCC_PLLCFGR_PLLXVCOSEL_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief PLL1 VCO selection */
      UINT32_C(0x00000020),   /** @brief PLL2 VCO selection */
      UINT32_C(0x00000200),   /** @brief PLL3 VCO selection */
    };

    static const uint32_t RCC_PLLCFGR_PLLXRGE_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000000C),   /** @brief PLL1 input frequency range */
      UINT32_C(0x000000C0),   /** @brief PLL2 input frequency range */
      UINT32_C(0x00000C00),   /** @brief PLL3 input frequency range */
    };

    static const uint32_t RCC_PLLCFGR_DIVPXEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief PLL1 DIVP divider output enable */
      UINT32_C(0x00080000),   /** @brief PLL2 DIVP divider output enable */
      UINT32_C(0x00400000),   /** @brief PLL3 DIVP divider output enable */
    };

    static const uint32_t RCC_PLLCFGR_DIVQXEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00020000),   /** @brief PLL1 DIVQ divider output enable */
      UINT32_C(0x00100000),   /** @brief PLL2 DIVQ divider output enable */
      UINT32_C(0x00800000),   /** @brief PLL3 DIVQ divider output enable */
    };

    static const uint32_t RCC_PLLCFGR_DIVRXEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00040000),   /** @brief PLL1 DIVR divider output enable */
      UINT32_C(0x00200000),   /** @brief PLL2 DIVR divider output enable */
      UINT32_C(0x01000000),   /** @brief PLL3 DIVR divider output enable */
    };

    static const uint32_t RCC_CIER_PLLXRDYIE_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief PLL1 ready interrupt enable */
      UINT32_C(0x00000080),   /** @brief PLL2 ready interrupt enable */
      UINT32_C(0x00000100),   /** @brief PLL3 ready interrupt enable */
    };

    static const uint32_t RCC_CIFR_PLLXRDYF_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief PLL1 ready interrupt flag */
      UINT32_C(0x00000080),   /** @brief PLL2 ready interrupt flag */
      UINT32_C(0x00000100),   /** @brief PLL3 ready interrupt flag */
    };

    static const uint32_t RCC_CICR_PLLXRDYC_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief PLL1 ready interrupt clear */
      UINT32_C(0x00000080),   /** @brief PLL2 ready interrupt clear */
      UINT32_C(0x00000100),   /** @brief PLL3 ready interrupt clear */
    };

    static const uint32_t RCC_APB1LRSTR_TIMXRST_MASK[15] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief TIM block reset */
      UINT32_C(0x00000002),   /** @brief TIM block reset */
      UINT32_C(0x00000004),   /** @brief TIM block reset */
      UINT32_C(0x00000008),   /** @brief TIM block reset */
      UINT32_C(0x00000010),   /** @brief TIM block reset */
      UINT32_C(0x00000020),   /** @brief TIM block reset */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief TIM block reset */
      UINT32_C(0x00000080),   /** @brief TIM block reset */
      UINT32_C(0x00000100),   /** @brief TIM block reset */
    };

    static const uint32_t RCC_APB1LRSTR_USARTXRST_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00020000),   /** @brief USART2 block reset */
      UINT32_C(0x00040000),   /** @brief USART3 block reset */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief USART7 block reset */
      UINT32_C(0x80000000),   /** @brief USART8 block reset */
    };

    static const uint32_t RCC_APB1LRSTR_I2CXRST_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief I2C1 block reset */
      UINT32_C(0x00400000),   /** @brief I2C2 block reset */
      UINT32_C(0x00800000),   /** @brief I2C3 block reset */
    };

    static const uint32_t RCC_APB2RSTR_SPIXRST_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief SPI1 block reset */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00002000),   /** @brief SPI4 block reset */
      UINT32_C(0x00100000),   /** @brief SPI5 block reset */
    };

    static const uint32_t RCC_APB2RSTR_TIM1XRST_MASK[8] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief TIM15 block reset */
      UINT32_C(0x00020000),   /** @brief TIM16 block reset */
      UINT32_C(0x00040000),   /** @brief TIM17 block reset */
    };

    static const uint32_t RCC_APB2RSTR_SAIXRST_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief SAI1 block reset */
      UINT32_C(0x00800000),   /** @brief SAI2 block reset */
      UINT32_C(0x01000000),   /** @brief SAI3 block reset */
    };

    static const uint32_t RCC_APB4RSTR_LPTIMXRST_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief LPTIM2 block reset */
      UINT32_C(0x00000400),   /** @brief LPTIM3 block reset */
      UINT32_C(0x00000800),   /** @brief LPTIM4 block reset */
      UINT32_C(0x00001000),   /** @brief LPTIM5 block reset */
    };

    static const uint32_t RCC_D3AMR_LPTIMXAMEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief LPTIM2 autonomous mode enable */
      UINT32_C(0x00000400),   /** @brief LPTIM3 autonomous mode enable */
      UINT32_C(0x00000800),   /** @brief LPTIM4 autonomous mode enable */
      UINT32_C(0x00001000),   /** @brief LPTIM5 autonomous mode enable */
    };

    static const uint32_t RCC_C1_AHB2ENR_SRAMXEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x20000000),   /** @brief SRAM1 block enable */
      UINT32_C(0x40000000),   /** @brief SRAM2 block enable */
      UINT32_C(0x80000000),   /** @brief SRAM3 block enable */
    };

    static const uint32_t RCC_APB1LENR_TIMXEN_MASK[15] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000002),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000004),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000008),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000010),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000020),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000080),   /** @brief TIM peripheral clock enable */
      UINT32_C(0x00000100),   /** @brief TIM peripheral clock enable */
    };

    static const uint32_t RCC_APB1LENR_USARTXEN_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00020000),   /** @brief USART2 peripheral clocks enable */
      UINT32_C(0x00040000),   /** @brief USART3 peripheral clocks enable */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief USART7 peripheral clocks enable */
      UINT32_C(0x80000000),   /** @brief USART8 peripheral clocks enable */
    };

    static const uint32_t RCC_APB1LENR_I2CXEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief I2C1 peripheral clocks enable */
      UINT32_C(0x00400000),   /** @brief I2C2 peripheral clocks enable */
      UINT32_C(0x00800000),   /** @brief I2C3 peripheral clocks enable */
    };

    static const uint32_t RCC_C1_APB2ENR_SPIXEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief SPI1 peripheral clocks enable */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00002000),   /** @brief SPI4 peripheral clocks enable */
      UINT32_C(0x00100000),   /** @brief SPI5 peripheral clocks enable */
    };

    static const uint32_t RCC_C1_APB2ENR_TIM1XEN_MASK[8] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief TIM15 peripheral clock enable */
      UINT32_C(0x00020000),   /** @brief TIM16 peripheral clock enable */
      UINT32_C(0x00040000),   /** @brief TIM17 peripheral clock enable */
    };

    static const uint32_t RCC_C1_APB2ENR_SAIXEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief SAI1 peripheral clocks enable */
      UINT32_C(0x00800000),   /** @brief SAI2 peripheral clocks enable */
      UINT32_C(0x01000000),   /** @brief SAI3 peripheral clocks enable */
    };

    static const uint32_t RCC_APB4ENR_LPTIMXEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief LPTIM2 peripheral clocks enable */
      UINT32_C(0x00000400),   /** @brief LPTIM3 peripheral clocks enable */
      UINT32_C(0x00000800),   /** @brief LPTIM4 peripheral clocks enable */
      UINT32_C(0x00001000),   /** @brief LPTIM5 peripheral clocks enable */
    };

    static const uint32_t RCC_C1_AHB2LPENR_SRAMXLPEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x20000000),   /** @brief SRAM1 clock enable during csleep mode */
      UINT32_C(0x40000000),   /** @brief SRAM2 clock enable during csleep mode */
      UINT32_C(0x80000000),   /** @brief SRAM3 clock enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_TIMXLPEN_MASK[15] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief TIM2 peripheral clock enable during csleep mode */
      UINT32_C(0x00000002),   /** @brief TIM3 peripheral clock enable during csleep mode */
      UINT32_C(0x00000004),   /** @brief TIM4 peripheral clock enable during csleep mode */
      UINT32_C(0x00000008),   /** @brief TIM5 peripheral clock enable during csleep mode */
      UINT32_C(0x00000010),   /** @brief TIM6 peripheral clock enable during csleep mode */
      UINT32_C(0x00000020),   /** @brief TIM7 peripheral clock enable during csleep mode */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief TIM12 peripheral clock enable during csleep mode */
      UINT32_C(0x00000080),   /** @brief TIM13 peripheral clock enable during csleep mode */
      UINT32_C(0x00000100),   /** @brief TIM14 peripheral clock enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_USARTXLPEN_MASK[9] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00020000),   /** @brief USART2 peripheral clocks enable during csleep mode */
      UINT32_C(0x00040000),   /** @brief USART3 peripheral clocks enable during csleep mode */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief USART7 peripheral clocks enable during csleep mode */
      UINT32_C(0x80000000),   /** @brief USART8 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_APB1LLPENR_I2CXLPEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief I2C1 peripheral clocks enable during csleep mode */
      UINT32_C(0x00400000),   /** @brief I2C2 peripheral clocks enable during csleep mode */
      UINT32_C(0x00800000),   /** @brief I2C3 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_APB2LPENR_SPIXLPEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief SPI1 peripheral clocks enable during csleep mode */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00002000),   /** @brief SPI4 peripheral clocks enable during csleep mode */
      UINT32_C(0x00100000),   /** @brief SPI5 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_APB2LPENR_TIM1XLPEN_MASK[8] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief TIM15 peripheral clock enable during csleep mode */
      UINT32_C(0x00020000),   /** @brief TIM16 peripheral clock enable during csleep mode */
      UINT32_C(0x00040000),   /** @brief TIM17 peripheral clock enable during csleep mode */
    };

    static const uint32_t RCC_APB2LPENR_SAIXLPEN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief SAI1 peripheral clocks enable during csleep mode */
      UINT32_C(0x00800000),   /** @brief SAI2 peripheral clocks enable during csleep mode */
      UINT32_C(0x01000000),   /** @brief SAI3 peripheral clocks enable during csleep mode */
    };

    static const uint32_t RCC_C1_APB4LPENR_LPTIMXLPEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief LPTIM2 peripheral clocks enable during csleep mode */
      UINT32_C(0x00000400),   /** @brief LPTIM3 peripheral clocks enable during csleep mode */
      UINT32_C(0x00000800),   /** @brief LPTIM4 peripheral clocks enable during csleep mode */
      UINT32_C(0x00001000),   /** @brief LPTIM5 peripheral clocks enable during csleep mode */
    };

    /** @subsection RCC field mask definitions */

    static const uint32_t RCC_CR_HSION_MASK = UINT32_C(0x00000001);                         /** @brief Internal high-speed clock enable */
    static const uint32_t RCC_CR_HSIKERON_MASK = UINT32_C(0x00000002);                      /** @brief High speed internal clock enable in stop mode */
    static const uint32_t RCC_CR_HSIRDY_MASK = UINT32_C(0x00000004);                        /** @brief HSI clock ready flag */
    static const uint32_t RCC_CR_HSIDIV_MASK = UINT32_C(0x00000018);                        /** @brief HSI clock divider */
    static const uint32_t RCC_CR_HSIDIVF_MASK = UINT32_C(0x00000020);                       /** @brief HSI divider flag */
    static const uint32_t RCC_CR_CSION_MASK = UINT32_C(0x00000080);                         /** @brief CSI clock enable */
    static const uint32_t RCC_CR_CSIRDY_MASK = UINT32_C(0x00000100);                        /** @brief CSI clock ready flag */
    static const uint32_t RCC_CR_CSIKERON_MASK = UINT32_C(0x00000200);                      /** @brief CSI clock enable in stop mode */
    static const uint32_t RCC_CR_RC48ON_MASK = UINT32_C(0x00001000);                        /** @brief RC48 clock enable */
    static const uint32_t RCC_CR_RC48RDY_MASK = UINT32_C(0x00002000);                       /** @brief RC48 clock ready flag */
    static const uint32_t RCC_CR_D1CKRDY_MASK = UINT32_C(0x00004000);                       /** @brief D1 domain clocks ready flag */
    static const uint32_t RCC_CR_D2CKRDY_MASK = UINT32_C(0x00008000);                       /** @brief D2 domain clocks ready flag */
    static const uint32_t RCC_CR_HSEON_MASK = UINT32_C(0x00010000);                         /** @brief HSE clock enable */
    static const uint32_t RCC_CR_HSERDY_MASK = UINT32_C(0x00020000);                        /** @brief HSE clock ready flag */
    static const uint32_t RCC_CR_HSEBYP_MASK = UINT32_C(0x00040000);                        /** @brief HSE clock bypass */
    static const uint32_t RCC_CR_HSECSSON_MASK = UINT32_C(0x00080000);                      /** @brief HSE clock security system enable */
    static const uint32_t RCC_ICSCR_HSICAL_MASK = UINT32_C(0x00000FFF);                     /** @brief HSI clock calibration */
    static const uint32_t RCC_ICSCR_HSITRIM_MASK = UINT32_C(0x0003F000);                    /** @brief HSI clock trimming */
    static const uint32_t RCC_ICSCR_CSICAL_MASK = UINT32_C(0x03FC0000);                     /** @brief CSI clock calibration */
    static const uint32_t RCC_ICSCR_CSITRIM_MASK = UINT32_C(0x7C000000);                    /** @brief CSI clock trimming */
    static const uint32_t RCC_CRRCR_RC48CAL_MASK = UINT32_C(0x000003FF);                    /** @brief Internal RC 48 mhz clock calibration */
    static const uint32_t RCC_CFGR_SW_MASK = UINT32_C(0x00000007);                          /** @brief System clock switch */
    static const uint32_t RCC_CFGR_SWS_MASK = UINT32_C(0x00000038);                         /** @brief System clock switch status */
    static const uint32_t RCC_CFGR_STOPWUCK_MASK = UINT32_C(0x00000040);                    /** @brief System clock selection after a wake up from system stop */
    static const uint32_t RCC_CFGR_STOPKERWUCK_MASK = UINT32_C(0x00000080);                 /** @brief Kernel clock selection after a wake up from system stop */
    static const uint32_t RCC_CFGR_RTCPRE_MASK = UINT32_C(0x00003F00);                      /** @brief HSE division factor for RTC clock */
    static const uint32_t RCC_CFGR_HRTIMSEL_MASK = UINT32_C(0x00004000);                    /** @brief High resolution timer clock prescaler selection */
    static const uint32_t RCC_CFGR_TIMPRE_MASK = UINT32_C(0x00008000);                      /** @brief Timers clocks prescaler selection */
    static const uint32_t RCC_CFGR_MCO1PRE_MASK = UINT32_C(0x003C0000);                     /** @brief MCO1 prescaler */
    static const uint32_t RCC_CFGR_MCO1SEL_MASK = UINT32_C(0x01C00000);                     /** @brief Micro-controller clock output 1 */
    static const uint32_t RCC_CFGR_MCO2PRE_MASK = UINT32_C(0x1E000000);                     /** @brief MCO2 prescaler */
    static const uint32_t RCC_CFGR_MCO2SEL_MASK = UINT32_C(0xE0000000);                     /** @brief Micro-controller clock output 2 */
    static const uint32_t RCC_D1CFGR_HPRE_MASK = UINT32_C(0x0000000F);                      /** @brief D1 domain AHB prescaler */
    static const uint32_t RCC_D1CFGR_D1PPRE_MASK = UINT32_C(0x00000070);                    /** @brief D1 domain APB3 prescaler */
    static const uint32_t RCC_D1CFGR_D1CPRE_MASK = UINT32_C(0x00000F00);                    /** @brief D1 domain core prescaler */
    static const uint32_t RCC_D2CFGR_D2PPRE1_MASK = UINT32_C(0x00000070);                   /** @brief D2 domain APB1 prescaler */
    static const uint32_t RCC_D2CFGR_D2PPRE2_MASK = UINT32_C(0x00000700);                   /** @brief D2 domain APB2 prescaler */
    static const uint32_t RCC_D3CFGR_D3PPRE_MASK = UINT32_C(0x00000070);                    /** @brief D3 domain APB4 prescaler */
    static const uint32_t RCC_PLLCKSELR_PLLSRC_MASK = UINT32_C(0x00000003);                 /** @brief DIVMx and plls clock source selection */
    static const uint32_t RCC_PLLXDIVR_DIVN1_MASK = UINT32_C(0x000001FF);                   /** @brief Multiplication factor for PLL1 VCO */
    static const uint32_t RCC_PLLXDIVR_DIVP1_MASK = UINT32_C(0x0000FE00);                   /** @brief PLL1 DIVP division factor */
    static const uint32_t RCC_PLLXDIVR_DIVQ1_MASK = UINT32_C(0x007F0000);                   /** @brief PLL1 DIVQ division factor */
    static const uint32_t RCC_PLLXDIVR_DIVR1_MASK = UINT32_C(0x7F000000);                   /** @brief PLL1 DIVR division factor */
    static const uint32_t RCC_PLLXFRACR_FRACN1_MASK = UINT32_C(0x0000FFF8);                 /** @brief Fractional part of the multiplication factor for PLL1 VCO */
    static const uint32_t RCC_PLLXDIVR_DIVN1_MASK = UINT32_C(0x000001FF);                   /** @brief Multiplication factor for PLL1 VCO */
    static const uint32_t RCC_PLLXDIVR_DIVP1_MASK = UINT32_C(0x0000FE00);                   /** @brief PLL1 DIVP division factor */
    static const uint32_t RCC_PLLXDIVR_DIVQ1_MASK = UINT32_C(0x007F0000);                   /** @brief PLL1 DIVQ division factor */
    static const uint32_t RCC_PLLXDIVR_DIVR1_MASK = UINT32_C(0x7F000000);                   /** @brief PLL1 DIVR division factor */
    static const uint32_t RCC_PLLXFRACR_FRACN2_MASK = UINT32_C(0x0000FFF8);                 /** @brief Fractional part of the multiplication factor for PLL VCO */
    static const uint32_t RCC_PLLXDIVR_DIVN3_MASK = UINT32_C(0x000001FF);                   /** @brief Multiplication factor for PLL1 VCO */
    static const uint32_t RCC_PLLXDIVR_DIVP3_MASK = UINT32_C(0x0000FE00);                   /** @brief PLL DIVP division factor */
    static const uint32_t RCC_PLLXDIVR_DIVQ3_MASK = UINT32_C(0x007F0000);                   /** @brief PLL DIVQ division factor */
    static const uint32_t RCC_PLLXDIVR_DIVR3_MASK = UINT32_C(0x7F000000);                   /** @brief PLL DIVR division factor */
    static const uint32_t RCC_PLLXFRACR_FRACN3_MASK = UINT32_C(0x0000FFF8);                 /** @brief Fractional part of the multiplication factor for PLL3 VCO */
    static const uint32_t RCC_D1CCIPR_FMCSRC_MASK = UINT32_C(0x00000003);                   /** @brief FMC kernel clock source selection */
    static const uint32_t RCC_D1CCIPR_QSPISRC_MASK = UINT32_C(0x00000030);                  /** @brief QUADSPI kernel clock source selection */
    static const uint32_t RCC_D1CCIPR_SDMMCSRC_MASK = UINT32_C(0x00010000);                 /** @brief SDMMC kernel clock source selection */
    static const uint32_t RCC_D1CCIPR_CKPERSRC_MASK = UINT32_C(0x30000000);                 /** @brief Per_ck clock source selection */
    static const uint32_t RCC_D2CCIP1R_SAI1SRC_MASK = UINT32_C(0x00000007);                 /** @brief SAI1 and DFSDM1 kernel aclk clock source selection */
    static const uint32_t RCC_D2CCIP1R_SAI23SRC_MASK = UINT32_C(0x000001C0);                /** @brief SAI2 and SAI3 kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SPI123SRC_MASK = UINT32_C(0x00007000);               /** @brief SPI/I2S1,2 and 3 kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SPI45SRC_MASK = UINT32_C(0x00070000);                /** @brief SPI4 and 5 kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SPDIFSRC_MASK = UINT32_C(0x00300000);                /** @brief SPDIFRX kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_DFSDM1SRC_MASK = UINT32_C(0x01000000);               /** @brief DFSDM1 kernel clk clock source selection */
    static const uint32_t RCC_D2CCIP1R_FDCANSRC_MASK = UINT32_C(0x30000000);                /** @brief FDCAN kernel clock source selection */
    static const uint32_t RCC_D2CCIP1R_SWPSRC_MASK = UINT32_C(0x80000000);                  /** @brief SWPMI kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_USART234578SRC_MASK = UINT32_C(0x00000007);          /** @brief USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_USART16SRC_MASK = UINT32_C(0x00000038);              /** @brief USART1 and 6 kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_RNGSRC_MASK = UINT32_C(0x00000300);                  /** @brief RNG kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_I2C123SRC_MASK = UINT32_C(0x00003000);               /** @brief I2C1,2,3 kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_USBSRC_MASK = UINT32_C(0x00300000);                  /** @brief USBOTG 1 and 2 kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_CECSRC_MASK = UINT32_C(0x00C00000);                  /** @brief HDMI-CEC kernel clock source selection */
    static const uint32_t RCC_D2CCIP2R_LPTIM1SRC_MASK = UINT32_C(0x70000000);               /** @brief LPTIM1 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_LPUART1SRC_MASK = UINT32_C(0x00000007);               /** @brief LPUART1 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_I2C4SRC_MASK = UINT32_C(0x00000300);                  /** @brief I2C4 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_LPTIM2SRC_MASK = UINT32_C(0x00001C00);                /** @brief LPTIM2 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_LPTIM345SRC_MASK = UINT32_C(0x0000E000);              /** @brief LPTIM3,4,5 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_ADCSRC_MASK = UINT32_C(0x00030000);                   /** @brief SAR ADC kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_SAI4ASRC_MASK = UINT32_C(0x00E00000);                 /** @brief Sub-Block A of SAI4 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_SAI4BSRC_MASK = UINT32_C(0x07000000);                 /** @brief Sub-Block B of SAI4 kernel clock source selection */
    static const uint32_t RCC_D3CCIPR_SPI6SRC_MASK = UINT32_C(0x70000000);                  /** @brief SPI6 kernel clock source selection */
    static const uint32_t RCC_CIER_LSIRDYIE_MASK = UINT32_C(0x00000001);                    /** @brief LSI ready interrupt enable */
    static const uint32_t RCC_CIER_LSERDYIE_MASK = UINT32_C(0x00000002);                    /** @brief LSE ready interrupt enable */
    static const uint32_t RCC_CIER_HSIRDYIE_MASK = UINT32_C(0x00000004);                    /** @brief HSI ready interrupt enable */
    static const uint32_t RCC_CIER_HSERDYIE_MASK = UINT32_C(0x00000008);                    /** @brief HSE ready interrupt enable */
    static const uint32_t RCC_CIER_CSIRDYIE_MASK = UINT32_C(0x00000010);                    /** @brief CSI ready interrupt enable */
    static const uint32_t RCC_CIER_RC48RDYIE_MASK = UINT32_C(0x00000020);                   /** @brief RC48 ready interrupt enable */
    static const uint32_t RCC_CIER_LSECSSIE_MASK = UINT32_C(0x00000200);                    /** @brief LSE clock security system interrupt enable */
    static const uint32_t RCC_CIFR_LSIRDYF_MASK = UINT32_C(0x00000001);                     /** @brief LSI ready interrupt flag */
    static const uint32_t RCC_CIFR_LSERDYF_MASK = UINT32_C(0x00000002);                     /** @brief LSE ready interrupt flag */
    static const uint32_t RCC_CIFR_HSIRDYF_MASK = UINT32_C(0x00000004);                     /** @brief HSI ready interrupt flag */
    static const uint32_t RCC_CIFR_HSERDYF_MASK = UINT32_C(0x00000008);                     /** @brief HSE ready interrupt flag */
    static const uint32_t RCC_CIFR_CSIRDY_MASK = UINT32_C(0x00000010);                      /** @brief CSI ready interrupt flag */
    static const uint32_t RCC_CIFR_RC48RDYF_MASK = UINT32_C(0x00000020);                    /** @brief RC48 ready interrupt flag */
    static const uint32_t RCC_CIFR_LSECSSF_MASK = UINT32_C(0x00000200);                     /** @brief LSE clock security system interrupt flag */
    static const uint32_t RCC_CIFR_HSECSSF_MASK = UINT32_C(0x00000400);                     /** @brief HSE clock security system interrupt flag */
    static const uint32_t RCC_CICR_LSIRDYC_MASK = UINT32_C(0x00000001);                     /** @brief LSI ready interrupt clear */
    static const uint32_t RCC_CICR_LSERDYC_MASK = UINT32_C(0x00000002);                     /** @brief LSE ready interrupt clear */
    static const uint32_t RCC_CICR_HSIRDYC_MASK = UINT32_C(0x00000004);                     /** @brief HSI ready interrupt clear */
    static const uint32_t RCC_CICR_HSERDYC_MASK = UINT32_C(0x00000008);                     /** @brief HSE ready interrupt clear */
    static const uint32_t RCC_CICR_HSE_READY_INTERRUPT_CLEAR_MASK = UINT32_C(0x00000010);   /** @brief CSI ready interrupt clear */
    static const uint32_t RCC_CICR_RC48RDYC_MASK = UINT32_C(0x00000020);                    /** @brief RC48 ready interrupt clear */
    static const uint32_t RCC_CICR_LSECSSC_MASK = UINT32_C(0x00000200);                     /** @brief LSE clock security system interrupt clear */
    static const uint32_t RCC_CICR_HSECSSC_MASK = UINT32_C(0x00000400);                     /** @brief HSE clock security system interrupt clear */
    static const uint32_t RCC_BDCR_LSEON_MASK = UINT32_C(0x00000001);                       /** @brief LSE oscillator enabled */
    static const uint32_t RCC_BDCR_LSERDY_MASK = UINT32_C(0x00000002);                      /** @brief LSE oscillator ready */
    static const uint32_t RCC_BDCR_LSEBYP_MASK = UINT32_C(0x00000004);                      /** @brief LSE oscillator bypass */
    static const uint32_t RCC_BDCR_LSEDRV_MASK = UINT32_C(0x00000018);                      /** @brief LSE oscillator driving capability */
    static const uint32_t RCC_BDCR_LSECSSON_MASK = UINT32_C(0x00000020);                    /** @brief LSE clock security system enable */
    static const uint32_t RCC_BDCR_LSECSSD_MASK = UINT32_C(0x00000040);                     /** @brief LSE clock security system failure detection */
    static const uint32_t RCC_BDCR_RTCSRC_MASK = UINT32_C(0x00000300);                      /** @brief RTC clock source selection */
    static const uint32_t RCC_BDCR_RTCEN_MASK = UINT32_C(0x00008000);                       /** @brief RTC clock enable */
    static const uint32_t RCC_BDCR_VSWRST_MASK = UINT32_C(0x00010000);                      /** @brief VSwitch domain software reset */
    static const uint32_t RCC_CSR_LSION_MASK = UINT32_C(0x00000001);                        /** @brief LSI oscillator enable */
    static const uint32_t RCC_CSR_LSIRDY_MASK = UINT32_C(0x00000002);                       /** @brief LSI oscillator ready */
    static const uint32_t RCC_AHB3RSTR_MDMARST_MASK = UINT32_C(0x00000001);                 /** @brief MDMA block reset */
    static const uint32_t RCC_AHB3RSTR_DMA2DRST_MASK = UINT32_C(0x00000010);                /** @brief DMA2D block reset */
    static const uint32_t RCC_AHB3RSTR_JPGDECRST_MASK = UINT32_C(0x00000020);               /** @brief JPGDEC block reset */
    static const uint32_t RCC_AHB3RSTR_FMCRST_MASK = UINT32_C(0x00001000);                  /** @brief FMC block reset */
    static const uint32_t RCC_AHB3RSTR_QSPIRST_MASK = UINT32_C(0x00004000);                 /** @brief QUADSPI and QUADSPI delay block reset */
    static const uint32_t RCC_AHB3RSTR_SDMMC1RST_MASK = UINT32_C(0x00010000);               /** @brief SDMMC1 and SDMMC1 delay block reset */
    static const uint32_t RCC_AHB3RSTR_CPURST_MASK = UINT32_C(0x80000000);                  /** @brief CPU reset */
    static const uint32_t RCC_AHB1RSTR_DMA1RST_MASK = UINT32_C(0x00000001);                 /** @brief DMA1 block reset */
    static const uint32_t RCC_AHB1RSTR_DMA2RST_MASK = UINT32_C(0x00000002);                 /** @brief DMA2 block reset */
    static const uint32_t RCC_AHB1RSTR_ADC12RST_MASK = UINT32_C(0x00000020);                /** @brief ADC1&2 block reset */
    static const uint32_t RCC_AHB1RSTR_ETH1MACRST_MASK = UINT32_C(0x00008000);              /** @brief ETH1MAC block reset */
    static const uint32_t RCC_AHB1RSTR_USB1OTGRST_MASK = UINT32_C(0x02000000);              /** @brief USB1OTG block reset */
    static const uint32_t RCC_AHB1RSTR_USB2OTGRST_MASK = UINT32_C(0x08000000);              /** @brief USB2OTG block reset */
    static const uint32_t RCC_AHB2RSTR_CAMITFRST_MASK = UINT32_C(0x00000001);               /** @brief CAMITF block reset */
    static const uint32_t RCC_AHB2RSTR_CRYPTRST_MASK = UINT32_C(0x00000010);                /** @brief Cryptography block reset */
    static const uint32_t RCC_AHB2RSTR_HASHRST_MASK = UINT32_C(0x00000020);                 /** @brief Hash block reset */
    static const uint32_t RCC_AHB2RSTR_RNGRST_MASK = UINT32_C(0x00000040);                  /** @brief Random number generator block reset */
    static const uint32_t RCC_AHB2RSTR_SDMMC2RST_MASK = UINT32_C(0x00000200);               /** @brief SDMMC2 and SDMMC2 delay block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOARST_MASK = UINT32_C(0x00000001);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOBRST_MASK = UINT32_C(0x00000002);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOCRST_MASK = UINT32_C(0x00000004);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIODRST_MASK = UINT32_C(0x00000008);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOERST_MASK = UINT32_C(0x00000010);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOFRST_MASK = UINT32_C(0x00000020);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOGRST_MASK = UINT32_C(0x00000040);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOHRST_MASK = UINT32_C(0x00000080);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOIRST_MASK = UINT32_C(0x00000100);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOJRST_MASK = UINT32_C(0x00000200);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_GPIOKRST_MASK = UINT32_C(0x00000400);                /** @brief GPIO block reset */
    static const uint32_t RCC_AHB4RSTR_CRCRST_MASK = UINT32_C(0x00080000);                  /** @brief CRC block reset */
    static const uint32_t RCC_AHB4RSTR_BDMARST_MASK = UINT32_C(0x00200000);                 /** @brief BDMA block reset */
    static const uint32_t RCC_AHB4RSTR_ADC3RST_MASK = UINT32_C(0x01000000);                 /** @brief ADC3 block reset */
    static const uint32_t RCC_AHB4RSTR_HSEMRST_MASK = UINT32_C(0x02000000);                 /** @brief HSEM block reset */
    static const uint32_t RCC_APB3RSTR_LTDCRST_MASK = UINT32_C(0x00000008);                 /** @brief LTDC block reset */
    static const uint32_t RCC_APB1LRSTR_LPTIM1RST_MASK = UINT32_C(0x00000200);              /** @brief TIM block reset */
    static const uint32_t RCC_APB1LRSTR_SPI2RST_MASK = UINT32_C(0x00004000);                /** @brief SPI2 block reset */
    static const uint32_t RCC_APB1LRSTR_SPI3RST_MASK = UINT32_C(0x00008000);                /** @brief SPI3 block reset */
    static const uint32_t RCC_APB1LRSTR_SPDIFRXRST_MASK = UINT32_C(0x00010000);             /** @brief SPDIFRX block reset */
    static const uint32_t RCC_APB1LRSTR_UART4RST_MASK = UINT32_C(0x00080000);               /** @brief UART4 block reset */
    static const uint32_t RCC_APB1LRSTR_UART5RST_MASK = UINT32_C(0x00100000);               /** @brief UART5 block reset */
    static const uint32_t RCC_APB1LRSTR_HDMICECRST_MASK = UINT32_C(0x08000000);             /** @brief HDMI-CEC block reset */
    static const uint32_t RCC_APB1LRSTR_DAC12RST_MASK = UINT32_C(0x20000000);               /** @brief DAC1 and 2 blocks reset */
    static const uint32_t RCC_APB1HRSTR_CRSRST_MASK = UINT32_C(0x00000002);                 /** @brief Clock recovery system reset */
    static const uint32_t RCC_APB1HRSTR_SWPRST_MASK = UINT32_C(0x00000004);                 /** @brief SWPMI block reset */
    static const uint32_t RCC_APB1HRSTR_OPAMPRST_MASK = UINT32_C(0x00000010);               /** @brief OPAMP block reset */
    static const uint32_t RCC_APB1HRSTR_MDIOSRST_MASK = UINT32_C(0x00000020);               /** @brief MDIOS block reset */
    static const uint32_t RCC_APB1HRSTR_FDCANRST_MASK = UINT32_C(0x00000100);               /** @brief FDCAN block reset */
    static const uint32_t RCC_APB2RSTR_TIM1RST_MASK = UINT32_C(0x00000001);                 /** @brief TIM1 block reset */
    static const uint32_t RCC_APB2RSTR_TIM8RST_MASK = UINT32_C(0x00000002);                 /** @brief TIM8 block reset */
    static const uint32_t RCC_APB2RSTR_USART1RST_MASK = UINT32_C(0x00000010);               /** @brief USART1 block reset */
    static const uint32_t RCC_APB2RSTR_USART6RST_MASK = UINT32_C(0x00000020);               /** @brief USART6 block reset */
    static const uint32_t RCC_APB2RSTR_DFSDM1RST_MASK = UINT32_C(0x10000000);               /** @brief DFSDM1 block reset */
    static const uint32_t RCC_APB2RSTR_HRTIMRST_MASK = UINT32_C(0x20000000);                /** @brief HRTIM block reset */
    static const uint32_t RCC_APB4RSTR_SYSCFGRST_MASK = UINT32_C(0x00000002);               /** @brief SYSCFG block reset */
    static const uint32_t RCC_APB4RSTR_LPUART1RST_MASK = UINT32_C(0x00000008);              /** @brief LPUART1 block reset */
    static const uint32_t RCC_APB4RSTR_SPI6RST_MASK = UINT32_C(0x00000020);                 /** @brief SPI6 block reset */
    static const uint32_t RCC_APB4RSTR_I2C4RST_MASK = UINT32_C(0x00000080);                 /** @brief I2C4 block reset */
    static const uint32_t RCC_APB4RSTR_COMP12RST_MASK = UINT32_C(0x00004000);               /** @brief COMP12 blocks reset */
    static const uint32_t RCC_APB4RSTR_VREFRST_MASK = UINT32_C(0x00008000);                 /** @brief VREF block reset */
    static const uint32_t RCC_APB4RSTR_SAI4RST_MASK = UINT32_C(0x00200000);                 /** @brief SAI4 block reset */
    static const uint32_t RCC_GCR_WW1RSC_MASK = UINT32_C(0x00000001);                       /** @brief WWDG1 reset scope control */
    static const uint32_t RCC_D3AMR_BDMAAMEN_MASK = UINT32_C(0x00000001);                   /** @brief BDMA and DMAMUX autonomous mode enable */
    static const uint32_t RCC_D3AMR_LPUART1AMEN_MASK = UINT32_C(0x00000008);                /** @brief LPUART1 autonomous mode enable */
    static const uint32_t RCC_D3AMR_SPI6AMEN_MASK = UINT32_C(0x00000020);                   /** @brief SPI6 autonomous mode enable */
    static const uint32_t RCC_D3AMR_I2C4AMEN_MASK = UINT32_C(0x00000080);                   /** @brief I2C4 autonomous mode enable */
    static const uint32_t RCC_D3AMR_COMP12AMEN_MASK = UINT32_C(0x00004000);                 /** @brief COMP12 autonomous mode enable */
    static const uint32_t RCC_D3AMR_VREFAMEN_MASK = UINT32_C(0x00008000);                   /** @brief VREF autonomous mode enable */
    static const uint32_t RCC_D3AMR_RTCAMEN_MASK = UINT32_C(0x00010000);                    /** @brief RTC autonomous mode enable */
    static const uint32_t RCC_D3AMR_CRCAMEN_MASK = UINT32_C(0x00080000);                    /** @brief CRC autonomous mode enable */
    static const uint32_t RCC_D3AMR_SAI4AMEN_MASK = UINT32_C(0x00200000);                   /** @brief SAI4 autonomous mode enable */
    static const uint32_t RCC_D3AMR_ADC3AMEN_MASK = UINT32_C(0x01000000);                   /** @brief ADC3 autonomous mode enable */
    static const uint32_t RCC_D3AMR_BKPSRAMAMEN_MASK = UINT32_C(0x10000000);                /** @brief Backup RAM autonomous mode enable */
    static const uint32_t RCC_D3AMR_SRAM4AMEN_MASK = UINT32_C(0x20000000);                  /** @brief SRAM4 autonomous mode enable */
    static const uint32_t RCC_RSR_RMVF_MASK = UINT32_C(0x00010000);                         /** @brief Remove reset flag */
    static const uint32_t RCC_RSR_CPURSTF_MASK = UINT32_C(0x00020000);                      /** @brief CPU reset flag */
    static const uint32_t RCC_RSR_D1RSTF_MASK = UINT32_C(0x00080000);                       /** @brief D1 domain power switch reset flag */
    static const uint32_t RCC_RSR_D2RSTF_MASK = UINT32_C(0x00100000);                       /** @brief D2 domain power switch reset flag */
    static const uint32_t RCC_RSR_BORRSTF_MASK = UINT32_C(0x00200000);                      /** @brief BOR reset flag */
    static const uint32_t RCC_RSR_PINRSTF_MASK = UINT32_C(0x00400000);                      /** @brief Pin reset flag (NRST) */
    static const uint32_t RCC_RSR_PORRSTF_MASK = UINT32_C(0x00800000);                      /** @brief POR/PDR reset flag */
    static const uint32_t RCC_RSR_SFTRSTF_MASK = UINT32_C(0x01000000);                      /** @brief System reset from CPU reset flag */
    static const uint32_t RCC_RSR_IWDG1RSTF_MASK = UINT32_C(0x04000000);                    /** @brief Independent watchdog reset flag */
    static const uint32_t RCC_RSR_WWDG1RSTF_MASK = UINT32_C(0x10000000);                    /** @brief Window watchdog reset flag */
    static const uint32_t RCC_RSR_LPWRRSTF_MASK = UINT32_C(0x40000000);                     /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const uint32_t RCC_C1_RSR_RMVF_MASK = UINT32_C(0x00010000);                      /** @brief Remove reset flag */
    static const uint32_t RCC_C1_RSR_CPURSTF_MASK = UINT32_C(0x00020000);                   /** @brief CPU reset flag */
    static const uint32_t RCC_C1_RSR_D1RSTF_MASK = UINT32_C(0x00080000);                    /** @brief D1 domain power switch reset flag */
    static const uint32_t RCC_C1_RSR_D2RSTF_MASK = UINT32_C(0x00100000);                    /** @brief D2 domain power switch reset flag */
    static const uint32_t RCC_C1_RSR_BORRSTF_MASK = UINT32_C(0x00200000);                   /** @brief BOR reset flag */
    static const uint32_t RCC_C1_RSR_PINRSTF_MASK = UINT32_C(0x00400000);                   /** @brief Pin reset flag (NRST) */
    static const uint32_t RCC_C1_RSR_PORRSTF_MASK = UINT32_C(0x00800000);                   /** @brief POR/PDR reset flag */
    static const uint32_t RCC_C1_RSR_SFTRSTF_MASK = UINT32_C(0x01000000);                   /** @brief System reset from CPU reset flag */
    static const uint32_t RCC_C1_RSR_IWDG1RSTF_MASK = UINT32_C(0x04000000);                 /** @brief Independent watchdog reset flag */
    static const uint32_t RCC_C1_RSR_WWDG1RSTF_MASK = UINT32_C(0x10000000);                 /** @brief Window watchdog reset flag */
    static const uint32_t RCC_C1_RSR_LPWRRSTF_MASK = UINT32_C(0x40000000);                  /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const uint32_t RCC_C1_AHB3ENR_MDMAEN_MASK = UINT32_C(0x00000001);                /** @brief MDMA peripheral clock enable */
    static const uint32_t RCC_C1_AHB3ENR_DMA2DEN_MASK = UINT32_C(0x00000010);               /** @brief DMA2D peripheral clock enable */
    static const uint32_t RCC_C1_AHB3ENR_JPGDECEN_MASK = UINT32_C(0x00000020);              /** @brief JPGDEC peripheral clock enable */
    static const uint32_t RCC_C1_AHB3ENR_FMCEN_MASK = UINT32_C(0x00001000);                 /** @brief FMC peripheral clocks enable */
    static const uint32_t RCC_C1_AHB3ENR_QSPIEN_MASK = UINT32_C(0x00004000);                /** @brief QUADSPI and QUADSPI delay clock enable */
    static const uint32_t RCC_C1_AHB3ENR_SDMMC1EN_MASK = UINT32_C(0x00010000);              /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const uint32_t RCC_AHB3ENR_MDMAEN_MASK = UINT32_C(0x00000001);                   /** @brief MDMA peripheral clock enable */
    static const uint32_t RCC_AHB3ENR_DMA2DEN_MASK = UINT32_C(0x00000010);                  /** @brief DMA2D peripheral clock enable */
    static const uint32_t RCC_AHB3ENR_JPGDECEN_MASK = UINT32_C(0x00000020);                 /** @brief JPGDEC peripheral clock enable */
    static const uint32_t RCC_AHB3ENR_FMCEN_MASK = UINT32_C(0x00001000);                    /** @brief FMC peripheral clocks enable */
    static const uint32_t RCC_AHB3ENR_QSPIEN_MASK = UINT32_C(0x00004000);                   /** @brief QUADSPI and QUADSPI delay clock enable */
    static const uint32_t RCC_AHB3ENR_SDMMC1EN_MASK = UINT32_C(0x00010000);                 /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const uint32_t RCC_AHB1ENR_DMA1EN_MASK = UINT32_C(0x00000001);                   /** @brief DMA1 clock enable */
    static const uint32_t RCC_AHB1ENR_DMA2EN_MASK = UINT32_C(0x00000002);                   /** @brief DMA2 clock enable */
    static const uint32_t RCC_AHB1ENR_ADC12EN_MASK = UINT32_C(0x00000020);                  /** @brief ADC1/2 peripheral clocks enable */
    static const uint32_t RCC_AHB1ENR_ETH1MACEN_MASK = UINT32_C(0x00008000);                /** @brief Ethernet MAC bus interface clock enable */
    static const uint32_t RCC_AHB1ENR_ETH1TXEN_MASK = UINT32_C(0x00010000);                 /** @brief Ethernet transmission clock enable */
    static const uint32_t RCC_AHB1ENR_ETH1RXEN_MASK = UINT32_C(0x00020000);                 /** @brief Ethernet reception clock enable */
    static const uint32_t RCC_AHB1ENR_USB1OTGEN_MASK = UINT32_C(0x02000000);                /** @brief USB1OTG peripheral clocks enable */
    static const uint32_t RCC_AHB1ENR_USB1ULPIEN_MASK = UINT32_C(0x04000000);               /** @brief USB_PHY1 clocks enable */
    static const uint32_t RCC_AHB1ENR_USB2OTGEN_MASK = UINT32_C(0x08000000);                /** @brief USB2OTG peripheral clocks enable */
    static const uint32_t RCC_AHB1ENR_USB2ULPIEN_MASK = UINT32_C(0x10000000);               /** @brief USB_PHY2 clocks enable */
    static const uint32_t RCC_C1_AHB1ENR_DMA1EN_MASK = UINT32_C(0x00000001);                /** @brief DMA1 clock enable */
    static const uint32_t RCC_C1_AHB1ENR_DMA2EN_MASK = UINT32_C(0x00000002);                /** @brief DMA2 clock enable */
    static const uint32_t RCC_C1_AHB1ENR_ADC12EN_MASK = UINT32_C(0x00000020);               /** @brief ADC1/2 peripheral clocks enable */
    static const uint32_t RCC_C1_AHB1ENR_ETH1MACEN_MASK = UINT32_C(0x00008000);             /** @brief Ethernet MAC bus interface clock enable */
    static const uint32_t RCC_C1_AHB1ENR_ETH1TXEN_MASK = UINT32_C(0x00010000);              /** @brief Ethernet transmission clock enable */
    static const uint32_t RCC_C1_AHB1ENR_ETH1RXEN_MASK = UINT32_C(0x00020000);              /** @brief Ethernet reception clock enable */
    static const uint32_t RCC_C1_AHB1ENR_USB1OTGEN_MASK = UINT32_C(0x02000000);             /** @brief USB1OTG peripheral clocks enable */
    static const uint32_t RCC_C1_AHB1ENR_USB1ULPIEN_MASK = UINT32_C(0x04000000);            /** @brief USB_PHY1 clocks enable */
    static const uint32_t RCC_C1_AHB1ENR_USB2OTGEN_MASK = UINT32_C(0x08000000);             /** @brief USB2OTG peripheral clocks enable */
    static const uint32_t RCC_C1_AHB1ENR_USB2ULPIEN_MASK = UINT32_C(0x10000000);            /** @brief USB_PHY2 clocks enable */
    static const uint32_t RCC_C1_AHB2ENR_CAMITFEN_MASK = UINT32_C(0x00000001);              /** @brief CAMITF peripheral clock enable */
    static const uint32_t RCC_C1_AHB2ENR_CRYPTEN_MASK = UINT32_C(0x00000010);               /** @brief CRYPT peripheral clock enable */
    static const uint32_t RCC_C1_AHB2ENR_HASHEN_MASK = UINT32_C(0x00000020);                /** @brief HASH peripheral clock enable */
    static const uint32_t RCC_C1_AHB2ENR_RNGEN_MASK = UINT32_C(0x00000040);                 /** @brief RNG peripheral clocks enable */
    static const uint32_t RCC_C1_AHB2ENR_SDMMC2EN_MASK = UINT32_C(0x00000200);              /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const uint32_t RCC_AHB2ENR_CAMITFEN_MASK = UINT32_C(0x00000001);                 /** @brief CAMITF peripheral clock enable */
    static const uint32_t RCC_AHB2ENR_CRYPTEN_MASK = UINT32_C(0x00000010);                  /** @brief CRYPT peripheral clock enable */
    static const uint32_t RCC_AHB2ENR_HASHEN_MASK = UINT32_C(0x00000020);                   /** @brief HASH peripheral clock enable */
    static const uint32_t RCC_AHB2ENR_RNGEN_MASK = UINT32_C(0x00000040);                    /** @brief RNG peripheral clocks enable */
    static const uint32_t RCC_AHB2ENR_SDMMC2EN_MASK = UINT32_C(0x00000200);                 /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOAEN_MASK = UINT32_C(0x00000001);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOBEN_MASK = UINT32_C(0x00000002);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOCEN_MASK = UINT32_C(0x00000004);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIODEN_MASK = UINT32_C(0x00000008);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOEEN_MASK = UINT32_C(0x00000010);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOFEN_MASK = UINT32_C(0x00000020);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOGEN_MASK = UINT32_C(0x00000040);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOHEN_MASK = UINT32_C(0x00000080);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOIEN_MASK = UINT32_C(0x00000100);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOJEN_MASK = UINT32_C(0x00000200);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_GPIOKEN_MASK = UINT32_C(0x00000400);                  /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_CRCEN_MASK = UINT32_C(0x00080000);                    /** @brief CRC peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_BDMAEN_MASK = UINT32_C(0x00200000);                   /** @brief BDMA and DMAMUX2 clock enable */
    static const uint32_t RCC_AHB4ENR_ADC3EN_MASK = UINT32_C(0x01000000);                   /** @brief ADC3 peripheral clocks enable */
    static const uint32_t RCC_AHB4ENR_HSEMEN_MASK = UINT32_C(0x02000000);                   /** @brief HSEM peripheral clock enable */
    static const uint32_t RCC_AHB4ENR_BKPRAMEN_MASK = UINT32_C(0x10000000);                 /** @brief Backup RAM clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOAEN_MASK = UINT32_C(0x00000001);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOBEN_MASK = UINT32_C(0x00000002);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOCEN_MASK = UINT32_C(0x00000004);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIODEN_MASK = UINT32_C(0x00000008);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOEEN_MASK = UINT32_C(0x00000010);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOFEN_MASK = UINT32_C(0x00000020);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOGEN_MASK = UINT32_C(0x00000040);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOHEN_MASK = UINT32_C(0x00000080);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOIEN_MASK = UINT32_C(0x00000100);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOJEN_MASK = UINT32_C(0x00000200);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_GPIOKEN_MASK = UINT32_C(0x00000400);               /** @brief 0GPIO peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_CRCEN_MASK = UINT32_C(0x00080000);                 /** @brief CRC peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_BDMAEN_MASK = UINT32_C(0x00200000);                /** @brief BDMA and DMAMUX2 clock enable */
    static const uint32_t RCC_C1_AHB4ENR_ADC3EN_MASK = UINT32_C(0x01000000);                /** @brief ADC3 peripheral clocks enable */
    static const uint32_t RCC_C1_AHB4ENR_HSEMEN_MASK = UINT32_C(0x02000000);                /** @brief HSEM peripheral clock enable */
    static const uint32_t RCC_C1_AHB4ENR_BKPRAMEN_MASK = UINT32_C(0x10000000);              /** @brief Backup RAM clock enable */
    static const uint32_t RCC_C1_APB3ENR_LTDCEN_MASK = UINT32_C(0x00000008);                /** @brief LTDC peripheral clock enable */
    static const uint32_t RCC_C1_APB3ENR_WWDG1EN_MASK = UINT32_C(0x00000040);               /** @brief WWDG1 clock enable */
    static const uint32_t RCC_APB3ENR_LTDCEN_MASK = UINT32_C(0x00000008);                   /** @brief LTDC peripheral clock enable */
    static const uint32_t RCC_APB3ENR_WWDG1EN_MASK = UINT32_C(0x00000040);                  /** @brief WWDG1 clock enable */
    static const uint32_t RCC_APB1LENR_LPTIM1EN_MASK = UINT32_C(0x00000200);                /** @brief LPTIM1 peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_SPI2EN_MASK = UINT32_C(0x00004000);                  /** @brief SPI2 peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_SPI3EN_MASK = UINT32_C(0x00008000);                  /** @brief SPI3 peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_SPDIFRXEN_MASK = UINT32_C(0x00010000);               /** @brief SPDIFRX peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_UART4EN_MASK = UINT32_C(0x00080000);                 /** @brief UART4 peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_UART5EN_MASK = UINT32_C(0x00100000);                 /** @brief UART5 peripheral clocks enable */
    static const uint32_t RCC_APB1LENR_HDMICECEN_MASK = UINT32_C(0x08000000);               /** @brief HDMI-CEC peripheral clock enable */
    static const uint32_t RCC_APB1LENR_DAC12EN_MASK = UINT32_C(0x20000000);                 /** @brief DAC1&2 peripheral clock enable */
    static const uint32_t RCC_C1_APB1LENR_LPTIM1EN_MASK = UINT32_C(0x00000200);             /** @brief LPTIM1 peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_SPI2EN_MASK = UINT32_C(0x00004000);               /** @brief SPI2 peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_SPI3EN_MASK = UINT32_C(0x00008000);               /** @brief SPI3 peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_SPDIFRXEN_MASK = UINT32_C(0x00010000);            /** @brief SPDIFRX peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_UART4EN_MASK = UINT32_C(0x00080000);              /** @brief UART4 peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_UART5EN_MASK = UINT32_C(0x00100000);              /** @brief UART5 peripheral clocks enable */
    static const uint32_t RCC_C1_APB1LENR_HDMICECEN_MASK = UINT32_C(0x08000000);            /** @brief HDMI-CEC peripheral clock enable */
    static const uint32_t RCC_C1_APB1LENR_DAC12EN_MASK = UINT32_C(0x20000000);              /** @brief DAC1&2 peripheral clock enable */
    static const uint32_t RCC_APB1HENR_CRSEN_MASK = UINT32_C(0x00000002);                   /** @brief Clock recovery system peripheral clock enable */
    static const uint32_t RCC_APB1HENR_SWPEN_MASK = UINT32_C(0x00000004);                   /** @brief SWPMI peripheral clocks enable */
    static const uint32_t RCC_APB1HENR_OPAMPEN_MASK = UINT32_C(0x00000010);                 /** @brief OPAMP peripheral clock enable */
    static const uint32_t RCC_APB1HENR_MDIOSEN_MASK = UINT32_C(0x00000020);                 /** @brief MDIOS peripheral clock enable */
    static const uint32_t RCC_APB1HENR_FDCANEN_MASK = UINT32_C(0x00000100);                 /** @brief FDCAN peripheral clocks enable */
    static const uint32_t RCC_C1_APB1HENR_CRSEN_MASK = UINT32_C(0x00000002);                /** @brief Clock recovery system peripheral clock enable */
    static const uint32_t RCC_C1_APB1HENR_SWPEN_MASK = UINT32_C(0x00000004);                /** @brief SWPMI peripheral clocks enable */
    static const uint32_t RCC_C1_APB1HENR_OPAMPEN_MASK = UINT32_C(0x00000010);              /** @brief OPAMP peripheral clock enable */
    static const uint32_t RCC_C1_APB1HENR_MDIOSEN_MASK = UINT32_C(0x00000020);              /** @brief MDIOS peripheral clock enable */
    static const uint32_t RCC_C1_APB1HENR_FDCANEN_MASK = UINT32_C(0x00000100);              /** @brief FDCAN peripheral clocks enable */
    static const uint32_t RCC_C1_APB2ENR_TIM1EN_MASK = UINT32_C(0x00000001);                /** @brief TIM1 peripheral clock enable */
    static const uint32_t RCC_C1_APB2ENR_TIM8EN_MASK = UINT32_C(0x00000002);                /** @brief TIM8 peripheral clock enable */
    static const uint32_t RCC_C1_APB2ENR_USART1EN_MASK = UINT32_C(0x00000010);              /** @brief USART1 peripheral clocks enable */
    static const uint32_t RCC_C1_APB2ENR_USART6EN_MASK = UINT32_C(0x00000020);              /** @brief USART6 peripheral clocks enable */
    static const uint32_t RCC_C1_APB2ENR_DFSDM1EN_MASK = UINT32_C(0x10000000);              /** @brief DFSDM1 peripheral clocks enable */
    static const uint32_t RCC_C1_APB2ENR_HRTIMEN_MASK = UINT32_C(0x20000000);               /** @brief HRTIM peripheral clock enable */
    static const uint32_t RCC_APB2ENR_TIM1EN_MASK = UINT32_C(0x00000001);                   /** @brief TIM1 peripheral clock enable */
    static const uint32_t RCC_APB2ENR_TIM8EN_MASK = UINT32_C(0x00000002);                   /** @brief TIM8 peripheral clock enable */
    static const uint32_t RCC_APB2ENR_USART1EN_MASK = UINT32_C(0x00000010);                 /** @brief USART1 peripheral clocks enable */
    static const uint32_t RCC_APB2ENR_USART6EN_MASK = UINT32_C(0x00000020);                 /** @brief USART6 peripheral clocks enable */
    static const uint32_t RCC_APB2ENR_DFSDM1EN_MASK = UINT32_C(0x10000000);                 /** @brief DFSDM1 peripheral clocks enable */
    static const uint32_t RCC_APB2ENR_HRTIMEN_MASK = UINT32_C(0x20000000);                  /** @brief HRTIM peripheral clock enable */
    static const uint32_t RCC_APB4ENR_SYSCFGEN_MASK = UINT32_C(0x00000002);                 /** @brief SYSCFG peripheral clock enable */
    static const uint32_t RCC_APB4ENR_LPUART1EN_MASK = UINT32_C(0x00000008);                /** @brief LPUART1 peripheral clocks enable */
    static const uint32_t RCC_APB4ENR_SPI6EN_MASK = UINT32_C(0x00000020);                   /** @brief SPI6 peripheral clocks enable */
    static const uint32_t RCC_APB4ENR_I2C4EN_MASK = UINT32_C(0x00000080);                   /** @brief I2C4 peripheral clocks enable */
    static const uint32_t RCC_APB4ENR_COMP12EN_MASK = UINT32_C(0x00004000);                 /** @brief COMP1/2 peripheral clock enable */
    static const uint32_t RCC_APB4ENR_VREFEN_MASK = UINT32_C(0x00008000);                   /** @brief VREF peripheral clock enable */
    static const uint32_t RCC_APB4ENR_RTCAPBEN_MASK = UINT32_C(0x00010000);                 /** @brief RTC APB clock enable */
    static const uint32_t RCC_APB4ENR_SAI4EN_MASK = UINT32_C(0x00200000);                   /** @brief SAI4 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_SYSCFGEN_MASK = UINT32_C(0x00000002);              /** @brief SYSCFG peripheral clock enable */
    static const uint32_t RCC_C1_APB4ENR_LPUART1EN_MASK = UINT32_C(0x00000008);             /** @brief LPUART1 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_SPI6EN_MASK = UINT32_C(0x00000020);                /** @brief SPI6 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_I2C4EN_MASK = UINT32_C(0x00000080);                /** @brief I2C4 peripheral clocks enable */
    static const uint32_t RCC_C1_APB4ENR_COMP12EN_MASK = UINT32_C(0x00004000);              /** @brief COMP1/2 peripheral clock enable */
    static const uint32_t RCC_C1_APB4ENR_VREFEN_MASK = UINT32_C(0x00008000);                /** @brief VREF peripheral clock enable */
    static const uint32_t RCC_C1_APB4ENR_RTCAPBEN_MASK = UINT32_C(0x00010000);              /** @brief RTC APB clock enable */
    static const uint32_t RCC_C1_APB4ENR_SAI4EN_MASK = UINT32_C(0x00200000);                /** @brief SAI4 peripheral clocks enable */
    static const uint32_t RCC_C1_AHB3LPENR_MDMALPEN_MASK = UINT32_C(0x00000001);            /** @brief MDMA clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_DMA2DLPEN_MASK = UINT32_C(0x00000010);           /** @brief DMA2D clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_JPGDECLPEN_MASK = UINT32_C(0x00000020);          /** @brief JPGDEC clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_FLITFLPEN_MASK = UINT32_C(0x00000100);           /** @brief FLITF clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_FMCLPEN_MASK = UINT32_C(0x00001000);             /** @brief FMC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_QSPILPEN_MASK = UINT32_C(0x00004000);            /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_SDMMC1LPEN_MASK = UINT32_C(0x00010000);          /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_D1DTCM1LPEN_MASK = UINT32_C(0x10000000);         /** @brief D1DTCM1 block clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_DTCM2LPEN_MASK = UINT32_C(0x20000000);           /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_ITCMLPEN_MASK = UINT32_C(0x40000000);            /** @brief D1ITCM block clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB3LPENR_AXISRAMLPEN_MASK = UINT32_C(0x80000000);         /** @brief AXISRAM block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_MDMALPEN_MASK = UINT32_C(0x00000001);               /** @brief MDMA clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_DMA2DLPEN_MASK = UINT32_C(0x00000010);              /** @brief DMA2D clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_JPGDECLPEN_MASK = UINT32_C(0x00000020);             /** @brief JPGDEC clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_FLITFLPEN_MASK = UINT32_C(0x00000100);              /** @brief FLITF clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_FMCLPEN_MASK = UINT32_C(0x00001000);                /** @brief FMC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_QSPILPEN_MASK = UINT32_C(0x00004000);               /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_SDMMC1LPEN_MASK = UINT32_C(0x00010000);             /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_D1DTCM1LPEN_MASK = UINT32_C(0x10000000);            /** @brief D1DTCM1 block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_DTCM2LPEN_MASK = UINT32_C(0x20000000);              /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_ITCMLPEN_MASK = UINT32_C(0x40000000);               /** @brief D1ITCM block clock enable during csleep mode */
    static const uint32_t RCC_AHB3LPENR_AXISRAMLPEN_MASK = UINT32_C(0x80000000);            /** @brief AXISRAM block clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_DMA1LPEN_MASK = UINT32_C(0x00000001);               /** @brief DMA1 clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_DMA2LPEN_MASK = UINT32_C(0x00000002);               /** @brief DMA2 clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ADC12LPEN_MASK = UINT32_C(0x00000020);              /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ETH1MACLPEN_MASK = UINT32_C(0x00008000);            /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ETH1TXLPEN_MASK = UINT32_C(0x00010000);             /** @brief Ethernet transmission clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_ETH1RXLPEN_MASK = UINT32_C(0x00020000);             /** @brief Ethernet reception clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_USB1OTGLPEN_MASK = UINT32_C(0x02000000);            /** @brief USB1OTG peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_USB1ULPILPEN_MASK = UINT32_C(0x04000000);           /** @brief USB_PHY1 clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_USB2OTGLPEN_MASK = UINT32_C(0x08000000);            /** @brief USB2OTG peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB1LPENR_USB2ULPILPEN_MASK = UINT32_C(0x10000000);           /** @brief USB_PHY2 clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_DMA1LPEN_MASK = UINT32_C(0x00000001);            /** @brief DMA1 clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_DMA2LPEN_MASK = UINT32_C(0x00000002);            /** @brief DMA2 clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ADC12LPEN_MASK = UINT32_C(0x00000020);           /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ETH1MACLPEN_MASK = UINT32_C(0x00008000);         /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ETH1TXLPEN_MASK = UINT32_C(0x00010000);          /** @brief Ethernet transmission clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_ETH1RXLPEN_MASK = UINT32_C(0x00020000);          /** @brief Ethernet reception clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_USB1OTGLPEN_MASK = UINT32_C(0x02000000);         /** @brief USB1OTG peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_USB1ULPILPEN_MASK = UINT32_C(0x04000000);        /** @brief USB_PHY1 clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_USB2OTGLPEN_MASK = UINT32_C(0x08000000);         /** @brief USB2OTG peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB1LPENR_USB2ULPILPEN_MASK = UINT32_C(0x10000000);        /** @brief USB_PHY2 clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_CAMITFLPEN_MASK = UINT32_C(0x00000001);          /** @brief CAMITF peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_CRYPTLPEN_MASK = UINT32_C(0x00000010);           /** @brief CRYPT peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_HASHLPEN_MASK = UINT32_C(0x00000020);            /** @brief HASH peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_SDMMC2LPEN_MASK = UINT32_C(0x00000200);          /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB2LPENR_RNGLPEN_MASK = UINT32_C(0x00000040);             /** @brief RNG peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_CAMITFLPEN_MASK = UINT32_C(0x00000001);             /** @brief CAMITF peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_CRYPTLPEN_MASK = UINT32_C(0x00000010);              /** @brief CRYPT peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_HASHLPEN_MASK = UINT32_C(0x00000020);               /** @brief HASH peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_SDMMC2LPEN_MASK = UINT32_C(0x00000200);             /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const uint32_t RCC_AHB2LPENR_RNGLPEN_MASK = UINT32_C(0x00000040);                /** @brief RNG peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOALPEN_MASK = UINT32_C(0x00000001);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOBLPEN_MASK = UINT32_C(0x00000002);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOCLPEN_MASK = UINT32_C(0x00000004);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIODLPEN_MASK = UINT32_C(0x00000008);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOELPEN_MASK = UINT32_C(0x00000010);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOFLPEN_MASK = UINT32_C(0x00000020);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOGLPEN_MASK = UINT32_C(0x00000040);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOHLPEN_MASK = UINT32_C(0x00000080);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOILPEN_MASK = UINT32_C(0x00000100);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOJLPEN_MASK = UINT32_C(0x00000200);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_GPIOKLPEN_MASK = UINT32_C(0x00000400);              /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_CRCLPEN_MASK = UINT32_C(0x00080000);                /** @brief CRC peripheral clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_BDMALPEN_MASK = UINT32_C(0x00200000);               /** @brief BDMA clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_ADC3LPEN_MASK = UINT32_C(0x01000000);               /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_BKPRAMLPEN_MASK = UINT32_C(0x10000000);             /** @brief Backup RAM clock enable during csleep mode */
    static const uint32_t RCC_AHB4LPENR_SRAM4LPEN_MASK = UINT32_C(0x20000000);              /** @brief SRAM4 clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOALPEN_MASK = UINT32_C(0x00000001);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOBLPEN_MASK = UINT32_C(0x00000002);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOCLPEN_MASK = UINT32_C(0x00000004);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIODLPEN_MASK = UINT32_C(0x00000008);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOELPEN_MASK = UINT32_C(0x00000010);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOFLPEN_MASK = UINT32_C(0x00000020);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOGLPEN_MASK = UINT32_C(0x00000040);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOHLPEN_MASK = UINT32_C(0x00000080);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOILPEN_MASK = UINT32_C(0x00000100);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOJLPEN_MASK = UINT32_C(0x00000200);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_GPIOKLPEN_MASK = UINT32_C(0x00000400);           /** @brief GPIO peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_CRCLPEN_MASK = UINT32_C(0x00080000);             /** @brief CRC peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_BDMALPEN_MASK = UINT32_C(0x00200000);            /** @brief BDMA clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_ADC3LPEN_MASK = UINT32_C(0x01000000);            /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_BKPRAMLPEN_MASK = UINT32_C(0x10000000);          /** @brief Backup RAM clock enable during csleep mode */
    static const uint32_t RCC_C1_AHB4LPENR_SRAM4LPEN_MASK = UINT32_C(0x20000000);           /** @brief SRAM4 clock enable during csleep mode */
    static const uint32_t RCC_C1_APB3LPENR_LTDCLPEN_MASK = UINT32_C(0x00000008);            /** @brief LTDC peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB3LPENR_WWDG1LPEN_MASK = UINT32_C(0x00000040);           /** @brief WWDG1 clock enable during csleep mode */
    static const uint32_t RCC_APB3LPENR_LTDCLPEN_MASK = UINT32_C(0x00000008);               /** @brief LTDC peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB3LPENR_WWDG1LPEN_MASK = UINT32_C(0x00000040);              /** @brief WWDG1 clock enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_LPTIM1LPEN_MASK = UINT32_C(0x00000200);            /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_SPI2LPEN_MASK = UINT32_C(0x00004000);              /** @brief SPI2 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_SPI3LPEN_MASK = UINT32_C(0x00008000);              /** @brief SPI3 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_SPDIFRXLPEN_MASK = UINT32_C(0x00010000);           /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_UART4LPEN_MASK = UINT32_C(0x00080000);             /** @brief UART4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_UART5LPEN_MASK = UINT32_C(0x00100000);             /** @brief UART5 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_HDMICECLPEN_MASK = UINT32_C(0x08000000);           /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_DAC12LPEN_MASK = UINT32_C(0x20000000);             /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_LPTIM1LPEN_MASK = UINT32_C(0x00000200);         /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_SPI2LPEN_MASK = UINT32_C(0x00004000);           /** @brief SPI2 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_SPI3LPEN_MASK = UINT32_C(0x00008000);           /** @brief SPI3 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_SPDIFRXLPEN_MASK = UINT32_C(0x00010000);        /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_UART4LPEN_MASK = UINT32_C(0x00080000);          /** @brief UART4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_UART5LPEN_MASK = UINT32_C(0x00100000);          /** @brief UART5 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_HDMICECLPEN_MASK = UINT32_C(0x08000000);        /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_DAC12LPEN_MASK = UINT32_C(0x20000000);          /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_CRSLPEN_MASK = UINT32_C(0x00000002);            /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_SWPLPEN_MASK = UINT32_C(0x00000004);            /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_OPAMPLPEN_MASK = UINT32_C(0x00000010);          /** @brief OPAMP peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_MDIOSLPEN_MASK = UINT32_C(0x00000020);          /** @brief MDIOS peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_FDCANLPEN_MASK = UINT32_C(0x00000100);          /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_CRSLPEN_MASK = UINT32_C(0x00000002);               /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_SWPLPEN_MASK = UINT32_C(0x00000004);               /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_OPAMPLPEN_MASK = UINT32_C(0x00000010);             /** @brief OPAMP peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_MDIOSLPEN_MASK = UINT32_C(0x00000020);             /** @brief MDIOS peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_FDCANLPEN_MASK = UINT32_C(0x00000100);             /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_TIM1LPEN_MASK = UINT32_C(0x00000001);               /** @brief TIM1 peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_TIM8LPEN_MASK = UINT32_C(0x00000002);               /** @brief TIM8 peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_USART1LPEN_MASK = UINT32_C(0x00000010);             /** @brief USART1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_USART6LPEN_MASK = UINT32_C(0x00000020);             /** @brief USART6 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_DFSDM1LPEN_MASK = UINT32_C(0x10000000);             /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB2LPENR_HRTIMLPEN_MASK = UINT32_C(0x20000000);              /** @brief HRTIM peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_TIM1LPEN_MASK = UINT32_C(0x00000001);            /** @brief TIM1 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_TIM8LPEN_MASK = UINT32_C(0x00000002);            /** @brief TIM8 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_USART1LPEN_MASK = UINT32_C(0x00000010);          /** @brief USART1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_USART6LPEN_MASK = UINT32_C(0x00000020);          /** @brief USART6 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_DFSDM1LPEN_MASK = UINT32_C(0x10000000);          /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB2LPENR_HRTIMLPEN_MASK = UINT32_C(0x20000000);           /** @brief HRTIM peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_SYSCFGLPEN_MASK = UINT32_C(0x00000002);          /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_LPUART1LPEN_MASK = UINT32_C(0x00000008);         /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_SPI6LPEN_MASK = UINT32_C(0x00000020);            /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_I2C4LPEN_MASK = UINT32_C(0x00000080);            /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_COMP12LPEN_MASK = UINT32_C(0x00004000);          /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_VREFLPEN_MASK = UINT32_C(0x00008000);            /** @brief VREF peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_RTCAPBLPEN_MASK = UINT32_C(0x00010000);          /** @brief RTC APB clock enable during csleep mode */
    static const uint32_t RCC_C1_APB4LPENR_SAI4LPEN_MASK = UINT32_C(0x00200000);            /** @brief SAI4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_SYSCFGLPEN_MASK = UINT32_C(0x00000002);             /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_LPUART1LPEN_MASK = UINT32_C(0x00000008);            /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_SPI6LPEN_MASK = UINT32_C(0x00000020);               /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_I2C4LPEN_MASK = UINT32_C(0x00000080);               /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_COMP12LPEN_MASK = UINT32_C(0x00004000);             /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_VREFLPEN_MASK = UINT32_C(0x00008000);               /** @brief VREF peripheral clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_RTCAPBLPEN_MASK = UINT32_C(0x00010000);             /** @brief RTC APB clock enable during csleep mode */
    static const uint32_t RCC_APB4LPENR_SAI4LPEN_MASK = UINT32_C(0x00200000);               /** @brief SAI4 peripheral clocks enable during csleep mode */

    /** @subsection RCC field position array definitions */

    static const int32_t RCC_APB4LPENR_PLLXON_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(24),   /** @brief PLL1 enable */
      INT32_C(26),   /** @brief PLL2 enable */
      INT32_C(28),   /** @brief PLL3 enable */
    };

    static const int32_t RCC_APB4LPENR_PLLXRDY_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(25),   /** @brief PLL1 clock ready flag */
      INT32_C(27),   /** @brief PLL2 clock ready flag */
      INT32_C(29),   /** @brief PLL3 clock ready flag */
    };

    static const int32_t RCC_APB4LPENR_DIVMX_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(4),    /** @brief Prescaler for PLL1 */
      INT32_C(12),   /** @brief Prescaler for PLL2 */
      INT32_C(20),   /** @brief Prescaler for PLL3 */
    };

    static const int32_t RCC_APB4LPENR_PLLXFRACEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief PLL1 fractional latch enable */
      INT32_C(4),    /** @brief PLL2 fractional latch enable */
      INT32_C(8),    /** @brief PLL3 fractional latch enable */
    };

    static const int32_t RCC_APB4LPENR_PLLXVCOSEL_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief PLL1 VCO selection */
      INT32_C(5),    /** @brief PLL2 VCO selection */
      INT32_C(9),    /** @brief PLL3 VCO selection */
    };

    static const int32_t RCC_APB4LPENR_PLLXRGE_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(2),    /** @brief PLL1 input frequency range */
      INT32_C(6),    /** @brief PLL2 input frequency range */
      INT32_C(10),   /** @brief PLL3 input frequency range */
    };

    static const int32_t RCC_APB4LPENR_DIVPXEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief PLL1 DIVP divider output enable */
      INT32_C(19),   /** @brief PLL2 DIVP divider output enable */
      INT32_C(22),   /** @brief PLL3 DIVP divider output enable */
    };

    static const int32_t RCC_APB4LPENR_DIVQXEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(17),   /** @brief PLL1 DIVQ divider output enable */
      INT32_C(20),   /** @brief PLL2 DIVQ divider output enable */
      INT32_C(23),   /** @brief PLL3 DIVQ divider output enable */
    };

    static const int32_t RCC_APB4LPENR_DIVRXEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(18),   /** @brief PLL1 DIVR divider output enable */
      INT32_C(21),   /** @brief PLL2 DIVR divider output enable */
      INT32_C(24),   /** @brief PLL3 DIVR divider output enable */
    };

    static const int32_t RCC_APB4LPENR_PLLXRDYIE_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief PLL1 ready interrupt enable */
      INT32_C(7),    /** @brief PLL2 ready interrupt enable */
      INT32_C(8),    /** @brief PLL3 ready interrupt enable */
    };

    static const int32_t RCC_APB4LPENR_PLLXRDYF_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief PLL1 ready interrupt flag */
      INT32_C(7),    /** @brief PLL2 ready interrupt flag */
      INT32_C(8),    /** @brief PLL3 ready interrupt flag */
    };

    static const int32_t RCC_APB4LPENR_PLLXRDYC_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief PLL1 ready interrupt clear */
      INT32_C(7),    /** @brief PLL2 ready interrupt clear */
      INT32_C(8),    /** @brief PLL3 ready interrupt clear */
    };

    static const int32_t RCC_APB4LPENR_TIMXRST_POS[15] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief TIM block reset */
      INT32_C(1),    /** @brief TIM block reset */
      INT32_C(2),    /** @brief TIM block reset */
      INT32_C(3),    /** @brief TIM block reset */
      INT32_C(4),    /** @brief TIM block reset */
      INT32_C(5),    /** @brief TIM block reset */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief TIM block reset */
      INT32_C(7),    /** @brief TIM block reset */
      INT32_C(8),    /** @brief TIM block reset */
    };

    static const int32_t RCC_APB4LPENR_USARTXRST_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(17),   /** @brief USART2 block reset */
      INT32_C(18),   /** @brief USART3 block reset */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief USART7 block reset */
      INT32_C(31),   /** @brief USART8 block reset */
    };

    static const int32_t RCC_APB4LPENR_I2CXRST_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief I2C1 block reset */
      INT32_C(22),   /** @brief I2C2 block reset */
      INT32_C(23),   /** @brief I2C3 block reset */
    };

    static const int32_t RCC_APB4LPENR_SPIXRST_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief SPI1 block reset */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(13),   /** @brief SPI4 block reset */
      INT32_C(20),   /** @brief SPI5 block reset */
    };

    static const int32_t RCC_APB4LPENR_TIM1XRST_POS[8] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief TIM15 block reset */
      INT32_C(17),   /** @brief TIM16 block reset */
      INT32_C(18),   /** @brief TIM17 block reset */
    };

    static const int32_t RCC_APB4LPENR_SAIXRST_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief SAI1 block reset */
      INT32_C(23),   /** @brief SAI2 block reset */
      INT32_C(24),   /** @brief SAI3 block reset */
    };

    static const int32_t RCC_APB4LPENR_LPTIMXRST_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief LPTIM2 block reset */
      INT32_C(10),   /** @brief LPTIM3 block reset */
      INT32_C(11),   /** @brief LPTIM4 block reset */
      INT32_C(12),   /** @brief LPTIM5 block reset */
    };

    static const int32_t RCC_APB4LPENR_LPTIMXAMEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief LPTIM2 autonomous mode enable */
      INT32_C(10),   /** @brief LPTIM3 autonomous mode enable */
      INT32_C(11),   /** @brief LPTIM4 autonomous mode enable */
      INT32_C(12),   /** @brief LPTIM5 autonomous mode enable */
    };

    static const int32_t RCC_APB4LPENR_SRAMXEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(29),   /** @brief SRAM1 block enable */
      INT32_C(30),   /** @brief SRAM2 block enable */
      INT32_C(31),   /** @brief SRAM3 block enable */
    };

    static const int32_t RCC_APB4LPENR_TIMXEN_POS[15] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief TIM peripheral clock enable */
      INT32_C(1),    /** @brief TIM peripheral clock enable */
      INT32_C(2),    /** @brief TIM peripheral clock enable */
      INT32_C(3),    /** @brief TIM peripheral clock enable */
      INT32_C(4),    /** @brief TIM peripheral clock enable */
      INT32_C(5),    /** @brief TIM peripheral clock enable */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief TIM peripheral clock enable */
      INT32_C(7),    /** @brief TIM peripheral clock enable */
      INT32_C(8),    /** @brief TIM peripheral clock enable */
    };

    static const int32_t RCC_APB4LPENR_USARTXEN_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(17),   /** @brief USART2 peripheral clocks enable */
      INT32_C(18),   /** @brief USART3 peripheral clocks enable */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief USART7 peripheral clocks enable */
      INT32_C(31),   /** @brief USART8 peripheral clocks enable */
    };

    static const int32_t RCC_APB4LPENR_I2CXEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief I2C1 peripheral clocks enable */
      INT32_C(22),   /** @brief I2C2 peripheral clocks enable */
      INT32_C(23),   /** @brief I2C3 peripheral clocks enable */
    };

    static const int32_t RCC_APB4LPENR_SPIXEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief SPI1 peripheral clocks enable */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(13),   /** @brief SPI4 peripheral clocks enable */
      INT32_C(20),   /** @brief SPI5 peripheral clocks enable */
    };

    static const int32_t RCC_APB4LPENR_TIM1XEN_POS[8] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief TIM15 peripheral clock enable */
      INT32_C(17),   /** @brief TIM16 peripheral clock enable */
      INT32_C(18),   /** @brief TIM17 peripheral clock enable */
    };

    static const int32_t RCC_APB4LPENR_SAIXEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief SAI1 peripheral clocks enable */
      INT32_C(23),   /** @brief SAI2 peripheral clocks enable */
      INT32_C(24),   /** @brief SAI3 peripheral clocks enable */
    };

    static const int32_t RCC_APB4LPENR_LPTIMXEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief LPTIM2 peripheral clocks enable */
      INT32_C(10),   /** @brief LPTIM3 peripheral clocks enable */
      INT32_C(11),   /** @brief LPTIM4 peripheral clocks enable */
      INT32_C(12),   /** @brief LPTIM5 peripheral clocks enable */
    };

    static const int32_t RCC_APB4LPENR_SRAMXLPEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(29),   /** @brief SRAM1 clock enable during csleep mode */
      INT32_C(30),   /** @brief SRAM2 clock enable during csleep mode */
      INT32_C(31),   /** @brief SRAM3 clock enable during csleep mode */
    };

    static const int32_t RCC_APB4LPENR_TIMXLPEN_POS[15] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief TIM2 peripheral clock enable during csleep mode */
      INT32_C(1),    /** @brief TIM3 peripheral clock enable during csleep mode */
      INT32_C(2),    /** @brief TIM4 peripheral clock enable during csleep mode */
      INT32_C(3),    /** @brief TIM5 peripheral clock enable during csleep mode */
      INT32_C(4),    /** @brief TIM6 peripheral clock enable during csleep mode */
      INT32_C(5),    /** @brief TIM7 peripheral clock enable during csleep mode */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief TIM12 peripheral clock enable during csleep mode */
      INT32_C(7),    /** @brief TIM13 peripheral clock enable during csleep mode */
      INT32_C(8),    /** @brief TIM14 peripheral clock enable during csleep mode */
    };

    static const int32_t RCC_APB4LPENR_USARTXLPEN_POS[9] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(17),   /** @brief USART2 peripheral clocks enable during csleep mode */
      INT32_C(18),   /** @brief USART3 peripheral clocks enable during csleep mode */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief USART7 peripheral clocks enable during csleep mode */
      INT32_C(31),   /** @brief USART8 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB4LPENR_I2CXLPEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief I2C1 peripheral clocks enable during csleep mode */
      INT32_C(22),   /** @brief I2C2 peripheral clocks enable during csleep mode */
      INT32_C(23),   /** @brief I2C3 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB4LPENR_SPIXLPEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief SPI1 peripheral clocks enable during csleep mode */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(13),   /** @brief SPI4 peripheral clocks enable during csleep mode */
      INT32_C(20),   /** @brief SPI5 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB4LPENR_TIM1XLPEN_POS[8] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief TIM15 peripheral clock enable during csleep mode */
      INT32_C(17),   /** @brief TIM16 peripheral clock enable during csleep mode */
      INT32_C(18),   /** @brief TIM17 peripheral clock enable during csleep mode */
    };

    static const int32_t RCC_APB4LPENR_SAIXLPEN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief SAI1 peripheral clocks enable during csleep mode */
      INT32_C(23),   /** @brief SAI2 peripheral clocks enable during csleep mode */
      INT32_C(24),   /** @brief SAI3 peripheral clocks enable during csleep mode */
    };

    static const int32_t RCC_APB4LPENR_LPTIMXLPEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief LPTIM2 peripheral clocks enable during csleep mode */
      INT32_C(10),   /** @brief LPTIM3 peripheral clocks enable during csleep mode */
      INT32_C(11),   /** @brief LPTIM4 peripheral clocks enable during csleep mode */
      INT32_C(12),   /** @brief LPTIM5 peripheral clocks enable during csleep mode */
    };

    /** @subsection RCC field position definitions */

    static const int32_t RCC_APB4LPENR_HSION_POS = INT32_C(0);                        /** @brief Internal high-speed clock enable */
    static const int32_t RCC_APB4LPENR_HSIKERON_POS = INT32_C(1);                     /** @brief High speed internal clock enable in stop mode */
    static const int32_t RCC_APB4LPENR_HSIRDY_POS = INT32_C(2);                       /** @brief HSI clock ready flag */
    static const int32_t RCC_APB4LPENR_HSIDIV_POS = INT32_C(3);                       /** @brief HSI clock divider */
    static const int32_t RCC_APB4LPENR_HSIDIVF_POS = INT32_C(5);                      /** @brief HSI divider flag */
    static const int32_t RCC_APB4LPENR_CSION_POS = INT32_C(7);                        /** @brief CSI clock enable */
    static const int32_t RCC_APB4LPENR_CSIRDY_POS = INT32_C(8);                       /** @brief CSI clock ready flag */
    static const int32_t RCC_APB4LPENR_CSIKERON_POS = INT32_C(9);                     /** @brief CSI clock enable in stop mode */
    static const int32_t RCC_APB4LPENR_RC48ON_POS = INT32_C(12);                      /** @brief RC48 clock enable */
    static const int32_t RCC_APB4LPENR_RC48RDY_POS = INT32_C(13);                     /** @brief RC48 clock ready flag */
    static const int32_t RCC_APB4LPENR_D1CKRDY_POS = INT32_C(14);                     /** @brief D1 domain clocks ready flag */
    static const int32_t RCC_APB4LPENR_D2CKRDY_POS = INT32_C(15);                     /** @brief D2 domain clocks ready flag */
    static const int32_t RCC_APB4LPENR_HSEON_POS = INT32_C(16);                       /** @brief HSE clock enable */
    static const int32_t RCC_APB4LPENR_HSERDY_POS = INT32_C(17);                      /** @brief HSE clock ready flag */
    static const int32_t RCC_APB4LPENR_HSEBYP_POS = INT32_C(18);                      /** @brief HSE clock bypass */
    static const int32_t RCC_APB4LPENR_HSECSSON_POS = INT32_C(19);                    /** @brief HSE clock security system enable */
    static const int32_t RCC_APB4LPENR_HSICAL_POS = INT32_C(0);                       /** @brief HSI clock calibration */
    static const int32_t RCC_APB4LPENR_HSITRIM_POS = INT32_C(12);                     /** @brief HSI clock trimming */
    static const int32_t RCC_APB4LPENR_CSICAL_POS = INT32_C(18);                      /** @brief CSI clock calibration */
    static const int32_t RCC_APB4LPENR_CSITRIM_POS = INT32_C(26);                     /** @brief CSI clock trimming */
    static const int32_t RCC_APB4LPENR_RC48CAL_POS = INT32_C(0);                      /** @brief Internal RC 48 mhz clock calibration */
    static const int32_t RCC_APB4LPENR_SW_POS = INT32_C(0);                           /** @brief System clock switch */
    static const int32_t RCC_APB4LPENR_SWS_POS = INT32_C(3);                          /** @brief System clock switch status */
    static const int32_t RCC_APB4LPENR_STOPWUCK_POS = INT32_C(6);                     /** @brief System clock selection after a wake up from system stop */
    static const int32_t RCC_APB4LPENR_STOPKERWUCK_POS = INT32_C(7);                  /** @brief Kernel clock selection after a wake up from system stop */
    static const int32_t RCC_APB4LPENR_RTCPRE_POS = INT32_C(8);                       /** @brief HSE division factor for RTC clock */
    static const int32_t RCC_APB4LPENR_HRTIMSEL_POS = INT32_C(14);                    /** @brief High resolution timer clock prescaler selection */
    static const int32_t RCC_APB4LPENR_TIMPRE_POS = INT32_C(15);                      /** @brief Timers clocks prescaler selection */
    static const int32_t RCC_APB4LPENR_MCO1PRE_POS = INT32_C(18);                     /** @brief MCO1 prescaler */
    static const int32_t RCC_APB4LPENR_MCO1SEL_POS = INT32_C(22);                     /** @brief Micro-controller clock output 1 */
    static const int32_t RCC_APB4LPENR_MCO2PRE_POS = INT32_C(25);                     /** @brief MCO2 prescaler */
    static const int32_t RCC_APB4LPENR_MCO2SEL_POS = INT32_C(29);                     /** @brief Micro-controller clock output 2 */
    static const int32_t RCC_APB4LPENR_HPRE_POS = INT32_C(0);                         /** @brief D1 domain AHB prescaler */
    static const int32_t RCC_APB4LPENR_D1PPRE_POS = INT32_C(4);                       /** @brief D1 domain APB3 prescaler */
    static const int32_t RCC_APB4LPENR_D1CPRE_POS = INT32_C(8);                       /** @brief D1 domain core prescaler */
    static const int32_t RCC_APB4LPENR_D2PPRE1_POS = INT32_C(4);                      /** @brief D2 domain APB1 prescaler */
    static const int32_t RCC_APB4LPENR_D2PPRE2_POS = INT32_C(8);                      /** @brief D2 domain APB2 prescaler */
    static const int32_t RCC_APB4LPENR_D3PPRE_POS = INT32_C(4);                       /** @brief D3 domain APB4 prescaler */
    static const int32_t RCC_APB4LPENR_PLLSRC_POS = INT32_C(0);                       /** @brief DIVMx and plls clock source selection */
    static const int32_t RCC_APB4LPENR_DIVN1_POS = INT32_C(0);                        /** @brief Multiplication factor for PLL1 VCO */
    static const int32_t RCC_APB4LPENR_DIVP1_POS = INT32_C(9);                        /** @brief PLL1 DIVP division factor */
    static const int32_t RCC_APB4LPENR_DIVQ1_POS = INT32_C(16);                       /** @brief PLL1 DIVQ division factor */
    static const int32_t RCC_APB4LPENR_DIVR1_POS = INT32_C(24);                       /** @brief PLL1 DIVR division factor */
    static const int32_t RCC_APB4LPENR_FRACN1_POS = INT32_C(3);                       /** @brief Fractional part of the multiplication factor for PLL1 VCO */
    static const int32_t RCC_APB4LPENR_DIVN1_POS = INT32_C(0);                        /** @brief Multiplication factor for PLL1 VCO */
    static const int32_t RCC_APB4LPENR_DIVP1_POS = INT32_C(9);                        /** @brief PLL1 DIVP division factor */
    static const int32_t RCC_APB4LPENR_DIVQ1_POS = INT32_C(16);                       /** @brief PLL1 DIVQ division factor */
    static const int32_t RCC_APB4LPENR_DIVR1_POS = INT32_C(24);                       /** @brief PLL1 DIVR division factor */
    static const int32_t RCC_APB4LPENR_FRACN2_POS = INT32_C(3);                       /** @brief Fractional part of the multiplication factor for PLL VCO */
    static const int32_t RCC_APB4LPENR_DIVN3_POS = INT32_C(0);                        /** @brief Multiplication factor for PLL1 VCO */
    static const int32_t RCC_APB4LPENR_DIVP3_POS = INT32_C(9);                        /** @brief PLL DIVP division factor */
    static const int32_t RCC_APB4LPENR_DIVQ3_POS = INT32_C(16);                       /** @brief PLL DIVQ division factor */
    static const int32_t RCC_APB4LPENR_DIVR3_POS = INT32_C(24);                       /** @brief PLL DIVR division factor */
    static const int32_t RCC_APB4LPENR_FRACN3_POS = INT32_C(3);                       /** @brief Fractional part of the multiplication factor for PLL3 VCO */
    static const int32_t RCC_APB4LPENR_FMCSRC_POS = INT32_C(0);                       /** @brief FMC kernel clock source selection */
    static const int32_t RCC_APB4LPENR_QSPISRC_POS = INT32_C(4);                      /** @brief QUADSPI kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SDMMCSRC_POS = INT32_C(16);                    /** @brief SDMMC kernel clock source selection */
    static const int32_t RCC_APB4LPENR_CKPERSRC_POS = INT32_C(28);                    /** @brief Per_ck clock source selection */
    static const int32_t RCC_APB4LPENR_SAI1SRC_POS = INT32_C(0);                      /** @brief SAI1 and DFSDM1 kernel aclk clock source selection */
    static const int32_t RCC_APB4LPENR_SAI23SRC_POS = INT32_C(6);                     /** @brief SAI2 and SAI3 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SPI123SRC_POS = INT32_C(12);                   /** @brief SPI/I2S1,2 and 3 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SPI45SRC_POS = INT32_C(16);                    /** @brief SPI4 and 5 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SPDIFSRC_POS = INT32_C(20);                    /** @brief SPDIFRX kernel clock source selection */
    static const int32_t RCC_APB4LPENR_DFSDM1SRC_POS = INT32_C(24);                   /** @brief DFSDM1 kernel clk clock source selection */
    static const int32_t RCC_APB4LPENR_FDCANSRC_POS = INT32_C(28);                    /** @brief FDCAN kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SWPSRC_POS = INT32_C(31);                      /** @brief SWPMI kernel clock source selection */
    static const int32_t RCC_APB4LPENR_USART234578SRC_POS = INT32_C(0);               /** @brief USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection */
    static const int32_t RCC_APB4LPENR_USART16SRC_POS = INT32_C(3);                   /** @brief USART1 and 6 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_RNGSRC_POS = INT32_C(8);                       /** @brief RNG kernel clock source selection */
    static const int32_t RCC_APB4LPENR_I2C123SRC_POS = INT32_C(12);                   /** @brief I2C1,2,3 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_USBSRC_POS = INT32_C(20);                      /** @brief USBOTG 1 and 2 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_CECSRC_POS = INT32_C(22);                      /** @brief HDMI-CEC kernel clock source selection */
    static const int32_t RCC_APB4LPENR_LPTIM1SRC_POS = INT32_C(28);                   /** @brief LPTIM1 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_LPUART1SRC_POS = INT32_C(0);                   /** @brief LPUART1 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_I2C4SRC_POS = INT32_C(8);                      /** @brief I2C4 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_LPTIM2SRC_POS = INT32_C(10);                   /** @brief LPTIM2 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_LPTIM345SRC_POS = INT32_C(13);                 /** @brief LPTIM3,4,5 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_ADCSRC_POS = INT32_C(16);                      /** @brief SAR ADC kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SAI4ASRC_POS = INT32_C(21);                    /** @brief Sub-Block A of SAI4 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SAI4BSRC_POS = INT32_C(24);                    /** @brief Sub-Block B of SAI4 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_SPI6SRC_POS = INT32_C(28);                     /** @brief SPI6 kernel clock source selection */
    static const int32_t RCC_APB4LPENR_LSIRDYIE_POS = INT32_C(0);                     /** @brief LSI ready interrupt enable */
    static const int32_t RCC_APB4LPENR_LSERDYIE_POS = INT32_C(1);                     /** @brief LSE ready interrupt enable */
    static const int32_t RCC_APB4LPENR_HSIRDYIE_POS = INT32_C(2);                     /** @brief HSI ready interrupt enable */
    static const int32_t RCC_APB4LPENR_HSERDYIE_POS = INT32_C(3);                     /** @brief HSE ready interrupt enable */
    static const int32_t RCC_APB4LPENR_CSIRDYIE_POS = INT32_C(4);                     /** @brief CSI ready interrupt enable */
    static const int32_t RCC_APB4LPENR_RC48RDYIE_POS = INT32_C(5);                    /** @brief RC48 ready interrupt enable */
    static const int32_t RCC_APB4LPENR_LSECSSIE_POS = INT32_C(9);                     /** @brief LSE clock security system interrupt enable */
    static const int32_t RCC_APB4LPENR_LSIRDYF_POS = INT32_C(0);                      /** @brief LSI ready interrupt flag */
    static const int32_t RCC_APB4LPENR_LSERDYF_POS = INT32_C(1);                      /** @brief LSE ready interrupt flag */
    static const int32_t RCC_APB4LPENR_HSIRDYF_POS = INT32_C(2);                      /** @brief HSI ready interrupt flag */
    static const int32_t RCC_APB4LPENR_HSERDYF_POS = INT32_C(3);                      /** @brief HSE ready interrupt flag */
    static const int32_t RCC_APB4LPENR_CSIRDY_POS = INT32_C(4);                       /** @brief CSI ready interrupt flag */
    static const int32_t RCC_APB4LPENR_RC48RDYF_POS = INT32_C(5);                     /** @brief RC48 ready interrupt flag */
    static const int32_t RCC_APB4LPENR_LSECSSF_POS = INT32_C(9);                      /** @brief LSE clock security system interrupt flag */
    static const int32_t RCC_APB4LPENR_HSECSSF_POS = INT32_C(10);                     /** @brief HSE clock security system interrupt flag */
    static const int32_t RCC_APB4LPENR_LSIRDYC_POS = INT32_C(0);                      /** @brief LSI ready interrupt clear */
    static const int32_t RCC_APB4LPENR_LSERDYC_POS = INT32_C(1);                      /** @brief LSE ready interrupt clear */
    static const int32_t RCC_APB4LPENR_HSIRDYC_POS = INT32_C(2);                      /** @brief HSI ready interrupt clear */
    static const int32_t RCC_APB4LPENR_HSERDYC_POS = INT32_C(3);                      /** @brief HSE ready interrupt clear */
    static const int32_t RCC_APB4LPENR_HSE_READY_INTERRUPT_CLEAR_POS = INT32_C(4);    /** @brief CSI ready interrupt clear */
    static const int32_t RCC_APB4LPENR_RC48RDYC_POS = INT32_C(5);                     /** @brief RC48 ready interrupt clear */
    static const int32_t RCC_APB4LPENR_LSECSSC_POS = INT32_C(9);                      /** @brief LSE clock security system interrupt clear */
    static const int32_t RCC_APB4LPENR_HSECSSC_POS = INT32_C(10);                     /** @brief HSE clock security system interrupt clear */
    static const int32_t RCC_APB4LPENR_LSEON_POS = INT32_C(0);                        /** @brief LSE oscillator enabled */
    static const int32_t RCC_APB4LPENR_LSERDY_POS = INT32_C(1);                       /** @brief LSE oscillator ready */
    static const int32_t RCC_APB4LPENR_LSEBYP_POS = INT32_C(2);                       /** @brief LSE oscillator bypass */
    static const int32_t RCC_APB4LPENR_LSEDRV_POS = INT32_C(3);                       /** @brief LSE oscillator driving capability */
    static const int32_t RCC_APB4LPENR_LSECSSON_POS = INT32_C(5);                     /** @brief LSE clock security system enable */
    static const int32_t RCC_APB4LPENR_LSECSSD_POS = INT32_C(6);                      /** @brief LSE clock security system failure detection */
    static const int32_t RCC_APB4LPENR_RTCSRC_POS = INT32_C(8);                       /** @brief RTC clock source selection */
    static const int32_t RCC_APB4LPENR_RTCEN_POS = INT32_C(15);                       /** @brief RTC clock enable */
    static const int32_t RCC_APB4LPENR_VSWRST_POS = INT32_C(16);                      /** @brief VSwitch domain software reset */
    static const int32_t RCC_APB4LPENR_LSION_POS = INT32_C(0);                        /** @brief LSI oscillator enable */
    static const int32_t RCC_APB4LPENR_LSIRDY_POS = INT32_C(1);                       /** @brief LSI oscillator ready */
    static const int32_t RCC_APB4LPENR_MDMARST_POS = INT32_C(0);                      /** @brief MDMA block reset */
    static const int32_t RCC_APB4LPENR_DMA2DRST_POS = INT32_C(4);                     /** @brief DMA2D block reset */
    static const int32_t RCC_APB4LPENR_JPGDECRST_POS = INT32_C(5);                    /** @brief JPGDEC block reset */
    static const int32_t RCC_APB4LPENR_FMCRST_POS = INT32_C(12);                      /** @brief FMC block reset */
    static const int32_t RCC_APB4LPENR_QSPIRST_POS = INT32_C(14);                     /** @brief QUADSPI and QUADSPI delay block reset */
    static const int32_t RCC_APB4LPENR_SDMMC1RST_POS = INT32_C(16);                   /** @brief SDMMC1 and SDMMC1 delay block reset */
    static const int32_t RCC_APB4LPENR_CPURST_POS = INT32_C(31);                      /** @brief CPU reset */
    static const int32_t RCC_APB4LPENR_DMA1RST_POS = INT32_C(0);                      /** @brief DMA1 block reset */
    static const int32_t RCC_APB4LPENR_DMA2RST_POS = INT32_C(1);                      /** @brief DMA2 block reset */
    static const int32_t RCC_APB4LPENR_ADC12RST_POS = INT32_C(5);                     /** @brief ADC1&2 block reset */
    static const int32_t RCC_APB4LPENR_ETH1MACRST_POS = INT32_C(15);                  /** @brief ETH1MAC block reset */
    static const int32_t RCC_APB4LPENR_USB1OTGRST_POS = INT32_C(25);                  /** @brief USB1OTG block reset */
    static const int32_t RCC_APB4LPENR_USB2OTGRST_POS = INT32_C(27);                  /** @brief USB2OTG block reset */
    static const int32_t RCC_APB4LPENR_CAMITFRST_POS = INT32_C(0);                    /** @brief CAMITF block reset */
    static const int32_t RCC_APB4LPENR_CRYPTRST_POS = INT32_C(4);                     /** @brief Cryptography block reset */
    static const int32_t RCC_APB4LPENR_HASHRST_POS = INT32_C(5);                      /** @brief Hash block reset */
    static const int32_t RCC_APB4LPENR_RNGRST_POS = INT32_C(6);                       /** @brief Random number generator block reset */
    static const int32_t RCC_APB4LPENR_SDMMC2RST_POS = INT32_C(9);                    /** @brief SDMMC2 and SDMMC2 delay block reset */
    static const int32_t RCC_APB4LPENR_GPIOARST_POS = INT32_C(0);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOBRST_POS = INT32_C(1);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOCRST_POS = INT32_C(2);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIODRST_POS = INT32_C(3);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOERST_POS = INT32_C(4);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOFRST_POS = INT32_C(5);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOGRST_POS = INT32_C(6);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOHRST_POS = INT32_C(7);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOIRST_POS = INT32_C(8);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOJRST_POS = INT32_C(9);                     /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_GPIOKRST_POS = INT32_C(10);                    /** @brief GPIO block reset */
    static const int32_t RCC_APB4LPENR_CRCRST_POS = INT32_C(19);                      /** @brief CRC block reset */
    static const int32_t RCC_APB4LPENR_BDMARST_POS = INT32_C(21);                     /** @brief BDMA block reset */
    static const int32_t RCC_APB4LPENR_ADC3RST_POS = INT32_C(24);                     /** @brief ADC3 block reset */
    static const int32_t RCC_APB4LPENR_HSEMRST_POS = INT32_C(25);                     /** @brief HSEM block reset */
    static const int32_t RCC_APB4LPENR_LTDCRST_POS = INT32_C(3);                      /** @brief LTDC block reset */
    static const int32_t RCC_APB4LPENR_LPTIM1RST_POS = INT32_C(9);                    /** @brief TIM block reset */
    static const int32_t RCC_APB4LPENR_SPI2RST_POS = INT32_C(14);                     /** @brief SPI2 block reset */
    static const int32_t RCC_APB4LPENR_SPI3RST_POS = INT32_C(15);                     /** @brief SPI3 block reset */
    static const int32_t RCC_APB4LPENR_SPDIFRXRST_POS = INT32_C(16);                  /** @brief SPDIFRX block reset */
    static const int32_t RCC_APB4LPENR_UART4RST_POS = INT32_C(19);                    /** @brief UART4 block reset */
    static const int32_t RCC_APB4LPENR_UART5RST_POS = INT32_C(20);                    /** @brief UART5 block reset */
    static const int32_t RCC_APB4LPENR_HDMICECRST_POS = INT32_C(27);                  /** @brief HDMI-CEC block reset */
    static const int32_t RCC_APB4LPENR_DAC12RST_POS = INT32_C(29);                    /** @brief DAC1 and 2 blocks reset */
    static const int32_t RCC_APB4LPENR_CRSRST_POS = INT32_C(1);                       /** @brief Clock recovery system reset */
    static const int32_t RCC_APB4LPENR_SWPRST_POS = INT32_C(2);                       /** @brief SWPMI block reset */
    static const int32_t RCC_APB4LPENR_OPAMPRST_POS = INT32_C(4);                     /** @brief OPAMP block reset */
    static const int32_t RCC_APB4LPENR_MDIOSRST_POS = INT32_C(5);                     /** @brief MDIOS block reset */
    static const int32_t RCC_APB4LPENR_FDCANRST_POS = INT32_C(8);                     /** @brief FDCAN block reset */
    static const int32_t RCC_APB4LPENR_TIM1RST_POS = INT32_C(0);                      /** @brief TIM1 block reset */
    static const int32_t RCC_APB4LPENR_TIM8RST_POS = INT32_C(1);                      /** @brief TIM8 block reset */
    static const int32_t RCC_APB4LPENR_USART1RST_POS = INT32_C(4);                    /** @brief USART1 block reset */
    static const int32_t RCC_APB4LPENR_USART6RST_POS = INT32_C(5);                    /** @brief USART6 block reset */
    static const int32_t RCC_APB4LPENR_DFSDM1RST_POS = INT32_C(28);                   /** @brief DFSDM1 block reset */
    static const int32_t RCC_APB4LPENR_HRTIMRST_POS = INT32_C(29);                    /** @brief HRTIM block reset */
    static const int32_t RCC_APB4LPENR_SYSCFGRST_POS = INT32_C(1);                    /** @brief SYSCFG block reset */
    static const int32_t RCC_APB4LPENR_LPUART1RST_POS = INT32_C(3);                   /** @brief LPUART1 block reset */
    static const int32_t RCC_APB4LPENR_SPI6RST_POS = INT32_C(5);                      /** @brief SPI6 block reset */
    static const int32_t RCC_APB4LPENR_I2C4RST_POS = INT32_C(7);                      /** @brief I2C4 block reset */
    static const int32_t RCC_APB4LPENR_COMP12RST_POS = INT32_C(14);                   /** @brief COMP12 blocks reset */
    static const int32_t RCC_APB4LPENR_VREFRST_POS = INT32_C(15);                     /** @brief VREF block reset */
    static const int32_t RCC_APB4LPENR_SAI4RST_POS = INT32_C(21);                     /** @brief SAI4 block reset */
    static const int32_t RCC_APB4LPENR_WW1RSC_POS = INT32_C(0);                       /** @brief WWDG1 reset scope control */
    static const int32_t RCC_APB4LPENR_BDMAAMEN_POS = INT32_C(0);                     /** @brief BDMA and DMAMUX autonomous mode enable */
    static const int32_t RCC_APB4LPENR_LPUART1AMEN_POS = INT32_C(3);                  /** @brief LPUART1 autonomous mode enable */
    static const int32_t RCC_APB4LPENR_SPI6AMEN_POS = INT32_C(5);                     /** @brief SPI6 autonomous mode enable */
    static const int32_t RCC_APB4LPENR_I2C4AMEN_POS = INT32_C(7);                     /** @brief I2C4 autonomous mode enable */
    static const int32_t RCC_APB4LPENR_COMP12AMEN_POS = INT32_C(14);                  /** @brief COMP12 autonomous mode enable */
    static const int32_t RCC_APB4LPENR_VREFAMEN_POS = INT32_C(15);                    /** @brief VREF autonomous mode enable */
    static const int32_t RCC_APB4LPENR_RTCAMEN_POS = INT32_C(16);                     /** @brief RTC autonomous mode enable */
    static const int32_t RCC_APB4LPENR_CRCAMEN_POS = INT32_C(19);                     /** @brief CRC autonomous mode enable */
    static const int32_t RCC_APB4LPENR_SAI4AMEN_POS = INT32_C(21);                    /** @brief SAI4 autonomous mode enable */
    static const int32_t RCC_APB4LPENR_ADC3AMEN_POS = INT32_C(24);                    /** @brief ADC3 autonomous mode enable */
    static const int32_t RCC_APB4LPENR_BKPSRAMAMEN_POS = INT32_C(28);                 /** @brief Backup RAM autonomous mode enable */
    static const int32_t RCC_APB4LPENR_SRAM4AMEN_POS = INT32_C(29);                   /** @brief SRAM4 autonomous mode enable */
    static const int32_t RCC_APB4LPENR_RMVF_POS = INT32_C(16);                        /** @brief Remove reset flag */
    static const int32_t RCC_APB4LPENR_CPURSTF_POS = INT32_C(17);                     /** @brief CPU reset flag */
    static const int32_t RCC_APB4LPENR_D1RSTF_POS = INT32_C(19);                      /** @brief D1 domain power switch reset flag */
    static const int32_t RCC_APB4LPENR_D2RSTF_POS = INT32_C(20);                      /** @brief D2 domain power switch reset flag */
    static const int32_t RCC_APB4LPENR_BORRSTF_POS = INT32_C(21);                     /** @brief BOR reset flag */
    static const int32_t RCC_APB4LPENR_PINRSTF_POS = INT32_C(22);                     /** @brief Pin reset flag (NRST) */
    static const int32_t RCC_APB4LPENR_PORRSTF_POS = INT32_C(23);                     /** @brief POR/PDR reset flag */
    static const int32_t RCC_APB4LPENR_SFTRSTF_POS = INT32_C(24);                     /** @brief System reset from CPU reset flag */
    static const int32_t RCC_APB4LPENR_IWDG1RSTF_POS = INT32_C(26);                   /** @brief Independent watchdog reset flag */
    static const int32_t RCC_APB4LPENR_WWDG1RSTF_POS = INT32_C(28);                   /** @brief Window watchdog reset flag */
    static const int32_t RCC_APB4LPENR_LPWRRSTF_POS = INT32_C(30);                    /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const int32_t RCC_APB4LPENR_RMVF_POS = INT32_C(16);                        /** @brief Remove reset flag */
    static const int32_t RCC_APB4LPENR_CPURSTF_POS = INT32_C(17);                     /** @brief CPU reset flag */
    static const int32_t RCC_APB4LPENR_D1RSTF_POS = INT32_C(19);                      /** @brief D1 domain power switch reset flag */
    static const int32_t RCC_APB4LPENR_D2RSTF_POS = INT32_C(20);                      /** @brief D2 domain power switch reset flag */
    static const int32_t RCC_APB4LPENR_BORRSTF_POS = INT32_C(21);                     /** @brief BOR reset flag */
    static const int32_t RCC_APB4LPENR_PINRSTF_POS = INT32_C(22);                     /** @brief Pin reset flag (NRST) */
    static const int32_t RCC_APB4LPENR_PORRSTF_POS = INT32_C(23);                     /** @brief POR/PDR reset flag */
    static const int32_t RCC_APB4LPENR_SFTRSTF_POS = INT32_C(24);                     /** @brief System reset from CPU reset flag */
    static const int32_t RCC_APB4LPENR_IWDG1RSTF_POS = INT32_C(26);                   /** @brief Independent watchdog reset flag */
    static const int32_t RCC_APB4LPENR_WWDG1RSTF_POS = INT32_C(28);                   /** @brief Window watchdog reset flag */
    static const int32_t RCC_APB4LPENR_LPWRRSTF_POS = INT32_C(30);                    /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const int32_t RCC_APB4LPENR_MDMAEN_POS = INT32_C(0);                       /** @brief MDMA peripheral clock enable */
    static const int32_t RCC_APB4LPENR_DMA2DEN_POS = INT32_C(4);                      /** @brief DMA2D peripheral clock enable */
    static const int32_t RCC_APB4LPENR_JPGDECEN_POS = INT32_C(5);                     /** @brief JPGDEC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_FMCEN_POS = INT32_C(12);                       /** @brief FMC peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_QSPIEN_POS = INT32_C(14);                      /** @brief QUADSPI and QUADSPI delay clock enable */
    static const int32_t RCC_APB4LPENR_SDMMC1EN_POS = INT32_C(16);                    /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const int32_t RCC_APB4LPENR_MDMAEN_POS = INT32_C(0);                       /** @brief MDMA peripheral clock enable */
    static const int32_t RCC_APB4LPENR_DMA2DEN_POS = INT32_C(4);                      /** @brief DMA2D peripheral clock enable */
    static const int32_t RCC_APB4LPENR_JPGDECEN_POS = INT32_C(5);                     /** @brief JPGDEC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_FMCEN_POS = INT32_C(12);                       /** @brief FMC peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_QSPIEN_POS = INT32_C(14);                      /** @brief QUADSPI and QUADSPI delay clock enable */
    static const int32_t RCC_APB4LPENR_SDMMC1EN_POS = INT32_C(16);                    /** @brief SDMMC1 and SDMMC1 delay clock enable */
    static const int32_t RCC_APB4LPENR_DMA1EN_POS = INT32_C(0);                       /** @brief DMA1 clock enable */
    static const int32_t RCC_APB4LPENR_DMA2EN_POS = INT32_C(1);                       /** @brief DMA2 clock enable */
    static const int32_t RCC_APB4LPENR_ADC12EN_POS = INT32_C(5);                      /** @brief ADC1/2 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_ETH1MACEN_POS = INT32_C(15);                   /** @brief Ethernet MAC bus interface clock enable */
    static const int32_t RCC_APB4LPENR_ETH1TXEN_POS = INT32_C(16);                    /** @brief Ethernet transmission clock enable */
    static const int32_t RCC_APB4LPENR_ETH1RXEN_POS = INT32_C(17);                    /** @brief Ethernet reception clock enable */
    static const int32_t RCC_APB4LPENR_USB1OTGEN_POS = INT32_C(25);                   /** @brief USB1OTG peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_USB1ULPIEN_POS = INT32_C(26);                  /** @brief USB_PHY1 clocks enable */
    static const int32_t RCC_APB4LPENR_USB2OTGEN_POS = INT32_C(27);                   /** @brief USB2OTG peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_USB2ULPIEN_POS = INT32_C(28);                  /** @brief USB_PHY2 clocks enable */
    static const int32_t RCC_APB4LPENR_DMA1EN_POS = INT32_C(0);                       /** @brief DMA1 clock enable */
    static const int32_t RCC_APB4LPENR_DMA2EN_POS = INT32_C(1);                       /** @brief DMA2 clock enable */
    static const int32_t RCC_APB4LPENR_ADC12EN_POS = INT32_C(5);                      /** @brief ADC1/2 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_ETH1MACEN_POS = INT32_C(15);                   /** @brief Ethernet MAC bus interface clock enable */
    static const int32_t RCC_APB4LPENR_ETH1TXEN_POS = INT32_C(16);                    /** @brief Ethernet transmission clock enable */
    static const int32_t RCC_APB4LPENR_ETH1RXEN_POS = INT32_C(17);                    /** @brief Ethernet reception clock enable */
    static const int32_t RCC_APB4LPENR_USB1OTGEN_POS = INT32_C(25);                   /** @brief USB1OTG peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_USB1ULPIEN_POS = INT32_C(26);                  /** @brief USB_PHY1 clocks enable */
    static const int32_t RCC_APB4LPENR_USB2OTGEN_POS = INT32_C(27);                   /** @brief USB2OTG peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_USB2ULPIEN_POS = INT32_C(28);                  /** @brief USB_PHY2 clocks enable */
    static const int32_t RCC_APB4LPENR_CAMITFEN_POS = INT32_C(0);                     /** @brief CAMITF peripheral clock enable */
    static const int32_t RCC_APB4LPENR_CRYPTEN_POS = INT32_C(4);                      /** @brief CRYPT peripheral clock enable */
    static const int32_t RCC_APB4LPENR_HASHEN_POS = INT32_C(5);                       /** @brief HASH peripheral clock enable */
    static const int32_t RCC_APB4LPENR_RNGEN_POS = INT32_C(6);                        /** @brief RNG peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SDMMC2EN_POS = INT32_C(9);                     /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const int32_t RCC_APB4LPENR_CAMITFEN_POS = INT32_C(0);                     /** @brief CAMITF peripheral clock enable */
    static const int32_t RCC_APB4LPENR_CRYPTEN_POS = INT32_C(4);                      /** @brief CRYPT peripheral clock enable */
    static const int32_t RCC_APB4LPENR_HASHEN_POS = INT32_C(5);                       /** @brief HASH peripheral clock enable */
    static const int32_t RCC_APB4LPENR_RNGEN_POS = INT32_C(6);                        /** @brief RNG peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SDMMC2EN_POS = INT32_C(9);                     /** @brief SDMMC2 and SDMMC2 delay clock enable */
    static const int32_t RCC_APB4LPENR_GPIOAEN_POS = INT32_C(0);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOBEN_POS = INT32_C(1);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOCEN_POS = INT32_C(2);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIODEN_POS = INT32_C(3);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOEEN_POS = INT32_C(4);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOFEN_POS = INT32_C(5);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOGEN_POS = INT32_C(6);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOHEN_POS = INT32_C(7);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOIEN_POS = INT32_C(8);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOJEN_POS = INT32_C(9);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOKEN_POS = INT32_C(10);                     /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_CRCEN_POS = INT32_C(19);                       /** @brief CRC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_BDMAEN_POS = INT32_C(21);                      /** @brief BDMA and DMAMUX2 clock enable */
    static const int32_t RCC_APB4LPENR_ADC3EN_POS = INT32_C(24);                      /** @brief ADC3 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_HSEMEN_POS = INT32_C(25);                      /** @brief HSEM peripheral clock enable */
    static const int32_t RCC_APB4LPENR_BKPRAMEN_POS = INT32_C(28);                    /** @brief Backup RAM clock enable */
    static const int32_t RCC_APB4LPENR_GPIOAEN_POS = INT32_C(0);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOBEN_POS = INT32_C(1);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOCEN_POS = INT32_C(2);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIODEN_POS = INT32_C(3);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOEEN_POS = INT32_C(4);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOFEN_POS = INT32_C(5);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOGEN_POS = INT32_C(6);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOHEN_POS = INT32_C(7);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOIEN_POS = INT32_C(8);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOJEN_POS = INT32_C(9);                      /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_GPIOKEN_POS = INT32_C(10);                     /** @brief 0GPIO peripheral clock enable */
    static const int32_t RCC_APB4LPENR_CRCEN_POS = INT32_C(19);                       /** @brief CRC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_BDMAEN_POS = INT32_C(21);                      /** @brief BDMA and DMAMUX2 clock enable */
    static const int32_t RCC_APB4LPENR_ADC3EN_POS = INT32_C(24);                      /** @brief ADC3 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_HSEMEN_POS = INT32_C(25);                      /** @brief HSEM peripheral clock enable */
    static const int32_t RCC_APB4LPENR_BKPRAMEN_POS = INT32_C(28);                    /** @brief Backup RAM clock enable */
    static const int32_t RCC_APB4LPENR_LTDCEN_POS = INT32_C(3);                       /** @brief LTDC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_WWDG1EN_POS = INT32_C(6);                      /** @brief WWDG1 clock enable */
    static const int32_t RCC_APB4LPENR_LTDCEN_POS = INT32_C(3);                       /** @brief LTDC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_WWDG1EN_POS = INT32_C(6);                      /** @brief WWDG1 clock enable */
    static const int32_t RCC_APB4LPENR_LPTIM1EN_POS = INT32_C(9);                     /** @brief LPTIM1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPI2EN_POS = INT32_C(14);                      /** @brief SPI2 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPI3EN_POS = INT32_C(15);                      /** @brief SPI3 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPDIFRXEN_POS = INT32_C(16);                   /** @brief SPDIFRX peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_UART4EN_POS = INT32_C(19);                     /** @brief UART4 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_UART5EN_POS = INT32_C(20);                     /** @brief UART5 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_HDMICECEN_POS = INT32_C(27);                   /** @brief HDMI-CEC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_DAC12EN_POS = INT32_C(29);                     /** @brief DAC1&2 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_LPTIM1EN_POS = INT32_C(9);                     /** @brief LPTIM1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPI2EN_POS = INT32_C(14);                      /** @brief SPI2 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPI3EN_POS = INT32_C(15);                      /** @brief SPI3 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPDIFRXEN_POS = INT32_C(16);                   /** @brief SPDIFRX peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_UART4EN_POS = INT32_C(19);                     /** @brief UART4 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_UART5EN_POS = INT32_C(20);                     /** @brief UART5 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_HDMICECEN_POS = INT32_C(27);                   /** @brief HDMI-CEC peripheral clock enable */
    static const int32_t RCC_APB4LPENR_DAC12EN_POS = INT32_C(29);                     /** @brief DAC1&2 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_CRSEN_POS = INT32_C(1);                        /** @brief Clock recovery system peripheral clock enable */
    static const int32_t RCC_APB4LPENR_SWPEN_POS = INT32_C(2);                        /** @brief SWPMI peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_OPAMPEN_POS = INT32_C(4);                      /** @brief OPAMP peripheral clock enable */
    static const int32_t RCC_APB4LPENR_MDIOSEN_POS = INT32_C(5);                      /** @brief MDIOS peripheral clock enable */
    static const int32_t RCC_APB4LPENR_FDCANEN_POS = INT32_C(8);                      /** @brief FDCAN peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_CRSEN_POS = INT32_C(1);                        /** @brief Clock recovery system peripheral clock enable */
    static const int32_t RCC_APB4LPENR_SWPEN_POS = INT32_C(2);                        /** @brief SWPMI peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_OPAMPEN_POS = INT32_C(4);                      /** @brief OPAMP peripheral clock enable */
    static const int32_t RCC_APB4LPENR_MDIOSEN_POS = INT32_C(5);                      /** @brief MDIOS peripheral clock enable */
    static const int32_t RCC_APB4LPENR_FDCANEN_POS = INT32_C(8);                      /** @brief FDCAN peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_TIM1EN_POS = INT32_C(0);                       /** @brief TIM1 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_TIM8EN_POS = INT32_C(1);                       /** @brief TIM8 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_USART1EN_POS = INT32_C(4);                     /** @brief USART1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_USART6EN_POS = INT32_C(5);                     /** @brief USART6 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_DFSDM1EN_POS = INT32_C(28);                    /** @brief DFSDM1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_HRTIMEN_POS = INT32_C(29);                     /** @brief HRTIM peripheral clock enable */
    static const int32_t RCC_APB4LPENR_TIM1EN_POS = INT32_C(0);                       /** @brief TIM1 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_TIM8EN_POS = INT32_C(1);                       /** @brief TIM8 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_USART1EN_POS = INT32_C(4);                     /** @brief USART1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_USART6EN_POS = INT32_C(5);                     /** @brief USART6 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_DFSDM1EN_POS = INT32_C(28);                    /** @brief DFSDM1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_HRTIMEN_POS = INT32_C(29);                     /** @brief HRTIM peripheral clock enable */
    static const int32_t RCC_APB4LPENR_SYSCFGEN_POS = INT32_C(1);                     /** @brief SYSCFG peripheral clock enable */
    static const int32_t RCC_APB4LPENR_LPUART1EN_POS = INT32_C(3);                    /** @brief LPUART1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPI6EN_POS = INT32_C(5);                       /** @brief SPI6 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_I2C4EN_POS = INT32_C(7);                       /** @brief I2C4 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_COMP12EN_POS = INT32_C(14);                    /** @brief COMP1/2 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_VREFEN_POS = INT32_C(15);                      /** @brief VREF peripheral clock enable */
    static const int32_t RCC_APB4LPENR_RTCAPBEN_POS = INT32_C(16);                    /** @brief RTC APB clock enable */
    static const int32_t RCC_APB4LPENR_SAI4EN_POS = INT32_C(21);                      /** @brief SAI4 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SYSCFGEN_POS = INT32_C(1);                     /** @brief SYSCFG peripheral clock enable */
    static const int32_t RCC_APB4LPENR_LPUART1EN_POS = INT32_C(3);                    /** @brief LPUART1 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_SPI6EN_POS = INT32_C(5);                       /** @brief SPI6 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_I2C4EN_POS = INT32_C(7);                       /** @brief I2C4 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_COMP12EN_POS = INT32_C(14);                    /** @brief COMP1/2 peripheral clock enable */
    static const int32_t RCC_APB4LPENR_VREFEN_POS = INT32_C(15);                      /** @brief VREF peripheral clock enable */
    static const int32_t RCC_APB4LPENR_RTCAPBEN_POS = INT32_C(16);                    /** @brief RTC APB clock enable */
    static const int32_t RCC_APB4LPENR_SAI4EN_POS = INT32_C(21);                      /** @brief SAI4 peripheral clocks enable */
    static const int32_t RCC_APB4LPENR_MDMALPEN_POS = INT32_C(0);                     /** @brief MDMA clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DMA2DLPEN_POS = INT32_C(4);                    /** @brief DMA2D clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_JPGDECLPEN_POS = INT32_C(5);                   /** @brief JPGDEC clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_FLITFLPEN_POS = INT32_C(8);                    /** @brief FLITF clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_FMCLPEN_POS = INT32_C(12);                     /** @brief FMC peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_QSPILPEN_POS = INT32_C(14);                    /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SDMMC1LPEN_POS = INT32_C(16);                  /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_D1DTCM1LPEN_POS = INT32_C(28);                 /** @brief D1DTCM1 block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DTCM2LPEN_POS = INT32_C(29);                   /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ITCMLPEN_POS = INT32_C(30);                    /** @brief D1ITCM block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_AXISRAMLPEN_POS = INT32_C(31);                 /** @brief AXISRAM block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_MDMALPEN_POS = INT32_C(0);                     /** @brief MDMA clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DMA2DLPEN_POS = INT32_C(4);                    /** @brief DMA2D clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_JPGDECLPEN_POS = INT32_C(5);                   /** @brief JPGDEC clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_FLITFLPEN_POS = INT32_C(8);                    /** @brief FLITF clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_FMCLPEN_POS = INT32_C(12);                     /** @brief FMC peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_QSPILPEN_POS = INT32_C(14);                    /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SDMMC1LPEN_POS = INT32_C(16);                  /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_D1DTCM1LPEN_POS = INT32_C(28);                 /** @brief D1DTCM1 block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DTCM2LPEN_POS = INT32_C(29);                   /** @brief D1 DTCM2 block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ITCMLPEN_POS = INT32_C(30);                    /** @brief D1ITCM block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_AXISRAMLPEN_POS = INT32_C(31);                 /** @brief AXISRAM block clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DMA1LPEN_POS = INT32_C(0);                     /** @brief DMA1 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DMA2LPEN_POS = INT32_C(1);                     /** @brief DMA2 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ADC12LPEN_POS = INT32_C(5);                    /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ETH1MACLPEN_POS = INT32_C(15);                 /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ETH1TXLPEN_POS = INT32_C(16);                  /** @brief Ethernet transmission clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ETH1RXLPEN_POS = INT32_C(17);                  /** @brief Ethernet reception clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB1OTGLPEN_POS = INT32_C(25);                 /** @brief USB1OTG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB1ULPILPEN_POS = INT32_C(26);                /** @brief USB_PHY1 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB2OTGLPEN_POS = INT32_C(27);                 /** @brief USB2OTG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB2ULPILPEN_POS = INT32_C(28);                /** @brief USB_PHY2 clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DMA1LPEN_POS = INT32_C(0);                     /** @brief DMA1 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DMA2LPEN_POS = INT32_C(1);                     /** @brief DMA2 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ADC12LPEN_POS = INT32_C(5);                    /** @brief ADC1/2 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ETH1MACLPEN_POS = INT32_C(15);                 /** @brief Ethernet MAC bus interface clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ETH1TXLPEN_POS = INT32_C(16);                  /** @brief Ethernet transmission clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ETH1RXLPEN_POS = INT32_C(17);                  /** @brief Ethernet reception clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB1OTGLPEN_POS = INT32_C(25);                 /** @brief USB1OTG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB1ULPILPEN_POS = INT32_C(26);                /** @brief USB_PHY1 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB2OTGLPEN_POS = INT32_C(27);                 /** @brief USB2OTG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USB2ULPILPEN_POS = INT32_C(28);                /** @brief USB_PHY2 clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CAMITFLPEN_POS = INT32_C(0);                   /** @brief CAMITF peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CRYPTLPEN_POS = INT32_C(4);                    /** @brief CRYPT peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_HASHLPEN_POS = INT32_C(5);                     /** @brief HASH peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SDMMC2LPEN_POS = INT32_C(9);                   /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_RNGLPEN_POS = INT32_C(6);                      /** @brief RNG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CAMITFLPEN_POS = INT32_C(0);                   /** @brief CAMITF peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CRYPTLPEN_POS = INT32_C(4);                    /** @brief CRYPT peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_HASHLPEN_POS = INT32_C(5);                     /** @brief HASH peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SDMMC2LPEN_POS = INT32_C(9);                   /** @brief SDMMC2 and SDMMC2 delay clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_RNGLPEN_POS = INT32_C(6);                      /** @brief RNG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOALPEN_POS = INT32_C(0);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOBLPEN_POS = INT32_C(1);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOCLPEN_POS = INT32_C(2);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIODLPEN_POS = INT32_C(3);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOELPEN_POS = INT32_C(4);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOFLPEN_POS = INT32_C(5);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOGLPEN_POS = INT32_C(6);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOHLPEN_POS = INT32_C(7);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOILPEN_POS = INT32_C(8);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOJLPEN_POS = INT32_C(9);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOKLPEN_POS = INT32_C(10);                   /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CRCLPEN_POS = INT32_C(19);                     /** @brief CRC peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_BDMALPEN_POS = INT32_C(21);                    /** @brief BDMA clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ADC3LPEN_POS = INT32_C(24);                    /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_BKPRAMLPEN_POS = INT32_C(28);                  /** @brief Backup RAM clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SRAM4LPEN_POS = INT32_C(29);                   /** @brief SRAM4 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOALPEN_POS = INT32_C(0);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOBLPEN_POS = INT32_C(1);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOCLPEN_POS = INT32_C(2);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIODLPEN_POS = INT32_C(3);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOELPEN_POS = INT32_C(4);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOFLPEN_POS = INT32_C(5);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOGLPEN_POS = INT32_C(6);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOHLPEN_POS = INT32_C(7);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOILPEN_POS = INT32_C(8);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOJLPEN_POS = INT32_C(9);                    /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_GPIOKLPEN_POS = INT32_C(10);                   /** @brief GPIO peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CRCLPEN_POS = INT32_C(19);                     /** @brief CRC peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_BDMALPEN_POS = INT32_C(21);                    /** @brief BDMA clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_ADC3LPEN_POS = INT32_C(24);                    /** @brief ADC3 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_BKPRAMLPEN_POS = INT32_C(28);                  /** @brief Backup RAM clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SRAM4LPEN_POS = INT32_C(29);                   /** @brief SRAM4 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_LTDCLPEN_POS = INT32_C(3);                     /** @brief LTDC peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_WWDG1LPEN_POS = INT32_C(6);                    /** @brief WWDG1 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_LTDCLPEN_POS = INT32_C(3);                     /** @brief LTDC peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_WWDG1LPEN_POS = INT32_C(6);                    /** @brief WWDG1 clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_LPTIM1LPEN_POS = INT32_C(9);                   /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPI2LPEN_POS = INT32_C(14);                    /** @brief SPI2 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPI3LPEN_POS = INT32_C(15);                    /** @brief SPI3 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPDIFRXLPEN_POS = INT32_C(16);                 /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_UART4LPEN_POS = INT32_C(19);                   /** @brief UART4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_UART5LPEN_POS = INT32_C(20);                   /** @brief UART5 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_HDMICECLPEN_POS = INT32_C(27);                 /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DAC12LPEN_POS = INT32_C(29);                   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_LPTIM1LPEN_POS = INT32_C(9);                   /** @brief LPTIM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPI2LPEN_POS = INT32_C(14);                    /** @brief SPI2 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPI3LPEN_POS = INT32_C(15);                    /** @brief SPI3 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPDIFRXLPEN_POS = INT32_C(16);                 /** @brief SPDIFRX peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_UART4LPEN_POS = INT32_C(19);                   /** @brief UART4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_UART5LPEN_POS = INT32_C(20);                   /** @brief UART5 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_HDMICECLPEN_POS = INT32_C(27);                 /** @brief HDMI-CEC peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DAC12LPEN_POS = INT32_C(29);                   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CRSLPEN_POS = INT32_C(1);                      /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SWPLPEN_POS = INT32_C(2);                      /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_OPAMPLPEN_POS = INT32_C(4);                    /** @brief OPAMP peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_MDIOSLPEN_POS = INT32_C(5);                    /** @brief MDIOS peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_FDCANLPEN_POS = INT32_C(8);                    /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_CRSLPEN_POS = INT32_C(1);                      /** @brief Clock recovery system peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SWPLPEN_POS = INT32_C(2);                      /** @brief SWPMI peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_OPAMPLPEN_POS = INT32_C(4);                    /** @brief OPAMP peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_MDIOSLPEN_POS = INT32_C(5);                    /** @brief MDIOS peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_FDCANLPEN_POS = INT32_C(8);                    /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_TIM1LPEN_POS = INT32_C(0);                     /** @brief TIM1 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_TIM8LPEN_POS = INT32_C(1);                     /** @brief TIM8 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USART1LPEN_POS = INT32_C(4);                   /** @brief USART1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USART6LPEN_POS = INT32_C(5);                   /** @brief USART6 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DFSDM1LPEN_POS = INT32_C(28);                  /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_HRTIMLPEN_POS = INT32_C(29);                   /** @brief HRTIM peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_TIM1LPEN_POS = INT32_C(0);                     /** @brief TIM1 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_TIM8LPEN_POS = INT32_C(1);                     /** @brief TIM8 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USART1LPEN_POS = INT32_C(4);                   /** @brief USART1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_USART6LPEN_POS = INT32_C(5);                   /** @brief USART6 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_DFSDM1LPEN_POS = INT32_C(28);                  /** @brief DFSDM1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_HRTIMLPEN_POS = INT32_C(29);                   /** @brief HRTIM peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SYSCFGLPEN_POS = INT32_C(1);                   /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_LPUART1LPEN_POS = INT32_C(3);                  /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPI6LPEN_POS = INT32_C(5);                     /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_I2C4LPEN_POS = INT32_C(7);                     /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_COMP12LPEN_POS = INT32_C(14);                  /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_VREFLPEN_POS = INT32_C(15);                    /** @brief VREF peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_RTCAPBLPEN_POS = INT32_C(16);                  /** @brief RTC APB clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SAI4LPEN_POS = INT32_C(21);                    /** @brief SAI4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SYSCFGLPEN_POS = INT32_C(1);                   /** @brief SYSCFG peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_LPUART1LPEN_POS = INT32_C(3);                  /** @brief LPUART1 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SPI6LPEN_POS = INT32_C(5);                     /** @brief SPI6 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_I2C4LPEN_POS = INT32_C(7);                     /** @brief I2C4 peripheral clocks enable during csleep mode */
    static const int32_t RCC_APB4LPENR_COMP12LPEN_POS = INT32_C(14);                  /** @brief COMP1/2 peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_VREFLPEN_POS = INT32_C(15);                    /** @brief VREF peripheral clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_RTCAPBLPEN_POS = INT32_C(16);                  /** @brief RTC APB clock enable during csleep mode */
    static const int32_t RCC_APB4LPENR_SAI4LPEN_POS = INT32_C(21);                    /** @brief SAI4 peripheral clocks enable during csleep mode */

    /**********************************************************************************************
     * @section LPTIMX Definitions
     **********************************************************************************************/

    /** @subsection LPTIMX IRQ interrupt array definitions */

    static const int32_t LPTIMX_IRQ[6] = {
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(93),     /** @brief LPTIM1 global interrupt */
      INT32_C(138),    /** @brief LPTIM2 timer interrupt */
      INT32_C(139),    /** @brief LPTIM2 timer interrupt */
      INT32_C(140),    /** @brief LPTIM2 timer interrupt */
      INT32_C(141),    /** @brief LPTIM2 timer interrupt */
    };

    /** @subsection LPTIMX register array definitions */

    static _RO uint32_t* const LPTIMX_ISR_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40002400),   /** @brief Interrupt and status register */
      (_RO uint32_t* const)UINT32_C(0x58002400),   /** @brief Interrupt and status register */
      (_RO uint32_t* const)UINT32_C(0x58002800),   /** @brief Interrupt and status register */
      (_RO uint32_t* const)UINT32_C(0x58002C00),   /** @brief Interrupt and status register */
      (_RO uint32_t* const)UINT32_C(0x58003000),   /** @brief Interrupt and status register */
    };

    static _RW uint32_t* const LPTIMX_ICR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40002404),   /** @brief Interrupt clear register */
      (_RW uint32_t* const)UINT32_C(0x58002404),   /** @brief Interrupt clear register */
      (_RW uint32_t* const)UINT32_C(0x58002804),   /** @brief Interrupt clear register */
      (_RW uint32_t* const)UINT32_C(0x58002C04),   /** @brief Interrupt clear register */
      (_RW uint32_t* const)UINT32_C(0x58003004),   /** @brief Interrupt clear register */
    };

    static _RW uint32_t* const LPTIMX_IER_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40002408),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x58002408),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x58002808),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x58002C08),   /** @brief Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x58003008),   /** @brief Interrupt enable register */
    };

    static _RW uint32_t* const LPTIMX_CFGR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000240C),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x5800240C),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x5800280C),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x58002C0C),   /** @brief Configuration register */
      (_RW uint32_t* const)UINT32_C(0x5800300C),   /** @brief Configuration register */
    };

    static _RW uint32_t* const LPTIMX_CR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40002410),   /** @brief Control register */
      (_RW uint32_t* const)UINT32_C(0x58002410),   /** @brief Control register */
      (_RW uint32_t* const)UINT32_C(0x58002810),   /** @brief Control register */
      (_RW uint32_t* const)UINT32_C(0x58002C10),   /** @brief Control register */
      (_RW uint32_t* const)UINT32_C(0x58003010),   /** @brief Control register */
    };

    static _RW uint32_t* const LPTIMX_CMP_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40002414),   /** @brief Compare register */
      (_RW uint32_t* const)UINT32_C(0x58002414),   /** @brief Compare register */
      (_RW uint32_t* const)UINT32_C(0x58002814),   /** @brief Compare register */
      (_RW uint32_t* const)UINT32_C(0x58002C14),   /** @brief Compare register */
      (_RW uint32_t* const)UINT32_C(0x58003014),   /** @brief Compare register */
    };

    static _RW uint32_t* const LPTIMX_ARR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40002418),   /** @brief Autoreload register */
      (_RW uint32_t* const)UINT32_C(0x58002418),   /** @brief Autoreload register */
      (_RW uint32_t* const)UINT32_C(0x58002818),   /** @brief Autoreload register */
      (_RW uint32_t* const)UINT32_C(0x58002C18),   /** @brief Autoreload register */
      (_RW uint32_t* const)UINT32_C(0x58003018),   /** @brief Autoreload register */
    };

    static _RO uint32_t* const LPTIMX_CNT_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000241C),   /** @brief Counter register */
      (_RO uint32_t* const)UINT32_C(0x5800241C),   /** @brief Counter register */
      (_RO uint32_t* const)UINT32_C(0x5800281C),   /** @brief Counter register */
      (_RO uint32_t* const)UINT32_C(0x58002C1C),   /** @brief Counter register */
      (_RO uint32_t* const)UINT32_C(0x5800301C),   /** @brief Counter register */
    };

    static _RW uint32_t* const LPTIMX_CFGR2_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40002424),   /** @brief LPTIM configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58002424),   /** @brief LPTIM configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58002824),   /** @brief LPTIM configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58002C24),   /** @brief LPTIM configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58003024),   /** @brief LPTIM configuration register 2 */
    };

    /** @subsection LPTIMX field mask definitions */

    static const uint32_t LPTIMX_ISR_DOWN_MASK = UINT32_C(0x00000040);         /** @brief Counter direction change up to down */
    static const uint32_t LPTIMX_ISR_UP_MASK = UINT32_C(0x00000020);           /** @brief Counter direction change down to up */
    static const uint32_t LPTIMX_ISR_ARROK_MASK = UINT32_C(0x00000010);        /** @brief Autoreload register update OK */
    static const uint32_t LPTIMX_ISR_CMPOK_MASK = UINT32_C(0x00000008);        /** @brief Compare register update OK */
    static const uint32_t LPTIMX_ISR_EXTTRIG_MASK = UINT32_C(0x00000004);      /** @brief External trigger edge event */
    static const uint32_t LPTIMX_ISR_ARRM_MASK = UINT32_C(0x00000002);         /** @brief Autoreload match */
    static const uint32_t LPTIMX_ISR_CMPM_MASK = UINT32_C(0x00000001);         /** @brief Compare match */
    static const uint32_t LPTIMX_ICR_DOWNCF_MASK = UINT32_C(0x00000040);       /** @brief Direction change to down clear flag */
    static const uint32_t LPTIMX_ICR_UPCF_MASK = UINT32_C(0x00000020);         /** @brief Direction change to UP clear flag */
    static const uint32_t LPTIMX_ICR_ARROKCF_MASK = UINT32_C(0x00000010);      /** @brief Autoreload register update OK clear flag */
    static const uint32_t LPTIMX_ICR_CMPOKCF_MASK = UINT32_C(0x00000008);      /** @brief Compare register update OK clear flag */
    static const uint32_t LPTIMX_ICR_EXTTRIGCF_MASK = UINT32_C(0x00000004);    /** @brief External trigger valid edge clear flag */
    static const uint32_t LPTIMX_ICR_ARRMCF_MASK = UINT32_C(0x00000002);       /** @brief Autoreload match clear flag */
    static const uint32_t LPTIMX_ICR_CMPMCF_MASK = UINT32_C(0x00000001);       /** @brief Compare match clear flag */
    static const uint32_t LPTIMX_IER_DOWNIE_MASK = UINT32_C(0x00000040);       /** @brief Direction change to down interrupt enable */
    static const uint32_t LPTIMX_IER_UPIE_MASK = UINT32_C(0x00000020);         /** @brief Direction change to UP interrupt enable */
    static const uint32_t LPTIMX_IER_ARROKIE_MASK = UINT32_C(0x00000010);      /** @brief Autoreload register update OK interrupt enable */
    static const uint32_t LPTIMX_IER_CMPOKIE_MASK = UINT32_C(0x00000008);      /** @brief Compare register update OK interrupt enable */
    static const uint32_t LPTIMX_IER_EXTTRIGIE_MASK = UINT32_C(0x00000004);    /** @brief External trigger valid edge interrupt enable */
    static const uint32_t LPTIMX_IER_ARRMIE_MASK = UINT32_C(0x00000002);       /** @brief Autoreload match interrupt enable */
    static const uint32_t LPTIMX_IER_CMPMIE_MASK = UINT32_C(0x00000001);       /** @brief Compare match interrupt enable */
    static const uint32_t LPTIMX_CFGR_ENC_MASK = UINT32_C(0x01000000);         /** @brief Encoder mode enable */
    static const uint32_t LPTIMX_CFGR_COUNTMODE_MASK = UINT32_C(0x00800000);   /** @brief Counter mode enabled */
    static const uint32_t LPTIMX_CFGR_PRELOAD_MASK = UINT32_C(0x00400000);     /** @brief Registers update mode */
    static const uint32_t LPTIMX_CFGR_WAVPOL_MASK = UINT32_C(0x00200000);      /** @brief Waveform shape polarity */
    static const uint32_t LPTIMX_CFGR_WAVE_MASK = UINT32_C(0x00100000);        /** @brief Waveform shape */
    static const uint32_t LPTIMX_CFGR_TIMOUT_MASK = UINT32_C(0x00080000);      /** @brief Timeout enable */
    static const uint32_t LPTIMX_CFGR_TRIGEN_MASK = UINT32_C(0x00060000);      /** @brief Trigger enable and polarity */
    static const uint32_t LPTIMX_CFGR_TRIGSEL_MASK = UINT32_C(0x0000E000);     /** @brief Trigger selector */
    static const uint32_t LPTIMX_CFGR_PRESC_MASK = UINT32_C(0x00000E00);       /** @brief Clock prescaler */
    static const uint32_t LPTIMX_CFGR_TRGFLT_MASK = UINT32_C(0x000000C0);      /** @brief Configurable digital filter for trigger */
    static const uint32_t LPTIMX_CFGR_CKFLT_MASK = UINT32_C(0x00000018);       /** @brief Configurable digital filter for external clock */
    static const uint32_t LPTIMX_CFGR_CKPOL_MASK = UINT32_C(0x00000006);       /** @brief Clock polarity */
    static const uint32_t LPTIMX_CFGR_CKSEL_MASK = UINT32_C(0x00000001);       /** @brief Clock selector */
    static const uint32_t LPTIMX_CR_ENABLE_MASK = UINT32_C(0x00000001);        /** @brief LPTIM enable */
    static const uint32_t LPTIMX_CR_SNGSTRT_MASK = UINT32_C(0x00000002);       /** @brief LPTIM start in single mode */
    static const uint32_t LPTIMX_CR_CNTSTRT_MASK = UINT32_C(0x00000004);       /** @brief Timer start in continuous mode */
    static const uint32_t LPTIMX_CR_COUNTRST_MASK = UINT32_C(0x00000008);      /** @brief Counter reset */
    static const uint32_t LPTIMX_CR_RSTARE_MASK = UINT32_C(0x00000010);        /** @brief Reset after read enable */
    static const uint32_t LPTIMX_CMP_CMP_MASK = UINT32_C(0x0000FFFF);          /** @brief Compare value */
    static const uint32_t LPTIMX_ARR_ARR_MASK = UINT32_C(0x0000FFFF);          /** @brief Auto reload value */
    static const uint32_t LPTIMX_CNT_CNT_MASK = UINT32_C(0x0000FFFF);          /** @brief Counter value */
    static const uint32_t LPTIMX_CFGR2_IN1SEL_MASK = UINT32_C(0x00000003);     /** @brief LPTIM input 1 selection */
    static const uint32_t LPTIMX_CFGR2_IN2SEL_MASK = UINT32_C(0x00000030);     /** @brief LPTIM input 2 selection */

    /** @subsection LPTIMX field position definitions */

    static const int32_t LPTIMX_CFGR2_DOWN_POS = INT32_C(6);         /** @brief Counter direction change up to down */
    static const int32_t LPTIMX_CFGR2_UP_POS = INT32_C(5);           /** @brief Counter direction change down to up */
    static const int32_t LPTIMX_CFGR2_ARROK_POS = INT32_C(4);        /** @brief Autoreload register update OK */
    static const int32_t LPTIMX_CFGR2_CMPOK_POS = INT32_C(3);        /** @brief Compare register update OK */
    static const int32_t LPTIMX_CFGR2_EXTTRIG_POS = INT32_C(2);      /** @brief External trigger edge event */
    static const int32_t LPTIMX_CFGR2_ARRM_POS = INT32_C(1);         /** @brief Autoreload match */
    static const int32_t LPTIMX_CFGR2_CMPM_POS = INT32_C(0);         /** @brief Compare match */
    static const int32_t LPTIMX_CFGR2_DOWNCF_POS = INT32_C(6);       /** @brief Direction change to down clear flag */
    static const int32_t LPTIMX_CFGR2_UPCF_POS = INT32_C(5);         /** @brief Direction change to UP clear flag */
    static const int32_t LPTIMX_CFGR2_ARROKCF_POS = INT32_C(4);      /** @brief Autoreload register update OK clear flag */
    static const int32_t LPTIMX_CFGR2_CMPOKCF_POS = INT32_C(3);      /** @brief Compare register update OK clear flag */
    static const int32_t LPTIMX_CFGR2_EXTTRIGCF_POS = INT32_C(2);    /** @brief External trigger valid edge clear flag */
    static const int32_t LPTIMX_CFGR2_ARRMCF_POS = INT32_C(1);       /** @brief Autoreload match clear flag */
    static const int32_t LPTIMX_CFGR2_CMPMCF_POS = INT32_C(0);       /** @brief Compare match clear flag */
    static const int32_t LPTIMX_CFGR2_DOWNIE_POS = INT32_C(6);       /** @brief Direction change to down interrupt enable */
    static const int32_t LPTIMX_CFGR2_UPIE_POS = INT32_C(5);         /** @brief Direction change to UP interrupt enable */
    static const int32_t LPTIMX_CFGR2_ARROKIE_POS = INT32_C(4);      /** @brief Autoreload register update OK interrupt enable */
    static const int32_t LPTIMX_CFGR2_CMPOKIE_POS = INT32_C(3);      /** @brief Compare register update OK interrupt enable */
    static const int32_t LPTIMX_CFGR2_EXTTRIGIE_POS = INT32_C(2);    /** @brief External trigger valid edge interrupt enable */
    static const int32_t LPTIMX_CFGR2_ARRMIE_POS = INT32_C(1);       /** @brief Autoreload match interrupt enable */
    static const int32_t LPTIMX_CFGR2_CMPMIE_POS = INT32_C(0);       /** @brief Compare match interrupt enable */
    static const int32_t LPTIMX_CFGR2_ENC_POS = INT32_C(24);         /** @brief Encoder mode enable */
    static const int32_t LPTIMX_CFGR2_COUNTMODE_POS = INT32_C(23);   /** @brief Counter mode enabled */
    static const int32_t LPTIMX_CFGR2_PRELOAD_POS = INT32_C(22);     /** @brief Registers update mode */
    static const int32_t LPTIMX_CFGR2_WAVPOL_POS = INT32_C(21);      /** @brief Waveform shape polarity */
    static const int32_t LPTIMX_CFGR2_WAVE_POS = INT32_C(20);        /** @brief Waveform shape */
    static const int32_t LPTIMX_CFGR2_TIMOUT_POS = INT32_C(19);      /** @brief Timeout enable */
    static const int32_t LPTIMX_CFGR2_TRIGEN_POS = INT32_C(17);      /** @brief Trigger enable and polarity */
    static const int32_t LPTIMX_CFGR2_TRIGSEL_POS = INT32_C(13);     /** @brief Trigger selector */
    static const int32_t LPTIMX_CFGR2_PRESC_POS = INT32_C(9);        /** @brief Clock prescaler */
    static const int32_t LPTIMX_CFGR2_TRGFLT_POS = INT32_C(6);       /** @brief Configurable digital filter for trigger */
    static const int32_t LPTIMX_CFGR2_CKFLT_POS = INT32_C(3);        /** @brief Configurable digital filter for external clock */
    static const int32_t LPTIMX_CFGR2_CKPOL_POS = INT32_C(1);        /** @brief Clock polarity */
    static const int32_t LPTIMX_CFGR2_CKSEL_POS = INT32_C(0);        /** @brief Clock selector */
    static const int32_t LPTIMX_CFGR2_ENABLE_POS = INT32_C(0);       /** @brief LPTIM enable */
    static const int32_t LPTIMX_CFGR2_SNGSTRT_POS = INT32_C(1);      /** @brief LPTIM start in single mode */
    static const int32_t LPTIMX_CFGR2_CNTSTRT_POS = INT32_C(2);      /** @brief Timer start in continuous mode */
    static const int32_t LPTIMX_CFGR2_COUNTRST_POS = INT32_C(3);     /** @brief Counter reset */
    static const int32_t LPTIMX_CFGR2_RSTARE_POS = INT32_C(4);       /** @brief Reset after read enable */
    static const int32_t LPTIMX_CFGR2_CMP_POS = INT32_C(0);          /** @brief Compare value */
    static const int32_t LPTIMX_CFGR2_ARR_POS = INT32_C(0);          /** @brief Auto reload value */
    static const int32_t LPTIMX_CFGR2_CNT_POS = INT32_C(0);          /** @brief Counter value */
    static const int32_t LPTIMX_CFGR2_IN1SEL_POS = INT32_C(0);       /** @brief LPTIM input 1 selection */
    static const int32_t LPTIMX_CFGR2_IN2SEL_POS = INT32_C(4);       /** @brief LPTIM input 2 selection */

    /**********************************************************************************************
     * @section LPUART1 Definitions
     **********************************************************************************************/

    /** @subsection LPUART1 IRQ interrupt definitions */

    static const int32_t LPUART_IRQ = INT32_C(142);   /** @brief LPUART global interrupt */

    /** @subsection LPUART1 register definitions */

    static _RW uint32_t* const LPUART1_CR1_REG = (_RW uint32_t* const)UINT32_C(0x58000C00);     /** @brief Control register 1 */
    static _RW uint32_t* const LPUART1_CR2_REG = (_RW uint32_t* const)UINT32_C(0x58000C04);     /** @brief Control register 2 */
    static _RW uint32_t* const LPUART1_CR3_REG = (_RW uint32_t* const)UINT32_C(0x58000C08);     /** @brief Control register 3 */
    static _RW uint32_t* const LPUART1_BRR_REG = (_RW uint32_t* const)UINT32_C(0x58000C0C);     /** @brief Baud rate register */
    static _RW uint32_t* const LPUART1_GTPR_REG = (_RW uint32_t* const)UINT32_C(0x58000C10);    /** @brief Guard time and prescaler register */
    static _RW uint32_t* const LPUART1_RTOR_REG = (_RW uint32_t* const)UINT32_C(0x58000C14);    /** @brief Receiver timeout register */
    static _RW uint32_t* const LPUART1_RQR_REG = (_RW uint32_t* const)UINT32_C(0x58000C18);     /** @brief Request register */
    static _RO uint32_t* const LPUART1_ISR_REG = (_RO uint32_t* const)UINT32_C(0x58000C1C);     /** @brief Interrupt & status register */
    static _RW uint32_t* const LPUART1_ICR_REG = (_RW uint32_t* const)UINT32_C(0x58000C20);     /** @brief Interrupt flag clear register */
    static _RO uint32_t* const LPUART1_RDR_REG = (_RO uint32_t* const)UINT32_C(0x58000C24);     /** @brief Receive data register */
    static _RW uint32_t* const LPUART1_TDR_REG = (_RW uint32_t* const)UINT32_C(0x58000C28);     /** @brief Transmit data register */
    static _RW uint32_t* const LPUART1_PRESC_REG = (_RW uint32_t* const)UINT32_C(0x58000C2C);   /** @brief Prescaler register */

    /** @subsection LPUART1 field mask definitions */

    static const uint32_t LPUART1_CR1_RXFFIE_MASK = UINT32_C(0x80000000);        /** @brief RXFIFO full interrupt enable */
    static const uint32_t LPUART1_CR1_TXFEIE_MASK = UINT32_C(0x40000000);        /** @brief TXFIFO empty interrupt enable */
    static const uint32_t LPUART1_CR1_FIFOEN_MASK = UINT32_C(0x20000000);        /** @brief FIFO mode enable */
    static const uint32_t LPUART1_CR1_M1_MASK = UINT32_C(0x10000000);            /** @brief Word length */
    static const uint32_t LPUART1_CR1_DEAT_MASK = UINT32_C(0x03E00000);          /** @brief Driver enable assertion time */
    static const uint32_t LPUART1_CR1_DEDT_MASK = UINT32_C(0x001F0000);          /** @brief Driver enable deassertion time */
    static const uint32_t LPUART1_CR1_CMIE_MASK = UINT32_C(0x00004000);          /** @brief Character match interrupt enable */
    static const uint32_t LPUART1_CR1_MME_MASK = UINT32_C(0x00002000);           /** @brief Mute mode enable */
    static const uint32_t LPUART1_CR1_M0_MASK = UINT32_C(0x00001000);            /** @brief Word length */
    static const uint32_t LPUART1_CR1_WAKE_MASK = UINT32_C(0x00000800);          /** @brief Receiver wakeup method */
    static const uint32_t LPUART1_CR1_PCE_MASK = UINT32_C(0x00000400);           /** @brief Parity control enable */
    static const uint32_t LPUART1_CR1_PS_MASK = UINT32_C(0x00000200);            /** @brief Parity selection */
    static const uint32_t LPUART1_CR1_PEIE_MASK = UINT32_C(0x00000100);          /** @brief PE interrupt enable */
    static const uint32_t LPUART1_CR1_TXEIE_MASK = UINT32_C(0x00000080);         /** @brief Interrupt enable */
    static const uint32_t LPUART1_CR1_TCIE_MASK = UINT32_C(0x00000040);          /** @brief Transmission complete interrupt enable */
    static const uint32_t LPUART1_CR1_RXNEIE_MASK = UINT32_C(0x00000020);        /** @brief RXNE interrupt enable */
    static const uint32_t LPUART1_CR1_IDLEIE_MASK = UINT32_C(0x00000010);        /** @brief IDLE interrupt enable */
    static const uint32_t LPUART1_CR1_TE_MASK = UINT32_C(0x00000008);            /** @brief Transmitter enable */
    static const uint32_t LPUART1_CR1_RE_MASK = UINT32_C(0x00000004);            /** @brief Receiver enable */
    static const uint32_t LPUART1_CR1_UESM_MASK = UINT32_C(0x00000002);          /** @brief USART enable in stop mode */
    static const uint32_t LPUART1_CR1_UE_MASK = UINT32_C(0x00000001);            /** @brief USART enable */
    static const uint32_t LPUART1_CR2_ADD_MASK = UINT32_C(0xFF000000);           /** @brief Address of the USART node */
    static const uint32_t LPUART1_CR2_MSBFIRST_MASK = UINT32_C(0x00080000);      /** @brief Most significant bit first */
    static const uint32_t LPUART1_CR2_DATAINV_MASK = UINT32_C(0x00040000);       /** @brief Binary data inversion */
    static const uint32_t LPUART1_CR2_TXINV_MASK = UINT32_C(0x00020000);         /** @brief TX pin active level inversion */
    static const uint32_t LPUART1_CR2_RXINV_MASK = UINT32_C(0x00010000);         /** @brief RX pin active level inversion */
    static const uint32_t LPUART1_CR2_SWAP_MASK = UINT32_C(0x00008000);          /** @brief Swap TX/RX pins */
    static const uint32_t LPUART1_CR2_STOP_MASK = UINT32_C(0x00003000);          /** @brief STOP bits */
    static const uint32_t LPUART1_CR2_ADDM7_MASK = UINT32_C(0x00000010);         /** @brief 7-bit address detection/4-bit address detection */
    static const uint32_t LPUART1_CR3_TXFTCFG_MASK = UINT32_C(0xE0000000);       /** @brief TXFIFO threshold configuration */
    static const uint32_t LPUART1_CR3_RXFTIE_MASK = UINT32_C(0x10000000);        /** @brief RXFIFO threshold interrupt enable */
    static const uint32_t LPUART1_CR3_RXFTCFG_MASK = UINT32_C(0x0E000000);       /** @brief Receive FIFO threshold configuration */
    static const uint32_t LPUART1_CR3_TXFTIE_MASK = UINT32_C(0x00800000);        /** @brief TXFIFO threshold interrupt enable */
    static const uint32_t LPUART1_CR3_WUFIE_MASK = UINT32_C(0x00400000);         /** @brief Wakeup from stop mode interrupt enable */
    static const uint32_t LPUART1_CR3_WUS_MASK = UINT32_C(0x00300000);           /** @brief Wakeup from stop mode interrupt flag selection */
    static const uint32_t LPUART1_CR3_DEP_MASK = UINT32_C(0x00008000);           /** @brief Driver enable polarity selection */
    static const uint32_t LPUART1_CR3_DEM_MASK = UINT32_C(0x00004000);           /** @brief Driver enable mode */
    static const uint32_t LPUART1_CR3_DDRE_MASK = UINT32_C(0x00002000);          /** @brief DMA disable on reception error */
    static const uint32_t LPUART1_CR3_OVRDIS_MASK = UINT32_C(0x00001000);        /** @brief Overrun disable */
    static const uint32_t LPUART1_CR3_CTSIE_MASK = UINT32_C(0x00000400);         /** @brief CTS interrupt enable */
    static const uint32_t LPUART1_CR3_CTSE_MASK = UINT32_C(0x00000200);          /** @brief CTS enable */
    static const uint32_t LPUART1_CR3_RTSE_MASK = UINT32_C(0x00000100);          /** @brief RTS enable */
    static const uint32_t LPUART1_CR3_DMAT_MASK = UINT32_C(0x00000080);          /** @brief DMA enable transmitter */
    static const uint32_t LPUART1_CR3_DMAR_MASK = UINT32_C(0x00000040);          /** @brief DMA enable receiver */
    static const uint32_t LPUART1_CR3_HDSEL_MASK = UINT32_C(0x00000008);         /** @brief Half-duplex selection */
    static const uint32_t LPUART1_CR3_EIE_MASK = UINT32_C(0x00000001);           /** @brief Error interrupt enable */
    static const uint32_t LPUART1_BRR_BRR_MASK = UINT32_C(0x000FFFFF);           /** @brief BRR */
    static const uint32_t LPUART1_GTPR_GT_MASK = UINT32_C(0x0000FF00);           /** @brief Guard time value */
    static const uint32_t LPUART1_GTPR_PSC_MASK = UINT32_C(0x000000FF);          /** @brief Prescaler value */
    static const uint32_t LPUART1_RTOR_BLEN_MASK = UINT32_C(0xFF000000);         /** @brief Block length */
    static const uint32_t LPUART1_RTOR_RTO_MASK = UINT32_C(0x00FFFFFF);          /** @brief Receiver timeout value */
    static const uint32_t LPUART1_RQR_TXFRQ_MASK = UINT32_C(0x00000010);         /** @brief Transmit data flush request */
    static const uint32_t LPUART1_RQR_RXFRQ_MASK = UINT32_C(0x00000008);         /** @brief Receive data flush request */
    static const uint32_t LPUART1_RQR_MMRQ_MASK = UINT32_C(0x00000004);          /** @brief Mute mode request */
    static const uint32_t LPUART1_RQR_SBKRQ_MASK = UINT32_C(0x00000002);         /** @brief Send break request */
    static const uint32_t LPUART1_RQR_ABRRQ_MASK = UINT32_C(0x00000001);         /** @brief Auto baud rate request */
    static const uint32_t LPUART1_ISR_TXFT_MASK = UINT32_C(0x08000000);          /** @brief TXFIFO threshold flag */
    static const uint32_t LPUART1_ISR_RXFT_MASK = UINT32_C(0x04000000);          /** @brief RXFIFO threshold flag */
    static const uint32_t LPUART1_ISR_RXFF_MASK = UINT32_C(0x01000000);          /** @brief RXFIFO full */
    static const uint32_t LPUART1_ISR_TXFE_MASK = UINT32_C(0x00800000);          /** @brief TXFIFO empty */
    static const uint32_t LPUART1_ISR_REACK_MASK = UINT32_C(0x00400000);         /** @brief REACK */
    static const uint32_t LPUART1_ISR_TEACK_MASK = UINT32_C(0x00200000);         /** @brief TEACK */
    static const uint32_t LPUART1_ISR_WUF_MASK = UINT32_C(0x00100000);           /** @brief WUF */
    static const uint32_t LPUART1_ISR_RWU_MASK = UINT32_C(0x00080000);           /** @brief RWU */
    static const uint32_t LPUART1_ISR_SBKF_MASK = UINT32_C(0x00040000);          /** @brief SBKF */
    static const uint32_t LPUART1_ISR_CMF_MASK = UINT32_C(0x00020000);           /** @brief CMF */
    static const uint32_t LPUART1_ISR_BUSY_MASK = UINT32_C(0x00010000);          /** @brief BUSY */
    static const uint32_t LPUART1_ISR_CTS_MASK = UINT32_C(0x00000400);           /** @brief CTS */
    static const uint32_t LPUART1_ISR_CTSIF_MASK = UINT32_C(0x00000200);         /** @brief CTSIF */
    static const uint32_t LPUART1_ISR_TXE_MASK = UINT32_C(0x00000080);           /** @brief TXE */
    static const uint32_t LPUART1_ISR_TC_MASK = UINT32_C(0x00000040);            /** @brief TC */
    static const uint32_t LPUART1_ISR_RXNE_MASK = UINT32_C(0x00000020);          /** @brief RXNE */
    static const uint32_t LPUART1_ISR_IDLE_MASK = UINT32_C(0x00000010);          /** @brief IDLE */
    static const uint32_t LPUART1_ISR_ORE_MASK = UINT32_C(0x00000008);           /** @brief ORE */
    static const uint32_t LPUART1_ISR_NE_MASK = UINT32_C(0x00000004);            /** @brief NE */
    static const uint32_t LPUART1_ISR_FE_MASK = UINT32_C(0x00000002);            /** @brief FE */
    static const uint32_t LPUART1_ISR_PE_MASK = UINT32_C(0x00000001);            /** @brief PE */
    static const uint32_t LPUART1_ICR_WUCF_MASK = UINT32_C(0x00100000);          /** @brief Wakeup from stop mode clear flag */
    static const uint32_t LPUART1_ICR_CMCF_MASK = UINT32_C(0x00020000);          /** @brief Character match clear flag */
    static const uint32_t LPUART1_ICR_CTSCF_MASK = UINT32_C(0x00000200);         /** @brief CTS clear flag */
    static const uint32_t LPUART1_ICR_TCCF_MASK = UINT32_C(0x00000040);          /** @brief Transmission complete clear flag */
    static const uint32_t LPUART1_ICR_IDLECF_MASK = UINT32_C(0x00000010);        /** @brief Idle line detected clear flag */
    static const uint32_t LPUART1_ICR_ORECF_MASK = UINT32_C(0x00000008);         /** @brief Overrun error clear flag */
    static const uint32_t LPUART1_ICR_NCF_MASK = UINT32_C(0x00000004);           /** @brief Noise detected clear flag */
    static const uint32_t LPUART1_ICR_FECF_MASK = UINT32_C(0x00000002);          /** @brief Framing error clear flag */
    static const uint32_t LPUART1_ICR_PECF_MASK = UINT32_C(0x00000001);          /** @brief Parity error clear flag */
    static const uint32_t LPUART1_RDR_RDR_MASK = UINT32_C(0x000001FF);           /** @brief Receive data value */
    static const uint32_t LPUART1_TDR_TDR_MASK = UINT32_C(0x000001FF);           /** @brief Transmit data value */
    static const uint32_t LPUART1_PRESC_PRESCALER_MASK = UINT32_C(0x0000000F);   /** @brief Clock prescaler */

    /** @subsection LPUART1 field position definitions */

    static const int32_t LPUART1_PRESC_RXFFIE_POS = INT32_C(31);      /** @brief RXFIFO full interrupt enable */
    static const int32_t LPUART1_PRESC_TXFEIE_POS = INT32_C(30);      /** @brief TXFIFO empty interrupt enable */
    static const int32_t LPUART1_PRESC_FIFOEN_POS = INT32_C(29);      /** @brief FIFO mode enable */
    static const int32_t LPUART1_PRESC_M1_POS = INT32_C(28);          /** @brief Word length */
    static const int32_t LPUART1_PRESC_DEAT_POS = INT32_C(21);        /** @brief Driver enable assertion time */
    static const int32_t LPUART1_PRESC_DEDT_POS = INT32_C(16);        /** @brief Driver enable deassertion time */
    static const int32_t LPUART1_PRESC_CMIE_POS = INT32_C(14);        /** @brief Character match interrupt enable */
    static const int32_t LPUART1_PRESC_MME_POS = INT32_C(13);         /** @brief Mute mode enable */
    static const int32_t LPUART1_PRESC_M0_POS = INT32_C(12);          /** @brief Word length */
    static const int32_t LPUART1_PRESC_WAKE_POS = INT32_C(11);        /** @brief Receiver wakeup method */
    static const int32_t LPUART1_PRESC_PCE_POS = INT32_C(10);         /** @brief Parity control enable */
    static const int32_t LPUART1_PRESC_PS_POS = INT32_C(9);           /** @brief Parity selection */
    static const int32_t LPUART1_PRESC_PEIE_POS = INT32_C(8);         /** @brief PE interrupt enable */
    static const int32_t LPUART1_PRESC_TXEIE_POS = INT32_C(7);        /** @brief Interrupt enable */
    static const int32_t LPUART1_PRESC_TCIE_POS = INT32_C(6);         /** @brief Transmission complete interrupt enable */
    static const int32_t LPUART1_PRESC_RXNEIE_POS = INT32_C(5);       /** @brief RXNE interrupt enable */
    static const int32_t LPUART1_PRESC_IDLEIE_POS = INT32_C(4);       /** @brief IDLE interrupt enable */
    static const int32_t LPUART1_PRESC_TE_POS = INT32_C(3);           /** @brief Transmitter enable */
    static const int32_t LPUART1_PRESC_RE_POS = INT32_C(2);           /** @brief Receiver enable */
    static const int32_t LPUART1_PRESC_UESM_POS = INT32_C(1);         /** @brief USART enable in stop mode */
    static const int32_t LPUART1_PRESC_UE_POS = INT32_C(0);           /** @brief USART enable */
    static const int32_t LPUART1_PRESC_ADD_POS = INT32_C(24);         /** @brief Address of the USART node */
    static const int32_t LPUART1_PRESC_MSBFIRST_POS = INT32_C(19);    /** @brief Most significant bit first */
    static const int32_t LPUART1_PRESC_DATAINV_POS = INT32_C(18);     /** @brief Binary data inversion */
    static const int32_t LPUART1_PRESC_TXINV_POS = INT32_C(17);       /** @brief TX pin active level inversion */
    static const int32_t LPUART1_PRESC_RXINV_POS = INT32_C(16);       /** @brief RX pin active level inversion */
    static const int32_t LPUART1_PRESC_SWAP_POS = INT32_C(15);        /** @brief Swap TX/RX pins */
    static const int32_t LPUART1_PRESC_STOP_POS = INT32_C(12);        /** @brief STOP bits */
    static const int32_t LPUART1_PRESC_ADDM7_POS = INT32_C(4);        /** @brief 7-bit address detection/4-bit address detection */
    static const int32_t LPUART1_PRESC_TXFTCFG_POS = INT32_C(29);     /** @brief TXFIFO threshold configuration */
    static const int32_t LPUART1_PRESC_RXFTIE_POS = INT32_C(28);      /** @brief RXFIFO threshold interrupt enable */
    static const int32_t LPUART1_PRESC_RXFTCFG_POS = INT32_C(25);     /** @brief Receive FIFO threshold configuration */
    static const int32_t LPUART1_PRESC_TXFTIE_POS = INT32_C(23);      /** @brief TXFIFO threshold interrupt enable */
    static const int32_t LPUART1_PRESC_WUFIE_POS = INT32_C(22);       /** @brief Wakeup from stop mode interrupt enable */
    static const int32_t LPUART1_PRESC_WUS_POS = INT32_C(20);         /** @brief Wakeup from stop mode interrupt flag selection */
    static const int32_t LPUART1_PRESC_DEP_POS = INT32_C(15);         /** @brief Driver enable polarity selection */
    static const int32_t LPUART1_PRESC_DEM_POS = INT32_C(14);         /** @brief Driver enable mode */
    static const int32_t LPUART1_PRESC_DDRE_POS = INT32_C(13);        /** @brief DMA disable on reception error */
    static const int32_t LPUART1_PRESC_OVRDIS_POS = INT32_C(12);      /** @brief Overrun disable */
    static const int32_t LPUART1_PRESC_CTSIE_POS = INT32_C(10);       /** @brief CTS interrupt enable */
    static const int32_t LPUART1_PRESC_CTSE_POS = INT32_C(9);         /** @brief CTS enable */
    static const int32_t LPUART1_PRESC_RTSE_POS = INT32_C(8);         /** @brief RTS enable */
    static const int32_t LPUART1_PRESC_DMAT_POS = INT32_C(7);         /** @brief DMA enable transmitter */
    static const int32_t LPUART1_PRESC_DMAR_POS = INT32_C(6);         /** @brief DMA enable receiver */
    static const int32_t LPUART1_PRESC_HDSEL_POS = INT32_C(3);        /** @brief Half-duplex selection */
    static const int32_t LPUART1_PRESC_EIE_POS = INT32_C(0);          /** @brief Error interrupt enable */
    static const int32_t LPUART1_PRESC_BRR_POS = INT32_C(0);          /** @brief BRR */
    static const int32_t LPUART1_PRESC_GT_POS = INT32_C(8);           /** @brief Guard time value */
    static const int32_t LPUART1_PRESC_PSC_POS = INT32_C(0);          /** @brief Prescaler value */
    static const int32_t LPUART1_PRESC_BLEN_POS = INT32_C(24);        /** @brief Block length */
    static const int32_t LPUART1_PRESC_RTO_POS = INT32_C(0);          /** @brief Receiver timeout value */
    static const int32_t LPUART1_PRESC_TXFRQ_POS = INT32_C(4);        /** @brief Transmit data flush request */
    static const int32_t LPUART1_PRESC_RXFRQ_POS = INT32_C(3);        /** @brief Receive data flush request */
    static const int32_t LPUART1_PRESC_MMRQ_POS = INT32_C(2);         /** @brief Mute mode request */
    static const int32_t LPUART1_PRESC_SBKRQ_POS = INT32_C(1);        /** @brief Send break request */
    static const int32_t LPUART1_PRESC_ABRRQ_POS = INT32_C(0);        /** @brief Auto baud rate request */
    static const int32_t LPUART1_PRESC_TXFT_POS = INT32_C(27);        /** @brief TXFIFO threshold flag */
    static const int32_t LPUART1_PRESC_RXFT_POS = INT32_C(26);        /** @brief RXFIFO threshold flag */
    static const int32_t LPUART1_PRESC_RXFF_POS = INT32_C(24);        /** @brief RXFIFO full */
    static const int32_t LPUART1_PRESC_TXFE_POS = INT32_C(23);        /** @brief TXFIFO empty */
    static const int32_t LPUART1_PRESC_REACK_POS = INT32_C(22);       /** @brief REACK */
    static const int32_t LPUART1_PRESC_TEACK_POS = INT32_C(21);       /** @brief TEACK */
    static const int32_t LPUART1_PRESC_WUF_POS = INT32_C(20);         /** @brief WUF */
    static const int32_t LPUART1_PRESC_RWU_POS = INT32_C(19);         /** @brief RWU */
    static const int32_t LPUART1_PRESC_SBKF_POS = INT32_C(18);        /** @brief SBKF */
    static const int32_t LPUART1_PRESC_CMF_POS = INT32_C(17);         /** @brief CMF */
    static const int32_t LPUART1_PRESC_BUSY_POS = INT32_C(16);        /** @brief BUSY */
    static const int32_t LPUART1_PRESC_CTS_POS = INT32_C(10);         /** @brief CTS */
    static const int32_t LPUART1_PRESC_CTSIF_POS = INT32_C(9);        /** @brief CTSIF */
    static const int32_t LPUART1_PRESC_TXE_POS = INT32_C(7);          /** @brief TXE */
    static const int32_t LPUART1_PRESC_TC_POS = INT32_C(6);           /** @brief TC */
    static const int32_t LPUART1_PRESC_RXNE_POS = INT32_C(5);         /** @brief RXNE */
    static const int32_t LPUART1_PRESC_IDLE_POS = INT32_C(4);         /** @brief IDLE */
    static const int32_t LPUART1_PRESC_ORE_POS = INT32_C(3);          /** @brief ORE */
    static const int32_t LPUART1_PRESC_NE_POS = INT32_C(2);           /** @brief NE */
    static const int32_t LPUART1_PRESC_FE_POS = INT32_C(1);           /** @brief FE */
    static const int32_t LPUART1_PRESC_PE_POS = INT32_C(0);           /** @brief PE */
    static const int32_t LPUART1_PRESC_WUCF_POS = INT32_C(20);        /** @brief Wakeup from stop mode clear flag */
    static const int32_t LPUART1_PRESC_CMCF_POS = INT32_C(17);        /** @brief Character match clear flag */
    static const int32_t LPUART1_PRESC_CTSCF_POS = INT32_C(9);        /** @brief CTS clear flag */
    static const int32_t LPUART1_PRESC_TCCF_POS = INT32_C(6);         /** @brief Transmission complete clear flag */
    static const int32_t LPUART1_PRESC_IDLECF_POS = INT32_C(4);       /** @brief Idle line detected clear flag */
    static const int32_t LPUART1_PRESC_ORECF_POS = INT32_C(3);        /** @brief Overrun error clear flag */
    static const int32_t LPUART1_PRESC_NCF_POS = INT32_C(2);          /** @brief Noise detected clear flag */
    static const int32_t LPUART1_PRESC_FECF_POS = INT32_C(1);         /** @brief Framing error clear flag */
    static const int32_t LPUART1_PRESC_PECF_POS = INT32_C(0);         /** @brief Parity error clear flag */
    static const int32_t LPUART1_PRESC_RDR_POS = INT32_C(0);          /** @brief Receive data value */
    static const int32_t LPUART1_PRESC_TDR_POS = INT32_C(0);          /** @brief Transmit data value */
    static const int32_t LPUART1_PRESC_PRESCALER_POS = INT32_C(0);    /** @brief Clock prescaler */

    /**********************************************************************************************
     * @section SYSCFG Definitions
     **********************************************************************************************/

    /** @subsection SYSCFG register array definitions */

    static _RW uint32_t* const SYSCFG_EXTICRX_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x58000408),   /** @brief External interrupt configuration register 1 */
      (_RW uint32_t* const)UINT32_C(0x5800040C),   /** @brief External interrupt configuration register 2 */
      (_RW uint32_t* const)UINT32_C(0x58000410),   /** @brief External interrupt configuration register 3 */
      (_RW uint32_t* const)UINT32_C(0x58000414),   /** @brief External interrupt configuration register 4 */
    };

    static _RO uint32_t* const SYSCFG_UR1X_REG[8] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x58000740),   /** @brief SYSCFG user register 16 */
      (_RO uint32_t* const)UINT32_C(0x58000744),   /** @brief SYSCFG user register 17 */
    };

    /** @subsection SYSCFG register definitions */

    static _RW uint32_t* const SYSCFG_PMCR_REG = (_RW uint32_t* const)UINT32_C(0x58000404);    /** @brief Peripheral mode configuration register */
    static _RW uint32_t* const SYSCFG_CCCSR_REG = (_RW uint32_t* const)UINT32_C(0x58000420);   /** @brief Compensation cell control/status register */
    static _RO uint32_t* const SYSCFG_CCVR_REG = (_RO uint32_t* const)UINT32_C(0x58000424);    /** @brief SYSCFG compensation cell value register */
    static _RW uint32_t* const SYSCFG_CCCR_REG = (_RW uint32_t* const)UINT32_C(0x58000428);    /** @brief SYSCFG compensation cell code register */
    static _RO uint32_t* const SYSCFG_PKGR_REG = (_RO uint32_t* const)UINT32_C(0x58000524);    /** @brief SYSCFG package register */
    static _RO uint32_t* const SYSCFG_UR0_REG = (_RO uint32_t* const)UINT32_C(0x58000700);     /** @brief SYSCFG user register 0 */
    static _RW uint32_t* const SYSCFG_UR2_REG = (_RW uint32_t* const)UINT32_C(0x58000708);     /** @brief SYSCFG user register 2 */
    static _RW uint32_t* const SYSCFG_UR3_REG = (_RW uint32_t* const)UINT32_C(0x5800070C);     /** @brief SYSCFG user register 3 */
    static _RO uint32_t* const SYSCFG_UR4_REG = (_RO uint32_t* const)UINT32_C(0x58000710);     /** @brief SYSCFG user register 4 */
    static _RO uint32_t* const SYSCFG_UR5_REG = (_RO uint32_t* const)UINT32_C(0x58000714);     /** @brief SYSCFG user register 5 */
    static _RO uint32_t* const SYSCFG_UR6_REG = (_RO uint32_t* const)UINT32_C(0x58000718);     /** @brief SYSCFG user register 6 */
    static _RO uint32_t* const SYSCFG_UR7_REG = (_RO uint32_t* const)UINT32_C(0x5800071C);     /** @brief SYSCFG user register 7 */
    static _RO uint32_t* const SYSCFG_UR8_REG = (_RO uint32_t* const)UINT32_C(0x58000720);     /** @brief SYSCFG user register 8 */
    static _RO uint32_t* const SYSCFG_UR9_REG = (_RO uint32_t* const)UINT32_C(0x58000724);     /** @brief SYSCFG user register 9 */
    static _RO uint32_t* const SYSCFG_UR10_REG = (_RO uint32_t* const)UINT32_C(0x58000728);    /** @brief SYSCFG user register 10 */
    static _RO uint32_t* const SYSCFG_UR11_REG = (_RO uint32_t* const)UINT32_C(0x5800072C);    /** @brief SYSCFG user register 11 */
    static _RO uint32_t* const SYSCFG_UR12_REG = (_RO uint32_t* const)UINT32_C(0x58000730);    /** @brief SYSCFG user register 12 */
    static _RO uint32_t* const SYSCFG_UR13_REG = (_RO uint32_t* const)UINT32_C(0x58000734);    /** @brief SYSCFG user register 13 */
    static _RW uint32_t* const SYSCFG_UR14_REG = (_RW uint32_t* const)UINT32_C(0x58000738);    /** @brief SYSCFG user register 14 */
    static _RO uint32_t* const SYSCFG_UR15_REG = (_RO uint32_t* const)UINT32_C(0x5800073C);    /** @brief SYSCFG user register 15 */

    /** @subsection SYSCFG field mask array definitions */

    static const uint32_t SYSCFG_PMCR_I2CXFMP_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief I2C1 fm+ */
      UINT32_C(0x00000002),   /** @brief I2C2 fm+ */
      UINT32_C(0x00000004),   /** @brief I2C3 fm+ */
      UINT32_C(0x00000008),   /** @brief I2C4 fm+ */
    };

    static const uint32_t SYSCFG_PMCR_PBXFMP_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000010),   /** @brief PB(6) fm+ */
      UINT32_C(0x00000020),   /** @brief PB(7) fast mode plus */
      UINT32_C(0x00000040),   /** @brief PB(8) fast mode plus */
      UINT32_C(0x00000080),   /** @brief PB(9) fm+ */
    };

    static const uint32_t SYSCFG_EXTICRX_EXTIX_MASK[4] = {
      UINT32_C(0x0000000F),   /** @brief EXTI x configuration (x = 0 to 3) */
      UINT32_C(0x000000F0),   /** @brief EXTI x configuration (x = 0 to 3) */
      UINT32_C(0x00000F00),   /** @brief EXTI x configuration (x = 0 to 3) */
      UINT32_C(0x0000F000),   /** @brief EXTI x configuration (x = 0 to 3) */
    };

    static const uint32_t SYSCFG_EXTICRX_EXTI1X_MASK[2] = {
      UINT32_C(0x00000F00),   /** @brief EXTI10 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    /** @subsection SYSCFG field mask definitions */

    static const uint32_t SYSCFG_PMCR_BOOSTE_MASK = UINT32_C(0x00000100);      /** @brief Booster enable */
    static const uint32_t SYSCFG_PMCR_EPIS_MASK = UINT32_C(0x00E00000);        /** @brief Ethernet PHY interface selection */
    static const uint32_t SYSCFG_PMCR_PA0SO_MASK = UINT32_C(0x01000000);       /** @brief PA0 switch open */
    static const uint32_t SYSCFG_PMCR_PA1SO_MASK = UINT32_C(0x02000000);       /** @brief PA1 switch open */
    static const uint32_t SYSCFG_PMCR_PC2SO_MASK = UINT32_C(0x04000000);       /** @brief PC2 switch open */
    static const uint32_t SYSCFG_PMCR_PC3SO_MASK = UINT32_C(0x08000000);       /** @brief PC3 switch open */
    static const uint32_t SYSCFG_CCCSR_EN_MASK = UINT32_C(0x00000001);         /** @brief Enable */
    static const uint32_t SYSCFG_CCCSR_CS_MASK = UINT32_C(0x00000002);         /** @brief Code selection */
    static const uint32_t SYSCFG_CCCSR_READY_MASK = UINT32_C(0x00000100);      /** @brief Compensation cell ready flag */
    static const uint32_t SYSCFG_CCCSR_HSLV_MASK = UINT32_C(0x00010000);       /** @brief High-speed at low-voltage */
    static const uint32_t SYSCFG_CCVR_NCV_MASK = UINT32_C(0x0000000F);         /** @brief NMOS compensation value */
    static const uint32_t SYSCFG_CCVR_PCV_MASK = UINT32_C(0x000000F0);         /** @brief PMOS compensation value */
    static const uint32_t SYSCFG_CCCR_NCC_MASK = UINT32_C(0x0000000F);         /** @brief NMOS compensation code */
    static const uint32_t SYSCFG_CCCR_PCC_MASK = UINT32_C(0x000000F0);         /** @brief PMOS compensation code */
    static const uint32_t SYSCFG_PKGR_PKG_MASK = UINT32_C(0x0000000F);         /** @brief Package */
    static const uint32_t SYSCFG_UR0_BKS_MASK = UINT32_C(0x00000001);          /** @brief Bank swap */
    static const uint32_t SYSCFG_UR0_RDP_MASK = UINT32_C(0x00FF0000);          /** @brief Readout protection */
    static const uint32_t SYSCFG_UR2_BORH_MASK = UINT32_C(0x00000003);         /** @brief BOR_LVL brownout reset threshold level */
    static const uint32_t SYSCFG_UR2_BOOT_ADD0_MASK = UINT32_C(0xFFFF0000);    /** @brief Boot address 0 */
    static const uint32_t SYSCFG_UR3_BOOT_ADD1_MASK = UINT32_C(0xFFFF0000);    /** @brief Boot address 1 */
    static const uint32_t SYSCFG_UR4_MEPAD_1_MASK = UINT32_C(0x00010000);      /** @brief Mass erase protected area disabled for bank 1 */
    static const uint32_t SYSCFG_UR5_MESAD_1_MASK = UINT32_C(0x00000001);      /** @brief Mass erase secured area disabled for bank 1 */
    static const uint32_t SYSCFG_UR5_WRPN_1_MASK = UINT32_C(0x00FF0000);       /** @brief Write protection for flash bank 1 */
    static const uint32_t SYSCFG_UR6_PA_BEG_1_MASK = UINT32_C(0x00000FFF);     /** @brief Protected area start address for bank 1 */
    static const uint32_t SYSCFG_UR6_PA_END_1_MASK = UINT32_C(0x0FFF0000);     /** @brief Protected area end address for bank 1 */
    static const uint32_t SYSCFG_UR7_SA_BEG_1_MASK = UINT32_C(0x00000FFF);     /** @brief Secured area start address for bank 1 */
    static const uint32_t SYSCFG_UR7_SA_END_1_MASK = UINT32_C(0x0FFF0000);     /** @brief Secured area end address for bank 1 */
    static const uint32_t SYSCFG_UR8_MEPAD_2_MASK = UINT32_C(0x00000001);      /** @brief Mass erase protected area disabled for bank 2 */
    static const uint32_t SYSCFG_UR8_MESAD_2_MASK = UINT32_C(0x00010000);      /** @brief Mass erase secured area disabled for bank 2 */
    static const uint32_t SYSCFG_UR9_WRPN_2_MASK = UINT32_C(0x000000FF);       /** @brief Write protection for flash bank 2 */
    static const uint32_t SYSCFG_UR9_PA_BEG_2_MASK = UINT32_C(0x0FFF0000);     /** @brief Protected area start address for bank 2 */
    static const uint32_t SYSCFG_UR10_PA_END_2_MASK = UINT32_C(0x00000FFF);    /** @brief Protected area end address for bank 2 */
    static const uint32_t SYSCFG_UR10_SA_BEG_2_MASK = UINT32_C(0x0FFF0000);    /** @brief Secured area start address for bank 2 */
    static const uint32_t SYSCFG_UR11_SA_END_2_MASK = UINT32_C(0x00000FFF);    /** @brief Secured area end address for bank 2 */
    static const uint32_t SYSCFG_UR11_IWDG1M_MASK = UINT32_C(0x00010000);      /** @brief Independent watchdog 1 mode */
    static const uint32_t SYSCFG_UR12_SECURE_MASK = UINT32_C(0x00010000);      /** @brief Secure mode */
    static const uint32_t SYSCFG_UR13_SDRS_MASK = UINT32_C(0x00000003);        /** @brief Secured DTCM RAM size */
    static const uint32_t SYSCFG_UR13_D1SBRST_MASK = UINT32_C(0x00010000);     /** @brief D1 standby reset */
    static const uint32_t SYSCFG_UR14_D1STPRST_MASK = UINT32_C(0x00000001);    /** @brief D1 stop reset */
    static const uint32_t SYSCFG_UR15_FZIWDGSTB_MASK = UINT32_C(0x00010000);   /** @brief Freeze independent watchdog in standby mode */
    static const uint32_t SYSCFG_UR1X_FZIWDGSTP_MASK = UINT32_C(0x00000001);   /** @brief Freeze independent watchdog in stop mode */
    static const uint32_t SYSCFG_UR1X_PKP_MASK = UINT32_C(0x00010000);         /** @brief Private key programmed */
    static const uint32_t SYSCFG_UR1X_IO_HSLV_MASK = UINT32_C(0x00000001);     /** @brief I/O high speed / low voltage */

    /** @subsection SYSCFG field position array definitions */

    static const int32_t SYSCFG_UR1X_I2CXFMP_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief I2C1 fm+ */
      INT32_C(1),    /** @brief I2C2 fm+ */
      INT32_C(2),    /** @brief I2C3 fm+ */
      INT32_C(3),    /** @brief I2C4 fm+ */
    };

    static const int32_t SYSCFG_UR1X_PBXFMP_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(4),    /** @brief PB(6) fm+ */
      INT32_C(5),    /** @brief PB(7) fast mode plus */
      INT32_C(6),    /** @brief PB(8) fast mode plus */
      INT32_C(7),    /** @brief PB(9) fm+ */
    };

    static const int32_t SYSCFG_UR1X_EXTIX_POS[4] = {
      INT32_C(0),    /** @brief EXTI x configuration (x = 0 to 3) */
      INT32_C(4),    /** @brief EXTI x configuration (x = 0 to 3) */
      INT32_C(8),    /** @brief EXTI x configuration (x = 0 to 3) */
      INT32_C(12),   /** @brief EXTI x configuration (x = 0 to 3) */
    };

    static const int32_t SYSCFG_UR1X_EXTI1X_POS[2] = {
      INT32_C(8),    /** @brief EXTI10 */
      INT32_C(-1),   /** @brief Invalid index. */
    };

    /** @subsection SYSCFG field position definitions */

    static const int32_t SYSCFG_UR1X_BOOSTE_POS = INT32_C(8);       /** @brief Booster enable */
    static const int32_t SYSCFG_UR1X_EPIS_POS = INT32_C(21);        /** @brief Ethernet PHY interface selection */
    static const int32_t SYSCFG_UR1X_PA0SO_POS = INT32_C(24);       /** @brief PA0 switch open */
    static const int32_t SYSCFG_UR1X_PA1SO_POS = INT32_C(25);       /** @brief PA1 switch open */
    static const int32_t SYSCFG_UR1X_PC2SO_POS = INT32_C(26);       /** @brief PC2 switch open */
    static const int32_t SYSCFG_UR1X_PC3SO_POS = INT32_C(27);       /** @brief PC3 switch open */
    static const int32_t SYSCFG_UR1X_EN_POS = INT32_C(0);           /** @brief Enable */
    static const int32_t SYSCFG_UR1X_CS_POS = INT32_C(1);           /** @brief Code selection */
    static const int32_t SYSCFG_UR1X_READY_POS = INT32_C(8);        /** @brief Compensation cell ready flag */
    static const int32_t SYSCFG_UR1X_HSLV_POS = INT32_C(16);        /** @brief High-speed at low-voltage */
    static const int32_t SYSCFG_UR1X_NCV_POS = INT32_C(0);          /** @brief NMOS compensation value */
    static const int32_t SYSCFG_UR1X_PCV_POS = INT32_C(4);          /** @brief PMOS compensation value */
    static const int32_t SYSCFG_UR1X_NCC_POS = INT32_C(0);          /** @brief NMOS compensation code */
    static const int32_t SYSCFG_UR1X_PCC_POS = INT32_C(4);          /** @brief PMOS compensation code */
    static const int32_t SYSCFG_UR1X_PKG_POS = INT32_C(0);          /** @brief Package */
    static const int32_t SYSCFG_UR1X_BKS_POS = INT32_C(0);          /** @brief Bank swap */
    static const int32_t SYSCFG_UR1X_RDP_POS = INT32_C(16);         /** @brief Readout protection */
    static const int32_t SYSCFG_UR1X_BORH_POS = INT32_C(0);         /** @brief BOR_LVL brownout reset threshold level */
    static const int32_t SYSCFG_UR1X_BOOT_ADD0_POS = INT32_C(16);   /** @brief Boot address 0 */
    static const int32_t SYSCFG_UR1X_BOOT_ADD1_POS = INT32_C(16);   /** @brief Boot address 1 */
    static const int32_t SYSCFG_UR1X_MEPAD_1_POS = INT32_C(16);     /** @brief Mass erase protected area disabled for bank 1 */
    static const int32_t SYSCFG_UR1X_MESAD_1_POS = INT32_C(0);      /** @brief Mass erase secured area disabled for bank 1 */
    static const int32_t SYSCFG_UR1X_WRPN_1_POS = INT32_C(16);      /** @brief Write protection for flash bank 1 */
    static const int32_t SYSCFG_UR1X_PA_BEG_1_POS = INT32_C(0);     /** @brief Protected area start address for bank 1 */
    static const int32_t SYSCFG_UR1X_PA_END_1_POS = INT32_C(16);    /** @brief Protected area end address for bank 1 */
    static const int32_t SYSCFG_UR1X_SA_BEG_1_POS = INT32_C(0);     /** @brief Secured area start address for bank 1 */
    static const int32_t SYSCFG_UR1X_SA_END_1_POS = INT32_C(16);    /** @brief Secured area end address for bank 1 */
    static const int32_t SYSCFG_UR1X_MEPAD_2_POS = INT32_C(0);      /** @brief Mass erase protected area disabled for bank 2 */
    static const int32_t SYSCFG_UR1X_MESAD_2_POS = INT32_C(16);     /** @brief Mass erase secured area disabled for bank 2 */
    static const int32_t SYSCFG_UR1X_WRPN_2_POS = INT32_C(0);       /** @brief Write protection for flash bank 2 */
    static const int32_t SYSCFG_UR1X_PA_BEG_2_POS = INT32_C(16);    /** @brief Protected area start address for bank 2 */
    static const int32_t SYSCFG_UR1X_PA_END_2_POS = INT32_C(0);     /** @brief Protected area end address for bank 2 */
    static const int32_t SYSCFG_UR1X_SA_BEG_2_POS = INT32_C(16);    /** @brief Secured area start address for bank 2 */
    static const int32_t SYSCFG_UR1X_SA_END_2_POS = INT32_C(0);     /** @brief Secured area end address for bank 2 */
    static const int32_t SYSCFG_UR1X_IWDG1M_POS = INT32_C(16);      /** @brief Independent watchdog 1 mode */
    static const int32_t SYSCFG_UR1X_SECURE_POS = INT32_C(16);      /** @brief Secure mode */
    static const int32_t SYSCFG_UR1X_SDRS_POS = INT32_C(0);         /** @brief Secured DTCM RAM size */
    static const int32_t SYSCFG_UR1X_D1SBRST_POS = INT32_C(16);     /** @brief D1 standby reset */
    static const int32_t SYSCFG_UR1X_D1STPRST_POS = INT32_C(0);     /** @brief D1 stop reset */
    static const int32_t SYSCFG_UR1X_FZIWDGSTB_POS = INT32_C(16);   /** @brief Freeze independent watchdog in standby mode */
    static const int32_t SYSCFG_UR1X_FZIWDGSTP_POS = INT32_C(0);    /** @brief Freeze independent watchdog in stop mode */
    static const int32_t SYSCFG_UR1X_PKP_POS = INT32_C(16);         /** @brief Private key programmed */
    static const int32_t SYSCFG_UR1X_IO_HSLV_POS = INT32_C(0);      /** @brief I/O high speed / low voltage */

    /**********************************************************************************************
     * @section EXTI Definitions
     **********************************************************************************************/

    /** @subsection EXTI IRQ interrupt array definitions */

    static const int32_t EXTIX_IRQ[5] = {
      INT32_C(6),     /** @brief EXTI line 0 interrupt */
      INT32_C(7),     /** @brief EXTI line 1 interrupt */
      INT32_C(8),     /** @brief EXTI line 2 interrupt */
      INT32_C(9),     /** @brief EXTI line 3interrupt */
      INT32_C(10),    /** @brief EXTI line 4interrupt */
    };

    /** @subsection EXTI IRQ interrupt definitions */

    static const int32_t PVD_PVM_IRQ = INT32_C(1);        /** @brief PVD through EXTI line */
    static const int32_t EXTI9_5_IRQ = INT32_C(23);       /** @brief EXTI line[9:5] interrupts */
    static const int32_t EXTI15_10_IRQ = INT32_C(40);     /** @brief EXTI line[15:10] interrupts */
    static const int32_t CM4_SEV_IT_IRQ = INT32_C(65);    /** @brief Arm cortex-m4 send even interrupt */
    static const int32_t WKUP_IRQ = INT32_C(149);         /** @brief WKUP1 to WKUP6 pins */
    static const int32_t HOLD_CORE_IRQ = INT32_C(148);    /** @brief CPU1 hold */

    /** @subsection EXTI register definitions */

    static _RW uint32_t* const EXTI_RTSR1_REG = (_RW uint32_t* const)UINT32_C(0x58000000);     /** @brief EXTI rising trigger selection register */
    static _RW uint32_t* const EXTI_FTSR1_REG = (_RW uint32_t* const)UINT32_C(0x58000004);     /** @brief EXTI falling trigger selection register */
    static _RW uint32_t* const EXTI_SWIER1_REG = (_RW uint32_t* const)UINT32_C(0x58000008);    /** @brief EXTI software interrupt event register */
    static _RW uint32_t* const EXTI_D3PMR1_REG = (_RW uint32_t* const)UINT32_C(0x5800000C);    /** @brief EXTI D3 pending mask register */
    static _RW uint32_t* const EXTI_D3PCR1L_REG = (_RW uint32_t* const)UINT32_C(0x58000010);   /** @brief EXTI D3 pending clear selection register low */
    static _RW uint32_t* const EXTI_D3PCR1H_REG = (_RW uint32_t* const)UINT32_C(0x58000014);   /** @brief EXTI D3 pending clear selection register high */
    static _RW uint32_t* const EXTI_RTSR2_REG = (_RW uint32_t* const)UINT32_C(0x58000020);     /** @brief EXTI rising trigger selection register */
    static _RW uint32_t* const EXTI_FTSR2_REG = (_RW uint32_t* const)UINT32_C(0x58000024);     /** @brief EXTI falling trigger selection register */
    static _RW uint32_t* const EXTI_SWIER2_REG = (_RW uint32_t* const)UINT32_C(0x58000028);    /** @brief EXTI software interrupt event register */
    static _RW uint32_t* const EXTI_D3PMR2_REG = (_RW uint32_t* const)UINT32_C(0x5800002C);    /** @brief EXTI D3 pending mask register */
    static _RW uint32_t* const EXTI_D3PCR2L_REG = (_RW uint32_t* const)UINT32_C(0x58000030);   /** @brief EXTI D3 pending clear selection register low */
    static _RW uint32_t* const EXTI_D3PCR2H_REG = (_RW uint32_t* const)UINT32_C(0x58000034);   /** @brief EXTI D3 pending clear selection register high */
    static _RW uint32_t* const EXTI_RTSR3_REG = (_RW uint32_t* const)UINT32_C(0x58000040);     /** @brief EXTI rising trigger selection register */
    static _RW uint32_t* const EXTI_FTSR3_REG = (_RW uint32_t* const)UINT32_C(0x58000044);     /** @brief EXTI falling trigger selection register */
    static _RW uint32_t* const EXTI_SWIER3_REG = (_RW uint32_t* const)UINT32_C(0x58000048);    /** @brief EXTI software interrupt event register */
    static _RW uint32_t* const EXTI_D3PMR3_REG = (_RW uint32_t* const)UINT32_C(0x5800004C);    /** @brief EXTI D3 pending mask register */
    static _RW uint32_t* const EXTI_D3PCR3H_REG = (_RW uint32_t* const)UINT32_C(0x58000054);   /** @brief EXTI D3 pending clear selection register high */
    static _RW uint32_t* const EXTI_CPUIMR1_REG = (_RW uint32_t* const)UINT32_C(0x58000080);   /** @brief EXTI interrupt mask register */
    static _RW uint32_t* const EXTI_CPUEMR1_REG = (_RW uint32_t* const)UINT32_C(0x58000084);   /** @brief EXTI event mask register */
    static _RW uint32_t* const EXTI_CPUPR1_REG = (_RW uint32_t* const)UINT32_C(0x58000088);    /** @brief EXTI pending register */
    static _RW uint32_t* const EXTI_CPUIMR2_REG = (_RW uint32_t* const)UINT32_C(0x58000090);   /** @brief EXTI interrupt mask register */
    static _RW uint32_t* const EXTI_CPUEMR2_REG = (_RW uint32_t* const)UINT32_C(0x58000094);   /** @brief EXTI event mask register */
    static _RO uint32_t* const EXTI_CPUPR2_REG = (_RO uint32_t* const)UINT32_C(0x58000098);    /** @brief EXTI pending register */
    static _RO uint32_t* const EXTI_CPUIMR3_REG = (_RO uint32_t* const)UINT32_C(0x580000A0);   /** @brief EXTI interrupt mask register */
    static _RO uint32_t* const EXTI_CPUEMR3_REG = (_RO uint32_t* const)UINT32_C(0x580000A4);   /** @brief EXTI event mask register */
    static _RO uint32_t* const EXTI_CPUPR3_REG = (_RO uint32_t* const)UINT32_C(0x580000A8);    /** @brief EXTI pending register */

    /** @subsection EXTI field mask array definitions */

    static const uint32_t EXTI_RTSR1_TRX_MASK[22] = {
      UINT32_C(0x00000001),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000002),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000004),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000008),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000010),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000020),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000040),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000080),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000100),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000200),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000400),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000800),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00001000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00002000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00004000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00008000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00010000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00020000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00040000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00080000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00100000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00200000),   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const uint32_t EXTI_SWIER1_SWIERX_MASK[22] = {
      UINT32_C(0x00000001),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000002),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000004),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000008),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000010),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000020),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000040),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000080),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000100),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000200),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000400),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000800),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00001000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00002000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00004000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00008000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00010000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00020000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00040000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00080000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00100000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00200000),   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const uint32_t EXTI_D3PMR1_MRX_MASK[26] = {
      UINT32_C(0x00000001),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000002),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000004),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000008),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000010),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000020),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000040),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000080),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000100),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000200),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000400),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000800),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00001000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00002000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00004000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00008000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00080000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00100000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00200000),   /** @brief Rising trigger event configuration bit of configurable event input */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x02000000),   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const uint32_t EXTI_D3PCR1L_PCSX_MASK[16] = {
      UINT32_C(0x00000003),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x0000000C),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x00000030),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x000000C0),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x00000300),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x00000C00),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x00003000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x0000C000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x00030000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x000C0000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x00300000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x00C00000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x03000000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x0C000000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0x30000000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      UINT32_C(0xC0000000),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    };

    static const uint32_t EXTI_D3PMR2_MR3X_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief D3 pending mask on event input x+32 */
    };

    static const uint32_t EXTI_D3PCR2L_PCS3X_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000030),   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+64)/2) */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static const uint32_t EXTI_D3PCR2H_PCS4X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000000C),   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
    };

    static const uint32_t EXTI_RTSR3_TR8X_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00040000),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00100000),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      UINT32_C(0x00200000),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      UINT32_C(0x00400000),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
    };

    static const uint32_t EXTI_SWIER3_SWIER8X_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00040000),   /** @brief Software interrupt on line x+64 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00100000),   /** @brief Software interrupt on line x+64 */
      UINT32_C(0x00200000),   /** @brief Software interrupt on line x+64 */
      UINT32_C(0x00400000),   /** @brief Software interrupt on line x+64 */
    };

    static const uint32_t EXTI_CPUPR1_PRX_MASK[22] = {
      UINT32_C(0x00000001),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000002),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000004),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000008),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000010),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000020),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000040),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000080),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000100),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000200),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000400),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00000800),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00001000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00002000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00004000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00008000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00010000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00020000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00040000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00080000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00100000),   /** @brief CPU event mask on event input x */
      UINT32_C(0x00200000),   /** @brief CPU event mask on event input x */
    };

    static const uint32_t EXTI_CPUIMR3_MR6X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief CPU interrupt mask on direct event input x+64 */
      UINT32_C(0x00000004),   /** @brief CPU interrupt mask on direct event input x+64 */
      UINT32_C(0x00000008),   /** @brief CPU interrupt mask on direct event input x+64 */
      UINT32_C(0x00000010),   /** @brief CPU interrupt mask on direct event input x+64 */
      UINT32_C(0x00000020),   /** @brief CPU interrupt mask on direct event input x+64 */
    };

    static const uint32_t EXTI_CPUPR3_PR8X_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00040000),   /** @brief Configurable event inputs x+64 pending bit */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00100000),   /** @brief Configurable event inputs x+64 pending bit */
      UINT32_C(0x00200000),   /** @brief Configurable event inputs x+64 pending bit */
      UINT32_C(0x00400000),   /** @brief Configurable event inputs x+64 pending bit */
    };

    /** @subsection EXTI field mask definitions */

    static const uint32_t EXTI_RTSR2_TR49_MASK = UINT32_C(0x00020000);       /** @brief Rising trigger event configuration bit of configurable event input x+32 */
    static const uint32_t EXTI_RTSR2_TR51_MASK = UINT32_C(0x00080000);       /** @brief Rising trigger event configuration bit of configurable event input x+32 */
    static const uint32_t EXTI_FTSR2_TR49_MASK = UINT32_C(0x00020000);       /** @brief Falling trigger event configuration bit of configurable event input x+32 */
    static const uint32_t EXTI_FTSR2_TR51_MASK = UINT32_C(0x00080000);       /** @brief Falling trigger event configuration bit of configurable event input x+32 */
    static const uint32_t EXTI_SWIER2_SWIER49_MASK = UINT32_C(0x00020000);   /** @brief Software interrupt on line x+32 */
    static const uint32_t EXTI_SWIER2_SWIER51_MASK = UINT32_C(0x00080000);   /** @brief Software interrupt on line x+32 */
    static const uint32_t EXTI_D3PMR3_MR88_MASK = UINT32_C(0x01000000);      /** @brief D3 pending mask on event input x+64 */
    static const uint32_t EXTI_D3PCR3H_PCS88_MASK = UINT32_C(0x000C0000);    /** @brief D3 pending request clear input signal selection on event input x= truncate N+160/2 */
    static const uint32_t EXTI_CPUPR2_PR49_MASK = UINT32_C(0x00020000);      /** @brief Configurable event inputs x+32 pending bit */
    static const uint32_t EXTI_CPUPR2_PR51_MASK = UINT32_C(0x00080000);      /** @brief Configurable event inputs x+32 pending bit */

    /** @subsection EXTI field position array definitions */

    static const int32_t EXTI_CPUPR3_TRX_POS[22] = {
      INT32_C(0),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(1),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(2),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(3),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(4),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(5),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(6),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(7),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(8),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(9),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(10),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(11),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(12),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(13),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(14),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(15),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(16),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(17),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(18),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(19),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(20),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(21),   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const int32_t EXTI_CPUPR3_SWIERX_POS[22] = {
      INT32_C(0),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(1),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(2),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(3),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(4),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(5),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(6),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(7),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(8),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(9),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(10),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(11),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(12),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(13),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(14),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(15),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(16),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(17),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(18),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(19),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(20),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(21),   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const int32_t EXTI_CPUPR3_MRX_POS[26] = {
      INT32_C(0),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(1),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(2),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(3),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(4),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(5),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(6),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(7),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(8),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(9),    /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(10),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(11),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(12),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(13),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(14),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(15),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(19),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(20),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(21),   /** @brief Rising trigger event configuration bit of configurable event input */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(25),   /** @brief Rising trigger event configuration bit of configurable event input */
    };

    static const int32_t EXTI_CPUPR3_PCSX_POS[16] = {
      INT32_C(0),    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(2),    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(4),    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(6),    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(8),    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(10),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(12),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(14),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(16),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(18),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(20),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(22),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(24),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(26),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(28),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      INT32_C(30),   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    };

    static const int32_t EXTI_CPUPR3_MR3X_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief D3 pending mask on event input x+32 */
    };

    static const int32_t EXTI_CPUPR3_PCS3X_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(4),    /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+64)/2) */
      INT32_C(-1),   /** @brief Invalid index. */
    };

    static const int32_t EXTI_CPUPR3_PCS4X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(2),    /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
    };

    static const int32_t EXTI_CPUPR3_TR8X_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(18),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(20),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      INT32_C(21),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      INT32_C(22),   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
    };

    static const int32_t EXTI_CPUPR3_SWIER8X_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(18),   /** @brief Software interrupt on line x+64 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(20),   /** @brief Software interrupt on line x+64 */
      INT32_C(21),   /** @brief Software interrupt on line x+64 */
      INT32_C(22),   /** @brief Software interrupt on line x+64 */
    };

    static const int32_t EXTI_CPUPR3_PRX_POS[22] = {
      INT32_C(0),    /** @brief CPU event mask on event input x */
      INT32_C(1),    /** @brief CPU event mask on event input x */
      INT32_C(2),    /** @brief CPU event mask on event input x */
      INT32_C(3),    /** @brief CPU event mask on event input x */
      INT32_C(4),    /** @brief CPU event mask on event input x */
      INT32_C(5),    /** @brief CPU event mask on event input x */
      INT32_C(6),    /** @brief CPU event mask on event input x */
      INT32_C(7),    /** @brief CPU event mask on event input x */
      INT32_C(8),    /** @brief CPU event mask on event input x */
      INT32_C(9),    /** @brief CPU event mask on event input x */
      INT32_C(10),   /** @brief CPU event mask on event input x */
      INT32_C(11),   /** @brief CPU event mask on event input x */
      INT32_C(12),   /** @brief CPU event mask on event input x */
      INT32_C(13),   /** @brief CPU event mask on event input x */
      INT32_C(14),   /** @brief CPU event mask on event input x */
      INT32_C(15),   /** @brief CPU event mask on event input x */
      INT32_C(16),   /** @brief CPU event mask on event input x */
      INT32_C(17),   /** @brief CPU event mask on event input x */
      INT32_C(18),   /** @brief CPU event mask on event input x */
      INT32_C(19),   /** @brief CPU event mask on event input x */
      INT32_C(20),   /** @brief CPU event mask on event input x */
      INT32_C(21),   /** @brief CPU event mask on event input x */
    };

    static const int32_t EXTI_CPUPR3_MR6X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief CPU interrupt mask on direct event input x+64 */
      INT32_C(2),    /** @brief CPU interrupt mask on direct event input x+64 */
      INT32_C(3),    /** @brief CPU interrupt mask on direct event input x+64 */
      INT32_C(4),    /** @brief CPU interrupt mask on direct event input x+64 */
      INT32_C(5),    /** @brief CPU interrupt mask on direct event input x+64 */
    };

    static const int32_t EXTI_CPUPR3_PR8X_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(18),   /** @brief Configurable event inputs x+64 pending bit */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(20),   /** @brief Configurable event inputs x+64 pending bit */
      INT32_C(21),   /** @brief Configurable event inputs x+64 pending bit */
      INT32_C(22),   /** @brief Configurable event inputs x+64 pending bit */
    };

    /** @subsection EXTI field position definitions */

    static const int32_t EXTI_CPUPR3_TR49_POS = INT32_C(17);      /** @brief Rising trigger event configuration bit of configurable event input x+32 */
    static const int32_t EXTI_CPUPR3_TR51_POS = INT32_C(19);      /** @brief Rising trigger event configuration bit of configurable event input x+32 */
    static const int32_t EXTI_CPUPR3_TR49_POS = INT32_C(17);      /** @brief Falling trigger event configuration bit of configurable event input x+32 */
    static const int32_t EXTI_CPUPR3_TR51_POS = INT32_C(19);      /** @brief Falling trigger event configuration bit of configurable event input x+32 */
    static const int32_t EXTI_CPUPR3_SWIER49_POS = INT32_C(17);   /** @brief Software interrupt on line x+32 */
    static const int32_t EXTI_CPUPR3_SWIER51_POS = INT32_C(19);   /** @brief Software interrupt on line x+32 */
    static const int32_t EXTI_CPUPR3_MR88_POS = INT32_C(24);      /** @brief D3 pending mask on event input x+64 */
    static const int32_t EXTI_CPUPR3_PCS88_POS = INT32_C(18);     /** @brief D3 pending request clear input signal selection on event input x= truncate N+160/2 */
    static const int32_t EXTI_CPUPR3_PR49_POS = INT32_C(17);      /** @brief Configurable event inputs x+32 pending bit */
    static const int32_t EXTI_CPUPR3_PR51_POS = INT32_C(19);      /** @brief Configurable event inputs x+32 pending bit */

    /**********************************************************************************************
     * @section DELAY_BLOCK_SDMMCX Definitions
     **********************************************************************************************/

    /** @subsection DELAY_BLOCK_SDMMCX register array definitions */

    static _RW uint32_t* const DELAY_BLOCK_SDMMCX_CR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52008000),   /** @brief DLYB control register */
      (_RW uint32_t* const)UINT32_C(0x48022800),   /** @brief DLYB control register */
    };

    static _RW uint32_t* const DELAY_BLOCK_SDMMCX_CFGR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52008004),   /** @brief DLYB configuration register */
      (_RW uint32_t* const)UINT32_C(0x48022804),   /** @brief DLYB configuration register */
    };

    /** @subsection DELAY_BLOCK_SDMMCX field mask definitions */

    static const uint32_t DELAY_BLOCK_SDMMCX_CR_DEN_MASK = UINT32_C(0x00000001);      /** @brief Delay block enable bit */
    static const uint32_t DELAY_BLOCK_SDMMCX_CR_SEN_MASK = UINT32_C(0x00000002);      /** @brief Sampler length enable bit */
    static const uint32_t DELAY_BLOCK_SDMMCX_CFGR_SEL_MASK = UINT32_C(0x0000000F);    /** @brief Select the phase for the output clock */
    static const uint32_t DELAY_BLOCK_SDMMCX_CFGR_UNIT_MASK = UINT32_C(0x00007F00);   /** @brief Delay defines the delay of a unit delay cell */
    static const uint32_t DELAY_BLOCK_SDMMCX_CFGR_LNG_MASK = UINT32_C(0x0FFF0000);    /** @brief Delay line length value */
    static const uint32_t DELAY_BLOCK_SDMMCX_CFGR_LNGF_MASK = UINT32_C(0x80000000);   /** @brief Length valid flag */

    /** @subsection DELAY_BLOCK_SDMMCX field position definitions */

    static const int32_t DELAY_BLOCK_SDMMCX_CFGR_DEN_POS = INT32_C(0);     /** @brief Delay block enable bit */
    static const int32_t DELAY_BLOCK_SDMMCX_CFGR_SEN_POS = INT32_C(1);     /** @brief Sampler length enable bit */
    static const int32_t DELAY_BLOCK_SDMMCX_CFGR_SEL_POS = INT32_C(0);     /** @brief Select the phase for the output clock */
    static const int32_t DELAY_BLOCK_SDMMCX_CFGR_UNIT_POS = INT32_C(8);    /** @brief Delay defines the delay of a unit delay cell */
    static const int32_t DELAY_BLOCK_SDMMCX_CFGR_LNG_POS = INT32_C(16);    /** @brief Delay line length value */
    static const int32_t DELAY_BLOCK_SDMMCX_CFGR_LNGF_POS = INT32_C(31);   /** @brief Length valid flag */

    /**********************************************************************************************
     * @section DELAY_BLOCK_QUADSPI Definitions
     **********************************************************************************************/

    /** @subsection DELAY_BLOCK_QUADSPI register definitions */

    static _RW uint32_t* const DELAY_BLOCK_QUADSPI_CR_REG = (_RW uint32_t* const)UINT32_C(0x52006000);     /** @brief DLYB control register */
    static _RW uint32_t* const DELAY_BLOCK_QUADSPI_CFGR_REG = (_RW uint32_t* const)UINT32_C(0x52006004);   /** @brief DLYB configuration register */

    /** @subsection DELAY_BLOCK_QUADSPI field mask definitions */

    static const uint32_t DELAY_BLOCK_QUADSPI_CR_DEN_MASK = UINT32_C(0x00000001);      /** @brief Delay block enable bit */
    static const uint32_t DELAY_BLOCK_QUADSPI_CR_SEN_MASK = UINT32_C(0x00000002);      /** @brief Sampler length enable bit */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_SEL_MASK = UINT32_C(0x0000000F);    /** @brief Select the phase for the output clock */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_UNIT_MASK = UINT32_C(0x00007F00);   /** @brief Delay defines the delay of a unit delay cell */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_LNG_MASK = UINT32_C(0x0FFF0000);    /** @brief Delay line length value */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF_MASK = UINT32_C(0x80000000);   /** @brief Length valid flag */

    /** @subsection DELAY_BLOCK_QUADSPI field position definitions */

    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_DEN_POS = INT32_C(0);     /** @brief Delay block enable bit */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_SEN_POS = INT32_C(1);     /** @brief Sampler length enable bit */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_SEL_POS = INT32_C(0);     /** @brief Select the phase for the output clock */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_UNIT_POS = INT32_C(8);    /** @brief Delay defines the delay of a unit delay cell */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_LNG_POS = INT32_C(16);    /** @brief Delay line length value */
    static const int32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF_POS = INT32_C(31);   /** @brief Length valid flag */

    /**********************************************************************************************
     * @section FLASH Definitions
     **********************************************************************************************/

    /** @subsection FLASH IRQ interrupt definitions */

    static const int32_t FLASH_IRQ = INT32_C(4);   /** @brief Flash memory */

    /** @subsection FLASH register definitions */

    static _RW uint32_t* const FLASH_ACR_REG = (_RW uint32_t* const)UINT32_C(0x52002000);          /** @brief Access control register */
    static _RW uint32_t* const FLASH_ACR__REG = (_RW uint32_t* const)UINT32_C(0x52002100);         /** @brief Access control register */
    static _RW uint32_t* const FLASH_KEYR1_REG = (_RW uint32_t* const)UINT32_C(0x52002004);        /** @brief FLASH key register for bank 1 */
    static _RW uint32_t* const FLASH_OPTKEYR_REG = (_RW uint32_t* const)UINT32_C(0x52002008);      /** @brief FLASH option key register */
    static _RW uint32_t* const FLASH_OPTKEYR__REG = (_RW uint32_t* const)UINT32_C(0x52002108);     /** @brief FLASH option key register */
    static _RW uint32_t* const FLASH_CR1_REG = (_RW uint32_t* const)UINT32_C(0x5200200C);          /** @brief FLASH control register for bank 1 */
    static _RW uint32_t* const FLASH_SR1_REG = (_RW uint32_t* const)UINT32_C(0x52002010);          /** @brief FLASH status register for bank 1 */
    static _RW uint32_t* const FLASH_CCR1_REG = (_RW uint32_t* const)UINT32_C(0x52002014);         /** @brief FLASH clear control register for bank 1 */
    static _RW uint32_t* const FLASH_OPTCR_REG = (_RW uint32_t* const)UINT32_C(0x52002018);        /** @brief FLASH option control register */
    static _RW uint32_t* const FLASH_OPTCR__REG = (_RW uint32_t* const)UINT32_C(0x52002118);       /** @brief FLASH option control register */
    static _RW uint32_t* const FLASH_OPTSR_CUR__REG = (_RW uint32_t* const)UINT32_C(0x5200211C);   /** @brief FLASH option status register */
    static _RW uint32_t* const FLASH_OPTSR_CUR_REG = (_RW uint32_t* const)UINT32_C(0x5200201C);    /** @brief FLASH option status register */
    static _RW uint32_t* const FLASH_OPTSR_PRG_REG = (_RW uint32_t* const)UINT32_C(0x52002020);    /** @brief FLASH option status register */
    static _RW uint32_t* const FLASH_OPTSR_PRG__REG = (_RW uint32_t* const)UINT32_C(0x52002120);   /** @brief FLASH option status register */
    static _RW uint32_t* const FLASH_OPTCCR__REG = (_RW uint32_t* const)UINT32_C(0x52002124);      /** @brief FLASH option clear control register */
    static _RW uint32_t* const FLASH_OPTCCR_REG = (_RW uint32_t* const)UINT32_C(0x52002024);       /** @brief FLASH option clear control register */
    static _RO uint32_t* const FLASH_PRAR_CUR1_REG = (_RO uint32_t* const)UINT32_C(0x52002028);    /** @brief FLASH protection address for bank 1 */
    static _RW uint32_t* const FLASH_PRAR_PRG1_REG = (_RW uint32_t* const)UINT32_C(0x5200202C);    /** @brief FLASH protection address for bank 1 */
    static _RW uint32_t* const FLASH_SCAR_CUR1_REG = (_RW uint32_t* const)UINT32_C(0x52002030);    /** @brief FLASH secure address for bank 1 */
    static _RW uint32_t* const FLASH_SCAR_PRG1_REG = (_RW uint32_t* const)UINT32_C(0x52002034);    /** @brief FLASH secure address for bank 1 */
    static _RO uint32_t* const FLASH_WPSN_CUR1R_REG = (_RO uint32_t* const)UINT32_C(0x52002038);   /** @brief FLASH write sector protection for bank 1 */
    static _RW uint32_t* const FLASH_WPSN_PRG1R_REG = (_RW uint32_t* const)UINT32_C(0x5200203C);   /** @brief FLASH write sector protection for bank 1 */
    static _RO uint32_t* const FLASH_BOOT_CURR_REG = (_RO uint32_t* const)UINT32_C(0x52002040);    /** @brief FLASH register with boot address */
    static _RO uint32_t* const FLASH_BOOT_PRGR_REG = (_RO uint32_t* const)UINT32_C(0x52002044);    /** @brief FLASH register with boot address */
    static _RW uint32_t* const FLASH_CRCCR1_REG = (_RW uint32_t* const)UINT32_C(0x52002050);       /** @brief FLASH CRC control register for bank 1 */
    static _RW uint32_t* const FLASH_CRCSADD1R_REG = (_RW uint32_t* const)UINT32_C(0x52002054);    /** @brief FLASH CRC start address register for bank 1 */
    static _RW uint32_t* const FLASH_CRCEADD1R_REG = (_RW uint32_t* const)UINT32_C(0x52002058);    /** @brief FLASH CRC end address register for bank 1 */
    static _RW uint32_t* const FLASH_CRCDATAR_REG = (_RW uint32_t* const)UINT32_C(0x5200205C);     /** @brief FLASH CRC data register */
    static _RO uint32_t* const FLASH_ECC_FA1R_REG = (_RO uint32_t* const)UINT32_C(0x52002060);     /** @brief FLASH ECC fail address for bank 1 */
    static _RO uint32_t* const FLASH_KEYR2_REG = (_RO uint32_t* const)UINT32_C(0x52002104);        /** @brief FLASH key register for bank 2 */
    static _RW uint32_t* const FLASH_CR2_REG = (_RW uint32_t* const)UINT32_C(0x5200210C);          /** @brief FLASH control register for bank 2 */
    static _RW uint32_t* const FLASH_SR2_REG = (_RW uint32_t* const)UINT32_C(0x52002110);          /** @brief FLASH status register for bank 2 */
    static _RW uint32_t* const FLASH_CCR2_REG = (_RW uint32_t* const)UINT32_C(0x52002114);         /** @brief FLASH clear control register for bank 2 */
    static _RO uint32_t* const FLASH_PRAR_CUR2_REG = (_RO uint32_t* const)UINT32_C(0x52002128);    /** @brief FLASH protection address for bank 1 */
    static _RW uint32_t* const FLASH_PRAR_PRG2_REG = (_RW uint32_t* const)UINT32_C(0x5200202C);    /** @brief FLASH protection address for bank 2 */
    static _RW uint32_t* const FLASH_SCAR_CUR2_REG = (_RW uint32_t* const)UINT32_C(0x52002130);    /** @brief FLASH secure address for bank 2 */
    static _RW uint32_t* const FLASH_SCAR_PRG2_REG = (_RW uint32_t* const)UINT32_C(0x52002134);    /** @brief FLASH secure address for bank 2 */
    static _RO uint32_t* const FLASH_WPSN_CUR2R_REG = (_RO uint32_t* const)UINT32_C(0x52002138);   /** @brief FLASH write sector protection for bank 2 */
    static _RW uint32_t* const FLASH_WPSN_PRG2R_REG = (_RW uint32_t* const)UINT32_C(0x5200213C);   /** @brief FLASH write sector protection for bank 2 */
    static _RW uint32_t* const FLASH_CRCCR2_REG = (_RW uint32_t* const)UINT32_C(0x52002150);       /** @brief FLASH CRC control register for bank 1 */
    static _RW uint32_t* const FLASH_CRCSADD2R_REG = (_RW uint32_t* const)UINT32_C(0x52002154);    /** @brief FLASH CRC start address register for bank 2 */
    static _RW uint32_t* const FLASH_CRCEADD2R_REG = (_RW uint32_t* const)UINT32_C(0x52002158);    /** @brief FLASH CRC end address register for bank 2 */
    static _RO uint32_t* const FLASH_ECC_FA2R_REG = (_RO uint32_t* const)UINT32_C(0x52002160);     /** @brief FLASH ECC fail address for bank 2 */

    /** @subsection FLASH field mask definitions */

    static const uint32_t FLASH_ACR_LATENCY_MASK = UINT32_C(0x00000007);                  /** @brief Read latency */
    static const uint32_t FLASH_ACR_WRHIGHFREQ_MASK = UINT32_C(0x00000030);               /** @brief Flash signal delay */
    static const uint32_t FLASH_ACR__LATENCY_MASK = UINT32_C(0x00000007);                 /** @brief Read latency */
    static const uint32_t FLASH_ACR__WRHIGHFREQ_MASK = UINT32_C(0x00000030);              /** @brief Flash signal delay */
    static const uint32_t FLASH_CR1_LOCK1_MASK = UINT32_C(0x00000001);                    /** @brief Bank 1 configuration lock bit */
    static const uint32_t FLASH_CR1_PG1_MASK = UINT32_C(0x00000002);                      /** @brief Bank 1 program enable bit */
    static const uint32_t FLASH_CR1_SER1_MASK = UINT32_C(0x00000004);                     /** @brief Bank 1 sector erase request */
    static const uint32_t FLASH_CR1_BER1_MASK = UINT32_C(0x00000008);                     /** @brief Bank 1 erase request */
    static const uint32_t FLASH_CR1_PSIZE1_MASK = UINT32_C(0x00000030);                   /** @brief Bank 1 program size */
    static const uint32_t FLASH_CR1_FW1_MASK = UINT32_C(0x00000040);                      /** @brief Bank 1 write forcing control bit */
    static const uint32_t FLASH_CR1_START1_MASK = UINT32_C(0x00000080);                   /** @brief Bank 1 bank or sector erase start control bit */
    static const uint32_t FLASH_CR1_SNB1_MASK = UINT32_C(0x00000700);                     /** @brief Bank 1 sector erase selection number */
    static const uint32_t FLASH_CR1_CRC_EN_MASK = UINT32_C(0x00008000);                   /** @brief Bank 1 CRC control bit */
    static const uint32_t FLASH_CR1_EOPIE1_MASK = UINT32_C(0x00010000);                   /** @brief Bank 1 end-of-program interrupt control bit */
    static const uint32_t FLASH_CR1_WRPERRIE1_MASK = UINT32_C(0x00020000);                /** @brief Bank 1 write protection error interrupt enable bit */
    static const uint32_t FLASH_CR1_PGSERRIE1_MASK = UINT32_C(0x00040000);                /** @brief Bank 1 programming sequence error interrupt enable bit */
    static const uint32_t FLASH_CR1_STRBERRIE1_MASK = UINT32_C(0x00080000);               /** @brief Bank 1 strobe error interrupt enable bit */
    static const uint32_t FLASH_CR1_INCERRIE1_MASK = UINT32_C(0x00200000);                /** @brief Bank 1 inconsistency error interrupt enable bit */
    static const uint32_t FLASH_CR1_OPERRIE1_MASK = UINT32_C(0x00400000);                 /** @brief Bank 1 write/erase error interrupt enable bit */
    static const uint32_t FLASH_CR1_RDPERRIE1_MASK = UINT32_C(0x00800000);                /** @brief Bank 1 read protection error interrupt enable bit */
    static const uint32_t FLASH_CR1_RDSERRIE1_MASK = UINT32_C(0x01000000);                /** @brief Bank 1 secure error interrupt enable bit */
    static const uint32_t FLASH_CR1_SNECCERRIE1_MASK = UINT32_C(0x02000000);              /** @brief Bank 1 ECC single correction error interrupt enable bit */
    static const uint32_t FLASH_CR1_DBECCERRIE1_MASK = UINT32_C(0x04000000);              /** @brief Bank 1 ECC double detection error interrupt enable bit */
    static const uint32_t FLASH_CR1_CRCENDIE1_MASK = UINT32_C(0x08000000);                /** @brief Bank 1 end of CRC calculation interrupt enable bit */
    static const uint32_t FLASH_SR1_BSY1_MASK = UINT32_C(0x00000001);                     /** @brief Bank 1 ongoing program flag */
    static const uint32_t FLASH_SR1_WBNE1_MASK = UINT32_C(0x00000002);                    /** @brief Bank 1 write buffer not empty flag */
    static const uint32_t FLASH_SR1_QW1_MASK = UINT32_C(0x00000004);                      /** @brief Bank 1 wait queue flag */
    static const uint32_t FLASH_SR1_CRC_BUSY1_MASK = UINT32_C(0x00000008);                /** @brief Bank 1 CRC busy flag */
    static const uint32_t FLASH_SR1_EOP1_MASK = UINT32_C(0x00010000);                     /** @brief Bank 1 end-of-program flag */
    static const uint32_t FLASH_SR1_WRPERR1_MASK = UINT32_C(0x00020000);                  /** @brief Bank 1 write protection error flag */
    static const uint32_t FLASH_SR1_PGSERR1_MASK = UINT32_C(0x00040000);                  /** @brief Bank 1 programming sequence error flag */
    static const uint32_t FLASH_SR1_STRBERR1_MASK = UINT32_C(0x00080000);                 /** @brief Bank 1 strobe error flag */
    static const uint32_t FLASH_SR1_INCERR1_MASK = UINT32_C(0x00200000);                  /** @brief Bank 1 inconsistency error flag */
    static const uint32_t FLASH_SR1_OPERR1_MASK = UINT32_C(0x00400000);                   /** @brief Bank 1 write/erase error flag */
    static const uint32_t FLASH_SR1_RDPERR1_MASK = UINT32_C(0x00800000);                  /** @brief Bank 1 read protection error flag */
    static const uint32_t FLASH_SR1_RDSERR1_MASK = UINT32_C(0x01000000);                  /** @brief Bank 1 secure error flag */
    static const uint32_t FLASH_SR1_SNECCERR11_MASK = UINT32_C(0x02000000);               /** @brief Bank 1 single correction error flag */
    static const uint32_t FLASH_SR1_DBECCERR1_MASK = UINT32_C(0x04000000);                /** @brief Bank 1 ECC double detection error flag */
    static const uint32_t FLASH_SR1_CRCEND1_MASK = UINT32_C(0x08000000);                  /** @brief Bank 1 crc-complete flag */
    static const uint32_t FLASH_CCR1_CLR_EOP1_MASK = UINT32_C(0x00010000);                /** @brief Bank 1 EOP1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_WRPERR1_MASK = UINT32_C(0x00020000);             /** @brief Bank 1 WRPERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_PGSERR1_MASK = UINT32_C(0x00040000);             /** @brief Bank 1 PGSERR1 flag clear bi */
    static const uint32_t FLASH_CCR1_CLR_STRBERR1_MASK = UINT32_C(0x00080000);            /** @brief Bank 1 STRBERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_INCERR1_MASK = UINT32_C(0x00200000);             /** @brief Bank 1 INCERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_OPERR1_MASK = UINT32_C(0x00400000);              /** @brief Bank 1 OPERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_RDPERR1_MASK = UINT32_C(0x00800000);             /** @brief Bank 1 RDPERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_RDSERR1_MASK = UINT32_C(0x01000000);             /** @brief Bank 1 RDSERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_SNECCERR1_MASK = UINT32_C(0x02000000);           /** @brief Bank 1 SNECCERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_DBECCERR1_MASK = UINT32_C(0x04000000);           /** @brief Bank 1 DBECCERR1 flag clear bit */
    static const uint32_t FLASH_CCR1_CLR_CRCEND1_MASK = UINT32_C(0x08000000);             /** @brief Bank 1 CRCEND1 flag clear bit */
    static const uint32_t FLASH_OPTCR_OPTLOCK_MASK = UINT32_C(0x00000001);                /** @brief FLASH_OPTCR lock option configuration bit */
    static const uint32_t FLASH_OPTCR_OPTSTART_MASK = UINT32_C(0x00000002);               /** @brief Option byte start change option configuration bit */
    static const uint32_t FLASH_OPTCR_MER_MASK = UINT32_C(0x00000010);                    /** @brief Flash mass erase enable bit */
    static const uint32_t FLASH_OPTCR_OPTCHANGEERRIE_MASK = UINT32_C(0x40000000);         /** @brief Option byte change error interrupt enable bit */
    static const uint32_t FLASH_OPTCR_SWAP_BANK_MASK = UINT32_C(0x80000000);              /** @brief Bank swapping configuration bit */
    static const uint32_t FLASH_OPTCR__OPTLOCK_MASK = UINT32_C(0x00000001);               /** @brief FLASH_OPTCR lock option configuration bit */
    static const uint32_t FLASH_OPTCR__OPTSTART_MASK = UINT32_C(0x00000002);              /** @brief Option byte start change option configuration bit */
    static const uint32_t FLASH_OPTCR__MER_MASK = UINT32_C(0x00000010);                   /** @brief Flash mass erase enable bit */
    static const uint32_t FLASH_OPTCR__OPTCHANGEERRIE_MASK = UINT32_C(0x40000000);        /** @brief Option byte change error interrupt enable bit */
    static const uint32_t FLASH_OPTCR__SWAP_BANK_MASK = UINT32_C(0x80000000);             /** @brief Bank swapping configuration bit */
    static const uint32_t FLASH_OPTSR_CUR__OPT_BUSY_MASK = UINT32_C(0x00000001);          /** @brief Option byte change ongoing flag */
    static const uint32_t FLASH_OPTSR_CUR__BOR_LEV_MASK = UINT32_C(0x0000000C);           /** @brief Brownout level option status bit */
    static const uint32_t FLASH_OPTSR_CUR__IWDG1_HW_MASK = UINT32_C(0x00000010);          /** @brief IWDG1 control option status bit */
    static const uint32_t FLASH_OPTSR_CUR__NRST_STOP_D1_MASK = UINT32_C(0x00000040);      /** @brief D1 dstop entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR__NRST_STBY_D1_MASK = UINT32_C(0x00000080);      /** @brief D1 dstandby entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR__RDP_MASK = UINT32_C(0x0000FF00);               /** @brief Readout protection level option status byte */
    static const uint32_t FLASH_OPTSR_CUR__FZ_IWDG_STOP_MASK = UINT32_C(0x00020000);      /** @brief IWDG stop mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR__FZ_IWDG_SDBY_MASK = UINT32_C(0x00040000);      /** @brief IWDG standby mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR__ST_RAM_SIZE_MASK = UINT32_C(0x00180000);       /** @brief DTCM RAM size option status */
    static const uint32_t FLASH_OPTSR_CUR__SECURITY_MASK = UINT32_C(0x00200000);          /** @brief Security enable option status bit */
    static const uint32_t FLASH_OPTSR_CUR__RSS1_MASK = UINT32_C(0x04000000);              /** @brief User option bit 1 */
    static const uint32_t FLASH_OPTSR_CUR__PERSO_OK_MASK = UINT32_C(0x10000000);          /** @brief Device personalization status bit */
    static const uint32_t FLASH_OPTSR_CUR__IO_HSLV_MASK = UINT32_C(0x20000000);           /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_CUR__OPTCHANGEERR_MASK = UINT32_C(0x40000000);      /** @brief Option byte change error flag */
    static const uint32_t FLASH_OPTSR_CUR__SWAP_BANK_OPT_MASK = UINT32_C(0x80000000);     /** @brief Bank swapping option status bit */
    static const uint32_t FLASH_OPTSR_CUR_OPT_BUSY_MASK = UINT32_C(0x00000001);           /** @brief Option byte change ongoing flag */
    static const uint32_t FLASH_OPTSR_CUR_BOR_LEV_MASK = UINT32_C(0x0000000C);            /** @brief Brownout level option status bit */
    static const uint32_t FLASH_OPTSR_CUR_IWDG1_HW_MASK = UINT32_C(0x00000010);           /** @brief IWDG1 control option status bit */
    static const uint32_t FLASH_OPTSR_CUR_NRST_STOP_D1_MASK = UINT32_C(0x00000040);       /** @brief D1 dstop entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR_NRST_STBY_D1_MASK = UINT32_C(0x00000080);       /** @brief D1 dstandby entry reset option status bit */
    static const uint32_t FLASH_OPTSR_CUR_RDP_MASK = UINT32_C(0x0000FF00);                /** @brief Readout protection level option status byte */
    static const uint32_t FLASH_OPTSR_CUR_FZ_IWDG_STOP_MASK = UINT32_C(0x00020000);       /** @brief IWDG stop mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR_FZ_IWDG_SDBY_MASK = UINT32_C(0x00040000);       /** @brief IWDG standby mode freeze option status bit */
    static const uint32_t FLASH_OPTSR_CUR_ST_RAM_SIZE_MASK = UINT32_C(0x00180000);        /** @brief DTCM RAM size option status */
    static const uint32_t FLASH_OPTSR_CUR_SECURITY_MASK = UINT32_C(0x00200000);           /** @brief Security enable option status bit */
    static const uint32_t FLASH_OPTSR_CUR_RSS1_MASK = UINT32_C(0x04000000);               /** @brief User option bit 1 */
    static const uint32_t FLASH_OPTSR_CUR_PERSO_OK_MASK = UINT32_C(0x10000000);           /** @brief Device personalization status bit */
    static const uint32_t FLASH_OPTSR_CUR_IO_HSLV_MASK = UINT32_C(0x20000000);            /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_CUR_OPTCHANGEERR_MASK = UINT32_C(0x40000000);       /** @brief Option byte change error flag */
    static const uint32_t FLASH_OPTSR_CUR_SWAP_BANK_OPT_MASK = UINT32_C(0x80000000);      /** @brief Bank swapping option status bit */
    static const uint32_t FLASH_OPTSR_PRG_BOR_LEV_MASK = UINT32_C(0x0000000C);            /** @brief BOR reset level option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG_IWDG1_HW_MASK = UINT32_C(0x00000010);           /** @brief IWDG1 option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_NRST_STOP_D1_MASK = UINT32_C(0x00000040);       /** @brief Option byte erase after D1 dstop option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_NRST_STBY_D1_MASK = UINT32_C(0x00000080);       /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_RDP_MASK = UINT32_C(0x0000FF00);                /** @brief Readout protection level option configuration byte */
    static const uint32_t FLASH_OPTSR_PRG_FZ_IWDG_STOP_MASK = UINT32_C(0x00020000);       /** @brief IWDG stop mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_FZ_IWDG_SDBY_MASK = UINT32_C(0x00040000);       /** @brief IWDG standby mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_ST_RAM_SIZE_MASK = UINT32_C(0x00180000);        /** @brief DTCM size select option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG_SECURITY_MASK = UINT32_C(0x00200000);           /** @brief Security option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG_RSS1_MASK = UINT32_C(0x04000000);               /** @brief User option configuration bit 1 */
    static const uint32_t FLASH_OPTSR_PRG_RSS2_MASK = UINT32_C(0x08000000);               /** @brief User option configuration bit 2 */
    static const uint32_t FLASH_OPTSR_PRG_IO_HSLV_MASK = UINT32_C(0x20000000);            /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_PRG_SWAP_BANK_OPT_MASK = UINT32_C(0x80000000);      /** @brief Bank swapping option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__BOR_LEV_MASK = UINT32_C(0x0000000C);           /** @brief BOR reset level option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG__IWDG1_HW_MASK = UINT32_C(0x00000010);          /** @brief IWDG1 option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__NRST_STOP_D1_MASK = UINT32_C(0x00000040);      /** @brief Option byte erase after D1 dstop option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__NRST_STBY_D1_MASK = UINT32_C(0x00000080);      /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__RDP_MASK = UINT32_C(0x0000FF00);               /** @brief Readout protection level option configuration byte */
    static const uint32_t FLASH_OPTSR_PRG__FZ_IWDG_STOP_MASK = UINT32_C(0x00020000);      /** @brief IWDG stop mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__FZ_IWDG_SDBY_MASK = UINT32_C(0x00040000);      /** @brief IWDG standby mode freeze option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__ST_RAM_SIZE_MASK = UINT32_C(0x00180000);       /** @brief DTCM size select option configuration bits */
    static const uint32_t FLASH_OPTSR_PRG__SECURITY_MASK = UINT32_C(0x00200000);          /** @brief Security option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__RSS1_MASK = UINT32_C(0x04000000);              /** @brief User option configuration bit 1 */
    static const uint32_t FLASH_OPTSR_PRG__RSS2_MASK = UINT32_C(0x08000000);              /** @brief User option configuration bit 2 */
    static const uint32_t FLASH_OPTSR_PRG__IO_HSLV_MASK = UINT32_C(0x20000000);           /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const uint32_t FLASH_OPTSR_PRG__SWAP_BANK_OPT_MASK = UINT32_C(0x80000000);     /** @brief Bank swapping option configuration bit */
    static const uint32_t FLASH_OPTCCR__CLR_OPTCHANGEERR_MASK = UINT32_C(0x40000000);     /** @brief OPTCHANGEERR reset bit */
    static const uint32_t FLASH_OPTCCR_CLR_OPTCHANGEERR_MASK = UINT32_C(0x40000000);      /** @brief OPTCHANGEERR reset bit */
    static const uint32_t FLASH_PRAR_CUR1_PROT_AREA_START1_MASK = UINT32_C(0x00000FFF);   /** @brief Bank 1 lowest PCROP protected address */
    static const uint32_t FLASH_PRAR_CUR1_PROT_AREA_END1_MASK = UINT32_C(0x0FFF0000);     /** @brief Bank 1 highest PCROP protected address */
    static const uint32_t FLASH_PRAR_CUR1_DMEP1_MASK = UINT32_C(0x80000000);              /** @brief Bank 1 PCROP protected erase enable option status bit */
    static const uint32_t FLASH_PRAR_PRG1_PROT_AREA_START1_MASK = UINT32_C(0x00000FFF);   /** @brief Bank 1 lowest PCROP protected address configuration */
    static const uint32_t FLASH_PRAR_PRG1_PROT_AREA_END1_MASK = UINT32_C(0x0FFF0000);     /** @brief Bank 1 highest PCROP protected address configuration */
    static const uint32_t FLASH_PRAR_PRG1_DMEP1_MASK = UINT32_C(0x80000000);              /** @brief Bank 1 PCROP protected erase enable option configuration bit */
    static const uint32_t FLASH_SCAR_CUR1_SEC_AREA_START1_MASK = UINT32_C(0x00000FFF);    /** @brief Bank 1 lowest secure protected address */
    static const uint32_t FLASH_SCAR_CUR1_SEC_AREA_END1_MASK = UINT32_C(0x0FFF0000);      /** @brief Bank 1 highest secure protected address */
    static const uint32_t FLASH_SCAR_CUR1_DMES1_MASK = UINT32_C(0x80000000);              /** @brief Bank 1 secure protected erase enable option status bit */
    static const uint32_t FLASH_SCAR_PRG1_SEC_AREA_START1_MASK = UINT32_C(0x00000FFF);    /** @brief Bank 1 lowest secure protected address configuration */
    static const uint32_t FLASH_SCAR_PRG1_SEC_AREA_END1_MASK = UINT32_C(0x0FFF0000);      /** @brief Bank 1 highest secure protected address configuration */
    static const uint32_t FLASH_SCAR_PRG1_DMES1_MASK = UINT32_C(0x80000000);              /** @brief Bank 1 secure protected erase enable option configuration bit */
    static const uint32_t FLASH_WPSN_CUR1R_WRPSN1_MASK = UINT32_C(0x000000FF);            /** @brief Bank 1 sector write protection option status byte */
    static const uint32_t FLASH_WPSN_PRG1R_WRPSN1_MASK = UINT32_C(0x000000FF);            /** @brief Bank 1 sector write protection configuration byte */
    static const uint32_t FLASH_BOOT_CURR_BOOT_ADD0_MASK = UINT32_C(0x0000FFFF);          /** @brief Boot address 0 */
    static const uint32_t FLASH_BOOT_CURR_BOOT_ADD1_MASK = UINT32_C(0xFFFF0000);          /** @brief Boot address 1 */
    static const uint32_t FLASH_BOOT_PRGR_BOOT_ADD0_MASK = UINT32_C(0x0000FFFF);          /** @brief Boot address 0 */
    static const uint32_t FLASH_BOOT_PRGR_BOOT_ADD1_MASK = UINT32_C(0xFFFF0000);          /** @brief Boot address 1 */
    static const uint32_t FLASH_CRCCR1_CRC_SECT_MASK = UINT32_C(0x00000007);              /** @brief Bank 1 CRC sector number */
    static const uint32_t FLASH_CRCCR1_ALL_BANK_MASK = UINT32_C(0x00000080);              /** @brief Bank 1 CRC select bit */
    static const uint32_t FLASH_CRCCR1_CRC_BY_SECT_MASK = UINT32_C(0x00000100);           /** @brief Bank 1 CRC sector mode select bit */
    static const uint32_t FLASH_CRCCR1_ADD_SECT_MASK = UINT32_C(0x00000200);              /** @brief Bank 1 CRC sector select bit */
    static const uint32_t FLASH_CRCCR1_CLEAN_SECT_MASK = UINT32_C(0x00000400);            /** @brief Bank 1 CRC sector list clear bit */
    static const uint32_t FLASH_CRCCR1_START_CRC_MASK = UINT32_C(0x00010000);             /** @brief Bank 1 CRC start bit */
    static const uint32_t FLASH_CRCCR1_CLEAN_CRC_MASK = UINT32_C(0x00020000);             /** @brief Bank 1 CRC clear bit */
    static const uint32_t FLASH_CRCCR1_CRC_BURST_MASK = UINT32_C(0x00300000);             /** @brief Bank 1 CRC burst size */
    static const uint32_t FLASH_ECC_FA1R_FAIL_ECC_ADDR1_MASK = UINT32_C(0x00007FFF);      /** @brief Bank 1 ECC error address */
    static const uint32_t FLASH_CR2_LOCK2_MASK = UINT32_C(0x00000001);                    /** @brief Bank 2 configuration lock bit */
    static const uint32_t FLASH_CR2_PG2_MASK = UINT32_C(0x00000002);                      /** @brief Bank 2 program enable bit */
    static const uint32_t FLASH_CR2_SER2_MASK = UINT32_C(0x00000004);                     /** @brief Bank 2 sector erase request */
    static const uint32_t FLASH_CR2_BER2_MASK = UINT32_C(0x00000008);                     /** @brief Bank 2 erase request */
    static const uint32_t FLASH_CR2_PSIZE2_MASK = UINT32_C(0x00000030);                   /** @brief Bank 2 program size */
    static const uint32_t FLASH_CR2_FW2_MASK = UINT32_C(0x00000040);                      /** @brief Bank 2 write forcing control bit */
    static const uint32_t FLASH_CR2_START2_MASK = UINT32_C(0x00000080);                   /** @brief Bank 2 bank or sector erase start control bit */
    static const uint32_t FLASH_CR2_SNB2_MASK = UINT32_C(0x00000700);                     /** @brief Bank 2 sector erase selection number */
    static const uint32_t FLASH_CR2_CRC_EN_MASK = UINT32_C(0x00008000);                   /** @brief Bank 2 CRC control bit */
    static const uint32_t FLASH_CR2_EOPIE2_MASK = UINT32_C(0x00010000);                   /** @brief Bank 2 end-of-program interrupt control bit */
    static const uint32_t FLASH_CR2_WRPERRIE2_MASK = UINT32_C(0x00020000);                /** @brief Bank 2 write protection error interrupt enable bit */
    static const uint32_t FLASH_CR2_PGSERRIE2_MASK = UINT32_C(0x00040000);                /** @brief Bank 2 programming sequence error interrupt enable bit */
    static const uint32_t FLASH_CR2_STRBERRIE2_MASK = UINT32_C(0x00080000);               /** @brief Bank 2 strobe error interrupt enable bit */
    static const uint32_t FLASH_CR2_INCERRIE2_MASK = UINT32_C(0x00200000);                /** @brief Bank 2 inconsistency error interrupt enable bit */
    static const uint32_t FLASH_CR2_OPERRIE2_MASK = UINT32_C(0x00400000);                 /** @brief Bank 2 write/erase error interrupt enable bit */
    static const uint32_t FLASH_CR2_RDPERRIE2_MASK = UINT32_C(0x00800000);                /** @brief Bank 2 read protection error interrupt enable bit */
    static const uint32_t FLASH_CR2_RDSERRIE2_MASK = UINT32_C(0x01000000);                /** @brief Bank 2 secure error interrupt enable bit */
    static const uint32_t FLASH_CR2_SNECCERRIE2_MASK = UINT32_C(0x02000000);              /** @brief Bank 2 ECC single correction error interrupt enable bit */
    static const uint32_t FLASH_CR2_DBECCERRIE2_MASK = UINT32_C(0x04000000);              /** @brief Bank 2 ECC double detection error interrupt enable bit */
    static const uint32_t FLASH_CR2_CRCENDIE2_MASK = UINT32_C(0x08000000);                /** @brief Bank 2 end of CRC calculation interrupt enable bit */
    static const uint32_t FLASH_SR2_BSY2_MASK = UINT32_C(0x00000001);                     /** @brief Bank 2 ongoing program flag */
    static const uint32_t FLASH_SR2_WBNE2_MASK = UINT32_C(0x00000002);                    /** @brief Bank 2 write buffer not empty flag */
    static const uint32_t FLASH_SR2_QW2_MASK = UINT32_C(0x00000004);                      /** @brief Bank 2 wait queue flag */
    static const uint32_t FLASH_SR2_CRC_BUSY2_MASK = UINT32_C(0x00000008);                /** @brief Bank 2 CRC busy flag */
    static const uint32_t FLASH_SR2_EOP2_MASK = UINT32_C(0x00010000);                     /** @brief Bank 2 end-of-program flag */
    static const uint32_t FLASH_SR2_WRPERR2_MASK = UINT32_C(0x00020000);                  /** @brief Bank 2 write protection error flag */
    static const uint32_t FLASH_SR2_PGSERR2_MASK = UINT32_C(0x00040000);                  /** @brief Bank 2 programming sequence error flag */
    static const uint32_t FLASH_SR2_STRBERR2_MASK = UINT32_C(0x00080000);                 /** @brief Bank 2 strobe error flag */
    static const uint32_t FLASH_SR2_INCERR2_MASK = UINT32_C(0x00200000);                  /** @brief Bank 2 inconsistency error flag */
    static const uint32_t FLASH_SR2_OPERR2_MASK = UINT32_C(0x00400000);                   /** @brief Bank 2 write/erase error flag */
    static const uint32_t FLASH_SR2_RDPERR2_MASK = UINT32_C(0x00800000);                  /** @brief Bank 2 read protection error flag */
    static const uint32_t FLASH_SR2_RDSERR2_MASK = UINT32_C(0x01000000);                  /** @brief Bank 2 secure error flag */
    static const uint32_t FLASH_SR2_SNECCERR2_MASK = UINT32_C(0x02000000);                /** @brief Bank 2 single correction error flag */
    static const uint32_t FLASH_SR2_DBECCERR2_MASK = UINT32_C(0x04000000);                /** @brief Bank 2 ECC double detection error flag */
    static const uint32_t FLASH_SR2_CRCEND2_MASK = UINT32_C(0x08000000);                  /** @brief Bank 2 crc-complete flag */
    static const uint32_t FLASH_CCR2_CLR_EOP2_MASK = UINT32_C(0x00010000);                /** @brief Bank 1 EOP1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_WRPERR2_MASK = UINT32_C(0x00020000);             /** @brief Bank 2 WRPERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_PGSERR2_MASK = UINT32_C(0x00040000);             /** @brief Bank 2 PGSERR1 flag clear bi */
    static const uint32_t FLASH_CCR2_CLR_STRBERR2_MASK = UINT32_C(0x00080000);            /** @brief Bank 2 STRBERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_INCERR2_MASK = UINT32_C(0x00200000);             /** @brief Bank 2 INCERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_OPERR2_MASK = UINT32_C(0x00400000);              /** @brief Bank 2 OPERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_RDPERR2_MASK = UINT32_C(0x00800000);             /** @brief Bank 2 RDPERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_RDSERR1_MASK = UINT32_C(0x01000000);             /** @brief Bank 1 RDSERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_SNECCERR2_MASK = UINT32_C(0x02000000);           /** @brief Bank 2 SNECCERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_DBECCERR1_MASK = UINT32_C(0x04000000);           /** @brief Bank 1 DBECCERR1 flag clear bit */
    static const uint32_t FLASH_CCR2_CLR_CRCEND2_MASK = UINT32_C(0x08000000);             /** @brief Bank 2 CRCEND1 flag clear bit */
    static const uint32_t FLASH_PRAR_CUR2_PROT_AREA_START2_MASK = UINT32_C(0x00000FFF);   /** @brief Bank 2 lowest PCROP protected address */
    static const uint32_t FLASH_PRAR_CUR2_PROT_AREA_END2_MASK = UINT32_C(0x0FFF0000);     /** @brief Bank 2 highest PCROP protected address */
    static const uint32_t FLASH_PRAR_CUR2_DMEP2_MASK = UINT32_C(0x80000000);              /** @brief Bank 2 PCROP protected erase enable option status bit */
    static const uint32_t FLASH_PRAR_PRG2_PROT_AREA_START2_MASK = UINT32_C(0x00000FFF);   /** @brief Bank 2 lowest PCROP protected address configuration */
    static const uint32_t FLASH_PRAR_PRG2_PROT_AREA_END2_MASK = UINT32_C(0x0FFF0000);     /** @brief Bank 2 highest PCROP protected address configuration */
    static const uint32_t FLASH_PRAR_PRG2_DMEP2_MASK = UINT32_C(0x80000000);              /** @brief Bank 2 PCROP protected erase enable option configuration bit */
    static const uint32_t FLASH_SCAR_CUR2_SEC_AREA_START2_MASK = UINT32_C(0x00000FFF);    /** @brief Bank 2 lowest secure protected address */
    static const uint32_t FLASH_SCAR_CUR2_SEC_AREA_END2_MASK = UINT32_C(0x0FFF0000);      /** @brief Bank 2 highest secure protected address */
    static const uint32_t FLASH_SCAR_CUR2_DMES2_MASK = UINT32_C(0x80000000);              /** @brief Bank 2 secure protected erase enable option status bit */
    static const uint32_t FLASH_SCAR_PRG2_SEC_AREA_START2_MASK = UINT32_C(0x00000FFF);    /** @brief Bank 2 lowest secure protected address configuration */
    static const uint32_t FLASH_SCAR_PRG2_SEC_AREA_END2_MASK = UINT32_C(0x0FFF0000);      /** @brief Bank 2 highest secure protected address configuration */
    static const uint32_t FLASH_SCAR_PRG2_DMES2_MASK = UINT32_C(0x80000000);              /** @brief Bank 2 secure protected erase enable option configuration bit */
    static const uint32_t FLASH_WPSN_CUR2R_WRPSN2_MASK = UINT32_C(0x000000FF);            /** @brief Bank 2 sector write protection option status byte */
    static const uint32_t FLASH_WPSN_PRG2R_WRPSN2_MASK = UINT32_C(0x000000FF);            /** @brief Bank 2 sector write protection configuration byte */
    static const uint32_t FLASH_CRCCR2_CRC_SECT_MASK = UINT32_C(0x00000007);              /** @brief Bank 2 CRC sector number */
    static const uint32_t FLASH_CRCCR2_ALL_BANK_MASK = UINT32_C(0x00000080);              /** @brief Bank 2 CRC select bit */
    static const uint32_t FLASH_CRCCR2_CRC_BY_SECT_MASK = UINT32_C(0x00000100);           /** @brief Bank 2 CRC sector mode select bit */
    static const uint32_t FLASH_CRCCR2_ADD_SECT_MASK = UINT32_C(0x00000200);              /** @brief Bank 2 CRC sector select bit */
    static const uint32_t FLASH_CRCCR2_CLEAN_SECT_MASK = UINT32_C(0x00000400);            /** @brief Bank 2 CRC sector list clear bit */
    static const uint32_t FLASH_CRCCR2_START_CRC_MASK = UINT32_C(0x00010000);             /** @brief Bank 2 CRC start bit */
    static const uint32_t FLASH_CRCCR2_CLEAN_CRC_MASK = UINT32_C(0x00020000);             /** @brief Bank 2 CRC clear bit */
    static const uint32_t FLASH_CRCCR2_CRC_BURST_MASK = UINT32_C(0x00300000);             /** @brief Bank 2 CRC burst size */
    static const uint32_t FLASH_ECC_FA2R_FAIL_ECC_ADDR2_MASK = UINT32_C(0x00007FFF);      /** @brief Bank 2 ECC error address */

    /** @subsection FLASH field position definitions */

    static const int32_t FLASH_ECC_FA2R_LATENCY_POS = INT32_C(0);             /** @brief Read latency */
    static const int32_t FLASH_ECC_FA2R_WRHIGHFREQ_POS = INT32_C(4);          /** @brief Flash signal delay */
    static const int32_t FLASH_ECC_FA2R_LATENCY_POS = INT32_C(0);             /** @brief Read latency */
    static const int32_t FLASH_ECC_FA2R_WRHIGHFREQ_POS = INT32_C(4);          /** @brief Flash signal delay */
    static const int32_t FLASH_ECC_FA2R_LOCK1_POS = INT32_C(0);               /** @brief Bank 1 configuration lock bit */
    static const int32_t FLASH_ECC_FA2R_PG1_POS = INT32_C(1);                 /** @brief Bank 1 program enable bit */
    static const int32_t FLASH_ECC_FA2R_SER1_POS = INT32_C(2);                /** @brief Bank 1 sector erase request */
    static const int32_t FLASH_ECC_FA2R_BER1_POS = INT32_C(3);                /** @brief Bank 1 erase request */
    static const int32_t FLASH_ECC_FA2R_PSIZE1_POS = INT32_C(4);              /** @brief Bank 1 program size */
    static const int32_t FLASH_ECC_FA2R_FW1_POS = INT32_C(6);                 /** @brief Bank 1 write forcing control bit */
    static const int32_t FLASH_ECC_FA2R_START1_POS = INT32_C(7);              /** @brief Bank 1 bank or sector erase start control bit */
    static const int32_t FLASH_ECC_FA2R_SNB1_POS = INT32_C(8);                /** @brief Bank 1 sector erase selection number */
    static const int32_t FLASH_ECC_FA2R_CRC_EN_POS = INT32_C(15);             /** @brief Bank 1 CRC control bit */
    static const int32_t FLASH_ECC_FA2R_EOPIE1_POS = INT32_C(16);             /** @brief Bank 1 end-of-program interrupt control bit */
    static const int32_t FLASH_ECC_FA2R_WRPERRIE1_POS = INT32_C(17);          /** @brief Bank 1 write protection error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_PGSERRIE1_POS = INT32_C(18);          /** @brief Bank 1 programming sequence error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_STRBERRIE1_POS = INT32_C(19);         /** @brief Bank 1 strobe error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_INCERRIE1_POS = INT32_C(21);          /** @brief Bank 1 inconsistency error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_OPERRIE1_POS = INT32_C(22);           /** @brief Bank 1 write/erase error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_RDPERRIE1_POS = INT32_C(23);          /** @brief Bank 1 read protection error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_RDSERRIE1_POS = INT32_C(24);          /** @brief Bank 1 secure error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_SNECCERRIE1_POS = INT32_C(25);        /** @brief Bank 1 ECC single correction error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_DBECCERRIE1_POS = INT32_C(26);        /** @brief Bank 1 ECC double detection error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_CRCENDIE1_POS = INT32_C(27);          /** @brief Bank 1 end of CRC calculation interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_BSY1_POS = INT32_C(0);                /** @brief Bank 1 ongoing program flag */
    static const int32_t FLASH_ECC_FA2R_WBNE1_POS = INT32_C(1);               /** @brief Bank 1 write buffer not empty flag */
    static const int32_t FLASH_ECC_FA2R_QW1_POS = INT32_C(2);                 /** @brief Bank 1 wait queue flag */
    static const int32_t FLASH_ECC_FA2R_CRC_BUSY1_POS = INT32_C(3);           /** @brief Bank 1 CRC busy flag */
    static const int32_t FLASH_ECC_FA2R_EOP1_POS = INT32_C(16);               /** @brief Bank 1 end-of-program flag */
    static const int32_t FLASH_ECC_FA2R_WRPERR1_POS = INT32_C(17);            /** @brief Bank 1 write protection error flag */
    static const int32_t FLASH_ECC_FA2R_PGSERR1_POS = INT32_C(18);            /** @brief Bank 1 programming sequence error flag */
    static const int32_t FLASH_ECC_FA2R_STRBERR1_POS = INT32_C(19);           /** @brief Bank 1 strobe error flag */
    static const int32_t FLASH_ECC_FA2R_INCERR1_POS = INT32_C(21);            /** @brief Bank 1 inconsistency error flag */
    static const int32_t FLASH_ECC_FA2R_OPERR1_POS = INT32_C(22);             /** @brief Bank 1 write/erase error flag */
    static const int32_t FLASH_ECC_FA2R_RDPERR1_POS = INT32_C(23);            /** @brief Bank 1 read protection error flag */
    static const int32_t FLASH_ECC_FA2R_RDSERR1_POS = INT32_C(24);            /** @brief Bank 1 secure error flag */
    static const int32_t FLASH_ECC_FA2R_SNECCERR11_POS = INT32_C(25);         /** @brief Bank 1 single correction error flag */
    static const int32_t FLASH_ECC_FA2R_DBECCERR1_POS = INT32_C(26);          /** @brief Bank 1 ECC double detection error flag */
    static const int32_t FLASH_ECC_FA2R_CRCEND1_POS = INT32_C(27);            /** @brief Bank 1 crc-complete flag */
    static const int32_t FLASH_ECC_FA2R_CLR_EOP1_POS = INT32_C(16);           /** @brief Bank 1 EOP1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_WRPERR1_POS = INT32_C(17);        /** @brief Bank 1 WRPERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_PGSERR1_POS = INT32_C(18);        /** @brief Bank 1 PGSERR1 flag clear bi */
    static const int32_t FLASH_ECC_FA2R_CLR_STRBERR1_POS = INT32_C(19);       /** @brief Bank 1 STRBERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_INCERR1_POS = INT32_C(21);        /** @brief Bank 1 INCERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_OPERR1_POS = INT32_C(22);         /** @brief Bank 1 OPERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_RDPERR1_POS = INT32_C(23);        /** @brief Bank 1 RDPERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_RDSERR1_POS = INT32_C(24);        /** @brief Bank 1 RDSERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_SNECCERR1_POS = INT32_C(25);      /** @brief Bank 1 SNECCERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_DBECCERR1_POS = INT32_C(26);      /** @brief Bank 1 DBECCERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_CRCEND1_POS = INT32_C(27);        /** @brief Bank 1 CRCEND1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_OPTLOCK_POS = INT32_C(0);             /** @brief FLASH_OPTCR lock option configuration bit */
    static const int32_t FLASH_ECC_FA2R_OPTSTART_POS = INT32_C(1);            /** @brief Option byte start change option configuration bit */
    static const int32_t FLASH_ECC_FA2R_MER_POS = INT32_C(4);                 /** @brief Flash mass erase enable bit */
    static const int32_t FLASH_ECC_FA2R_OPTCHANGEERRIE_POS = INT32_C(30);     /** @brief Option byte change error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_SWAP_BANK_POS = INT32_C(31);          /** @brief Bank swapping configuration bit */
    static const int32_t FLASH_ECC_FA2R_OPTLOCK_POS = INT32_C(0);             /** @brief FLASH_OPTCR lock option configuration bit */
    static const int32_t FLASH_ECC_FA2R_OPTSTART_POS = INT32_C(1);            /** @brief Option byte start change option configuration bit */
    static const int32_t FLASH_ECC_FA2R_MER_POS = INT32_C(4);                 /** @brief Flash mass erase enable bit */
    static const int32_t FLASH_ECC_FA2R_OPTCHANGEERRIE_POS = INT32_C(30);     /** @brief Option byte change error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_SWAP_BANK_POS = INT32_C(31);          /** @brief Bank swapping configuration bit */
    static const int32_t FLASH_ECC_FA2R_OPT_BUSY_POS = INT32_C(0);            /** @brief Option byte change ongoing flag */
    static const int32_t FLASH_ECC_FA2R_BOR_LEV_POS = INT32_C(2);             /** @brief Brownout level option status bit */
    static const int32_t FLASH_ECC_FA2R_IWDG1_HW_POS = INT32_C(4);            /** @brief IWDG1 control option status bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STOP_D1_POS = INT32_C(6);        /** @brief D1 dstop entry reset option status bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STBY_D1_POS = INT32_C(7);        /** @brief D1 dstandby entry reset option status bit */
    static const int32_t FLASH_ECC_FA2R_RDP_POS = INT32_C(8);                 /** @brief Readout protection level option status byte */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_STOP_POS = INT32_C(17);       /** @brief IWDG stop mode freeze option status bit */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_SDBY_POS = INT32_C(18);       /** @brief IWDG standby mode freeze option status bit */
    static const int32_t FLASH_ECC_FA2R_ST_RAM_SIZE_POS = INT32_C(19);        /** @brief DTCM RAM size option status */
    static const int32_t FLASH_ECC_FA2R_SECURITY_POS = INT32_C(21);           /** @brief Security enable option status bit */
    static const int32_t FLASH_ECC_FA2R_RSS1_POS = INT32_C(26);               /** @brief User option bit 1 */
    static const int32_t FLASH_ECC_FA2R_PERSO_OK_POS = INT32_C(28);           /** @brief Device personalization status bit */
    static const int32_t FLASH_ECC_FA2R_IO_HSLV_POS = INT32_C(29);            /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_ECC_FA2R_OPTCHANGEERR_POS = INT32_C(30);       /** @brief Option byte change error flag */
    static const int32_t FLASH_ECC_FA2R_SWAP_BANK_OPT_POS = INT32_C(31);      /** @brief Bank swapping option status bit */
    static const int32_t FLASH_ECC_FA2R_OPT_BUSY_POS = INT32_C(0);            /** @brief Option byte change ongoing flag */
    static const int32_t FLASH_ECC_FA2R_BOR_LEV_POS = INT32_C(2);             /** @brief Brownout level option status bit */
    static const int32_t FLASH_ECC_FA2R_IWDG1_HW_POS = INT32_C(4);            /** @brief IWDG1 control option status bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STOP_D1_POS = INT32_C(6);        /** @brief D1 dstop entry reset option status bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STBY_D1_POS = INT32_C(7);        /** @brief D1 dstandby entry reset option status bit */
    static const int32_t FLASH_ECC_FA2R_RDP_POS = INT32_C(8);                 /** @brief Readout protection level option status byte */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_STOP_POS = INT32_C(17);       /** @brief IWDG stop mode freeze option status bit */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_SDBY_POS = INT32_C(18);       /** @brief IWDG standby mode freeze option status bit */
    static const int32_t FLASH_ECC_FA2R_ST_RAM_SIZE_POS = INT32_C(19);        /** @brief DTCM RAM size option status */
    static const int32_t FLASH_ECC_FA2R_SECURITY_POS = INT32_C(21);           /** @brief Security enable option status bit */
    static const int32_t FLASH_ECC_FA2R_RSS1_POS = INT32_C(26);               /** @brief User option bit 1 */
    static const int32_t FLASH_ECC_FA2R_PERSO_OK_POS = INT32_C(28);           /** @brief Device personalization status bit */
    static const int32_t FLASH_ECC_FA2R_IO_HSLV_POS = INT32_C(29);            /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_ECC_FA2R_OPTCHANGEERR_POS = INT32_C(30);       /** @brief Option byte change error flag */
    static const int32_t FLASH_ECC_FA2R_SWAP_BANK_OPT_POS = INT32_C(31);      /** @brief Bank swapping option status bit */
    static const int32_t FLASH_ECC_FA2R_BOR_LEV_POS = INT32_C(2);             /** @brief BOR reset level option configuration bits */
    static const int32_t FLASH_ECC_FA2R_IWDG1_HW_POS = INT32_C(4);            /** @brief IWDG1 option configuration bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STOP_D1_POS = INT32_C(6);        /** @brief Option byte erase after D1 dstop option configuration bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STBY_D1_POS = INT32_C(7);        /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const int32_t FLASH_ECC_FA2R_RDP_POS = INT32_C(8);                 /** @brief Readout protection level option configuration byte */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_STOP_POS = INT32_C(17);       /** @brief IWDG stop mode freeze option configuration bit */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_SDBY_POS = INT32_C(18);       /** @brief IWDG standby mode freeze option configuration bit */
    static const int32_t FLASH_ECC_FA2R_ST_RAM_SIZE_POS = INT32_C(19);        /** @brief DTCM size select option configuration bits */
    static const int32_t FLASH_ECC_FA2R_SECURITY_POS = INT32_C(21);           /** @brief Security option configuration bit */
    static const int32_t FLASH_ECC_FA2R_RSS1_POS = INT32_C(26);               /** @brief User option configuration bit 1 */
    static const int32_t FLASH_ECC_FA2R_RSS2_POS = INT32_C(27);               /** @brief User option configuration bit 2 */
    static const int32_t FLASH_ECC_FA2R_IO_HSLV_POS = INT32_C(29);            /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_ECC_FA2R_SWAP_BANK_OPT_POS = INT32_C(31);      /** @brief Bank swapping option configuration bit */
    static const int32_t FLASH_ECC_FA2R_BOR_LEV_POS = INT32_C(2);             /** @brief BOR reset level option configuration bits */
    static const int32_t FLASH_ECC_FA2R_IWDG1_HW_POS = INT32_C(4);            /** @brief IWDG1 option configuration bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STOP_D1_POS = INT32_C(6);        /** @brief Option byte erase after D1 dstop option configuration bit */
    static const int32_t FLASH_ECC_FA2R_NRST_STBY_D1_POS = INT32_C(7);        /** @brief Option byte erase after D1 dstandby option configuration bit */
    static const int32_t FLASH_ECC_FA2R_RDP_POS = INT32_C(8);                 /** @brief Readout protection level option configuration byte */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_STOP_POS = INT32_C(17);       /** @brief IWDG stop mode freeze option configuration bit */
    static const int32_t FLASH_ECC_FA2R_FZ_IWDG_SDBY_POS = INT32_C(18);       /** @brief IWDG standby mode freeze option configuration bit */
    static const int32_t FLASH_ECC_FA2R_ST_RAM_SIZE_POS = INT32_C(19);        /** @brief DTCM size select option configuration bits */
    static const int32_t FLASH_ECC_FA2R_SECURITY_POS = INT32_C(21);           /** @brief Security option configuration bit */
    static const int32_t FLASH_ECC_FA2R_RSS1_POS = INT32_C(26);               /** @brief User option configuration bit 1 */
    static const int32_t FLASH_ECC_FA2R_RSS2_POS = INT32_C(27);               /** @brief User option configuration bit 2 */
    static const int32_t FLASH_ECC_FA2R_IO_HSLV_POS = INT32_C(29);            /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
    static const int32_t FLASH_ECC_FA2R_SWAP_BANK_OPT_POS = INT32_C(31);      /** @brief Bank swapping option configuration bit */
    static const int32_t FLASH_ECC_FA2R_CLR_OPTCHANGEERR_POS = INT32_C(30);   /** @brief OPTCHANGEERR reset bit */
    static const int32_t FLASH_ECC_FA2R_CLR_OPTCHANGEERR_POS = INT32_C(30);   /** @brief OPTCHANGEERR reset bit */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_START1_POS = INT32_C(0);    /** @brief Bank 1 lowest PCROP protected address */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_END1_POS = INT32_C(16);     /** @brief Bank 1 highest PCROP protected address */
    static const int32_t FLASH_ECC_FA2R_DMEP1_POS = INT32_C(31);              /** @brief Bank 1 PCROP protected erase enable option status bit */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_START1_POS = INT32_C(0);    /** @brief Bank 1 lowest PCROP protected address configuration */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_END1_POS = INT32_C(16);     /** @brief Bank 1 highest PCROP protected address configuration */
    static const int32_t FLASH_ECC_FA2R_DMEP1_POS = INT32_C(31);              /** @brief Bank 1 PCROP protected erase enable option configuration bit */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_START1_POS = INT32_C(0);     /** @brief Bank 1 lowest secure protected address */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_END1_POS = INT32_C(16);      /** @brief Bank 1 highest secure protected address */
    static const int32_t FLASH_ECC_FA2R_DMES1_POS = INT32_C(31);              /** @brief Bank 1 secure protected erase enable option status bit */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_START1_POS = INT32_C(0);     /** @brief Bank 1 lowest secure protected address configuration */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_END1_POS = INT32_C(16);      /** @brief Bank 1 highest secure protected address configuration */
    static const int32_t FLASH_ECC_FA2R_DMES1_POS = INT32_C(31);              /** @brief Bank 1 secure protected erase enable option configuration bit */
    static const int32_t FLASH_ECC_FA2R_WRPSN1_POS = INT32_C(0);              /** @brief Bank 1 sector write protection option status byte */
    static const int32_t FLASH_ECC_FA2R_WRPSN1_POS = INT32_C(0);              /** @brief Bank 1 sector write protection configuration byte */
    static const int32_t FLASH_ECC_FA2R_BOOT_ADD0_POS = INT32_C(0);           /** @brief Boot address 0 */
    static const int32_t FLASH_ECC_FA2R_BOOT_ADD1_POS = INT32_C(16);          /** @brief Boot address 1 */
    static const int32_t FLASH_ECC_FA2R_BOOT_ADD0_POS = INT32_C(0);           /** @brief Boot address 0 */
    static const int32_t FLASH_ECC_FA2R_BOOT_ADD1_POS = INT32_C(16);          /** @brief Boot address 1 */
    static const int32_t FLASH_ECC_FA2R_CRC_SECT_POS = INT32_C(0);            /** @brief Bank 1 CRC sector number */
    static const int32_t FLASH_ECC_FA2R_ALL_BANK_POS = INT32_C(7);            /** @brief Bank 1 CRC select bit */
    static const int32_t FLASH_ECC_FA2R_CRC_BY_SECT_POS = INT32_C(8);         /** @brief Bank 1 CRC sector mode select bit */
    static const int32_t FLASH_ECC_FA2R_ADD_SECT_POS = INT32_C(9);            /** @brief Bank 1 CRC sector select bit */
    static const int32_t FLASH_ECC_FA2R_CLEAN_SECT_POS = INT32_C(10);         /** @brief Bank 1 CRC sector list clear bit */
    static const int32_t FLASH_ECC_FA2R_START_CRC_POS = INT32_C(16);          /** @brief Bank 1 CRC start bit */
    static const int32_t FLASH_ECC_FA2R_CLEAN_CRC_POS = INT32_C(17);          /** @brief Bank 1 CRC clear bit */
    static const int32_t FLASH_ECC_FA2R_CRC_BURST_POS = INT32_C(20);          /** @brief Bank 1 CRC burst size */
    static const int32_t FLASH_ECC_FA2R_FAIL_ECC_ADDR1_POS = INT32_C(0);      /** @brief Bank 1 ECC error address */
    static const int32_t FLASH_ECC_FA2R_LOCK2_POS = INT32_C(0);               /** @brief Bank 2 configuration lock bit */
    static const int32_t FLASH_ECC_FA2R_PG2_POS = INT32_C(1);                 /** @brief Bank 2 program enable bit */
    static const int32_t FLASH_ECC_FA2R_SER2_POS = INT32_C(2);                /** @brief Bank 2 sector erase request */
    static const int32_t FLASH_ECC_FA2R_BER2_POS = INT32_C(3);                /** @brief Bank 2 erase request */
    static const int32_t FLASH_ECC_FA2R_PSIZE2_POS = INT32_C(4);              /** @brief Bank 2 program size */
    static const int32_t FLASH_ECC_FA2R_FW2_POS = INT32_C(6);                 /** @brief Bank 2 write forcing control bit */
    static const int32_t FLASH_ECC_FA2R_START2_POS = INT32_C(7);              /** @brief Bank 2 bank or sector erase start control bit */
    static const int32_t FLASH_ECC_FA2R_SNB2_POS = INT32_C(8);                /** @brief Bank 2 sector erase selection number */
    static const int32_t FLASH_ECC_FA2R_CRC_EN_POS = INT32_C(15);             /** @brief Bank 2 CRC control bit */
    static const int32_t FLASH_ECC_FA2R_EOPIE2_POS = INT32_C(16);             /** @brief Bank 2 end-of-program interrupt control bit */
    static const int32_t FLASH_ECC_FA2R_WRPERRIE2_POS = INT32_C(17);          /** @brief Bank 2 write protection error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_PGSERRIE2_POS = INT32_C(18);          /** @brief Bank 2 programming sequence error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_STRBERRIE2_POS = INT32_C(19);         /** @brief Bank 2 strobe error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_INCERRIE2_POS = INT32_C(21);          /** @brief Bank 2 inconsistency error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_OPERRIE2_POS = INT32_C(22);           /** @brief Bank 2 write/erase error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_RDPERRIE2_POS = INT32_C(23);          /** @brief Bank 2 read protection error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_RDSERRIE2_POS = INT32_C(24);          /** @brief Bank 2 secure error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_SNECCERRIE2_POS = INT32_C(25);        /** @brief Bank 2 ECC single correction error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_DBECCERRIE2_POS = INT32_C(26);        /** @brief Bank 2 ECC double detection error interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_CRCENDIE2_POS = INT32_C(27);          /** @brief Bank 2 end of CRC calculation interrupt enable bit */
    static const int32_t FLASH_ECC_FA2R_BSY2_POS = INT32_C(0);                /** @brief Bank 2 ongoing program flag */
    static const int32_t FLASH_ECC_FA2R_WBNE2_POS = INT32_C(1);               /** @brief Bank 2 write buffer not empty flag */
    static const int32_t FLASH_ECC_FA2R_QW2_POS = INT32_C(2);                 /** @brief Bank 2 wait queue flag */
    static const int32_t FLASH_ECC_FA2R_CRC_BUSY2_POS = INT32_C(3);           /** @brief Bank 2 CRC busy flag */
    static const int32_t FLASH_ECC_FA2R_EOP2_POS = INT32_C(16);               /** @brief Bank 2 end-of-program flag */
    static const int32_t FLASH_ECC_FA2R_WRPERR2_POS = INT32_C(17);            /** @brief Bank 2 write protection error flag */
    static const int32_t FLASH_ECC_FA2R_PGSERR2_POS = INT32_C(18);            /** @brief Bank 2 programming sequence error flag */
    static const int32_t FLASH_ECC_FA2R_STRBERR2_POS = INT32_C(19);           /** @brief Bank 2 strobe error flag */
    static const int32_t FLASH_ECC_FA2R_INCERR2_POS = INT32_C(21);            /** @brief Bank 2 inconsistency error flag */
    static const int32_t FLASH_ECC_FA2R_OPERR2_POS = INT32_C(22);             /** @brief Bank 2 write/erase error flag */
    static const int32_t FLASH_ECC_FA2R_RDPERR2_POS = INT32_C(23);            /** @brief Bank 2 read protection error flag */
    static const int32_t FLASH_ECC_FA2R_RDSERR2_POS = INT32_C(24);            /** @brief Bank 2 secure error flag */
    static const int32_t FLASH_ECC_FA2R_SNECCERR2_POS = INT32_C(25);          /** @brief Bank 2 single correction error flag */
    static const int32_t FLASH_ECC_FA2R_DBECCERR2_POS = INT32_C(26);          /** @brief Bank 2 ECC double detection error flag */
    static const int32_t FLASH_ECC_FA2R_CRCEND2_POS = INT32_C(27);            /** @brief Bank 2 crc-complete flag */
    static const int32_t FLASH_ECC_FA2R_CLR_EOP2_POS = INT32_C(16);           /** @brief Bank 1 EOP1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_WRPERR2_POS = INT32_C(17);        /** @brief Bank 2 WRPERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_PGSERR2_POS = INT32_C(18);        /** @brief Bank 2 PGSERR1 flag clear bi */
    static const int32_t FLASH_ECC_FA2R_CLR_STRBERR2_POS = INT32_C(19);       /** @brief Bank 2 STRBERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_INCERR2_POS = INT32_C(21);        /** @brief Bank 2 INCERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_OPERR2_POS = INT32_C(22);         /** @brief Bank 2 OPERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_RDPERR2_POS = INT32_C(23);        /** @brief Bank 2 RDPERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_RDSERR1_POS = INT32_C(24);        /** @brief Bank 1 RDSERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_SNECCERR2_POS = INT32_C(25);      /** @brief Bank 2 SNECCERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_DBECCERR1_POS = INT32_C(26);      /** @brief Bank 1 DBECCERR1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_CLR_CRCEND2_POS = INT32_C(27);        /** @brief Bank 2 CRCEND1 flag clear bit */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_START2_POS = INT32_C(0);    /** @brief Bank 2 lowest PCROP protected address */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_END2_POS = INT32_C(16);     /** @brief Bank 2 highest PCROP protected address */
    static const int32_t FLASH_ECC_FA2R_DMEP2_POS = INT32_C(31);              /** @brief Bank 2 PCROP protected erase enable option status bit */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_START2_POS = INT32_C(0);    /** @brief Bank 2 lowest PCROP protected address configuration */
    static const int32_t FLASH_ECC_FA2R_PROT_AREA_END2_POS = INT32_C(16);     /** @brief Bank 2 highest PCROP protected address configuration */
    static const int32_t FLASH_ECC_FA2R_DMEP2_POS = INT32_C(31);              /** @brief Bank 2 PCROP protected erase enable option configuration bit */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_START2_POS = INT32_C(0);     /** @brief Bank 2 lowest secure protected address */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_END2_POS = INT32_C(16);      /** @brief Bank 2 highest secure protected address */
    static const int32_t FLASH_ECC_FA2R_DMES2_POS = INT32_C(31);              /** @brief Bank 2 secure protected erase enable option status bit */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_START2_POS = INT32_C(0);     /** @brief Bank 2 lowest secure protected address configuration */
    static const int32_t FLASH_ECC_FA2R_SEC_AREA_END2_POS = INT32_C(16);      /** @brief Bank 2 highest secure protected address configuration */
    static const int32_t FLASH_ECC_FA2R_DMES2_POS = INT32_C(31);              /** @brief Bank 2 secure protected erase enable option configuration bit */
    static const int32_t FLASH_ECC_FA2R_WRPSN2_POS = INT32_C(0);              /** @brief Bank 2 sector write protection option status byte */
    static const int32_t FLASH_ECC_FA2R_WRPSN2_POS = INT32_C(0);              /** @brief Bank 2 sector write protection configuration byte */
    static const int32_t FLASH_ECC_FA2R_CRC_SECT_POS = INT32_C(0);            /** @brief Bank 2 CRC sector number */
    static const int32_t FLASH_ECC_FA2R_ALL_BANK_POS = INT32_C(7);            /** @brief Bank 2 CRC select bit */
    static const int32_t FLASH_ECC_FA2R_CRC_BY_SECT_POS = INT32_C(8);         /** @brief Bank 2 CRC sector mode select bit */
    static const int32_t FLASH_ECC_FA2R_ADD_SECT_POS = INT32_C(9);            /** @brief Bank 2 CRC sector select bit */
    static const int32_t FLASH_ECC_FA2R_CLEAN_SECT_POS = INT32_C(10);         /** @brief Bank 2 CRC sector list clear bit */
    static const int32_t FLASH_ECC_FA2R_START_CRC_POS = INT32_C(16);          /** @brief Bank 2 CRC start bit */
    static const int32_t FLASH_ECC_FA2R_CLEAN_CRC_POS = INT32_C(17);          /** @brief Bank 2 CRC clear bit */
    static const int32_t FLASH_ECC_FA2R_CRC_BURST_POS = INT32_C(20);          /** @brief Bank 2 CRC burst size */
    static const int32_t FLASH_ECC_FA2R_FAIL_ECC_ADDR2_POS = INT32_C(0);      /** @brief Bank 2 ECC error address */

    /**********************************************************************************************
     * @section AXI Definitions
     **********************************************************************************************/

    /** @subsection AXI register array definitions */

    static _RO uint32_t* const AXI_PERIPH_ID_X_REG[5] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x51001FEC),   /** @brief AXI interconnect - peripheral ID3 register */
      (_RO uint32_t* const)UINT32_C(0x51001FD0),   /** @brief AXI interconnect - peripheral ID4 register */
    };

    static _RO uint32_t* const AXI_COMP_ID_X_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x51001FF0),   /** @brief AXI interconnect - component ID0 register */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x51001FF8),   /** @brief AXI interconnect - component ID2 register */
      (_RO uint32_t* const)UINT32_C(0x51001FFC),   /** @brief AXI interconnect - component ID3 register */
    };

    static _RW uint32_t* const AXI_TARGX_FN_MOD_ISS_BM_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51002008),   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      (_RW uint32_t* const)UINT32_C(0x51003008),   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      (_RW uint32_t* const)UINT32_C(0x51004008),   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      (_RW uint32_t* const)UINT32_C(0x51005008),   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      (_RW uint32_t* const)UINT32_C(0x51006008),   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      (_RW uint32_t* const)UINT32_C(0x51007008),   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      (_RW uint32_t* const)UINT32_C(0x5100800C),   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    };

    static _RW uint32_t* const AXI_TARGX_FN_MOD2_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51002024),   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      (_RW uint32_t* const)UINT32_C(0x51003024),   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51008024),   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
    };

    static _RW uint32_t* const AXI_TARGX_FN_MOD_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51002108),   /** @brief AXI interconnect - TARG x long burst functionality modification */
      (_RW uint32_t* const)UINT32_C(0x51003108),   /** @brief AXI interconnect - TARG x long burst functionality modification */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51008108),   /** @brief AXI interconnect - TARG x long burst functionality modification */
    };

    static _RW uint32_t* const AXI_INIX_READ_QOS_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51042100),   /** @brief AXI interconnect - INI x read qos register */
      (_RW uint32_t* const)UINT32_C(0x51043100),   /** @brief AXI interconnect - INI x read qos register */
      (_RW uint32_t* const)UINT32_C(0x51044100),   /** @brief AXI interconnect - INI x read qos register */
      (_RW uint32_t* const)UINT32_C(0x51045100),   /** @brief AXI interconnect - INI x read qos register */
      (_RW uint32_t* const)UINT32_C(0x51046100),   /** @brief AXI interconnect - INI x read qos register */
      (_RW uint32_t* const)UINT32_C(0x51047100),   /** @brief AXI interconnect - INI x read qos register */
    };

    static _RW uint32_t* const AXI_INIX_WRITE_QOS_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51042104),   /** @brief AXI interconnect - INI x write qos register */
      (_RW uint32_t* const)UINT32_C(0x51043104),   /** @brief AXI interconnect - INI x write qos register */
      (_RW uint32_t* const)UINT32_C(0x51044104),   /** @brief AXI interconnect - INI x write qos register */
      (_RW uint32_t* const)UINT32_C(0x51045104),   /** @brief AXI interconnect - INI x write qos register */
      (_RW uint32_t* const)UINT32_C(0x51046104),   /** @brief AXI interconnect - INI x write qos register */
      (_RW uint32_t* const)UINT32_C(0x51047104),   /** @brief AXI interconnect - INI x write qos register */
    };

    static _RW uint32_t* const AXI_INIX_FN_MOD_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x51042108),   /** @brief AXI interconnect - INI x issuing functionality modification register */
      (_RW uint32_t* const)UINT32_C(0x51043108),   /** @brief AXI interconnect - INI x issuing functionality modification register */
      (_RW uint32_t* const)UINT32_C(0x51044108),   /** @brief AXI interconnect - INI x issuing functionality modification register */
      (_RW uint32_t* const)UINT32_C(0x51045108),   /** @brief AXI interconnect - INI x issuing functionality modification register */
      (_RW uint32_t* const)UINT32_C(0x51046108),   /** @brief AXI interconnect - INI x issuing functionality modification register */
      (_RW uint32_t* const)UINT32_C(0x51047108),   /** @brief AXI interconnect - INI x issuing functionality modification register */
    };

    /** @subsection AXI register definitions */

    static _RO uint32_t* const AXI_PERIPH_ID_0_REG = (_RO uint32_t* const)UINT32_C(0x51001FE0);/** @brief AXI interconnect - peripheral ID0 register */
    static _RO uint32_t* const AXI_PERIPH_ID_1_REG = (_RO uint32_t* const)UINT32_C(0x51001FE4);/** @brief AXI interconnect - peripheral ID1 register */
    static _RO uint32_t* const AXI_PERIPH_ID_2_REG = (_RO uint32_t* const)UINT32_C(0x51001FE8);/** @brief AXI interconnect - peripheral ID2 register */
    static _RO uint32_t* const AXI_COMP_ID_1_REG = (_RO uint32_t* const)UINT32_C(0x51001FF4);/** @brief AXI interconnect - component ID1 register */
    static _RW uint32_t* const AXI_TARG1_FN_MOD_LB_REG = (_RW uint32_t* const)UINT32_C(0x5100202C);/** @brief AXI interconnect - TARG x long burst functionality modification */
    static _RW uint32_t* const AXI_TARG2_FN_MOD_LB_REG = (_RW uint32_t* const)UINT32_C(0x5100302C);/** @brief AXI interconnect - TARG x long burst functionality modification */
    static _RW uint32_t* const AXI_INI1_FN_MOD2_REG = (_RW uint32_t* const)UINT32_C(0x51042024);/** @brief AXI interconnect - INI x functionality modification 2 register */
    static _RW uint32_t* const AXI_INI3_FN_MOD2_REG = (_RW uint32_t* const)UINT32_C(0x51044024);/** @brief AXI interconnect - INI x functionality modification 2 register */
    static _RW uint32_t* const AXI_INI1_FN_MOD_AHB_REG = (_RW uint32_t* const)UINT32_C(0x51042028);/** @brief AXI interconnect - INI x AHB functionality modification register */
    static _RW uint32_t* const AXI_INI3_FN_MOD_AHB_REG = (_RW uint32_t* const)UINT32_C(0x51044028);/** @brief AXI interconnect - INI x AHB functionality modification register */

    /** @subsection AXI field mask definitions */

    static const uint32_t AXI_PERIPH_ID_X_JEP106CON_MASK = UINT32_C(0x0000000F);                    /** @brief JEP106 continuation code */
    static const uint32_t AXI_PERIPH_ID_X_KCOUNT4_MASK = UINT32_C(0x000000F0);                      /** @brief Register file size */
    static const uint32_t AXI_PERIPH_ID_0_PARTNUM_MASK = UINT32_C(0x000000FF);                      /** @brief Peripheral part number bits 0 to 7 */
    static const uint32_t AXI_PERIPH_ID_1_PARTNUM_MASK = UINT32_C(0x0000000F);                      /** @brief Peripheral part number bits 8 to 11 */
    static const uint32_t AXI_PERIPH_ID_1_JEP106I_MASK = UINT32_C(0x000000F0);                      /** @brief JEP106 identity bits 0 to 3 */
    static const uint32_t AXI_PERIPH_ID_2_JEP106ID_MASK = UINT32_C(0x00000007);                     /** @brief JEP106 identity bits 4 to 6 */
    static const uint32_t AXI_PERIPH_ID_2_JEDEC_MASK = UINT32_C(0x00000008);                        /** @brief JEP106 code flag */
    static const uint32_t AXI_PERIPH_ID_2_REVISION_MASK = UINT32_C(0x000000F0);                     /** @brief Peripheral revision number */
    static const uint32_t AXI_PERIPH_ID_X_CUST_MOD_NUM_MASK = UINT32_C(0x0000000F);                 /** @brief Customer modification */
    static const uint32_t AXI_PERIPH_ID_X_REV_AND_MASK = UINT32_C(0x000000F0);                      /** @brief Customer version */
    static const uint32_t AXI_COMP_ID_X_PREAMBLE_MASK = UINT32_C(0x000000FF);                       /** @brief Preamble bits 0 to 7 */
    static const uint32_t AXI_COMP_ID_1_PREAMBLE_MASK = UINT32_C(0x0000000F);                       /** @brief Preamble bits 8 to 11 */
    static const uint32_t AXI_COMP_ID_1_CLASS_MASK = UINT32_C(0x000000F0);                          /** @brief Component class */
    static const uint32_t AXI_COMP_ID_X_PREAMBLE_MASK = UINT32_C(0x000000FF);                       /** @brief Preamble bits 12 to 19 */
    static const uint32_t AXI_COMP_ID_X_PREAMBLE_MASK = UINT32_C(0x000000FF);                       /** @brief Preamble bits 20 to 27 */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);    /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);    /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);    /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);    /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);    /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);    /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);    /** @brief READ_ISS_OVERRIDE */
    static const uint32_t AXI_TARGX_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);   /** @brief Switch matrix write issuing override for target */
    static const uint32_t AXI_TARGX_FN_MOD2_BYPASS_MERGE_MASK = UINT32_C(0x00000001);               /** @brief Disable packing of beats to match the output data width */
    static const uint32_t AXI_TARGX_FN_MOD2_BYPASS_MERGE_MASK = UINT32_C(0x00000001);               /** @brief Disable packing of beats to match the output data width */
    static const uint32_t AXI_TARGX_FN_MOD2_BYPASS_MERGE_MASK = UINT32_C(0x00000001);               /** @brief Disable packing of beats to match the output data width */
    static const uint32_t AXI_TARG1_FN_MOD_LB_FN_MOD_LB_MASK = UINT32_C(0x00000001);                /** @brief Controls burst breaking of long bursts */
    static const uint32_t AXI_TARG2_FN_MOD_LB_FN_MOD_LB_MASK = UINT32_C(0x00000001);                /** @brief Controls burst breaking of long bursts */
    static const uint32_t AXI_TARGX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);           /** @brief Override AMIB read issuing capability */
    static const uint32_t AXI_TARGX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);          /** @brief Override AMIB write issuing capability */
    static const uint32_t AXI_TARGX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);           /** @brief Override AMIB read issuing capability */
    static const uint32_t AXI_TARGX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);          /** @brief Override AMIB write issuing capability */
    static const uint32_t AXI_TARGX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);           /** @brief Override AMIB read issuing capability */
    static const uint32_t AXI_TARGX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);          /** @brief Override AMIB write issuing capability */
    static const uint32_t AXI_INI1_FN_MOD2_BYPASS_MERGE_MASK = UINT32_C(0x00000001);                /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
    static const uint32_t AXI_INI3_FN_MOD2_BYPASS_MERGE_MASK = UINT32_C(0x00000001);                /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
    static const uint32_t AXI_INI1_FN_MOD_AHB_RD_INC_OVERRIDE_MASK = UINT32_C(0x00000001);          /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
    static const uint32_t AXI_INI1_FN_MOD_AHB_WR_INC_OVERRIDE_MASK = UINT32_C(0x00000002);          /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
    static const uint32_t AXI_INI3_FN_MOD_AHB_RD_INC_OVERRIDE_MASK = UINT32_C(0x00000001);          /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
    static const uint32_t AXI_INI3_FN_MOD_AHB_WR_INC_OVERRIDE_MASK = UINT32_C(0x00000002);          /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
    static const uint32_t AXI_INIX_READ_QOS_AR_QOS_MASK = UINT32_C(0x0000000F);                     /** @brief Read channel qos setting */
    static const uint32_t AXI_INIX_READ_QOS_AR_QOS_MASK = UINT32_C(0x0000000F);                     /** @brief Read channel qos setting */
    static const uint32_t AXI_INIX_READ_QOS_AR_QOS_MASK = UINT32_C(0x0000000F);                     /** @brief Read channel qos setting */
    static const uint32_t AXI_INIX_READ_QOS_AR_QOS_MASK = UINT32_C(0x0000000F);                     /** @brief Read channel qos setting */
    static const uint32_t AXI_INIX_READ_QOS_AR_QOS_MASK = UINT32_C(0x0000000F);                     /** @brief Read channel qos setting */
    static const uint32_t AXI_INIX_READ_QOS_AR_QOS_MASK = UINT32_C(0x0000000F);                     /** @brief Read channel qos setting */
    static const uint32_t AXI_INIX_WRITE_QOS_AW_QOS_MASK = UINT32_C(0x0000000F);                    /** @brief Write channel qos setting */
    static const uint32_t AXI_INIX_WRITE_QOS_AW_QOS_MASK = UINT32_C(0x0000000F);                    /** @brief Write channel qos setting */
    static const uint32_t AXI_INIX_WRITE_QOS_AW_QOS_MASK = UINT32_C(0x0000000F);                    /** @brief Write channel qos setting */
    static const uint32_t AXI_INIX_WRITE_QOS_AW_QOS_MASK = UINT32_C(0x0000000F);                    /** @brief Write channel qos setting */
    static const uint32_t AXI_INIX_WRITE_QOS_AW_QOS_MASK = UINT32_C(0x0000000F);                    /** @brief Write channel qos setting */
    static const uint32_t AXI_INIX_WRITE_QOS_AW_QOS_MASK = UINT32_C(0x0000000F);                    /** @brief Write channel qos setting */
    static const uint32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);            /** @brief Override ASIB read issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);           /** @brief Override ASIB write issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);            /** @brief Override ASIB read issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);           /** @brief Override ASIB write issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);            /** @brief Override ASIB read issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);           /** @brief Override ASIB write issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);            /** @brief Override ASIB read issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);           /** @brief Override ASIB write issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);            /** @brief Override ASIB read issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);           /** @brief Override ASIB write issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_MASK = UINT32_C(0x00000001);            /** @brief Override ASIB read issuing capability */
    static const uint32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_MASK = UINT32_C(0x00000002);           /** @brief Override ASIB write issuing capability */

    /** @subsection AXI field position definitions */

    static const int32_t AXI_INIX_FN_MOD_JEP106CON_POS = INT32_C(0);            /** @brief JEP106 continuation code */
    static const int32_t AXI_INIX_FN_MOD_KCOUNT4_POS = INT32_C(4);              /** @brief Register file size */
    static const int32_t AXI_INIX_FN_MOD_PARTNUM_POS = INT32_C(0);              /** @brief Peripheral part number bits 0 to 7 */
    static const int32_t AXI_INIX_FN_MOD_PARTNUM_POS = INT32_C(0);              /** @brief Peripheral part number bits 8 to 11 */
    static const int32_t AXI_INIX_FN_MOD_JEP106I_POS = INT32_C(4);              /** @brief JEP106 identity bits 0 to 3 */
    static const int32_t AXI_INIX_FN_MOD_JEP106ID_POS = INT32_C(0);             /** @brief JEP106 identity bits 4 to 6 */
    static const int32_t AXI_INIX_FN_MOD_JEDEC_POS = INT32_C(3);                /** @brief JEP106 code flag */
    static const int32_t AXI_INIX_FN_MOD_REVISION_POS = INT32_C(4);             /** @brief Peripheral revision number */
    static const int32_t AXI_INIX_FN_MOD_CUST_MOD_NUM_POS = INT32_C(0);         /** @brief Customer modification */
    static const int32_t AXI_INIX_FN_MOD_REV_AND_POS = INT32_C(4);              /** @brief Customer version */
    static const int32_t AXI_INIX_FN_MOD_PREAMBLE_POS = INT32_C(0);             /** @brief Preamble bits 0 to 7 */
    static const int32_t AXI_INIX_FN_MOD_PREAMBLE_POS = INT32_C(0);             /** @brief Preamble bits 8 to 11 */
    static const int32_t AXI_INIX_FN_MOD_CLASS_POS = INT32_C(4);                /** @brief Component class */
    static const int32_t AXI_INIX_FN_MOD_PREAMBLE_POS = INT32_C(0);             /** @brief Preamble bits 12 to 19 */
    static const int32_t AXI_INIX_FN_MOD_PREAMBLE_POS = INT32_C(0);             /** @brief Preamble bits 20 to 27 */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief READ_ISS_OVERRIDE */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Switch matrix write issuing override for target */
    static const int32_t AXI_INIX_FN_MOD_BYPASS_MERGE_POS = INT32_C(0);         /** @brief Disable packing of beats to match the output data width */
    static const int32_t AXI_INIX_FN_MOD_BYPASS_MERGE_POS = INT32_C(0);         /** @brief Disable packing of beats to match the output data width */
    static const int32_t AXI_INIX_FN_MOD_BYPASS_MERGE_POS = INT32_C(0);         /** @brief Disable packing of beats to match the output data width */
    static const int32_t AXI_INIX_FN_MOD_FN_MOD_LB_POS = INT32_C(0);            /** @brief Controls burst breaking of long bursts */
    static const int32_t AXI_INIX_FN_MOD_FN_MOD_LB_POS = INT32_C(0);            /** @brief Controls burst breaking of long bursts */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override AMIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override AMIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override AMIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override AMIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override AMIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override AMIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_BYPASS_MERGE_POS = INT32_C(0);         /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
    static const int32_t AXI_INIX_FN_MOD_BYPASS_MERGE_POS = INT32_C(0);         /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
    static const int32_t AXI_INIX_FN_MOD_RD_INC_OVERRIDE_POS = INT32_C(0);      /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
    static const int32_t AXI_INIX_FN_MOD_WR_INC_OVERRIDE_POS = INT32_C(1);      /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
    static const int32_t AXI_INIX_FN_MOD_RD_INC_OVERRIDE_POS = INT32_C(0);      /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
    static const int32_t AXI_INIX_FN_MOD_WR_INC_OVERRIDE_POS = INT32_C(1);      /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
    static const int32_t AXI_INIX_FN_MOD_AR_QOS_POS = INT32_C(0);               /** @brief Read channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AR_QOS_POS = INT32_C(0);               /** @brief Read channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AR_QOS_POS = INT32_C(0);               /** @brief Read channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AR_QOS_POS = INT32_C(0);               /** @brief Read channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AR_QOS_POS = INT32_C(0);               /** @brief Read channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AR_QOS_POS = INT32_C(0);               /** @brief Read channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AW_QOS_POS = INT32_C(0);               /** @brief Write channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AW_QOS_POS = INT32_C(0);               /** @brief Write channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AW_QOS_POS = INT32_C(0);               /** @brief Write channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AW_QOS_POS = INT32_C(0);               /** @brief Write channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AW_QOS_POS = INT32_C(0);               /** @brief Write channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_AW_QOS_POS = INT32_C(0);               /** @brief Write channel qos setting */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override ASIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override ASIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override ASIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override ASIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override ASIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override ASIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override ASIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override ASIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override ASIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override ASIB write issuing capability */
    static const int32_t AXI_INIX_FN_MOD_READ_ISS_OVERRIDE_POS = INT32_C(0);    /** @brief Override ASIB read issuing capability */
    static const int32_t AXI_INIX_FN_MOD_WRITE_ISS_OVERRIDE_POS = INT32_C(1);   /** @brief Override ASIB write issuing capability */

    /**********************************************************************************************
     * @section HASH Definitions
     **********************************************************************************************/

    /** @subsection HASH IRQ interrupt definitions */

    static const int32_t HASH_RNG_IRQ = INT32_C(80);   /** @brief HASH and RNG */

    /** @subsection HASH register array definitions */

    static _RO uint32_t* const HASH_HRX_REG[8] = {
      (_RO uint32_t* const)UINT32_C(0x4802140C),   /** @brief Digest registers */
      (_RO uint32_t* const)UINT32_C(0x48021410),   /** @brief Digest registers */
      (_RO uint32_t* const)UINT32_C(0x48021414),   /** @brief Digest registers */
      (_RO uint32_t* const)UINT32_C(0x48021418),   /** @brief Digest registers */
      (_RO uint32_t* const)UINT32_C(0x4802141C),   /** @brief Digest registers */
      (_RO uint32_t* const)UINT32_C(0x48021724),   /** @brief Read-only */
      (_RO uint32_t* const)UINT32_C(0x48021728),   /** @brief Read-only */
      (_RO uint32_t* const)UINT32_C(0x4802172C),   /** @brief Read-only */
    };

    static _RW uint32_t* const HASH_CSRX_REG[54] = {
      (_RW uint32_t* const)UINT32_C(0x480214F8),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480214FC),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021500),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021504),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021508),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802150C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021510),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021514),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021518),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802151C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021520),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021524),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021528),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802152C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021530),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021534),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021538),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802153C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021540),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021544),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021548),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802154C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021550),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021554),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021558),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802155C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021560),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021564),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021568),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802156C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021570),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021574),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021578),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802157C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021580),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021584),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021588),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802158C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021590),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021594),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x48021598),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x4802159C),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215A0),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215A4),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215A8),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215AC),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215B0),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215B4),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215B8),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215BC),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215C0),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215C4),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215C8),   /** @brief Context swap registers */
      (_RW uint32_t* const)UINT32_C(0x480215CC),   /** @brief Context swap registers */
    };

    static _RO uint32_t* const HASH_HASH_HRX_REG[5] = {
      (_RO uint32_t* const)UINT32_C(0x48021710),   /** @brief HASH digest register */
      (_RO uint32_t* const)UINT32_C(0x48021714),   /** @brief Read-only */
      (_RO uint32_t* const)UINT32_C(0x48021718),   /** @brief Read-only */
      (_RO uint32_t* const)UINT32_C(0x4802171C),   /** @brief Read-only */
      (_RO uint32_t* const)UINT32_C(0x48021720),   /** @brief Read-only */
    };

    /** @subsection HASH register definitions */

    static _RW uint32_t* const HASH_CR_REG = (_RW uint32_t* const)UINT32_C(0x48021400);    /** @brief Control register */
    static _RW uint32_t* const HASH_DIN_REG = (_RW uint32_t* const)UINT32_C(0x48021404);   /** @brief Data input register */
    static _RW uint32_t* const HASH_STR_REG = (_RW uint32_t* const)UINT32_C(0x48021408);   /** @brief Start register */
    static _RW uint32_t* const HASH_IMR_REG = (_RW uint32_t* const)UINT32_C(0x48021420);   /** @brief Interrupt enable register */
    static _RW uint32_t* const HASH_SR_REG = (_RW uint32_t* const)UINT32_C(0x48021424);    /** @brief Status register */

    /** @subsection HASH field mask definitions */

    static const uint32_t HASH_CR_INIT_MASK = UINT32_C(0x00000004);       /** @brief Initialize message digest calculation */
    static const uint32_t HASH_CR_DMAE_MASK = UINT32_C(0x00000008);       /** @brief DMA enable */
    static const uint32_t HASH_CR_DATATYPE_MASK = UINT32_C(0x00000030);   /** @brief Data type selection */
    static const uint32_t HASH_CR_MODE_MASK = UINT32_C(0x00000040);       /** @brief Mode selection */
    static const uint32_t HASH_CR_ALGO0_MASK = UINT32_C(0x00000080);      /** @brief Algorithm selection */
    static const uint32_t HASH_CR_NBW_MASK = UINT32_C(0x00000F00);        /** @brief Number of words already pushed */
    static const uint32_t HASH_CR_DINNE_MASK = UINT32_C(0x00001000);      /** @brief DIN not empty */
    static const uint32_t HASH_CR_MDMAT_MASK = UINT32_C(0x00002000);      /** @brief Multiple DMA transfers */
    static const uint32_t HASH_CR_LKEY_MASK = UINT32_C(0x00010000);       /** @brief Long key selection */
    static const uint32_t HASH_CR_ALGO1_MASK = UINT32_C(0x00040000);      /** @brief ALGO */
    static const uint32_t HASH_STR_DCAL_MASK = UINT32_C(0x00000100);      /** @brief Digest calculation */
    static const uint32_t HASH_STR_NBLW_MASK = UINT32_C(0x0000001F);      /** @brief Number of valid bits in the last word of the message */
    static const uint32_t HASH_IMR_DCIE_MASK = UINT32_C(0x00000002);      /** @brief Digest calculation completion interrupt enable */
    static const uint32_t HASH_IMR_DINIE_MASK = UINT32_C(0x00000001);     /** @brief Data input interrupt enable */
    static const uint32_t HASH_SR_BUSY_MASK = UINT32_C(0x00000008);       /** @brief Busy bit */
    static const uint32_t HASH_SR_DMAS_MASK = UINT32_C(0x00000004);       /** @brief DMA status */
    static const uint32_t HASH_SR_DCIS_MASK = UINT32_C(0x00000002);       /** @brief Digest calculation completion interrupt status */
    static const uint32_t HASH_SR_DINIS_MASK = UINT32_C(0x00000001);      /** @brief Data input interrupt status */

    /** @subsection HASH field position definitions */

    static const int32_t HASH_HRX_INIT_POS = INT32_C(2);        /** @brief Initialize message digest calculation */
    static const int32_t HASH_HRX_DMAE_POS = INT32_C(3);        /** @brief DMA enable */
    static const int32_t HASH_HRX_DATATYPE_POS = INT32_C(4);    /** @brief Data type selection */
    static const int32_t HASH_HRX_MODE_POS = INT32_C(6);        /** @brief Mode selection */
    static const int32_t HASH_HRX_ALGO0_POS = INT32_C(7);       /** @brief Algorithm selection */
    static const int32_t HASH_HRX_NBW_POS = INT32_C(8);         /** @brief Number of words already pushed */
    static const int32_t HASH_HRX_DINNE_POS = INT32_C(12);      /** @brief DIN not empty */
    static const int32_t HASH_HRX_MDMAT_POS = INT32_C(13);      /** @brief Multiple DMA transfers */
    static const int32_t HASH_HRX_LKEY_POS = INT32_C(16);       /** @brief Long key selection */
    static const int32_t HASH_HRX_ALGO1_POS = INT32_C(18);      /** @brief ALGO */
    static const int32_t HASH_HRX_DCAL_POS = INT32_C(8);        /** @brief Digest calculation */
    static const int32_t HASH_HRX_NBLW_POS = INT32_C(0);        /** @brief Number of valid bits in the last word of the message */
    static const int32_t HASH_HRX_DCIE_POS = INT32_C(1);        /** @brief Digest calculation completion interrupt enable */
    static const int32_t HASH_HRX_DINIE_POS = INT32_C(0);       /** @brief Data input interrupt enable */
    static const int32_t HASH_HRX_BUSY_POS = INT32_C(3);        /** @brief Busy bit */
    static const int32_t HASH_HRX_DMAS_POS = INT32_C(2);        /** @brief DMA status */
    static const int32_t HASH_HRX_DCIS_POS = INT32_C(1);        /** @brief Digest calculation completion interrupt status */
    static const int32_t HASH_HRX_DINIS_POS = INT32_C(0);       /** @brief Data input interrupt status */

    /**********************************************************************************************
     * @section CRYP Definitions
     **********************************************************************************************/

    /** @subsection CRYP IRQ interrupt definitions */

    static const int32_t CRYP_IRQ = INT32_C(79);   /** @brief CRYP global interrupt */

    /** @subsection CRYP register array definitions */

    static _RW uint32_t* const CRYP_KXLR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x48021020),   /** @brief Key registers */
      (_RW uint32_t* const)UINT32_C(0x48021028),   /** @brief Key registers */
      (_RW uint32_t* const)UINT32_C(0x48021030),   /** @brief Key registers */
      (_RW uint32_t* const)UINT32_C(0x48021038),   /** @brief Key registers */
    };

    static _RW uint32_t* const CRYP_KXRR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x48021024),   /** @brief Key registers */
      (_RW uint32_t* const)UINT32_C(0x4802102C),   /** @brief Key registers */
      (_RW uint32_t* const)UINT32_C(0x48021034),   /** @brief Key registers */
      (_RW uint32_t* const)UINT32_C(0x4802103C),   /** @brief Key registers */
    };

    static _RW uint32_t* const CRYP_CSGCMCCMXR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x48021050),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021054),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021058),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x4802105C),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021060),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021064),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021068),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x4802106C),   /** @brief Context swap register */
    };

    static _RW uint32_t* const CRYP_CSGCMXR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x48021070),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021074),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021078),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x4802107C),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021080),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021084),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x48021088),   /** @brief Context swap register */
      (_RW uint32_t* const)UINT32_C(0x4802108C),   /** @brief Context swap register */
    };

    /** @subsection CRYP register definitions */

    static _RW uint32_t* const CRYP_CR_REG = (_RW uint32_t* const)UINT32_C(0x48021000);      /** @brief Control register */
    static _RO uint32_t* const CRYP_SR_REG = (_RO uint32_t* const)UINT32_C(0x48021004);      /** @brief Status register */
    static _RW uint32_t* const CRYP_DIN_REG = (_RW uint32_t* const)UINT32_C(0x48021008);     /** @brief Data input register */
    static _RO uint32_t* const CRYP_DOUT_REG = (_RO uint32_t* const)UINT32_C(0x4802100C);    /** @brief Data output register */
    static _RW uint32_t* const CRYP_DMACR_REG = (_RW uint32_t* const)UINT32_C(0x48021010);   /** @brief DMA control register */
    static _RW uint32_t* const CRYP_IMSCR_REG = (_RW uint32_t* const)UINT32_C(0x48021014);   /** @brief Interrupt mask set/clear register */
    static _RO uint32_t* const CRYP_RISR_REG = (_RO uint32_t* const)UINT32_C(0x48021018);    /** @brief Raw interrupt status register */
    static _RO uint32_t* const CRYP_MISR_REG = (_RO uint32_t* const)UINT32_C(0x4802101C);    /** @brief Masked interrupt status register */
    static _RW uint32_t* const CRYP_IV0LR_REG = (_RW uint32_t* const)UINT32_C(0x48021040);   /** @brief Initialization vector registers */
    static _RW uint32_t* const CRYP_IV0RR_REG = (_RW uint32_t* const)UINT32_C(0x48021044);   /** @brief Initialization vector registers */
    static _RW uint32_t* const CRYP_IV1LR_REG = (_RW uint32_t* const)UINT32_C(0x48021048);   /** @brief Initialization vector registers */
    static _RW uint32_t* const CRYP_IV1RR_REG = (_RW uint32_t* const)UINT32_C(0x4802104C);   /** @brief Initialization vector registers */

    /** @subsection CRYP field mask array definitions */

    static const uint32_t CRYP_KXLR_B2X_MASK[56] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief B224 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief B230 */
      UINT32_C(0x00000080),   /** @brief B231 */
      UINT32_C(0x00000100),   /** @brief B232 */
      UINT32_C(0x00000200),   /** @brief B233 */
      UINT32_C(0x00000400),   /** @brief B234 */
      UINT32_C(0x00000800),   /** @brief B235 */
      UINT32_C(0x00001000),   /** @brief B236 */
      UINT32_C(0x00002000),   /** @brief B237 */
      UINT32_C(0x00004000),   /** @brief B238 */
      UINT32_C(0x00008000),   /** @brief B239 */
      UINT32_C(0x00010000),   /** @brief B240 */
      UINT32_C(0x00020000),   /** @brief B241 */
      UINT32_C(0x00040000),   /** @brief B242 */
      UINT32_C(0x00080000),   /** @brief B243 */
      UINT32_C(0x00100000),   /** @brief B244 */
      UINT32_C(0x00200000),   /** @brief B245 */
      UINT32_C(0x00400000),   /** @brief B246 */
      UINT32_C(0x00800000),   /** @brief B247 */
      UINT32_C(0x01000000),   /** @brief B248 */
      UINT32_C(0x02000000),   /** @brief B249 */
      UINT32_C(0x04000000),   /** @brief B250 */
      UINT32_C(0x08000000),   /** @brief B251 */
      UINT32_C(0x10000000),   /** @brief B252 */
      UINT32_C(0x20000000),   /** @brief B253 */
      UINT32_C(0x40000000),   /** @brief B254 */
      UINT32_C(0x80000000),   /** @brief B255 */
    };

    static const uint32_t CRYP_KXLR_B22X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief B225 */
      UINT32_C(0x00000004),   /** @brief B226 */
      UINT32_C(0x00000008),   /** @brief B227 */
      UINT32_C(0x00000010),   /** @brief B228 */
      UINT32_C(0x00000020),   /** @brief B229 */
    };

    static const uint32_t CRYP_KXRR_B20X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief B201 */
      UINT32_C(0x00000400),   /** @brief B202 */
      UINT32_C(0x00000800),   /** @brief B203 */
      UINT32_C(0x00001000),   /** @brief B204 */
      UINT32_C(0x00002000),   /** @brief B205 */
      UINT32_C(0x00004000),   /** @brief B206 */
      UINT32_C(0x00008000),   /** @brief B207 */
      UINT32_C(0x00010000),   /** @brief B208 */
      UINT32_C(0x00020000),   /** @brief B209 */
    };

    static const uint32_t CRYP_KXLR_B1X_MASK[92] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief B160 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000400),   /** @brief B170 */
      UINT32_C(0x00000800),   /** @brief B171 */
      UINT32_C(0x00001000),   /** @brief B172 */
      UINT32_C(0x00002000),   /** @brief B173 */
      UINT32_C(0x00004000),   /** @brief B174 */
      UINT32_C(0x00008000),   /** @brief B175 */
      UINT32_C(0x00010000),   /** @brief B176 */
      UINT32_C(0x00020000),   /** @brief B177 */
      UINT32_C(0x00040000),   /** @brief B178 */
      UINT32_C(0x00080000),   /** @brief B179 */
      UINT32_C(0x00100000),   /** @brief B180 */
      UINT32_C(0x00200000),   /** @brief B181 */
      UINT32_C(0x00400000),   /** @brief B182 */
      UINT32_C(0x00800000),   /** @brief B183 */
      UINT32_C(0x01000000),   /** @brief B184 */
      UINT32_C(0x02000000),   /** @brief B185 */
      UINT32_C(0x04000000),   /** @brief B186 */
      UINT32_C(0x08000000),   /** @brief B187 */
      UINT32_C(0x10000000),   /** @brief B188 */
      UINT32_C(0x20000000),   /** @brief B189 */
      UINT32_C(0x40000000),   /** @brief B190 */
      UINT32_C(0x80000000),   /** @brief B191 */
    };

    static const uint32_t CRYP_KXLR_B16X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief B161 */
      UINT32_C(0x00000004),   /** @brief B162 */
      UINT32_C(0x00000008),   /** @brief B163 */
      UINT32_C(0x00000010),   /** @brief B164 */
      UINT32_C(0x00000020),   /** @brief B165 */
      UINT32_C(0x00000040),   /** @brief B166 */
      UINT32_C(0x00000080),   /** @brief B167 */
      UINT32_C(0x00000100),   /** @brief B168 */
      UINT32_C(0x00000200),   /** @brief B169 */
    };

    static const uint32_t CRYP_KXRR_B12X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief B129 */
    };

    static const uint32_t CRYP_KXLR_B10X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000020),   /** @brief B101 */
      UINT32_C(0x00000040),   /** @brief B102 */
      UINT32_C(0x00000080),   /** @brief B103 */
      UINT32_C(0x00000100),   /** @brief B104 */
      UINT32_C(0x00000200),   /** @brief B105 */
      UINT32_C(0x00000400),   /** @brief B106 */
      UINT32_C(0x00000800),   /** @brief B107 */
      UINT32_C(0x00001000),   /** @brief B108 */
      UINT32_C(0x00002000),   /** @brief B109 */
    };

    static const uint32_t CRYP_KXRR_BX_MASK[96] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief B64 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief B70 */
      UINT32_C(0x00000080),   /** @brief B71 */
      UINT32_C(0x00000100),   /** @brief B72 */
      UINT32_C(0x00000200),   /** @brief B73 */
      UINT32_C(0x00000400),   /** @brief B74 */
      UINT32_C(0x00000800),   /** @brief B75 */
      UINT32_C(0x00001000),   /** @brief B76 */
      UINT32_C(0x00002000),   /** @brief B77 */
      UINT32_C(0x00004000),   /** @brief B78 */
      UINT32_C(0x00008000),   /** @brief B79 */
      UINT32_C(0x00010000),   /** @brief B80 */
      UINT32_C(0x00020000),   /** @brief B81 */
      UINT32_C(0x00040000),   /** @brief B82 */
      UINT32_C(0x00080000),   /** @brief B83 */
      UINT32_C(0x00100000),   /** @brief B84 */
      UINT32_C(0x00200000),   /** @brief B85 */
      UINT32_C(0x00400000),   /** @brief B86 */
      UINT32_C(0x00800000),   /** @brief B87 */
      UINT32_C(0x01000000),   /** @brief B88 */
      UINT32_C(0x02000000),   /** @brief B89 */
      UINT32_C(0x04000000),   /** @brief B90 */
      UINT32_C(0x08000000),   /** @brief B91 */
      UINT32_C(0x10000000),   /** @brief B92 */
      UINT32_C(0x20000000),   /** @brief B93 */
      UINT32_C(0x40000000),   /** @brief B94 */
      UINT32_C(0x80000000),   /** @brief B95 */
    };

    static const uint32_t CRYP_KXRR_B6X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief B65 */
      UINT32_C(0x00000004),   /** @brief B66 */
      UINT32_C(0x00000008),   /** @brief B67 */
      UINT32_C(0x00000010),   /** @brief B68 */
      UINT32_C(0x00000020),   /** @brief B69 */
    };

    static const uint32_t CRYP_KXLR_B3X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief B33 */
      UINT32_C(0x00000004),   /** @brief B34 */
      UINT32_C(0x00000008),   /** @brief B35 */
      UINT32_C(0x00000010),   /** @brief B36 */
      UINT32_C(0x00000020),   /** @brief B37 */
      UINT32_C(0x00000040),   /** @brief B38 */
      UINT32_C(0x00000080),   /** @brief B39 */
    };

    static const uint32_t CRYP_IV0LR_IVX_MASK[32] = {
      UINT32_C(0x80000000),   /** @brief IV0 */
      UINT32_C(0x40000000),   /** @brief IV1 */
      UINT32_C(0x20000000),   /** @brief IV2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x08000000),   /** @brief IV4 */
      UINT32_C(0x04000000),   /** @brief IV5 */
      UINT32_C(0x02000000),   /** @brief IV6 */
      UINT32_C(0x01000000),   /** @brief IV7 */
      UINT32_C(0x00800000),   /** @brief IV8 */
      UINT32_C(0x00400000),   /** @brief IV9 */
      UINT32_C(0x00200000),   /** @brief IV10 */
      UINT32_C(0x00100000),   /** @brief IV11 */
      UINT32_C(0x00080000),   /** @brief IV12 */
      UINT32_C(0x00040000),   /** @brief IV13 */
      UINT32_C(0x00020000),   /** @brief IV14 */
      UINT32_C(0x00010000),   /** @brief IV15 */
      UINT32_C(0x00008000),   /** @brief IV16 */
      UINT32_C(0x00004000),   /** @brief IV17 */
      UINT32_C(0x00002000),   /** @brief IV18 */
      UINT32_C(0x00001000),   /** @brief IV19 */
      UINT32_C(0x00000800),   /** @brief IV20 */
      UINT32_C(0x00000400),   /** @brief IV21 */
      UINT32_C(0x00000200),   /** @brief IV22 */
      UINT32_C(0x00000100),   /** @brief IV23 */
      UINT32_C(0x00000080),   /** @brief IV24 */
      UINT32_C(0x00000040),   /** @brief IV25 */
      UINT32_C(0x00000020),   /** @brief IV26 */
      UINT32_C(0x00000010),   /** @brief IV27 */
      UINT32_C(0x00000008),   /** @brief IV28 */
      UINT32_C(0x00000004),   /** @brief IV29 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief IV31 */
    };

    static const uint32_t CRYP_IV0LR_IV3X_MASK[2] = {
      UINT32_C(0x00000002),   /** @brief IV30 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static const uint32_t CRYP_IV0RR_IV6X_MASK[4] = {
      UINT32_C(0x00000008),   /** @brief IV60 */
      UINT32_C(0x00000004),   /** @brief IV61 */
      UINT32_C(0x00000002),   /** @brief IV62 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static const uint32_t CRYP_IV1LR_IV9X_MASK[6] = {
      UINT32_C(0x00000020),   /** @brief IV90 */
      UINT32_C(0x00000010),   /** @brief IV91 */
      UINT32_C(0x00000008),   /** @brief IV92 */
      UINT32_C(0x00000004),   /** @brief IV93 */
      UINT32_C(0x00000002),   /** @brief IV94 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static const uint32_t CRYP_IV1RR_IV12X_MASK[8] = {
      UINT32_C(0x00000080),   /** @brief IV120 */
      UINT32_C(0x00000040),   /** @brief IV121 */
      UINT32_C(0x00000020),   /** @brief IV122 */
      UINT32_C(0x00000010),   /** @brief IV123 */
      UINT32_C(0x00000008),   /** @brief IV124 */
      UINT32_C(0x00000004),   /** @brief IV125 */
      UINT32_C(0x00000002),   /** @brief IV126 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    /** @subsection CRYP field mask definitions */

    static const uint32_t CRYP_CR_ALGODIR_MASK = UINT32_C(0x00000004);     /** @brief Algorithm direction */
    static const uint32_t CRYP_CR_ALGOMODE0_MASK = UINT32_C(0x00000038);   /** @brief Algorithm mode */
    static const uint32_t CRYP_CR_DATATYPE_MASK = UINT32_C(0x000000C0);    /** @brief Data type selection */
    static const uint32_t CRYP_CR_KEYSIZE_MASK = UINT32_C(0x00000300);     /** @brief Key size selection (AES mode only) */
    static const uint32_t CRYP_CR_FFLUSH_MASK = UINT32_C(0x00004000);      /** @brief FIFO flush */
    static const uint32_t CRYP_CR_CRYPEN_MASK = UINT32_C(0x00008000);      /** @brief Cryptographic processor enable */
    static const uint32_t CRYP_CR_GCM_CCMPH_MASK = UINT32_C(0x00030000);   /** @brief GCM_CCMPH */
    static const uint32_t CRYP_CR_ALGOMODE3_MASK = UINT32_C(0x00080000);   /** @brief ALGOMODE */
    static const uint32_t CRYP_SR_BUSY_MASK = UINT32_C(0x00000010);        /** @brief Busy bit */
    static const uint32_t CRYP_SR_OFFU_MASK = UINT32_C(0x00000008);        /** @brief Output FIFO full */
    static const uint32_t CRYP_SR_OFNE_MASK = UINT32_C(0x00000004);        /** @brief Output FIFO not empty */
    static const uint32_t CRYP_SR_IFNF_MASK = UINT32_C(0x00000002);        /** @brief Input FIFO not full */
    static const uint32_t CRYP_SR_IFEM_MASK = UINT32_C(0x00000001);        /** @brief Input FIFO empty */
    static const uint32_t CRYP_DMACR_DOEN_MASK = UINT32_C(0x00000002);     /** @brief DMA output enable */
    static const uint32_t CRYP_DMACR_DIEN_MASK = UINT32_C(0x00000001);     /** @brief DMA input enable */
    static const uint32_t CRYP_IMSCR_OUTIM_MASK = UINT32_C(0x00000002);    /** @brief Output FIFO service interrupt mask */
    static const uint32_t CRYP_IMSCR_INIM_MASK = UINT32_C(0x00000001);     /** @brief Input FIFO service interrupt mask */
    static const uint32_t CRYP_RISR_OUTRIS_MASK = UINT32_C(0x00000002);    /** @brief Output FIFO service raw interrupt status */
    static const uint32_t CRYP_RISR_INRIS_MASK = UINT32_C(0x00000001);     /** @brief Input FIFO service raw interrupt status */
    static const uint32_t CRYP_MISR_OUTMIS_MASK = UINT32_C(0x00000002);    /** @brief Output FIFO service masked interrupt status */
    static const uint32_t CRYP_MISR_INMIS_MASK = UINT32_C(0x00000001);     /** @brief Input FIFO service masked interrupt status */
    static const uint32_t CRYP_KXRR_B192_MASK = UINT32_C(0x00000001);      /** @brief B192 */
    static const uint32_t CRYP_KXRR_B193_MASK = UINT32_C(0x00000002);      /** @brief B193 */
    static const uint32_t CRYP_KXRR_B194_MASK = UINT32_C(0x00000004);      /** @brief B194 */
    static const uint32_t CRYP_KXRR_B195_MASK = UINT32_C(0x00000008);      /** @brief B195 */
    static const uint32_t CRYP_KXRR_B196_MASK = UINT32_C(0x00000010);      /** @brief B196 */
    static const uint32_t CRYP_KXRR_B197_MASK = UINT32_C(0x00000020);      /** @brief B197 */
    static const uint32_t CRYP_KXRR_B198_MASK = UINT32_C(0x00000040);      /** @brief B198 */
    static const uint32_t CRYP_KXRR_B199_MASK = UINT32_C(0x00000080);      /** @brief B199 */
    static const uint32_t CRYP_KXLR_B96_MASK = UINT32_C(0x00000001);       /** @brief B96 */
    static const uint32_t CRYP_KXLR_B97_MASK = UINT32_C(0x00000002);       /** @brief B97 */
    static const uint32_t CRYP_KXLR_B98_MASK = UINT32_C(0x00000004);       /** @brief B98 */
    static const uint32_t CRYP_KXLR_B99_MASK = UINT32_C(0x00000008);       /** @brief B99 */
    static const uint32_t CRYP_IV0LR_IV3_MASK = UINT32_C(0x10000000);      /** @brief IV3 */
    static const uint32_t CRYP_IV1RR_IV127_MASK = UINT32_C(0x00000001);    /** @brief IV127 */
    static const uint32_t CRYP_IV1RR_IV119_MASK = UINT32_C(0x00000100);    /** @brief IV119 */
    static const uint32_t CRYP_IV1RR_IV118_MASK = UINT32_C(0x00000200);    /** @brief IV118 */
    static const uint32_t CRYP_IV1RR_IV117_MASK = UINT32_C(0x00000400);    /** @brief IV117 */
    static const uint32_t CRYP_IV1RR_IV116_MASK = UINT32_C(0x00000800);    /** @brief IV116 */
    static const uint32_t CRYP_IV1RR_IV115_MASK = UINT32_C(0x00001000);    /** @brief IV115 */
    static const uint32_t CRYP_IV1RR_IV114_MASK = UINT32_C(0x00002000);    /** @brief IV114 */
    static const uint32_t CRYP_IV1RR_IV113_MASK = UINT32_C(0x00004000);    /** @brief IV113 */
    static const uint32_t CRYP_IV1RR_IV112_MASK = UINT32_C(0x00008000);    /** @brief IV112 */
    static const uint32_t CRYP_IV1RR_IV111_MASK = UINT32_C(0x00010000);    /** @brief IV111 */
    static const uint32_t CRYP_IV1RR_IV110_MASK = UINT32_C(0x00020000);    /** @brief IV110 */
    static const uint32_t CRYP_IV1RR_IV109_MASK = UINT32_C(0x00040000);    /** @brief IV109 */
    static const uint32_t CRYP_IV1RR_IV108_MASK = UINT32_C(0x00080000);    /** @brief IV108 */
    static const uint32_t CRYP_IV1RR_IV107_MASK = UINT32_C(0x00100000);    /** @brief IV107 */
    static const uint32_t CRYP_IV1RR_IV106_MASK = UINT32_C(0x00200000);    /** @brief IV106 */
    static const uint32_t CRYP_IV1RR_IV105_MASK = UINT32_C(0x00400000);    /** @brief IV105 */
    static const uint32_t CRYP_IV1RR_IV104_MASK = UINT32_C(0x00800000);    /** @brief IV104 */
    static const uint32_t CRYP_IV1RR_IV103_MASK = UINT32_C(0x01000000);    /** @brief IV103 */
    static const uint32_t CRYP_IV1RR_IV102_MASK = UINT32_C(0x02000000);    /** @brief IV102 */
    static const uint32_t CRYP_IV1RR_IV101_MASK = UINT32_C(0x04000000);    /** @brief IV101 */
    static const uint32_t CRYP_IV1RR_IV100_MASK = UINT32_C(0x08000000);    /** @brief IV100 */

    /** @subsection CRYP field position array definitions */

    static const int32_t CRYP_CSGCMXR_B2X_POS[56] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief B224 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief B230 */
      INT32_C(7),    /** @brief B231 */
      INT32_C(8),    /** @brief B232 */
      INT32_C(9),    /** @brief B233 */
      INT32_C(10),   /** @brief B234 */
      INT32_C(11),   /** @brief B235 */
      INT32_C(12),   /** @brief B236 */
      INT32_C(13),   /** @brief B237 */
      INT32_C(14),   /** @brief B238 */
      INT32_C(15),   /** @brief B239 */
      INT32_C(16),   /** @brief B240 */
      INT32_C(17),   /** @brief B241 */
      INT32_C(18),   /** @brief B242 */
      INT32_C(19),   /** @brief B243 */
      INT32_C(20),   /** @brief B244 */
      INT32_C(21),   /** @brief B245 */
      INT32_C(22),   /** @brief B246 */
      INT32_C(23),   /** @brief B247 */
      INT32_C(24),   /** @brief B248 */
      INT32_C(25),   /** @brief B249 */
      INT32_C(26),   /** @brief B250 */
      INT32_C(27),   /** @brief B251 */
      INT32_C(28),   /** @brief B252 */
      INT32_C(29),   /** @brief B253 */
      INT32_C(30),   /** @brief B254 */
      INT32_C(31),   /** @brief B255 */
    };

    static const int32_t CRYP_CSGCMXR_B22X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief B225 */
      INT32_C(2),    /** @brief B226 */
      INT32_C(3),    /** @brief B227 */
      INT32_C(4),    /** @brief B228 */
      INT32_C(5),    /** @brief B229 */
    };

    static const int32_t CRYP_CSGCMXR_B20X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief B201 */
      INT32_C(10),   /** @brief B202 */
      INT32_C(11),   /** @brief B203 */
      INT32_C(12),   /** @brief B204 */
      INT32_C(13),   /** @brief B205 */
      INT32_C(14),   /** @brief B206 */
      INT32_C(15),   /** @brief B207 */
      INT32_C(16),   /** @brief B208 */
      INT32_C(17),   /** @brief B209 */
    };

    static const int32_t CRYP_CSGCMXR_B1X_POS[92] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief B160 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(10),   /** @brief B170 */
      INT32_C(11),   /** @brief B171 */
      INT32_C(12),   /** @brief B172 */
      INT32_C(13),   /** @brief B173 */
      INT32_C(14),   /** @brief B174 */
      INT32_C(15),   /** @brief B175 */
      INT32_C(16),   /** @brief B176 */
      INT32_C(17),   /** @brief B177 */
      INT32_C(18),   /** @brief B178 */
      INT32_C(19),   /** @brief B179 */
      INT32_C(20),   /** @brief B180 */
      INT32_C(21),   /** @brief B181 */
      INT32_C(22),   /** @brief B182 */
      INT32_C(23),   /** @brief B183 */
      INT32_C(24),   /** @brief B184 */
      INT32_C(25),   /** @brief B185 */
      INT32_C(26),   /** @brief B186 */
      INT32_C(27),   /** @brief B187 */
      INT32_C(28),   /** @brief B188 */
      INT32_C(29),   /** @brief B189 */
      INT32_C(30),   /** @brief B190 */
      INT32_C(31),   /** @brief B191 */
    };

    static const int32_t CRYP_CSGCMXR_B16X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief B161 */
      INT32_C(2),    /** @brief B162 */
      INT32_C(3),    /** @brief B163 */
      INT32_C(4),    /** @brief B164 */
      INT32_C(5),    /** @brief B165 */
      INT32_C(6),    /** @brief B166 */
      INT32_C(7),    /** @brief B167 */
      INT32_C(8),    /** @brief B168 */
      INT32_C(9),    /** @brief B169 */
    };

    static const int32_t CRYP_CSGCMXR_B12X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief B129 */
    };

    static const int32_t CRYP_CSGCMXR_B10X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(5),    /** @brief B101 */
      INT32_C(6),    /** @brief B102 */
      INT32_C(7),    /** @brief B103 */
      INT32_C(8),    /** @brief B104 */
      INT32_C(9),    /** @brief B105 */
      INT32_C(10),   /** @brief B106 */
      INT32_C(11),   /** @brief B107 */
      INT32_C(12),   /** @brief B108 */
      INT32_C(13),   /** @brief B109 */
    };

    static const int32_t CRYP_CSGCMXR_BX_POS[96] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief B64 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief B70 */
      INT32_C(7),    /** @brief B71 */
      INT32_C(8),    /** @brief B72 */
      INT32_C(9),    /** @brief B73 */
      INT32_C(10),   /** @brief B74 */
      INT32_C(11),   /** @brief B75 */
      INT32_C(12),   /** @brief B76 */
      INT32_C(13),   /** @brief B77 */
      INT32_C(14),   /** @brief B78 */
      INT32_C(15),   /** @brief B79 */
      INT32_C(16),   /** @brief B80 */
      INT32_C(17),   /** @brief B81 */
      INT32_C(18),   /** @brief B82 */
      INT32_C(19),   /** @brief B83 */
      INT32_C(20),   /** @brief B84 */
      INT32_C(21),   /** @brief B85 */
      INT32_C(22),   /** @brief B86 */
      INT32_C(23),   /** @brief B87 */
      INT32_C(24),   /** @brief B88 */
      INT32_C(25),   /** @brief B89 */
      INT32_C(26),   /** @brief B90 */
      INT32_C(27),   /** @brief B91 */
      INT32_C(28),   /** @brief B92 */
      INT32_C(29),   /** @brief B93 */
      INT32_C(30),   /** @brief B94 */
      INT32_C(31),   /** @brief B95 */
    };

    static const int32_t CRYP_CSGCMXR_B6X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief B65 */
      INT32_C(2),    /** @brief B66 */
      INT32_C(3),    /** @brief B67 */
      INT32_C(4),    /** @brief B68 */
      INT32_C(5),    /** @brief B69 */
    };

    static const int32_t CRYP_CSGCMXR_B3X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief B33 */
      INT32_C(2),    /** @brief B34 */
      INT32_C(3),    /** @brief B35 */
      INT32_C(4),    /** @brief B36 */
      INT32_C(5),    /** @brief B37 */
      INT32_C(6),    /** @brief B38 */
      INT32_C(7),    /** @brief B39 */
    };

    static const int32_t CRYP_CSGCMXR_IVX_POS[32] = {
      INT32_C(31),   /** @brief IV0 */
      INT32_C(30),   /** @brief IV1 */
      INT32_C(29),   /** @brief IV2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(27),   /** @brief IV4 */
      INT32_C(26),   /** @brief IV5 */
      INT32_C(25),   /** @brief IV6 */
      INT32_C(24),   /** @brief IV7 */
      INT32_C(23),   /** @brief IV8 */
      INT32_C(22),   /** @brief IV9 */
      INT32_C(21),   /** @brief IV10 */
      INT32_C(20),   /** @brief IV11 */
      INT32_C(19),   /** @brief IV12 */
      INT32_C(18),   /** @brief IV13 */
      INT32_C(17),   /** @brief IV14 */
      INT32_C(16),   /** @brief IV15 */
      INT32_C(15),   /** @brief IV16 */
      INT32_C(14),   /** @brief IV17 */
      INT32_C(13),   /** @brief IV18 */
      INT32_C(12),   /** @brief IV19 */
      INT32_C(11),   /** @brief IV20 */
      INT32_C(10),   /** @brief IV21 */
      INT32_C(9),    /** @brief IV22 */
      INT32_C(8),    /** @brief IV23 */
      INT32_C(7),    /** @brief IV24 */
      INT32_C(6),    /** @brief IV25 */
      INT32_C(5),    /** @brief IV26 */
      INT32_C(4),    /** @brief IV27 */
      INT32_C(3),    /** @brief IV28 */
      INT32_C(2),    /** @brief IV29 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief IV31 */
    };

    static const int32_t CRYP_CSGCMXR_IV3X_POS[2] = {
      INT32_C(1),    /** @brief IV30 */
      INT32_C(-1),   /** @brief Invalid index. */
    };

    static const int32_t CRYP_CSGCMXR_IV6X_POS[4] = {
      INT32_C(3),    /** @brief IV60 */
      INT32_C(2),    /** @brief IV61 */
      INT32_C(1),    /** @brief IV62 */
      INT32_C(-1),   /** @brief Invalid index. */
    };

    static const int32_t CRYP_CSGCMXR_IV9X_POS[6] = {
      INT32_C(5),    /** @brief IV90 */
      INT32_C(4),    /** @brief IV91 */
      INT32_C(3),    /** @brief IV92 */
      INT32_C(2),    /** @brief IV93 */
      INT32_C(1),    /** @brief IV94 */
      INT32_C(-1),   /** @brief Invalid index. */
    };

    static const int32_t CRYP_CSGCMXR_IV12X_POS[8] = {
      INT32_C(7),    /** @brief IV120 */
      INT32_C(6),    /** @brief IV121 */
      INT32_C(5),    /** @brief IV122 */
      INT32_C(4),    /** @brief IV123 */
      INT32_C(3),    /** @brief IV124 */
      INT32_C(2),    /** @brief IV125 */
      INT32_C(1),    /** @brief IV126 */
      INT32_C(-1),   /** @brief Invalid index. */
    };

    /** @subsection CRYP field position definitions */

    static const int32_t CRYP_CSGCMXR_ALGODIR_POS = INT32_C(2);      /** @brief Algorithm direction */
    static const int32_t CRYP_CSGCMXR_ALGOMODE0_POS = INT32_C(3);    /** @brief Algorithm mode */
    static const int32_t CRYP_CSGCMXR_DATATYPE_POS = INT32_C(6);     /** @brief Data type selection */
    static const int32_t CRYP_CSGCMXR_KEYSIZE_POS = INT32_C(8);      /** @brief Key size selection (AES mode only) */
    static const int32_t CRYP_CSGCMXR_FFLUSH_POS = INT32_C(14);      /** @brief FIFO flush */
    static const int32_t CRYP_CSGCMXR_CRYPEN_POS = INT32_C(15);      /** @brief Cryptographic processor enable */
    static const int32_t CRYP_CSGCMXR_GCM_CCMPH_POS = INT32_C(16);   /** @brief GCM_CCMPH */
    static const int32_t CRYP_CSGCMXR_ALGOMODE3_POS = INT32_C(19);   /** @brief ALGOMODE */
    static const int32_t CRYP_CSGCMXR_BUSY_POS = INT32_C(4);         /** @brief Busy bit */
    static const int32_t CRYP_CSGCMXR_OFFU_POS = INT32_C(3);         /** @brief Output FIFO full */
    static const int32_t CRYP_CSGCMXR_OFNE_POS = INT32_C(2);         /** @brief Output FIFO not empty */
    static const int32_t CRYP_CSGCMXR_IFNF_POS = INT32_C(1);         /** @brief Input FIFO not full */
    static const int32_t CRYP_CSGCMXR_IFEM_POS = INT32_C(0);         /** @brief Input FIFO empty */
    static const int32_t CRYP_CSGCMXR_DOEN_POS = INT32_C(1);         /** @brief DMA output enable */
    static const int32_t CRYP_CSGCMXR_DIEN_POS = INT32_C(0);         /** @brief DMA input enable */
    static const int32_t CRYP_CSGCMXR_OUTIM_POS = INT32_C(1);        /** @brief Output FIFO service interrupt mask */
    static const int32_t CRYP_CSGCMXR_INIM_POS = INT32_C(0);         /** @brief Input FIFO service interrupt mask */
    static const int32_t CRYP_CSGCMXR_OUTRIS_POS = INT32_C(1);       /** @brief Output FIFO service raw interrupt status */
    static const int32_t CRYP_CSGCMXR_INRIS_POS = INT32_C(0);        /** @brief Input FIFO service raw interrupt status */
    static const int32_t CRYP_CSGCMXR_OUTMIS_POS = INT32_C(1);       /** @brief Output FIFO service masked interrupt status */
    static const int32_t CRYP_CSGCMXR_INMIS_POS = INT32_C(0);        /** @brief Input FIFO service masked interrupt status */
    static const int32_t CRYP_CSGCMXR_B192_POS = INT32_C(0);         /** @brief B192 */
    static const int32_t CRYP_CSGCMXR_B193_POS = INT32_C(1);         /** @brief B193 */
    static const int32_t CRYP_CSGCMXR_B194_POS = INT32_C(2);         /** @brief B194 */
    static const int32_t CRYP_CSGCMXR_B195_POS = INT32_C(3);         /** @brief B195 */
    static const int32_t CRYP_CSGCMXR_B196_POS = INT32_C(4);         /** @brief B196 */
    static const int32_t CRYP_CSGCMXR_B197_POS = INT32_C(5);         /** @brief B197 */
    static const int32_t CRYP_CSGCMXR_B198_POS = INT32_C(6);         /** @brief B198 */
    static const int32_t CRYP_CSGCMXR_B199_POS = INT32_C(7);         /** @brief B199 */
    static const int32_t CRYP_CSGCMXR_B96_POS = INT32_C(0);          /** @brief B96 */
    static const int32_t CRYP_CSGCMXR_B97_POS = INT32_C(1);          /** @brief B97 */
    static const int32_t CRYP_CSGCMXR_B98_POS = INT32_C(2);          /** @brief B98 */
    static const int32_t CRYP_CSGCMXR_B99_POS = INT32_C(3);          /** @brief B99 */
    static const int32_t CRYP_CSGCMXR_IV3_POS = INT32_C(28);         /** @brief IV3 */
    static const int32_t CRYP_CSGCMXR_IV127_POS = INT32_C(0);        /** @brief IV127 */
    static const int32_t CRYP_CSGCMXR_IV119_POS = INT32_C(8);        /** @brief IV119 */
    static const int32_t CRYP_CSGCMXR_IV118_POS = INT32_C(9);        /** @brief IV118 */
    static const int32_t CRYP_CSGCMXR_IV117_POS = INT32_C(10);       /** @brief IV117 */
    static const int32_t CRYP_CSGCMXR_IV116_POS = INT32_C(11);       /** @brief IV116 */
    static const int32_t CRYP_CSGCMXR_IV115_POS = INT32_C(12);       /** @brief IV115 */
    static const int32_t CRYP_CSGCMXR_IV114_POS = INT32_C(13);       /** @brief IV114 */
    static const int32_t CRYP_CSGCMXR_IV113_POS = INT32_C(14);       /** @brief IV113 */
    static const int32_t CRYP_CSGCMXR_IV112_POS = INT32_C(15);       /** @brief IV112 */
    static const int32_t CRYP_CSGCMXR_IV111_POS = INT32_C(16);       /** @brief IV111 */
    static const int32_t CRYP_CSGCMXR_IV110_POS = INT32_C(17);       /** @brief IV110 */
    static const int32_t CRYP_CSGCMXR_IV109_POS = INT32_C(18);       /** @brief IV109 */
    static const int32_t CRYP_CSGCMXR_IV108_POS = INT32_C(19);       /** @brief IV108 */
    static const int32_t CRYP_CSGCMXR_IV107_POS = INT32_C(20);       /** @brief IV107 */
    static const int32_t CRYP_CSGCMXR_IV106_POS = INT32_C(21);       /** @brief IV106 */
    static const int32_t CRYP_CSGCMXR_IV105_POS = INT32_C(22);       /** @brief IV105 */
    static const int32_t CRYP_CSGCMXR_IV104_POS = INT32_C(23);       /** @brief IV104 */
    static const int32_t CRYP_CSGCMXR_IV103_POS = INT32_C(24);       /** @brief IV103 */
    static const int32_t CRYP_CSGCMXR_IV102_POS = INT32_C(25);       /** @brief IV102 */
    static const int32_t CRYP_CSGCMXR_IV101_POS = INT32_C(26);       /** @brief IV101 */
    static const int32_t CRYP_CSGCMXR_IV100_POS = INT32_C(27);       /** @brief IV100 */

    /**********************************************************************************************
     * @section DCMI Definitions
     **********************************************************************************************/

    /** @subsection DCMI IRQ interrupt definitions */

    static const int32_t DCMI_IRQ = INT32_C(78);   /** @brief DCMI global interrupt */

    /** @subsection DCMI register definitions */

    static _RW uint32_t* const DCMI_CR_REG = (_RW uint32_t* const)UINT32_C(0x48020000);       /** @brief Control register 1 */
    static _RO uint32_t* const DCMI_SR_REG = (_RO uint32_t* const)UINT32_C(0x48020004);       /** @brief Status register */
    static _RO uint32_t* const DCMI_RIS_REG = (_RO uint32_t* const)UINT32_C(0x48020008);      /** @brief Raw interrupt status register */
    static _RW uint32_t* const DCMI_IER_REG = (_RW uint32_t* const)UINT32_C(0x4802000C);      /** @brief Interrupt enable register */
    static _RO uint32_t* const DCMI_MIS_REG = (_RO uint32_t* const)UINT32_C(0x48020010);      /** @brief Masked interrupt status register */
    static _RW uint32_t* const DCMI_ICR_REG = (_RW uint32_t* const)UINT32_C(0x48020014);      /** @brief Interrupt clear register */
    static _RW uint32_t* const DCMI_ESCR_REG = (_RW uint32_t* const)UINT32_C(0x48020018);     /** @brief Embedded synchronization code register */
    static _RW uint32_t* const DCMI_ESUR_REG = (_RW uint32_t* const)UINT32_C(0x4802001C);     /** @brief Embedded synchronization unmask register */
    static _RW uint32_t* const DCMI_CWSTRT_REG = (_RW uint32_t* const)UINT32_C(0x48020020);   /** @brief Crop window start */
    static _RW uint32_t* const DCMI_CWSIZE_REG = (_RW uint32_t* const)UINT32_C(0x48020024);   /** @brief Crop window size */
    static _RO uint32_t* const DCMI_DR_REG = (_RO uint32_t* const)UINT32_C(0x48020028);       /** @brief Data register */

    /** @subsection DCMI field mask array definitions */

    static const uint32_t DCMI_DR_BYTEX_MASK[4] = {
      UINT32_C(0x000000FF),   /** @brief Data byte 0 */
      UINT32_C(0x0000FF00),   /** @brief Data byte 1 */
      UINT32_C(0x00FF0000),   /** @brief Data byte 2 */
      UINT32_C(0xFF000000),   /** @brief Data byte 3 */
    };

    /** @subsection DCMI field mask definitions */

    static const uint32_t DCMI_CR_OELS_MASK = UINT32_C(0x00100000);          /** @brief Odd/Even line select (line select start) */
    static const uint32_t DCMI_CR_LSM_MASK = UINT32_C(0x00080000);           /** @brief Line select mode */
    static const uint32_t DCMI_CR_OEBS_MASK = UINT32_C(0x00040000);          /** @brief Odd/Even byte select (byte select start) */
    static const uint32_t DCMI_CR_BSM_MASK = UINT32_C(0x00030000);           /** @brief Byte select mode */
    static const uint32_t DCMI_CR_ENABLE_MASK = UINT32_C(0x00004000);        /** @brief DCMI enable */
    static const uint32_t DCMI_CR_EDM_MASK = UINT32_C(0x00000C00);           /** @brief Extended data mode */
    static const uint32_t DCMI_CR_FCRC_MASK = UINT32_C(0x00000300);          /** @brief Frame capture rate control */
    static const uint32_t DCMI_CR_VSPOL_MASK = UINT32_C(0x00000080);         /** @brief Vertical synchronization polarity */
    static const uint32_t DCMI_CR_HSPOL_MASK = UINT32_C(0x00000040);         /** @brief Horizontal synchronization polarity */
    static const uint32_t DCMI_CR_PCKPOL_MASK = UINT32_C(0x00000020);        /** @brief Pixel clock polarity */
    static const uint32_t DCMI_CR_ESS_MASK = UINT32_C(0x00000010);           /** @brief Embedded synchronization select */
    static const uint32_t DCMI_CR_JPEG_MASK = UINT32_C(0x00000008);          /** @brief JPEG format */
    static const uint32_t DCMI_CR_CROP_MASK = UINT32_C(0x00000004);          /** @brief Crop feature */
    static const uint32_t DCMI_CR_CM_MASK = UINT32_C(0x00000002);            /** @brief Capture mode */
    static const uint32_t DCMI_CR_CAPTURE_MASK = UINT32_C(0x00000001);       /** @brief Capture enable */
    static const uint32_t DCMI_SR_FNE_MASK = UINT32_C(0x00000004);           /** @brief FIFO not empty */
    static const uint32_t DCMI_SR_VSYNC_MASK = UINT32_C(0x00000002);         /** @brief VSYNC */
    static const uint32_t DCMI_SR_HSYNC_MASK = UINT32_C(0x00000001);         /** @brief HSYNC */
    static const uint32_t DCMI_RIS_LINE_RIS_MASK = UINT32_C(0x00000010);     /** @brief Line raw interrupt status */
    static const uint32_t DCMI_RIS_VSYNC_RIS_MASK = UINT32_C(0x00000008);    /** @brief VSYNC raw interrupt status */
    static const uint32_t DCMI_RIS_ERR_RIS_MASK = UINT32_C(0x00000004);      /** @brief Synchronization error raw interrupt status */
    static const uint32_t DCMI_RIS_OVR_RIS_MASK = UINT32_C(0x00000002);      /** @brief Overrun raw interrupt status */
    static const uint32_t DCMI_RIS_FRAME_RIS_MASK = UINT32_C(0x00000001);    /** @brief Capture complete raw interrupt status */
    static const uint32_t DCMI_IER_LINE_IE_MASK = UINT32_C(0x00000010);      /** @brief Line interrupt enable */
    static const uint32_t DCMI_IER_VSYNC_IE_MASK = UINT32_C(0x00000008);     /** @brief VSYNC interrupt enable */
    static const uint32_t DCMI_IER_ERR_IE_MASK = UINT32_C(0x00000004);       /** @brief Synchronization error interrupt enable */
    static const uint32_t DCMI_IER_OVR_IE_MASK = UINT32_C(0x00000002);       /** @brief Overrun interrupt enable */
    static const uint32_t DCMI_IER_FRAME_IE_MASK = UINT32_C(0x00000001);     /** @brief Capture complete interrupt enable */
    static const uint32_t DCMI_MIS_LINE_MIS_MASK = UINT32_C(0x00000010);     /** @brief Line masked interrupt status */
    static const uint32_t DCMI_MIS_VSYNC_MIS_MASK = UINT32_C(0x00000008);    /** @brief VSYNC masked interrupt status */
    static const uint32_t DCMI_MIS_ERR_MIS_MASK = UINT32_C(0x00000004);      /** @brief Synchronization error masked interrupt status */
    static const uint32_t DCMI_MIS_OVR_MIS_MASK = UINT32_C(0x00000002);      /** @brief Overrun masked interrupt status */
    static const uint32_t DCMI_MIS_FRAME_MIS_MASK = UINT32_C(0x00000001);    /** @brief Capture complete masked interrupt status */
    static const uint32_t DCMI_ICR_LINE_ISC_MASK = UINT32_C(0x00000010);     /** @brief Line interrupt status clear */
    static const uint32_t DCMI_ICR_VSYNC_ISC_MASK = UINT32_C(0x00000008);    /** @brief Vertical synch interrupt status clear */
    static const uint32_t DCMI_ICR_ERR_ISC_MASK = UINT32_C(0x00000004);      /** @brief Synchronization error interrupt status clear */
    static const uint32_t DCMI_ICR_OVR_ISC_MASK = UINT32_C(0x00000002);      /** @brief Overrun interrupt status clear */
    static const uint32_t DCMI_ICR_FRAME_ISC_MASK = UINT32_C(0x00000001);    /** @brief Capture complete interrupt status clear */
    static const uint32_t DCMI_ESCR_FEC_MASK = UINT32_C(0xFF000000);         /** @brief Frame end delimiter code */
    static const uint32_t DCMI_ESCR_LEC_MASK = UINT32_C(0x00FF0000);         /** @brief Line end delimiter code */
    static const uint32_t DCMI_ESCR_LSC_MASK = UINT32_C(0x0000FF00);         /** @brief Line start delimiter code */
    static const uint32_t DCMI_ESCR_FSC_MASK = UINT32_C(0x000000FF);         /** @brief Frame start delimiter code */
    static const uint32_t DCMI_ESUR_FEU_MASK = UINT32_C(0xFF000000);         /** @brief Frame end delimiter unmask */
    static const uint32_t DCMI_ESUR_LEU_MASK = UINT32_C(0x00FF0000);         /** @brief Line end delimiter unmask */
    static const uint32_t DCMI_ESUR_LSU_MASK = UINT32_C(0x0000FF00);         /** @brief Line start delimiter unmask */
    static const uint32_t DCMI_ESUR_FSU_MASK = UINT32_C(0x000000FF);         /** @brief Frame start delimiter unmask */
    static const uint32_t DCMI_CWSTRT_VST_MASK = UINT32_C(0x1FFF0000);       /** @brief Vertical start line count */
    static const uint32_t DCMI_CWSTRT_HOFFCNT_MASK = UINT32_C(0x00003FFF);   /** @brief Horizontal offset count */
    static const uint32_t DCMI_CWSIZE_VLINE_MASK = UINT32_C(0x3FFF0000);     /** @brief Vertical line count */
    static const uint32_t DCMI_CWSIZE_CAPCNT_MASK = UINT32_C(0x00003FFF);    /** @brief Capture count */

    /** @subsection DCMI field position array definitions */

    static const int32_t DCMI_DR_BYTEX_POS[4] = {
      INT32_C(0),    /** @brief Data byte 0 */
      INT32_C(8),    /** @brief Data byte 1 */
      INT32_C(16),   /** @brief Data byte 2 */
      INT32_C(24),   /** @brief Data byte 3 */
    };

    /** @subsection DCMI field position definitions */

    static const int32_t DCMI_DR_OELS_POS = INT32_C(20);        /** @brief Odd/Even line select (line select start) */
    static const int32_t DCMI_DR_LSM_POS = INT32_C(19);         /** @brief Line select mode */
    static const int32_t DCMI_DR_OEBS_POS = INT32_C(18);        /** @brief Odd/Even byte select (byte select start) */
    static const int32_t DCMI_DR_BSM_POS = INT32_C(16);         /** @brief Byte select mode */
    static const int32_t DCMI_DR_ENABLE_POS = INT32_C(14);      /** @brief DCMI enable */
    static const int32_t DCMI_DR_EDM_POS = INT32_C(10);         /** @brief Extended data mode */
    static const int32_t DCMI_DR_FCRC_POS = INT32_C(8);         /** @brief Frame capture rate control */
    static const int32_t DCMI_DR_VSPOL_POS = INT32_C(7);        /** @brief Vertical synchronization polarity */
    static const int32_t DCMI_DR_HSPOL_POS = INT32_C(6);        /** @brief Horizontal synchronization polarity */
    static const int32_t DCMI_DR_PCKPOL_POS = INT32_C(5);       /** @brief Pixel clock polarity */
    static const int32_t DCMI_DR_ESS_POS = INT32_C(4);          /** @brief Embedded synchronization select */
    static const int32_t DCMI_DR_JPEG_POS = INT32_C(3);         /** @brief JPEG format */
    static const int32_t DCMI_DR_CROP_POS = INT32_C(2);         /** @brief Crop feature */
    static const int32_t DCMI_DR_CM_POS = INT32_C(1);           /** @brief Capture mode */
    static const int32_t DCMI_DR_CAPTURE_POS = INT32_C(0);      /** @brief Capture enable */
    static const int32_t DCMI_DR_FNE_POS = INT32_C(2);          /** @brief FIFO not empty */
    static const int32_t DCMI_DR_VSYNC_POS = INT32_C(1);        /** @brief VSYNC */
    static const int32_t DCMI_DR_HSYNC_POS = INT32_C(0);        /** @brief HSYNC */
    static const int32_t DCMI_DR_LINE_RIS_POS = INT32_C(4);     /** @brief Line raw interrupt status */
    static const int32_t DCMI_DR_VSYNC_RIS_POS = INT32_C(3);    /** @brief VSYNC raw interrupt status */
    static const int32_t DCMI_DR_ERR_RIS_POS = INT32_C(2);      /** @brief Synchronization error raw interrupt status */
    static const int32_t DCMI_DR_OVR_RIS_POS = INT32_C(1);      /** @brief Overrun raw interrupt status */
    static const int32_t DCMI_DR_FRAME_RIS_POS = INT32_C(0);    /** @brief Capture complete raw interrupt status */
    static const int32_t DCMI_DR_LINE_IE_POS = INT32_C(4);      /** @brief Line interrupt enable */
    static const int32_t DCMI_DR_VSYNC_IE_POS = INT32_C(3);     /** @brief VSYNC interrupt enable */
    static const int32_t DCMI_DR_ERR_IE_POS = INT32_C(2);       /** @brief Synchronization error interrupt enable */
    static const int32_t DCMI_DR_OVR_IE_POS = INT32_C(1);       /** @brief Overrun interrupt enable */
    static const int32_t DCMI_DR_FRAME_IE_POS = INT32_C(0);     /** @brief Capture complete interrupt enable */
    static const int32_t DCMI_DR_LINE_MIS_POS = INT32_C(4);     /** @brief Line masked interrupt status */
    static const int32_t DCMI_DR_VSYNC_MIS_POS = INT32_C(3);    /** @brief VSYNC masked interrupt status */
    static const int32_t DCMI_DR_ERR_MIS_POS = INT32_C(2);      /** @brief Synchronization error masked interrupt status */
    static const int32_t DCMI_DR_OVR_MIS_POS = INT32_C(1);      /** @brief Overrun masked interrupt status */
    static const int32_t DCMI_DR_FRAME_MIS_POS = INT32_C(0);    /** @brief Capture complete masked interrupt status */
    static const int32_t DCMI_DR_LINE_ISC_POS = INT32_C(4);     /** @brief Line interrupt status clear */
    static const int32_t DCMI_DR_VSYNC_ISC_POS = INT32_C(3);    /** @brief Vertical synch interrupt status clear */
    static const int32_t DCMI_DR_ERR_ISC_POS = INT32_C(2);      /** @brief Synchronization error interrupt status clear */
    static const int32_t DCMI_DR_OVR_ISC_POS = INT32_C(1);      /** @brief Overrun interrupt status clear */
    static const int32_t DCMI_DR_FRAME_ISC_POS = INT32_C(0);    /** @brief Capture complete interrupt status clear */
    static const int32_t DCMI_DR_FEC_POS = INT32_C(24);         /** @brief Frame end delimiter code */
    static const int32_t DCMI_DR_LEC_POS = INT32_C(16);         /** @brief Line end delimiter code */
    static const int32_t DCMI_DR_LSC_POS = INT32_C(8);          /** @brief Line start delimiter code */
    static const int32_t DCMI_DR_FSC_POS = INT32_C(0);          /** @brief Frame start delimiter code */
    static const int32_t DCMI_DR_FEU_POS = INT32_C(24);         /** @brief Frame end delimiter unmask */
    static const int32_t DCMI_DR_LEU_POS = INT32_C(16);         /** @brief Line end delimiter unmask */
    static const int32_t DCMI_DR_LSU_POS = INT32_C(8);          /** @brief Line start delimiter unmask */
    static const int32_t DCMI_DR_FSU_POS = INT32_C(0);          /** @brief Frame start delimiter unmask */
    static const int32_t DCMI_DR_VST_POS = INT32_C(16);         /** @brief Vertical start line count */
    static const int32_t DCMI_DR_HOFFCNT_POS = INT32_C(0);      /** @brief Horizontal offset count */
    static const int32_t DCMI_DR_VLINE_POS = INT32_C(16);       /** @brief Vertical line count */
    static const int32_t DCMI_DR_CAPCNT_POS = INT32_C(0);       /** @brief Capture count */

    /**********************************************************************************************
     * @section OTGX_HS_GLOBAL Definitions
     **********************************************************************************************/

    /** @subsection OTGX_HS_GLOBAL IRQ interrupt definitions */

    static const int32_t OTG_FS_EP1_OUT_IRQ = INT32_C(98);    /** @brief OTG_FS out global interrupt */
    static const int32_t OTG_FS_EP1_IN_IRQ = INT32_C(99);     /** @brief OTG_FS in global interrupt */
    static const int32_t OTG_FS_WKUP_IRQ = INT32_C(100);      /** @brief OTG_FS wakeup */
    static const int32_t OTG_FS_IRQ = INT32_C(101);           /** @brief OTG_FS global interrupt */

    /** @subsection OTGX_HS_GLOBAL register array definitions */

    static _RW uint32_t* const OTGX_HS_GLOBAL_GOTGCTL_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040000),   /** @brief OTG_HS control and status register */
      (_RW uint32_t* const)UINT32_C(0x40080000),   /** @brief OTG_HS control and status register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GOTGINT_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040004),   /** @brief OTG_HS interrupt register */
      (_RW uint32_t* const)UINT32_C(0x40080004),   /** @brief OTG_HS interrupt register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GAHBCFG_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040008),   /** @brief OTG_HS AHB configuration register */
      (_RW uint32_t* const)UINT32_C(0x40080008),   /** @brief OTG_HS AHB configuration register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GUSBCFG_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4004000C),   /** @brief OTG_HS USB configuration register */
      (_RW uint32_t* const)UINT32_C(0x4008000C),   /** @brief OTG_HS USB configuration register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GRSTCTL_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040010),   /** @brief OTG_HS reset register */
      (_RW uint32_t* const)UINT32_C(0x40080010),   /** @brief OTG_HS reset register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GINTSTS_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040014),   /** @brief OTG_HS core interrupt register */
      (_RW uint32_t* const)UINT32_C(0x40080014),   /** @brief OTG_HS core interrupt register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GINTMSK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040018),   /** @brief OTG_HS interrupt mask register */
      (_RW uint32_t* const)UINT32_C(0x40080018),   /** @brief OTG_HS interrupt mask register */
    };

    static _RO uint32_t* const OTGX_HS_GLOBAL_GRXSTSR_HOST_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4004001C),   /** @brief OTG_HS receive status debug read register (host mode) */
      (_RO uint32_t* const)UINT32_C(0x4008001C),   /** @brief OTG_HS receive status debug read register (host mode) */
    };

    static _RO uint32_t* const OTGX_HS_GLOBAL_GRXSTSP_HOST_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40040020),   /** @brief OTG_HS status read and pop register (host mode) */
      (_RO uint32_t* const)UINT32_C(0x40080020),   /** @brief OTG_HS status read and pop register (host mode) */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GRXFSIZ_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040024),   /** @brief OTG_HS receive FIFO size register */
      (_RW uint32_t* const)UINT32_C(0x40080024),   /** @brief OTG_HS receive FIFO size register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_HNPTXFSIZ_HOST_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040028),   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
      (_RW uint32_t* const)UINT32_C(0x40080028),   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_DIEPTXF0_DEVICE_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040028),   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
      (_RW uint32_t* const)UINT32_C(0x40080028),   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    };

    static _RO uint32_t* const OTGX_HS_GLOBAL_GNPTXSTS_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4004002C),   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
      (_RO uint32_t* const)UINT32_C(0x4008002C),   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GCCFG_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040038),   /** @brief OTG_HS general core configuration register */
      (_RW uint32_t* const)UINT32_C(0x40080038),   /** @brief OTG_HS general core configuration register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_CID_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4004003C),   /** @brief OTG_HS core ID register */
      (_RW uint32_t* const)UINT32_C(0x4008003C),   /** @brief OTG_HS core ID register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_HPTXFSIZ_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040100),   /** @brief OTG_HS host periodic transmit FIFO size register */
      (_RW uint32_t* const)UINT32_C(0x40080100),   /** @brief OTG_HS host periodic transmit FIFO size register */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_DIEPTXFX_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40040104),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40040108),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x4004011C),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40040120),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40040124),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40040128),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x4004012C),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40080104),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40080108),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x4008011C),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40080120),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40080124),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x40080128),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
        (_RW uint32_t* const)UINT32_C(0x4008012C),   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      },
    };

    static _RO uint32_t* const OTGX_HS_GLOBAL_GRXSTSR_DEVICE_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4004001C),   /** @brief OTG_HS receive status debug read register (host mode) */
      (_RO uint32_t* const)UINT32_C(0x4008001C),   /** @brief OTG_HS receive status debug read register (host mode) */
    };

    static _RO uint32_t* const OTGX_HS_GLOBAL_GRXSTSP_DEVICE_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40040020),   /** @brief OTG_HS status read and pop register (host mode) */
      (_RO uint32_t* const)UINT32_C(0x40080020),   /** @brief OTG_HS status read and pop register (host mode) */
    };

    static _RW uint32_t* const OTGX_HS_GLOBAL_GLPMCFG_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040054),   /** @brief OTG core LPM configuration register */
      (_RW uint32_t* const)UINT32_C(0x40080054),   /** @brief OTG core LPM configuration register */
    };

    /** @subsection OTGX_HS_GLOBAL field mask definitions */

    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_SRQSCS_MASK = UINT32_C(0x00000001);              /** @brief Session request success */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_SRQ_MASK = UINT32_C(0x00000002);                 /** @brief Session request */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_HNGSCS_MASK = UINT32_C(0x00000100);              /** @brief Host negotiation success */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_HNPRQ_MASK = UINT32_C(0x00000200);               /** @brief HNP request */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_HSHNPEN_MASK = UINT32_C(0x00000400);             /** @brief Host set HNP enable */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_DHNPEN_MASK = UINT32_C(0x00000800);              /** @brief Device HNP enabled */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_CIDSTS_MASK = UINT32_C(0x00010000);              /** @brief Connector ID status */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_DBCT_MASK = UINT32_C(0x00020000);                /** @brief Long/short debounce time */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_ASVLD_MASK = UINT32_C(0x00040000);               /** @brief A-session valid */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_BSVLD_MASK = UINT32_C(0x00080000);               /** @brief B-session valid */
    static const uint32_t OTGX_HS_GLOBAL_GOTGCTL_EHEN_MASK = UINT32_C(0x00001000);                /** @brief Embedded host enable */
    static const uint32_t OTGX_HS_GLOBAL_GOTGINT_SEDET_MASK = UINT32_C(0x00000004);               /** @brief Session end detected */
    static const uint32_t OTGX_HS_GLOBAL_GOTGINT_SRSSCHG_MASK = UINT32_C(0x00000100);             /** @brief Session request success status change */
    static const uint32_t OTGX_HS_GLOBAL_GOTGINT_HNSSCHG_MASK = UINT32_C(0x00000200);             /** @brief Host negotiation success status change */
    static const uint32_t OTGX_HS_GLOBAL_GOTGINT_HNGDET_MASK = UINT32_C(0x00020000);              /** @brief Host negotiation detected */
    static const uint32_t OTGX_HS_GLOBAL_GOTGINT_ADTOCHG_MASK = UINT32_C(0x00040000);             /** @brief A-device timeout change */
    static const uint32_t OTGX_HS_GLOBAL_GOTGINT_DBCDNE_MASK = UINT32_C(0x00080000);              /** @brief Debounce done */
    static const uint32_t OTGX_HS_GLOBAL_GOTGINT_IDCHNG_MASK = UINT32_C(0x00100000);              /** @brief ID input pin changed */
    static const uint32_t OTGX_HS_GLOBAL_GAHBCFG_GINT_MASK = UINT32_C(0x00000001);                /** @brief Global interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GAHBCFG_HBSTLEN_MASK = UINT32_C(0x0000001E);             /** @brief Burst length/type */
    static const uint32_t OTGX_HS_GLOBAL_GAHBCFG_DMAEN_MASK = UINT32_C(0x00000020);               /** @brief DMA enable */
    static const uint32_t OTGX_HS_GLOBAL_GAHBCFG_TXFELVL_MASK = UINT32_C(0x00000080);             /** @brief TxFIFO empty level */
    static const uint32_t OTGX_HS_GLOBAL_GAHBCFG_PTXFELVL_MASK = UINT32_C(0x00000100);            /** @brief Periodic txfifo empty level */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_TOCAL_MASK = UINT32_C(0x00000007);               /** @brief FS timeout calibration */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_PHYSEL_MASK = UINT32_C(0x00000040);              /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_SRPCAP_MASK = UINT32_C(0x00000100);              /** @brief SRP-capable */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_HNPCAP_MASK = UINT32_C(0x00000200);              /** @brief HNP-capable */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_TRDT_MASK = UINT32_C(0x00003C00);                /** @brief USB turnaround time */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_PHYLPCS_MASK = UINT32_C(0x00008000);             /** @brief PHY low-power clock select */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_ULPIFSLS_MASK = UINT32_C(0x00020000);            /** @brief ULPI FS/LS select */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_ULPIAR_MASK = UINT32_C(0x00040000);              /** @brief ULPI auto-resume */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_ULPICSM_MASK = UINT32_C(0x00080000);             /** @brief ULPI clock suspendm */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_ULPIEVBUSD_MASK = UINT32_C(0x00100000);          /** @brief ULPI external VBUS drive */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_ULPIEVBUSI_MASK = UINT32_C(0x00200000);          /** @brief ULPI external VBUS indicator */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_TSDPS_MASK = UINT32_C(0x00400000);               /** @brief TermSel dline pulsing selection */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_PCCI_MASK = UINT32_C(0x00800000);                /** @brief Indicator complement */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_PTCI_MASK = UINT32_C(0x01000000);                /** @brief Indicator pass through */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_ULPIIPD_MASK = UINT32_C(0x02000000);             /** @brief ULPI interface protect disable */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_FHMOD_MASK = UINT32_C(0x20000000);               /** @brief Forced host mode */
    static const uint32_t OTGX_HS_GLOBAL_GUSBCFG_FDMOD_MASK = UINT32_C(0x40000000);               /** @brief Forced peripheral mode */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_CSRST_MASK = UINT32_C(0x00000001);               /** @brief Core soft reset */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_HSRST_MASK = UINT32_C(0x00000002);               /** @brief HCLK soft reset */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_FCRST_MASK = UINT32_C(0x00000004);               /** @brief Host frame counter reset */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_RXFFLSH_MASK = UINT32_C(0x00000010);             /** @brief RxFIFO flush */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_TXFFLSH_MASK = UINT32_C(0x00000020);             /** @brief TxFIFO flush */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_TXFNUM_MASK = UINT32_C(0x000007C0);              /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_AHBIDL_MASK = UINT32_C(0x80000000);              /** @brief AHB master idle */
    static const uint32_t OTGX_HS_GLOBAL_GRSTCTL_DMAREQ_MASK = UINT32_C(0x40000000);              /** @brief DMA request signal enabled for USB OTG HS */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_CMOD_MASK = UINT32_C(0x00000001);                /** @brief Current mode of operation */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_MMIS_MASK = UINT32_C(0x00000002);                /** @brief Mode mismatch interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_OTGINT_MASK = UINT32_C(0x00000004);              /** @brief OTG interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_SOF_MASK = UINT32_C(0x00000008);                 /** @brief Start of frame */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_RXFLVL_MASK = UINT32_C(0x00000010);              /** @brief RxFIFO nonempty */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_NPTXFE_MASK = UINT32_C(0x00000020);              /** @brief Nonperiodic txfifo empty */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_GINAKEFF_MASK = UINT32_C(0x00000040);            /** @brief Global IN nonperiodic NAK effective */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_BOUTNAKEFF_MASK = UINT32_C(0x00000080);          /** @brief Global OUT NAK effective */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_ESUSP_MASK = UINT32_C(0x00000400);               /** @brief Early suspend */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_USBSUSP_MASK = UINT32_C(0x00000800);             /** @brief USB suspend */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_USBRST_MASK = UINT32_C(0x00001000);              /** @brief USB reset */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_ENUMDNE_MASK = UINT32_C(0x00002000);             /** @brief Enumeration done */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_ISOODRP_MASK = UINT32_C(0x00004000);             /** @brief Isochronous OUT packet dropped interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_EOPF_MASK = UINT32_C(0x00008000);                /** @brief End of periodic frame interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_IEPINT_MASK = UINT32_C(0x00040000);              /** @brief IN endpoint interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_OEPINT_MASK = UINT32_C(0x00080000);              /** @brief OUT endpoint interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_IISOIXFR_MASK = UINT32_C(0x00100000);            /** @brief Incomplete isochronous IN transfer */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_PXFR_INCOMPISOOUT_MASK = UINT32_C(0x00200000);   /** @brief Incomplete periodic transfer */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_DATAFSUSP_MASK = UINT32_C(0x00400000);           /** @brief Data fetch suspended */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_HPRTINT_MASK = UINT32_C(0x01000000);             /** @brief Host port interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_HCINT_MASK = UINT32_C(0x02000000);               /** @brief Host channels interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_PTXFE_MASK = UINT32_C(0x04000000);               /** @brief Periodic txfifo empty */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_CIDSCHG_MASK = UINT32_C(0x10000000);             /** @brief Connector ID status change */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_DISCINT_MASK = UINT32_C(0x20000000);             /** @brief Disconnect detected interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_SRQINT_MASK = UINT32_C(0x40000000);              /** @brief Session request/new session detected interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTSTS_WKUINT_MASK = UINT32_C(0x80000000);              /** @brief Resume/remote wakeup detected interrupt */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_MMISM_MASK = UINT32_C(0x00000002);               /** @brief Mode mismatch interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_OTGINT_MASK = UINT32_C(0x00000004);              /** @brief OTG interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_SOFM_MASK = UINT32_C(0x00000008);                /** @brief Start of frame mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_RXFLVLM_MASK = UINT32_C(0x00000010);             /** @brief Receive FIFO nonempty mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_NPTXFEM_MASK = UINT32_C(0x00000020);             /** @brief Nonperiodic txfifo empty mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_GINAKEFFM_MASK = UINT32_C(0x00000040);           /** @brief Global nonperiodic IN NAK effective mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_GONAKEFFM_MASK = UINT32_C(0x00000080);           /** @brief Global OUT NAK effective mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_ESUSPM_MASK = UINT32_C(0x00000400);              /** @brief Early suspend mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_USBSUSPM_MASK = UINT32_C(0x00000800);            /** @brief USB suspend mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_USBRST_MASK = UINT32_C(0x00001000);              /** @brief USB reset mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_ENUMDNEM_MASK = UINT32_C(0x00002000);            /** @brief Enumeration done mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_ISOODRPM_MASK = UINT32_C(0x00004000);            /** @brief Isochronous OUT packet dropped interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_EOPFM_MASK = UINT32_C(0x00008000);               /** @brief End of periodic frame interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_IEPINT_MASK = UINT32_C(0x00040000);              /** @brief IN endpoints interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_OEPINT_MASK = UINT32_C(0x00080000);              /** @brief OUT endpoints interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_IISOIXFRM_MASK = UINT32_C(0x00100000);           /** @brief Incomplete isochronous IN transfer mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_PXFRM_IISOOXFRM_MASK = UINT32_C(0x00200000);     /** @brief Incomplete periodic transfer mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_FSUSPM_MASK = UINT32_C(0x00400000);              /** @brief Data fetch suspended mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_PRTIM_MASK = UINT32_C(0x01000000);               /** @brief Host port interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_HCIM_MASK = UINT32_C(0x02000000);                /** @brief Host channels interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_PTXFEM_MASK = UINT32_C(0x04000000);              /** @brief Periodic txfifo empty mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_CIDSCHGM_MASK = UINT32_C(0x10000000);            /** @brief Connector ID status change mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_DISCINT_MASK = UINT32_C(0x20000000);             /** @brief Disconnect detected interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_SRQIM_MASK = UINT32_C(0x40000000);               /** @brief Session request/new session detected interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_WUIM_MASK = UINT32_C(0x80000000);                /** @brief Resume/remote wakeup detected interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_RSTDE_MASK = UINT32_C(0x00800000);               /** @brief Reset detected interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GINTMSK_LPMINTM_MASK = UINT32_C(0x08000000);             /** @brief LPM interrupt mask */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_HOST_CHNUM_MASK = UINT32_C(0x0000000F);          /** @brief Channel number */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_HOST_BCNT_MASK = UINT32_C(0x00007FF0);           /** @brief Byte count */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_HOST_DPID_MASK = UINT32_C(0x00018000);           /** @brief Data PID */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_HOST_PKTSTS_MASK = UINT32_C(0x001E0000);         /** @brief Packet status */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_HOST_CHNUM_MASK = UINT32_C(0x0000000F);          /** @brief Channel number */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_HOST_BCNT_MASK = UINT32_C(0x00007FF0);           /** @brief Byte count */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_HOST_DPID_MASK = UINT32_C(0x00018000);           /** @brief Data PID */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_HOST_PKTSTS_MASK = UINT32_C(0x001E0000);         /** @brief Packet status */
    static const uint32_t OTGX_HS_GLOBAL_GRXFSIZ_RXFD_MASK = UINT32_C(0x0000FFFF);                /** @brief RxFIFO depth */
    static const uint32_t OTGX_HS_GLOBAL_HNPTXFSIZ_HOST_NPTXFSA_MASK = UINT32_C(0x0000FFFF);      /** @brief Nonperiodic transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_HNPTXFSIZ_HOST_NPTXFD_MASK = UINT32_C(0xFFFF0000);       /** @brief Nonperiodic txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXF0_DEVICE_TX0FSA_MASK = UINT32_C(0x0000FFFF);      /** @brief Endpoint 0 transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXF0_DEVICE_TX0FD_MASK = UINT32_C(0xFFFF0000);       /** @brief Endpoint 0 txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_GNPTXSTS_NPTXFSAV_MASK = UINT32_C(0x0000FFFF);           /** @brief Nonperiodic txfifo space available */
    static const uint32_t OTGX_HS_GLOBAL_GNPTXSTS_NPTQXSAV_MASK = UINT32_C(0x00FF0000);           /** @brief Nonperiodic transmit request queue space available */
    static const uint32_t OTGX_HS_GLOBAL_GNPTXSTS_NPTXQTOP_MASK = UINT32_C(0x7F000000);           /** @brief Top of the nonperiodic transmit request queue */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_PWRDWN_MASK = UINT32_C(0x00010000);                /** @brief Power down */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_BCDEN_MASK = UINT32_C(0x00020000);                 /** @brief Battery charging detector (BCD) enable */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_DCDEN_MASK = UINT32_C(0x00040000);                 /** @brief Data contact detection (DCD) mode enable */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_PDEN_MASK = UINT32_C(0x00080000);                  /** @brief Primary detection (PD) mode enable */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_SDEN_MASK = UINT32_C(0x00100000);                  /** @brief Secondary detection (SD) mode enable */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_VBDEN_MASK = UINT32_C(0x00200000);                 /** @brief USB VBUS detection enable */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_DCDET_MASK = UINT32_C(0x00000001);                 /** @brief Data contact detection (DCD) status */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_PDET_MASK = UINT32_C(0x00000002);                  /** @brief Primary detection (PD) status */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_SDET_MASK = UINT32_C(0x00000004);                  /** @brief Secondary detection (SD) status */
    static const uint32_t OTGX_HS_GLOBAL_GCCFG_PS2DET_MASK = UINT32_C(0x00000008);                /** @brief DM pull-up detection status */
    static const uint32_t OTGX_HS_GLOBAL_HPTXFSIZ_PTXSA_MASK = UINT32_C(0x0000FFFF);              /** @brief Host periodic txfifo start address */
    static const uint32_t OTGX_HS_GLOBAL_HPTXFSIZ_PTXFD_MASK = UINT32_C(0xFFFF0000);              /** @brief Host periodic txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXSA_MASK = UINT32_C(0x0000FFFF);           /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXFD_MASK = UINT32_C(0xFFFF0000);           /** @brief IN endpoint txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXSA_MASK = UINT32_C(0x0000FFFF);           /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXFD_MASK = UINT32_C(0xFFFF0000);           /** @brief IN endpoint txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXSA_MASK = UINT32_C(0x0000FFFF);           /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXFD_MASK = UINT32_C(0xFFFF0000);           /** @brief IN endpoint txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXSA_MASK = UINT32_C(0x0000FFFF);           /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXFD_MASK = UINT32_C(0xFFFF0000);           /** @brief IN endpoint txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXSA_MASK = UINT32_C(0x0000FFFF);           /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXFD_MASK = UINT32_C(0xFFFF0000);           /** @brief IN endpoint txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXSA_MASK = UINT32_C(0x0000FFFF);           /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXFD_MASK = UINT32_C(0xFFFF0000);           /** @brief IN endpoint txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXSA_MASK = UINT32_C(0x0000FFFF);           /** @brief IN endpoint fifox transmit RAM start address */
    static const uint32_t OTGX_HS_GLOBAL_DIEPTXFX_INEPTXFD_MASK = UINT32_C(0xFFFF0000);           /** @brief IN endpoint txfifo depth */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_DEVICE_EPNUM_MASK = UINT32_C(0x0000000F);        /** @brief Endpoint number */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_DEVICE_BCNT_MASK = UINT32_C(0x00007FF0);         /** @brief Byte count */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_DEVICE_DPID_MASK = UINT32_C(0x00018000);         /** @brief Data PID */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_DEVICE_PKTSTS_MASK = UINT32_C(0x001E0000);       /** @brief Packet status */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSR_DEVICE_FRMNUM_MASK = UINT32_C(0x01E00000);       /** @brief Frame number */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_DEVICE_EPNUM_MASK = UINT32_C(0x0000000F);        /** @brief Endpoint number */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_DEVICE_BCNT_MASK = UINT32_C(0x00007FF0);         /** @brief Byte count */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_DEVICE_DPID_MASK = UINT32_C(0x00018000);         /** @brief Data PID */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_DEVICE_PKTSTS_MASK = UINT32_C(0x001E0000);       /** @brief Packet status */
    static const uint32_t OTGX_HS_GLOBAL_GRXSTSP_DEVICE_FRMNUM_MASK = UINT32_C(0x01E00000);       /** @brief Frame number */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_LPMEN_MASK = UINT32_C(0x00000001);               /** @brief LPM support enable */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_LPMACK_MASK = UINT32_C(0x00000002);              /** @brief LPM token acknowledge enable */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_BESL_MASK = UINT32_C(0x0000003C);                /** @brief Best effort service latency */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_REMWAKE_MASK = UINT32_C(0x00000040);             /** @brief BRemoteWake value */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_L1SSEN_MASK = UINT32_C(0x00000080);              /** @brief L1 shallow sleep enable */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_BESLTHRS_MASK = UINT32_C(0x00000F00);            /** @brief BESL threshold */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_L1DSEN_MASK = UINT32_C(0x00001000);              /** @brief L1 deep sleep enable */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_LPMRST_MASK = UINT32_C(0x00006000);              /** @brief LPM response */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_SLPSTS_MASK = UINT32_C(0x00008000);              /** @brief Port sleep status */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_L1RSMOK_MASK = UINT32_C(0x00010000);             /** @brief Sleep state resume OK */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_LPMCHIDX_MASK = UINT32_C(0x001E0000);            /** @brief LPM channel index */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_LPMRCNT_MASK = UINT32_C(0x00E00000);             /** @brief LPM retry count */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_SNDLPM_MASK = UINT32_C(0x01000000);              /** @brief Send LPM transaction */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_LPMRCNTSTS_MASK = UINT32_C(0x0E000000);          /** @brief LPM retry count status */
    static const uint32_t OTGX_HS_GLOBAL_GLPMCFG_ENBESL_MASK = UINT32_C(0x10000000);              /** @brief Enable best effort service latency */

    /** @subsection OTGX_HS_GLOBAL field position definitions */

    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SRQSCS_POS = INT32_C(0);               /** @brief Session request success */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SRQ_POS = INT32_C(1);                  /** @brief Session request */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HNGSCS_POS = INT32_C(8);               /** @brief Host negotiation success */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HNPRQ_POS = INT32_C(9);                /** @brief HNP request */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HSHNPEN_POS = INT32_C(10);             /** @brief Host set HNP enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DHNPEN_POS = INT32_C(11);              /** @brief Device HNP enabled */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_CIDSTS_POS = INT32_C(16);              /** @brief Connector ID status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DBCT_POS = INT32_C(17);                /** @brief Long/short debounce time */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ASVLD_POS = INT32_C(18);               /** @brief A-session valid */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BSVLD_POS = INT32_C(19);               /** @brief B-session valid */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_EHEN_POS = INT32_C(12);                /** @brief Embedded host enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SEDET_POS = INT32_C(2);                /** @brief Session end detected */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SRSSCHG_POS = INT32_C(8);              /** @brief Session request success status change */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HNSSCHG_POS = INT32_C(9);              /** @brief Host negotiation success status change */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HNGDET_POS = INT32_C(17);              /** @brief Host negotiation detected */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ADTOCHG_POS = INT32_C(18);             /** @brief A-device timeout change */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DBCDNE_POS = INT32_C(19);              /** @brief Debounce done */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_IDCHNG_POS = INT32_C(20);              /** @brief ID input pin changed */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_GINT_POS = INT32_C(0);                 /** @brief Global interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HBSTLEN_POS = INT32_C(1);              /** @brief Burst length/type */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DMAEN_POS = INT32_C(5);                /** @brief DMA enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TXFELVL_POS = INT32_C(7);              /** @brief TxFIFO empty level */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PTXFELVL_POS = INT32_C(8);             /** @brief Periodic txfifo empty level */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TOCAL_POS = INT32_C(0);                /** @brief FS timeout calibration */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PHYSEL_POS = INT32_C(6);               /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SRPCAP_POS = INT32_C(8);               /** @brief SRP-capable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HNPCAP_POS = INT32_C(9);               /** @brief HNP-capable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TRDT_POS = INT32_C(10);                /** @brief USB turnaround time */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PHYLPCS_POS = INT32_C(15);             /** @brief PHY low-power clock select */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ULPIFSLS_POS = INT32_C(17);            /** @brief ULPI FS/LS select */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ULPIAR_POS = INT32_C(18);              /** @brief ULPI auto-resume */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ULPICSM_POS = INT32_C(19);             /** @brief ULPI clock suspendm */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ULPIEVBUSD_POS = INT32_C(20);          /** @brief ULPI external VBUS drive */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ULPIEVBUSI_POS = INT32_C(21);          /** @brief ULPI external VBUS indicator */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TSDPS_POS = INT32_C(22);               /** @brief TermSel dline pulsing selection */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PCCI_POS = INT32_C(23);                /** @brief Indicator complement */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PTCI_POS = INT32_C(24);                /** @brief Indicator pass through */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ULPIIPD_POS = INT32_C(25);             /** @brief ULPI interface protect disable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_FHMOD_POS = INT32_C(29);               /** @brief Forced host mode */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_FDMOD_POS = INT32_C(30);               /** @brief Forced peripheral mode */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_CSRST_POS = INT32_C(0);                /** @brief Core soft reset */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HSRST_POS = INT32_C(1);                /** @brief HCLK soft reset */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_FCRST_POS = INT32_C(2);                /** @brief Host frame counter reset */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_RXFFLSH_POS = INT32_C(4);              /** @brief RxFIFO flush */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TXFFLSH_POS = INT32_C(5);              /** @brief TxFIFO flush */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TXFNUM_POS = INT32_C(6);               /** @brief TxFIFO number */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_AHBIDL_POS = INT32_C(31);              /** @brief AHB master idle */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DMAREQ_POS = INT32_C(30);              /** @brief DMA request signal enabled for USB OTG HS */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_CMOD_POS = INT32_C(0);                 /** @brief Current mode of operation */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_MMIS_POS = INT32_C(1);                 /** @brief Mode mismatch interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_OTGINT_POS = INT32_C(2);               /** @brief OTG interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SOF_POS = INT32_C(3);                  /** @brief Start of frame */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_RXFLVL_POS = INT32_C(4);               /** @brief RxFIFO nonempty */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_NPTXFE_POS = INT32_C(5);               /** @brief Nonperiodic txfifo empty */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_GINAKEFF_POS = INT32_C(6);             /** @brief Global IN nonperiodic NAK effective */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BOUTNAKEFF_POS = INT32_C(7);           /** @brief Global OUT NAK effective */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ESUSP_POS = INT32_C(10);               /** @brief Early suspend */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_USBSUSP_POS = INT32_C(11);             /** @brief USB suspend */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_USBRST_POS = INT32_C(12);              /** @brief USB reset */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ENUMDNE_POS = INT32_C(13);             /** @brief Enumeration done */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ISOODRP_POS = INT32_C(14);             /** @brief Isochronous OUT packet dropped interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_EOPF_POS = INT32_C(15);                /** @brief End of periodic frame interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_IEPINT_POS = INT32_C(18);              /** @brief IN endpoint interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_OEPINT_POS = INT32_C(19);              /** @brief OUT endpoint interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_IISOIXFR_POS = INT32_C(20);            /** @brief Incomplete isochronous IN transfer */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PXFR_INCOMPISOOUT_POS = INT32_C(21);   /** @brief Incomplete periodic transfer */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DATAFSUSP_POS = INT32_C(22);           /** @brief Data fetch suspended */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HPRTINT_POS = INT32_C(24);             /** @brief Host port interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HCINT_POS = INT32_C(25);               /** @brief Host channels interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PTXFE_POS = INT32_C(26);               /** @brief Periodic txfifo empty */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_CIDSCHG_POS = INT32_C(28);             /** @brief Connector ID status change */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DISCINT_POS = INT32_C(29);             /** @brief Disconnect detected interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SRQINT_POS = INT32_C(30);              /** @brief Session request/new session detected interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_WKUINT_POS = INT32_C(31);              /** @brief Resume/remote wakeup detected interrupt */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_MMISM_POS = INT32_C(1);                /** @brief Mode mismatch interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_OTGINT_POS = INT32_C(2);               /** @brief OTG interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SOFM_POS = INT32_C(3);                 /** @brief Start of frame mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_RXFLVLM_POS = INT32_C(4);              /** @brief Receive FIFO nonempty mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_NPTXFEM_POS = INT32_C(5);              /** @brief Nonperiodic txfifo empty mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_GINAKEFFM_POS = INT32_C(6);            /** @brief Global nonperiodic IN NAK effective mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_GONAKEFFM_POS = INT32_C(7);            /** @brief Global OUT NAK effective mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ESUSPM_POS = INT32_C(10);              /** @brief Early suspend mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_USBSUSPM_POS = INT32_C(11);            /** @brief USB suspend mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_USBRST_POS = INT32_C(12);              /** @brief USB reset mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ENUMDNEM_POS = INT32_C(13);            /** @brief Enumeration done mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ISOODRPM_POS = INT32_C(14);            /** @brief Isochronous OUT packet dropped interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_EOPFM_POS = INT32_C(15);               /** @brief End of periodic frame interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_IEPINT_POS = INT32_C(18);              /** @brief IN endpoints interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_OEPINT_POS = INT32_C(19);              /** @brief OUT endpoints interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_IISOIXFRM_POS = INT32_C(20);           /** @brief Incomplete isochronous IN transfer mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PXFRM_IISOOXFRM_POS = INT32_C(21);     /** @brief Incomplete periodic transfer mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_FSUSPM_POS = INT32_C(22);              /** @brief Data fetch suspended mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PRTIM_POS = INT32_C(24);               /** @brief Host port interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_HCIM_POS = INT32_C(25);                /** @brief Host channels interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PTXFEM_POS = INT32_C(26);              /** @brief Periodic txfifo empty mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_CIDSCHGM_POS = INT32_C(28);            /** @brief Connector ID status change mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DISCINT_POS = INT32_C(29);             /** @brief Disconnect detected interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SRQIM_POS = INT32_C(30);               /** @brief Session request/new session detected interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_WUIM_POS = INT32_C(31);                /** @brief Resume/remote wakeup detected interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_RSTDE_POS = INT32_C(23);               /** @brief Reset detected interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_LPMINTM_POS = INT32_C(27);             /** @brief LPM interrupt mask */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_CHNUM_POS = INT32_C(0);                /** @brief Channel number */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BCNT_POS = INT32_C(4);                 /** @brief Byte count */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DPID_POS = INT32_C(15);                /** @brief Data PID */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PKTSTS_POS = INT32_C(17);              /** @brief Packet status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_CHNUM_POS = INT32_C(0);                /** @brief Channel number */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BCNT_POS = INT32_C(4);                 /** @brief Byte count */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DPID_POS = INT32_C(15);                /** @brief Data PID */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PKTSTS_POS = INT32_C(17);              /** @brief Packet status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_RXFD_POS = INT32_C(0);                 /** @brief RxFIFO depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_NPTXFSA_POS = INT32_C(0);              /** @brief Nonperiodic transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_NPTXFD_POS = INT32_C(16);              /** @brief Nonperiodic txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TX0FSA_POS = INT32_C(0);               /** @brief Endpoint 0 transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_TX0FD_POS = INT32_C(16);               /** @brief Endpoint 0 txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_NPTXFSAV_POS = INT32_C(0);             /** @brief Nonperiodic txfifo space available */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_NPTQXSAV_POS = INT32_C(16);            /** @brief Nonperiodic transmit request queue space available */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_NPTXQTOP_POS = INT32_C(24);            /** @brief Top of the nonperiodic transmit request queue */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PWRDWN_POS = INT32_C(16);              /** @brief Power down */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BCDEN_POS = INT32_C(17);               /** @brief Battery charging detector (BCD) enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DCDEN_POS = INT32_C(18);               /** @brief Data contact detection (DCD) mode enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PDEN_POS = INT32_C(19);                /** @brief Primary detection (PD) mode enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SDEN_POS = INT32_C(20);                /** @brief Secondary detection (SD) mode enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_VBDEN_POS = INT32_C(21);               /** @brief USB VBUS detection enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DCDET_POS = INT32_C(0);                /** @brief Data contact detection (DCD) status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PDET_POS = INT32_C(1);                 /** @brief Primary detection (PD) status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SDET_POS = INT32_C(2);                 /** @brief Secondary detection (SD) status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PS2DET_POS = INT32_C(3);               /** @brief DM pull-up detection status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PTXSA_POS = INT32_C(0);                /** @brief Host periodic txfifo start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PTXFD_POS = INT32_C(16);               /** @brief Host periodic txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXSA_POS = INT32_C(0);             /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXFD_POS = INT32_C(16);            /** @brief IN endpoint txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXSA_POS = INT32_C(0);             /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXFD_POS = INT32_C(16);            /** @brief IN endpoint txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXSA_POS = INT32_C(0);             /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXFD_POS = INT32_C(16);            /** @brief IN endpoint txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXSA_POS = INT32_C(0);             /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXFD_POS = INT32_C(16);            /** @brief IN endpoint txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXSA_POS = INT32_C(0);             /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXFD_POS = INT32_C(16);            /** @brief IN endpoint txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXSA_POS = INT32_C(0);             /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXFD_POS = INT32_C(16);            /** @brief IN endpoint txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXSA_POS = INT32_C(0);             /** @brief IN endpoint fifox transmit RAM start address */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_INEPTXFD_POS = INT32_C(16);            /** @brief IN endpoint txfifo depth */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_EPNUM_POS = INT32_C(0);                /** @brief Endpoint number */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BCNT_POS = INT32_C(4);                 /** @brief Byte count */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DPID_POS = INT32_C(15);                /** @brief Data PID */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PKTSTS_POS = INT32_C(17);              /** @brief Packet status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_FRMNUM_POS = INT32_C(21);              /** @brief Frame number */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_EPNUM_POS = INT32_C(0);                /** @brief Endpoint number */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BCNT_POS = INT32_C(4);                 /** @brief Byte count */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_DPID_POS = INT32_C(15);                /** @brief Data PID */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_PKTSTS_POS = INT32_C(17);              /** @brief Packet status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_FRMNUM_POS = INT32_C(21);              /** @brief Frame number */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_LPMEN_POS = INT32_C(0);                /** @brief LPM support enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_LPMACK_POS = INT32_C(1);               /** @brief LPM token acknowledge enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BESL_POS = INT32_C(2);                 /** @brief Best effort service latency */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_REMWAKE_POS = INT32_C(6);              /** @brief BRemoteWake value */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_L1SSEN_POS = INT32_C(7);               /** @brief L1 shallow sleep enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_BESLTHRS_POS = INT32_C(8);             /** @brief BESL threshold */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_L1DSEN_POS = INT32_C(12);              /** @brief L1 deep sleep enable */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_LPMRST_POS = INT32_C(13);              /** @brief LPM response */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SLPSTS_POS = INT32_C(15);              /** @brief Port sleep status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_L1RSMOK_POS = INT32_C(16);             /** @brief Sleep state resume OK */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_LPMCHIDX_POS = INT32_C(17);            /** @brief LPM channel index */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_LPMRCNT_POS = INT32_C(21);             /** @brief LPM retry count */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_SNDLPM_POS = INT32_C(24);              /** @brief Send LPM transaction */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_LPMRCNTSTS_POS = INT32_C(25);          /** @brief LPM retry count status */
    static const int32_t OTGX_HS_GLOBAL_GLPMCFG_ENBESL_POS = INT32_C(28);              /** @brief Enable best effort service latency */

    /**********************************************************************************************
     * @section OTGX_HS_HOST Definitions
     **********************************************************************************************/

    /** @subsection OTGX_HS_HOST register array definitions */

    static _RW uint32_t* const OTGX_HS_HOST_HCFG_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040400),   /** @brief OTG_HS host configuration register */
      (_RW uint32_t* const)UINT32_C(0x40080400),   /** @brief OTG_HS host configuration register */
    };

    static _RW uint32_t* const OTGX_HS_HOST_HFIR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040404),   /** @brief OTG_HS host frame interval register */
      (_RW uint32_t* const)UINT32_C(0x40080404),   /** @brief OTG_HS host frame interval register */
    };

    static _RO uint32_t* const OTGX_HS_HOST_HFNUM_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40040408),   /** @brief OTG_HS host frame number/frame time remaining register */
      (_RO uint32_t* const)UINT32_C(0x40080408),   /** @brief OTG_HS host frame number/frame time remaining register */
    };

    static _RW uint32_t* const OTGX_HS_HOST_HPTXSTS_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040410),   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
      (_RW uint32_t* const)UINT32_C(0x40080410),   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
    };

    static _RO uint32_t* const OTGX_HS_HOST_HAINT_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40040414),   /** @brief OTG_HS host all channels interrupt register */
      (_RO uint32_t* const)UINT32_C(0x40080414),   /** @brief OTG_HS host all channels interrupt register */
    };

    static _RW uint32_t* const OTGX_HS_HOST_HAINTMSK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040418),   /** @brief OTG_HS host all channels interrupt mask register */
      (_RW uint32_t* const)UINT32_C(0x40080418),   /** @brief OTG_HS host all channels interrupt mask register */
    };

    static _RW uint32_t* const OTGX_HS_HOST_HPRT_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040440),   /** @brief OTG_HS host port control and status register */
      (_RW uint32_t* const)UINT32_C(0x40080440),   /** @brief OTG_HS host port control and status register */
    };

    static _RW uint32_t* const OTGX_HS_HOST_HCCHARX_REG[3][16] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040500),   /** @brief OTG_HS host channel-0 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040520),   /** @brief OTG_HS host channel-1 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040540),   /** @brief OTG_HS host channel-2 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040560),   /** @brief OTG_HS host channel-3 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040580),   /** @brief OTG_HS host channel-4 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400405A0),   /** @brief OTG_HS host channel-5 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400405C0),   /** @brief OTG_HS host channel-6 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400405E0),   /** @brief OTG_HS host channel-7 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040600),   /** @brief OTG_HS host channel-8 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040620),   /** @brief OTG_HS host channel-9 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040640),   /** @brief OTG_HS host channel-10 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040660),   /** @brief OTG_HS host channel-11 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040678),   /** @brief OTG_HS host channel-12 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40040690),   /** @brief OTG_HS host channel-13 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400406A8),   /** @brief OTG_HS host channel-14 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400406C0),   /** @brief OTG_HS host channel-15 characteristics register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080500),   /** @brief OTG_HS host channel-0 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080520),   /** @brief OTG_HS host channel-1 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080540),   /** @brief OTG_HS host channel-2 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080560),   /** @brief OTG_HS host channel-3 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080580),   /** @brief OTG_HS host channel-4 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400805A0),   /** @brief OTG_HS host channel-5 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400805C0),   /** @brief OTG_HS host channel-6 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400805E0),   /** @brief OTG_HS host channel-7 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080600),   /** @brief OTG_HS host channel-8 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080620),   /** @brief OTG_HS host channel-9 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080640),   /** @brief OTG_HS host channel-10 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080660),   /** @brief OTG_HS host channel-11 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080678),   /** @brief OTG_HS host channel-12 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x40080690),   /** @brief OTG_HS host channel-13 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400806A8),   /** @brief OTG_HS host channel-14 characteristics register */
        (_RW uint32_t* const)UINT32_C(0x400806C0),   /** @brief OTG_HS host channel-15 characteristics register */
      },
    };

    static _RW uint32_t* const OTGX_HS_HOST_HCSPLTX_REG[3][16] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040504),   /** @brief OTG_HS host channel-0 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040524),   /** @brief OTG_HS host channel-1 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040544),   /** @brief OTG_HS host channel-2 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040564),   /** @brief OTG_HS host channel-3 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040584),   /** @brief OTG_HS host channel-4 split control register */
        (_RW uint32_t* const)UINT32_C(0x400405A4),   /** @brief OTG_HS host channel-5 split control register */
        (_RW uint32_t* const)UINT32_C(0x400405C4),   /** @brief OTG_HS host channel-6 split control register */
        (_RW uint32_t* const)UINT32_C(0x400405E4),   /** @brief OTG_HS host channel-7 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040604),   /** @brief OTG_HS host channel-8 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040624),   /** @brief OTG_HS host channel-9 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040644),   /** @brief OTG_HS host channel-10 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040664),   /** @brief OTG_HS host channel-11 split control register */
        (_RW uint32_t* const)UINT32_C(0x4004067C),   /** @brief OTG_HS host channel-12 split control register */
        (_RW uint32_t* const)UINT32_C(0x40040694),   /** @brief OTG_HS host channel-13 split control register */
        (_RW uint32_t* const)UINT32_C(0x400406AC),   /** @brief OTG_HS host channel-14 split control register */
        (_RW uint32_t* const)UINT32_C(0x400406C4),   /** @brief OTG_HS host channel-15 split control register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080504),   /** @brief OTG_HS host channel-0 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080524),   /** @brief OTG_HS host channel-1 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080544),   /** @brief OTG_HS host channel-2 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080564),   /** @brief OTG_HS host channel-3 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080584),   /** @brief OTG_HS host channel-4 split control register */
        (_RW uint32_t* const)UINT32_C(0x400805A4),   /** @brief OTG_HS host channel-5 split control register */
        (_RW uint32_t* const)UINT32_C(0x400805C4),   /** @brief OTG_HS host channel-6 split control register */
        (_RW uint32_t* const)UINT32_C(0x400805E4),   /** @brief OTG_HS host channel-7 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080604),   /** @brief OTG_HS host channel-8 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080624),   /** @brief OTG_HS host channel-9 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080644),   /** @brief OTG_HS host channel-10 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080664),   /** @brief OTG_HS host channel-11 split control register */
        (_RW uint32_t* const)UINT32_C(0x4008067C),   /** @brief OTG_HS host channel-12 split control register */
        (_RW uint32_t* const)UINT32_C(0x40080694),   /** @brief OTG_HS host channel-13 split control register */
        (_RW uint32_t* const)UINT32_C(0x400806AC),   /** @brief OTG_HS host channel-14 split control register */
        (_RW uint32_t* const)UINT32_C(0x400806C4),   /** @brief OTG_HS host channel-15 split control register */
      },
    };

    static _RW uint32_t* const OTGX_HS_HOST_HCINTX_REG[3][16] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040508),   /** @brief OTG_HS host channel-11 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040528),   /** @brief OTG_HS host channel-1 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040548),   /** @brief OTG_HS host channel-2 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040568),   /** @brief OTG_HS host channel-3 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040588),   /** @brief OTG_HS host channel-4 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400405A8),   /** @brief OTG_HS host channel-5 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400405C8),   /** @brief OTG_HS host channel-6 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400405E8),   /** @brief OTG_HS host channel-7 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040608),   /** @brief OTG_HS host channel-8 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040628),   /** @brief OTG_HS host channel-9 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040648),   /** @brief OTG_HS host channel-10 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040668),   /** @brief OTG_HS host channel-11 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040680),   /** @brief OTG_HS host channel-12 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040698),   /** @brief OTG_HS host channel-13 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400406B0),   /** @brief OTG_HS host channel-14 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400406C8),   /** @brief OTG_HS host channel-15 interrupt register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080508),   /** @brief OTG_HS host channel-11 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080528),   /** @brief OTG_HS host channel-1 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080548),   /** @brief OTG_HS host channel-2 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080568),   /** @brief OTG_HS host channel-3 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080588),   /** @brief OTG_HS host channel-4 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400805A8),   /** @brief OTG_HS host channel-5 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400805C8),   /** @brief OTG_HS host channel-6 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400805E8),   /** @brief OTG_HS host channel-7 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080608),   /** @brief OTG_HS host channel-8 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080628),   /** @brief OTG_HS host channel-9 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080648),   /** @brief OTG_HS host channel-10 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080668),   /** @brief OTG_HS host channel-11 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080680),   /** @brief OTG_HS host channel-12 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080698),   /** @brief OTG_HS host channel-13 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400806B0),   /** @brief OTG_HS host channel-14 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400806C8),   /** @brief OTG_HS host channel-15 interrupt register */
      },
    };

    static _RW uint32_t* const OTGX_HS_HOST_HCINTMSKX_REG[3][16] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x4004050C),   /** @brief OTG_HS host channel-11 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004052C),   /** @brief OTG_HS host channel-1 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004054C),   /** @brief OTG_HS host channel-2 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004056C),   /** @brief OTG_HS host channel-3 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004058C),   /** @brief OTG_HS host channel-4 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400405AC),   /** @brief OTG_HS host channel-5 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400405CC),   /** @brief OTG_HS host channel-6 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400405EC),   /** @brief OTG_HS host channel-7 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004060C),   /** @brief OTG_HS host channel-8 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004062C),   /** @brief OTG_HS host channel-9 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004064C),   /** @brief OTG_HS host channel-10 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004066C),   /** @brief OTG_HS host channel-11 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x40040684),   /** @brief OTG_HS host channel-12 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4004069C),   /** @brief OTG_HS host channel-13 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400406B4),   /** @brief OTG_HS host channel-14 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400406CC),   /** @brief OTG_HS host channel-15 interrupt mask register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x4008050C),   /** @brief OTG_HS host channel-11 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008052C),   /** @brief OTG_HS host channel-1 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008054C),   /** @brief OTG_HS host channel-2 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008056C),   /** @brief OTG_HS host channel-3 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008058C),   /** @brief OTG_HS host channel-4 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400805AC),   /** @brief OTG_HS host channel-5 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400805CC),   /** @brief OTG_HS host channel-6 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400805EC),   /** @brief OTG_HS host channel-7 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008060C),   /** @brief OTG_HS host channel-8 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008062C),   /** @brief OTG_HS host channel-9 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008064C),   /** @brief OTG_HS host channel-10 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008066C),   /** @brief OTG_HS host channel-11 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x40080684),   /** @brief OTG_HS host channel-12 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x4008069C),   /** @brief OTG_HS host channel-13 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400806B4),   /** @brief OTG_HS host channel-14 interrupt mask register */
        (_RW uint32_t* const)UINT32_C(0x400806CC),   /** @brief OTG_HS host channel-15 interrupt mask register */
      },
    };

    static _RW uint32_t* const OTGX_HS_HOST_HCTSIZX_REG[3][16] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040510),   /** @brief OTG_HS host channel-11 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040530),   /** @brief OTG_HS host channel-1 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040550),   /** @brief OTG_HS host channel-2 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040570),   /** @brief OTG_HS host channel-3 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040590),   /** @brief OTG_HS host channel-4 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400405B0),   /** @brief OTG_HS host channel-5 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400405D0),   /** @brief OTG_HS host channel-6 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400405F0),   /** @brief OTG_HS host channel-7 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040610),   /** @brief OTG_HS host channel-8 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040630),   /** @brief OTG_HS host channel-9 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040650),   /** @brief OTG_HS host channel-10 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040670),   /** @brief OTG_HS host channel-11 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040688),   /** @brief OTG_HS host channel-12 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400406A0),   /** @brief OTG_HS host channel-13 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400406B8),   /** @brief OTG_HS host channel-14 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400406D0),   /** @brief OTG_HS host channel-15 transfer size register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080510),   /** @brief OTG_HS host channel-11 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080530),   /** @brief OTG_HS host channel-1 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080550),   /** @brief OTG_HS host channel-2 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080570),   /** @brief OTG_HS host channel-3 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080590),   /** @brief OTG_HS host channel-4 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400805B0),   /** @brief OTG_HS host channel-5 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400805D0),   /** @brief OTG_HS host channel-6 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400805F0),   /** @brief OTG_HS host channel-7 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080610),   /** @brief OTG_HS host channel-8 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080630),   /** @brief OTG_HS host channel-9 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080650),   /** @brief OTG_HS host channel-10 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080670),   /** @brief OTG_HS host channel-11 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080688),   /** @brief OTG_HS host channel-12 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400806A0),   /** @brief OTG_HS host channel-13 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400806B8),   /** @brief OTG_HS host channel-14 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400806D0),   /** @brief OTG_HS host channel-15 transfer size register */
      },
    };

    static _RW uint32_t* const OTGX_HS_HOST_HCDMAX_REG[3][16] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040514),   /** @brief OTG_HS host channel-0 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040534),   /** @brief OTG_HS host channel-1 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040554),   /** @brief OTG_HS host channel-2 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040574),   /** @brief OTG_HS host channel-3 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040594),   /** @brief OTG_HS host channel-4 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400405B4),   /** @brief OTG_HS host channel-5 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400405D4),   /** @brief OTG_HS host channel-6 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400405F4),   /** @brief OTG_HS host channel-7 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040614),   /** @brief OTG_HS host channel-8 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040634),   /** @brief OTG_HS host channel-9 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040654),   /** @brief OTG_HS host channel-10 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040674),   /** @brief OTG_HS host channel-11 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x4004068C),   /** @brief OTG_HS host channel-12 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400406A4),   /** @brief OTG_HS host channel-13 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400406BC),   /** @brief OTG_HS host channel-14 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400406D4),   /** @brief OTG_HS host channel-15 DMA address register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080514),   /** @brief OTG_HS host channel-0 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080534),   /** @brief OTG_HS host channel-1 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080554),   /** @brief OTG_HS host channel-2 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080574),   /** @brief OTG_HS host channel-3 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080594),   /** @brief OTG_HS host channel-4 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400805B4),   /** @brief OTG_HS host channel-5 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400805D4),   /** @brief OTG_HS host channel-6 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400805F4),   /** @brief OTG_HS host channel-7 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080614),   /** @brief OTG_HS host channel-8 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080634),   /** @brief OTG_HS host channel-9 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080654),   /** @brief OTG_HS host channel-10 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080674),   /** @brief OTG_HS host channel-11 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x4008068C),   /** @brief OTG_HS host channel-12 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400806A4),   /** @brief OTG_HS host channel-13 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400806BC),   /** @brief OTG_HS host channel-14 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x400806D4),   /** @brief OTG_HS host channel-15 DMA address register */
      },
    };

    /** @subsection OTGX_HS_HOST field mask definitions */

    static const uint32_t OTGX_HS_HOST_HCFG_FSLSPCS_MASK = UINT32_C(0x00000003);        /** @brief FS/LS PHY clock select */
    static const uint32_t OTGX_HS_HOST_HCFG_FSLSS_MASK = UINT32_C(0x00000004);          /** @brief FS- and ls-only support */
    static const uint32_t OTGX_HS_HOST_HFIR_FRIVL_MASK = UINT32_C(0x0000FFFF);          /** @brief Frame interval */
    static const uint32_t OTGX_HS_HOST_HFNUM_FRNUM_MASK = UINT32_C(0x0000FFFF);         /** @brief Frame number */
    static const uint32_t OTGX_HS_HOST_HFNUM_FTREM_MASK = UINT32_C(0xFFFF0000);         /** @brief Frame time remaining */
    static const uint32_t OTGX_HS_HOST_HPTXSTS_PTXFSAVL_MASK = UINT32_C(0x0000FFFF);    /** @brief Periodic transmit data FIFO space available */
    static const uint32_t OTGX_HS_HOST_HPTXSTS_PTXQSAV_MASK = UINT32_C(0x00FF0000);     /** @brief Periodic transmit request queue space available */
    static const uint32_t OTGX_HS_HOST_HPTXSTS_PTXQTOP_MASK = UINT32_C(0xFF000000);     /** @brief Top of the periodic transmit request queue */
    static const uint32_t OTGX_HS_HOST_HAINT_HAINT_MASK = UINT32_C(0x0000FFFF);         /** @brief Channel interrupts */
    static const uint32_t OTGX_HS_HOST_HAINTMSK_HAINTM_MASK = UINT32_C(0x0000FFFF);     /** @brief Channel interrupt mask */
    static const uint32_t OTGX_HS_HOST_HPRT_PCSTS_MASK = UINT32_C(0x00000001);          /** @brief Port connect status */
    static const uint32_t OTGX_HS_HOST_HPRT_PCDET_MASK = UINT32_C(0x00000002);          /** @brief Port connect detected */
    static const uint32_t OTGX_HS_HOST_HPRT_PENA_MASK = UINT32_C(0x00000004);           /** @brief Port enable */
    static const uint32_t OTGX_HS_HOST_HPRT_PENCHNG_MASK = UINT32_C(0x00000008);        /** @brief Port enable/disable change */
    static const uint32_t OTGX_HS_HOST_HPRT_POCA_MASK = UINT32_C(0x00000010);           /** @brief Port overcurrent active */
    static const uint32_t OTGX_HS_HOST_HPRT_POCCHNG_MASK = UINT32_C(0x00000020);        /** @brief Port overcurrent change */
    static const uint32_t OTGX_HS_HOST_HPRT_PRES_MASK = UINT32_C(0x00000040);           /** @brief Port resume */
    static const uint32_t OTGX_HS_HOST_HPRT_PSUSP_MASK = UINT32_C(0x00000080);          /** @brief Port suspend */
    static const uint32_t OTGX_HS_HOST_HPRT_PRST_MASK = UINT32_C(0x00000100);           /** @brief Port reset */
    static const uint32_t OTGX_HS_HOST_HPRT_PLSTS_MASK = UINT32_C(0x00000C00);          /** @brief Port line status */
    static const uint32_t OTGX_HS_HOST_HPRT_PPWR_MASK = UINT32_C(0x00001000);           /** @brief Port power */
    static const uint32_t OTGX_HS_HOST_HPRT_PTCTL_MASK = UINT32_C(0x0001E000);          /** @brief Port test control */
    static const uint32_t OTGX_HS_HOST_HPRT_PSPD_MASK = UINT32_C(0x00060000);           /** @brief Port speed */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALLM response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALLM_MASK = UINT32_C(0x00000008);    /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAKM response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACKM response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MPSIZ_MASK = UINT32_C(0x000007FF);       /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPNUM_MASK = UINT32_C(0x00007800);       /** @brief Endpoint number */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPDIR_MASK = UINT32_C(0x00008000);       /** @brief Endpoint direction */
    static const uint32_t OTGX_HS_HOST_HCCHARX_LSDEV_MASK = UINT32_C(0x00020000);       /** @brief Low-speed device */
    static const uint32_t OTGX_HS_HOST_HCCHARX_EPTYP_MASK = UINT32_C(0x000C0000);       /** @brief Endpoint type */
    static const uint32_t OTGX_HS_HOST_HCCHARX_MC_MASK = UINT32_C(0x00300000);          /** @brief Multi count (MC) / error count (EC) */
    static const uint32_t OTGX_HS_HOST_HCCHARX_DAD_MASK = UINT32_C(0x1FC00000);         /** @brief Device address */
    static const uint32_t OTGX_HS_HOST_HCCHARX_ODDFRM_MASK = UINT32_C(0x20000000);      /** @brief Odd frame */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHDIS_MASK = UINT32_C(0x40000000);       /** @brief Channel disable */
    static const uint32_t OTGX_HS_HOST_HCCHARX_CHENA_MASK = UINT32_C(0x80000000);       /** @brief Channel enable */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_PRTADDR_MASK = UINT32_C(0x0000007F);     /** @brief Port address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_HUBADDR_MASK = UINT32_C(0x00003F80);     /** @brief Hub address */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_XACTPOS_MASK = UINT32_C(0x0000C000);     /** @brief XACTPOS */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_COMPLSPLT_MASK = UINT32_C(0x00010000);   /** @brief Do complete split */
    static const uint32_t OTGX_HS_HOST_HCSPLTX_SPLITEN_MASK = UINT32_C(0x80000000);     /** @brief Split enable */
    static const uint32_t OTGX_HS_HOST_HCINTX_XFRC_MASK = UINT32_C(0x00000001);         /** @brief Transfer completed */
    static const uint32_t OTGX_HS_HOST_HCINTX_CHH_MASK = UINT32_C(0x00000002);          /** @brief Channel halted */
    static const uint32_t OTGX_HS_HOST_HCINTX_AHBERR_MASK = UINT32_C(0x00000004);       /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTX_STALL_MASK = UINT32_C(0x00000008);        /** @brief STALL response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NAK_MASK = UINT32_C(0x00000010);          /** @brief NAK response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_ACK_MASK = UINT32_C(0x00000020);          /** @brief ACK response received/transmitted interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_NYET_MASK = UINT32_C(0x00000040);         /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTX_TXERR_MASK = UINT32_C(0x00000080);        /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTX_BBERR_MASK = UINT32_C(0x00000100);        /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTX_FRMOR_MASK = UINT32_C(0x00000200);        /** @brief Frame overrun */
    static const uint32_t OTGX_HS_HOST_HCINTX_DTERR_MASK = UINT32_C(0x00000400);        /** @brief Data toggle error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_XFRCM_MASK = UINT32_C(0x00000001);     /** @brief Transfer completed mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_CHHM_MASK = UINT32_C(0x00000002);      /** @brief Channel halted mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_AHBERR_MASK = UINT32_C(0x00000004);    /** @brief AHB error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_STALL_MASK = UINT32_C(0x00000008);     /** @brief STALL response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NAKM_MASK = UINT32_C(0x00000010);      /** @brief NAK response received interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_ACKM_MASK = UINT32_C(0x00000020);      /** @brief ACK response received/transmitted interrupt mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_NYET_MASK = UINT32_C(0x00000040);      /** @brief Response received interrupt */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_TXERRM_MASK = UINT32_C(0x00000080);    /** @brief Transaction error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_BBERRM_MASK = UINT32_C(0x00000100);    /** @brief Babble error */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_FRMORM_MASK = UINT32_C(0x00000200);    /** @brief Frame overrun mask */
    static const uint32_t OTGX_HS_HOST_HCINTMSKX_DTERRM_MASK = UINT32_C(0x00000400);    /** @brief Data toggle error mask */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);      /** @brief Transfer size */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);      /** @brief Packet count */
    static const uint32_t OTGX_HS_HOST_HCTSIZX_DPID_MASK = UINT32_C(0x60000000);        /** @brief Data PID */

    /** @subsection OTGX_HS_HOST field position definitions */

    static const int32_t OTGX_HS_HOST_HCDMAX_FSLSPCS_POS = INT32_C(0);      /** @brief FS/LS PHY clock select */
    static const int32_t OTGX_HS_HOST_HCDMAX_FSLSS_POS = INT32_C(2);        /** @brief FS- and ls-only support */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRIVL_POS = INT32_C(0);        /** @brief Frame interval */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRNUM_POS = INT32_C(0);        /** @brief Frame number */
    static const int32_t OTGX_HS_HOST_HCDMAX_FTREM_POS = INT32_C(16);       /** @brief Frame time remaining */
    static const int32_t OTGX_HS_HOST_HCDMAX_PTXFSAVL_POS = INT32_C(0);     /** @brief Periodic transmit data FIFO space available */
    static const int32_t OTGX_HS_HOST_HCDMAX_PTXQSAV_POS = INT32_C(16);     /** @brief Periodic transmit request queue space available */
    static const int32_t OTGX_HS_HOST_HCDMAX_PTXQTOP_POS = INT32_C(24);     /** @brief Top of the periodic transmit request queue */
    static const int32_t OTGX_HS_HOST_HCDMAX_HAINT_POS = INT32_C(0);        /** @brief Channel interrupts */
    static const int32_t OTGX_HS_HOST_HCDMAX_HAINTM_POS = INT32_C(0);       /** @brief Channel interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_PCSTS_POS = INT32_C(0);        /** @brief Port connect status */
    static const int32_t OTGX_HS_HOST_HCDMAX_PCDET_POS = INT32_C(1);        /** @brief Port connect detected */
    static const int32_t OTGX_HS_HOST_HCDMAX_PENA_POS = INT32_C(2);         /** @brief Port enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PENCHNG_POS = INT32_C(3);      /** @brief Port enable/disable change */
    static const int32_t OTGX_HS_HOST_HCDMAX_POCA_POS = INT32_C(4);         /** @brief Port overcurrent active */
    static const int32_t OTGX_HS_HOST_HCDMAX_POCCHNG_POS = INT32_C(5);      /** @brief Port overcurrent change */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRES_POS = INT32_C(6);         /** @brief Port resume */
    static const int32_t OTGX_HS_HOST_HCDMAX_PSUSP_POS = INT32_C(7);        /** @brief Port suspend */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRST_POS = INT32_C(8);         /** @brief Port reset */
    static const int32_t OTGX_HS_HOST_HCDMAX_PLSTS_POS = INT32_C(10);       /** @brief Port line status */
    static const int32_t OTGX_HS_HOST_HCDMAX_PPWR_POS = INT32_C(12);        /** @brief Port power */
    static const int32_t OTGX_HS_HOST_HCDMAX_PTCTL_POS = INT32_C(13);       /** @brief Port test control */
    static const int32_t OTGX_HS_HOST_HCDMAX_PSPD_POS = INT32_C(17);        /** @brief Port speed */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALLM response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALLM_POS = INT32_C(3);       /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAKM response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACKM response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */
    static const int32_t OTGX_HS_HOST_HCDMAX_MPSIZ_POS = INT32_C(0);        /** @brief Maximum packet size */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPNUM_POS = INT32_C(11);       /** @brief Endpoint number */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPDIR_POS = INT32_C(15);       /** @brief Endpoint direction */
    static const int32_t OTGX_HS_HOST_HCDMAX_LSDEV_POS = INT32_C(17);       /** @brief Low-speed device */
    static const int32_t OTGX_HS_HOST_HCDMAX_EPTYP_POS = INT32_C(18);       /** @brief Endpoint type */
    static const int32_t OTGX_HS_HOST_HCDMAX_MC_POS = INT32_C(20);          /** @brief Multi count (MC) / error count (EC) */
    static const int32_t OTGX_HS_HOST_HCDMAX_DAD_POS = INT32_C(22);         /** @brief Device address */
    static const int32_t OTGX_HS_HOST_HCDMAX_ODDFRM_POS = INT32_C(29);      /** @brief Odd frame */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHDIS_POS = INT32_C(30);       /** @brief Channel disable */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHENA_POS = INT32_C(31);       /** @brief Channel enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_PRTADDR_POS = INT32_C(0);      /** @brief Port address */
    static const int32_t OTGX_HS_HOST_HCDMAX_HUBADDR_POS = INT32_C(7);      /** @brief Hub address */
    static const int32_t OTGX_HS_HOST_HCDMAX_XACTPOS_POS = INT32_C(14);     /** @brief XACTPOS */
    static const int32_t OTGX_HS_HOST_HCDMAX_COMPLSPLT_POS = INT32_C(16);   /** @brief Do complete split */
    static const int32_t OTGX_HS_HOST_HCDMAX_SPLITEN_POS = INT32_C(31);     /** @brief Split enable */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRC_POS = INT32_C(0);         /** @brief Transfer completed */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHH_POS = INT32_C(1);          /** @brief Channel halted */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAK_POS = INT32_C(4);          /** @brief NAK response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACK_POS = INT32_C(5);          /** @brief ACK response received/transmitted interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERR_POS = INT32_C(7);        /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERR_POS = INT32_C(8);        /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMOR_POS = INT32_C(9);        /** @brief Frame overrun */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERR_POS = INT32_C(10);       /** @brief Data toggle error */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRCM_POS = INT32_C(0);        /** @brief Transfer completed mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_CHHM_POS = INT32_C(1);         /** @brief Channel halted mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_AHBERR_POS = INT32_C(2);       /** @brief AHB error */
    static const int32_t OTGX_HS_HOST_HCDMAX_STALL_POS = INT32_C(3);        /** @brief STALL response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NAKM_POS = INT32_C(4);         /** @brief NAK response received interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_ACKM_POS = INT32_C(5);         /** @brief ACK response received/transmitted interrupt mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_NYET_POS = INT32_C(6);         /** @brief Response received interrupt */
    static const int32_t OTGX_HS_HOST_HCDMAX_TXERRM_POS = INT32_C(7);       /** @brief Transaction error */
    static const int32_t OTGX_HS_HOST_HCDMAX_BBERRM_POS = INT32_C(8);       /** @brief Babble error */
    static const int32_t OTGX_HS_HOST_HCDMAX_FRMORM_POS = INT32_C(9);       /** @brief Frame overrun mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_DTERRM_POS = INT32_C(10);      /** @brief Data toggle error mask */
    static const int32_t OTGX_HS_HOST_HCDMAX_XFRSIZ_POS = INT32_C(0);       /** @brief Transfer size */
    static const int32_t OTGX_HS_HOST_HCDMAX_PKTCNT_POS = INT32_C(19);      /** @brief Packet count */
    static const int32_t OTGX_HS_HOST_HCDMAX_DPID_POS = INT32_C(29);        /** @brief Data PID */

    /**********************************************************************************************
     * @section OTGX_HS_DEVICE Definitions
     **********************************************************************************************/

    /** @subsection OTGX_HS_DEVICE register array definitions */

    static _RW uint32_t* const OTGX_HS_DEVICE_DCFG_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040800),   /** @brief OTG_HS device configuration register */
      (_RW uint32_t* const)UINT32_C(0x40080800),   /** @brief OTG_HS device configuration register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DCTL_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040804),   /** @brief OTG_HS device control register */
      (_RW uint32_t* const)UINT32_C(0x40080804),   /** @brief OTG_HS device control register */
    };

    static _RO uint32_t* const OTGX_HS_DEVICE_DSTS_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40040808),   /** @brief OTG_HS device status register */
      (_RO uint32_t* const)UINT32_C(0x40080808),   /** @brief OTG_HS device status register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DIEPMSK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040810),   /** @brief OTG_HS device IN endpoint common interrupt mask register */
      (_RW uint32_t* const)UINT32_C(0x40080810),   /** @brief OTG_HS device IN endpoint common interrupt mask register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DOEPMSK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040814),   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
      (_RW uint32_t* const)UINT32_C(0x40080814),   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
    };

    static _RO uint32_t* const OTGX_HS_DEVICE_DAINT_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40040818),   /** @brief OTG_HS device all endpoints interrupt register */
      (_RO uint32_t* const)UINT32_C(0x40080818),   /** @brief OTG_HS device all endpoints interrupt register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DAINTMSK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4004081C),   /** @brief OTG_HS all endpoints interrupt mask register */
      (_RW uint32_t* const)UINT32_C(0x4008081C),   /** @brief OTG_HS all endpoints interrupt mask register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DVBUSDIS_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040828),   /** @brief OTG_HS device VBUS discharge time register */
      (_RW uint32_t* const)UINT32_C(0x40080828),   /** @brief OTG_HS device VBUS discharge time register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DVBUSPULSE_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4004082C),   /** @brief OTG_HS device VBUS pulsing time register */
      (_RW uint32_t* const)UINT32_C(0x4008082C),   /** @brief OTG_HS device VBUS pulsing time register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DTHRCTL_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040830),   /** @brief OTG_HS device threshold control register */
      (_RW uint32_t* const)UINT32_C(0x40080830),   /** @brief OTG_HS device threshold control register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DIEPEMPMSK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040834),   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
      (_RW uint32_t* const)UINT32_C(0x40080834),   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DEACHINT_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040838),   /** @brief OTG_HS device each endpoint interrupt register */
      (_RW uint32_t* const)UINT32_C(0x40080838),   /** @brief OTG_HS device each endpoint interrupt register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DEACHINTMSK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4004083C),   /** @brief OTG_HS device each endpoint interrupt register mask */
      (_RW uint32_t* const)UINT32_C(0x4008083C),   /** @brief OTG_HS device each endpoint interrupt register mask */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DIEPCTLX_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040900),   /** @brief OTG device endpoint-0 control register */
        (_RW uint32_t* const)UINT32_C(0x40040920),   /** @brief OTG device endpoint-1 control register */
        (_RW uint32_t* const)UINT32_C(0x40040940),   /** @brief OTG device endpoint-2 control register */
        (_RW uint32_t* const)UINT32_C(0x40040960),   /** @brief OTG device endpoint-3 control register */
        (_RW uint32_t* const)UINT32_C(0x40040980),   /** @brief OTG device endpoint-4 control register */
        (_RW uint32_t* const)UINT32_C(0x400409A0),   /** @brief OTG device endpoint-5 control register */
        (_RW uint32_t* const)UINT32_C(0x400409C0),   /** @brief OTG device endpoint-6 control register */
        (_RW uint32_t* const)UINT32_C(0x400409E0),   /** @brief OTG device endpoint-7 control register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080900),   /** @brief OTG device endpoint-0 control register */
        (_RW uint32_t* const)UINT32_C(0x40080920),   /** @brief OTG device endpoint-1 control register */
        (_RW uint32_t* const)UINT32_C(0x40080940),   /** @brief OTG device endpoint-2 control register */
        (_RW uint32_t* const)UINT32_C(0x40080960),   /** @brief OTG device endpoint-3 control register */
        (_RW uint32_t* const)UINT32_C(0x40080980),   /** @brief OTG device endpoint-4 control register */
        (_RW uint32_t* const)UINT32_C(0x400809A0),   /** @brief OTG device endpoint-5 control register */
        (_RW uint32_t* const)UINT32_C(0x400809C0),   /** @brief OTG device endpoint-6 control register */
        (_RW uint32_t* const)UINT32_C(0x400809E0),   /** @brief OTG device endpoint-7 control register */
      },
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DIEPINTX_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040908),   /** @brief OTG device endpoint-0 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040928),   /** @brief OTG device endpoint-1 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040948),   /** @brief OTG device endpoint-2 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040968),   /** @brief OTG device endpoint-3 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040988),   /** @brief OTG device endpoint-4 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400409A8),   /** @brief OTG device endpoint-5 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400409C8),   /** @brief OTG device endpoint-6 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400409E8),   /** @brief OTG device endpoint-7 interrupt register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080908),   /** @brief OTG device endpoint-0 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080928),   /** @brief OTG device endpoint-1 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080948),   /** @brief OTG device endpoint-2 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080968),   /** @brief OTG device endpoint-3 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080988),   /** @brief OTG device endpoint-4 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400809A8),   /** @brief OTG device endpoint-5 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400809C8),   /** @brief OTG device endpoint-6 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x400809E8),   /** @brief OTG device endpoint-7 interrupt register */
      },
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DIEPTSIZ0_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040910),   /** @brief OTG_HS device IN endpoint 0 transfer size register */
      (_RW uint32_t* const)UINT32_C(0x40080910),   /** @brief OTG_HS device IN endpoint 0 transfer size register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DIEPDMAX_REG[3][6] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40040914),   /** @brief OTG_HS device endpoint-1 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040934),   /** @brief OTG_HS device endpoint-2 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040954),   /** @brief OTG_HS device endpoint-3 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040974),   /** @brief OTG_HS device endpoint-4 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40040994),   /** @brief OTG_HS device endpoint-5 DMA address register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40080914),   /** @brief OTG_HS device endpoint-1 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080934),   /** @brief OTG_HS device endpoint-2 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080954),   /** @brief OTG_HS device endpoint-3 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080974),   /** @brief OTG_HS device endpoint-4 DMA address register */
        (_RW uint32_t* const)UINT32_C(0x40080994),   /** @brief OTG_HS device endpoint-5 DMA address register */
      },
    };

    static _RO uint32_t* const OTGX_HS_DEVICE_DTXFSTSX_REG[3][8] = {
      {
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RO uint32_t* const)UINT32_C(0x40040918),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40040938),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40040958),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40040978),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40040998),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x400409B8),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x400409A4),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x400409AC),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      },
      {
        (_RO uint32_t* const)UINT32_C(0x40080918),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40080938),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40080958),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40080978),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x40080998),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x400809B8),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x400809A4),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
        (_RO uint32_t* const)UINT32_C(0x400809AC),   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      },
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DIEPTSIZX_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40040930),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040950),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040970),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040990),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400409B0),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400409A0),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400409A8),   /** @brief OTG_HS device endpoint transfer size register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40080930),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080950),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080970),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080990),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400809B0),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400809A0),   /** @brief OTG_HS device endpoint transfer size register */
        (_RW uint32_t* const)UINT32_C(0x400809A8),   /** @brief OTG_HS device endpoint transfer size register */
      },
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DOEPCTL0_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040B00),   /** @brief OTG_HS device control OUT endpoint 0 control register */
      (_RW uint32_t* const)UINT32_C(0x40080B00),   /** @brief OTG_HS device control OUT endpoint 0 control register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DOEPCTLX_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40040B20),   /** @brief OTG device endpoint-1 control register */
        (_RW uint32_t* const)UINT32_C(0x40040B40),   /** @brief OTG device endpoint-2 control register */
        (_RW uint32_t* const)UINT32_C(0x40040B60),   /** @brief OTG device endpoint-3 control register */
        (_RW uint32_t* const)UINT32_C(0x40040B80),   /** @brief OTG device endpoint-4 control register */
        (_RW uint32_t* const)UINT32_C(0x40040BA0),   /** @brief OTG device endpoint-5 control register */
        (_RW uint32_t* const)UINT32_C(0x40040BC0),   /** @brief OTG device endpoint-6 control register */
        (_RW uint32_t* const)UINT32_C(0x40040BE0),   /** @brief OTG device endpoint-7 control register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40080B20),   /** @brief OTG device endpoint-1 control register */
        (_RW uint32_t* const)UINT32_C(0x40080B40),   /** @brief OTG device endpoint-2 control register */
        (_RW uint32_t* const)UINT32_C(0x40080B60),   /** @brief OTG device endpoint-3 control register */
        (_RW uint32_t* const)UINT32_C(0x40080B80),   /** @brief OTG device endpoint-4 control register */
        (_RW uint32_t* const)UINT32_C(0x40080BA0),   /** @brief OTG device endpoint-5 control register */
        (_RW uint32_t* const)UINT32_C(0x40080BC0),   /** @brief OTG device endpoint-6 control register */
        (_RW uint32_t* const)UINT32_C(0x40080BE0),   /** @brief OTG device endpoint-7 control register */
      },
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DOEPINTX_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40040B08),   /** @brief OTG_HS device endpoint-0 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040B28),   /** @brief OTG_HS device endpoint-1 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040B48),   /** @brief OTG_HS device endpoint-2 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040B68),   /** @brief OTG_HS device endpoint-3 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040B88),   /** @brief OTG_HS device endpoint-4 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040BA8),   /** @brief OTG_HS device endpoint-5 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040BC8),   /** @brief OTG_HS device endpoint-6 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40040BE8),   /** @brief OTG_HS device endpoint-7 interrupt register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40080B08),   /** @brief OTG_HS device endpoint-0 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080B28),   /** @brief OTG_HS device endpoint-1 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080B48),   /** @brief OTG_HS device endpoint-2 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080B68),   /** @brief OTG_HS device endpoint-3 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080B88),   /** @brief OTG_HS device endpoint-4 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080BA8),   /** @brief OTG_HS device endpoint-5 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080BC8),   /** @brief OTG_HS device endpoint-6 interrupt register */
        (_RW uint32_t* const)UINT32_C(0x40080BE8),   /** @brief OTG_HS device endpoint-7 interrupt register */
      },
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DOEPTSIZ0_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040B10),   /** @brief OTG_HS device endpoint-0 transfer size register */
      (_RW uint32_t* const)UINT32_C(0x40080B10),   /** @brief OTG_HS device endpoint-0 transfer size register */
    };

    static _RW uint32_t* const OTGX_HS_DEVICE_DOEPTSIZX_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40040B30),   /** @brief OTG_HS device endpoint-1 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040B50),   /** @brief OTG_HS device endpoint-2 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040B70),   /** @brief OTG_HS device endpoint-3 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040B90),   /** @brief OTG_HS device endpoint-4 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040BB0),   /** @brief OTG_HS device endpoint-5 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040BD0),   /** @brief OTG_HS device endpoint-6 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40040BF0),   /** @brief OTG_HS device endpoint-7 transfer size register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40080B30),   /** @brief OTG_HS device endpoint-1 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080B50),   /** @brief OTG_HS device endpoint-2 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080B70),   /** @brief OTG_HS device endpoint-3 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080B90),   /** @brief OTG_HS device endpoint-4 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080BB0),   /** @brief OTG_HS device endpoint-5 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080BD0),   /** @brief OTG_HS device endpoint-6 transfer size register */
        (_RW uint32_t* const)UINT32_C(0x40080BF0),   /** @brief OTG_HS device endpoint-7 transfer size register */
      },
    };

    /** @subsection OTGX_HS_DEVICE field mask definitions */

    static const uint32_t OTGX_HS_DEVICE_DCFG_DSPD_MASK = UINT32_C(0x00000003);                  /** @brief Device speed */
    static const uint32_t OTGX_HS_DEVICE_DCFG_NZLSOHSK_MASK = UINT32_C(0x00000004);              /** @brief Nonzero-length status OUT handshake */
    static const uint32_t OTGX_HS_DEVICE_DCFG_DAD_MASK = UINT32_C(0x000007F0);                   /** @brief Device address */
    static const uint32_t OTGX_HS_DEVICE_DCFG_PFIVL_MASK = UINT32_C(0x00001800);                 /** @brief Periodic (micro)frame interval */
    static const uint32_t OTGX_HS_DEVICE_DCFG_PERSCHIVL_MASK = UINT32_C(0x03000000);             /** @brief Periodic scheduling interval */
    static const uint32_t OTGX_HS_DEVICE_DCTL_RWUSIG_MASK = UINT32_C(0x00000001);                /** @brief Remote wakeup signaling */
    static const uint32_t OTGX_HS_DEVICE_DCTL_SDIS_MASK = UINT32_C(0x00000002);                  /** @brief Soft disconnect */
    static const uint32_t OTGX_HS_DEVICE_DCTL_GINSTS_MASK = UINT32_C(0x00000004);                /** @brief Global IN NAK status */
    static const uint32_t OTGX_HS_DEVICE_DCTL_GONSTS_MASK = UINT32_C(0x00000008);                /** @brief Global OUT NAK status */
    static const uint32_t OTGX_HS_DEVICE_DCTL_TCTL_MASK = UINT32_C(0x00000070);                  /** @brief Test control */
    static const uint32_t OTGX_HS_DEVICE_DCTL_SGINAK_MASK = UINT32_C(0x00000080);                /** @brief Set global IN NAK */
    static const uint32_t OTGX_HS_DEVICE_DCTL_CGINAK_MASK = UINT32_C(0x00000100);                /** @brief Clear global IN NAK */
    static const uint32_t OTGX_HS_DEVICE_DCTL_SGONAK_MASK = UINT32_C(0x00000200);                /** @brief Set global OUT NAK */
    static const uint32_t OTGX_HS_DEVICE_DCTL_CGONAK_MASK = UINT32_C(0x00000400);                /** @brief Clear global OUT NAK */
    static const uint32_t OTGX_HS_DEVICE_DCTL_POPRGDNE_MASK = UINT32_C(0x00000800);              /** @brief Power-on programming done */
    static const uint32_t OTGX_HS_DEVICE_DSTS_SUSPSTS_MASK = UINT32_C(0x00000001);               /** @brief Suspend status */
    static const uint32_t OTGX_HS_DEVICE_DSTS_ENUMSPD_MASK = UINT32_C(0x00000006);               /** @brief Enumerated speed */
    static const uint32_t OTGX_HS_DEVICE_DSTS_EERR_MASK = UINT32_C(0x00000008);                  /** @brief Erratic error */
    static const uint32_t OTGX_HS_DEVICE_DSTS_FNSOF_MASK = UINT32_C(0x003FFF00);                 /** @brief Frame number of the received SOF */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_XFRCM_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt mask */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_EPDM_MASK = UINT32_C(0x00000002);               /** @brief Endpoint disabled interrupt mask */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_TOM_MASK = UINT32_C(0x00000008);                /** @brief Timeout condition mask (nonisochronous endpoints) */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_ITTXFEMSK_MASK = UINT32_C(0x00000010);          /** @brief IN token received when txfifo empty mask */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_INEPNMM_MASK = UINT32_C(0x00000020);            /** @brief IN token received with EP mismatch mask */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_INEPNEM_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective mask */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_TXFURM_MASK = UINT32_C(0x00000100);             /** @brief FIFO underrun mask */
    static const uint32_t OTGX_HS_DEVICE_DIEPMSK_BIM_MASK = UINT32_C(0x00000200);                /** @brief BNA interrupt mask */
    static const uint32_t OTGX_HS_DEVICE_DOEPMSK_XFRCM_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt mask */
    static const uint32_t OTGX_HS_DEVICE_DOEPMSK_EPDM_MASK = UINT32_C(0x00000002);               /** @brief Endpoint disabled interrupt mask */
    static const uint32_t OTGX_HS_DEVICE_DOEPMSK_STUPM_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done mask */
    static const uint32_t OTGX_HS_DEVICE_DOEPMSK_OTEPDM_MASK = UINT32_C(0x00000010);             /** @brief OUT token received when endpoint disabled mask */
    static const uint32_t OTGX_HS_DEVICE_DOEPMSK_B2BSTUP_MASK = UINT32_C(0x00000040);            /** @brief Back-to-back SETUP packets received mask */
    static const uint32_t OTGX_HS_DEVICE_DOEPMSK_OPEM_MASK = UINT32_C(0x00000100);               /** @brief OUT packet error mask */
    static const uint32_t OTGX_HS_DEVICE_DOEPMSK_BOIM_MASK = UINT32_C(0x00000200);               /** @brief BNA interrupt mask */
    static const uint32_t OTGX_HS_DEVICE_DAINT_IEPINT_MASK = UINT32_C(0x0000FFFF);               /** @brief IN endpoint interrupt bits */
    static const uint32_t OTGX_HS_DEVICE_DAINT_OEPINT_MASK = UINT32_C(0xFFFF0000);               /** @brief OUT endpoint interrupt bits */
    static const uint32_t OTGX_HS_DEVICE_DAINTMSK_IEPM_MASK = UINT32_C(0x0000FFFF);              /** @brief IN EP interrupt mask bits */
    static const uint32_t OTGX_HS_DEVICE_DAINTMSK_OEPM_MASK = UINT32_C(0xFFFF0000);              /** @brief OUT EP interrupt mask bits */
    static const uint32_t OTGX_HS_DEVICE_DVBUSDIS_VBUSDT_MASK = UINT32_C(0x0000FFFF);            /** @brief Device VBUS discharge time */
    static const uint32_t OTGX_HS_DEVICE_DVBUSPULSE_DVBUSP_MASK = UINT32_C(0x00000FFF);          /** @brief Device VBUS pulsing time */
    static const uint32_t OTGX_HS_DEVICE_DTHRCTL_NONISOTHREN_MASK = UINT32_C(0x00000001);        /** @brief Nonisochronous IN endpoints threshold enable */
    static const uint32_t OTGX_HS_DEVICE_DTHRCTL_ISOTHREN_MASK = UINT32_C(0x00000002);           /** @brief ISO IN endpoint threshold enable */
    static const uint32_t OTGX_HS_DEVICE_DTHRCTL_TXTHRLEN_MASK = UINT32_C(0x000007FC);           /** @brief Transmit threshold length */
    static const uint32_t OTGX_HS_DEVICE_DTHRCTL_RXTHREN_MASK = UINT32_C(0x00010000);            /** @brief Receive threshold enable */
    static const uint32_t OTGX_HS_DEVICE_DTHRCTL_RXTHRLEN_MASK = UINT32_C(0x03FE0000);           /** @brief Receive threshold length */
    static const uint32_t OTGX_HS_DEVICE_DTHRCTL_ARPEN_MASK = UINT32_C(0x08000000);              /** @brief Arbiter parking enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPEMPMSK_INEPTXFEM_MASK = UINT32_C(0x0000FFFF);       /** @brief IN EP tx FIFO empty interrupt mask bits */
    static const uint32_t OTGX_HS_DEVICE_DEACHINT_IEP1INT_MASK = UINT32_C(0x00000002);           /** @brief IN endpoint 1interrupt bit */
    static const uint32_t OTGX_HS_DEVICE_DEACHINT_OEP1INT_MASK = UINT32_C(0x00020000);           /** @brief OUT endpoint 1 interrupt bit */
    static const uint32_t OTGX_HS_DEVICE_DEACHINTMSK_IEP1INTM_MASK = UINT32_C(0x00000002);       /** @brief IN endpoint 1 interrupt mask bit */
    static const uint32_t OTGX_HS_DEVICE_DEACHINTMSK_OEP1INTM_MASK = UINT32_C(0x00020000);       /** @brief OUT endpoint 1 interrupt mask bit */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even/odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_TXFNUM_MASK = UINT32_C(0x03C00000);            /** @brief TxFIFO number */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 PID */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DIEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TOC_MASK = UINT32_C(0x00000008);               /** @brief Timeout condition */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_ITTXFE_MASK = UINT32_C(0x00000010);            /** @brief IN token received when txfifo is empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_INEPNE_MASK = UINT32_C(0x00000040);            /** @brief IN endpoint NAK effective */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFE_MASK = UINT32_C(0x00000080);              /** @brief Transmit FIFO empty */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_TXFIFOUDRN_MASK = UINT32_C(0x00000100);        /** @brief Transmit fifo underrun */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BNA_MASK = UINT32_C(0x00000200);               /** @brief Buffer not available interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_PKTDRPSTS_MASK = UINT32_C(0x00000800);         /** @brief Packet dropped status */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_BERR_MASK = UINT32_C(0x00001000);              /** @brief Babble error interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPINTX_NAK_MASK = UINT32_C(0x00002000);               /** @brief NAK interrupt */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZ0_XFRSIZ_MASK = UINT32_C(0x0000007F);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZ0_PKTCNT_MASK = UINT32_C(0x00180000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_MCNT_MASK = UINT32_C(0x60000000);             /** @brief Multi count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_MCNT_MASK = UINT32_C(0x60000000);             /** @brief Multi count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_MCNT_MASK = UINT32_C(0x60000000);             /** @brief Multi count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_MCNT_MASK = UINT32_C(0x60000000);             /** @brief Multi count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_MCNT_MASK = UINT32_C(0x60000000);             /** @brief Multi count */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_MPSIZ_MASK = UINT32_C(0x00000003);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTL0_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_XFRC_MASK = UINT32_C(0x00000001);              /** @brief Transfer completed interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_EPDISD_MASK = UINT32_C(0x00000002);            /** @brief Endpoint disabled interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_STUP_MASK = UINT32_C(0x00000008);              /** @brief SETUP phase done */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_OTEPDIS_MASK = UINT32_C(0x00000010);           /** @brief OUT token received when endpoint disabled */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_B2BSTUP_MASK = UINT32_C(0x00000040);           /** @brief Back-to-back SETUP packets received */
    static const uint32_t OTGX_HS_DEVICE_DOEPINTX_NYET_MASK = UINT32_C(0x00004000);              /** @brief NYET interrupt */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZ0_XFRSIZ_MASK = UINT32_C(0x0000007F);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZ0_PKTCNT_MASK = UINT32_C(0x00080000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZ0_STUPCNT_MASK = UINT32_C(0x60000000);          /** @brief SETUP packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_MASK = UINT32_C(0x60000000);   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_MASK = UINT32_C(0x60000000);   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_MASK = UINT32_C(0x60000000);   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_MASK = UINT32_C(0x60000000);   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_MCNT_MASK = UINT32_C(0x60000000);             /** @brief Multi count */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DIEPTSIZX_MCNT_MASK = UINT32_C(0x60000000);             /** @brief Multi count */
    static const uint32_t OTGX_HS_DEVICE_DTXFSTSX_INEPTFSAV_MASK = UINT32_C(0x0000FFFF);         /** @brief IN endpoint txfifo space avail */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_MPSIZ_MASK = UINT32_C(0x000007FF);             /** @brief Maximum packet size */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_USBAEP_MASK = UINT32_C(0x00008000);            /** @brief USB active endpoint */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EONUM_DPID_MASK = UINT32_C(0x00010000);        /** @brief Even odd frame/endpoint data PID */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_NAKSTS_MASK = UINT32_C(0x00020000);            /** @brief NAK status */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPTYP_MASK = UINT32_C(0x000C0000);             /** @brief Endpoint type */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNPM_MASK = UINT32_C(0x00100000);              /** @brief Snoop mode */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_STALL_MASK = UINT32_C(0x00200000);             /** @brief STALL handshake */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_CNAK_MASK = UINT32_C(0x04000000);              /** @brief Clear NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SNAK_MASK = UINT32_C(0x08000000);              /** @brief Set NAK */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SD0PID_SEVNFRM_MASK = UINT32_C(0x10000000);    /** @brief Set DATA0 pid/set even frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_SODDFRM_MASK = UINT32_C(0x20000000);           /** @brief Set odd frame */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPDIS_MASK = UINT32_C(0x40000000);             /** @brief Endpoint disable */
    static const uint32_t OTGX_HS_DEVICE_DOEPCTLX_EPENA_MASK = UINT32_C(0x80000000);             /** @brief Endpoint enable */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_MASK = UINT32_C(0x60000000);   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_MASK = UINT32_C(0x60000000);   /** @brief Received data PID/SETUP packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_MASK = UINT32_C(0x0007FFFF);           /** @brief Transfer size */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_MASK = UINT32_C(0x1FF80000);           /** @brief Packet count */
    static const uint32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_MASK = UINT32_C(0x60000000);   /** @brief Received data PID/SETUP packet count */

    /** @subsection OTGX_HS_DEVICE field position definitions */

    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_DSPD_POS = INT32_C(0);              /** @brief Device speed */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NZLSOHSK_POS = INT32_C(2);          /** @brief Nonzero-length status OUT handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_DAD_POS = INT32_C(4);               /** @brief Device address */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PFIVL_POS = INT32_C(11);            /** @brief Periodic (micro)frame interval */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PERSCHIVL_POS = INT32_C(24);        /** @brief Periodic scheduling interval */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RWUSIG_POS = INT32_C(0);            /** @brief Remote wakeup signaling */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SDIS_POS = INT32_C(1);              /** @brief Soft disconnect */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_GINSTS_POS = INT32_C(2);            /** @brief Global IN NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_GONSTS_POS = INT32_C(3);            /** @brief Global OUT NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TCTL_POS = INT32_C(4);              /** @brief Test control */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SGINAK_POS = INT32_C(7);            /** @brief Set global IN NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CGINAK_POS = INT32_C(8);            /** @brief Clear global IN NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SGONAK_POS = INT32_C(9);            /** @brief Set global OUT NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CGONAK_POS = INT32_C(10);           /** @brief Clear global OUT NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_POPRGDNE_POS = INT32_C(11);         /** @brief Power-on programming done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SUSPSTS_POS = INT32_C(0);           /** @brief Suspend status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ENUMSPD_POS = INT32_C(1);           /** @brief Enumerated speed */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EERR_POS = INT32_C(3);              /** @brief Erratic error */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_FNSOF_POS = INT32_C(8);             /** @brief Frame number of the received SOF */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRCM_POS = INT32_C(0);             /** @brief Transfer completed interrupt mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDM_POS = INT32_C(1);              /** @brief Endpoint disabled interrupt mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOM_POS = INT32_C(3);               /** @brief Timeout condition mask (nonisochronous endpoints) */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFEMSK_POS = INT32_C(4);         /** @brief IN token received when txfifo empty mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNMM_POS = INT32_C(5);           /** @brief IN token received with EP mismatch mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNEM_POS = INT32_C(6);           /** @brief IN endpoint NAK effective mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFURM_POS = INT32_C(8);            /** @brief FIFO underrun mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BIM_POS = INT32_C(9);               /** @brief BNA interrupt mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRCM_POS = INT32_C(0);             /** @brief Transfer completed interrupt mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDM_POS = INT32_C(1);              /** @brief Endpoint disabled interrupt mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUPM_POS = INT32_C(3);             /** @brief SETUP phase done mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDM_POS = INT32_C(4);            /** @brief OUT token received when endpoint disabled mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OPEM_POS = INT32_C(8);              /** @brief OUT packet error mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BOIM_POS = INT32_C(9);              /** @brief BNA interrupt mask */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_IEPINT_POS = INT32_C(0);            /** @brief IN endpoint interrupt bits */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OEPINT_POS = INT32_C(16);           /** @brief OUT endpoint interrupt bits */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_IEPM_POS = INT32_C(0);              /** @brief IN EP interrupt mask bits */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OEPM_POS = INT32_C(16);             /** @brief OUT EP interrupt mask bits */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_VBUSDT_POS = INT32_C(0);            /** @brief Device VBUS discharge time */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_DVBUSP_POS = INT32_C(0);            /** @brief Device VBUS pulsing time */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NONISOTHREN_POS = INT32_C(0);       /** @brief Nonisochronous IN endpoints threshold enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ISOTHREN_POS = INT32_C(1);          /** @brief ISO IN endpoint threshold enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXTHRLEN_POS = INT32_C(2);          /** @brief Transmit threshold length */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXTHREN_POS = INT32_C(16);          /** @brief Receive threshold enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXTHRLEN_POS = INT32_C(17);         /** @brief Receive threshold length */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ARPEN_POS = INT32_C(27);            /** @brief Arbiter parking enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTXFEM_POS = INT32_C(0);         /** @brief IN EP tx FIFO empty interrupt mask bits */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_IEP1INT_POS = INT32_C(1);           /** @brief IN endpoint 1interrupt bit */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OEP1INT_POS = INT32_C(17);          /** @brief OUT endpoint 1 interrupt bit */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_IEP1INTM_POS = INT32_C(1);          /** @brief IN endpoint 1 interrupt mask bit */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OEP1INTM_POS = INT32_C(17);         /** @brief OUT endpoint 1 interrupt mask bit */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even/odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFNUM_POS = INT32_C(22);           /** @brief TxFIFO number */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TOC_POS = INT32_C(3);               /** @brief Timeout condition */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_ITTXFE_POS = INT32_C(4);            /** @brief IN token received when txfifo is empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPNE_POS = INT32_C(6);            /** @brief IN endpoint NAK effective */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFE_POS = INT32_C(7);              /** @brief Transmit FIFO empty */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_TXFIFOUDRN_POS = INT32_C(8);        /** @brief Transmit fifo underrun */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BNA_POS = INT32_C(9);               /** @brief Buffer not available interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTDRPSTS_POS = INT32_C(11);        /** @brief Packet dropped status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_BERR_POS = INT32_C(12);             /** @brief Babble error interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAK_POS = INT32_C(13);              /** @brief NAK interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MCNT_POS = INT32_C(29);             /** @brief Multi count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MCNT_POS = INT32_C(29);             /** @brief Multi count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MCNT_POS = INT32_C(29);             /** @brief Multi count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MCNT_POS = INT32_C(29);             /** @brief Multi count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MCNT_POS = INT32_C(29);             /** @brief Multi count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRC_POS = INT32_C(0);              /** @brief Transfer completed interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDISD_POS = INT32_C(1);            /** @brief Endpoint disabled interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUP_POS = INT32_C(3);              /** @brief SETUP phase done */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_OTEPDIS_POS = INT32_C(4);           /** @brief OUT token received when endpoint disabled */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_B2BSTUP_POS = INT32_C(6);           /** @brief Back-to-back SETUP packets received */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NYET_POS = INT32_C(14);             /** @brief NYET interrupt */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STUPCNT_POS = INT32_C(29);          /** @brief SETUP packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_POS = INT32_C(29);   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_POS = INT32_C(29);   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_POS = INT32_C(29);   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_POS = INT32_C(29);   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MCNT_POS = INT32_C(29);             /** @brief Multi count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MCNT_POS = INT32_C(29);             /** @brief Multi count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_INEPTFSAV_POS = INT32_C(0);         /** @brief IN endpoint txfifo space avail */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_MPSIZ_POS = INT32_C(0);             /** @brief Maximum packet size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_USBAEP_POS = INT32_C(15);           /** @brief USB active endpoint */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EONUM_DPID_POS = INT32_C(16);       /** @brief Even odd frame/endpoint data PID */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_NAKSTS_POS = INT32_C(17);           /** @brief NAK status */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPTYP_POS = INT32_C(18);            /** @brief Endpoint type */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNPM_POS = INT32_C(20);             /** @brief Snoop mode */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_STALL_POS = INT32_C(21);            /** @brief STALL handshake */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_CNAK_POS = INT32_C(26);             /** @brief Clear NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SNAK_POS = INT32_C(27);             /** @brief Set NAK */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SD0PID_SEVNFRM_POS = INT32_C(28);   /** @brief Set DATA0 pid/set even frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_SODDFRM_POS = INT32_C(29);          /** @brief Set odd frame */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPDIS_POS = INT32_C(30);            /** @brief Endpoint disable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_EPENA_POS = INT32_C(31);            /** @brief Endpoint enable */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_POS = INT32_C(29);   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_POS = INT32_C(29);   /** @brief Received data PID/SETUP packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_XFRSIZ_POS = INT32_C(0);            /** @brief Transfer size */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_PKTCNT_POS = INT32_C(19);           /** @brief Packet count */
    static const int32_t OTGX_HS_DEVICE_DOEPTSIZX_RXDPID_STUPCNT_POS = INT32_C(29);   /** @brief Received data PID/SETUP packet count */

    /**********************************************************************************************
     * @section OTGX_HS_PWRCLK Definitions
     **********************************************************************************************/

    /** @subsection OTGX_HS_PWRCLK register array definitions */

    static _RW uint32_t* const OTGX_HS_PWRCLK_PCGCR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40040E00),   /** @brief Power and clock gating control register */
      (_RW uint32_t* const)UINT32_C(0x40080E00),   /** @brief Power and clock gating control register */
    };

    /** @subsection OTGX_HS_PWRCLK field mask definitions */

    static const uint32_t OTGX_HS_PWRCLK_PCGCR_STPPCLK_MASK = UINT32_C(0x00000001);    /** @brief Stop PHY clock */
    static const uint32_t OTGX_HS_PWRCLK_PCGCR_GATEHCLK_MASK = UINT32_C(0x00000002);   /** @brief Gate HCLK */
    static const uint32_t OTGX_HS_PWRCLK_PCGCR_PHYSUSP_MASK = UINT32_C(0x00000010);    /** @brief PHY suspended */

    /** @subsection OTGX_HS_PWRCLK field position definitions */

    static const int32_t OTGX_HS_PWRCLK_PCGCR_STPPCLK_POS = INT32_C(0);    /** @brief Stop PHY clock */
    static const int32_t OTGX_HS_PWRCLK_PCGCR_GATEHCLK_POS = INT32_C(1);   /** @brief Gate HCLK */
    static const int32_t OTGX_HS_PWRCLK_PCGCR_PHYSUSP_POS = INT32_C(4);    /** @brief PHY suspended */

    /**********************************************************************************************
     * @section ETHERNET_MAC Definitions
     **********************************************************************************************/

    /** @subsection ETHERNET_MAC IRQ interrupt definitions */

    static const int32_t ETH_IRQ = INT32_C(61);        /** @brief Ethernet global interrupt */
    static const int32_t ETH_WKUP_IRQ = INT32_C(62);   /** @brief Ethernet wakeup through EXTI */

    /** @subsection ETHERNET_MAC register array definitions */

    static _RW uint32_t* const ETHERNET_MAC_MACAXLR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x40028304),   /** @brief Address 0 low register */
      (_RW uint32_t* const)UINT32_C(0x4002830C),   /** @brief Address 1 low register */
      (_RW uint32_t* const)UINT32_C(0x40028314),   /** @brief Address 2 low register */
      (_RW uint32_t* const)UINT32_C(0x4002831C),   /** @brief Address 3 low register */
    };

    static _RW uint32_t* const ETHERNET_MAC_MACAXHR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40028308),   /** @brief Address 1 high register */
      (_RW uint32_t* const)UINT32_C(0x40028310),   /** @brief Address 2 high register */
      (_RW uint32_t* const)UINT32_C(0x40028318),   /** @brief Address 3 high register */
    };

    static _RW uint32_t* const ETHERNET_MAC_MACL3AXR_REG[32] = {
      (_RW uint32_t* const)UINT32_C(0x40028910),   /** @brief MACL3A00R */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40028914),   /** @brief Layer3 address 1 filter 0 register */
      (_RW uint32_t* const)UINT32_C(0x40028944),   /** @brief Layer3 address 1 filter 1 register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40028948),   /** @brief Layer3 address 2 filter 1 register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4002894C),   /** @brief Layer3 address 3 filter 1 register */
    };

    static _RW uint32_t* const ETHERNET_MAC_MACL3A0XR_REG[2] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40028940),   /** @brief Layer3 address 0 filter 1 register */
    };

    /** @subsection ETHERNET_MAC register definitions */

    static _RW uint32_t* const ETHERNET_MAC_DMAMR_REG = (_RW uint32_t* const)UINT32_C(0x40029000);                                /** @brief DMA mode register */
    static _RW uint32_t* const ETHERNET_MAC_DMASBMR_REG = (_RW uint32_t* const)UINT32_C(0x40029004);                              /** @brief System bus mode register */
    static _RO uint32_t* const ETHERNET_MAC_DMAISR_REG = (_RO uint32_t* const)UINT32_C(0x40029008);                               /** @brief Interrupt status register */
    static _RO uint32_t* const ETHERNET_MAC_DMADSR_REG = (_RO uint32_t* const)UINT32_C(0x4002900C);                               /** @brief Debug status register */
    static _RW uint32_t* const ETHERNET_MAC_DMACCR_REG = (_RW uint32_t* const)UINT32_C(0x40029100);                               /** @brief Channel control register */
    static _RW uint32_t* const ETHERNET_MAC_DMACTXCR_REG = (_RW uint32_t* const)UINT32_C(0x40029104);                             /** @brief Channel transmit control register */
    static _RW uint32_t* const ETHERNET_MAC_DMACRXCR_REG = (_RW uint32_t* const)UINT32_C(0x40029108);                             /** @brief Channel receive control register */
    static _RW uint32_t* const ETHERNET_MAC_DMACTXDLAR_REG = (_RW uint32_t* const)UINT32_C(0x40029114);                           /** @brief Channel tx descriptor list address register */
    static _RW uint32_t* const ETHERNET_MAC_DMACRXDLAR_REG = (_RW uint32_t* const)UINT32_C(0x4002911C);                           /** @brief Channel rx descriptor list address register */
    static _RW uint32_t* const ETHERNET_MAC_DMACTXDTPR_REG = (_RW uint32_t* const)UINT32_C(0x40029120);                           /** @brief Channel tx descriptor tail pointer register */
    static _RW uint32_t* const ETHERNET_MAC_DMACRXDTPR_REG = (_RW uint32_t* const)UINT32_C(0x40029128);                           /** @brief Channel rx descriptor tail pointer register */
    static _RW uint32_t* const ETHERNET_MAC_DMACTXRLR_REG = (_RW uint32_t* const)UINT32_C(0x4002912C);                            /** @brief Channel tx descriptor ring length register */
    static _RW uint32_t* const ETHERNET_MAC_DMACRXRLR_REG = (_RW uint32_t* const)UINT32_C(0x40029130);                            /** @brief Channel rx descriptor ring length register */
    static _RW uint32_t* const ETHERNET_MAC_DMACIER_REG = (_RW uint32_t* const)UINT32_C(0x40029134);                              /** @brief Channel interrupt enable register */
    static _RW uint32_t* const ETHERNET_MAC_DMACRXIWTR_REG = (_RW uint32_t* const)UINT32_C(0x40029138);                           /** @brief Channel rx interrupt watchdog timer register */
    static _RO uint32_t* const ETHERNET_MAC_DMACCATXDR_REG = (_RO uint32_t* const)UINT32_C(0x40029144);                           /** @brief Channel current application transmit descriptor register */
    static _RO uint32_t* const ETHERNET_MAC_DMACCARXDR_REG = (_RO uint32_t* const)UINT32_C(0x4002914C);                           /** @brief Channel current application receive descriptor register */
    static _RO uint32_t* const ETHERNET_MAC_DMACCATXBR_REG = (_RO uint32_t* const)UINT32_C(0x40029154);                           /** @brief Channel current application transmit buffer register */
    static _RO uint32_t* const ETHERNET_MAC_DMACCARXBR_REG = (_RO uint32_t* const)UINT32_C(0x4002915C);                           /** @brief Channel current application receive buffer register */
    static _RW uint32_t* const ETHERNET_MAC_DMACSR_REG = (_RW uint32_t* const)UINT32_C(0x40029160);                               /** @brief Channel status register */
    static _RO uint32_t* const ETHERNET_MAC_DMACMFCR_REG = (_RO uint32_t* const)UINT32_C(0x4002916C);                             /** @brief Channel missed frame count register */
    static _RW uint32_t* const ETHERNET_MAC_MTLOMR_REG = (_RW uint32_t* const)UINT32_C(0x40028C00);                               /** @brief Operating mode register */
    static _RO uint32_t* const ETHERNET_MAC_MTLISR_REG = (_RO uint32_t* const)UINT32_C(0x40028C20);                               /** @brief Interrupt status register */
    static _RW uint32_t* const ETHERNET_MAC_MTLTXQOMR_REG = (_RW uint32_t* const)UINT32_C(0x40028D00);                            /** @brief Tx queue operating mode register */
    static _RO uint32_t* const ETHERNET_MAC_MTLTXQUR_REG = (_RO uint32_t* const)UINT32_C(0x40028D04);                             /** @brief Tx queue underflow register */
    static _RO uint32_t* const ETHERNET_MAC_MTLTXQDR_REG = (_RO uint32_t* const)UINT32_C(0x40028D08);                             /** @brief Tx queue debug register */
    static _RW uint32_t* const ETHERNET_MAC_MTLQICSR_REG = (_RW uint32_t* const)UINT32_C(0x40028D2C);                             /** @brief Queue interrupt control status register */
    static _RW uint32_t* const ETHERNET_MAC_MTLRXQOMR_REG = (_RW uint32_t* const)UINT32_C(0x40028D30);                            /** @brief Rx queue operating mode register */
    static _RO uint32_t* const ETHERNET_MAC_MTLRXQMPOCR_REG = (_RO uint32_t* const)UINT32_C(0x40028D34);                          /** @brief Rx queue missed packet and overflow counter register */
    static _RO uint32_t* const ETHERNET_MAC_MTLRXQDR_REG = (_RO uint32_t* const)UINT32_C(0x40028D38);                             /** @brief Rx queue debug register */
    static _RW uint32_t* const ETHERNET_MAC_MACCR_REG = (_RW uint32_t* const)UINT32_C(0x40028000);                                /** @brief Operating mode configuration register */
    static _RW uint32_t* const ETHERNET_MAC_MACECR_REG = (_RW uint32_t* const)UINT32_C(0x40028004);                               /** @brief Extended operating mode configuration register */
    static _RW uint32_t* const ETHERNET_MAC_MACPFR_REG = (_RW uint32_t* const)UINT32_C(0x40028008);                               /** @brief Packet filtering control register */
    static _RW uint32_t* const ETHERNET_MAC_MACWTR_REG = (_RW uint32_t* const)UINT32_C(0x4002800C);                               /** @brief Watchdog timeout register */
    static _RW uint32_t* const ETHERNET_MAC_MACHT0R_REG = (_RW uint32_t* const)UINT32_C(0x40028010);                              /** @brief Hash table 0 register */
    static _RW uint32_t* const ETHERNET_MAC_MACHT1R_REG = (_RW uint32_t* const)UINT32_C(0x40028014);                              /** @brief Hash table 1 register */
    static _RW uint32_t* const ETHERNET_MAC_MACVTR_REG = (_RW uint32_t* const)UINT32_C(0x40028050);                               /** @brief VLAN tag register */
    static _RW uint32_t* const ETHERNET_MAC_MACVHTR_REG = (_RW uint32_t* const)UINT32_C(0x40028058);                              /** @brief VLAN hash table register */
    static _RW uint32_t* const ETHERNET_MAC_MACVIR_REG = (_RW uint32_t* const)UINT32_C(0x40028060);                               /** @brief VLAN inclusion register */
    static _RW uint32_t* const ETHERNET_MAC_MACIVIR_REG = (_RW uint32_t* const)UINT32_C(0x40028064);                              /** @brief Inner VLAN inclusion register */
    static _RW uint32_t* const ETHERNET_MAC_MACQTXFCR_REG = (_RW uint32_t* const)UINT32_C(0x40028070);                            /** @brief Tx queue flow control register */
    static _RW uint32_t* const ETHERNET_MAC_MACRXFCR_REG = (_RW uint32_t* const)UINT32_C(0x40028090);                             /** @brief Rx flow control register */
    static _RO uint32_t* const ETHERNET_MAC_MACISR_REG = (_RO uint32_t* const)UINT32_C(0x400280B0);                               /** @brief Interrupt status register */
    static _RW uint32_t* const ETHERNET_MAC_MACIER_REG = (_RW uint32_t* const)UINT32_C(0x400280B4);                               /** @brief Interrupt enable register */
    static _RO uint32_t* const ETHERNET_MAC_MACRXTXSR_REG = (_RO uint32_t* const)UINT32_C(0x400280B8);                            /** @brief Rx tx status register */
    static _RW uint32_t* const ETHERNET_MAC_MACPCSR_REG = (_RW uint32_t* const)UINT32_C(0x400280C0);                              /** @brief PMT control status register */
    static _RW uint32_t* const ETHERNET_MAC_MACRWKPFR_REG = (_RW uint32_t* const)UINT32_C(0x400280C4);                            /** @brief Remove wakeup packet filter register */
    static _RW uint32_t* const ETHERNET_MAC_MACLCSR_REG = (_RW uint32_t* const)UINT32_C(0x400280D0);                              /** @brief LPI control status register */
    static _RW uint32_t* const ETHERNET_MAC_MACLTCR_REG = (_RW uint32_t* const)UINT32_C(0x400280D4);                              /** @brief LPI timers control register */
    static _RW uint32_t* const ETHERNET_MAC_MACLETR_REG = (_RW uint32_t* const)UINT32_C(0x400280D8);                              /** @brief LPI entry timer register */
    static _RW uint32_t* const ETHERNET_MAC_MAC1USTCR_REG = (_RW uint32_t* const)UINT32_C(0x400280DC);                            /** @brief 1-microsecond-tick counter register */
    static _RO uint32_t* const ETHERNET_MAC_MACVR_REG = (_RO uint32_t* const)UINT32_C(0x40028110);                                /** @brief Version register */
    static _RO uint32_t* const ETHERNET_MAC_MACHWF1R_REG = (_RO uint32_t* const)UINT32_C(0x40028120);                             /** @brief HW feature 1 register */
    static _RO uint32_t* const ETHERNET_MAC_MACHWF2R_REG = (_RO uint32_t* const)UINT32_C(0x40028124);                             /** @brief HW feature 2 register */
    static _RW uint32_t* const ETHERNET_MAC_MACMDIOAR_REG = (_RW uint32_t* const)UINT32_C(0x40028200);                            /** @brief MDIO address register */
    static _RW uint32_t* const ETHERNET_MAC_MACMDIODR_REG = (_RW uint32_t* const)UINT32_C(0x40028204);                            /** @brief MDIO data register */
    static _RW uint32_t* const ETHERNET_MAC_MACARPAR_REG = (_RW uint32_t* const)UINT32_C(0x40028AE0);                             /** @brief ARP address register */
    static _RW uint32_t* const ETHERNET_MAC_MACA0HR_REG = (_RW uint32_t* const)UINT32_C(0x40028300);                              /** @brief Address 0 high register */
    static _RW uint32_t* const ETHERNET_MAC_MMC_CONTROL_REG = (_RW uint32_t* const)UINT32_C(0x40028700);                          /** @brief MMC control register */
    static _RO uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_REG = (_RO uint32_t* const)UINT32_C(0x40028704);                     /** @brief MMC rx interrupt register */
    static _RO uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_REG = (_RO uint32_t* const)UINT32_C(0x40028708);                     /** @brief MMC tx interrupt register */
    static _RW uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_REG = (_RW uint32_t* const)UINT32_C(0x4002870C);                /** @brief MMC rx interrupt mask register */
    static _RW uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_REG = (_RW uint32_t* const)UINT32_C(0x40028710);                /** @brief MMC tx interrupt mask register */
    static _RO uint32_t* const ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_REG = (_RO uint32_t* const)UINT32_C(0x4002874C);     /** @brief Tx single collision good packets register */
    static _RO uint32_t* const ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_REG = (_RO uint32_t* const)UINT32_C(0x40028750);   /** @brief Tx multiple collision good packets register */
    static _RO uint32_t* const ETHERNET_MAC_TX_PACKET_COUNT_GOOD_REG = (_RO uint32_t* const)UINT32_C(0x40028768);                 /** @brief Tx packet count good register */
    static _RO uint32_t* const ETHERNET_MAC_RX_CRC_ERROR_PACKETS_REG = (_RO uint32_t* const)UINT32_C(0x40028794);                 /** @brief Rx CRC error packets register */
    static _RO uint32_t* const ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_REG = (_RO uint32_t* const)UINT32_C(0x40028798);           /** @brief Rx alignment error packets register */
    static _RO uint32_t* const ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_REG = (_RO uint32_t* const)UINT32_C(0x400287C4);              /** @brief Rx unicast packets good register */
    static _RO uint32_t* const ETHERNET_MAC_TX_LPI_USEC_CNTR_REG = (_RO uint32_t* const)UINT32_C(0x400287EC);                     /** @brief Tx LPI microsecond timer register */
    static _RO uint32_t* const ETHERNET_MAC_TX_LPI_TRAN_CNTR_REG = (_RO uint32_t* const)UINT32_C(0x400287F0);                     /** @brief Tx LPI transition counter register */
    static _RO uint32_t* const ETHERNET_MAC_RX_LPI_USEC_CNTR_REG = (_RO uint32_t* const)UINT32_C(0x400287F4);                     /** @brief Rx LPI microsecond counter register */
    static _RO uint32_t* const ETHERNET_MAC_RX_LPI_TRAN_CNTR_REG = (_RO uint32_t* const)UINT32_C(0x400287F8);                     /** @brief Rx LPI transition counter register */
    static _RW uint32_t* const ETHERNET_MAC_MACL3L4C0R_REG = (_RW uint32_t* const)UINT32_C(0x40028900);                           /** @brief L3 and L4 control 0 register */
    static _RW uint32_t* const ETHERNET_MAC_MACL4A0R_REG = (_RW uint32_t* const)UINT32_C(0x40028904);                             /** @brief Layer4 address filter 0 register */
    static _RO uint32_t* const ETHERNET_MAC_MACDR_REG = (_RO uint32_t* const)UINT32_C(0x40028114);                                /** @brief Debug register */
    static _RW uint32_t* const ETHERNET_MAC_MACL3A20_REG = (_RW uint32_t* const)UINT32_C(0x40028918);                             /** @brief Layer3 address 2 filter 0 register */
    static _RW uint32_t* const ETHERNET_MAC_MACL3A30_REG = (_RW uint32_t* const)UINT32_C(0x4002891C);                             /** @brief Layer3 address 3 filter 0 register */
    static _RW uint32_t* const ETHERNET_MAC_MACL3L4C1R_REG = (_RW uint32_t* const)UINT32_C(0x40028930);                           /** @brief L3 and L4 control 1 register */
    static _RW uint32_t* const ETHERNET_MAC_MACL4A1R_REG = (_RW uint32_t* const)UINT32_C(0x40028934);                             /** @brief Layer 4 address filter 1 register */
    static _RW uint32_t* const ETHERNET_MAC_MACTSCR_REG = (_RW uint32_t* const)UINT32_C(0x40028B00);                              /** @brief Timestamp control register */
    static _RW uint32_t* const ETHERNET_MAC_MACSSIR_REG = (_RW uint32_t* const)UINT32_C(0x40028B04);                              /** @brief Sub-second increment register */
    static _RO uint32_t* const ETHERNET_MAC_MACSTSR_REG = (_RO uint32_t* const)UINT32_C(0x40028B08);                              /** @brief System time seconds register */
    static _RO uint32_t* const ETHERNET_MAC_MACSTNR_REG = (_RO uint32_t* const)UINT32_C(0x40028B0C);                              /** @brief System time nanoseconds register */
    static _RW uint32_t* const ETHERNET_MAC_MACSTSUR_REG = (_RW uint32_t* const)UINT32_C(0x40028B10);                             /** @brief System time seconds update register */
    static _RW uint32_t* const ETHERNET_MAC_MACSTNUR_REG = (_RW uint32_t* const)UINT32_C(0x40028B14);                             /** @brief System time nanoseconds update register */
    static _RW uint32_t* const ETHERNET_MAC_MACTSAR_REG = (_RW uint32_t* const)UINT32_C(0x40028B18);                              /** @brief Timestamp addend register */
    static _RO uint32_t* const ETHERNET_MAC_MACTSSR_REG = (_RO uint32_t* const)UINT32_C(0x40028B20);                              /** @brief Timestamp status register */
    static _RO uint32_t* const ETHERNET_MAC_MACTXTSSNR_REG = (_RO uint32_t* const)UINT32_C(0x40028B30);                           /** @brief Tx timestamp status nanoseconds register */
    static _RO uint32_t* const ETHERNET_MAC_MACTXTSSSR_REG = (_RO uint32_t* const)UINT32_C(0x40028B34);                           /** @brief Tx timestamp status seconds register */
    static _RW uint32_t* const ETHERNET_MAC_MACACR_REG = (_RW uint32_t* const)UINT32_C(0x40028B40);                               /** @brief Auxiliary control register */
    static _RO uint32_t* const ETHERNET_MAC_MACATSNR_REG = (_RO uint32_t* const)UINT32_C(0x40028B48);                             /** @brief Auxiliary timestamp nanoseconds register */
    static _RO uint32_t* const ETHERNET_MAC_MACATSSR_REG = (_RO uint32_t* const)UINT32_C(0x40028B4C);                             /** @brief Auxiliary timestamp seconds register */
    static _RW uint32_t* const ETHERNET_MAC_MACTSIACR_REG = (_RW uint32_t* const)UINT32_C(0x40028B50);                            /** @brief Timestamp ingress asymmetric correction register */
    static _RW uint32_t* const ETHERNET_MAC_MACTSEACR_REG = (_RW uint32_t* const)UINT32_C(0x40028B54);                            /** @brief Timestamp egress asymmetric correction register */
    static _RW uint32_t* const ETHERNET_MAC_MACTSICNR_REG = (_RW uint32_t* const)UINT32_C(0x40028B58);                            /** @brief Timestamp ingress correction nanosecond register */
    static _RW uint32_t* const ETHERNET_MAC_MACTSECNR_REG = (_RW uint32_t* const)UINT32_C(0x40028B5C);                            /** @brief Timestamp egress correction nanosecond register */
    static _RW uint32_t* const ETHERNET_MAC_MACPPSCR_REG = (_RW uint32_t* const)UINT32_C(0x40028B70);                             /** @brief PPS control register */
    static _RW uint32_t* const ETHERNET_MAC_MACPPSTTSR_REG = (_RW uint32_t* const)UINT32_C(0x40028B80);                           /** @brief PPS target time seconds register */
    static _RW uint32_t* const ETHERNET_MAC_MACPPSTTNR_REG = (_RW uint32_t* const)UINT32_C(0x40028B84);                           /** @brief PPS target time nanoseconds register */
    static _RW uint32_t* const ETHERNET_MAC_MACPPSIR_REG = (_RW uint32_t* const)UINT32_C(0x40028B88);                             /** @brief PPS interval register */
    static _RW uint32_t* const ETHERNET_MAC_MACPPSWR_REG = (_RW uint32_t* const)UINT32_C(0x40028B8C);                             /** @brief PPS width register */
    static _RW uint32_t* const ETHERNET_MAC_MACPOCR_REG = (_RW uint32_t* const)UINT32_C(0x40028BC0);                              /** @brief PTP offload control register */
    static _RW uint32_t* const ETHERNET_MAC_MACSPI0R_REG = (_RW uint32_t* const)UINT32_C(0x40028BC4);                             /** @brief PTP source port identity 0 register */
    static _RW uint32_t* const ETHERNET_MAC_MACSPI1R_REG = (_RW uint32_t* const)UINT32_C(0x40028BC8);                             /** @brief PTP source port identity 1 register */
    static _RW uint32_t* const ETHERNET_MAC_MACSPI2R_REG = (_RW uint32_t* const)UINT32_C(0x40028BCC);                             /** @brief PTP source port identity 2 register */
    static _RW uint32_t* const ETHERNET_MAC_MACLMIR_REG = (_RW uint32_t* const)UINT32_C(0x40028BD0);                              /** @brief Log message interval register */

    /** @subsection ETHERNET_MAC field mask array definitions */

    static const uint32_t ETHERNET_MAC_MACACR_ATSENX_MASK[4] = {
      UINT32_C(0x00000010),   /** @brief ATSEN0 */
      UINT32_C(0x00000020),   /** @brief ATSEN1 */
      UINT32_C(0x00000040),   /** @brief ATSEN2 */
      UINT32_C(0x00000080),   /** @brief ATSEN3 */
    };

    /** @subsection ETHERNET_MAC field mask definitions */

    static const uint32_t ETHERNET_MAC_DMAMR_SWR_MASK = UINT32_C(0x00000001);                           /** @brief Software reset */
    static const uint32_t ETHERNET_MAC_DMAMR_DA_MASK = UINT32_C(0x00000002);                            /** @brief DMA tx or rx arbitration scheme */
    static const uint32_t ETHERNET_MAC_DMAMR_TXPR_MASK = UINT32_C(0x00000800);                          /** @brief Transmit priority */
    static const uint32_t ETHERNET_MAC_DMAMR_PR_MASK = UINT32_C(0x00007000);                            /** @brief Priority ratio */
    static const uint32_t ETHERNET_MAC_DMAMR_INTM_MASK = UINT32_C(0x00010000);                          /** @brief Interrupt mode */
    static const uint32_t ETHERNET_MAC_DMASBMR_FB_MASK = UINT32_C(0x00000001);                          /** @brief Fixed burst length */
    static const uint32_t ETHERNET_MAC_DMASBMR_AAL_MASK = UINT32_C(0x00001000);                         /** @brief Address-Aligned beats */
    static const uint32_t ETHERNET_MAC_DMASBMR_MB_MASK = UINT32_C(0x00004000);                          /** @brief Mixed burst */
    static const uint32_t ETHERNET_MAC_DMASBMR_RB_MASK = UINT32_C(0x00008000);                          /** @brief Rebuild incrx burst */
    static const uint32_t ETHERNET_MAC_DMAISR_DC0IS_MASK = UINT32_C(0x00000001);                        /** @brief DMA channel interrupt status */
    static const uint32_t ETHERNET_MAC_DMAISR_MTLIS_MASK = UINT32_C(0x00010000);                        /** @brief MTL interrupt status */
    static const uint32_t ETHERNET_MAC_DMAISR_MACIS_MASK = UINT32_C(0x00020000);                        /** @brief MAC interrupt status */
    static const uint32_t ETHERNET_MAC_DMADSR_AXWHSTS_MASK = UINT32_C(0x00000001);                      /** @brief AHB master write channel */
    static const uint32_t ETHERNET_MAC_DMADSR_RPS0_MASK = UINT32_C(0x00000F00);                         /** @brief DMA channel receive process state */
    static const uint32_t ETHERNET_MAC_DMADSR_TPS0_MASK = UINT32_C(0x0000F000);                         /** @brief DMA channel transmit process state */
    static const uint32_t ETHERNET_MAC_DMACCR_MSS_MASK = UINT32_C(0x00003FFF);                          /** @brief Maximum segment size */
    static const uint32_t ETHERNET_MAC_DMACCR_PBLX8_MASK = UINT32_C(0x00010000);                        /** @brief 8xPBL mode */
    static const uint32_t ETHERNET_MAC_DMACCR_DSL_MASK = UINT32_C(0x001C0000);                          /** @brief Descriptor skip length */
    static const uint32_t ETHERNET_MAC_DMACTXCR_ST_MASK = UINT32_C(0x00000001);                         /** @brief Start or stop transmission command */
    static const uint32_t ETHERNET_MAC_DMACTXCR_OSF_MASK = UINT32_C(0x00000010);                        /** @brief Operate on second packet */
    static const uint32_t ETHERNET_MAC_DMACTXCR_TSE_MASK = UINT32_C(0x00001000);                        /** @brief TCP segmentation enabled */
    static const uint32_t ETHERNET_MAC_DMACTXCR_TXPBL_MASK = UINT32_C(0x003F0000);                      /** @brief Transmit programmable burst length */
    static const uint32_t ETHERNET_MAC_DMACRXCR_SR_MASK = UINT32_C(0x00000001);                         /** @brief Start or stop receive command */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RBSZ_MASK = UINT32_C(0x00007FFE);                       /** @brief Receive buffer size */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RXPBL_MASK = UINT32_C(0x003F0000);                      /** @brief RXPBL */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RPF_MASK = UINT32_C(0x80000000);                        /** @brief DMA rx channel packet flush */
    static const uint32_t ETHERNET_MAC_DMACTXDLAR_TDESLA_MASK = UINT32_C(0xFFFFFFFC);                   /** @brief Start of transmit list */
    static const uint32_t ETHERNET_MAC_DMACRXDLAR_RDESLA_MASK = UINT32_C(0xFFFFFFFC);                   /** @brief Start of receive list */
    static const uint32_t ETHERNET_MAC_DMACTXDTPR_TDT_MASK = UINT32_C(0xFFFFFFFC);                      /** @brief Transmit descriptor tail pointer */
    static const uint32_t ETHERNET_MAC_DMACRXDTPR_RDT_MASK = UINT32_C(0xFFFFFFFC);                      /** @brief Receive descriptor tail pointer */
    static const uint32_t ETHERNET_MAC_DMACTXRLR_TDRL_MASK = UINT32_C(0x000003FF);                      /** @brief Transmit descriptor ring length */
    static const uint32_t ETHERNET_MAC_DMACRXRLR_RDRL_MASK = UINT32_C(0x000003FF);                      /** @brief Receive descriptor ring length */
    static const uint32_t ETHERNET_MAC_DMACIER_TIE_MASK = UINT32_C(0x00000001);                         /** @brief Transmit interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_TXSE_MASK = UINT32_C(0x00000002);                        /** @brief Transmit stopped enable */
    static const uint32_t ETHERNET_MAC_DMACIER_TBUE_MASK = UINT32_C(0x00000004);                        /** @brief Transmit buffer unavailable enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RIE_MASK = UINT32_C(0x00000040);                         /** @brief Receive interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RBUE_MASK = UINT32_C(0x00000080);                        /** @brief Receive buffer unavailable enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RSE_MASK = UINT32_C(0x00000100);                         /** @brief Receive stopped enable */
    static const uint32_t ETHERNET_MAC_DMACIER_RWTE_MASK = UINT32_C(0x00000200);                        /** @brief Receive watchdog timeout enable */
    static const uint32_t ETHERNET_MAC_DMACIER_ETIE_MASK = UINT32_C(0x00000400);                        /** @brief Early transmit interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_ERIE_MASK = UINT32_C(0x00000800);                        /** @brief Early receive interrupt enable */
    static const uint32_t ETHERNET_MAC_DMACIER_FBEE_MASK = UINT32_C(0x00001000);                        /** @brief Fatal bus error enable */
    static const uint32_t ETHERNET_MAC_DMACIER_CDEE_MASK = UINT32_C(0x00002000);                        /** @brief Context descriptor error enable */
    static const uint32_t ETHERNET_MAC_DMACIER_AIE_MASK = UINT32_C(0x00004000);                         /** @brief Abnormal interrupt summary enable */
    static const uint32_t ETHERNET_MAC_DMACIER_NIE_MASK = UINT32_C(0x00008000);                         /** @brief Normal interrupt summary enable */
    static const uint32_t ETHERNET_MAC_DMACRXIWTR_RWT_MASK = UINT32_C(0x000000FF);                      /** @brief Receive interrupt watchdog timer count */
    static const uint32_t ETHERNET_MAC_DMACSR_TI_MASK = UINT32_C(0x00000001);                           /** @brief Transmit interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_TPS_MASK = UINT32_C(0x00000002);                          /** @brief Transmit process stopped */
    static const uint32_t ETHERNET_MAC_DMACSR_TBU_MASK = UINT32_C(0x00000004);                          /** @brief Transmit buffer unavailable */
    static const uint32_t ETHERNET_MAC_DMACSR_RI_MASK = UINT32_C(0x00000040);                           /** @brief Receive interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_RBU_MASK = UINT32_C(0x00000080);                          /** @brief Receive buffer unavailable */
    static const uint32_t ETHERNET_MAC_DMACSR_RPS_MASK = UINT32_C(0x00000100);                          /** @brief Receive process stopped */
    static const uint32_t ETHERNET_MAC_DMACSR_RWT_MASK = UINT32_C(0x00000200);                          /** @brief Receive watchdog timeout */
    static const uint32_t ETHERNET_MAC_DMACSR_ET_MASK = UINT32_C(0x00000400);                           /** @brief Early transmit interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_ER_MASK = UINT32_C(0x00000800);                           /** @brief Early receive interrupt */
    static const uint32_t ETHERNET_MAC_DMACSR_FBE_MASK = UINT32_C(0x00001000);                          /** @brief Fatal bus error */
    static const uint32_t ETHERNET_MAC_DMACSR_CDE_MASK = UINT32_C(0x00002000);                          /** @brief Context descriptor error */
    static const uint32_t ETHERNET_MAC_DMACSR_AIS_MASK = UINT32_C(0x00004000);                          /** @brief Abnormal interrupt summary */
    static const uint32_t ETHERNET_MAC_DMACSR_NIS_MASK = UINT32_C(0x00008000);                          /** @brief Normal interrupt summary */
    static const uint32_t ETHERNET_MAC_DMACSR_TEB_MASK = UINT32_C(0x00070000);                          /** @brief Tx DMA error bits */
    static const uint32_t ETHERNET_MAC_DMACSR_REB_MASK = UINT32_C(0x00380000);                          /** @brief Rx DMA error bits */
    static const uint32_t ETHERNET_MAC_DMACMFCR_MFC_MASK = UINT32_C(0x000007FF);                        /** @brief Dropped packet counters */
    static const uint32_t ETHERNET_MAC_DMACMFCR_MFCO_MASK = UINT32_C(0x00008000);                       /** @brief Overflow status of the MFC counter */
    static const uint32_t ETHERNET_MAC_MTLOMR_DTXSTS_MASK = UINT32_C(0x00000002);                       /** @brief DTXSTS */
    static const uint32_t ETHERNET_MAC_MTLOMR_CNTPRST_MASK = UINT32_C(0x00000100);                      /** @brief CNTPRST */
    static const uint32_t ETHERNET_MAC_MTLOMR_CNTCLR_MASK = UINT32_C(0x00000200);                       /** @brief CNTCLR */
    static const uint32_t ETHERNET_MAC_MTLISR_Q0IS_MASK = UINT32_C(0x00000001);                         /** @brief Queue interrupt status */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_FTQ_MASK = UINT32_C(0x00000001);                       /** @brief Flush transmit queue */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TSF_MASK = UINT32_C(0x00000002);                       /** @brief Transmit store and forward */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TXQEN_MASK = UINT32_C(0x0000000C);                     /** @brief Transmit queue enable */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TTC_MASK = UINT32_C(0x00000070);                       /** @brief Transmit threshold control */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TQS_MASK = UINT32_C(0x01FF0000);                       /** @brief Transmit queue size */
    static const uint32_t ETHERNET_MAC_MTLTXQUR_UFFRMCNT_MASK = UINT32_C(0x000007FF);                   /** @brief Underflow packet counter */
    static const uint32_t ETHERNET_MAC_MTLTXQUR_UFCNTOVF_MASK = UINT32_C(0x00000800);                   /** @brief UFCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TXQPAUSED_MASK = UINT32_C(0x00000001);                  /** @brief TXQPAUSED */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TRCSTS_MASK = UINT32_C(0x00000006);                     /** @brief TRCSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TWCSTS_MASK = UINT32_C(0x00000008);                     /** @brief TWCSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TXQSTS_MASK = UINT32_C(0x00000010);                     /** @brief TXQSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_TXSTSFSTS_MASK = UINT32_C(0x00000020);                  /** @brief TXSTSFSTS */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_PTXQ_MASK = UINT32_C(0x00070000);                       /** @brief PTXQ */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_STXSTSF_MASK = UINT32_C(0x00700000);                    /** @brief STXSTSF */
    static const uint32_t ETHERNET_MAC_MTLQICSR_TXUNFIS_MASK = UINT32_C(0x00000001);                    /** @brief TXUNFIS */
    static const uint32_t ETHERNET_MAC_MTLQICSR_TXUIE_MASK = UINT32_C(0x00000100);                      /** @brief TXUIE */
    static const uint32_t ETHERNET_MAC_MTLQICSR_RXOVFIS_MASK = UINT32_C(0x00010000);                    /** @brief RXOVFIS */
    static const uint32_t ETHERNET_MAC_MTLQICSR_RXOIE_MASK = UINT32_C(0x01000000);                      /** @brief RXOIE */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RTC_MASK = UINT32_C(0x00000003);                       /** @brief RTC */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_FUP_MASK = UINT32_C(0x00000008);                       /** @brief FUP */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_FEP_MASK = UINT32_C(0x00000010);                       /** @brief FEP */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RSF_MASK = UINT32_C(0x00000020);                       /** @brief RSF */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_DIS_TCP_EF_MASK = UINT32_C(0x00000040);                /** @brief DIS_TCP_EF */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_EHFC_MASK = UINT32_C(0x00000080);                      /** @brief EHFC */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RFA_MASK = UINT32_C(0x00000700);                       /** @brief RFA */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RFD_MASK = UINT32_C(0x0001C000);                       /** @brief RFD */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RQS_MASK = UINT32_C(0x00700000);                       /** @brief RQS */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT_MASK = UINT32_C(0x000007FF);               /** @brief OVFPKTCNT */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_OVFCNTOVF_MASK = UINT32_C(0x00000800);               /** @brief OVFCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT_MASK = UINT32_C(0x07FF0000);               /** @brief MISPKTCNT */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF_MASK = UINT32_C(0x08000000);               /** @brief MISCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RWCSTS_MASK = UINT32_C(0x00000001);                     /** @brief RWCSTS */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RRCSTS_MASK = UINT32_C(0x00000006);                     /** @brief RRCSTS */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RXQSTS_MASK = UINT32_C(0x00000030);                     /** @brief RXQSTS */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_PRXQ_MASK = UINT32_C(0x3FFF0000);                       /** @brief PRXQ */
    static const uint32_t ETHERNET_MAC_MACCR_RE_MASK = UINT32_C(0x00000001);                            /** @brief Receiver enable */
    static const uint32_t ETHERNET_MAC_MACCR_TE_MASK = UINT32_C(0x00000002);                            /** @brief TE */
    static const uint32_t ETHERNET_MAC_MACCR_PRELEN_MASK = UINT32_C(0x0000000C);                        /** @brief PRELEN */
    static const uint32_t ETHERNET_MAC_MACCR_DC_MASK = UINT32_C(0x00000010);                            /** @brief DC */
    static const uint32_t ETHERNET_MAC_MACCR_BL_MASK = UINT32_C(0x00000060);                            /** @brief BL */
    static const uint32_t ETHERNET_MAC_MACCR_DR_MASK = UINT32_C(0x00000100);                            /** @brief DR */
    static const uint32_t ETHERNET_MAC_MACCR_DCRS_MASK = UINT32_C(0x00000200);                          /** @brief DCRS */
    static const uint32_t ETHERNET_MAC_MACCR_DO_MASK = UINT32_C(0x00000400);                            /** @brief DO */
    static const uint32_t ETHERNET_MAC_MACCR_ECRSFD_MASK = UINT32_C(0x00000800);                        /** @brief ECRSFD */
    static const uint32_t ETHERNET_MAC_MACCR_LM_MASK = UINT32_C(0x00001000);                            /** @brief LM */
    static const uint32_t ETHERNET_MAC_MACCR_DM_MASK = UINT32_C(0x00002000);                            /** @brief DM */
    static const uint32_t ETHERNET_MAC_MACCR_FES_MASK = UINT32_C(0x00004000);                           /** @brief FES */
    static const uint32_t ETHERNET_MAC_MACCR_JE_MASK = UINT32_C(0x00010000);                            /** @brief JE */
    static const uint32_t ETHERNET_MAC_MACCR_JD_MASK = UINT32_C(0x00020000);                            /** @brief JD */
    static const uint32_t ETHERNET_MAC_MACCR_WD_MASK = UINT32_C(0x00080000);                            /** @brief WD */
    static const uint32_t ETHERNET_MAC_MACCR_ACS_MASK = UINT32_C(0x00100000);                           /** @brief ACS */
    static const uint32_t ETHERNET_MAC_MACCR_CST_MASK = UINT32_C(0x00200000);                           /** @brief CST */
    static const uint32_t ETHERNET_MAC_MACCR_S2KP_MASK = UINT32_C(0x00400000);                          /** @brief S2KP */
    static const uint32_t ETHERNET_MAC_MACCR_GPSLCE_MASK = UINT32_C(0x00800000);                        /** @brief GPSLCE */
    static const uint32_t ETHERNET_MAC_MACCR_IPG_MASK = UINT32_C(0x07000000);                           /** @brief IPG */
    static const uint32_t ETHERNET_MAC_MACCR_IPC_MASK = UINT32_C(0x08000000);                           /** @brief IPC */
    static const uint32_t ETHERNET_MAC_MACCR_SARC_MASK = UINT32_C(0x70000000);                          /** @brief SARC */
    static const uint32_t ETHERNET_MAC_MACCR_ARPEN_MASK = UINT32_C(0x80000000);                         /** @brief ARPEN */
    static const uint32_t ETHERNET_MAC_MACECR_GPSL_MASK = UINT32_C(0x00003FFF);                         /** @brief GPSL */
    static const uint32_t ETHERNET_MAC_MACECR_DCRCC_MASK = UINT32_C(0x00010000);                        /** @brief DCRCC */
    static const uint32_t ETHERNET_MAC_MACECR_SPEN_MASK = UINT32_C(0x00020000);                         /** @brief SPEN */
    static const uint32_t ETHERNET_MAC_MACECR_USP_MASK = UINT32_C(0x00040000);                          /** @brief USP */
    static const uint32_t ETHERNET_MAC_MACECR_EIPGEN_MASK = UINT32_C(0x01000000);                       /** @brief EIPGEN */
    static const uint32_t ETHERNET_MAC_MACECR_EIPG_MASK = UINT32_C(0x3E000000);                         /** @brief EIPG */
    static const uint32_t ETHERNET_MAC_MACPFR_PR_MASK = UINT32_C(0x00000001);                           /** @brief PR */
    static const uint32_t ETHERNET_MAC_MACPFR_HUC_MASK = UINT32_C(0x00000002);                          /** @brief HUC */
    static const uint32_t ETHERNET_MAC_MACPFR_HMC_MASK = UINT32_C(0x00000004);                          /** @brief HMC */
    static const uint32_t ETHERNET_MAC_MACPFR_DAIF_MASK = UINT32_C(0x00000008);                         /** @brief DAIF */
    static const uint32_t ETHERNET_MAC_MACPFR_PM_MASK = UINT32_C(0x00000010);                           /** @brief PM */
    static const uint32_t ETHERNET_MAC_MACPFR_DBF_MASK = UINT32_C(0x00000020);                          /** @brief DBF */
    static const uint32_t ETHERNET_MAC_MACPFR_PCF_MASK = UINT32_C(0x000000C0);                          /** @brief PCF */
    static const uint32_t ETHERNET_MAC_MACPFR_SAIF_MASK = UINT32_C(0x00000100);                         /** @brief SAIF */
    static const uint32_t ETHERNET_MAC_MACPFR_SAF_MASK = UINT32_C(0x00000200);                          /** @brief SAF */
    static const uint32_t ETHERNET_MAC_MACPFR_HPF_MASK = UINT32_C(0x00000400);                          /** @brief HPF */
    static const uint32_t ETHERNET_MAC_MACPFR_VTFE_MASK = UINT32_C(0x00010000);                         /** @brief VTFE */
    static const uint32_t ETHERNET_MAC_MACPFR_IPFE_MASK = UINT32_C(0x00100000);                         /** @brief IPFE */
    static const uint32_t ETHERNET_MAC_MACPFR_DNTU_MASK = UINT32_C(0x00200000);                         /** @brief DNTU */
    static const uint32_t ETHERNET_MAC_MACPFR_RA_MASK = UINT32_C(0x80000000);                           /** @brief RA */
    static const uint32_t ETHERNET_MAC_MACWTR_WTO_MASK = UINT32_C(0x0000000F);                          /** @brief WTO */
    static const uint32_t ETHERNET_MAC_MACWTR_PWE_MASK = UINT32_C(0x00000100);                          /** @brief PWE */
    static const uint32_t ETHERNET_MAC_MACVTR_VL_MASK = UINT32_C(0x0000FFFF);                           /** @brief VL */
    static const uint32_t ETHERNET_MAC_MACVTR_ETV_MASK = UINT32_C(0x00010000);                          /** @brief ETV */
    static const uint32_t ETHERNET_MAC_MACVTR_VTIM_MASK = UINT32_C(0x00020000);                         /** @brief VTIM */
    static const uint32_t ETHERNET_MAC_MACVTR_ESVL_MASK = UINT32_C(0x00040000);                         /** @brief ESVL */
    static const uint32_t ETHERNET_MAC_MACVTR_ERSVLM_MASK = UINT32_C(0x00080000);                       /** @brief ERSVLM */
    static const uint32_t ETHERNET_MAC_MACVTR_DOVLTC_MASK = UINT32_C(0x00100000);                       /** @brief DOVLTC */
    static const uint32_t ETHERNET_MAC_MACVTR_EVLS_MASK = UINT32_C(0x00600000);                         /** @brief EVLS */
    static const uint32_t ETHERNET_MAC_MACVTR_EVLRXS_MASK = UINT32_C(0x01000000);                       /** @brief EVLRXS */
    static const uint32_t ETHERNET_MAC_MACVTR_VTHM_MASK = UINT32_C(0x02000000);                         /** @brief VTHM */
    static const uint32_t ETHERNET_MAC_MACVTR_EDVLP_MASK = UINT32_C(0x04000000);                        /** @brief EDVLP */
    static const uint32_t ETHERNET_MAC_MACVTR_ERIVLT_MASK = UINT32_C(0x08000000);                       /** @brief ERIVLT */
    static const uint32_t ETHERNET_MAC_MACVTR_EIVLS_MASK = UINT32_C(0x30000000);                        /** @brief EIVLS */
    static const uint32_t ETHERNET_MAC_MACVTR_EIVLRXS_MASK = UINT32_C(0x80000000);                      /** @brief EIVLRXS */
    static const uint32_t ETHERNET_MAC_MACVHTR_VLHT_MASK = UINT32_C(0x0000FFFF);                        /** @brief VLHT */
    static const uint32_t ETHERNET_MAC_MACVIR_VLT_MASK = UINT32_C(0x0000FFFF);                          /** @brief VLT */
    static const uint32_t ETHERNET_MAC_MACVIR_VLC_MASK = UINT32_C(0x00030000);                          /** @brief VLC */
    static const uint32_t ETHERNET_MAC_MACVIR_VLP_MASK = UINT32_C(0x00040000);                          /** @brief VLP */
    static const uint32_t ETHERNET_MAC_MACVIR_CSVL_MASK = UINT32_C(0x00080000);                         /** @brief CSVL */
    static const uint32_t ETHERNET_MAC_MACVIR_VLTI_MASK = UINT32_C(0x00100000);                         /** @brief VLTI */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLT_MASK = UINT32_C(0x0000FFFF);                         /** @brief VLT */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLC_MASK = UINT32_C(0x00030000);                         /** @brief VLC */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLP_MASK = UINT32_C(0x00040000);                         /** @brief VLP */
    static const uint32_t ETHERNET_MAC_MACIVIR_CSVL_MASK = UINT32_C(0x00080000);                        /** @brief CSVL */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLTI_MASK = UINT32_C(0x00100000);                        /** @brief VLTI */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_FCB_BPA_MASK = UINT32_C(0x00000001);                   /** @brief FCB_BPA */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_TFE_MASK = UINT32_C(0x00000002);                       /** @brief TFE */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_PLT_MASK = UINT32_C(0x00000070);                       /** @brief PLT */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_DZPQ_MASK = UINT32_C(0x00000080);                      /** @brief DZPQ */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_PT_MASK = UINT32_C(0xFFFF0000);                        /** @brief PT */
    static const uint32_t ETHERNET_MAC_MACRXFCR_RFE_MASK = UINT32_C(0x00000001);                        /** @brief RFE */
    static const uint32_t ETHERNET_MAC_MACRXFCR_UP_MASK = UINT32_C(0x00000002);                         /** @brief UP */
    static const uint32_t ETHERNET_MAC_MACISR_PHYIS_MASK = UINT32_C(0x00000008);                        /** @brief PHYIS */
    static const uint32_t ETHERNET_MAC_MACISR_PMTIS_MASK = UINT32_C(0x00000010);                        /** @brief PMTIS */
    static const uint32_t ETHERNET_MAC_MACISR_LPIIS_MASK = UINT32_C(0x00000020);                        /** @brief LPIIS */
    static const uint32_t ETHERNET_MAC_MACISR_MMCIS_MASK = UINT32_C(0x00000100);                        /** @brief MMCIS */
    static const uint32_t ETHERNET_MAC_MACISR_MMCRXIS_MASK = UINT32_C(0x00000200);                      /** @brief MMCRXIS */
    static const uint32_t ETHERNET_MAC_MACISR_MMCTXIS_MASK = UINT32_C(0x00000400);                      /** @brief MMCTXIS */
    static const uint32_t ETHERNET_MAC_MACISR_TSIS_MASK = UINT32_C(0x00001000);                         /** @brief TSIS */
    static const uint32_t ETHERNET_MAC_MACISR_TXSTSIS_MASK = UINT32_C(0x00002000);                      /** @brief TXSTSIS */
    static const uint32_t ETHERNET_MAC_MACISR_RXSTSIS_MASK = UINT32_C(0x00004000);                      /** @brief RXSTSIS */
    static const uint32_t ETHERNET_MAC_MACIER_PHYIE_MASK = UINT32_C(0x00000008);                        /** @brief PHYIE */
    static const uint32_t ETHERNET_MAC_MACIER_PMTIE_MASK = UINT32_C(0x00000010);                        /** @brief PMTIE */
    static const uint32_t ETHERNET_MAC_MACIER_LPIIE_MASK = UINT32_C(0x00000020);                        /** @brief LPIIE */
    static const uint32_t ETHERNET_MAC_MACIER_TSIE_MASK = UINT32_C(0x00001000);                         /** @brief TSIE */
    static const uint32_t ETHERNET_MAC_MACIER_TXSTSIE_MASK = UINT32_C(0x00002000);                      /** @brief TXSTSIE */
    static const uint32_t ETHERNET_MAC_MACIER_RXSTSIE_MASK = UINT32_C(0x00004000);                      /** @brief RXSTSIE */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_TJT_MASK = UINT32_C(0x00000001);                       /** @brief TJT */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_NCARR_MASK = UINT32_C(0x00000002);                     /** @brief NCARR */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_LCARR_MASK = UINT32_C(0x00000004);                     /** @brief LCARR */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_EXDEF_MASK = UINT32_C(0x00000008);                     /** @brief EXDEF */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_LCOL_MASK = UINT32_C(0x00000010);                      /** @brief LCOL */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_EXCOL_MASK = UINT32_C(0x00000020);                     /** @brief LCOL */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_RWT_MASK = UINT32_C(0x00000100);                       /** @brief RWT */
    static const uint32_t ETHERNET_MAC_MACPCSR_PWRDWN_MASK = UINT32_C(0x00000001);                      /** @brief PWRDWN */
    static const uint32_t ETHERNET_MAC_MACPCSR_MGKPKTEN_MASK = UINT32_C(0x00000002);                    /** @brief MGKPKTEN */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPKTEN_MASK = UINT32_C(0x00000004);                    /** @brief RWKPKTEN */
    static const uint32_t ETHERNET_MAC_MACPCSR_MGKPRCVD_MASK = UINT32_C(0x00000020);                    /** @brief MGKPRCVD */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPRCVD_MASK = UINT32_C(0x00000040);                    /** @brief RWKPRCVD */
    static const uint32_t ETHERNET_MAC_MACPCSR_GLBLUCAST_MASK = UINT32_C(0x00000200);                   /** @brief GLBLUCAST */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPFE_MASK = UINT32_C(0x00000400);                      /** @brief RWKPFE */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKPTR_MASK = UINT32_C(0x1F000000);                      /** @brief RWKPTR */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKFILTRST_MASK = UINT32_C(0x80000000);                  /** @brief RWKFILTRST */
    static const uint32_t ETHERNET_MAC_MACLCSR_TLPIEN_MASK = UINT32_C(0x00000001);                      /** @brief TLPIEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_TLPIEX_MASK = UINT32_C(0x00000002);                      /** @brief TLPIEX */
    static const uint32_t ETHERNET_MAC_MACLCSR_RLPIEN_MASK = UINT32_C(0x00000004);                      /** @brief RLPIEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_RLPIEX_MASK = UINT32_C(0x00000008);                      /** @brief RLPIEX */
    static const uint32_t ETHERNET_MAC_MACLCSR_TLPIST_MASK = UINT32_C(0x00000100);                      /** @brief TLPIST */
    static const uint32_t ETHERNET_MAC_MACLCSR_RLPIST_MASK = UINT32_C(0x00000200);                      /** @brief RLPIST */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPIEN_MASK = UINT32_C(0x00010000);                       /** @brief LPIEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_PLS_MASK = UINT32_C(0x00020000);                         /** @brief PLS */
    static const uint32_t ETHERNET_MAC_MACLCSR_PLSEN_MASK = UINT32_C(0x00040000);                       /** @brief PLSEN */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPITXA_MASK = UINT32_C(0x00080000);                      /** @brief LPITXA */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPITE_MASK = UINT32_C(0x00100000);                       /** @brief LPITE */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPITCSE_MASK = UINT32_C(0x00200000);                     /** @brief LPITCSE */
    static const uint32_t ETHERNET_MAC_MACLTCR_TWT_MASK = UINT32_C(0x0000FFFF);                         /** @brief TWT */
    static const uint32_t ETHERNET_MAC_MACLTCR_LST_MASK = UINT32_C(0x03FF0000);                         /** @brief LST */
    static const uint32_t ETHERNET_MAC_MACLETR_LPIET_MASK = UINT32_C(0x0001FFFF);                       /** @brief LPIET */
    static const uint32_t ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR_MASK = UINT32_C(0x00000FFF);              /** @brief TIC_1US_CNTR */
    static const uint32_t ETHERNET_MAC_MACVR_SNPSVER_MASK = UINT32_C(0x000000FF);                       /** @brief SNPSVER */
    static const uint32_t ETHERNET_MAC_MACVR_USERVER_MASK = UINT32_C(0x0000FF00);                       /** @brief USERVER */
    static const uint32_t ETHERNET_MAC_MACHWF1R_RXFIFOSIZE_MASK = UINT32_C(0x0000001F);                 /** @brief RXFIFOSIZE */
    static const uint32_t ETHERNET_MAC_MACHWF1R_TXFIFOSIZE_MASK = UINT32_C(0x000007C0);                 /** @brief TXFIFOSIZE */
    static const uint32_t ETHERNET_MAC_MACHWF1R_OSTEN_MASK = UINT32_C(0x00000800);                      /** @brief OSTEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_PTOEN_MASK = UINT32_C(0x00001000);                      /** @brief PTOEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_ADVTHWORD_MASK = UINT32_C(0x00002000);                  /** @brief ADVTHWORD */
    static const uint32_t ETHERNET_MAC_MACHWF1R_DCBEN_MASK = UINT32_C(0x00010000);                      /** @brief DCBEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_SPHEN_MASK = UINT32_C(0x00020000);                      /** @brief SPHEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_TSOEN_MASK = UINT32_C(0x00040000);                      /** @brief TSOEN */
    static const uint32_t ETHERNET_MAC_MACHWF1R_DBGMEMA_MASK = UINT32_C(0x00080000);                    /** @brief DBGMEMA */
    static const uint32_t ETHERNET_MAC_MACHWF1R_AVSEL_MASK = UINT32_C(0x00100000);                      /** @brief AVSEL */
    static const uint32_t ETHERNET_MAC_MACHWF1R_HASHTBLSZ_MASK = UINT32_C(0x03000000);                  /** @brief HASHTBLSZ */
    static const uint32_t ETHERNET_MAC_MACHWF1R_L3L4FNUM_MASK = UINT32_C(0x78000000);                   /** @brief L3L4FNUM */
    static const uint32_t ETHERNET_MAC_MACHWF2R_RXQCNT_MASK = UINT32_C(0x0000000F);                     /** @brief RXQCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_TXQCNT_MASK = UINT32_C(0x000003C0);                     /** @brief TXQCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_RXCHCNT_MASK = UINT32_C(0x0000F000);                    /** @brief RXCHCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_TXCHCNT_MASK = UINT32_C(0x003C0000);                    /** @brief TXCHCNT */
    static const uint32_t ETHERNET_MAC_MACHWF2R_PPSOUTNUM_MASK = UINT32_C(0x07000000);                  /** @brief PPSOUTNUM */
    static const uint32_t ETHERNET_MAC_MACHWF2R_AUXSNAPNUM_MASK = UINT32_C(0x70000000);                 /** @brief AUXSNAPNUM */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_MB_MASK = UINT32_C(0x00000001);                        /** @brief MB */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_C45E_MASK = UINT32_C(0x00000002);                      /** @brief C45E */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_GOC_MASK = UINT32_C(0x0000000C);                       /** @brief GOC */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_SKAP_MASK = UINT32_C(0x00000010);                      /** @brief SKAP */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_CR_MASK = UINT32_C(0x00000F00);                        /** @brief CR */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_NTC_MASK = UINT32_C(0x00007000);                       /** @brief NTC */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_RDA_MASK = UINT32_C(0x001F0000);                       /** @brief RDA */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_PA_MASK = UINT32_C(0x03E00000);                        /** @brief PA */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_BTB_MASK = UINT32_C(0x04000000);                       /** @brief BTB */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_PSE_MASK = UINT32_C(0x08000000);                       /** @brief PSE */
    static const uint32_t ETHERNET_MAC_MACMDIODR_MD_MASK = UINT32_C(0x0000FFFF);                        /** @brief MD */
    static const uint32_t ETHERNET_MAC_MACMDIODR_RA_MASK = UINT32_C(0xFFFF0000);                        /** @brief RA */
    static const uint32_t ETHERNET_MAC_MACA0HR_ADDRHI_MASK = UINT32_C(0x0000FFFF);                      /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACA0HR_AE_MASK = UINT32_C(0x80000000);                          /** @brief AE */
    static const uint32_t ETHERNET_MAC_MACAXHR_ADDRHI_MASK = UINT32_C(0x0000FFFF);                      /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACAXHR_MBC_MASK = UINT32_C(0x3F000000);                         /** @brief MBC */
    static const uint32_t ETHERNET_MAC_MACAXHR_SA_MASK = UINT32_C(0x40000000);                          /** @brief SA */
    static const uint32_t ETHERNET_MAC_MACAXHR_AE_MASK = UINT32_C(0x80000000);                          /** @brief AE */
    static const uint32_t ETHERNET_MAC_MACAXHR_ADDRHI_MASK = UINT32_C(0x0000FFFF);                      /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACAXHR_MBC_MASK = UINT32_C(0x3F000000);                         /** @brief MBC */
    static const uint32_t ETHERNET_MAC_MACAXHR_SA_MASK = UINT32_C(0x40000000);                          /** @brief SA */
    static const uint32_t ETHERNET_MAC_MACAXHR_AE_MASK = UINT32_C(0x80000000);                          /** @brief AE */
    static const uint32_t ETHERNET_MAC_MACAXHR_ADDRHI_MASK = UINT32_C(0x0000FFFF);                      /** @brief ADDRHI */
    static const uint32_t ETHERNET_MAC_MACAXHR_MBC_MASK = UINT32_C(0x3F000000);                         /** @brief MBC */
    static const uint32_t ETHERNET_MAC_MACAXHR_SA_MASK = UINT32_C(0x40000000);                          /** @brief SA */
    static const uint32_t ETHERNET_MAC_MACAXHR_AE_MASK = UINT32_C(0x80000000);                          /** @brief AE */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTRST_MASK = UINT32_C(0x00000001);                  /** @brief CNTRST */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTSTOPRO_MASK = UINT32_C(0x00000002);               /** @brief CNTSTOPRO */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_RSTONRD_MASK = UINT32_C(0x00000004);                 /** @brief RSTONRD */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTFREEZ_MASK = UINT32_C(0x00000008);                /** @brief CNTFREEZ */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTPRST_MASK = UINT32_C(0x00000010);                 /** @brief CNTPRST */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTPRSTLVL_MASK = UINT32_C(0x00000020);              /** @brief CNTPRSTLVL */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_UCDBC_MASK = UINT32_C(0x00000100);                   /** @brief UCDBC */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXCRCERPIS_MASK = UINT32_C(0x00000020);         /** @brief RXCRCERPIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXALGNERPIS_MASK = UINT32_C(0x00000040);        /** @brief RXALGNERPIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXUCGPIS_MASK = UINT32_C(0x00020000);           /** @brief RXUCGPIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS_MASK = UINT32_C(0x04000000);         /** @brief RXLPIUSCIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS_MASK = UINT32_C(0x08000000);         /** @brief RXLPITRCIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS_MASK = UINT32_C(0x00004000);         /** @brief TXSCOLGPIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS_MASK = UINT32_C(0x00008000);         /** @brief TXMCOLGPIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXGPKTIS_MASK = UINT32_C(0x00200000);           /** @brief TXGPKTIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS_MASK = UINT32_C(0x04000000);         /** @brief TXLPIUSCIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS_MASK = UINT32_C(0x08000000);         /** @brief TXLPITRCIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM_MASK = UINT32_C(0x00000020);    /** @brief RXCRCERPIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM_MASK = UINT32_C(0x00000040);   /** @brief RXALGNERPIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM_MASK = UINT32_C(0x00020000);      /** @brief RXUCGPIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM_MASK = UINT32_C(0x04000000);    /** @brief RXLPIUSCIM */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_MASK = UINT32_C(0x08000000);    /** @brief RXLPITRCIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM_MASK = UINT32_C(0x00004000);    /** @brief TXSCOLGPIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM_MASK = UINT32_C(0x00008000);    /** @brief TXMCOLGPIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM_MASK = UINT32_C(0x00200000);      /** @brief TXGPKTIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM_MASK = UINT32_C(0x04000000);    /** @brief TXLPIUSCIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_MASK = UINT32_C(0x08000000);    /** @brief TXLPITRCIM */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L3PEN0_MASK = UINT32_C(0x00000001);                   /** @brief L3PEN0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L3SAM0_MASK = UINT32_C(0x00000004);                   /** @brief L3SAM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L3SAIM0_MASK = UINT32_C(0x00000008);                  /** @brief L3SAIM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L3DAM0_MASK = UINT32_C(0x00000010);                   /** @brief L3DAM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L3DAIM0_MASK = UINT32_C(0x00000020);                  /** @brief L3DAIM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L3HSBM0_MASK = UINT32_C(0x000007C0);                  /** @brief L3HSBM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L3HDBM0_MASK = UINT32_C(0x0000F800);                  /** @brief L3HDBM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L4PEN0_MASK = UINT32_C(0x00010000);                   /** @brief L4PEN0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L4SPM0_MASK = UINT32_C(0x00040000);                   /** @brief L4SPM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L4SPIM0_MASK = UINT32_C(0x00080000);                  /** @brief L4SPIM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L4DPM0_MASK = UINT32_C(0x00100000);                   /** @brief L4DPM0 */
    static const uint32_t ETHERNET_MAC_MACL3L4C0R_L4DPIM0_MASK = UINT32_C(0x00200000);                  /** @brief L4DPIM0 */
    static const uint32_t ETHERNET_MAC_MACL4A0R_L4SP0_MASK = UINT32_C(0x0000FFFF);                      /** @brief L4SP0 */
    static const uint32_t ETHERNET_MAC_MACL4A0R_L4DP0_MASK = UINT32_C(0xFFFF0000);                      /** @brief L4DP0 */
    static const uint32_t ETHERNET_MAC_MACDR_RPESTS_MASK = UINT32_C(0x00000001);                        /** @brief RPESTS */
    static const uint32_t ETHERNET_MAC_MACDR_RFCFCSTS_MASK = UINT32_C(0x00000006);                      /** @brief RFCFCSTS */
    static const uint32_t ETHERNET_MAC_MACDR_TPESTS_MASK = UINT32_C(0x00010000);                        /** @brief TPESTS */
    static const uint32_t ETHERNET_MAC_MACDR_TFCSTS_MASK = UINT32_C(0x00060000);                        /** @brief TFCSTS */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L3PEN1_MASK = UINT32_C(0x00000001);                   /** @brief L3PEN1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L3SAM1_MASK = UINT32_C(0x00000004);                   /** @brief L3SAM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L3SAIM1_MASK = UINT32_C(0x00000008);                  /** @brief L3SAIM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L3DAM1_MASK = UINT32_C(0x00000010);                   /** @brief L3DAM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L3DAIM1_MASK = UINT32_C(0x00000020);                  /** @brief L3DAIM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L3HSBM1_MASK = UINT32_C(0x000007C0);                  /** @brief L3HSBM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L3HDBM1_MASK = UINT32_C(0x0000F800);                  /** @brief L3HDBM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L4PEN1_MASK = UINT32_C(0x00010000);                   /** @brief L4PEN1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L4SPM1_MASK = UINT32_C(0x00040000);                   /** @brief L4SPM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L4SPIM1_MASK = UINT32_C(0x00080000);                  /** @brief L4SPIM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L4DPM1_MASK = UINT32_C(0x00100000);                   /** @brief L4DPM1 */
    static const uint32_t ETHERNET_MAC_MACL3L4C1R_L4DPIM1_MASK = UINT32_C(0x00200000);                  /** @brief L4DPIM1 */
    static const uint32_t ETHERNET_MAC_MACL4A1R_L4SP1_MASK = UINT32_C(0x0000FFFF);                      /** @brief L4SP1 */
    static const uint32_t ETHERNET_MAC_MACL4A1R_L4DP1_MASK = UINT32_C(0xFFFF0000);                      /** @brief L4DP1 */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSENA_MASK = UINT32_C(0x00000001);                       /** @brief TSENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSCFUPDT_MASK = UINT32_C(0x00000002);                    /** @brief TSCFUPDT */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSINIT_MASK = UINT32_C(0x00000004);                      /** @brief TSINIT */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSUPDT_MASK = UINT32_C(0x00000008);                      /** @brief TSUPDT */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSADDREG_MASK = UINT32_C(0x00000020);                    /** @brief TSADDREG */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSENALL_MASK = UINT32_C(0x00000100);                     /** @brief TSENALL */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSCTRLSSR_MASK = UINT32_C(0x00000200);                   /** @brief TSCTRLSSR */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSVER2ENA_MASK = UINT32_C(0x00000400);                   /** @brief TSVER2ENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSIPENA_MASK = UINT32_C(0x00000800);                     /** @brief TSIPENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSIPV6ENA_MASK = UINT32_C(0x00001000);                   /** @brief TSIPV6ENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSIPV4ENA_MASK = UINT32_C(0x00002000);                   /** @brief TSIPV4ENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSEVNTENA_MASK = UINT32_C(0x00004000);                   /** @brief TSEVNTENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSMSTRENA_MASK = UINT32_C(0x00008000);                   /** @brief TSMSTRENA */
    static const uint32_t ETHERNET_MAC_MACTSCR_SNAPTYPSEL_MASK = UINT32_C(0x00030000);                  /** @brief SNAPTYPSEL */
    static const uint32_t ETHERNET_MAC_MACTSCR_TSENMACADDR_MASK = UINT32_C(0x00040000);                 /** @brief TSENMACADDR */
    static const uint32_t ETHERNET_MAC_MACTSCR_CSC_MASK = UINT32_C(0x00080000);                         /** @brief CSC */
    static const uint32_t ETHERNET_MAC_MACTSCR_TXTSSTSM_MASK = UINT32_C(0x01000000);                    /** @brief TXTSSTSM */
    static const uint32_t ETHERNET_MAC_MACSSIR_SNSINC_MASK = UINT32_C(0x0000FF00);                      /** @brief SNSINC */
    static const uint32_t ETHERNET_MAC_MACSSIR_SSINC_MASK = UINT32_C(0x00FF0000);                       /** @brief SSINC */
    static const uint32_t ETHERNET_MAC_MACSTNR_TSSS_MASK = UINT32_C(0x7FFFFFFF);                        /** @brief TSSS */
    static const uint32_t ETHERNET_MAC_MACSTNUR_TSSS_MASK = UINT32_C(0x7FFFFFFF);                       /** @brief TSSS */
    static const uint32_t ETHERNET_MAC_MACSTNUR_ADDSUB_MASK = UINT32_C(0x80000000);                     /** @brief ADDSUB */
    static const uint32_t ETHERNET_MAC_MACTSSR_TSSOVF_MASK = UINT32_C(0x00000001);                      /** @brief TSSOVF */
    static const uint32_t ETHERNET_MAC_MACTSSR_TSTARGT0_MASK = UINT32_C(0x00000002);                    /** @brief TSTARGT0 */
    static const uint32_t ETHERNET_MAC_MACTSSR_AUXTSTRIG_MASK = UINT32_C(0x00000004);                   /** @brief AUXTSTRIG */
    static const uint32_t ETHERNET_MAC_MACTSSR_TSTRGTERR0_MASK = UINT32_C(0x00000008);                  /** @brief TSTRGTERR0 */
    static const uint32_t ETHERNET_MAC_MACTSSR_TXTSSIS_MASK = UINT32_C(0x00008000);                     /** @brief TXTSSIS */
    static const uint32_t ETHERNET_MAC_MACTSSR_ATSSTN_MASK = UINT32_C(0x000F0000);                      /** @brief ATSSTN */
    static const uint32_t ETHERNET_MAC_MACTSSR_ATSSTM_MASK = UINT32_C(0x01000000);                      /** @brief ATSSTM */
    static const uint32_t ETHERNET_MAC_MACTSSR_ATSNS_MASK = UINT32_C(0x3E000000);                       /** @brief ATSNS */
    static const uint32_t ETHERNET_MAC_MACTXTSSNR_TXTSSLO_MASK = UINT32_C(0x7FFFFFFF);                  /** @brief TXTSSLO */
    static const uint32_t ETHERNET_MAC_MACTXTSSNR_TXTSSMIS_MASK = UINT32_C(0x80000000);                 /** @brief TXTSSMIS */
    static const uint32_t ETHERNET_MAC_MACACR_ATSFC_MASK = UINT32_C(0x00000001);                        /** @brief ATSFC */
    static const uint32_t ETHERNET_MAC_MACATSNR_AUXTSLO_MASK = UINT32_C(0x7FFFFFFF);                    /** @brief AUXTSLO */
    static const uint32_t ETHERNET_MAC_MACPPSCR_PPSCTRL_MASK = UINT32_C(0x0000000F);                    /** @brief PPSCTRL */
    static const uint32_t ETHERNET_MAC_MACPPSCR_PPSEN0_MASK = UINT32_C(0x00000010);                     /** @brief PPSEN0 */
    static const uint32_t ETHERNET_MAC_MACPPSCR_TRGTMODSEL0_MASK = UINT32_C(0x00000060);                /** @brief TRGTMODSEL0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTSR_TSTRH0_MASK = UINT32_C(0x7FFFFFFF);                   /** @brief TSTRH0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTNR_TTSL0_MASK = UINT32_C(0x7FFFFFFF);                    /** @brief TTSL0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0_MASK = UINT32_C(0x80000000);                /** @brief TRGTBUSY0 */
    static const uint32_t ETHERNET_MAC_MACPOCR_PTOEN_MASK = UINT32_C(0x00000001);                       /** @brief PTOEN */
    static const uint32_t ETHERNET_MAC_MACPOCR_ASYNCEN_MASK = UINT32_C(0x00000002);                     /** @brief ASYNCEN */
    static const uint32_t ETHERNET_MAC_MACPOCR_APDREQEN_MASK = UINT32_C(0x00000004);                    /** @brief APDREQEN */
    static const uint32_t ETHERNET_MAC_MACPOCR_ASYNCTRIG_MASK = UINT32_C(0x00000010);                   /** @brief ASYNCTRIG */
    static const uint32_t ETHERNET_MAC_MACPOCR_APDREQTRIG_MASK = UINT32_C(0x00000020);                  /** @brief APDREQTRIG */
    static const uint32_t ETHERNET_MAC_MACPOCR_DRRDIS_MASK = UINT32_C(0x00000040);                      /** @brief DRRDIS */
    static const uint32_t ETHERNET_MAC_MACPOCR_DN_MASK = UINT32_C(0x0000FF00);                          /** @brief DN */
    static const uint32_t ETHERNET_MAC_MACSPI2R_SPI2_MASK = UINT32_C(0x0000FFFF);                       /** @brief SPI2 */
    static const uint32_t ETHERNET_MAC_MACLMIR_LSI_MASK = UINT32_C(0x000000FF);                         /** @brief LSI */
    static const uint32_t ETHERNET_MAC_MACLMIR_DRSYNCR_MASK = UINT32_C(0x00000700);                     /** @brief DRSYNCR */
    static const uint32_t ETHERNET_MAC_MACLMIR_LMPDRI_MASK = UINT32_C(0xFF000000);                      /** @brief LMPDRI */

    /** @subsection ETHERNET_MAC field position array definitions */

    static const int32_t ETHERNET_MAC_MACLMIR_ATSENX_POS[4] = {
      INT32_C(4),   /** @brief ATSEN0 */
      INT32_C(5),   /** @brief ATSEN1 */
      INT32_C(6),   /** @brief ATSEN2 */
      INT32_C(7),   /** @brief ATSEN3 */
    };

    /** @subsection ETHERNET_MAC field position definitions */

    static const int32_t ETHERNET_MAC_MACLMIR_SWR_POS = INT32_C(0);             /** @brief Software reset */
    static const int32_t ETHERNET_MAC_MACLMIR_DA_POS = INT32_C(1);              /** @brief DMA tx or rx arbitration scheme */
    static const int32_t ETHERNET_MAC_MACLMIR_TXPR_POS = INT32_C(11);           /** @brief Transmit priority */
    static const int32_t ETHERNET_MAC_MACLMIR_PR_POS = INT32_C(12);             /** @brief Priority ratio */
    static const int32_t ETHERNET_MAC_MACLMIR_INTM_POS = INT32_C(16);           /** @brief Interrupt mode */
    static const int32_t ETHERNET_MAC_MACLMIR_FB_POS = INT32_C(0);              /** @brief Fixed burst length */
    static const int32_t ETHERNET_MAC_MACLMIR_AAL_POS = INT32_C(12);            /** @brief Address-Aligned beats */
    static const int32_t ETHERNET_MAC_MACLMIR_MB_POS = INT32_C(14);             /** @brief Mixed burst */
    static const int32_t ETHERNET_MAC_MACLMIR_RB_POS = INT32_C(15);             /** @brief Rebuild incrx burst */
    static const int32_t ETHERNET_MAC_MACLMIR_DC0IS_POS = INT32_C(0);           /** @brief DMA channel interrupt status */
    static const int32_t ETHERNET_MAC_MACLMIR_MTLIS_POS = INT32_C(16);          /** @brief MTL interrupt status */
    static const int32_t ETHERNET_MAC_MACLMIR_MACIS_POS = INT32_C(17);          /** @brief MAC interrupt status */
    static const int32_t ETHERNET_MAC_MACLMIR_AXWHSTS_POS = INT32_C(0);         /** @brief AHB master write channel */
    static const int32_t ETHERNET_MAC_MACLMIR_RPS0_POS = INT32_C(8);            /** @brief DMA channel receive process state */
    static const int32_t ETHERNET_MAC_MACLMIR_TPS0_POS = INT32_C(12);           /** @brief DMA channel transmit process state */
    static const int32_t ETHERNET_MAC_MACLMIR_MSS_POS = INT32_C(0);             /** @brief Maximum segment size */
    static const int32_t ETHERNET_MAC_MACLMIR_PBLX8_POS = INT32_C(16);          /** @brief 8xPBL mode */
    static const int32_t ETHERNET_MAC_MACLMIR_DSL_POS = INT32_C(18);            /** @brief Descriptor skip length */
    static const int32_t ETHERNET_MAC_MACLMIR_ST_POS = INT32_C(0);              /** @brief Start or stop transmission command */
    static const int32_t ETHERNET_MAC_MACLMIR_OSF_POS = INT32_C(4);             /** @brief Operate on second packet */
    static const int32_t ETHERNET_MAC_MACLMIR_TSE_POS = INT32_C(12);            /** @brief TCP segmentation enabled */
    static const int32_t ETHERNET_MAC_MACLMIR_TXPBL_POS = INT32_C(16);          /** @brief Transmit programmable burst length */
    static const int32_t ETHERNET_MAC_MACLMIR_SR_POS = INT32_C(0);              /** @brief Start or stop receive command */
    static const int32_t ETHERNET_MAC_MACLMIR_RBSZ_POS = INT32_C(1);            /** @brief Receive buffer size */
    static const int32_t ETHERNET_MAC_MACLMIR_RXPBL_POS = INT32_C(16);          /** @brief RXPBL */
    static const int32_t ETHERNET_MAC_MACLMIR_RPF_POS = INT32_C(31);            /** @brief DMA rx channel packet flush */
    static const int32_t ETHERNET_MAC_MACLMIR_TDESLA_POS = INT32_C(2);          /** @brief Start of transmit list */
    static const int32_t ETHERNET_MAC_MACLMIR_RDESLA_POS = INT32_C(2);          /** @brief Start of receive list */
    static const int32_t ETHERNET_MAC_MACLMIR_TDT_POS = INT32_C(2);             /** @brief Transmit descriptor tail pointer */
    static const int32_t ETHERNET_MAC_MACLMIR_RDT_POS = INT32_C(2);             /** @brief Receive descriptor tail pointer */
    static const int32_t ETHERNET_MAC_MACLMIR_TDRL_POS = INT32_C(0);            /** @brief Transmit descriptor ring length */
    static const int32_t ETHERNET_MAC_MACLMIR_RDRL_POS = INT32_C(0);            /** @brief Receive descriptor ring length */
    static const int32_t ETHERNET_MAC_MACLMIR_TIE_POS = INT32_C(0);             /** @brief Transmit interrupt enable */
    static const int32_t ETHERNET_MAC_MACLMIR_TXSE_POS = INT32_C(1);            /** @brief Transmit stopped enable */
    static const int32_t ETHERNET_MAC_MACLMIR_TBUE_POS = INT32_C(2);            /** @brief Transmit buffer unavailable enable */
    static const int32_t ETHERNET_MAC_MACLMIR_RIE_POS = INT32_C(6);             /** @brief Receive interrupt enable */
    static const int32_t ETHERNET_MAC_MACLMIR_RBUE_POS = INT32_C(7);            /** @brief Receive buffer unavailable enable */
    static const int32_t ETHERNET_MAC_MACLMIR_RSE_POS = INT32_C(8);             /** @brief Receive stopped enable */
    static const int32_t ETHERNET_MAC_MACLMIR_RWTE_POS = INT32_C(9);            /** @brief Receive watchdog timeout enable */
    static const int32_t ETHERNET_MAC_MACLMIR_ETIE_POS = INT32_C(10);           /** @brief Early transmit interrupt enable */
    static const int32_t ETHERNET_MAC_MACLMIR_ERIE_POS = INT32_C(11);           /** @brief Early receive interrupt enable */
    static const int32_t ETHERNET_MAC_MACLMIR_FBEE_POS = INT32_C(12);           /** @brief Fatal bus error enable */
    static const int32_t ETHERNET_MAC_MACLMIR_CDEE_POS = INT32_C(13);           /** @brief Context descriptor error enable */
    static const int32_t ETHERNET_MAC_MACLMIR_AIE_POS = INT32_C(14);            /** @brief Abnormal interrupt summary enable */
    static const int32_t ETHERNET_MAC_MACLMIR_NIE_POS = INT32_C(15);            /** @brief Normal interrupt summary enable */
    static const int32_t ETHERNET_MAC_MACLMIR_RWT_POS = INT32_C(0);             /** @brief Receive interrupt watchdog timer count */
    static const int32_t ETHERNET_MAC_MACLMIR_TI_POS = INT32_C(0);              /** @brief Transmit interrupt */
    static const int32_t ETHERNET_MAC_MACLMIR_TPS_POS = INT32_C(1);             /** @brief Transmit process stopped */
    static const int32_t ETHERNET_MAC_MACLMIR_TBU_POS = INT32_C(2);             /** @brief Transmit buffer unavailable */
    static const int32_t ETHERNET_MAC_MACLMIR_RI_POS = INT32_C(6);              /** @brief Receive interrupt */
    static const int32_t ETHERNET_MAC_MACLMIR_RBU_POS = INT32_C(7);             /** @brief Receive buffer unavailable */
    static const int32_t ETHERNET_MAC_MACLMIR_RPS_POS = INT32_C(8);             /** @brief Receive process stopped */
    static const int32_t ETHERNET_MAC_MACLMIR_RWT_POS = INT32_C(9);             /** @brief Receive watchdog timeout */
    static const int32_t ETHERNET_MAC_MACLMIR_ET_POS = INT32_C(10);             /** @brief Early transmit interrupt */
    static const int32_t ETHERNET_MAC_MACLMIR_ER_POS = INT32_C(11);             /** @brief Early receive interrupt */
    static const int32_t ETHERNET_MAC_MACLMIR_FBE_POS = INT32_C(12);            /** @brief Fatal bus error */
    static const int32_t ETHERNET_MAC_MACLMIR_CDE_POS = INT32_C(13);            /** @brief Context descriptor error */
    static const int32_t ETHERNET_MAC_MACLMIR_AIS_POS = INT32_C(14);            /** @brief Abnormal interrupt summary */
    static const int32_t ETHERNET_MAC_MACLMIR_NIS_POS = INT32_C(15);            /** @brief Normal interrupt summary */
    static const int32_t ETHERNET_MAC_MACLMIR_TEB_POS = INT32_C(16);            /** @brief Tx DMA error bits */
    static const int32_t ETHERNET_MAC_MACLMIR_REB_POS = INT32_C(19);            /** @brief Rx DMA error bits */
    static const int32_t ETHERNET_MAC_MACLMIR_MFC_POS = INT32_C(0);             /** @brief Dropped packet counters */
    static const int32_t ETHERNET_MAC_MACLMIR_MFCO_POS = INT32_C(15);           /** @brief Overflow status of the MFC counter */
    static const int32_t ETHERNET_MAC_MACLMIR_DTXSTS_POS = INT32_C(1);          /** @brief DTXSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_CNTPRST_POS = INT32_C(8);         /** @brief CNTPRST */
    static const int32_t ETHERNET_MAC_MACLMIR_CNTCLR_POS = INT32_C(9);          /** @brief CNTCLR */
    static const int32_t ETHERNET_MAC_MACLMIR_Q0IS_POS = INT32_C(0);            /** @brief Queue interrupt status */
    static const int32_t ETHERNET_MAC_MACLMIR_FTQ_POS = INT32_C(0);             /** @brief Flush transmit queue */
    static const int32_t ETHERNET_MAC_MACLMIR_TSF_POS = INT32_C(1);             /** @brief Transmit store and forward */
    static const int32_t ETHERNET_MAC_MACLMIR_TXQEN_POS = INT32_C(2);           /** @brief Transmit queue enable */
    static const int32_t ETHERNET_MAC_MACLMIR_TTC_POS = INT32_C(4);             /** @brief Transmit threshold control */
    static const int32_t ETHERNET_MAC_MACLMIR_TQS_POS = INT32_C(16);            /** @brief Transmit queue size */
    static const int32_t ETHERNET_MAC_MACLMIR_UFFRMCNT_POS = INT32_C(0);        /** @brief Underflow packet counter */
    static const int32_t ETHERNET_MAC_MACLMIR_UFCNTOVF_POS = INT32_C(11);       /** @brief UFCNTOVF */
    static const int32_t ETHERNET_MAC_MACLMIR_TXQPAUSED_POS = INT32_C(0);       /** @brief TXQPAUSED */
    static const int32_t ETHERNET_MAC_MACLMIR_TRCSTS_POS = INT32_C(1);          /** @brief TRCSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_TWCSTS_POS = INT32_C(3);          /** @brief TWCSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXQSTS_POS = INT32_C(4);          /** @brief TXQSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXSTSFSTS_POS = INT32_C(5);       /** @brief TXSTSFSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_PTXQ_POS = INT32_C(16);           /** @brief PTXQ */
    static const int32_t ETHERNET_MAC_MACLMIR_STXSTSF_POS = INT32_C(20);        /** @brief STXSTSF */
    static const int32_t ETHERNET_MAC_MACLMIR_TXUNFIS_POS = INT32_C(0);         /** @brief TXUNFIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXUIE_POS = INT32_C(8);           /** @brief TXUIE */
    static const int32_t ETHERNET_MAC_MACLMIR_RXOVFIS_POS = INT32_C(16);        /** @brief RXOVFIS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXOIE_POS = INT32_C(24);          /** @brief RXOIE */
    static const int32_t ETHERNET_MAC_MACLMIR_RTC_POS = INT32_C(0);             /** @brief RTC */
    static const int32_t ETHERNET_MAC_MACLMIR_FUP_POS = INT32_C(3);             /** @brief FUP */
    static const int32_t ETHERNET_MAC_MACLMIR_FEP_POS = INT32_C(4);             /** @brief FEP */
    static const int32_t ETHERNET_MAC_MACLMIR_RSF_POS = INT32_C(5);             /** @brief RSF */
    static const int32_t ETHERNET_MAC_MACLMIR_DIS_TCP_EF_POS = INT32_C(6);      /** @brief DIS_TCP_EF */
    static const int32_t ETHERNET_MAC_MACLMIR_EHFC_POS = INT32_C(7);            /** @brief EHFC */
    static const int32_t ETHERNET_MAC_MACLMIR_RFA_POS = INT32_C(8);             /** @brief RFA */
    static const int32_t ETHERNET_MAC_MACLMIR_RFD_POS = INT32_C(14);            /** @brief RFD */
    static const int32_t ETHERNET_MAC_MACLMIR_RQS_POS = INT32_C(20);            /** @brief RQS */
    static const int32_t ETHERNET_MAC_MACLMIR_OVFPKTCNT_POS = INT32_C(0);       /** @brief OVFPKTCNT */
    static const int32_t ETHERNET_MAC_MACLMIR_OVFCNTOVF_POS = INT32_C(11);      /** @brief OVFCNTOVF */
    static const int32_t ETHERNET_MAC_MACLMIR_MISPKTCNT_POS = INT32_C(16);      /** @brief MISPKTCNT */
    static const int32_t ETHERNET_MAC_MACLMIR_MISCNTOVF_POS = INT32_C(27);      /** @brief MISCNTOVF */
    static const int32_t ETHERNET_MAC_MACLMIR_RWCSTS_POS = INT32_C(0);          /** @brief RWCSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_RRCSTS_POS = INT32_C(1);          /** @brief RRCSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXQSTS_POS = INT32_C(4);          /** @brief RXQSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_PRXQ_POS = INT32_C(16);           /** @brief PRXQ */
    static const int32_t ETHERNET_MAC_MACLMIR_RE_POS = INT32_C(0);              /** @brief Receiver enable */
    static const int32_t ETHERNET_MAC_MACLMIR_TE_POS = INT32_C(1);              /** @brief TE */
    static const int32_t ETHERNET_MAC_MACLMIR_PRELEN_POS = INT32_C(2);          /** @brief PRELEN */
    static const int32_t ETHERNET_MAC_MACLMIR_DC_POS = INT32_C(4);              /** @brief DC */
    static const int32_t ETHERNET_MAC_MACLMIR_BL_POS = INT32_C(5);              /** @brief BL */
    static const int32_t ETHERNET_MAC_MACLMIR_DR_POS = INT32_C(8);              /** @brief DR */
    static const int32_t ETHERNET_MAC_MACLMIR_DCRS_POS = INT32_C(9);            /** @brief DCRS */
    static const int32_t ETHERNET_MAC_MACLMIR_DO_POS = INT32_C(10);             /** @brief DO */
    static const int32_t ETHERNET_MAC_MACLMIR_ECRSFD_POS = INT32_C(11);         /** @brief ECRSFD */
    static const int32_t ETHERNET_MAC_MACLMIR_LM_POS = INT32_C(12);             /** @brief LM */
    static const int32_t ETHERNET_MAC_MACLMIR_DM_POS = INT32_C(13);             /** @brief DM */
    static const int32_t ETHERNET_MAC_MACLMIR_FES_POS = INT32_C(14);            /** @brief FES */
    static const int32_t ETHERNET_MAC_MACLMIR_JE_POS = INT32_C(16);             /** @brief JE */
    static const int32_t ETHERNET_MAC_MACLMIR_JD_POS = INT32_C(17);             /** @brief JD */
    static const int32_t ETHERNET_MAC_MACLMIR_WD_POS = INT32_C(19);             /** @brief WD */
    static const int32_t ETHERNET_MAC_MACLMIR_ACS_POS = INT32_C(20);            /** @brief ACS */
    static const int32_t ETHERNET_MAC_MACLMIR_CST_POS = INT32_C(21);            /** @brief CST */
    static const int32_t ETHERNET_MAC_MACLMIR_S2KP_POS = INT32_C(22);           /** @brief S2KP */
    static const int32_t ETHERNET_MAC_MACLMIR_GPSLCE_POS = INT32_C(23);         /** @brief GPSLCE */
    static const int32_t ETHERNET_MAC_MACLMIR_IPG_POS = INT32_C(24);            /** @brief IPG */
    static const int32_t ETHERNET_MAC_MACLMIR_IPC_POS = INT32_C(27);            /** @brief IPC */
    static const int32_t ETHERNET_MAC_MACLMIR_SARC_POS = INT32_C(28);           /** @brief SARC */
    static const int32_t ETHERNET_MAC_MACLMIR_ARPEN_POS = INT32_C(31);          /** @brief ARPEN */
    static const int32_t ETHERNET_MAC_MACLMIR_GPSL_POS = INT32_C(0);            /** @brief GPSL */
    static const int32_t ETHERNET_MAC_MACLMIR_DCRCC_POS = INT32_C(16);          /** @brief DCRCC */
    static const int32_t ETHERNET_MAC_MACLMIR_SPEN_POS = INT32_C(17);           /** @brief SPEN */
    static const int32_t ETHERNET_MAC_MACLMIR_USP_POS = INT32_C(18);            /** @brief USP */
    static const int32_t ETHERNET_MAC_MACLMIR_EIPGEN_POS = INT32_C(24);         /** @brief EIPGEN */
    static const int32_t ETHERNET_MAC_MACLMIR_EIPG_POS = INT32_C(25);           /** @brief EIPG */
    static const int32_t ETHERNET_MAC_MACLMIR_PR_POS = INT32_C(0);              /** @brief PR */
    static const int32_t ETHERNET_MAC_MACLMIR_HUC_POS = INT32_C(1);             /** @brief HUC */
    static const int32_t ETHERNET_MAC_MACLMIR_HMC_POS = INT32_C(2);             /** @brief HMC */
    static const int32_t ETHERNET_MAC_MACLMIR_DAIF_POS = INT32_C(3);            /** @brief DAIF */
    static const int32_t ETHERNET_MAC_MACLMIR_PM_POS = INT32_C(4);              /** @brief PM */
    static const int32_t ETHERNET_MAC_MACLMIR_DBF_POS = INT32_C(5);             /** @brief DBF */
    static const int32_t ETHERNET_MAC_MACLMIR_PCF_POS = INT32_C(6);             /** @brief PCF */
    static const int32_t ETHERNET_MAC_MACLMIR_SAIF_POS = INT32_C(8);            /** @brief SAIF */
    static const int32_t ETHERNET_MAC_MACLMIR_SAF_POS = INT32_C(9);             /** @brief SAF */
    static const int32_t ETHERNET_MAC_MACLMIR_HPF_POS = INT32_C(10);            /** @brief HPF */
    static const int32_t ETHERNET_MAC_MACLMIR_VTFE_POS = INT32_C(16);           /** @brief VTFE */
    static const int32_t ETHERNET_MAC_MACLMIR_IPFE_POS = INT32_C(20);           /** @brief IPFE */
    static const int32_t ETHERNET_MAC_MACLMIR_DNTU_POS = INT32_C(21);           /** @brief DNTU */
    static const int32_t ETHERNET_MAC_MACLMIR_RA_POS = INT32_C(31);             /** @brief RA */
    static const int32_t ETHERNET_MAC_MACLMIR_WTO_POS = INT32_C(0);             /** @brief WTO */
    static const int32_t ETHERNET_MAC_MACLMIR_PWE_POS = INT32_C(8);             /** @brief PWE */
    static const int32_t ETHERNET_MAC_MACLMIR_VL_POS = INT32_C(0);              /** @brief VL */
    static const int32_t ETHERNET_MAC_MACLMIR_ETV_POS = INT32_C(16);            /** @brief ETV */
    static const int32_t ETHERNET_MAC_MACLMIR_VTIM_POS = INT32_C(17);           /** @brief VTIM */
    static const int32_t ETHERNET_MAC_MACLMIR_ESVL_POS = INT32_C(18);           /** @brief ESVL */
    static const int32_t ETHERNET_MAC_MACLMIR_ERSVLM_POS = INT32_C(19);         /** @brief ERSVLM */
    static const int32_t ETHERNET_MAC_MACLMIR_DOVLTC_POS = INT32_C(20);         /** @brief DOVLTC */
    static const int32_t ETHERNET_MAC_MACLMIR_EVLS_POS = INT32_C(21);           /** @brief EVLS */
    static const int32_t ETHERNET_MAC_MACLMIR_EVLRXS_POS = INT32_C(24);         /** @brief EVLRXS */
    static const int32_t ETHERNET_MAC_MACLMIR_VTHM_POS = INT32_C(25);           /** @brief VTHM */
    static const int32_t ETHERNET_MAC_MACLMIR_EDVLP_POS = INT32_C(26);          /** @brief EDVLP */
    static const int32_t ETHERNET_MAC_MACLMIR_ERIVLT_POS = INT32_C(27);         /** @brief ERIVLT */
    static const int32_t ETHERNET_MAC_MACLMIR_EIVLS_POS = INT32_C(28);          /** @brief EIVLS */
    static const int32_t ETHERNET_MAC_MACLMIR_EIVLRXS_POS = INT32_C(31);        /** @brief EIVLRXS */
    static const int32_t ETHERNET_MAC_MACLMIR_VLHT_POS = INT32_C(0);            /** @brief VLHT */
    static const int32_t ETHERNET_MAC_MACLMIR_VLT_POS = INT32_C(0);             /** @brief VLT */
    static const int32_t ETHERNET_MAC_MACLMIR_VLC_POS = INT32_C(16);            /** @brief VLC */
    static const int32_t ETHERNET_MAC_MACLMIR_VLP_POS = INT32_C(18);            /** @brief VLP */
    static const int32_t ETHERNET_MAC_MACLMIR_CSVL_POS = INT32_C(19);           /** @brief CSVL */
    static const int32_t ETHERNET_MAC_MACLMIR_VLTI_POS = INT32_C(20);           /** @brief VLTI */
    static const int32_t ETHERNET_MAC_MACLMIR_VLT_POS = INT32_C(0);             /** @brief VLT */
    static const int32_t ETHERNET_MAC_MACLMIR_VLC_POS = INT32_C(16);            /** @brief VLC */
    static const int32_t ETHERNET_MAC_MACLMIR_VLP_POS = INT32_C(18);            /** @brief VLP */
    static const int32_t ETHERNET_MAC_MACLMIR_CSVL_POS = INT32_C(19);           /** @brief CSVL */
    static const int32_t ETHERNET_MAC_MACLMIR_VLTI_POS = INT32_C(20);           /** @brief VLTI */
    static const int32_t ETHERNET_MAC_MACLMIR_FCB_BPA_POS = INT32_C(0);         /** @brief FCB_BPA */
    static const int32_t ETHERNET_MAC_MACLMIR_TFE_POS = INT32_C(1);             /** @brief TFE */
    static const int32_t ETHERNET_MAC_MACLMIR_PLT_POS = INT32_C(4);             /** @brief PLT */
    static const int32_t ETHERNET_MAC_MACLMIR_DZPQ_POS = INT32_C(7);            /** @brief DZPQ */
    static const int32_t ETHERNET_MAC_MACLMIR_PT_POS = INT32_C(16);             /** @brief PT */
    static const int32_t ETHERNET_MAC_MACLMIR_RFE_POS = INT32_C(0);             /** @brief RFE */
    static const int32_t ETHERNET_MAC_MACLMIR_UP_POS = INT32_C(1);              /** @brief UP */
    static const int32_t ETHERNET_MAC_MACLMIR_PHYIS_POS = INT32_C(3);           /** @brief PHYIS */
    static const int32_t ETHERNET_MAC_MACLMIR_PMTIS_POS = INT32_C(4);           /** @brief PMTIS */
    static const int32_t ETHERNET_MAC_MACLMIR_LPIIS_POS = INT32_C(5);           /** @brief LPIIS */
    static const int32_t ETHERNET_MAC_MACLMIR_MMCIS_POS = INT32_C(8);           /** @brief MMCIS */
    static const int32_t ETHERNET_MAC_MACLMIR_MMCRXIS_POS = INT32_C(9);         /** @brief MMCRXIS */
    static const int32_t ETHERNET_MAC_MACLMIR_MMCTXIS_POS = INT32_C(10);        /** @brief MMCTXIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TSIS_POS = INT32_C(12);           /** @brief TSIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXSTSIS_POS = INT32_C(13);        /** @brief TXSTSIS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXSTSIS_POS = INT32_C(14);        /** @brief RXSTSIS */
    static const int32_t ETHERNET_MAC_MACLMIR_PHYIE_POS = INT32_C(3);           /** @brief PHYIE */
    static const int32_t ETHERNET_MAC_MACLMIR_PMTIE_POS = INT32_C(4);           /** @brief PMTIE */
    static const int32_t ETHERNET_MAC_MACLMIR_LPIIE_POS = INT32_C(5);           /** @brief LPIIE */
    static const int32_t ETHERNET_MAC_MACLMIR_TSIE_POS = INT32_C(12);           /** @brief TSIE */
    static const int32_t ETHERNET_MAC_MACLMIR_TXSTSIE_POS = INT32_C(13);        /** @brief TXSTSIE */
    static const int32_t ETHERNET_MAC_MACLMIR_RXSTSIE_POS = INT32_C(14);        /** @brief RXSTSIE */
    static const int32_t ETHERNET_MAC_MACLMIR_TJT_POS = INT32_C(0);             /** @brief TJT */
    static const int32_t ETHERNET_MAC_MACLMIR_NCARR_POS = INT32_C(1);           /** @brief NCARR */
    static const int32_t ETHERNET_MAC_MACLMIR_LCARR_POS = INT32_C(2);           /** @brief LCARR */
    static const int32_t ETHERNET_MAC_MACLMIR_EXDEF_POS = INT32_C(3);           /** @brief EXDEF */
    static const int32_t ETHERNET_MAC_MACLMIR_LCOL_POS = INT32_C(4);            /** @brief LCOL */
    static const int32_t ETHERNET_MAC_MACLMIR_EXCOL_POS = INT32_C(5);           /** @brief LCOL */
    static const int32_t ETHERNET_MAC_MACLMIR_RWT_POS = INT32_C(8);             /** @brief RWT */
    static const int32_t ETHERNET_MAC_MACLMIR_PWRDWN_POS = INT32_C(0);          /** @brief PWRDWN */
    static const int32_t ETHERNET_MAC_MACLMIR_MGKPKTEN_POS = INT32_C(1);        /** @brief MGKPKTEN */
    static const int32_t ETHERNET_MAC_MACLMIR_RWKPKTEN_POS = INT32_C(2);        /** @brief RWKPKTEN */
    static const int32_t ETHERNET_MAC_MACLMIR_MGKPRCVD_POS = INT32_C(5);        /** @brief MGKPRCVD */
    static const int32_t ETHERNET_MAC_MACLMIR_RWKPRCVD_POS = INT32_C(6);        /** @brief RWKPRCVD */
    static const int32_t ETHERNET_MAC_MACLMIR_GLBLUCAST_POS = INT32_C(9);       /** @brief GLBLUCAST */
    static const int32_t ETHERNET_MAC_MACLMIR_RWKPFE_POS = INT32_C(10);         /** @brief RWKPFE */
    static const int32_t ETHERNET_MAC_MACLMIR_RWKPTR_POS = INT32_C(24);         /** @brief RWKPTR */
    static const int32_t ETHERNET_MAC_MACLMIR_RWKFILTRST_POS = INT32_C(31);     /** @brief RWKFILTRST */
    static const int32_t ETHERNET_MAC_MACLMIR_TLPIEN_POS = INT32_C(0);          /** @brief TLPIEN */
    static const int32_t ETHERNET_MAC_MACLMIR_TLPIEX_POS = INT32_C(1);          /** @brief TLPIEX */
    static const int32_t ETHERNET_MAC_MACLMIR_RLPIEN_POS = INT32_C(2);          /** @brief RLPIEN */
    static const int32_t ETHERNET_MAC_MACLMIR_RLPIEX_POS = INT32_C(3);          /** @brief RLPIEX */
    static const int32_t ETHERNET_MAC_MACLMIR_TLPIST_POS = INT32_C(8);          /** @brief TLPIST */
    static const int32_t ETHERNET_MAC_MACLMIR_RLPIST_POS = INT32_C(9);          /** @brief RLPIST */
    static const int32_t ETHERNET_MAC_MACLMIR_LPIEN_POS = INT32_C(16);          /** @brief LPIEN */
    static const int32_t ETHERNET_MAC_MACLMIR_PLS_POS = INT32_C(17);            /** @brief PLS */
    static const int32_t ETHERNET_MAC_MACLMIR_PLSEN_POS = INT32_C(18);          /** @brief PLSEN */
    static const int32_t ETHERNET_MAC_MACLMIR_LPITXA_POS = INT32_C(19);         /** @brief LPITXA */
    static const int32_t ETHERNET_MAC_MACLMIR_LPITE_POS = INT32_C(20);          /** @brief LPITE */
    static const int32_t ETHERNET_MAC_MACLMIR_LPITCSE_POS = INT32_C(21);        /** @brief LPITCSE */
    static const int32_t ETHERNET_MAC_MACLMIR_TWT_POS = INT32_C(0);             /** @brief TWT */
    static const int32_t ETHERNET_MAC_MACLMIR_LST_POS = INT32_C(16);            /** @brief LST */
    static const int32_t ETHERNET_MAC_MACLMIR_LPIET_POS = INT32_C(0);           /** @brief LPIET */
    static const int32_t ETHERNET_MAC_MACLMIR_TIC_1US_CNTR_POS = INT32_C(0);    /** @brief TIC_1US_CNTR */
    static const int32_t ETHERNET_MAC_MACLMIR_SNPSVER_POS = INT32_C(0);         /** @brief SNPSVER */
    static const int32_t ETHERNET_MAC_MACLMIR_USERVER_POS = INT32_C(8);         /** @brief USERVER */
    static const int32_t ETHERNET_MAC_MACLMIR_RXFIFOSIZE_POS = INT32_C(0);      /** @brief RXFIFOSIZE */
    static const int32_t ETHERNET_MAC_MACLMIR_TXFIFOSIZE_POS = INT32_C(6);      /** @brief TXFIFOSIZE */
    static const int32_t ETHERNET_MAC_MACLMIR_OSTEN_POS = INT32_C(11);          /** @brief OSTEN */
    static const int32_t ETHERNET_MAC_MACLMIR_PTOEN_POS = INT32_C(12);          /** @brief PTOEN */
    static const int32_t ETHERNET_MAC_MACLMIR_ADVTHWORD_POS = INT32_C(13);      /** @brief ADVTHWORD */
    static const int32_t ETHERNET_MAC_MACLMIR_DCBEN_POS = INT32_C(16);          /** @brief DCBEN */
    static const int32_t ETHERNET_MAC_MACLMIR_SPHEN_POS = INT32_C(17);          /** @brief SPHEN */
    static const int32_t ETHERNET_MAC_MACLMIR_TSOEN_POS = INT32_C(18);          /** @brief TSOEN */
    static const int32_t ETHERNET_MAC_MACLMIR_DBGMEMA_POS = INT32_C(19);        /** @brief DBGMEMA */
    static const int32_t ETHERNET_MAC_MACLMIR_AVSEL_POS = INT32_C(20);          /** @brief AVSEL */
    static const int32_t ETHERNET_MAC_MACLMIR_HASHTBLSZ_POS = INT32_C(24);      /** @brief HASHTBLSZ */
    static const int32_t ETHERNET_MAC_MACLMIR_L3L4FNUM_POS = INT32_C(27);       /** @brief L3L4FNUM */
    static const int32_t ETHERNET_MAC_MACLMIR_RXQCNT_POS = INT32_C(0);          /** @brief RXQCNT */
    static const int32_t ETHERNET_MAC_MACLMIR_TXQCNT_POS = INT32_C(6);          /** @brief TXQCNT */
    static const int32_t ETHERNET_MAC_MACLMIR_RXCHCNT_POS = INT32_C(12);        /** @brief RXCHCNT */
    static const int32_t ETHERNET_MAC_MACLMIR_TXCHCNT_POS = INT32_C(18);        /** @brief TXCHCNT */
    static const int32_t ETHERNET_MAC_MACLMIR_PPSOUTNUM_POS = INT32_C(24);      /** @brief PPSOUTNUM */
    static const int32_t ETHERNET_MAC_MACLMIR_AUXSNAPNUM_POS = INT32_C(28);     /** @brief AUXSNAPNUM */
    static const int32_t ETHERNET_MAC_MACLMIR_MB_POS = INT32_C(0);              /** @brief MB */
    static const int32_t ETHERNET_MAC_MACLMIR_C45E_POS = INT32_C(1);            /** @brief C45E */
    static const int32_t ETHERNET_MAC_MACLMIR_GOC_POS = INT32_C(2);             /** @brief GOC */
    static const int32_t ETHERNET_MAC_MACLMIR_SKAP_POS = INT32_C(4);            /** @brief SKAP */
    static const int32_t ETHERNET_MAC_MACLMIR_CR_POS = INT32_C(8);              /** @brief CR */
    static const int32_t ETHERNET_MAC_MACLMIR_NTC_POS = INT32_C(12);            /** @brief NTC */
    static const int32_t ETHERNET_MAC_MACLMIR_RDA_POS = INT32_C(16);            /** @brief RDA */
    static const int32_t ETHERNET_MAC_MACLMIR_PA_POS = INT32_C(21);             /** @brief PA */
    static const int32_t ETHERNET_MAC_MACLMIR_BTB_POS = INT32_C(26);            /** @brief BTB */
    static const int32_t ETHERNET_MAC_MACLMIR_PSE_POS = INT32_C(27);            /** @brief PSE */
    static const int32_t ETHERNET_MAC_MACLMIR_MD_POS = INT32_C(0);              /** @brief MD */
    static const int32_t ETHERNET_MAC_MACLMIR_RA_POS = INT32_C(16);             /** @brief RA */
    static const int32_t ETHERNET_MAC_MACLMIR_ADDRHI_POS = INT32_C(0);          /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACLMIR_AE_POS = INT32_C(31);             /** @brief AE */
    static const int32_t ETHERNET_MAC_MACLMIR_ADDRHI_POS = INT32_C(0);          /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACLMIR_MBC_POS = INT32_C(24);            /** @brief MBC */
    static const int32_t ETHERNET_MAC_MACLMIR_SA_POS = INT32_C(30);             /** @brief SA */
    static const int32_t ETHERNET_MAC_MACLMIR_AE_POS = INT32_C(31);             /** @brief AE */
    static const int32_t ETHERNET_MAC_MACLMIR_ADDRHI_POS = INT32_C(0);          /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACLMIR_MBC_POS = INT32_C(24);            /** @brief MBC */
    static const int32_t ETHERNET_MAC_MACLMIR_SA_POS = INT32_C(30);             /** @brief SA */
    static const int32_t ETHERNET_MAC_MACLMIR_AE_POS = INT32_C(31);             /** @brief AE */
    static const int32_t ETHERNET_MAC_MACLMIR_ADDRHI_POS = INT32_C(0);          /** @brief ADDRHI */
    static const int32_t ETHERNET_MAC_MACLMIR_MBC_POS = INT32_C(24);            /** @brief MBC */
    static const int32_t ETHERNET_MAC_MACLMIR_SA_POS = INT32_C(30);             /** @brief SA */
    static const int32_t ETHERNET_MAC_MACLMIR_AE_POS = INT32_C(31);             /** @brief AE */
    static const int32_t ETHERNET_MAC_MACLMIR_CNTRST_POS = INT32_C(0);          /** @brief CNTRST */
    static const int32_t ETHERNET_MAC_MACLMIR_CNTSTOPRO_POS = INT32_C(1);       /** @brief CNTSTOPRO */
    static const int32_t ETHERNET_MAC_MACLMIR_RSTONRD_POS = INT32_C(2);         /** @brief RSTONRD */
    static const int32_t ETHERNET_MAC_MACLMIR_CNTFREEZ_POS = INT32_C(3);        /** @brief CNTFREEZ */
    static const int32_t ETHERNET_MAC_MACLMIR_CNTPRST_POS = INT32_C(4);         /** @brief CNTPRST */
    static const int32_t ETHERNET_MAC_MACLMIR_CNTPRSTLVL_POS = INT32_C(5);      /** @brief CNTPRSTLVL */
    static const int32_t ETHERNET_MAC_MACLMIR_UCDBC_POS = INT32_C(8);           /** @brief UCDBC */
    static const int32_t ETHERNET_MAC_MACLMIR_RXCRCERPIS_POS = INT32_C(5);      /** @brief RXCRCERPIS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXALGNERPIS_POS = INT32_C(6);     /** @brief RXALGNERPIS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXUCGPIS_POS = INT32_C(17);       /** @brief RXUCGPIS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXLPIUSCIS_POS = INT32_C(26);     /** @brief RXLPIUSCIS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXLPITRCIS_POS = INT32_C(27);     /** @brief RXLPITRCIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXSCOLGPIS_POS = INT32_C(14);     /** @brief TXSCOLGPIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXMCOLGPIS_POS = INT32_C(15);     /** @brief TXMCOLGPIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXGPKTIS_POS = INT32_C(21);       /** @brief TXGPKTIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXLPIUSCIS_POS = INT32_C(26);     /** @brief TXLPIUSCIS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXLPITRCIS_POS = INT32_C(27);     /** @brief TXLPITRCIS */
    static const int32_t ETHERNET_MAC_MACLMIR_RXCRCERPIM_POS = INT32_C(5);      /** @brief RXCRCERPIM */
    static const int32_t ETHERNET_MAC_MACLMIR_RXALGNERPIM_POS = INT32_C(6);     /** @brief RXALGNERPIM */
    static const int32_t ETHERNET_MAC_MACLMIR_RXUCGPIM_POS = INT32_C(17);       /** @brief RXUCGPIM */
    static const int32_t ETHERNET_MAC_MACLMIR_RXLPIUSCIM_POS = INT32_C(26);     /** @brief RXLPIUSCIM */
    static const int32_t ETHERNET_MAC_MACLMIR_RXLPITRCIM_POS = INT32_C(27);     /** @brief RXLPITRCIM */
    static const int32_t ETHERNET_MAC_MACLMIR_TXSCOLGPIM_POS = INT32_C(14);     /** @brief TXSCOLGPIM */
    static const int32_t ETHERNET_MAC_MACLMIR_TXMCOLGPIM_POS = INT32_C(15);     /** @brief TXMCOLGPIM */
    static const int32_t ETHERNET_MAC_MACLMIR_TXGPKTIM_POS = INT32_C(21);       /** @brief TXGPKTIM */
    static const int32_t ETHERNET_MAC_MACLMIR_TXLPIUSCIM_POS = INT32_C(26);     /** @brief TXLPIUSCIM */
    static const int32_t ETHERNET_MAC_MACLMIR_TXLPITRCIM_POS = INT32_C(27);     /** @brief TXLPITRCIM */
    static const int32_t ETHERNET_MAC_MACLMIR_L3PEN0_POS = INT32_C(0);          /** @brief L3PEN0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3SAM0_POS = INT32_C(2);          /** @brief L3SAM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3SAIM0_POS = INT32_C(3);         /** @brief L3SAIM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3DAM0_POS = INT32_C(4);          /** @brief L3DAM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3DAIM0_POS = INT32_C(5);         /** @brief L3DAIM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3HSBM0_POS = INT32_C(6);         /** @brief L3HSBM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3HDBM0_POS = INT32_C(11);        /** @brief L3HDBM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4PEN0_POS = INT32_C(16);         /** @brief L4PEN0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4SPM0_POS = INT32_C(18);         /** @brief L4SPM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4SPIM0_POS = INT32_C(19);        /** @brief L4SPIM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4DPM0_POS = INT32_C(20);         /** @brief L4DPM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4DPIM0_POS = INT32_C(21);        /** @brief L4DPIM0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4SP0_POS = INT32_C(0);           /** @brief L4SP0 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4DP0_POS = INT32_C(16);          /** @brief L4DP0 */
    static const int32_t ETHERNET_MAC_MACLMIR_RPESTS_POS = INT32_C(0);          /** @brief RPESTS */
    static const int32_t ETHERNET_MAC_MACLMIR_RFCFCSTS_POS = INT32_C(1);        /** @brief RFCFCSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_TPESTS_POS = INT32_C(16);         /** @brief TPESTS */
    static const int32_t ETHERNET_MAC_MACLMIR_TFCSTS_POS = INT32_C(17);         /** @brief TFCSTS */
    static const int32_t ETHERNET_MAC_MACLMIR_L3PEN1_POS = INT32_C(0);          /** @brief L3PEN1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3SAM1_POS = INT32_C(2);          /** @brief L3SAM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3SAIM1_POS = INT32_C(3);         /** @brief L3SAIM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3DAM1_POS = INT32_C(4);          /** @brief L3DAM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3DAIM1_POS = INT32_C(5);         /** @brief L3DAIM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3HSBM1_POS = INT32_C(6);         /** @brief L3HSBM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L3HDBM1_POS = INT32_C(11);        /** @brief L3HDBM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4PEN1_POS = INT32_C(16);         /** @brief L4PEN1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4SPM1_POS = INT32_C(18);         /** @brief L4SPM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4SPIM1_POS = INT32_C(19);        /** @brief L4SPIM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4DPM1_POS = INT32_C(20);         /** @brief L4DPM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4DPIM1_POS = INT32_C(21);        /** @brief L4DPIM1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4SP1_POS = INT32_C(0);           /** @brief L4SP1 */
    static const int32_t ETHERNET_MAC_MACLMIR_L4DP1_POS = INT32_C(16);          /** @brief L4DP1 */
    static const int32_t ETHERNET_MAC_MACLMIR_TSENA_POS = INT32_C(0);           /** @brief TSENA */
    static const int32_t ETHERNET_MAC_MACLMIR_TSCFUPDT_POS = INT32_C(1);        /** @brief TSCFUPDT */
    static const int32_t ETHERNET_MAC_MACLMIR_TSINIT_POS = INT32_C(2);          /** @brief TSINIT */
    static const int32_t ETHERNET_MAC_MACLMIR_TSUPDT_POS = INT32_C(3);          /** @brief TSUPDT */
    static const int32_t ETHERNET_MAC_MACLMIR_TSADDREG_POS = INT32_C(5);        /** @brief TSADDREG */
    static const int32_t ETHERNET_MAC_MACLMIR_TSENALL_POS = INT32_C(8);         /** @brief TSENALL */
    static const int32_t ETHERNET_MAC_MACLMIR_TSCTRLSSR_POS = INT32_C(9);       /** @brief TSCTRLSSR */
    static const int32_t ETHERNET_MAC_MACLMIR_TSVER2ENA_POS = INT32_C(10);      /** @brief TSVER2ENA */
    static const int32_t ETHERNET_MAC_MACLMIR_TSIPENA_POS = INT32_C(11);        /** @brief TSIPENA */
    static const int32_t ETHERNET_MAC_MACLMIR_TSIPV6ENA_POS = INT32_C(12);      /** @brief TSIPV6ENA */
    static const int32_t ETHERNET_MAC_MACLMIR_TSIPV4ENA_POS = INT32_C(13);      /** @brief TSIPV4ENA */
    static const int32_t ETHERNET_MAC_MACLMIR_TSEVNTENA_POS = INT32_C(14);      /** @brief TSEVNTENA */
    static const int32_t ETHERNET_MAC_MACLMIR_TSMSTRENA_POS = INT32_C(15);      /** @brief TSMSTRENA */
    static const int32_t ETHERNET_MAC_MACLMIR_SNAPTYPSEL_POS = INT32_C(16);     /** @brief SNAPTYPSEL */
    static const int32_t ETHERNET_MAC_MACLMIR_TSENMACADDR_POS = INT32_C(18);    /** @brief TSENMACADDR */
    static const int32_t ETHERNET_MAC_MACLMIR_CSC_POS = INT32_C(19);            /** @brief CSC */
    static const int32_t ETHERNET_MAC_MACLMIR_TXTSSTSM_POS = INT32_C(24);       /** @brief TXTSSTSM */
    static const int32_t ETHERNET_MAC_MACLMIR_SNSINC_POS = INT32_C(8);          /** @brief SNSINC */
    static const int32_t ETHERNET_MAC_MACLMIR_SSINC_POS = INT32_C(16);          /** @brief SSINC */
    static const int32_t ETHERNET_MAC_MACLMIR_TSSS_POS = INT32_C(0);            /** @brief TSSS */
    static const int32_t ETHERNET_MAC_MACLMIR_TSSS_POS = INT32_C(0);            /** @brief TSSS */
    static const int32_t ETHERNET_MAC_MACLMIR_ADDSUB_POS = INT32_C(31);         /** @brief ADDSUB */
    static const int32_t ETHERNET_MAC_MACLMIR_TSSOVF_POS = INT32_C(0);          /** @brief TSSOVF */
    static const int32_t ETHERNET_MAC_MACLMIR_TSTARGT0_POS = INT32_C(1);        /** @brief TSTARGT0 */
    static const int32_t ETHERNET_MAC_MACLMIR_AUXTSTRIG_POS = INT32_C(2);       /** @brief AUXTSTRIG */
    static const int32_t ETHERNET_MAC_MACLMIR_TSTRGTERR0_POS = INT32_C(3);      /** @brief TSTRGTERR0 */
    static const int32_t ETHERNET_MAC_MACLMIR_TXTSSIS_POS = INT32_C(15);        /** @brief TXTSSIS */
    static const int32_t ETHERNET_MAC_MACLMIR_ATSSTN_POS = INT32_C(16);         /** @brief ATSSTN */
    static const int32_t ETHERNET_MAC_MACLMIR_ATSSTM_POS = INT32_C(24);         /** @brief ATSSTM */
    static const int32_t ETHERNET_MAC_MACLMIR_ATSNS_POS = INT32_C(25);          /** @brief ATSNS */
    static const int32_t ETHERNET_MAC_MACLMIR_TXTSSLO_POS = INT32_C(0);         /** @brief TXTSSLO */
    static const int32_t ETHERNET_MAC_MACLMIR_TXTSSMIS_POS = INT32_C(31);       /** @brief TXTSSMIS */
    static const int32_t ETHERNET_MAC_MACLMIR_ATSFC_POS = INT32_C(0);           /** @brief ATSFC */
    static const int32_t ETHERNET_MAC_MACLMIR_AUXTSLO_POS = INT32_C(0);         /** @brief AUXTSLO */
    static const int32_t ETHERNET_MAC_MACLMIR_PPSCTRL_POS = INT32_C(0);         /** @brief PPSCTRL */
    static const int32_t ETHERNET_MAC_MACLMIR_PPSEN0_POS = INT32_C(4);          /** @brief PPSEN0 */
    static const int32_t ETHERNET_MAC_MACLMIR_TRGTMODSEL0_POS = INT32_C(5);     /** @brief TRGTMODSEL0 */
    static const int32_t ETHERNET_MAC_MACLMIR_TSTRH0_POS = INT32_C(0);          /** @brief TSTRH0 */
    static const int32_t ETHERNET_MAC_MACLMIR_TTSL0_POS = INT32_C(0);           /** @brief TTSL0 */
    static const int32_t ETHERNET_MAC_MACLMIR_TRGTBUSY0_POS = INT32_C(31);      /** @brief TRGTBUSY0 */
    static const int32_t ETHERNET_MAC_MACLMIR_PTOEN_POS = INT32_C(0);           /** @brief PTOEN */
    static const int32_t ETHERNET_MAC_MACLMIR_ASYNCEN_POS = INT32_C(1);         /** @brief ASYNCEN */
    static const int32_t ETHERNET_MAC_MACLMIR_APDREQEN_POS = INT32_C(2);        /** @brief APDREQEN */
    static const int32_t ETHERNET_MAC_MACLMIR_ASYNCTRIG_POS = INT32_C(4);       /** @brief ASYNCTRIG */
    static const int32_t ETHERNET_MAC_MACLMIR_APDREQTRIG_POS = INT32_C(5);      /** @brief APDREQTRIG */
    static const int32_t ETHERNET_MAC_MACLMIR_DRRDIS_POS = INT32_C(6);          /** @brief DRRDIS */
    static const int32_t ETHERNET_MAC_MACLMIR_DN_POS = INT32_C(8);              /** @brief DN */
    static const int32_t ETHERNET_MAC_MACLMIR_SPI2_POS = INT32_C(0);            /** @brief SPI2 */
    static const int32_t ETHERNET_MAC_MACLMIR_LSI_POS = INT32_C(0);             /** @brief LSI */
    static const int32_t ETHERNET_MAC_MACLMIR_DRSYNCR_POS = INT32_C(8);         /** @brief DRSYNCR */
    static const int32_t ETHERNET_MAC_MACLMIR_LMPDRI_POS = INT32_C(24);         /** @brief LMPDRI */

    /**********************************************************************************************
     * @section DMAX Definitions
     **********************************************************************************************/

    /** @subsection DMAX IRQ interrupt array definitions */

    static const int32_t DMA_STRX_IRQ[7] = {
      INT32_C(11),    /** @brief DMA1 stream0 */
      INT32_C(12),    /** @brief DMA1 stream1 */
      INT32_C(13),    /** @brief DMA1 stream2 */
      INT32_C(14),    /** @brief DMA1 stream3 */
      INT32_C(15),    /** @brief DMA1 stream4 */
      INT32_C(16),    /** @brief DMA1 stream5 */
      INT32_C(17),    /** @brief DMA1 stream6 */
    };

    static const int32_t DMAX_STR7_IRQ[3] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(47),    /** @brief DMA1 stream7 */
      INT32_C(70),    /** @brief DMA2 stream7 interrupt */
    };

    /** @subsection DMAX register array definitions */

    static _RO uint32_t* const DMAX_LISR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40020000),   /** @brief Low interrupt status register */
      (_RO uint32_t* const)UINT32_C(0x40020400),   /** @brief Low interrupt status register */
    };

    static _RO uint32_t* const DMAX_HISR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40020004),   /** @brief High interrupt status register */
      (_RO uint32_t* const)UINT32_C(0x40020404),   /** @brief High interrupt status register */
    };

    static _RW uint32_t* const DMAX_LIFCR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40020008),   /** @brief Low interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x40020408),   /** @brief Low interrupt flag clear register */
    };

    static _RW uint32_t* const DMAX_HIFCR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4002000C),   /** @brief High interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x4002040C),   /** @brief High interrupt flag clear register */
    };

    static _RW uint32_t* const DMAX_S0CR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40020010),   /** @brief Stream x configuration register */
      (_RW uint32_t* const)UINT32_C(0x40020410),   /** @brief Stream x configuration register */
    };

    static _RW uint32_t* const DMAX_SXNDTR_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40020014),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x4002002C),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x40020044),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x4002005C),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x40020074),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x4002008C),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x400200A4),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x400200BC),   /** @brief Stream x number of data register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40020414),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x4002042C),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x40020444),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x4002045C),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x40020474),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x4002048C),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x400204A4),   /** @brief Stream x number of data register */
        (_RW uint32_t* const)UINT32_C(0x400204BC),   /** @brief Stream x number of data register */
      },
    };

    static _RW uint32_t* const DMAX_SXPAR_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40020018),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020030),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020048),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020060),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020078),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020090),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x400200A8),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x400200C0),   /** @brief Stream x peripheral address register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40020418),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020430),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020448),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020460),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020478),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x40020490),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x400204A8),   /** @brief Stream x peripheral address register */
        (_RW uint32_t* const)UINT32_C(0x400204C0),   /** @brief Stream x peripheral address register */
      },
    };

    static _RW uint32_t* const DMAX_SXM0AR_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x4002001C),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x40020034),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x4002004C),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x40020064),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x4002007C),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x40020094),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x400200AC),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x400200C4),   /** @brief Stream x memory 0 address register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x4002041C),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x40020434),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x4002044C),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x40020464),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x4002047C),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x40020494),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x400204AC),   /** @brief Stream x memory 0 address register */
        (_RW uint32_t* const)UINT32_C(0x400204C4),   /** @brief Stream x memory 0 address register */
      },
    };

    static _RW uint32_t* const DMAX_S0MXAR_REG[3][2] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40020020),   /** @brief Stream x memory 1 address register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40020420),   /** @brief Stream x memory 1 address register */
      },
    };

    static _RW uint32_t* const DMAX_SXFCR_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40020024),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x4002003C),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x40020054),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x4002006C),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x40020084),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x4002009C),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x400200B4),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x400200CC),   /** @brief Stream x FIFO control register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x40020424),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x4002043C),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x40020454),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x4002046C),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x40020484),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x4002049C),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x400204B4),   /** @brief Stream x FIFO control register */
        (_RW uint32_t* const)UINT32_C(0x400204CC),   /** @brief Stream x FIFO control register */
      },
    };

    static _RW uint32_t* const DMAX_SXCR_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40020028),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020040),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020058),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020070),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020088),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x400200A0),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x400200B8),   /** @brief Stream x configuration register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40020428),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020440),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020458),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020470),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x40020488),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x400204A0),   /** @brief Stream x configuration register */
        (_RW uint32_t* const)UINT32_C(0x400204B8),   /** @brief Stream x configuration register */
      },
    };

    static _RW uint32_t* const DMAX_SXM1AR_REG[3][8] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40020038),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020050),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020068),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020080),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020098),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x400200B0),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x400200C8),   /** @brief Stream x memory 1 address register */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40020438),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020450),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020468),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020480),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x40020498),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x400204B0),   /** @brief Stream x memory 1 address register */
        (_RW uint32_t* const)UINT32_C(0x400204C8),   /** @brief Stream x memory 1 address register */
      },
    };

    /** @subsection DMAX field mask array definitions */

    static const uint32_t DMAX_LISR_TCIFX_MASK[4] = {
      UINT32_C(0x00000020),   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      UINT32_C(0x00000800),   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      UINT32_C(0x00200000),   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      UINT32_C(0x08000000),   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAX_LISR_HTIFX_MASK[4] = {
      UINT32_C(0x00000010),   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      UINT32_C(0x00000400),   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      UINT32_C(0x00100000),   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      UINT32_C(0x04000000),   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    };

    static const uint32_t DMAX_LISR_TEIFX_MASK[4] = {
      UINT32_C(0x00000008),   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      UINT32_C(0x00000200),   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      UINT32_C(0x00080000),   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      UINT32_C(0x02000000),   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    };

    static const uint32_t DMAX_LISR_DMEIFX_MASK[4] = {
      UINT32_C(0x00000004),   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      UINT32_C(0x00000100),   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      UINT32_C(0x00040000),   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      UINT32_C(0x01000000),   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    };

    static const uint32_t DMAX_LISR_FEIFX_MASK[4] = {
      UINT32_C(0x00000001),   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      UINT32_C(0x00000040),   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      UINT32_C(0x00010000),   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      UINT32_C(0x00400000),   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    };

    static const uint32_t DMAX_LIFCR_CTCIFX_MASK[4] = {
      UINT32_C(0x00000020),   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      UINT32_C(0x00000800),   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      UINT32_C(0x00200000),   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      UINT32_C(0x08000000),   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAX_LIFCR_CHTIFX_MASK[4] = {
      UINT32_C(0x00000010),   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      UINT32_C(0x00000400),   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      UINT32_C(0x00100000),   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      UINT32_C(0x04000000),   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAX_LIFCR_CTEIFX_MASK[4] = {
      UINT32_C(0x00000008),   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      UINT32_C(0x00000200),   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      UINT32_C(0x00080000),   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      UINT32_C(0x02000000),   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAX_LIFCR_CDMEIFX_MASK[4] = {
      UINT32_C(0x00000004),   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      UINT32_C(0x00000100),   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      UINT32_C(0x00040000),   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      UINT32_C(0x01000000),   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    };

    static const uint32_t DMAX_LIFCR_CFEIFX_MASK[4] = {
      UINT32_C(0x00000001),   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      UINT32_C(0x00000040),   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      UINT32_C(0x00010000),   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      UINT32_C(0x00400000),   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    };

    /** @subsection DMAX field mask definitions */

    static const uint32_t DMAX_S0CR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_S0CR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_S0CR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_S0CR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_S0CR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_S0CR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_S0CR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_S0CR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_S0CR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_S0CR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_S0CR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_S0CR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_S0CR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_S0CR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_S0CR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_S0CR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_S0CR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_S0CR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */
    static const uint32_t DMAX_SXCR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_SXCR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_SXCR_ACK_MASK = UINT32_C(0x00100000);      /** @brief ACK */
    static const uint32_t DMAX_SXCR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_SXCR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_SXCR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_SXCR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_SXCR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_SXCR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_SXCR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_SXCR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_SXCR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_SXCR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_SXCR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_SXCR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_SXCR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_SXCR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_SXCR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_SXCR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */
    static const uint32_t DMAX_SXCR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_SXCR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_SXCR_ACK_MASK = UINT32_C(0x00100000);      /** @brief ACK */
    static const uint32_t DMAX_SXCR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_SXCR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_SXCR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_SXCR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_SXCR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_SXCR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_SXCR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_SXCR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_SXCR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_SXCR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_SXCR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_SXCR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_SXCR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_SXCR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_SXCR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_SXCR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */
    static const uint32_t DMAX_SXCR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_SXCR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_SXCR_ACK_MASK = UINT32_C(0x00100000);      /** @brief ACK */
    static const uint32_t DMAX_SXCR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_SXCR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_SXCR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_SXCR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_SXCR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_SXCR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_SXCR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_SXCR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_SXCR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_SXCR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_SXCR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_SXCR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_SXCR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_SXCR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_SXCR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_SXCR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */
    static const uint32_t DMAX_SXCR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_SXCR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_SXCR_ACK_MASK = UINT32_C(0x00100000);      /** @brief ACK */
    static const uint32_t DMAX_SXCR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_SXCR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_SXCR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_SXCR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_SXCR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_SXCR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_SXCR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_SXCR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_SXCR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_SXCR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_SXCR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_SXCR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_SXCR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_SXCR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_SXCR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_SXCR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */
    static const uint32_t DMAX_SXCR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_SXCR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_SXCR_ACK_MASK = UINT32_C(0x00100000);      /** @brief ACK */
    static const uint32_t DMAX_SXCR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_SXCR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_SXCR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_SXCR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_SXCR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_SXCR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_SXCR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_SXCR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_SXCR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_SXCR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_SXCR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_SXCR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_SXCR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_SXCR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_SXCR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_SXCR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */
    static const uint32_t DMAX_SXCR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_SXCR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_SXCR_ACK_MASK = UINT32_C(0x00100000);      /** @brief ACK */
    static const uint32_t DMAX_SXCR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_SXCR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_SXCR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_SXCR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_SXCR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_SXCR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_SXCR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_SXCR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_SXCR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_SXCR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_SXCR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_SXCR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_SXCR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_SXCR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_SXCR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_SXCR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */
    static const uint32_t DMAX_SXCR_MBURST_MASK = UINT32_C(0x01800000);   /** @brief Memory burst transfer configuration */
    static const uint32_t DMAX_SXCR_PBURST_MASK = UINT32_C(0x00600000);   /** @brief Peripheral burst transfer configuration */
    static const uint32_t DMAX_SXCR_ACK_MASK = UINT32_C(0x00100000);      /** @brief ACK */
    static const uint32_t DMAX_SXCR_CT_MASK = UINT32_C(0x00080000);       /** @brief Current target (only in double buffer mode) */
    static const uint32_t DMAX_SXCR_DBM_MASK = UINT32_C(0x00040000);      /** @brief Double buffer mode */
    static const uint32_t DMAX_SXCR_PL_MASK = UINT32_C(0x00030000);       /** @brief Priority level */
    static const uint32_t DMAX_SXCR_PINCOS_MASK = UINT32_C(0x00008000);   /** @brief Peripheral increment offset size */
    static const uint32_t DMAX_SXCR_MSIZE_MASK = UINT32_C(0x00006000);    /** @brief Memory data size */
    static const uint32_t DMAX_SXCR_PSIZE_MASK = UINT32_C(0x00001800);    /** @brief Peripheral data size */
    static const uint32_t DMAX_SXCR_MINC_MASK = UINT32_C(0x00000400);     /** @brief Memory increment mode */
    static const uint32_t DMAX_SXCR_PINC_MASK = UINT32_C(0x00000200);     /** @brief Peripheral increment mode */
    static const uint32_t DMAX_SXCR_CIRC_MASK = UINT32_C(0x00000100);     /** @brief Circular mode */
    static const uint32_t DMAX_SXCR_DIR_MASK = UINT32_C(0x000000C0);      /** @brief Data transfer direction */
    static const uint32_t DMAX_SXCR_PFCTRL_MASK = UINT32_C(0x00000020);   /** @brief Peripheral flow controller */
    static const uint32_t DMAX_SXCR_TCIE_MASK = UINT32_C(0x00000010);     /** @brief Transfer complete interrupt enable */
    static const uint32_t DMAX_SXCR_HTIE_MASK = UINT32_C(0x00000008);     /** @brief Half transfer interrupt enable */
    static const uint32_t DMAX_SXCR_TEIE_MASK = UINT32_C(0x00000004);     /** @brief Transfer error interrupt enable */
    static const uint32_t DMAX_SXCR_DMEIE_MASK = UINT32_C(0x00000002);    /** @brief Direct mode error interrupt enable */
    static const uint32_t DMAX_SXCR_EN_MASK = UINT32_C(0x00000001);       /** @brief Stream enable / flag stream ready when read low */
    static const uint32_t DMAX_SXNDTR_NDT_MASK = UINT32_C(0x0000FFFF);    /** @brief Number of data items to transfer */
    static const uint32_t DMAX_SXFCR_FEIE_MASK = UINT32_C(0x00000080);    /** @brief FIFO error interrupt enable */
    static const uint32_t DMAX_SXFCR_FS_MASK = UINT32_C(0x00000038);      /** @brief FIFO status */
    static const uint32_t DMAX_SXFCR_DMDIS_MASK = UINT32_C(0x00000004);   /** @brief Direct mode disable */
    static const uint32_t DMAX_SXFCR_FTH_MASK = UINT32_C(0x00000003);     /** @brief FIFO threshold selection */

    /** @subsection DMAX field position array definitions */

    static const int32_t DMAX_SXFCR_TCIFX_POS[4] = {
      INT32_C(5),    /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      INT32_C(11),   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      INT32_C(21),   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
      INT32_C(27),   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    };

    static const int32_t DMAX_SXFCR_HTIFX_POS[4] = {
      INT32_C(4),    /** @brief Stream x half transfer interrupt flag (x=3..0) */
      INT32_C(10),   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      INT32_C(20),   /** @brief Stream x half transfer interrupt flag (x=3..0) */
      INT32_C(26),   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    };

    static const int32_t DMAX_SXFCR_TEIFX_POS[4] = {
      INT32_C(3),    /** @brief Stream x transfer error interrupt flag (x=3..0) */
      INT32_C(9),    /** @brief Stream x transfer error interrupt flag (x=3..0) */
      INT32_C(19),   /** @brief Stream x transfer error interrupt flag (x=3..0) */
      INT32_C(25),   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    };

    static const int32_t DMAX_SXFCR_DMEIFX_POS[4] = {
      INT32_C(2),    /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      INT32_C(8),    /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      INT32_C(18),   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
      INT32_C(24),   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    };

    static const int32_t DMAX_SXFCR_FEIFX_POS[4] = {
      INT32_C(0),    /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      INT32_C(6),    /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      INT32_C(16),   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      INT32_C(22),   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    };

    static const int32_t DMAX_SXFCR_CTCIFX_POS[4] = {
      INT32_C(5),    /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      INT32_C(11),   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      INT32_C(21),   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
      INT32_C(27),   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    };

    static const int32_t DMAX_SXFCR_CHTIFX_POS[4] = {
      INT32_C(4),    /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      INT32_C(10),   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      INT32_C(20),   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
      INT32_C(26),   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    };

    static const int32_t DMAX_SXFCR_CTEIFX_POS[4] = {
      INT32_C(3),    /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      INT32_C(9),    /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      INT32_C(19),   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
      INT32_C(25),   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    };

    static const int32_t DMAX_SXFCR_CDMEIFX_POS[4] = {
      INT32_C(2),    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      INT32_C(8),    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      INT32_C(18),   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
      INT32_C(24),   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    };

    static const int32_t DMAX_SXFCR_CFEIFX_POS[4] = {
      INT32_C(0),    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      INT32_C(6),    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      INT32_C(16),   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      INT32_C(22),   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    };

    /** @subsection DMAX field position definitions */

    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */
    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_ACK_POS = INT32_C(20);      /** @brief ACK */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */
    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_ACK_POS = INT32_C(20);      /** @brief ACK */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */
    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_ACK_POS = INT32_C(20);      /** @brief ACK */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */
    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_ACK_POS = INT32_C(20);      /** @brief ACK */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */
    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_ACK_POS = INT32_C(20);      /** @brief ACK */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */
    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_ACK_POS = INT32_C(20);      /** @brief ACK */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */
    static const int32_t DMAX_SXFCR_MBURST_POS = INT32_C(23);   /** @brief Memory burst transfer configuration */
    static const int32_t DMAX_SXFCR_PBURST_POS = INT32_C(21);   /** @brief Peripheral burst transfer configuration */
    static const int32_t DMAX_SXFCR_ACK_POS = INT32_C(20);      /** @brief ACK */
    static const int32_t DMAX_SXFCR_CT_POS = INT32_C(19);       /** @brief Current target (only in double buffer mode) */
    static const int32_t DMAX_SXFCR_DBM_POS = INT32_C(18);      /** @brief Double buffer mode */
    static const int32_t DMAX_SXFCR_PL_POS = INT32_C(16);       /** @brief Priority level */
    static const int32_t DMAX_SXFCR_PINCOS_POS = INT32_C(15);   /** @brief Peripheral increment offset size */
    static const int32_t DMAX_SXFCR_MSIZE_POS = INT32_C(13);    /** @brief Memory data size */
    static const int32_t DMAX_SXFCR_PSIZE_POS = INT32_C(11);    /** @brief Peripheral data size */
    static const int32_t DMAX_SXFCR_MINC_POS = INT32_C(10);     /** @brief Memory increment mode */
    static const int32_t DMAX_SXFCR_PINC_POS = INT32_C(9);      /** @brief Peripheral increment mode */
    static const int32_t DMAX_SXFCR_CIRC_POS = INT32_C(8);      /** @brief Circular mode */
    static const int32_t DMAX_SXFCR_DIR_POS = INT32_C(6);       /** @brief Data transfer direction */
    static const int32_t DMAX_SXFCR_PFCTRL_POS = INT32_C(5);    /** @brief Peripheral flow controller */
    static const int32_t DMAX_SXFCR_TCIE_POS = INT32_C(4);      /** @brief Transfer complete interrupt enable */
    static const int32_t DMAX_SXFCR_HTIE_POS = INT32_C(3);      /** @brief Half transfer interrupt enable */
    static const int32_t DMAX_SXFCR_TEIE_POS = INT32_C(2);      /** @brief Transfer error interrupt enable */
    static const int32_t DMAX_SXFCR_DMEIE_POS = INT32_C(1);     /** @brief Direct mode error interrupt enable */
    static const int32_t DMAX_SXFCR_EN_POS = INT32_C(0);        /** @brief Stream enable / flag stream ready when read low */
    static const int32_t DMAX_SXFCR_NDT_POS = INT32_C(0);       /** @brief Number of data items to transfer */
    static const int32_t DMAX_SXFCR_FEIE_POS = INT32_C(7);      /** @brief FIFO error interrupt enable */
    static const int32_t DMAX_SXFCR_FS_POS = INT32_C(3);        /** @brief FIFO status */
    static const int32_t DMAX_SXFCR_DMDIS_POS = INT32_C(2);     /** @brief Direct mode disable */
    static const int32_t DMAX_SXFCR_FTH_POS = INT32_C(0);       /** @brief FIFO threshold selection */

    /**********************************************************************************************
     * @section HRTIM_MASTER Definitions
     **********************************************************************************************/

    /** @subsection HRTIM_MASTER register array definitions */

    static _RW uint32_t* const HRTIM_MASTER_MCMPXR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001741C),   /** @brief Master timer compare 1 register */
      (_RW uint32_t* const)UINT32_C(0x40017424),   /** @brief Master timer compare 2 register */
      (_RW uint32_t* const)UINT32_C(0x40017428),   /** @brief Master timer compare 3 register */
      (_RW uint32_t* const)UINT32_C(0x4001742C),   /** @brief Master timer compare 4 register */
    };

    /** @subsection HRTIM_MASTER register definitions */

    static _RW uint32_t* const HRTIM_MASTER_MCR_REG = (_RW uint32_t* const)UINT32_C(0x40017400);      /** @brief Master timer control register */
    static _RO uint32_t* const HRTIM_MASTER_MISR_REG = (_RO uint32_t* const)UINT32_C(0x40017404);     /** @brief Master timer interrupt status register */
    static _RW uint32_t* const HRTIM_MASTER_MICR_REG = (_RW uint32_t* const)UINT32_C(0x40017408);     /** @brief Master timer interrupt clear register */
    static _RW uint32_t* const HRTIM_MASTER_MDIER4_REG = (_RW uint32_t* const)UINT32_C(0x4001740C);   /** @brief MDIER4 */
    static _RW uint32_t* const HRTIM_MASTER_MCNTR_REG = (_RW uint32_t* const)UINT32_C(0x40017410);    /** @brief Master timer counter register */
    static _RW uint32_t* const HRTIM_MASTER_MPER_REG = (_RW uint32_t* const)UINT32_C(0x40017414);     /** @brief Master timer period register */
    static _RW uint32_t* const HRTIM_MASTER_MREP_REG = (_RW uint32_t* const)UINT32_C(0x40017418);     /** @brief Master timer repetition register */

    /** @subsection HRTIM_MASTER field mask array definitions */

    static const uint32_t HRTIM_MASTER_MISR_MCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Master compare 1 interrupt flag */
      UINT32_C(0x00000002),   /** @brief Master compare 2 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Master compare 3 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Master compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_MASTER_MICR_MCMPXC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Master compare 1 interrupt flag clear */
      UINT32_C(0x00000002),   /** @brief Master compare 2 interrupt flag clear */
      UINT32_C(0x00000004),   /** @brief Master compare 3 interrupt flag clear */
      UINT32_C(0x00000008),   /** @brief Master compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_MASTER_MDIER4_MCMPXDE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief MCMP1DE */
      UINT32_C(0x00020000),   /** @brief MCMP2DE */
      UINT32_C(0x00040000),   /** @brief MCMP3DE */
      UINT32_C(0x00080000),   /** @brief MCMP4DE */
    };

    static const uint32_t HRTIM_MASTER_MDIER4_MCMPXIE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief MCMP1IE */
      UINT32_C(0x00000002),   /** @brief MCMP2IE */
      UINT32_C(0x00000004),   /** @brief MCMP3IE */
      UINT32_C(0x00000008),   /** @brief MCMP4IE */
    };

    /** @subsection HRTIM_MASTER field mask definitions */

    static const uint32_t HRTIM_MASTER_MCR_BRSTDMA_MASK = UINT32_C(0xC0000000);     /** @brief Burst DMA update */
    static const uint32_t HRTIM_MASTER_MCR_MREPU_MASK = UINT32_C(0x20000000);       /** @brief Master timer repetition update */
    static const uint32_t HRTIM_MASTER_MCR_PREEN_MASK = UINT32_C(0x08000000);       /** @brief Preload enable */
    static const uint32_t HRTIM_MASTER_MCR_DACSYNC_MASK = UINT32_C(0x06000000);     /** @brief AC synchronization */
    static const uint32_t HRTIM_MASTER_MCR_TECEN_MASK = UINT32_C(0x00200000);       /** @brief Timer E counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TDCEN_MASK = UINT32_C(0x00100000);       /** @brief Timer D counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TCCEN_MASK = UINT32_C(0x00080000);       /** @brief Timer C counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TBCEN_MASK = UINT32_C(0x00040000);       /** @brief Timer B counter enable */
    static const uint32_t HRTIM_MASTER_MCR_TACEN_MASK = UINT32_C(0x00020000);       /** @brief Timer A counter enable */
    static const uint32_t HRTIM_MASTER_MCR_MCEN_MASK = UINT32_C(0x00010000);        /** @brief Master counter enable */
    static const uint32_t HRTIM_MASTER_MCR_SYNC_SRC_MASK = UINT32_C(0x0000C000);    /** @brief Synchronization source */
    static const uint32_t HRTIM_MASTER_MCR_SYNC_OUT_MASK = UINT32_C(0x00003000);    /** @brief Synchronization output */
    static const uint32_t HRTIM_MASTER_MCR_SYNCSTRTM_MASK = UINT32_C(0x00000800);   /** @brief Synchronization starts master */
    static const uint32_t HRTIM_MASTER_MCR_SYNCRSTM_MASK = UINT32_C(0x00000400);    /** @brief Synchronization resets master */
    static const uint32_t HRTIM_MASTER_MCR_SYNC_IN_MASK = UINT32_C(0x00000300);     /** @brief Ynchronization input */
    static const uint32_t HRTIM_MASTER_MCR_HALF_MASK = UINT32_C(0x00000020);        /** @brief Half mode enable */
    static const uint32_t HRTIM_MASTER_MCR_RETRIG_MASK = UINT32_C(0x00000010);      /** @brief Master re-triggerable mode */
    static const uint32_t HRTIM_MASTER_MCR_CONT_MASK = UINT32_C(0x00000008);        /** @brief Master continuous mode */
    static const uint32_t HRTIM_MASTER_MCR_CK_PSC_MASK = UINT32_C(0x00000007);      /** @brief HRTIM master clock prescaler */
    static const uint32_t HRTIM_MASTER_MISR_MUPD_MASK = UINT32_C(0x00000040);       /** @brief Master update interrupt flag */
    static const uint32_t HRTIM_MASTER_MISR_SYNC_MASK = UINT32_C(0x00000020);       /** @brief Sync input interrupt flag */
    static const uint32_t HRTIM_MASTER_MISR_MREP_MASK = UINT32_C(0x00000010);       /** @brief Master repetition interrupt flag */
    static const uint32_t HRTIM_MASTER_MICR_MUPDC_MASK = UINT32_C(0x00000040);      /** @brief Master update interrupt flag clear */
    static const uint32_t HRTIM_MASTER_MICR_SYNCC_MASK = UINT32_C(0x00000020);      /** @brief Sync input interrupt flag clear */
    static const uint32_t HRTIM_MASTER_MICR_MREPC_MASK = UINT32_C(0x00000010);      /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_MASTER_MDIER4_MUPDDE_MASK = UINT32_C(0x00400000);   /** @brief MUPDDE */
    static const uint32_t HRTIM_MASTER_MDIER4_SYNCDE_MASK = UINT32_C(0x00200000);   /** @brief SYNCDE */
    static const uint32_t HRTIM_MASTER_MDIER4_MREPDE_MASK = UINT32_C(0x00100000);   /** @brief MREPDE */
    static const uint32_t HRTIM_MASTER_MDIER4_MUPDIE_MASK = UINT32_C(0x00000040);   /** @brief MUPDIE */
    static const uint32_t HRTIM_MASTER_MDIER4_SYNCIE_MASK = UINT32_C(0x00000020);   /** @brief SYNCIE */
    static const uint32_t HRTIM_MASTER_MDIER4_MREPIE_MASK = UINT32_C(0x00000010);   /** @brief MREPIE */
    static const uint32_t HRTIM_MASTER_MCNTR_MCNT_MASK = UINT32_C(0x0000FFFF);      /** @brief Counter value */
    static const uint32_t HRTIM_MASTER_MPER_MPER_MASK = UINT32_C(0x0000FFFF);       /** @brief Master timer period value */
    static const uint32_t HRTIM_MASTER_MREP_MREP_MASK = UINT32_C(0x000000FF);       /** @brief Master timer repetition counter value */
    static const uint32_t HRTIM_MASTER_MCMPXR_MCMP1_MASK = UINT32_C(0x0000FFFF);    /** @brief Master timer compare 1 value */
    static const uint32_t HRTIM_MASTER_MCMPXR_MCMP2_MASK = UINT32_C(0x0000FFFF);    /** @brief Master timer compare 2 value */
    static const uint32_t HRTIM_MASTER_MCMPXR_MCMP3_MASK = UINT32_C(0x0000FFFF);    /** @brief Master timer compare 3 value */
    static const uint32_t HRTIM_MASTER_MCMPXR_MCMP4_MASK = UINT32_C(0x0000FFFF);    /** @brief Master timer compare 4 value */

    /** @subsection HRTIM_MASTER field position array definitions */

    static const int32_t HRTIM_MASTER_MCMPXR_MCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Master compare 1 interrupt flag */
      INT32_C(1),    /** @brief Master compare 2 interrupt flag */
      INT32_C(2),    /** @brief Master compare 3 interrupt flag */
      INT32_C(3),    /** @brief Master compare 4 interrupt flag */
    };

    static const int32_t HRTIM_MASTER_MCMPXR_MCMPXC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Master compare 1 interrupt flag clear */
      INT32_C(1),    /** @brief Master compare 2 interrupt flag clear */
      INT32_C(2),    /** @brief Master compare 3 interrupt flag clear */
      INT32_C(3),    /** @brief Master compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_MASTER_MCMPXR_MCMPXDE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief MCMP1DE */
      INT32_C(17),   /** @brief MCMP2DE */
      INT32_C(18),   /** @brief MCMP3DE */
      INT32_C(19),   /** @brief MCMP4DE */
    };

    static const int32_t HRTIM_MASTER_MCMPXR_MCMPXIE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief MCMP1IE */
      INT32_C(1),    /** @brief MCMP2IE */
      INT32_C(2),    /** @brief MCMP3IE */
      INT32_C(3),    /** @brief MCMP4IE */
    };

    /** @subsection HRTIM_MASTER field position definitions */

    static const int32_t HRTIM_MASTER_MCMPXR_BRSTDMA_POS = INT32_C(30);     /** @brief Burst DMA update */
    static const int32_t HRTIM_MASTER_MCMPXR_MREPU_POS = INT32_C(29);       /** @brief Master timer repetition update */
    static const int32_t HRTIM_MASTER_MCMPXR_PREEN_POS = INT32_C(27);       /** @brief Preload enable */
    static const int32_t HRTIM_MASTER_MCMPXR_DACSYNC_POS = INT32_C(25);     /** @brief AC synchronization */
    static const int32_t HRTIM_MASTER_MCMPXR_TECEN_POS = INT32_C(21);       /** @brief Timer E counter enable */
    static const int32_t HRTIM_MASTER_MCMPXR_TDCEN_POS = INT32_C(20);       /** @brief Timer D counter enable */
    static const int32_t HRTIM_MASTER_MCMPXR_TCCEN_POS = INT32_C(19);       /** @brief Timer C counter enable */
    static const int32_t HRTIM_MASTER_MCMPXR_TBCEN_POS = INT32_C(18);       /** @brief Timer B counter enable */
    static const int32_t HRTIM_MASTER_MCMPXR_TACEN_POS = INT32_C(17);       /** @brief Timer A counter enable */
    static const int32_t HRTIM_MASTER_MCMPXR_MCEN_POS = INT32_C(16);        /** @brief Master counter enable */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNC_SRC_POS = INT32_C(14);    /** @brief Synchronization source */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNC_OUT_POS = INT32_C(12);    /** @brief Synchronization output */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNCSTRTM_POS = INT32_C(11);   /** @brief Synchronization starts master */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNCRSTM_POS = INT32_C(10);    /** @brief Synchronization resets master */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNC_IN_POS = INT32_C(8);      /** @brief Ynchronization input */
    static const int32_t HRTIM_MASTER_MCMPXR_HALF_POS = INT32_C(5);         /** @brief Half mode enable */
    static const int32_t HRTIM_MASTER_MCMPXR_RETRIG_POS = INT32_C(4);       /** @brief Master re-triggerable mode */
    static const int32_t HRTIM_MASTER_MCMPXR_CONT_POS = INT32_C(3);         /** @brief Master continuous mode */
    static const int32_t HRTIM_MASTER_MCMPXR_CK_PSC_POS = INT32_C(0);       /** @brief HRTIM master clock prescaler */
    static const int32_t HRTIM_MASTER_MCMPXR_MUPD_POS = INT32_C(6);         /** @brief Master update interrupt flag */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNC_POS = INT32_C(5);         /** @brief Sync input interrupt flag */
    static const int32_t HRTIM_MASTER_MCMPXR_MREP_POS = INT32_C(4);         /** @brief Master repetition interrupt flag */
    static const int32_t HRTIM_MASTER_MCMPXR_MUPDC_POS = INT32_C(6);        /** @brief Master update interrupt flag clear */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNCC_POS = INT32_C(5);        /** @brief Sync input interrupt flag clear */
    static const int32_t HRTIM_MASTER_MCMPXR_MREPC_POS = INT32_C(4);        /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_MASTER_MCMPXR_MUPDDE_POS = INT32_C(22);      /** @brief MUPDDE */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNCDE_POS = INT32_C(21);      /** @brief SYNCDE */
    static const int32_t HRTIM_MASTER_MCMPXR_MREPDE_POS = INT32_C(20);      /** @brief MREPDE */
    static const int32_t HRTIM_MASTER_MCMPXR_MUPDIE_POS = INT32_C(6);       /** @brief MUPDIE */
    static const int32_t HRTIM_MASTER_MCMPXR_SYNCIE_POS = INT32_C(5);       /** @brief SYNCIE */
    static const int32_t HRTIM_MASTER_MCMPXR_MREPIE_POS = INT32_C(4);       /** @brief MREPIE */
    static const int32_t HRTIM_MASTER_MCMPXR_MCNT_POS = INT32_C(0);         /** @brief Counter value */
    static const int32_t HRTIM_MASTER_MCMPXR_MPER_POS = INT32_C(0);         /** @brief Master timer period value */
    static const int32_t HRTIM_MASTER_MCMPXR_MREP_POS = INT32_C(0);         /** @brief Master timer repetition counter value */
    static const int32_t HRTIM_MASTER_MCMPXR_MCMP1_POS = INT32_C(0);        /** @brief Master timer compare 1 value */
    static const int32_t HRTIM_MASTER_MCMPXR_MCMP2_POS = INT32_C(0);        /** @brief Master timer compare 2 value */
    static const int32_t HRTIM_MASTER_MCMPXR_MCMP3_POS = INT32_C(0);        /** @brief Master timer compare 3 value */
    static const int32_t HRTIM_MASTER_MCMPXR_MCMP4_POS = INT32_C(0);        /** @brief Master timer compare 4 value */

    /**********************************************************************************************
     * @section HRTIM_TIMA Definitions
     **********************************************************************************************/

    /** @subsection HRTIM_TIMA IRQ interrupt definitions */

    static const int32_t HRTIM1_MST_IRQ = INT32_C(103);   /** @brief HRTIM1 master timer interrupt */
    static const int32_t HRTIM1_FLT_IRQ = INT32_C(109);   /** @brief HRTIM1 fault interrupt */

    /** @subsection HRTIM_TIMA register array definitions */

    static _RW uint32_t* const HRTIM_TIMA_CMPXAR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001749C),   /** @brief Timerx compare 1 register */
      (_RW uint32_t* const)UINT32_C(0x400174A4),   /** @brief Timerx compare 2 register */
      (_RW uint32_t* const)UINT32_C(0x400174A8),   /** @brief Timerx compare 3 register */
      (_RW uint32_t* const)UINT32_C(0x400174AC),   /** @brief Timerx compare 4 register */
    };

    /** @subsection HRTIM_TIMA register definitions */

    static _RW uint32_t* const HRTIM_TIMA_TIMACR_REG = (_RW uint32_t* const)UINT32_C(0x40017480);      /** @brief Timerx control register */
    static _RO uint32_t* const HRTIM_TIMA_TIMAISR_REG = (_RO uint32_t* const)UINT32_C(0x40017484);     /** @brief Timerx interrupt status register */
    static _RW uint32_t* const HRTIM_TIMA_TIMAICR_REG = (_RW uint32_t* const)UINT32_C(0x40017488);     /** @brief Timerx interrupt clear register */
    static _RW uint32_t* const HRTIM_TIMA_TIMADIER5_REG = (_RW uint32_t* const)UINT32_C(0x4001748C);   /** @brief TIMxDIER5 */
    static _RW uint32_t* const HRTIM_TIMA_CNTAR_REG = (_RW uint32_t* const)UINT32_C(0x40017490);       /** @brief Timerx counter register */
    static _RW uint32_t* const HRTIM_TIMA_PERAR_REG = (_RW uint32_t* const)UINT32_C(0x40017494);       /** @brief Timerx period register */
    static _RW uint32_t* const HRTIM_TIMA_REPAR_REG = (_RW uint32_t* const)UINT32_C(0x40017498);       /** @brief Timerx repetition register */
    static _RW uint32_t* const HRTIM_TIMA_CMP1CAR_REG = (_RW uint32_t* const)UINT32_C(0x400174A0);     /** @brief Timerx compare 1 compound register */
    static _RO uint32_t* const HRTIM_TIMA_CPT1AR_REG = (_RO uint32_t* const)UINT32_C(0x400174B0);      /** @brief Timerx capture 1 register */
    static _RO uint32_t* const HRTIM_TIMA_CPT2AR_REG = (_RO uint32_t* const)UINT32_C(0x400174B4);      /** @brief Timerx capture 2 register */
    static _RW uint32_t* const HRTIM_TIMA_DTAR_REG = (_RW uint32_t* const)UINT32_C(0x400174B8);        /** @brief Timerx deadtime register */
    static _RW uint32_t* const HRTIM_TIMA_SETA1R_REG = (_RW uint32_t* const)UINT32_C(0x400174BC);      /** @brief Timerx output1 set register */
    static _RW uint32_t* const HRTIM_TIMA_RSTA1R_REG = (_RW uint32_t* const)UINT32_C(0x400174C0);      /** @brief Timerx output1 reset register */
    static _RW uint32_t* const HRTIM_TIMA_SETA2R_REG = (_RW uint32_t* const)UINT32_C(0x400174C4);      /** @brief Timerx output2 set register */
    static _RW uint32_t* const HRTIM_TIMA_RSTA2R_REG = (_RW uint32_t* const)UINT32_C(0x400174C8);      /** @brief Timerx output2 reset register */
    static _RW uint32_t* const HRTIM_TIMA_EEFAR1_REG = (_RW uint32_t* const)UINT32_C(0x400174CC);      /** @brief Timerx external event filtering register 1 */
    static _RW uint32_t* const HRTIM_TIMA_EEFAR2_REG = (_RW uint32_t* const)UINT32_C(0x400174D0);      /** @brief Timerx external event filtering register 2 */
    static _RW uint32_t* const HRTIM_TIMA_RSTAR_REG = (_RW uint32_t* const)UINT32_C(0x400174D4);       /** @brief TimerA reset register */
    static _RW uint32_t* const HRTIM_TIMA_CHPAR_REG = (_RW uint32_t* const)UINT32_C(0x400174D8);       /** @brief Timerx chopper register */
    static _RW uint32_t* const HRTIM_TIMA_CPT1ACR_REG = (_RW uint32_t* const)UINT32_C(0x400174DC);     /** @brief Timerx capture 2 control register */
    static _RW uint32_t* const HRTIM_TIMA_CPT2ACR_REG = (_RW uint32_t* const)UINT32_C(0x400174E0);     /** @brief CPT2xCR */
    static _RW uint32_t* const HRTIM_TIMA_OUTAR_REG = (_RW uint32_t* const)UINT32_C(0x400174E4);       /** @brief Timerx output register */
    static _RW uint32_t* const HRTIM_TIMA_FLTAR_REG = (_RW uint32_t* const)UINT32_C(0x400174E8);       /** @brief Timerx fault register */

    /** @subsection HRTIM_TIMA field mask array definitions */

    static const uint32_t HRTIM_TIMA_TIMAISR_CMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMA_TIMAICR_CMPXC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag clear */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag clear */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag clear */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_CMPXDE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief CMP1DE */
      UINT32_C(0x00020000),   /** @brief CMP2DE */
      UINT32_C(0x00040000),   /** @brief CMP3DE */
      UINT32_C(0x00080000),   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_CMPXIE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief CMP1IE */
      UINT32_C(0x00000002),   /** @brief CMP2IE */
      UINT32_C(0x00000004),   /** @brief CMP3IE */
      UINT32_C(0x00000008),   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMA_SETA1R_EXTEVNTX_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief External event 2 */
      UINT32_C(0x00800000),   /** @brief External event 3 */
      UINT32_C(0x01000000),   /** @brief External event 4 */
      UINT32_C(0x02000000),   /** @brief External event 5 */
      UINT32_C(0x04000000),   /** @brief External event 6 */
      UINT32_C(0x08000000),   /** @brief External event 7 */
      UINT32_C(0x10000000),   /** @brief External event 8 */
      UINT32_C(0x20000000),   /** @brief External event 9 */
      UINT32_C(0x40000000),   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMA_SETA1R_TIMEVNTX_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief Timer event 1 */
      UINT32_C(0x00002000),   /** @brief Timer event 2 */
      UINT32_C(0x00004000),   /** @brief Timer event 3 */
      UINT32_C(0x00008000),   /** @brief Timer event 4 */
      UINT32_C(0x00010000),   /** @brief Timer event 5 */
      UINT32_C(0x00020000),   /** @brief Timer event 6 */
      UINT32_C(0x00040000),   /** @brief Timer event 7 */
      UINT32_C(0x00080000),   /** @brief Timer event 8 */
      UINT32_C(0x00100000),   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMA_SETA1R_MSTCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Master compare 1 */
      UINT32_C(0x00000200),   /** @brief Master compare 2 */
      UINT32_C(0x00000400),   /** @brief Master compare 3 */
      UINT32_C(0x00000800),   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMA_EEFAR1_EEXFLTR_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000001E),   /** @brief External event 1 filter */
      UINT32_C(0x00000780),   /** @brief External event 2 filter */
      UINT32_C(0x0001E000),   /** @brief External event 3 filter */
      UINT32_C(0x00780000),   /** @brief External event 4 filter */
      UINT32_C(0x1E000000),   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMA_EEFAR1_EEXLTCH_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief External event 1 latch */
      UINT32_C(0x00000040),   /** @brief External event 2 latch */
      UINT32_C(0x00001000),   /** @brief External event 3 latch */
      UINT32_C(0x00040000),   /** @brief External event 4 latch */
      UINT32_C(0x01000000),   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMECMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x10000000),   /** @brief Timer E compare 1 */
      UINT32_C(0x20000000),   /** @brief Timer E compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMDCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x02000000),   /** @brief Timer D compare 1 */
      UINT32_C(0x04000000),   /** @brief Timer D compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x08000000),   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMCCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief Timer C compare 1 */
      UINT32_C(0x00800000),   /** @brief Timer C compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x01000000),   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIMA_RSTAR_TIMBCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00080000),   /** @brief Timer B compare 1 */
      UINT32_C(0x00100000),   /** @brief Timer B compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIMA_CPT1ACR_EXEVXCPT_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief External event 2 capture */
      UINT32_C(0x00000010),   /** @brief External event 3 capture */
      UINT32_C(0x00000020),   /** @brief External event 4 capture */
      UINT32_C(0x00000040),   /** @brief External event 5 capture */
      UINT32_C(0x00000080),   /** @brief External event 6 capture */
      UINT32_C(0x00000100),   /** @brief External event 7 capture */
      UINT32_C(0x00000200),   /** @brief External event 8 capture */
      UINT32_C(0x00000400),   /** @brief External event 9 capture */
      UINT32_C(0x00000800),   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMA_FLTAR_FLTXEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 enable */
      UINT32_C(0x00000002),   /** @brief Fault 2 enable */
      UINT32_C(0x00000004),   /** @brief Fault 3 enable */
      UINT32_C(0x00000008),   /** @brief Fault 4 enable */
      UINT32_C(0x00000010),   /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMA field mask definitions */

    static const uint32_t HRTIM_TIMA_TIMACR_UPDGAT_MASK = UINT32_C(0xF0000000);        /** @brief Update gating */
    static const uint32_t HRTIM_TIMA_TIMACR_PREEN_MASK = UINT32_C(0x08000000);         /** @brief Preload enable */
    static const uint32_t HRTIM_TIMA_TIMACR_DACSYNC_MASK = UINT32_C(0x06000000);       /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMA_TIMACR_MSTU_MASK = UINT32_C(0x01000000);          /** @brief Master timer update */
    static const uint32_t HRTIM_TIMA_TIMACR_TEU_MASK = UINT32_C(0x00800000);           /** @brief TEU */
    static const uint32_t HRTIM_TIMA_TIMACR_TDU_MASK = UINT32_C(0x00400000);           /** @brief TDU */
    static const uint32_t HRTIM_TIMA_TIMACR_TCU_MASK = UINT32_C(0x00200000);           /** @brief TCU */
    static const uint32_t HRTIM_TIMA_TIMACR_TBU_MASK = UINT32_C(0x00100000);           /** @brief TBU */
    static const uint32_t HRTIM_TIMA_TIMACR_TXRSTU_MASK = UINT32_C(0x00040000);        /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMA_TIMACR_TXREPU_MASK = UINT32_C(0x00020000);        /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMA_TIMACR_DELCMP4_MASK = UINT32_C(0x0000C000);       /** @brief Delayed CMP4 mode */
    static const uint32_t HRTIM_TIMA_TIMACR_DELCMP2_MASK = UINT32_C(0x00003000);       /** @brief Delayed CMP2 mode */
    static const uint32_t HRTIM_TIMA_TIMACR_SYNCSTRTX_MASK = UINT32_C(0x00000800);     /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMA_TIMACR_SYNCRSTX_MASK = UINT32_C(0x00000400);      /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMA_TIMACR_PSHPLL_MASK = UINT32_C(0x00000040);        /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMA_TIMACR_HALF_MASK = UINT32_C(0x00000020);          /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMA_TIMACR_RETRIG_MASK = UINT32_C(0x00000010);        /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMA_TIMACR_CONT_MASK = UINT32_C(0x00000008);          /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMA_TIMACR_CK_PSCX_MASK = UINT32_C(0x00000007);       /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMA_TIMAISR_O2STAT_MASK = UINT32_C(0x00080000);       /** @brief Output 2 state */
    static const uint32_t HRTIM_TIMA_TIMAISR_O1STAT_MASK = UINT32_C(0x00040000);       /** @brief Output 1 state */
    static const uint32_t HRTIM_TIMA_TIMAISR_IPPSTAT_MASK = UINT32_C(0x00020000);      /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMA_TIMAISR_CPPSTAT_MASK = UINT32_C(0x00010000);      /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMA_TIMAISR_DLYPRT_MASK = UINT32_C(0x00004000);       /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_RST_MASK = UINT32_C(0x00002000);          /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_RSTX2_MASK = UINT32_C(0x00001000);        /** @brief Output 2 reset interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_SETX2_MASK = UINT32_C(0x00000800);        /** @brief Output 2 set interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_RSTX1_MASK = UINT32_C(0x00000400);        /** @brief Output 1 reset interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_SETX1_MASK = UINT32_C(0x00000200);        /** @brief Output 1 set interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_CPT2_MASK = UINT32_C(0x00000100);         /** @brief Capture2 interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_CPT1_MASK = UINT32_C(0x00000080);         /** @brief Capture1 interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_UPD_MASK = UINT32_C(0x00000040);          /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAISR_REP_MASK = UINT32_C(0x00000010);          /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMA_TIMAICR_DLYPRTC_MASK = UINT32_C(0x00004000);      /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_RSTC_MASK = UINT32_C(0x00002000);         /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_RSTX2C_MASK = UINT32_C(0x00001000);       /** @brief Output 2 reset flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_SET2XC_MASK = UINT32_C(0x00000800);       /** @brief Output 2 set flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_RSTX1C_MASK = UINT32_C(0x00000400);       /** @brief Output 1 reset flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_SET1XC_MASK = UINT32_C(0x00000200);       /** @brief Output 1 set flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_CPT2C_MASK = UINT32_C(0x00000100);        /** @brief Capture2 interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_CPT1C_MASK = UINT32_C(0x00000080);        /** @brief Capture1 interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_UPDC_MASK = UINT32_C(0x00000040);         /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMAICR_REPC_MASK = UINT32_C(0x00000010);         /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMA_TIMADIER5_DLYPRTDE_MASK = UINT32_C(0x40000000);   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTDE_MASK = UINT32_C(0x20000000);      /** @brief RSTDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTX2DE_MASK = UINT32_C(0x10000000);    /** @brief RSTx2DE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SETX2DE_MASK = UINT32_C(0x08000000);    /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTX1DE_MASK = UINT32_C(0x04000000);    /** @brief RSTx1DE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SET1XDE_MASK = UINT32_C(0x02000000);    /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_CPT2DE_MASK = UINT32_C(0x01000000);     /** @brief CPT2DE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_CPT1DE_MASK = UINT32_C(0x00800000);     /** @brief CPT1DE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_UPDDE_MASK = UINT32_C(0x00400000);      /** @brief UPDDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_REPDE_MASK = UINT32_C(0x00100000);      /** @brief REPDE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_DLYPRTIE_MASK = UINT32_C(0x00004000);   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTIE_MASK = UINT32_C(0x00002000);      /** @brief RSTIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTX2IE_MASK = UINT32_C(0x00001000);    /** @brief RSTx2IE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SETX2IE_MASK = UINT32_C(0x00000800);    /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RSTX1IE_MASK = UINT32_C(0x00000400);    /** @brief RSTx1IE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_SET1XIE_MASK = UINT32_C(0x00000200);    /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_CPT2IE_MASK = UINT32_C(0x00000100);     /** @brief CPT2IE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_CPT1IE_MASK = UINT32_C(0x00000080);     /** @brief CPT1IE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_UPDIE_MASK = UINT32_C(0x00000040);      /** @brief UPDIE */
    static const uint32_t HRTIM_TIMA_TIMADIER5_REPIE_MASK = UINT32_C(0x00000010);      /** @brief REPIE */
    static const uint32_t HRTIM_TIMA_CNTAR_CNTX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMA_PERAR_PERX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMA_REPAR_REPX_MASK = UINT32_C(0x000000FF);           /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMA_CMPXAR_CMP1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMA_CMP1CAR_REPX_MASK = UINT32_C(0x00FF0000);         /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMA_CMP1CAR_CMP1X_MASK = UINT32_C(0x0000FFFF);        /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMA_CMPXAR_CMP2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 2 value */
    static const uint32_t HRTIM_TIMA_CMPXAR_CMP3X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 3 value */
    static const uint32_t HRTIM_TIMA_CMPXAR_CMP4X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 4 value */
    static const uint32_t HRTIM_TIMA_CPT1AR_CPT1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMA_CPT2AR_CPT2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 2 value */
    static const uint32_t HRTIM_TIMA_DTAR_DTFLKX_MASK = UINT32_C(0x80000000);          /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMA_DTAR_DTFSLKX_MASK = UINT32_C(0x40000000);         /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMA_DTAR_SDTFX_MASK = UINT32_C(0x02000000);           /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMA_DTAR_DTFX_MASK = UINT32_C(0x01FF0000);            /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMA_DTAR_DTRLKX_MASK = UINT32_C(0x00008000);          /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMA_DTAR_DTRSLKX_MASK = UINT32_C(0x00004000);         /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMA_DTAR_DTPRSC_MASK = UINT32_C(0x00001C00);          /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMA_DTAR_SDTRX_MASK = UINT32_C(0x00000200);           /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMA_DTAR_DTRX_MASK = UINT32_C(0x000001FF);            /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMA_SETA1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief External event 1 */
    static const uint32_t HRTIM_TIMA_SETA1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief Master period */
    static const uint32_t HRTIM_TIMA_SETA1R_PER_MASK = UINT32_C(0x00000004);           /** @brief Timer A period */
    static const uint32_t HRTIM_TIMA_SETA1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMA_SETA1R_SST_MASK = UINT32_C(0x00000001);           /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMA_RSTA1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMA_RSTA1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMA_RSTA1R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMA_RSTA1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMA_RSTA1R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMA_SETA2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMA_SETA2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMA_SETA2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMA_SETA2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMA_SETA2R_SST_MASK = UINT32_C(0x00000001);           /** @brief SST */
    static const uint32_t HRTIM_TIMA_RSTA2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMA_RSTA2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMA_RSTA2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMA_RSTA2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMA_RSTA2R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT1_MASK = UINT32_C(0x00000200);       /** @brief External event 1 */
    static const uint32_t HRTIM_TIMA_RSTAR_MSTPER_MASK = UINT32_C(0x00000010);         /** @brief Master timer period */
    static const uint32_t HRTIM_TIMA_RSTAR_CMP4_MASK = UINT32_C(0x00000008);           /** @brief Timer A compare 4 reset */
    static const uint32_t HRTIM_TIMA_RSTAR_CMP2_MASK = UINT32_C(0x00000004);           /** @brief Timer A compare 2 reset */
    static const uint32_t HRTIM_TIMA_RSTAR_UPDT_MASK = UINT32_C(0x00000002);           /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMA_CHPAR_STRTPW_MASK = UINT32_C(0x00000780);         /** @brief STRTPW */
    static const uint32_t HRTIM_TIMA_CHPAR_CHPDTY_MASK = UINT32_C(0x00000070);         /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMA_CHPAR_CHPFRQ_MASK = UINT32_C(0x0000000F);         /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT1ACR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMA_CPT1ACR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMA_CPT1ACR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMA_CPT1ACR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMA_CPT2ACR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMA_CPT2ACR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMA_CPT2ACR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMA_CPT2ACR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMA_OUTAR_DIDL2_MASK = UINT32_C(0x00800000);          /** @brief Output 2 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMA_OUTAR_CHP2_MASK = UINT32_C(0x00400000);           /** @brief Output 2 chopper enable */
    static const uint32_t HRTIM_TIMA_OUTAR_FAULT2_MASK = UINT32_C(0x00300000);         /** @brief Output 2 fault state */
    static const uint32_t HRTIM_TIMA_OUTAR_IDLES2_MASK = UINT32_C(0x00080000);         /** @brief Output 2 idle state */
    static const uint32_t HRTIM_TIMA_OUTAR_IDLEM2_MASK = UINT32_C(0x00040000);         /** @brief Output 2 idle mode */
    static const uint32_t HRTIM_TIMA_OUTAR_POL2_MASK = UINT32_C(0x00020000);           /** @brief Output 2 polarity */
    static const uint32_t HRTIM_TIMA_OUTAR_DLYPRT_MASK = UINT32_C(0x00001C00);         /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMA_OUTAR_DLYPRTEN_MASK = UINT32_C(0x00000200);       /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMA_OUTAR_DTEN_MASK = UINT32_C(0x00000100);           /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMA_OUTAR_DIDL1_MASK = UINT32_C(0x00000080);          /** @brief Output 1 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMA_OUTAR_CHP1_MASK = UINT32_C(0x00000040);           /** @brief Output 1 chopper enable */
    static const uint32_t HRTIM_TIMA_OUTAR_FAULT1_MASK = UINT32_C(0x00000030);         /** @brief Output 1 fault state */
    static const uint32_t HRTIM_TIMA_OUTAR_IDLES1_MASK = UINT32_C(0x00000008);         /** @brief Output 1 idle state */
    static const uint32_t HRTIM_TIMA_OUTAR_IDLEM1_MASK = UINT32_C(0x00000004);         /** @brief Output 1 idle mode */
    static const uint32_t HRTIM_TIMA_OUTAR_POL1_MASK = UINT32_C(0x00000002);           /** @brief Output 1 polarity */
    static const uint32_t HRTIM_TIMA_FLTAR_FLTLCK_MASK = UINT32_C(0x80000000);         /** @brief Fault sources lock */

    /** @subsection HRTIM_TIMA field position array definitions */

    static const int32_t HRTIM_TIMA_FLTAR_CMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag */
      INT32_C(1),    /** @brief Compare 2 interrupt flag */
      INT32_C(2),    /** @brief Compare 3 interrupt flag */
      INT32_C(3),    /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMA_FLTAR_CMPXC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag clear */
      INT32_C(1),    /** @brief Compare 2 interrupt flag clear */
      INT32_C(2),    /** @brief Compare 3 interrupt flag clear */
      INT32_C(3),    /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMA_FLTAR_CMPXDE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief CMP1DE */
      INT32_C(17),   /** @brief CMP2DE */
      INT32_C(18),   /** @brief CMP3DE */
      INT32_C(19),   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMA_FLTAR_CMPXIE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief CMP1IE */
      INT32_C(1),    /** @brief CMP2IE */
      INT32_C(2),    /** @brief CMP3IE */
      INT32_C(3),    /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMA_FLTAR_EXTEVNTX_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief External event 2 */
      INT32_C(23),   /** @brief External event 3 */
      INT32_C(24),   /** @brief External event 4 */
      INT32_C(25),   /** @brief External event 5 */
      INT32_C(26),   /** @brief External event 6 */
      INT32_C(27),   /** @brief External event 7 */
      INT32_C(28),   /** @brief External event 8 */
      INT32_C(29),   /** @brief External event 9 */
      INT32_C(30),   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMA_FLTAR_TIMEVNTX_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief Timer event 1 */
      INT32_C(13),   /** @brief Timer event 2 */
      INT32_C(14),   /** @brief Timer event 3 */
      INT32_C(15),   /** @brief Timer event 4 */
      INT32_C(16),   /** @brief Timer event 5 */
      INT32_C(17),   /** @brief Timer event 6 */
      INT32_C(18),   /** @brief Timer event 7 */
      INT32_C(19),   /** @brief Timer event 8 */
      INT32_C(20),   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMA_FLTAR_MSTCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Master compare 1 */
      INT32_C(9),    /** @brief Master compare 2 */
      INT32_C(10),   /** @brief Master compare 3 */
      INT32_C(11),   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMA_FLTAR_EEXFLTR_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief External event 1 filter */
      INT32_C(7),    /** @brief External event 2 filter */
      INT32_C(13),   /** @brief External event 3 filter */
      INT32_C(19),   /** @brief External event 4 filter */
      INT32_C(25),   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMA_FLTAR_EEXLTCH_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief External event 1 latch */
      INT32_C(6),    /** @brief External event 2 latch */
      INT32_C(12),   /** @brief External event 3 latch */
      INT32_C(18),   /** @brief External event 4 latch */
      INT32_C(24),   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMA_FLTAR_TIMECMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(28),   /** @brief Timer E compare 1 */
      INT32_C(29),   /** @brief Timer E compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMA_FLTAR_TIMDCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(25),   /** @brief Timer D compare 1 */
      INT32_C(26),   /** @brief Timer D compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(27),   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIMA_FLTAR_TIMCCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief Timer C compare 1 */
      INT32_C(23),   /** @brief Timer C compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(24),   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIMA_FLTAR_TIMBCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(19),   /** @brief Timer B compare 1 */
      INT32_C(20),   /** @brief Timer B compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIMA_FLTAR_EXEVXCPT_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief External event 2 capture */
      INT32_C(4),    /** @brief External event 3 capture */
      INT32_C(5),    /** @brief External event 4 capture */
      INT32_C(6),    /** @brief External event 5 capture */
      INT32_C(7),    /** @brief External event 6 capture */
      INT32_C(8),    /** @brief External event 7 capture */
      INT32_C(9),    /** @brief External event 8 capture */
      INT32_C(10),   /** @brief External event 9 capture */
      INT32_C(11),   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMA_FLTAR_FLTXEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 enable */
      INT32_C(1),    /** @brief Fault 2 enable */
      INT32_C(2),    /** @brief Fault 3 enable */
      INT32_C(3),    /** @brief Fault 4 enable */
      INT32_C(4),    /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMA field position definitions */

    static const int32_t HRTIM_TIMA_FLTAR_UPDGAT_POS = INT32_C(28);      /** @brief Update gating */
    static const int32_t HRTIM_TIMA_FLTAR_PREEN_POS = INT32_C(27);       /** @brief Preload enable */
    static const int32_t HRTIM_TIMA_FLTAR_DACSYNC_POS = INT32_C(25);     /** @brief AC synchronization */
    static const int32_t HRTIM_TIMA_FLTAR_MSTU_POS = INT32_C(24);        /** @brief Master timer update */
    static const int32_t HRTIM_TIMA_FLTAR_TEU_POS = INT32_C(23);         /** @brief TEU */
    static const int32_t HRTIM_TIMA_FLTAR_TDU_POS = INT32_C(22);         /** @brief TDU */
    static const int32_t HRTIM_TIMA_FLTAR_TCU_POS = INT32_C(21);         /** @brief TCU */
    static const int32_t HRTIM_TIMA_FLTAR_TBU_POS = INT32_C(20);         /** @brief TBU */
    static const int32_t HRTIM_TIMA_FLTAR_TXRSTU_POS = INT32_C(18);      /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMA_FLTAR_TXREPU_POS = INT32_C(17);      /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMA_FLTAR_DELCMP4_POS = INT32_C(14);     /** @brief Delayed CMP4 mode */
    static const int32_t HRTIM_TIMA_FLTAR_DELCMP2_POS = INT32_C(12);     /** @brief Delayed CMP2 mode */
    static const int32_t HRTIM_TIMA_FLTAR_SYNCSTRTX_POS = INT32_C(11);   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMA_FLTAR_SYNCRSTX_POS = INT32_C(10);    /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMA_FLTAR_PSHPLL_POS = INT32_C(6);       /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMA_FLTAR_HALF_POS = INT32_C(5);         /** @brief Half mode enable */
    static const int32_t HRTIM_TIMA_FLTAR_RETRIG_POS = INT32_C(4);       /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMA_FLTAR_CONT_POS = INT32_C(3);         /** @brief Continuous mode */
    static const int32_t HRTIM_TIMA_FLTAR_CK_PSCX_POS = INT32_C(0);      /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMA_FLTAR_O2STAT_POS = INT32_C(19);      /** @brief Output 2 state */
    static const int32_t HRTIM_TIMA_FLTAR_O1STAT_POS = INT32_C(18);      /** @brief Output 1 state */
    static const int32_t HRTIM_TIMA_FLTAR_IPPSTAT_POS = INT32_C(17);     /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMA_FLTAR_CPPSTAT_POS = INT32_C(16);     /** @brief Current push pull status */
    static const int32_t HRTIM_TIMA_FLTAR_DLYPRT_POS = INT32_C(14);      /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMA_FLTAR_RST_POS = INT32_C(13);         /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX2_POS = INT32_C(12);       /** @brief Output 2 reset interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_SETX2_POS = INT32_C(11);       /** @brief Output 2 set interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX1_POS = INT32_C(10);       /** @brief Output 1 reset interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_SETX1_POS = INT32_C(9);        /** @brief Output 1 set interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_CPT2_POS = INT32_C(8);         /** @brief Capture2 interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_CPT1_POS = INT32_C(7);         /** @brief Capture1 interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_UPD_POS = INT32_C(6);          /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_REP_POS = INT32_C(4);          /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMA_FLTAR_DLYPRTC_POS = INT32_C(14);     /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_RSTC_POS = INT32_C(13);        /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX2C_POS = INT32_C(12);      /** @brief Output 2 reset flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_SET2XC_POS = INT32_C(11);      /** @brief Output 2 set flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX1C_POS = INT32_C(10);      /** @brief Output 1 reset flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_SET1XC_POS = INT32_C(9);       /** @brief Output 1 set flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_CPT2C_POS = INT32_C(8);        /** @brief Capture2 interrupt flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_CPT1C_POS = INT32_C(7);        /** @brief Capture1 interrupt flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_UPDC_POS = INT32_C(6);         /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_REPC_POS = INT32_C(4);         /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMA_FLTAR_DLYPRTDE_POS = INT32_C(30);    /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMA_FLTAR_RSTDE_POS = INT32_C(29);       /** @brief RSTDE */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX2DE_POS = INT32_C(28);     /** @brief RSTx2DE */
    static const int32_t HRTIM_TIMA_FLTAR_SETX2DE_POS = INT32_C(27);     /** @brief SETx2DE */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX1DE_POS = INT32_C(26);     /** @brief RSTx1DE */
    static const int32_t HRTIM_TIMA_FLTAR_SET1XDE_POS = INT32_C(25);     /** @brief SET1xDE */
    static const int32_t HRTIM_TIMA_FLTAR_CPT2DE_POS = INT32_C(24);      /** @brief CPT2DE */
    static const int32_t HRTIM_TIMA_FLTAR_CPT1DE_POS = INT32_C(23);      /** @brief CPT1DE */
    static const int32_t HRTIM_TIMA_FLTAR_UPDDE_POS = INT32_C(22);       /** @brief UPDDE */
    static const int32_t HRTIM_TIMA_FLTAR_REPDE_POS = INT32_C(20);       /** @brief REPDE */
    static const int32_t HRTIM_TIMA_FLTAR_DLYPRTIE_POS = INT32_C(14);    /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMA_FLTAR_RSTIE_POS = INT32_C(13);       /** @brief RSTIE */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX2IE_POS = INT32_C(12);     /** @brief RSTx2IE */
    static const int32_t HRTIM_TIMA_FLTAR_SETX2IE_POS = INT32_C(11);     /** @brief SETx2IE */
    static const int32_t HRTIM_TIMA_FLTAR_RSTX1IE_POS = INT32_C(10);     /** @brief RSTx1IE */
    static const int32_t HRTIM_TIMA_FLTAR_SET1XIE_POS = INT32_C(9);      /** @brief SET1xIE */
    static const int32_t HRTIM_TIMA_FLTAR_CPT2IE_POS = INT32_C(8);       /** @brief CPT2IE */
    static const int32_t HRTIM_TIMA_FLTAR_CPT1IE_POS = INT32_C(7);       /** @brief CPT1IE */
    static const int32_t HRTIM_TIMA_FLTAR_UPDIE_POS = INT32_C(6);        /** @brief UPDIE */
    static const int32_t HRTIM_TIMA_FLTAR_REPIE_POS = INT32_C(4);        /** @brief REPIE */
    static const int32_t HRTIM_TIMA_FLTAR_CNTX_POS = INT32_C(0);         /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMA_FLTAR_PERX_POS = INT32_C(0);         /** @brief Timerx period value */
    static const int32_t HRTIM_TIMA_FLTAR_REPX_POS = INT32_C(0);         /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMA_FLTAR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMA_FLTAR_REPX_POS = INT32_C(16);        /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMA_FLTAR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMA_FLTAR_CMP2X_POS = INT32_C(0);        /** @brief Timerx compare 2 value */
    static const int32_t HRTIM_TIMA_FLTAR_CMP3X_POS = INT32_C(0);        /** @brief Timerx compare 3 value */
    static const int32_t HRTIM_TIMA_FLTAR_CMP4X_POS = INT32_C(0);        /** @brief Timerx compare 4 value */
    static const int32_t HRTIM_TIMA_FLTAR_CPT1X_POS = INT32_C(0);        /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMA_FLTAR_CPT2X_POS = INT32_C(0);        /** @brief Timerx capture 2 value */
    static const int32_t HRTIM_TIMA_FLTAR_DTFLKX_POS = INT32_C(31);      /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMA_FLTAR_DTFSLKX_POS = INT32_C(30);     /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMA_FLTAR_SDTFX_POS = INT32_C(25);       /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMA_FLTAR_DTFX_POS = INT32_C(16);        /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMA_FLTAR_DTRLKX_POS = INT32_C(15);      /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMA_FLTAR_DTRSLKX_POS = INT32_C(14);     /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMA_FLTAR_DTPRSC_POS = INT32_C(10);      /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMA_FLTAR_SDTRX_POS = INT32_C(9);        /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMA_FLTAR_DTRX_POS = INT32_C(0);         /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMA_FLTAR_UPDATE_POS = INT32_C(31);      /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMA_FLTAR_EXTEVNT1_POS = INT32_C(21);    /** @brief External event 1 */
    static const int32_t HRTIM_TIMA_FLTAR_MSTPER_POS = INT32_C(7);       /** @brief Master period */
    static const int32_t HRTIM_TIMA_FLTAR_PER_POS = INT32_C(2);          /** @brief Timer A period */
    static const int32_t HRTIM_TIMA_FLTAR_RESYNC_POS = INT32_C(1);       /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMA_FLTAR_SST_POS = INT32_C(0);          /** @brief Software set trigger */
    static const int32_t HRTIM_TIMA_FLTAR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMA_FLTAR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMA_FLTAR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMA_FLTAR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMA_FLTAR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMA_FLTAR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMA_FLTAR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMA_FLTAR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMA_FLTAR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMA_FLTAR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMA_FLTAR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMA_FLTAR_SST_POS = INT32_C(0);          /** @brief SST */
    static const int32_t HRTIM_TIMA_FLTAR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMA_FLTAR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMA_FLTAR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMA_FLTAR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMA_FLTAR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMA_FLTAR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMA_FLTAR_EXTEVNT1_POS = INT32_C(9);     /** @brief External event 1 */
    static const int32_t HRTIM_TIMA_FLTAR_MSTPER_POS = INT32_C(4);       /** @brief Master timer period */
    static const int32_t HRTIM_TIMA_FLTAR_CMP4_POS = INT32_C(3);         /** @brief Timer A compare 4 reset */
    static const int32_t HRTIM_TIMA_FLTAR_CMP2_POS = INT32_C(2);         /** @brief Timer A compare 2 reset */
    static const int32_t HRTIM_TIMA_FLTAR_UPDT_POS = INT32_C(1);         /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMA_FLTAR_STRTPW_POS = INT32_C(7);       /** @brief STRTPW */
    static const int32_t HRTIM_TIMA_FLTAR_CHPDTY_POS = INT32_C(4);       /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMA_FLTAR_CHPFRQ_POS = INT32_C(0);       /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMA_FLTAR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMA_FLTAR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMA_FLTAR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMA_FLTAR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIMA_FLTAR_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIMA_FLTAR_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMA_FLTAR_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMA_FLTAR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMA_FLTAR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMA_FLTAR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMA_FLTAR_DIDL2_POS = INT32_C(23);       /** @brief Output 2 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMA_FLTAR_CHP2_POS = INT32_C(22);        /** @brief Output 2 chopper enable */
    static const int32_t HRTIM_TIMA_FLTAR_FAULT2_POS = INT32_C(20);      /** @brief Output 2 fault state */
    static const int32_t HRTIM_TIMA_FLTAR_IDLES2_POS = INT32_C(19);      /** @brief Output 2 idle state */
    static const int32_t HRTIM_TIMA_FLTAR_IDLEM2_POS = INT32_C(18);      /** @brief Output 2 idle mode */
    static const int32_t HRTIM_TIMA_FLTAR_POL2_POS = INT32_C(17);        /** @brief Output 2 polarity */
    static const int32_t HRTIM_TIMA_FLTAR_DLYPRT_POS = INT32_C(10);      /** @brief Delayed protection */
    static const int32_t HRTIM_TIMA_FLTAR_DLYPRTEN_POS = INT32_C(9);     /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMA_FLTAR_DTEN_POS = INT32_C(8);         /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMA_FLTAR_DIDL1_POS = INT32_C(7);        /** @brief Output 1 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMA_FLTAR_CHP1_POS = INT32_C(6);         /** @brief Output 1 chopper enable */
    static const int32_t HRTIM_TIMA_FLTAR_FAULT1_POS = INT32_C(4);       /** @brief Output 1 fault state */
    static const int32_t HRTIM_TIMA_FLTAR_IDLES1_POS = INT32_C(3);       /** @brief Output 1 idle state */
    static const int32_t HRTIM_TIMA_FLTAR_IDLEM1_POS = INT32_C(2);       /** @brief Output 1 idle mode */
    static const int32_t HRTIM_TIMA_FLTAR_POL1_POS = INT32_C(1);         /** @brief Output 1 polarity */
    static const int32_t HRTIM_TIMA_FLTAR_FLTLCK_POS = INT32_C(31);      /** @brief Fault sources lock */

    /**********************************************************************************************
     * @section HRTIM_TIMB Definitions
     **********************************************************************************************/

    /** @subsection HRTIM_TIMB IRQ interrupt definitions */

    static const int32_t HRTIM1_TIMA_IRQ = INT32_C(104);   /** @brief HRTIM1 timer A interrupt */

    /** @subsection HRTIM_TIMB register array definitions */

    static _RW uint32_t* const HRTIM_TIMB_CMPXBR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001751C),   /** @brief Timerx compare 1 register */
      (_RW uint32_t* const)UINT32_C(0x40017524),   /** @brief Timerx compare 2 register */
      (_RW uint32_t* const)UINT32_C(0x40017528),   /** @brief Timerx compare 3 register */
      (_RW uint32_t* const)UINT32_C(0x4001752C),   /** @brief Timerx compare 4 register */
    };

    /** @subsection HRTIM_TIMB register definitions */

    static _RW uint32_t* const HRTIM_TIMB_TIMBCR_REG = (_RW uint32_t* const)UINT32_C(0x40017500);      /** @brief Timerx control register */
    static _RO uint32_t* const HRTIM_TIMB_TIMBISR_REG = (_RO uint32_t* const)UINT32_C(0x40017504);     /** @brief Timerx interrupt status register */
    static _RW uint32_t* const HRTIM_TIMB_TIMBICR_REG = (_RW uint32_t* const)UINT32_C(0x40017508);     /** @brief Timerx interrupt clear register */
    static _RW uint32_t* const HRTIM_TIMB_TIMBDIER5_REG = (_RW uint32_t* const)UINT32_C(0x4001750C);   /** @brief TIMxDIER5 */
    static _RW uint32_t* const HRTIM_TIMB_CNTR_REG = (_RW uint32_t* const)UINT32_C(0x40017510);        /** @brief Timerx counter register */
    static _RW uint32_t* const HRTIM_TIMB_PERBR_REG = (_RW uint32_t* const)UINT32_C(0x40017514);       /** @brief Timerx period register */
    static _RW uint32_t* const HRTIM_TIMB_REPBR_REG = (_RW uint32_t* const)UINT32_C(0x40017518);       /** @brief Timerx repetition register */
    static _RW uint32_t* const HRTIM_TIMB_CMP1CBR_REG = (_RW uint32_t* const)UINT32_C(0x40017520);     /** @brief Timerx compare 1 compound register */
    static _RO uint32_t* const HRTIM_TIMB_CPT1BR_REG = (_RO uint32_t* const)UINT32_C(0x40017530);      /** @brief Timerx capture 1 register */
    static _RO uint32_t* const HRTIM_TIMB_CPT2BR_REG = (_RO uint32_t* const)UINT32_C(0x40017534);      /** @brief Timerx capture 2 register */
    static _RW uint32_t* const HRTIM_TIMB_DTBR_REG = (_RW uint32_t* const)UINT32_C(0x40017538);        /** @brief Timerx deadtime register */
    static _RW uint32_t* const HRTIM_TIMB_SETB1R_REG = (_RW uint32_t* const)UINT32_C(0x4001753C);      /** @brief Timerx output1 set register */
    static _RW uint32_t* const HRTIM_TIMB_RSTB1R_REG = (_RW uint32_t* const)UINT32_C(0x40017540);      /** @brief Timerx output1 reset register */
    static _RW uint32_t* const HRTIM_TIMB_SETB2R_REG = (_RW uint32_t* const)UINT32_C(0x40017544);      /** @brief Timerx output2 set register */
    static _RW uint32_t* const HRTIM_TIMB_RSTB2R_REG = (_RW uint32_t* const)UINT32_C(0x40017548);      /** @brief Timerx output2 reset register */
    static _RW uint32_t* const HRTIM_TIMB_EEFBR1_REG = (_RW uint32_t* const)UINT32_C(0x4001754C);      /** @brief Timerx external event filtering register 1 */
    static _RW uint32_t* const HRTIM_TIMB_EEFBR2_REG = (_RW uint32_t* const)UINT32_C(0x40017550);      /** @brief Timerx external event filtering register 2 */
    static _RW uint32_t* const HRTIM_TIMB_RSTBR_REG = (_RW uint32_t* const)UINT32_C(0x40017554);       /** @brief TimerA reset register */
    static _RW uint32_t* const HRTIM_TIMB_CHPBR_REG = (_RW uint32_t* const)UINT32_C(0x40017558);       /** @brief Timerx chopper register */
    static _RW uint32_t* const HRTIM_TIMB_CPT1BCR_REG = (_RW uint32_t* const)UINT32_C(0x4001755C);     /** @brief Timerx capture 2 control register */
    static _RW uint32_t* const HRTIM_TIMB_CPT2BCR_REG = (_RW uint32_t* const)UINT32_C(0x40017560);     /** @brief CPT2xCR */
    static _RW uint32_t* const HRTIM_TIMB_OUTBR_REG = (_RW uint32_t* const)UINT32_C(0x40017564);       /** @brief Timerx output register */
    static _RW uint32_t* const HRTIM_TIMB_FLTBR_REG = (_RW uint32_t* const)UINT32_C(0x40017568);       /** @brief Timerx fault register */

    /** @subsection HRTIM_TIMB field mask array definitions */

    static const uint32_t HRTIM_TIMB_TIMBISR_CMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMB_TIMBICR_CMPXC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag clear */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag clear */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag clear */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_CMPXDE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief CMP1DE */
      UINT32_C(0x00020000),   /** @brief CMP2DE */
      UINT32_C(0x00040000),   /** @brief CMP3DE */
      UINT32_C(0x00080000),   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_CMPXIE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief CMP1IE */
      UINT32_C(0x00000002),   /** @brief CMP2IE */
      UINT32_C(0x00000004),   /** @brief CMP3IE */
      UINT32_C(0x00000008),   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMB_SETB1R_EXTEVNTX_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief External event 2 */
      UINT32_C(0x00800000),   /** @brief External event 3 */
      UINT32_C(0x01000000),   /** @brief External event 4 */
      UINT32_C(0x02000000),   /** @brief External event 5 */
      UINT32_C(0x04000000),   /** @brief External event 6 */
      UINT32_C(0x08000000),   /** @brief External event 7 */
      UINT32_C(0x10000000),   /** @brief External event 8 */
      UINT32_C(0x20000000),   /** @brief External event 9 */
      UINT32_C(0x40000000),   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMB_SETB1R_TIMEVNTX_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief Timer event 1 */
      UINT32_C(0x00002000),   /** @brief Timer event 2 */
      UINT32_C(0x00004000),   /** @brief Timer event 3 */
      UINT32_C(0x00008000),   /** @brief Timer event 4 */
      UINT32_C(0x00010000),   /** @brief Timer event 5 */
      UINT32_C(0x00020000),   /** @brief Timer event 6 */
      UINT32_C(0x00040000),   /** @brief Timer event 7 */
      UINT32_C(0x00080000),   /** @brief Timer event 8 */
      UINT32_C(0x00100000),   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMB_SETB1R_MSTCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Master compare 1 */
      UINT32_C(0x00000200),   /** @brief Master compare 2 */
      UINT32_C(0x00000400),   /** @brief Master compare 3 */
      UINT32_C(0x00000800),   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMB_EEFBR1_EEXFLTR_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000001E),   /** @brief External event 1 filter */
      UINT32_C(0x00000780),   /** @brief External event 2 filter */
      UINT32_C(0x0001E000),   /** @brief External event 3 filter */
      UINT32_C(0x00780000),   /** @brief External event 4 filter */
      UINT32_C(0x1E000000),   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMB_EEFBR1_EEXLTCH_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief External event 1 latch */
      UINT32_C(0x00000040),   /** @brief External event 2 latch */
      UINT32_C(0x00001000),   /** @brief External event 3 latch */
      UINT32_C(0x00040000),   /** @brief External event 4 latch */
      UINT32_C(0x01000000),   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMECMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x10000000),   /** @brief Timer E compare 1 */
      UINT32_C(0x20000000),   /** @brief Timer E compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMDCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x02000000),   /** @brief Timer D compare 1 */
      UINT32_C(0x04000000),   /** @brief Timer D compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x08000000),   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMCCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief Timer C compare 1 */
      UINT32_C(0x00800000),   /** @brief Timer C compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x01000000),   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIMB_RSTBR_TIMACMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00080000),   /** @brief Timer A compare 1 */
      UINT32_C(0x00100000),   /** @brief Timer A compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIMB_CPT1BCR_EXEVXCPT_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief External event 2 capture */
      UINT32_C(0x00000010),   /** @brief External event 3 capture */
      UINT32_C(0x00000020),   /** @brief External event 4 capture */
      UINT32_C(0x00000040),   /** @brief External event 5 capture */
      UINT32_C(0x00000080),   /** @brief External event 6 capture */
      UINT32_C(0x00000100),   /** @brief External event 7 capture */
      UINT32_C(0x00000200),   /** @brief External event 8 capture */
      UINT32_C(0x00000400),   /** @brief External event 9 capture */
      UINT32_C(0x00000800),   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMB_FLTBR_FLTXEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 enable */
      UINT32_C(0x00000002),   /** @brief Fault 2 enable */
      UINT32_C(0x00000004),   /** @brief Fault 3 enable */
      UINT32_C(0x00000008),   /** @brief Fault 4 enable */
      UINT32_C(0x00000010),   /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMB field mask definitions */

    static const uint32_t HRTIM_TIMB_TIMBCR_UPDGAT_MASK = UINT32_C(0xF0000000);        /** @brief Update gating */
    static const uint32_t HRTIM_TIMB_TIMBCR_PREEN_MASK = UINT32_C(0x08000000);         /** @brief Preload enable */
    static const uint32_t HRTIM_TIMB_TIMBCR_DACSYNC_MASK = UINT32_C(0x06000000);       /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMB_TIMBCR_MSTU_MASK = UINT32_C(0x01000000);          /** @brief Master timer update */
    static const uint32_t HRTIM_TIMB_TIMBCR_TEU_MASK = UINT32_C(0x00800000);           /** @brief TEU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TDU_MASK = UINT32_C(0x00400000);           /** @brief TDU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TCU_MASK = UINT32_C(0x00200000);           /** @brief TCU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TBU_MASK = UINT32_C(0x00100000);           /** @brief TBU */
    static const uint32_t HRTIM_TIMB_TIMBCR_TXRSTU_MASK = UINT32_C(0x00040000);        /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMB_TIMBCR_TXREPU_MASK = UINT32_C(0x00020000);        /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMB_TIMBCR_DELCMP4_MASK = UINT32_C(0x0000C000);       /** @brief Delayed CMP4 mode */
    static const uint32_t HRTIM_TIMB_TIMBCR_DELCMP2_MASK = UINT32_C(0x00003000);       /** @brief Delayed CMP2 mode */
    static const uint32_t HRTIM_TIMB_TIMBCR_SYNCSTRTX_MASK = UINT32_C(0x00000800);     /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMB_TIMBCR_SYNCRSTX_MASK = UINT32_C(0x00000400);      /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMB_TIMBCR_PSHPLL_MASK = UINT32_C(0x00000040);        /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMB_TIMBCR_HALF_MASK = UINT32_C(0x00000020);          /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMB_TIMBCR_RETRIG_MASK = UINT32_C(0x00000010);        /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMB_TIMBCR_CONT_MASK = UINT32_C(0x00000008);          /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMB_TIMBCR_CK_PSCX_MASK = UINT32_C(0x00000007);       /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMB_TIMBISR_O2STAT_MASK = UINT32_C(0x00080000);       /** @brief Output 2 state */
    static const uint32_t HRTIM_TIMB_TIMBISR_O1STAT_MASK = UINT32_C(0x00040000);       /** @brief Output 1 state */
    static const uint32_t HRTIM_TIMB_TIMBISR_IPPSTAT_MASK = UINT32_C(0x00020000);      /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMB_TIMBISR_CPPSTAT_MASK = UINT32_C(0x00010000);      /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMB_TIMBISR_DLYPRT_MASK = UINT32_C(0x00004000);       /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_RST_MASK = UINT32_C(0x00002000);          /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_RSTX2_MASK = UINT32_C(0x00001000);        /** @brief Output 2 reset interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_SETX2_MASK = UINT32_C(0x00000800);        /** @brief Output 2 set interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_RSTX1_MASK = UINT32_C(0x00000400);        /** @brief Output 1 reset interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_SETX1_MASK = UINT32_C(0x00000200);        /** @brief Output 1 set interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_CPT2_MASK = UINT32_C(0x00000100);         /** @brief Capture2 interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_CPT1_MASK = UINT32_C(0x00000080);         /** @brief Capture1 interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_UPD_MASK = UINT32_C(0x00000040);          /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBISR_REP_MASK = UINT32_C(0x00000010);          /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMB_TIMBICR_DLYPRTC_MASK = UINT32_C(0x00004000);      /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_RSTC_MASK = UINT32_C(0x00002000);         /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_RSTX2C_MASK = UINT32_C(0x00001000);       /** @brief Output 2 reset flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_SET2XC_MASK = UINT32_C(0x00000800);       /** @brief Output 2 set flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_RSTX1C_MASK = UINT32_C(0x00000400);       /** @brief Output 1 reset flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_SET1XC_MASK = UINT32_C(0x00000200);       /** @brief Output 1 set flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_CPT2C_MASK = UINT32_C(0x00000100);        /** @brief Capture2 interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_CPT1C_MASK = UINT32_C(0x00000080);        /** @brief Capture1 interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_UPDC_MASK = UINT32_C(0x00000040);         /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBICR_REPC_MASK = UINT32_C(0x00000010);         /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_DLYPRTDE_MASK = UINT32_C(0x40000000);   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTDE_MASK = UINT32_C(0x20000000);      /** @brief RSTDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTX2DE_MASK = UINT32_C(0x10000000);    /** @brief RSTx2DE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SETX2DE_MASK = UINT32_C(0x08000000);    /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTX1DE_MASK = UINT32_C(0x04000000);    /** @brief RSTx1DE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SET1XDE_MASK = UINT32_C(0x02000000);    /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_CPT2DE_MASK = UINT32_C(0x01000000);     /** @brief CPT2DE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_CPT1DE_MASK = UINT32_C(0x00800000);     /** @brief CPT1DE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_UPDDE_MASK = UINT32_C(0x00400000);      /** @brief UPDDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_REPDE_MASK = UINT32_C(0x00100000);      /** @brief REPDE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_DLYPRTIE_MASK = UINT32_C(0x00004000);   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTIE_MASK = UINT32_C(0x00002000);      /** @brief RSTIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTX2IE_MASK = UINT32_C(0x00001000);    /** @brief RSTx2IE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SETX2IE_MASK = UINT32_C(0x00000800);    /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RSTX1IE_MASK = UINT32_C(0x00000400);    /** @brief RSTx1IE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_SET1XIE_MASK = UINT32_C(0x00000200);    /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_CPT2IE_MASK = UINT32_C(0x00000100);     /** @brief CPT2IE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_CPT1IE_MASK = UINT32_C(0x00000080);     /** @brief CPT1IE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_UPDIE_MASK = UINT32_C(0x00000040);      /** @brief UPDIE */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_REPIE_MASK = UINT32_C(0x00000010);      /** @brief REPIE */
    static const uint32_t HRTIM_TIMB_CNTR_CNTX_MASK = UINT32_C(0x0000FFFF);            /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMB_PERBR_PERX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMB_REPBR_REPX_MASK = UINT32_C(0x000000FF);           /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMB_CMPXBR_CMP1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMB_CMP1CBR_REPX_MASK = UINT32_C(0x00FF0000);         /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMB_CMP1CBR_CMP1X_MASK = UINT32_C(0x0000FFFF);        /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMB_CMPXBR_CMP2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 2 value */
    static const uint32_t HRTIM_TIMB_CMPXBR_CMP3X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 3 value */
    static const uint32_t HRTIM_TIMB_CMPXBR_CMP4X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 4 value */
    static const uint32_t HRTIM_TIMB_CPT1BR_CPT1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMB_CPT2BR_CPT2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 2 value */
    static const uint32_t HRTIM_TIMB_DTBR_DTFLKX_MASK = UINT32_C(0x80000000);          /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMB_DTBR_DTFSLKX_MASK = UINT32_C(0x40000000);         /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMB_DTBR_SDTFX_MASK = UINT32_C(0x02000000);           /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMB_DTBR_DTFX_MASK = UINT32_C(0x01FF0000);            /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMB_DTBR_DTRLKX_MASK = UINT32_C(0x00008000);          /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMB_DTBR_DTRSLKX_MASK = UINT32_C(0x00004000);         /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMB_DTBR_DTPRSC_MASK = UINT32_C(0x00001C00);          /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMB_DTBR_SDTRX_MASK = UINT32_C(0x00000200);           /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMB_DTBR_DTRX_MASK = UINT32_C(0x000001FF);            /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMB_SETB1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief External event 1 */
    static const uint32_t HRTIM_TIMB_SETB1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief Master period */
    static const uint32_t HRTIM_TIMB_SETB1R_PER_MASK = UINT32_C(0x00000004);           /** @brief Timer A period */
    static const uint32_t HRTIM_TIMB_SETB1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMB_SETB1R_SST_MASK = UINT32_C(0x00000001);           /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMB_RSTB1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMB_RSTB1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMB_RSTB1R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMB_RSTB1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMB_RSTB1R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMB_SETB2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMB_SETB2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMB_SETB2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMB_SETB2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMB_SETB2R_SST_MASK = UINT32_C(0x00000001);           /** @brief SST */
    static const uint32_t HRTIM_TIMB_RSTB2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMB_RSTB2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMB_RSTB2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMB_RSTB2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMB_RSTB2R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT1_MASK = UINT32_C(0x00000200);       /** @brief External event 1 */
    static const uint32_t HRTIM_TIMB_RSTBR_MSTPER_MASK = UINT32_C(0x00000010);         /** @brief Master timer period */
    static const uint32_t HRTIM_TIMB_RSTBR_CMP4_MASK = UINT32_C(0x00000008);           /** @brief Timer A compare 4 reset */
    static const uint32_t HRTIM_TIMB_RSTBR_CMP2_MASK = UINT32_C(0x00000004);           /** @brief Timer A compare 2 reset */
    static const uint32_t HRTIM_TIMB_RSTBR_UPDT_MASK = UINT32_C(0x00000002);           /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMB_CHPBR_STRTPW_MASK = UINT32_C(0x00000780);         /** @brief STRTPW */
    static const uint32_t HRTIM_TIMB_CHPBR_CHPDTY_MASK = UINT32_C(0x00000070);         /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMB_CHPBR_CHPFRQ_MASK = UINT32_C(0x0000000F);         /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT1BCR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMB_CPT1BCR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMB_CPT1BCR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMB_CPT1BCR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMB_CPT2BCR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMB_CPT2BCR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMB_CPT2BCR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMB_CPT2BCR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMB_OUTBR_DIDL2_MASK = UINT32_C(0x00800000);          /** @brief Output 2 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMB_OUTBR_CHP2_MASK = UINT32_C(0x00400000);           /** @brief Output 2 chopper enable */
    static const uint32_t HRTIM_TIMB_OUTBR_FAULT2_MASK = UINT32_C(0x00300000);         /** @brief Output 2 fault state */
    static const uint32_t HRTIM_TIMB_OUTBR_IDLES2_MASK = UINT32_C(0x00080000);         /** @brief Output 2 idle state */
    static const uint32_t HRTIM_TIMB_OUTBR_IDLEM2_MASK = UINT32_C(0x00040000);         /** @brief Output 2 idle mode */
    static const uint32_t HRTIM_TIMB_OUTBR_POL2_MASK = UINT32_C(0x00020000);           /** @brief Output 2 polarity */
    static const uint32_t HRTIM_TIMB_OUTBR_DLYPRT_MASK = UINT32_C(0x00001C00);         /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMB_OUTBR_DLYPRTEN_MASK = UINT32_C(0x00000200);       /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMB_OUTBR_DTEN_MASK = UINT32_C(0x00000100);           /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMB_OUTBR_DIDL1_MASK = UINT32_C(0x00000080);          /** @brief Output 1 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMB_OUTBR_CHP1_MASK = UINT32_C(0x00000040);           /** @brief Output 1 chopper enable */
    static const uint32_t HRTIM_TIMB_OUTBR_FAULT1_MASK = UINT32_C(0x00000030);         /** @brief Output 1 fault state */
    static const uint32_t HRTIM_TIMB_OUTBR_IDLES1_MASK = UINT32_C(0x00000008);         /** @brief Output 1 idle state */
    static const uint32_t HRTIM_TIMB_OUTBR_IDLEM1_MASK = UINT32_C(0x00000004);         /** @brief Output 1 idle mode */
    static const uint32_t HRTIM_TIMB_OUTBR_POL1_MASK = UINT32_C(0x00000002);           /** @brief Output 1 polarity */
    static const uint32_t HRTIM_TIMB_FLTBR_FLTLCK_MASK = UINT32_C(0x80000000);         /** @brief Fault sources lock */

    /** @subsection HRTIM_TIMB field position array definitions */

    static const int32_t HRTIM_TIMB_FLTBR_CMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag */
      INT32_C(1),    /** @brief Compare 2 interrupt flag */
      INT32_C(2),    /** @brief Compare 3 interrupt flag */
      INT32_C(3),    /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMB_FLTBR_CMPXC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag clear */
      INT32_C(1),    /** @brief Compare 2 interrupt flag clear */
      INT32_C(2),    /** @brief Compare 3 interrupt flag clear */
      INT32_C(3),    /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMB_FLTBR_CMPXDE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief CMP1DE */
      INT32_C(17),   /** @brief CMP2DE */
      INT32_C(18),   /** @brief CMP3DE */
      INT32_C(19),   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMB_FLTBR_CMPXIE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief CMP1IE */
      INT32_C(1),    /** @brief CMP2IE */
      INT32_C(2),    /** @brief CMP3IE */
      INT32_C(3),    /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMB_FLTBR_EXTEVNTX_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief External event 2 */
      INT32_C(23),   /** @brief External event 3 */
      INT32_C(24),   /** @brief External event 4 */
      INT32_C(25),   /** @brief External event 5 */
      INT32_C(26),   /** @brief External event 6 */
      INT32_C(27),   /** @brief External event 7 */
      INT32_C(28),   /** @brief External event 8 */
      INT32_C(29),   /** @brief External event 9 */
      INT32_C(30),   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMB_FLTBR_TIMEVNTX_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief Timer event 1 */
      INT32_C(13),   /** @brief Timer event 2 */
      INT32_C(14),   /** @brief Timer event 3 */
      INT32_C(15),   /** @brief Timer event 4 */
      INT32_C(16),   /** @brief Timer event 5 */
      INT32_C(17),   /** @brief Timer event 6 */
      INT32_C(18),   /** @brief Timer event 7 */
      INT32_C(19),   /** @brief Timer event 8 */
      INT32_C(20),   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMB_FLTBR_MSTCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Master compare 1 */
      INT32_C(9),    /** @brief Master compare 2 */
      INT32_C(10),   /** @brief Master compare 3 */
      INT32_C(11),   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMB_FLTBR_EEXFLTR_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief External event 1 filter */
      INT32_C(7),    /** @brief External event 2 filter */
      INT32_C(13),   /** @brief External event 3 filter */
      INT32_C(19),   /** @brief External event 4 filter */
      INT32_C(25),   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMB_FLTBR_EEXLTCH_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief External event 1 latch */
      INT32_C(6),    /** @brief External event 2 latch */
      INT32_C(12),   /** @brief External event 3 latch */
      INT32_C(18),   /** @brief External event 4 latch */
      INT32_C(24),   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMB_FLTBR_TIMECMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(28),   /** @brief Timer E compare 1 */
      INT32_C(29),   /** @brief Timer E compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMB_FLTBR_TIMDCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(25),   /** @brief Timer D compare 1 */
      INT32_C(26),   /** @brief Timer D compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(27),   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIMB_FLTBR_TIMCCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief Timer C compare 1 */
      INT32_C(23),   /** @brief Timer C compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(24),   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIMB_FLTBR_TIMACMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(19),   /** @brief Timer A compare 1 */
      INT32_C(20),   /** @brief Timer A compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIMB_FLTBR_EXEVXCPT_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief External event 2 capture */
      INT32_C(4),    /** @brief External event 3 capture */
      INT32_C(5),    /** @brief External event 4 capture */
      INT32_C(6),    /** @brief External event 5 capture */
      INT32_C(7),    /** @brief External event 6 capture */
      INT32_C(8),    /** @brief External event 7 capture */
      INT32_C(9),    /** @brief External event 8 capture */
      INT32_C(10),   /** @brief External event 9 capture */
      INT32_C(11),   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMB_FLTBR_FLTXEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 enable */
      INT32_C(1),    /** @brief Fault 2 enable */
      INT32_C(2),    /** @brief Fault 3 enable */
      INT32_C(3),    /** @brief Fault 4 enable */
      INT32_C(4),    /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMB field position definitions */

    static const int32_t HRTIM_TIMB_FLTBR_UPDGAT_POS = INT32_C(28);      /** @brief Update gating */
    static const int32_t HRTIM_TIMB_FLTBR_PREEN_POS = INT32_C(27);       /** @brief Preload enable */
    static const int32_t HRTIM_TIMB_FLTBR_DACSYNC_POS = INT32_C(25);     /** @brief AC synchronization */
    static const int32_t HRTIM_TIMB_FLTBR_MSTU_POS = INT32_C(24);        /** @brief Master timer update */
    static const int32_t HRTIM_TIMB_FLTBR_TEU_POS = INT32_C(23);         /** @brief TEU */
    static const int32_t HRTIM_TIMB_FLTBR_TDU_POS = INT32_C(22);         /** @brief TDU */
    static const int32_t HRTIM_TIMB_FLTBR_TCU_POS = INT32_C(21);         /** @brief TCU */
    static const int32_t HRTIM_TIMB_FLTBR_TBU_POS = INT32_C(20);         /** @brief TBU */
    static const int32_t HRTIM_TIMB_FLTBR_TXRSTU_POS = INT32_C(18);      /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMB_FLTBR_TXREPU_POS = INT32_C(17);      /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMB_FLTBR_DELCMP4_POS = INT32_C(14);     /** @brief Delayed CMP4 mode */
    static const int32_t HRTIM_TIMB_FLTBR_DELCMP2_POS = INT32_C(12);     /** @brief Delayed CMP2 mode */
    static const int32_t HRTIM_TIMB_FLTBR_SYNCSTRTX_POS = INT32_C(11);   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMB_FLTBR_SYNCRSTX_POS = INT32_C(10);    /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMB_FLTBR_PSHPLL_POS = INT32_C(6);       /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMB_FLTBR_HALF_POS = INT32_C(5);         /** @brief Half mode enable */
    static const int32_t HRTIM_TIMB_FLTBR_RETRIG_POS = INT32_C(4);       /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMB_FLTBR_CONT_POS = INT32_C(3);         /** @brief Continuous mode */
    static const int32_t HRTIM_TIMB_FLTBR_CK_PSCX_POS = INT32_C(0);      /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMB_FLTBR_O2STAT_POS = INT32_C(19);      /** @brief Output 2 state */
    static const int32_t HRTIM_TIMB_FLTBR_O1STAT_POS = INT32_C(18);      /** @brief Output 1 state */
    static const int32_t HRTIM_TIMB_FLTBR_IPPSTAT_POS = INT32_C(17);     /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMB_FLTBR_CPPSTAT_POS = INT32_C(16);     /** @brief Current push pull status */
    static const int32_t HRTIM_TIMB_FLTBR_DLYPRT_POS = INT32_C(14);      /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMB_FLTBR_RST_POS = INT32_C(13);         /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX2_POS = INT32_C(12);       /** @brief Output 2 reset interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_SETX2_POS = INT32_C(11);       /** @brief Output 2 set interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX1_POS = INT32_C(10);       /** @brief Output 1 reset interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_SETX1_POS = INT32_C(9);        /** @brief Output 1 set interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_CPT2_POS = INT32_C(8);         /** @brief Capture2 interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_CPT1_POS = INT32_C(7);         /** @brief Capture1 interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_UPD_POS = INT32_C(6);          /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_REP_POS = INT32_C(4);          /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMB_FLTBR_DLYPRTC_POS = INT32_C(14);     /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_RSTC_POS = INT32_C(13);        /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX2C_POS = INT32_C(12);      /** @brief Output 2 reset flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_SET2XC_POS = INT32_C(11);      /** @brief Output 2 set flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX1C_POS = INT32_C(10);      /** @brief Output 1 reset flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_SET1XC_POS = INT32_C(9);       /** @brief Output 1 set flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_CPT2C_POS = INT32_C(8);        /** @brief Capture2 interrupt flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_CPT1C_POS = INT32_C(7);        /** @brief Capture1 interrupt flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_UPDC_POS = INT32_C(6);         /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_REPC_POS = INT32_C(4);         /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMB_FLTBR_DLYPRTDE_POS = INT32_C(30);    /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMB_FLTBR_RSTDE_POS = INT32_C(29);       /** @brief RSTDE */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX2DE_POS = INT32_C(28);     /** @brief RSTx2DE */
    static const int32_t HRTIM_TIMB_FLTBR_SETX2DE_POS = INT32_C(27);     /** @brief SETx2DE */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX1DE_POS = INT32_C(26);     /** @brief RSTx1DE */
    static const int32_t HRTIM_TIMB_FLTBR_SET1XDE_POS = INT32_C(25);     /** @brief SET1xDE */
    static const int32_t HRTIM_TIMB_FLTBR_CPT2DE_POS = INT32_C(24);      /** @brief CPT2DE */
    static const int32_t HRTIM_TIMB_FLTBR_CPT1DE_POS = INT32_C(23);      /** @brief CPT1DE */
    static const int32_t HRTIM_TIMB_FLTBR_UPDDE_POS = INT32_C(22);       /** @brief UPDDE */
    static const int32_t HRTIM_TIMB_FLTBR_REPDE_POS = INT32_C(20);       /** @brief REPDE */
    static const int32_t HRTIM_TIMB_FLTBR_DLYPRTIE_POS = INT32_C(14);    /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMB_FLTBR_RSTIE_POS = INT32_C(13);       /** @brief RSTIE */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX2IE_POS = INT32_C(12);     /** @brief RSTx2IE */
    static const int32_t HRTIM_TIMB_FLTBR_SETX2IE_POS = INT32_C(11);     /** @brief SETx2IE */
    static const int32_t HRTIM_TIMB_FLTBR_RSTX1IE_POS = INT32_C(10);     /** @brief RSTx1IE */
    static const int32_t HRTIM_TIMB_FLTBR_SET1XIE_POS = INT32_C(9);      /** @brief SET1xIE */
    static const int32_t HRTIM_TIMB_FLTBR_CPT2IE_POS = INT32_C(8);       /** @brief CPT2IE */
    static const int32_t HRTIM_TIMB_FLTBR_CPT1IE_POS = INT32_C(7);       /** @brief CPT1IE */
    static const int32_t HRTIM_TIMB_FLTBR_UPDIE_POS = INT32_C(6);        /** @brief UPDIE */
    static const int32_t HRTIM_TIMB_FLTBR_REPIE_POS = INT32_C(4);        /** @brief REPIE */
    static const int32_t HRTIM_TIMB_FLTBR_CNTX_POS = INT32_C(0);         /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMB_FLTBR_PERX_POS = INT32_C(0);         /** @brief Timerx period value */
    static const int32_t HRTIM_TIMB_FLTBR_REPX_POS = INT32_C(0);         /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMB_FLTBR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMB_FLTBR_REPX_POS = INT32_C(16);        /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMB_FLTBR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMB_FLTBR_CMP2X_POS = INT32_C(0);        /** @brief Timerx compare 2 value */
    static const int32_t HRTIM_TIMB_FLTBR_CMP3X_POS = INT32_C(0);        /** @brief Timerx compare 3 value */
    static const int32_t HRTIM_TIMB_FLTBR_CMP4X_POS = INT32_C(0);        /** @brief Timerx compare 4 value */
    static const int32_t HRTIM_TIMB_FLTBR_CPT1X_POS = INT32_C(0);        /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMB_FLTBR_CPT2X_POS = INT32_C(0);        /** @brief Timerx capture 2 value */
    static const int32_t HRTIM_TIMB_FLTBR_DTFLKX_POS = INT32_C(31);      /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMB_FLTBR_DTFSLKX_POS = INT32_C(30);     /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMB_FLTBR_SDTFX_POS = INT32_C(25);       /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMB_FLTBR_DTFX_POS = INT32_C(16);        /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMB_FLTBR_DTRLKX_POS = INT32_C(15);      /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMB_FLTBR_DTRSLKX_POS = INT32_C(14);     /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMB_FLTBR_DTPRSC_POS = INT32_C(10);      /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMB_FLTBR_SDTRX_POS = INT32_C(9);        /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMB_FLTBR_DTRX_POS = INT32_C(0);         /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMB_FLTBR_UPDATE_POS = INT32_C(31);      /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMB_FLTBR_EXTEVNT1_POS = INT32_C(21);    /** @brief External event 1 */
    static const int32_t HRTIM_TIMB_FLTBR_MSTPER_POS = INT32_C(7);       /** @brief Master period */
    static const int32_t HRTIM_TIMB_FLTBR_PER_POS = INT32_C(2);          /** @brief Timer A period */
    static const int32_t HRTIM_TIMB_FLTBR_RESYNC_POS = INT32_C(1);       /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMB_FLTBR_SST_POS = INT32_C(0);          /** @brief Software set trigger */
    static const int32_t HRTIM_TIMB_FLTBR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMB_FLTBR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMB_FLTBR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMB_FLTBR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMB_FLTBR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMB_FLTBR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMB_FLTBR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMB_FLTBR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMB_FLTBR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMB_FLTBR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMB_FLTBR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMB_FLTBR_SST_POS = INT32_C(0);          /** @brief SST */
    static const int32_t HRTIM_TIMB_FLTBR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMB_FLTBR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMB_FLTBR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMB_FLTBR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMB_FLTBR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMB_FLTBR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMB_FLTBR_EXTEVNT1_POS = INT32_C(9);     /** @brief External event 1 */
    static const int32_t HRTIM_TIMB_FLTBR_MSTPER_POS = INT32_C(4);       /** @brief Master timer period */
    static const int32_t HRTIM_TIMB_FLTBR_CMP4_POS = INT32_C(3);         /** @brief Timer A compare 4 reset */
    static const int32_t HRTIM_TIMB_FLTBR_CMP2_POS = INT32_C(2);         /** @brief Timer A compare 2 reset */
    static const int32_t HRTIM_TIMB_FLTBR_UPDT_POS = INT32_C(1);         /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMB_FLTBR_STRTPW_POS = INT32_C(7);       /** @brief STRTPW */
    static const int32_t HRTIM_TIMB_FLTBR_CHPDTY_POS = INT32_C(4);       /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMB_FLTBR_CHPFRQ_POS = INT32_C(0);       /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMB_FLTBR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMB_FLTBR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMB_FLTBR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMB_FLTBR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIMB_FLTBR_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIMB_FLTBR_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMB_FLTBR_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMB_FLTBR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMB_FLTBR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMB_FLTBR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMB_FLTBR_DIDL2_POS = INT32_C(23);       /** @brief Output 2 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMB_FLTBR_CHP2_POS = INT32_C(22);        /** @brief Output 2 chopper enable */
    static const int32_t HRTIM_TIMB_FLTBR_FAULT2_POS = INT32_C(20);      /** @brief Output 2 fault state */
    static const int32_t HRTIM_TIMB_FLTBR_IDLES2_POS = INT32_C(19);      /** @brief Output 2 idle state */
    static const int32_t HRTIM_TIMB_FLTBR_IDLEM2_POS = INT32_C(18);      /** @brief Output 2 idle mode */
    static const int32_t HRTIM_TIMB_FLTBR_POL2_POS = INT32_C(17);        /** @brief Output 2 polarity */
    static const int32_t HRTIM_TIMB_FLTBR_DLYPRT_POS = INT32_C(10);      /** @brief Delayed protection */
    static const int32_t HRTIM_TIMB_FLTBR_DLYPRTEN_POS = INT32_C(9);     /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMB_FLTBR_DTEN_POS = INT32_C(8);         /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMB_FLTBR_DIDL1_POS = INT32_C(7);        /** @brief Output 1 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMB_FLTBR_CHP1_POS = INT32_C(6);         /** @brief Output 1 chopper enable */
    static const int32_t HRTIM_TIMB_FLTBR_FAULT1_POS = INT32_C(4);       /** @brief Output 1 fault state */
    static const int32_t HRTIM_TIMB_FLTBR_IDLES1_POS = INT32_C(3);       /** @brief Output 1 idle state */
    static const int32_t HRTIM_TIMB_FLTBR_IDLEM1_POS = INT32_C(2);       /** @brief Output 1 idle mode */
    static const int32_t HRTIM_TIMB_FLTBR_POL1_POS = INT32_C(1);         /** @brief Output 1 polarity */
    static const int32_t HRTIM_TIMB_FLTBR_FLTLCK_POS = INT32_C(31);      /** @brief Fault sources lock */

    /**********************************************************************************************
     * @section HRTIM_TIMC Definitions
     **********************************************************************************************/

    /** @subsection HRTIM_TIMC IRQ interrupt definitions */

    static const int32_t HRTIM_TIMB_IRQ = INT32_C(105);   /** @brief HRTIM1 timer B interrupt */

    /** @subsection HRTIM_TIMC register array definitions */

    static _RW uint32_t* const HRTIM_TIMC_CMPXCR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001759C),   /** @brief Timerx compare 1 register */
      (_RW uint32_t* const)UINT32_C(0x400175A4),   /** @brief Timerx compare 2 register */
      (_RW uint32_t* const)UINT32_C(0x400175A8),   /** @brief Timerx compare 3 register */
      (_RW uint32_t* const)UINT32_C(0x400175AC),   /** @brief Timerx compare 4 register */
    };

    /** @subsection HRTIM_TIMC register definitions */

    static _RW uint32_t* const HRTIM_TIMC_TIMCCR_REG = (_RW uint32_t* const)UINT32_C(0x40017580);      /** @brief Timerx control register */
    static _RO uint32_t* const HRTIM_TIMC_TIMCISR_REG = (_RO uint32_t* const)UINT32_C(0x40017584);     /** @brief Timerx interrupt status register */
    static _RW uint32_t* const HRTIM_TIMC_TIMCICR_REG = (_RW uint32_t* const)UINT32_C(0x40017588);     /** @brief Timerx interrupt clear register */
    static _RW uint32_t* const HRTIM_TIMC_TIMCDIER5_REG = (_RW uint32_t* const)UINT32_C(0x4001758C);   /** @brief TIMxDIER5 */
    static _RW uint32_t* const HRTIM_TIMC_CNTCR_REG = (_RW uint32_t* const)UINT32_C(0x40017590);       /** @brief Timerx counter register */
    static _RW uint32_t* const HRTIM_TIMC_PERCR_REG = (_RW uint32_t* const)UINT32_C(0x40017594);       /** @brief Timerx period register */
    static _RW uint32_t* const HRTIM_TIMC_REPCR_REG = (_RW uint32_t* const)UINT32_C(0x40017598);       /** @brief Timerx repetition register */
    static _RW uint32_t* const HRTIM_TIMC_CMP1CCR_REG = (_RW uint32_t* const)UINT32_C(0x400175A0);     /** @brief Timerx compare 1 compound register */
    static _RO uint32_t* const HRTIM_TIMC_CPT1CR_REG = (_RO uint32_t* const)UINT32_C(0x400175B0);      /** @brief Timerx capture 1 register */
    static _RO uint32_t* const HRTIM_TIMC_CPT2CR_REG = (_RO uint32_t* const)UINT32_C(0x400175B4);      /** @brief Timerx capture 2 register */
    static _RW uint32_t* const HRTIM_TIMC_DTCR_REG = (_RW uint32_t* const)UINT32_C(0x400175B8);        /** @brief Timerx deadtime register */
    static _RW uint32_t* const HRTIM_TIMC_SETC1R_REG = (_RW uint32_t* const)UINT32_C(0x400175BC);      /** @brief Timerx output1 set register */
    static _RW uint32_t* const HRTIM_TIMC_RSTC1R_REG = (_RW uint32_t* const)UINT32_C(0x400175C0);      /** @brief Timerx output1 reset register */
    static _RW uint32_t* const HRTIM_TIMC_SETC2R_REG = (_RW uint32_t* const)UINT32_C(0x400175C4);      /** @brief Timerx output2 set register */
    static _RW uint32_t* const HRTIM_TIMC_RSTC2R_REG = (_RW uint32_t* const)UINT32_C(0x400175C8);      /** @brief Timerx output2 reset register */
    static _RW uint32_t* const HRTIM_TIMC_EEFCR1_REG = (_RW uint32_t* const)UINT32_C(0x400175CC);      /** @brief Timerx external event filtering register 1 */
    static _RW uint32_t* const HRTIM_TIMC_EEFCR2_REG = (_RW uint32_t* const)UINT32_C(0x400175D0);      /** @brief Timerx external event filtering register 2 */
    static _RW uint32_t* const HRTIM_TIMC_RSTCR_REG = (_RW uint32_t* const)UINT32_C(0x400175D4);       /** @brief TimerA reset register */
    static _RW uint32_t* const HRTIM_TIMC_CHPCR_REG = (_RW uint32_t* const)UINT32_C(0x400175D8);       /** @brief Timerx chopper register */
    static _RW uint32_t* const HRTIM_TIMC_CPT1CCR_REG = (_RW uint32_t* const)UINT32_C(0x400175DC);     /** @brief Timerx capture 2 control register */
    static _RW uint32_t* const HRTIM_TIMC_CPT2CCR_REG = (_RW uint32_t* const)UINT32_C(0x400175E0);     /** @brief CPT2xCR */
    static _RW uint32_t* const HRTIM_TIMC_OUTCR_REG = (_RW uint32_t* const)UINT32_C(0x400175E4);       /** @brief Timerx output register */
    static _RW uint32_t* const HRTIM_TIMC_FLTCR_REG = (_RW uint32_t* const)UINT32_C(0x400175E8);       /** @brief Timerx fault register */

    /** @subsection HRTIM_TIMC field mask array definitions */

    static const uint32_t HRTIM_TIMC_TIMCISR_CMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMC_TIMCICR_CMPXC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag clear */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag clear */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag clear */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_CMPXDE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief CMP1DE */
      UINT32_C(0x00020000),   /** @brief CMP2DE */
      UINT32_C(0x00040000),   /** @brief CMP3DE */
      UINT32_C(0x00080000),   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_CMPXIE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief CMP1IE */
      UINT32_C(0x00000002),   /** @brief CMP2IE */
      UINT32_C(0x00000004),   /** @brief CMP3IE */
      UINT32_C(0x00000008),   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMC_SETC1R_EXTEVNTX_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief External event 2 */
      UINT32_C(0x00800000),   /** @brief External event 3 */
      UINT32_C(0x01000000),   /** @brief External event 4 */
      UINT32_C(0x02000000),   /** @brief External event 5 */
      UINT32_C(0x04000000),   /** @brief External event 6 */
      UINT32_C(0x08000000),   /** @brief External event 7 */
      UINT32_C(0x10000000),   /** @brief External event 8 */
      UINT32_C(0x20000000),   /** @brief External event 9 */
      UINT32_C(0x40000000),   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMC_SETC1R_TIMEVNTX_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief Timer event 1 */
      UINT32_C(0x00002000),   /** @brief Timer event 2 */
      UINT32_C(0x00004000),   /** @brief Timer event 3 */
      UINT32_C(0x00008000),   /** @brief Timer event 4 */
      UINT32_C(0x00010000),   /** @brief Timer event 5 */
      UINT32_C(0x00020000),   /** @brief Timer event 6 */
      UINT32_C(0x00040000),   /** @brief Timer event 7 */
      UINT32_C(0x00080000),   /** @brief Timer event 8 */
      UINT32_C(0x00100000),   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMC_SETC1R_MSTCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Master compare 1 */
      UINT32_C(0x00000200),   /** @brief Master compare 2 */
      UINT32_C(0x00000400),   /** @brief Master compare 3 */
      UINT32_C(0x00000800),   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMC_EEFCR1_EEXFLTR_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000001E),   /** @brief External event 1 filter */
      UINT32_C(0x00000780),   /** @brief External event 2 filter */
      UINT32_C(0x0001E000),   /** @brief External event 3 filter */
      UINT32_C(0x00780000),   /** @brief External event 4 filter */
      UINT32_C(0x1E000000),   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMC_EEFCR1_EEXLTCH_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief External event 1 latch */
      UINT32_C(0x00000040),   /** @brief External event 2 latch */
      UINT32_C(0x00001000),   /** @brief External event 3 latch */
      UINT32_C(0x00040000),   /** @brief External event 4 latch */
      UINT32_C(0x01000000),   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMECMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x10000000),   /** @brief Timer E compare 1 */
      UINT32_C(0x20000000),   /** @brief Timer E compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMDCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x02000000),   /** @brief Timer D compare 1 */
      UINT32_C(0x04000000),   /** @brief Timer D compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x08000000),   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMBCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief Timer B compare 1 */
      UINT32_C(0x00800000),   /** @brief Timer B compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x01000000),   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIMC_RSTCR_TIMACMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00080000),   /** @brief Timer A compare 1 */
      UINT32_C(0x00100000),   /** @brief Timer A compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIMC_CPT1CCR_EXEVXCPT_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief External event 2 capture */
      UINT32_C(0x00000010),   /** @brief External event 3 capture */
      UINT32_C(0x00000020),   /** @brief External event 4 capture */
      UINT32_C(0x00000040),   /** @brief External event 5 capture */
      UINT32_C(0x00000080),   /** @brief External event 6 capture */
      UINT32_C(0x00000100),   /** @brief External event 7 capture */
      UINT32_C(0x00000200),   /** @brief External event 8 capture */
      UINT32_C(0x00000400),   /** @brief External event 9 capture */
      UINT32_C(0x00000800),   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMC_FLTCR_FLTXEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 enable */
      UINT32_C(0x00000002),   /** @brief Fault 2 enable */
      UINT32_C(0x00000004),   /** @brief Fault 3 enable */
      UINT32_C(0x00000008),   /** @brief Fault 4 enable */
      UINT32_C(0x00000010),   /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMC field mask definitions */

    static const uint32_t HRTIM_TIMC_TIMCCR_UPDGAT_MASK = UINT32_C(0xF0000000);        /** @brief Update gating */
    static const uint32_t HRTIM_TIMC_TIMCCR_PREEN_MASK = UINT32_C(0x08000000);         /** @brief Preload enable */
    static const uint32_t HRTIM_TIMC_TIMCCR_DACSYNC_MASK = UINT32_C(0x06000000);       /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMC_TIMCCR_MSTU_MASK = UINT32_C(0x01000000);          /** @brief Master timer update */
    static const uint32_t HRTIM_TIMC_TIMCCR_TEU_MASK = UINT32_C(0x00800000);           /** @brief TEU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TDU_MASK = UINT32_C(0x00400000);           /** @brief TDU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TCU_MASK = UINT32_C(0x00200000);           /** @brief TCU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TBU_MASK = UINT32_C(0x00100000);           /** @brief TBU */
    static const uint32_t HRTIM_TIMC_TIMCCR_TXRSTU_MASK = UINT32_C(0x00040000);        /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMC_TIMCCR_TXREPU_MASK = UINT32_C(0x00020000);        /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMC_TIMCCR_DELCMP4_MASK = UINT32_C(0x0000C000);       /** @brief Delayed CMP4 mode */
    static const uint32_t HRTIM_TIMC_TIMCCR_DELCMP2_MASK = UINT32_C(0x00003000);       /** @brief Delayed CMP2 mode */
    static const uint32_t HRTIM_TIMC_TIMCCR_SYNCSTRTX_MASK = UINT32_C(0x00000800);     /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMC_TIMCCR_SYNCRSTX_MASK = UINT32_C(0x00000400);      /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMC_TIMCCR_PSHPLL_MASK = UINT32_C(0x00000040);        /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMC_TIMCCR_HALF_MASK = UINT32_C(0x00000020);          /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMC_TIMCCR_RETRIG_MASK = UINT32_C(0x00000010);        /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMC_TIMCCR_CONT_MASK = UINT32_C(0x00000008);          /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMC_TIMCCR_CK_PSCX_MASK = UINT32_C(0x00000007);       /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMC_TIMCISR_O2STAT_MASK = UINT32_C(0x00080000);       /** @brief Output 2 state */
    static const uint32_t HRTIM_TIMC_TIMCISR_O1STAT_MASK = UINT32_C(0x00040000);       /** @brief Output 1 state */
    static const uint32_t HRTIM_TIMC_TIMCISR_IPPSTAT_MASK = UINT32_C(0x00020000);      /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMC_TIMCISR_CPPSTAT_MASK = UINT32_C(0x00010000);      /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMC_TIMCISR_DLYPRT_MASK = UINT32_C(0x00004000);       /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_RST_MASK = UINT32_C(0x00002000);          /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_RSTX2_MASK = UINT32_C(0x00001000);        /** @brief Output 2 reset interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_SETX2_MASK = UINT32_C(0x00000800);        /** @brief Output 2 set interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_RSTX1_MASK = UINT32_C(0x00000400);        /** @brief Output 1 reset interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_SETX1_MASK = UINT32_C(0x00000200);        /** @brief Output 1 set interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_CPT2_MASK = UINT32_C(0x00000100);         /** @brief Capture2 interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_CPT1_MASK = UINT32_C(0x00000080);         /** @brief Capture1 interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_UPD_MASK = UINT32_C(0x00000040);          /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCISR_REP_MASK = UINT32_C(0x00000010);          /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMC_TIMCICR_DLYPRTC_MASK = UINT32_C(0x00004000);      /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_RSTC_MASK = UINT32_C(0x00002000);         /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_RSTX2C_MASK = UINT32_C(0x00001000);       /** @brief Output 2 reset flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_SET2XC_MASK = UINT32_C(0x00000800);       /** @brief Output 2 set flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_RSTX1C_MASK = UINT32_C(0x00000400);       /** @brief Output 1 reset flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_SET1XC_MASK = UINT32_C(0x00000200);       /** @brief Output 1 set flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_CPT2C_MASK = UINT32_C(0x00000100);        /** @brief Capture2 interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_CPT1C_MASK = UINT32_C(0x00000080);        /** @brief Capture1 interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_UPDC_MASK = UINT32_C(0x00000040);         /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCICR_REPC_MASK = UINT32_C(0x00000010);         /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_DLYPRTDE_MASK = UINT32_C(0x40000000);   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTDE_MASK = UINT32_C(0x20000000);      /** @brief RSTDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTX2DE_MASK = UINT32_C(0x10000000);    /** @brief RSTx2DE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SETX2DE_MASK = UINT32_C(0x08000000);    /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTX1DE_MASK = UINT32_C(0x04000000);    /** @brief RSTx1DE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SET1XDE_MASK = UINT32_C(0x02000000);    /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_CPT2DE_MASK = UINT32_C(0x01000000);     /** @brief CPT2DE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_CPT1DE_MASK = UINT32_C(0x00800000);     /** @brief CPT1DE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_UPDDE_MASK = UINT32_C(0x00400000);      /** @brief UPDDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_REPDE_MASK = UINT32_C(0x00100000);      /** @brief REPDE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_DLYPRTIE_MASK = UINT32_C(0x00004000);   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTIE_MASK = UINT32_C(0x00002000);      /** @brief RSTIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTX2IE_MASK = UINT32_C(0x00001000);    /** @brief RSTx2IE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SETX2IE_MASK = UINT32_C(0x00000800);    /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RSTX1IE_MASK = UINT32_C(0x00000400);    /** @brief RSTx1IE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_SET1XIE_MASK = UINT32_C(0x00000200);    /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_CPT2IE_MASK = UINT32_C(0x00000100);     /** @brief CPT2IE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_CPT1IE_MASK = UINT32_C(0x00000080);     /** @brief CPT1IE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_UPDIE_MASK = UINT32_C(0x00000040);      /** @brief UPDIE */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_REPIE_MASK = UINT32_C(0x00000010);      /** @brief REPIE */
    static const uint32_t HRTIM_TIMC_CNTCR_CNTX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMC_PERCR_PERX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMC_REPCR_REPX_MASK = UINT32_C(0x000000FF);           /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMC_CMPXCR_CMP1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMC_CMP1CCR_REPX_MASK = UINT32_C(0x00FF0000);         /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMC_CMP1CCR_CMP1X_MASK = UINT32_C(0x0000FFFF);        /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMC_CMPXCR_CMP2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 2 value */
    static const uint32_t HRTIM_TIMC_CMPXCR_CMP3X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 3 value */
    static const uint32_t HRTIM_TIMC_CMPXCR_CMP4X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 4 value */
    static const uint32_t HRTIM_TIMC_CPT1CR_CPT1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMC_CPT2CR_CPT2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 2 value */
    static const uint32_t HRTIM_TIMC_DTCR_DTFLKX_MASK = UINT32_C(0x80000000);          /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMC_DTCR_DTFSLKX_MASK = UINT32_C(0x40000000);         /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMC_DTCR_SDTFX_MASK = UINT32_C(0x02000000);           /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMC_DTCR_DTFX_MASK = UINT32_C(0x01FF0000);            /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMC_DTCR_DTRLKX_MASK = UINT32_C(0x00008000);          /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMC_DTCR_DTRSLKX_MASK = UINT32_C(0x00004000);         /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMC_DTCR_DTPRSC_MASK = UINT32_C(0x00001C00);          /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMC_DTCR_SDTRX_MASK = UINT32_C(0x00000200);           /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMC_DTCR_DTRX_MASK = UINT32_C(0x000001FF);            /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMC_SETC1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief External event 1 */
    static const uint32_t HRTIM_TIMC_SETC1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief Master period */
    static const uint32_t HRTIM_TIMC_SETC1R_PER_MASK = UINT32_C(0x00000004);           /** @brief Timer A period */
    static const uint32_t HRTIM_TIMC_SETC1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMC_SETC1R_SST_MASK = UINT32_C(0x00000001);           /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMC_RSTC1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMC_RSTC1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMC_RSTC1R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMC_RSTC1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMC_RSTC1R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMC_SETC2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMC_SETC2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMC_SETC2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMC_SETC2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMC_SETC2R_SST_MASK = UINT32_C(0x00000001);           /** @brief SST */
    static const uint32_t HRTIM_TIMC_RSTC2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMC_RSTC2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMC_RSTC2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMC_RSTC2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMC_RSTC2R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT1_MASK = UINT32_C(0x00000200);       /** @brief External event 1 */
    static const uint32_t HRTIM_TIMC_RSTCR_MSTPER_MASK = UINT32_C(0x00000010);         /** @brief Master timer period */
    static const uint32_t HRTIM_TIMC_RSTCR_CMP4_MASK = UINT32_C(0x00000008);           /** @brief Timer A compare 4 reset */
    static const uint32_t HRTIM_TIMC_RSTCR_CMP2_MASK = UINT32_C(0x00000004);           /** @brief Timer A compare 2 reset */
    static const uint32_t HRTIM_TIMC_RSTCR_UPDT_MASK = UINT32_C(0x00000002);           /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMC_CHPCR_STRTPW_MASK = UINT32_C(0x00000780);         /** @brief STRTPW */
    static const uint32_t HRTIM_TIMC_CHPCR_CHPDTY_MASK = UINT32_C(0x00000070);         /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMC_CHPCR_CHPFRQ_MASK = UINT32_C(0x0000000F);         /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT1CCR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMC_CPT1CCR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMC_CPT1CCR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMC_CPT1CCR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMC_CPT2CCR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMC_CPT2CCR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMC_CPT2CCR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMC_CPT2CCR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMC_OUTCR_DIDL2_MASK = UINT32_C(0x00800000);          /** @brief Output 2 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMC_OUTCR_CHP2_MASK = UINT32_C(0x00400000);           /** @brief Output 2 chopper enable */
    static const uint32_t HRTIM_TIMC_OUTCR_FAULT2_MASK = UINT32_C(0x00300000);         /** @brief Output 2 fault state */
    static const uint32_t HRTIM_TIMC_OUTCR_IDLES2_MASK = UINT32_C(0x00080000);         /** @brief Output 2 idle state */
    static const uint32_t HRTIM_TIMC_OUTCR_IDLEM2_MASK = UINT32_C(0x00040000);         /** @brief Output 2 idle mode */
    static const uint32_t HRTIM_TIMC_OUTCR_POL2_MASK = UINT32_C(0x00020000);           /** @brief Output 2 polarity */
    static const uint32_t HRTIM_TIMC_OUTCR_DLYPRT_MASK = UINT32_C(0x00001C00);         /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMC_OUTCR_DLYPRTEN_MASK = UINT32_C(0x00000200);       /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMC_OUTCR_DTEN_MASK = UINT32_C(0x00000100);           /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMC_OUTCR_DIDL1_MASK = UINT32_C(0x00000080);          /** @brief Output 1 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMC_OUTCR_CHP1_MASK = UINT32_C(0x00000040);           /** @brief Output 1 chopper enable */
    static const uint32_t HRTIM_TIMC_OUTCR_FAULT1_MASK = UINT32_C(0x00000030);         /** @brief Output 1 fault state */
    static const uint32_t HRTIM_TIMC_OUTCR_IDLES1_MASK = UINT32_C(0x00000008);         /** @brief Output 1 idle state */
    static const uint32_t HRTIM_TIMC_OUTCR_IDLEM1_MASK = UINT32_C(0x00000004);         /** @brief Output 1 idle mode */
    static const uint32_t HRTIM_TIMC_OUTCR_POL1_MASK = UINT32_C(0x00000002);           /** @brief Output 1 polarity */
    static const uint32_t HRTIM_TIMC_FLTCR_FLTLCK_MASK = UINT32_C(0x80000000);         /** @brief Fault sources lock */

    /** @subsection HRTIM_TIMC field position array definitions */

    static const int32_t HRTIM_TIMC_FLTCR_CMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag */
      INT32_C(1),    /** @brief Compare 2 interrupt flag */
      INT32_C(2),    /** @brief Compare 3 interrupt flag */
      INT32_C(3),    /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMC_FLTCR_CMPXC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag clear */
      INT32_C(1),    /** @brief Compare 2 interrupt flag clear */
      INT32_C(2),    /** @brief Compare 3 interrupt flag clear */
      INT32_C(3),    /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMC_FLTCR_CMPXDE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief CMP1DE */
      INT32_C(17),   /** @brief CMP2DE */
      INT32_C(18),   /** @brief CMP3DE */
      INT32_C(19),   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMC_FLTCR_CMPXIE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief CMP1IE */
      INT32_C(1),    /** @brief CMP2IE */
      INT32_C(2),    /** @brief CMP3IE */
      INT32_C(3),    /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMC_FLTCR_EXTEVNTX_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief External event 2 */
      INT32_C(23),   /** @brief External event 3 */
      INT32_C(24),   /** @brief External event 4 */
      INT32_C(25),   /** @brief External event 5 */
      INT32_C(26),   /** @brief External event 6 */
      INT32_C(27),   /** @brief External event 7 */
      INT32_C(28),   /** @brief External event 8 */
      INT32_C(29),   /** @brief External event 9 */
      INT32_C(30),   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMC_FLTCR_TIMEVNTX_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief Timer event 1 */
      INT32_C(13),   /** @brief Timer event 2 */
      INT32_C(14),   /** @brief Timer event 3 */
      INT32_C(15),   /** @brief Timer event 4 */
      INT32_C(16),   /** @brief Timer event 5 */
      INT32_C(17),   /** @brief Timer event 6 */
      INT32_C(18),   /** @brief Timer event 7 */
      INT32_C(19),   /** @brief Timer event 8 */
      INT32_C(20),   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMC_FLTCR_MSTCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Master compare 1 */
      INT32_C(9),    /** @brief Master compare 2 */
      INT32_C(10),   /** @brief Master compare 3 */
      INT32_C(11),   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMC_FLTCR_EEXFLTR_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief External event 1 filter */
      INT32_C(7),    /** @brief External event 2 filter */
      INT32_C(13),   /** @brief External event 3 filter */
      INT32_C(19),   /** @brief External event 4 filter */
      INT32_C(25),   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMC_FLTCR_EEXLTCH_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief External event 1 latch */
      INT32_C(6),    /** @brief External event 2 latch */
      INT32_C(12),   /** @brief External event 3 latch */
      INT32_C(18),   /** @brief External event 4 latch */
      INT32_C(24),   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMC_FLTCR_TIMECMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(28),   /** @brief Timer E compare 1 */
      INT32_C(29),   /** @brief Timer E compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMC_FLTCR_TIMDCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(25),   /** @brief Timer D compare 1 */
      INT32_C(26),   /** @brief Timer D compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(27),   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIMC_FLTCR_TIMBCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief Timer B compare 1 */
      INT32_C(23),   /** @brief Timer B compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(24),   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIMC_FLTCR_TIMACMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(19),   /** @brief Timer A compare 1 */
      INT32_C(20),   /** @brief Timer A compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIMC_FLTCR_EXEVXCPT_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief External event 2 capture */
      INT32_C(4),    /** @brief External event 3 capture */
      INT32_C(5),    /** @brief External event 4 capture */
      INT32_C(6),    /** @brief External event 5 capture */
      INT32_C(7),    /** @brief External event 6 capture */
      INT32_C(8),    /** @brief External event 7 capture */
      INT32_C(9),    /** @brief External event 8 capture */
      INT32_C(10),   /** @brief External event 9 capture */
      INT32_C(11),   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMC_FLTCR_FLTXEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 enable */
      INT32_C(1),    /** @brief Fault 2 enable */
      INT32_C(2),    /** @brief Fault 3 enable */
      INT32_C(3),    /** @brief Fault 4 enable */
      INT32_C(4),    /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMC field position definitions */

    static const int32_t HRTIM_TIMC_FLTCR_UPDGAT_POS = INT32_C(28);      /** @brief Update gating */
    static const int32_t HRTIM_TIMC_FLTCR_PREEN_POS = INT32_C(27);       /** @brief Preload enable */
    static const int32_t HRTIM_TIMC_FLTCR_DACSYNC_POS = INT32_C(25);     /** @brief AC synchronization */
    static const int32_t HRTIM_TIMC_FLTCR_MSTU_POS = INT32_C(24);        /** @brief Master timer update */
    static const int32_t HRTIM_TIMC_FLTCR_TEU_POS = INT32_C(23);         /** @brief TEU */
    static const int32_t HRTIM_TIMC_FLTCR_TDU_POS = INT32_C(22);         /** @brief TDU */
    static const int32_t HRTIM_TIMC_FLTCR_TCU_POS = INT32_C(21);         /** @brief TCU */
    static const int32_t HRTIM_TIMC_FLTCR_TBU_POS = INT32_C(20);         /** @brief TBU */
    static const int32_t HRTIM_TIMC_FLTCR_TXRSTU_POS = INT32_C(18);      /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMC_FLTCR_TXREPU_POS = INT32_C(17);      /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMC_FLTCR_DELCMP4_POS = INT32_C(14);     /** @brief Delayed CMP4 mode */
    static const int32_t HRTIM_TIMC_FLTCR_DELCMP2_POS = INT32_C(12);     /** @brief Delayed CMP2 mode */
    static const int32_t HRTIM_TIMC_FLTCR_SYNCSTRTX_POS = INT32_C(11);   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMC_FLTCR_SYNCRSTX_POS = INT32_C(10);    /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMC_FLTCR_PSHPLL_POS = INT32_C(6);       /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMC_FLTCR_HALF_POS = INT32_C(5);         /** @brief Half mode enable */
    static const int32_t HRTIM_TIMC_FLTCR_RETRIG_POS = INT32_C(4);       /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMC_FLTCR_CONT_POS = INT32_C(3);         /** @brief Continuous mode */
    static const int32_t HRTIM_TIMC_FLTCR_CK_PSCX_POS = INT32_C(0);      /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMC_FLTCR_O2STAT_POS = INT32_C(19);      /** @brief Output 2 state */
    static const int32_t HRTIM_TIMC_FLTCR_O1STAT_POS = INT32_C(18);      /** @brief Output 1 state */
    static const int32_t HRTIM_TIMC_FLTCR_IPPSTAT_POS = INT32_C(17);     /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMC_FLTCR_CPPSTAT_POS = INT32_C(16);     /** @brief Current push pull status */
    static const int32_t HRTIM_TIMC_FLTCR_DLYPRT_POS = INT32_C(14);      /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMC_FLTCR_RST_POS = INT32_C(13);         /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX2_POS = INT32_C(12);       /** @brief Output 2 reset interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_SETX2_POS = INT32_C(11);       /** @brief Output 2 set interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX1_POS = INT32_C(10);       /** @brief Output 1 reset interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_SETX1_POS = INT32_C(9);        /** @brief Output 1 set interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_CPT2_POS = INT32_C(8);         /** @brief Capture2 interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_CPT1_POS = INT32_C(7);         /** @brief Capture1 interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_UPD_POS = INT32_C(6);          /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_REP_POS = INT32_C(4);          /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMC_FLTCR_DLYPRTC_POS = INT32_C(14);     /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_RSTC_POS = INT32_C(13);        /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX2C_POS = INT32_C(12);      /** @brief Output 2 reset flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_SET2XC_POS = INT32_C(11);      /** @brief Output 2 set flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX1C_POS = INT32_C(10);      /** @brief Output 1 reset flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_SET1XC_POS = INT32_C(9);       /** @brief Output 1 set flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_CPT2C_POS = INT32_C(8);        /** @brief Capture2 interrupt flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_CPT1C_POS = INT32_C(7);        /** @brief Capture1 interrupt flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_UPDC_POS = INT32_C(6);         /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_REPC_POS = INT32_C(4);         /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMC_FLTCR_DLYPRTDE_POS = INT32_C(30);    /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMC_FLTCR_RSTDE_POS = INT32_C(29);       /** @brief RSTDE */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX2DE_POS = INT32_C(28);     /** @brief RSTx2DE */
    static const int32_t HRTIM_TIMC_FLTCR_SETX2DE_POS = INT32_C(27);     /** @brief SETx2DE */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX1DE_POS = INT32_C(26);     /** @brief RSTx1DE */
    static const int32_t HRTIM_TIMC_FLTCR_SET1XDE_POS = INT32_C(25);     /** @brief SET1xDE */
    static const int32_t HRTIM_TIMC_FLTCR_CPT2DE_POS = INT32_C(24);      /** @brief CPT2DE */
    static const int32_t HRTIM_TIMC_FLTCR_CPT1DE_POS = INT32_C(23);      /** @brief CPT1DE */
    static const int32_t HRTIM_TIMC_FLTCR_UPDDE_POS = INT32_C(22);       /** @brief UPDDE */
    static const int32_t HRTIM_TIMC_FLTCR_REPDE_POS = INT32_C(20);       /** @brief REPDE */
    static const int32_t HRTIM_TIMC_FLTCR_DLYPRTIE_POS = INT32_C(14);    /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMC_FLTCR_RSTIE_POS = INT32_C(13);       /** @brief RSTIE */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX2IE_POS = INT32_C(12);     /** @brief RSTx2IE */
    static const int32_t HRTIM_TIMC_FLTCR_SETX2IE_POS = INT32_C(11);     /** @brief SETx2IE */
    static const int32_t HRTIM_TIMC_FLTCR_RSTX1IE_POS = INT32_C(10);     /** @brief RSTx1IE */
    static const int32_t HRTIM_TIMC_FLTCR_SET1XIE_POS = INT32_C(9);      /** @brief SET1xIE */
    static const int32_t HRTIM_TIMC_FLTCR_CPT2IE_POS = INT32_C(8);       /** @brief CPT2IE */
    static const int32_t HRTIM_TIMC_FLTCR_CPT1IE_POS = INT32_C(7);       /** @brief CPT1IE */
    static const int32_t HRTIM_TIMC_FLTCR_UPDIE_POS = INT32_C(6);        /** @brief UPDIE */
    static const int32_t HRTIM_TIMC_FLTCR_REPIE_POS = INT32_C(4);        /** @brief REPIE */
    static const int32_t HRTIM_TIMC_FLTCR_CNTX_POS = INT32_C(0);         /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMC_FLTCR_PERX_POS = INT32_C(0);         /** @brief Timerx period value */
    static const int32_t HRTIM_TIMC_FLTCR_REPX_POS = INT32_C(0);         /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMC_FLTCR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMC_FLTCR_REPX_POS = INT32_C(16);        /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMC_FLTCR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMC_FLTCR_CMP2X_POS = INT32_C(0);        /** @brief Timerx compare 2 value */
    static const int32_t HRTIM_TIMC_FLTCR_CMP3X_POS = INT32_C(0);        /** @brief Timerx compare 3 value */
    static const int32_t HRTIM_TIMC_FLTCR_CMP4X_POS = INT32_C(0);        /** @brief Timerx compare 4 value */
    static const int32_t HRTIM_TIMC_FLTCR_CPT1X_POS = INT32_C(0);        /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMC_FLTCR_CPT2X_POS = INT32_C(0);        /** @brief Timerx capture 2 value */
    static const int32_t HRTIM_TIMC_FLTCR_DTFLKX_POS = INT32_C(31);      /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMC_FLTCR_DTFSLKX_POS = INT32_C(30);     /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMC_FLTCR_SDTFX_POS = INT32_C(25);       /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMC_FLTCR_DTFX_POS = INT32_C(16);        /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMC_FLTCR_DTRLKX_POS = INT32_C(15);      /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMC_FLTCR_DTRSLKX_POS = INT32_C(14);     /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMC_FLTCR_DTPRSC_POS = INT32_C(10);      /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMC_FLTCR_SDTRX_POS = INT32_C(9);        /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMC_FLTCR_DTRX_POS = INT32_C(0);         /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMC_FLTCR_UPDATE_POS = INT32_C(31);      /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMC_FLTCR_EXTEVNT1_POS = INT32_C(21);    /** @brief External event 1 */
    static const int32_t HRTIM_TIMC_FLTCR_MSTPER_POS = INT32_C(7);       /** @brief Master period */
    static const int32_t HRTIM_TIMC_FLTCR_PER_POS = INT32_C(2);          /** @brief Timer A period */
    static const int32_t HRTIM_TIMC_FLTCR_RESYNC_POS = INT32_C(1);       /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMC_FLTCR_SST_POS = INT32_C(0);          /** @brief Software set trigger */
    static const int32_t HRTIM_TIMC_FLTCR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMC_FLTCR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMC_FLTCR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMC_FLTCR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMC_FLTCR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMC_FLTCR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMC_FLTCR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMC_FLTCR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMC_FLTCR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMC_FLTCR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMC_FLTCR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMC_FLTCR_SST_POS = INT32_C(0);          /** @brief SST */
    static const int32_t HRTIM_TIMC_FLTCR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMC_FLTCR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMC_FLTCR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMC_FLTCR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMC_FLTCR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMC_FLTCR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMC_FLTCR_EXTEVNT1_POS = INT32_C(9);     /** @brief External event 1 */
    static const int32_t HRTIM_TIMC_FLTCR_MSTPER_POS = INT32_C(4);       /** @brief Master timer period */
    static const int32_t HRTIM_TIMC_FLTCR_CMP4_POS = INT32_C(3);         /** @brief Timer A compare 4 reset */
    static const int32_t HRTIM_TIMC_FLTCR_CMP2_POS = INT32_C(2);         /** @brief Timer A compare 2 reset */
    static const int32_t HRTIM_TIMC_FLTCR_UPDT_POS = INT32_C(1);         /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMC_FLTCR_STRTPW_POS = INT32_C(7);       /** @brief STRTPW */
    static const int32_t HRTIM_TIMC_FLTCR_CHPDTY_POS = INT32_C(4);       /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMC_FLTCR_CHPFRQ_POS = INT32_C(0);       /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMC_FLTCR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMC_FLTCR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMC_FLTCR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMC_FLTCR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIMC_FLTCR_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIMC_FLTCR_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMC_FLTCR_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMC_FLTCR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMC_FLTCR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMC_FLTCR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMC_FLTCR_DIDL2_POS = INT32_C(23);       /** @brief Output 2 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMC_FLTCR_CHP2_POS = INT32_C(22);        /** @brief Output 2 chopper enable */
    static const int32_t HRTIM_TIMC_FLTCR_FAULT2_POS = INT32_C(20);      /** @brief Output 2 fault state */
    static const int32_t HRTIM_TIMC_FLTCR_IDLES2_POS = INT32_C(19);      /** @brief Output 2 idle state */
    static const int32_t HRTIM_TIMC_FLTCR_IDLEM2_POS = INT32_C(18);      /** @brief Output 2 idle mode */
    static const int32_t HRTIM_TIMC_FLTCR_POL2_POS = INT32_C(17);        /** @brief Output 2 polarity */
    static const int32_t HRTIM_TIMC_FLTCR_DLYPRT_POS = INT32_C(10);      /** @brief Delayed protection */
    static const int32_t HRTIM_TIMC_FLTCR_DLYPRTEN_POS = INT32_C(9);     /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMC_FLTCR_DTEN_POS = INT32_C(8);         /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMC_FLTCR_DIDL1_POS = INT32_C(7);        /** @brief Output 1 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMC_FLTCR_CHP1_POS = INT32_C(6);         /** @brief Output 1 chopper enable */
    static const int32_t HRTIM_TIMC_FLTCR_FAULT1_POS = INT32_C(4);       /** @brief Output 1 fault state */
    static const int32_t HRTIM_TIMC_FLTCR_IDLES1_POS = INT32_C(3);       /** @brief Output 1 idle state */
    static const int32_t HRTIM_TIMC_FLTCR_IDLEM1_POS = INT32_C(2);       /** @brief Output 1 idle mode */
    static const int32_t HRTIM_TIMC_FLTCR_POL1_POS = INT32_C(1);         /** @brief Output 1 polarity */
    static const int32_t HRTIM_TIMC_FLTCR_FLTLCK_POS = INT32_C(31);      /** @brief Fault sources lock */

    /**********************************************************************************************
     * @section HRTIM_TIMD Definitions
     **********************************************************************************************/

    /** @subsection HRTIM_TIMD IRQ interrupt definitions */

    static const int32_t HRTIM1_TIMC_IRQ = INT32_C(106);   /** @brief HRTIM1 timer C interrupt */

    /** @subsection HRTIM_TIMD register array definitions */

    static _RW uint32_t* const HRTIM_TIMD_CMPXDR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001761C),   /** @brief Timerx compare 1 register */
      (_RW uint32_t* const)UINT32_C(0x40017624),   /** @brief Timerx compare 2 register */
      (_RW uint32_t* const)UINT32_C(0x40017628),   /** @brief Timerx compare 3 register */
      (_RW uint32_t* const)UINT32_C(0x4001762C),   /** @brief Timerx compare 4 register */
    };

    /** @subsection HRTIM_TIMD register definitions */

    static _RW uint32_t* const HRTIM_TIMD_TIMDCR_REG = (_RW uint32_t* const)UINT32_C(0x40017600);      /** @brief Timerx control register */
    static _RO uint32_t* const HRTIM_TIMD_TIMDISR_REG = (_RO uint32_t* const)UINT32_C(0x40017604);     /** @brief Timerx interrupt status register */
    static _RW uint32_t* const HRTIM_TIMD_TIMDICR_REG = (_RW uint32_t* const)UINT32_C(0x40017608);     /** @brief Timerx interrupt clear register */
    static _RW uint32_t* const HRTIM_TIMD_TIMDDIER5_REG = (_RW uint32_t* const)UINT32_C(0x4001760C);   /** @brief TIMxDIER5 */
    static _RW uint32_t* const HRTIM_TIMD_CNTDR_REG = (_RW uint32_t* const)UINT32_C(0x40017610);       /** @brief Timerx counter register */
    static _RW uint32_t* const HRTIM_TIMD_PERDR_REG = (_RW uint32_t* const)UINT32_C(0x40017614);       /** @brief Timerx period register */
    static _RW uint32_t* const HRTIM_TIMD_REPDR_REG = (_RW uint32_t* const)UINT32_C(0x40017618);       /** @brief Timerx repetition register */
    static _RW uint32_t* const HRTIM_TIMD_CMP1CDR_REG = (_RW uint32_t* const)UINT32_C(0x40017620);     /** @brief Timerx compare 1 compound register */
    static _RO uint32_t* const HRTIM_TIMD_CPT1DR_REG = (_RO uint32_t* const)UINT32_C(0x40017630);      /** @brief Timerx capture 1 register */
    static _RO uint32_t* const HRTIM_TIMD_CPT2DR_REG = (_RO uint32_t* const)UINT32_C(0x40017634);      /** @brief Timerx capture 2 register */
    static _RW uint32_t* const HRTIM_TIMD_DTDR_REG = (_RW uint32_t* const)UINT32_C(0x40017638);        /** @brief Timerx deadtime register */
    static _RW uint32_t* const HRTIM_TIMD_SETD1R_REG = (_RW uint32_t* const)UINT32_C(0x4001763C);      /** @brief Timerx output1 set register */
    static _RW uint32_t* const HRTIM_TIMD_RSTD1R_REG = (_RW uint32_t* const)UINT32_C(0x40017640);      /** @brief Timerx output1 reset register */
    static _RW uint32_t* const HRTIM_TIMD_SETD2R_REG = (_RW uint32_t* const)UINT32_C(0x40017644);      /** @brief Timerx output2 set register */
    static _RW uint32_t* const HRTIM_TIMD_RSTD2R_REG = (_RW uint32_t* const)UINT32_C(0x40017648);      /** @brief Timerx output2 reset register */
    static _RW uint32_t* const HRTIM_TIMD_EEFDR1_REG = (_RW uint32_t* const)UINT32_C(0x4001764C);      /** @brief Timerx external event filtering register 1 */
    static _RW uint32_t* const HRTIM_TIMD_EEFDR2_REG = (_RW uint32_t* const)UINT32_C(0x40017650);      /** @brief Timerx external event filtering register 2 */
    static _RW uint32_t* const HRTIM_TIMD_RSTDR_REG = (_RW uint32_t* const)UINT32_C(0x40017654);       /** @brief TimerA reset register */
    static _RW uint32_t* const HRTIM_TIMD_CHPDR_REG = (_RW uint32_t* const)UINT32_C(0x40017658);       /** @brief Timerx chopper register */
    static _RW uint32_t* const HRTIM_TIMD_CPT1DCR_REG = (_RW uint32_t* const)UINT32_C(0x4001765C);     /** @brief Timerx capture 2 control register */
    static _RW uint32_t* const HRTIM_TIMD_CPT2DCR_REG = (_RW uint32_t* const)UINT32_C(0x40017660);     /** @brief CPT2xCR */
    static _RW uint32_t* const HRTIM_TIMD_OUTDR_REG = (_RW uint32_t* const)UINT32_C(0x40017664);       /** @brief Timerx output register */
    static _RW uint32_t* const HRTIM_TIMD_FLTDR_REG = (_RW uint32_t* const)UINT32_C(0x40017668);       /** @brief Timerx fault register */

    /** @subsection HRTIM_TIMD field mask array definitions */

    static const uint32_t HRTIM_TIMD_TIMDISR_CMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMD_TIMDICR_CMPXC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag clear */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag clear */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag clear */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_CMPXDE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief CMP1DE */
      UINT32_C(0x00020000),   /** @brief CMP2DE */
      UINT32_C(0x00040000),   /** @brief CMP3DE */
      UINT32_C(0x00080000),   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_CMPXIE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief CMP1IE */
      UINT32_C(0x00000002),   /** @brief CMP2IE */
      UINT32_C(0x00000004),   /** @brief CMP3IE */
      UINT32_C(0x00000008),   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMD_SETD1R_EXTEVNTX_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief External event 2 */
      UINT32_C(0x00800000),   /** @brief External event 3 */
      UINT32_C(0x01000000),   /** @brief External event 4 */
      UINT32_C(0x02000000),   /** @brief External event 5 */
      UINT32_C(0x04000000),   /** @brief External event 6 */
      UINT32_C(0x08000000),   /** @brief External event 7 */
      UINT32_C(0x10000000),   /** @brief External event 8 */
      UINT32_C(0x20000000),   /** @brief External event 9 */
      UINT32_C(0x40000000),   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIMD_SETD1R_TIMEVNTX_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief Timer event 1 */
      UINT32_C(0x00002000),   /** @brief Timer event 2 */
      UINT32_C(0x00004000),   /** @brief Timer event 3 */
      UINT32_C(0x00008000),   /** @brief Timer event 4 */
      UINT32_C(0x00010000),   /** @brief Timer event 5 */
      UINT32_C(0x00020000),   /** @brief Timer event 6 */
      UINT32_C(0x00040000),   /** @brief Timer event 7 */
      UINT32_C(0x00080000),   /** @brief Timer event 8 */
      UINT32_C(0x00100000),   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIMD_SETD1R_MSTCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Master compare 1 */
      UINT32_C(0x00000200),   /** @brief Master compare 2 */
      UINT32_C(0x00000400),   /** @brief Master compare 3 */
      UINT32_C(0x00000800),   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIMD_EEFDR1_EEXFLTR_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000001E),   /** @brief External event 1 filter */
      UINT32_C(0x00000780),   /** @brief External event 2 filter */
      UINT32_C(0x0001E000),   /** @brief External event 3 filter */
      UINT32_C(0x00780000),   /** @brief External event 4 filter */
      UINT32_C(0x1E000000),   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIMD_EEFDR1_EEXLTCH_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief External event 1 latch */
      UINT32_C(0x00000040),   /** @brief External event 2 latch */
      UINT32_C(0x00001000),   /** @brief External event 3 latch */
      UINT32_C(0x00040000),   /** @brief External event 4 latch */
      UINT32_C(0x01000000),   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMECMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x10000000),   /** @brief Timer E compare 1 */
      UINT32_C(0x20000000),   /** @brief Timer E compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief Timer E compare 4 */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMCCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x02000000),   /** @brief Timer C compare 1 */
      UINT32_C(0x04000000),   /** @brief Timer C compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x08000000),   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMBCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief Timer B compare 1 */
      UINT32_C(0x00800000),   /** @brief Timer B compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x01000000),   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIMD_RSTDR_TIMACMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00080000),   /** @brief Timer A compare 1 */
      UINT32_C(0x00100000),   /** @brief Timer A compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIMD_CPT1DCR_EXEVXCPT_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief External event 2 capture */
      UINT32_C(0x00000010),   /** @brief External event 3 capture */
      UINT32_C(0x00000020),   /** @brief External event 4 capture */
      UINT32_C(0x00000040),   /** @brief External event 5 capture */
      UINT32_C(0x00000080),   /** @brief External event 6 capture */
      UINT32_C(0x00000100),   /** @brief External event 7 capture */
      UINT32_C(0x00000200),   /** @brief External event 8 capture */
      UINT32_C(0x00000400),   /** @brief External event 9 capture */
      UINT32_C(0x00000800),   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIMD_FLTDR_FLTXEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 enable */
      UINT32_C(0x00000002),   /** @brief Fault 2 enable */
      UINT32_C(0x00000004),   /** @brief Fault 3 enable */
      UINT32_C(0x00000008),   /** @brief Fault 4 enable */
      UINT32_C(0x00000010),   /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMD field mask definitions */

    static const uint32_t HRTIM_TIMD_TIMDCR_UPDGAT_MASK = UINT32_C(0xF0000000);        /** @brief Update gating */
    static const uint32_t HRTIM_TIMD_TIMDCR_PREEN_MASK = UINT32_C(0x08000000);         /** @brief Preload enable */
    static const uint32_t HRTIM_TIMD_TIMDCR_DACSYNC_MASK = UINT32_C(0x06000000);       /** @brief AC synchronization */
    static const uint32_t HRTIM_TIMD_TIMDCR_MSTU_MASK = UINT32_C(0x01000000);          /** @brief Master timer update */
    static const uint32_t HRTIM_TIMD_TIMDCR_TEU_MASK = UINT32_C(0x00800000);           /** @brief TEU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TDU_MASK = UINT32_C(0x00400000);           /** @brief TDU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TCU_MASK = UINT32_C(0x00200000);           /** @brief TCU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TBU_MASK = UINT32_C(0x00100000);           /** @brief TBU */
    static const uint32_t HRTIM_TIMD_TIMDCR_TXRSTU_MASK = UINT32_C(0x00040000);        /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIMD_TIMDCR_TXREPU_MASK = UINT32_C(0x00020000);        /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIMD_TIMDCR_DELCMP4_MASK = UINT32_C(0x0000C000);       /** @brief Delayed CMP4 mode */
    static const uint32_t HRTIM_TIMD_TIMDCR_DELCMP2_MASK = UINT32_C(0x00003000);       /** @brief Delayed CMP2 mode */
    static const uint32_t HRTIM_TIMD_TIMDCR_SYNCSTRTX_MASK = UINT32_C(0x00000800);     /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIMD_TIMDCR_SYNCRSTX_MASK = UINT32_C(0x00000400);      /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIMD_TIMDCR_PSHPLL_MASK = UINT32_C(0x00000040);        /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIMD_TIMDCR_HALF_MASK = UINT32_C(0x00000020);          /** @brief Half mode enable */
    static const uint32_t HRTIM_TIMD_TIMDCR_RETRIG_MASK = UINT32_C(0x00000010);        /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIMD_TIMDCR_CONT_MASK = UINT32_C(0x00000008);          /** @brief Continuous mode */
    static const uint32_t HRTIM_TIMD_TIMDCR_CK_PSCX_MASK = UINT32_C(0x00000007);       /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMD_TIMDISR_O2STAT_MASK = UINT32_C(0x00080000);       /** @brief Output 2 state */
    static const uint32_t HRTIM_TIMD_TIMDISR_O1STAT_MASK = UINT32_C(0x00040000);       /** @brief Output 1 state */
    static const uint32_t HRTIM_TIMD_TIMDISR_IPPSTAT_MASK = UINT32_C(0x00020000);      /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIMD_TIMDISR_CPPSTAT_MASK = UINT32_C(0x00010000);      /** @brief Current push pull status */
    static const uint32_t HRTIM_TIMD_TIMDISR_DLYPRT_MASK = UINT32_C(0x00004000);       /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_RST_MASK = UINT32_C(0x00002000);          /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_RSTX2_MASK = UINT32_C(0x00001000);        /** @brief Output 2 reset interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_SETX2_MASK = UINT32_C(0x00000800);        /** @brief Output 2 set interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_RSTX1_MASK = UINT32_C(0x00000400);        /** @brief Output 1 reset interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_SETX1_MASK = UINT32_C(0x00000200);        /** @brief Output 1 set interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_CPT2_MASK = UINT32_C(0x00000100);         /** @brief Capture2 interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_CPT1_MASK = UINT32_C(0x00000080);         /** @brief Capture1 interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_UPD_MASK = UINT32_C(0x00000040);          /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDISR_REP_MASK = UINT32_C(0x00000010);          /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIMD_TIMDICR_DLYPRTC_MASK = UINT32_C(0x00004000);      /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_RSTC_MASK = UINT32_C(0x00002000);         /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_RSTX2C_MASK = UINT32_C(0x00001000);       /** @brief Output 2 reset flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_SET2XC_MASK = UINT32_C(0x00000800);       /** @brief Output 2 set flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_RSTX1C_MASK = UINT32_C(0x00000400);       /** @brief Output 1 reset flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_SET1XC_MASK = UINT32_C(0x00000200);       /** @brief Output 1 set flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_CPT2C_MASK = UINT32_C(0x00000100);        /** @brief Capture2 interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_CPT1C_MASK = UINT32_C(0x00000080);        /** @brief Capture1 interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_UPDC_MASK = UINT32_C(0x00000040);         /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDICR_REPC_MASK = UINT32_C(0x00000010);         /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_DLYPRTDE_MASK = UINT32_C(0x40000000);   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTDE_MASK = UINT32_C(0x20000000);      /** @brief RSTDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTX2DE_MASK = UINT32_C(0x10000000);    /** @brief RSTx2DE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SETX2DE_MASK = UINT32_C(0x08000000);    /** @brief SETx2DE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTX1DE_MASK = UINT32_C(0x04000000);    /** @brief RSTx1DE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SET1XDE_MASK = UINT32_C(0x02000000);    /** @brief SET1xDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_CPT2DE_MASK = UINT32_C(0x01000000);     /** @brief CPT2DE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_CPT1DE_MASK = UINT32_C(0x00800000);     /** @brief CPT1DE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_UPDDE_MASK = UINT32_C(0x00400000);      /** @brief UPDDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_REPDE_MASK = UINT32_C(0x00100000);      /** @brief REPDE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_DLYPRTIE_MASK = UINT32_C(0x00004000);   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTIE_MASK = UINT32_C(0x00002000);      /** @brief RSTIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTX2IE_MASK = UINT32_C(0x00001000);    /** @brief RSTx2IE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SETX2IE_MASK = UINT32_C(0x00000800);    /** @brief SETx2IE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RSTX1IE_MASK = UINT32_C(0x00000400);    /** @brief RSTx1IE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_SET1XIE_MASK = UINT32_C(0x00000200);    /** @brief SET1xIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_CPT2IE_MASK = UINT32_C(0x00000100);     /** @brief CPT2IE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_CPT1IE_MASK = UINT32_C(0x00000080);     /** @brief CPT1IE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_UPDIE_MASK = UINT32_C(0x00000040);      /** @brief UPDIE */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_REPIE_MASK = UINT32_C(0x00000010);      /** @brief REPIE */
    static const uint32_t HRTIM_TIMD_CNTDR_CNTX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMD_PERDR_PERX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMD_REPDR_REPX_MASK = UINT32_C(0x000000FF);           /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMD_CMPXDR_CMP1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMD_CMP1CDR_REPX_MASK = UINT32_C(0x00FF0000);         /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIMD_CMP1CDR_CMP1X_MASK = UINT32_C(0x0000FFFF);        /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMD_CMPXDR_CMP2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 2 value */
    static const uint32_t HRTIM_TIMD_CMPXDR_CMP3X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 3 value */
    static const uint32_t HRTIM_TIMD_CMPXDR_CMP4X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 4 value */
    static const uint32_t HRTIM_TIMD_CPT1DR_CPT1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIMD_CPT2DR_CPT2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 2 value */
    static const uint32_t HRTIM_TIMD_DTDR_DTFLKX_MASK = UINT32_C(0x80000000);          /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIMD_DTDR_DTFSLKX_MASK = UINT32_C(0x40000000);         /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIMD_DTDR_SDTFX_MASK = UINT32_C(0x02000000);           /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIMD_DTDR_DTFX_MASK = UINT32_C(0x01FF0000);            /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIMD_DTDR_DTRLKX_MASK = UINT32_C(0x00008000);          /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIMD_DTDR_DTRSLKX_MASK = UINT32_C(0x00004000);         /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIMD_DTDR_DTPRSC_MASK = UINT32_C(0x00001C00);          /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIMD_DTDR_SDTRX_MASK = UINT32_C(0x00000200);           /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIMD_DTDR_DTRX_MASK = UINT32_C(0x000001FF);            /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMD_SETD1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief External event 1 */
    static const uint32_t HRTIM_TIMD_SETD1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief Master period */
    static const uint32_t HRTIM_TIMD_SETD1R_PER_MASK = UINT32_C(0x00000004);           /** @brief Timer A period */
    static const uint32_t HRTIM_TIMD_SETD1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIMD_SETD1R_SST_MASK = UINT32_C(0x00000001);           /** @brief Software set trigger */
    static const uint32_t HRTIM_TIMD_RSTD1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMD_RSTD1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMD_RSTD1R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMD_RSTD1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMD_RSTD1R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMD_SETD2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMD_SETD2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMD_SETD2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMD_SETD2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMD_SETD2R_SST_MASK = UINT32_C(0x00000001);           /** @brief SST */
    static const uint32_t HRTIM_TIMD_RSTD2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIMD_RSTD2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIMD_RSTD2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIMD_RSTD2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIMD_RSTD2R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT1_MASK = UINT32_C(0x00000200);       /** @brief External event 1 */
    static const uint32_t HRTIM_TIMD_RSTDR_MSTPER_MASK = UINT32_C(0x00000010);         /** @brief Master timer period */
    static const uint32_t HRTIM_TIMD_RSTDR_CMP4_MASK = UINT32_C(0x00000008);           /** @brief Timer A compare 4 reset */
    static const uint32_t HRTIM_TIMD_RSTDR_CMP2_MASK = UINT32_C(0x00000004);           /** @brief Timer A compare 2 reset */
    static const uint32_t HRTIM_TIMD_RSTDR_UPDT_MASK = UINT32_C(0x00000002);           /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMD_CHPDR_STRTPW_MASK = UINT32_C(0x00000780);         /** @brief STRTPW */
    static const uint32_t HRTIM_TIMD_CHPDR_CHPDTY_MASK = UINT32_C(0x00000070);         /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIMD_CHPDR_CHPFRQ_MASK = UINT32_C(0x0000000F);         /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT1DCR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMD_CPT1DCR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMD_CPT1DCR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMD_CPT1DCR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TECMP2_MASK = UINT32_C(0x80000000);       /** @brief Timer E compare 2 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TECMP1_MASK = UINT32_C(0x40000000);       /** @brief Timer E compare 1 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TE1RST_MASK = UINT32_C(0x20000000);       /** @brief Timer E output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TE1SET_MASK = UINT32_C(0x10000000);       /** @brief Timer E output 1 set */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIMD_CPT2DCR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIMD_CPT2DCR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIMD_CPT2DCR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIMD_CPT2DCR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIMD_OUTDR_DIDL2_MASK = UINT32_C(0x00800000);          /** @brief Output 2 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMD_OUTDR_CHP2_MASK = UINT32_C(0x00400000);           /** @brief Output 2 chopper enable */
    static const uint32_t HRTIM_TIMD_OUTDR_FAULT2_MASK = UINT32_C(0x00300000);         /** @brief Output 2 fault state */
    static const uint32_t HRTIM_TIMD_OUTDR_IDLES2_MASK = UINT32_C(0x00080000);         /** @brief Output 2 idle state */
    static const uint32_t HRTIM_TIMD_OUTDR_IDLEM2_MASK = UINT32_C(0x00040000);         /** @brief Output 2 idle mode */
    static const uint32_t HRTIM_TIMD_OUTDR_POL2_MASK = UINT32_C(0x00020000);           /** @brief Output 2 polarity */
    static const uint32_t HRTIM_TIMD_OUTDR_DLYPRT_MASK = UINT32_C(0x00001C00);         /** @brief Delayed protection */
    static const uint32_t HRTIM_TIMD_OUTDR_DLYPRTEN_MASK = UINT32_C(0x00000200);       /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIMD_OUTDR_DTEN_MASK = UINT32_C(0x00000100);           /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIMD_OUTDR_DIDL1_MASK = UINT32_C(0x00000080);          /** @brief Output 1 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIMD_OUTDR_CHP1_MASK = UINT32_C(0x00000040);           /** @brief Output 1 chopper enable */
    static const uint32_t HRTIM_TIMD_OUTDR_FAULT1_MASK = UINT32_C(0x00000030);         /** @brief Output 1 fault state */
    static const uint32_t HRTIM_TIMD_OUTDR_IDLES1_MASK = UINT32_C(0x00000008);         /** @brief Output 1 idle state */
    static const uint32_t HRTIM_TIMD_OUTDR_IDLEM1_MASK = UINT32_C(0x00000004);         /** @brief Output 1 idle mode */
    static const uint32_t HRTIM_TIMD_OUTDR_POL1_MASK = UINT32_C(0x00000002);           /** @brief Output 1 polarity */
    static const uint32_t HRTIM_TIMD_FLTDR_FLTLCK_MASK = UINT32_C(0x80000000);         /** @brief Fault sources lock */

    /** @subsection HRTIM_TIMD field position array definitions */

    static const int32_t HRTIM_TIMD_FLTDR_CMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag */
      INT32_C(1),    /** @brief Compare 2 interrupt flag */
      INT32_C(2),    /** @brief Compare 3 interrupt flag */
      INT32_C(3),    /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIMD_FLTDR_CMPXC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag clear */
      INT32_C(1),    /** @brief Compare 2 interrupt flag clear */
      INT32_C(2),    /** @brief Compare 3 interrupt flag clear */
      INT32_C(3),    /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIMD_FLTDR_CMPXDE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief CMP1DE */
      INT32_C(17),   /** @brief CMP2DE */
      INT32_C(18),   /** @brief CMP3DE */
      INT32_C(19),   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIMD_FLTDR_CMPXIE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief CMP1IE */
      INT32_C(1),    /** @brief CMP2IE */
      INT32_C(2),    /** @brief CMP3IE */
      INT32_C(3),    /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIMD_FLTDR_EXTEVNTX_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief External event 2 */
      INT32_C(23),   /** @brief External event 3 */
      INT32_C(24),   /** @brief External event 4 */
      INT32_C(25),   /** @brief External event 5 */
      INT32_C(26),   /** @brief External event 6 */
      INT32_C(27),   /** @brief External event 7 */
      INT32_C(28),   /** @brief External event 8 */
      INT32_C(29),   /** @brief External event 9 */
      INT32_C(30),   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIMD_FLTDR_TIMEVNTX_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief Timer event 1 */
      INT32_C(13),   /** @brief Timer event 2 */
      INT32_C(14),   /** @brief Timer event 3 */
      INT32_C(15),   /** @brief Timer event 4 */
      INT32_C(16),   /** @brief Timer event 5 */
      INT32_C(17),   /** @brief Timer event 6 */
      INT32_C(18),   /** @brief Timer event 7 */
      INT32_C(19),   /** @brief Timer event 8 */
      INT32_C(20),   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIMD_FLTDR_MSTCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Master compare 1 */
      INT32_C(9),    /** @brief Master compare 2 */
      INT32_C(10),   /** @brief Master compare 3 */
      INT32_C(11),   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIMD_FLTDR_EEXFLTR_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief External event 1 filter */
      INT32_C(7),    /** @brief External event 2 filter */
      INT32_C(13),   /** @brief External event 3 filter */
      INT32_C(19),   /** @brief External event 4 filter */
      INT32_C(25),   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIMD_FLTDR_EEXLTCH_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief External event 1 latch */
      INT32_C(6),    /** @brief External event 2 latch */
      INT32_C(12),   /** @brief External event 3 latch */
      INT32_C(18),   /** @brief External event 4 latch */
      INT32_C(24),   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIMD_FLTDR_TIMECMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(28),   /** @brief Timer E compare 1 */
      INT32_C(29),   /** @brief Timer E compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief Timer E compare 4 */
    };

    static const int32_t HRTIM_TIMD_FLTDR_TIMCCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(25),   /** @brief Timer C compare 1 */
      INT32_C(26),   /** @brief Timer C compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(27),   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIMD_FLTDR_TIMBCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief Timer B compare 1 */
      INT32_C(23),   /** @brief Timer B compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(24),   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIMD_FLTDR_TIMACMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(19),   /** @brief Timer A compare 1 */
      INT32_C(20),   /** @brief Timer A compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIMD_FLTDR_EXEVXCPT_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief External event 2 capture */
      INT32_C(4),    /** @brief External event 3 capture */
      INT32_C(5),    /** @brief External event 4 capture */
      INT32_C(6),    /** @brief External event 5 capture */
      INT32_C(7),    /** @brief External event 6 capture */
      INT32_C(8),    /** @brief External event 7 capture */
      INT32_C(9),    /** @brief External event 8 capture */
      INT32_C(10),   /** @brief External event 9 capture */
      INT32_C(11),   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIMD_FLTDR_FLTXEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 enable */
      INT32_C(1),    /** @brief Fault 2 enable */
      INT32_C(2),    /** @brief Fault 3 enable */
      INT32_C(3),    /** @brief Fault 4 enable */
      INT32_C(4),    /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIMD field position definitions */

    static const int32_t HRTIM_TIMD_FLTDR_UPDGAT_POS = INT32_C(28);      /** @brief Update gating */
    static const int32_t HRTIM_TIMD_FLTDR_PREEN_POS = INT32_C(27);       /** @brief Preload enable */
    static const int32_t HRTIM_TIMD_FLTDR_DACSYNC_POS = INT32_C(25);     /** @brief AC synchronization */
    static const int32_t HRTIM_TIMD_FLTDR_MSTU_POS = INT32_C(24);        /** @brief Master timer update */
    static const int32_t HRTIM_TIMD_FLTDR_TEU_POS = INT32_C(23);         /** @brief TEU */
    static const int32_t HRTIM_TIMD_FLTDR_TDU_POS = INT32_C(22);         /** @brief TDU */
    static const int32_t HRTIM_TIMD_FLTDR_TCU_POS = INT32_C(21);         /** @brief TCU */
    static const int32_t HRTIM_TIMD_FLTDR_TBU_POS = INT32_C(20);         /** @brief TBU */
    static const int32_t HRTIM_TIMD_FLTDR_TXRSTU_POS = INT32_C(18);      /** @brief Timerx reset update */
    static const int32_t HRTIM_TIMD_FLTDR_TXREPU_POS = INT32_C(17);      /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIMD_FLTDR_DELCMP4_POS = INT32_C(14);     /** @brief Delayed CMP4 mode */
    static const int32_t HRTIM_TIMD_FLTDR_DELCMP2_POS = INT32_C(12);     /** @brief Delayed CMP2 mode */
    static const int32_t HRTIM_TIMD_FLTDR_SYNCSTRTX_POS = INT32_C(11);   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIMD_FLTDR_SYNCRSTX_POS = INT32_C(10);    /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIMD_FLTDR_PSHPLL_POS = INT32_C(6);       /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIMD_FLTDR_HALF_POS = INT32_C(5);         /** @brief Half mode enable */
    static const int32_t HRTIM_TIMD_FLTDR_RETRIG_POS = INT32_C(4);       /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIMD_FLTDR_CONT_POS = INT32_C(3);         /** @brief Continuous mode */
    static const int32_t HRTIM_TIMD_FLTDR_CK_PSCX_POS = INT32_C(0);      /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIMD_FLTDR_O2STAT_POS = INT32_C(19);      /** @brief Output 2 state */
    static const int32_t HRTIM_TIMD_FLTDR_O1STAT_POS = INT32_C(18);      /** @brief Output 1 state */
    static const int32_t HRTIM_TIMD_FLTDR_IPPSTAT_POS = INT32_C(17);     /** @brief Idle push pull status */
    static const int32_t HRTIM_TIMD_FLTDR_CPPSTAT_POS = INT32_C(16);     /** @brief Current push pull status */
    static const int32_t HRTIM_TIMD_FLTDR_DLYPRT_POS = INT32_C(14);      /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIMD_FLTDR_RST_POS = INT32_C(13);         /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX2_POS = INT32_C(12);       /** @brief Output 2 reset interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_SETX2_POS = INT32_C(11);       /** @brief Output 2 set interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX1_POS = INT32_C(10);       /** @brief Output 1 reset interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_SETX1_POS = INT32_C(9);        /** @brief Output 1 set interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_CPT2_POS = INT32_C(8);         /** @brief Capture2 interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_CPT1_POS = INT32_C(7);         /** @brief Capture1 interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_UPD_POS = INT32_C(6);          /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_REP_POS = INT32_C(4);          /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIMD_FLTDR_DLYPRTC_POS = INT32_C(14);     /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_RSTC_POS = INT32_C(13);        /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX2C_POS = INT32_C(12);      /** @brief Output 2 reset flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_SET2XC_POS = INT32_C(11);      /** @brief Output 2 set flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX1C_POS = INT32_C(10);      /** @brief Output 1 reset flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_SET1XC_POS = INT32_C(9);       /** @brief Output 1 set flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_CPT2C_POS = INT32_C(8);        /** @brief Capture2 interrupt flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_CPT1C_POS = INT32_C(7);        /** @brief Capture1 interrupt flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_UPDC_POS = INT32_C(6);         /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_REPC_POS = INT32_C(4);         /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIMD_FLTDR_DLYPRTDE_POS = INT32_C(30);    /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIMD_FLTDR_RSTDE_POS = INT32_C(29);       /** @brief RSTDE */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX2DE_POS = INT32_C(28);     /** @brief RSTx2DE */
    static const int32_t HRTIM_TIMD_FLTDR_SETX2DE_POS = INT32_C(27);     /** @brief SETx2DE */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX1DE_POS = INT32_C(26);     /** @brief RSTx1DE */
    static const int32_t HRTIM_TIMD_FLTDR_SET1XDE_POS = INT32_C(25);     /** @brief SET1xDE */
    static const int32_t HRTIM_TIMD_FLTDR_CPT2DE_POS = INT32_C(24);      /** @brief CPT2DE */
    static const int32_t HRTIM_TIMD_FLTDR_CPT1DE_POS = INT32_C(23);      /** @brief CPT1DE */
    static const int32_t HRTIM_TIMD_FLTDR_UPDDE_POS = INT32_C(22);       /** @brief UPDDE */
    static const int32_t HRTIM_TIMD_FLTDR_REPDE_POS = INT32_C(20);       /** @brief REPDE */
    static const int32_t HRTIM_TIMD_FLTDR_DLYPRTIE_POS = INT32_C(14);    /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIMD_FLTDR_RSTIE_POS = INT32_C(13);       /** @brief RSTIE */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX2IE_POS = INT32_C(12);     /** @brief RSTx2IE */
    static const int32_t HRTIM_TIMD_FLTDR_SETX2IE_POS = INT32_C(11);     /** @brief SETx2IE */
    static const int32_t HRTIM_TIMD_FLTDR_RSTX1IE_POS = INT32_C(10);     /** @brief RSTx1IE */
    static const int32_t HRTIM_TIMD_FLTDR_SET1XIE_POS = INT32_C(9);      /** @brief SET1xIE */
    static const int32_t HRTIM_TIMD_FLTDR_CPT2IE_POS = INT32_C(8);       /** @brief CPT2IE */
    static const int32_t HRTIM_TIMD_FLTDR_CPT1IE_POS = INT32_C(7);       /** @brief CPT1IE */
    static const int32_t HRTIM_TIMD_FLTDR_UPDIE_POS = INT32_C(6);        /** @brief UPDIE */
    static const int32_t HRTIM_TIMD_FLTDR_REPIE_POS = INT32_C(4);        /** @brief REPIE */
    static const int32_t HRTIM_TIMD_FLTDR_CNTX_POS = INT32_C(0);         /** @brief Timerx counter value */
    static const int32_t HRTIM_TIMD_FLTDR_PERX_POS = INT32_C(0);         /** @brief Timerx period value */
    static const int32_t HRTIM_TIMD_FLTDR_REPX_POS = INT32_C(0);         /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIMD_FLTDR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMD_FLTDR_REPX_POS = INT32_C(16);        /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIMD_FLTDR_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIMD_FLTDR_CMP2X_POS = INT32_C(0);        /** @brief Timerx compare 2 value */
    static const int32_t HRTIM_TIMD_FLTDR_CMP3X_POS = INT32_C(0);        /** @brief Timerx compare 3 value */
    static const int32_t HRTIM_TIMD_FLTDR_CMP4X_POS = INT32_C(0);        /** @brief Timerx compare 4 value */
    static const int32_t HRTIM_TIMD_FLTDR_CPT1X_POS = INT32_C(0);        /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIMD_FLTDR_CPT2X_POS = INT32_C(0);        /** @brief Timerx capture 2 value */
    static const int32_t HRTIM_TIMD_FLTDR_DTFLKX_POS = INT32_C(31);      /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIMD_FLTDR_DTFSLKX_POS = INT32_C(30);     /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIMD_FLTDR_SDTFX_POS = INT32_C(25);       /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIMD_FLTDR_DTFX_POS = INT32_C(16);        /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIMD_FLTDR_DTRLKX_POS = INT32_C(15);      /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIMD_FLTDR_DTRSLKX_POS = INT32_C(14);     /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIMD_FLTDR_DTPRSC_POS = INT32_C(10);      /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIMD_FLTDR_SDTRX_POS = INT32_C(9);        /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIMD_FLTDR_DTRX_POS = INT32_C(0);         /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIMD_FLTDR_UPDATE_POS = INT32_C(31);      /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIMD_FLTDR_EXTEVNT1_POS = INT32_C(21);    /** @brief External event 1 */
    static const int32_t HRTIM_TIMD_FLTDR_MSTPER_POS = INT32_C(7);       /** @brief Master period */
    static const int32_t HRTIM_TIMD_FLTDR_PER_POS = INT32_C(2);          /** @brief Timer A period */
    static const int32_t HRTIM_TIMD_FLTDR_RESYNC_POS = INT32_C(1);       /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIMD_FLTDR_SST_POS = INT32_C(0);          /** @brief Software set trigger */
    static const int32_t HRTIM_TIMD_FLTDR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMD_FLTDR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMD_FLTDR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMD_FLTDR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMD_FLTDR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMD_FLTDR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMD_FLTDR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMD_FLTDR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMD_FLTDR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMD_FLTDR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMD_FLTDR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMD_FLTDR_SST_POS = INT32_C(0);          /** @brief SST */
    static const int32_t HRTIM_TIMD_FLTDR_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIMD_FLTDR_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIMD_FLTDR_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIMD_FLTDR_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIMD_FLTDR_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIMD_FLTDR_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIMD_FLTDR_EXTEVNT1_POS = INT32_C(9);     /** @brief External event 1 */
    static const int32_t HRTIM_TIMD_FLTDR_MSTPER_POS = INT32_C(4);       /** @brief Master timer period */
    static const int32_t HRTIM_TIMD_FLTDR_CMP4_POS = INT32_C(3);         /** @brief Timer A compare 4 reset */
    static const int32_t HRTIM_TIMD_FLTDR_CMP2_POS = INT32_C(2);         /** @brief Timer A compare 2 reset */
    static const int32_t HRTIM_TIMD_FLTDR_UPDT_POS = INT32_C(1);         /** @brief Timer A update reset */
    static const int32_t HRTIM_TIMD_FLTDR_STRTPW_POS = INT32_C(7);       /** @brief STRTPW */
    static const int32_t HRTIM_TIMD_FLTDR_CHPDTY_POS = INT32_C(4);       /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIMD_FLTDR_CHPFRQ_POS = INT32_C(0);       /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIMD_FLTDR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMD_FLTDR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMD_FLTDR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMD_FLTDR_TECMP2_POS = INT32_C(31);      /** @brief Timer E compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TECMP1_POS = INT32_C(30);      /** @brief Timer E compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TE1RST_POS = INT32_C(29);      /** @brief Timer E output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TE1SET_POS = INT32_C(28);      /** @brief Timer E output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIMD_FLTDR_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIMD_FLTDR_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIMD_FLTDR_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIMD_FLTDR_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIMD_FLTDR_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIMD_FLTDR_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIMD_FLTDR_DIDL2_POS = INT32_C(23);       /** @brief Output 2 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMD_FLTDR_CHP2_POS = INT32_C(22);        /** @brief Output 2 chopper enable */
    static const int32_t HRTIM_TIMD_FLTDR_FAULT2_POS = INT32_C(20);      /** @brief Output 2 fault state */
    static const int32_t HRTIM_TIMD_FLTDR_IDLES2_POS = INT32_C(19);      /** @brief Output 2 idle state */
    static const int32_t HRTIM_TIMD_FLTDR_IDLEM2_POS = INT32_C(18);      /** @brief Output 2 idle mode */
    static const int32_t HRTIM_TIMD_FLTDR_POL2_POS = INT32_C(17);        /** @brief Output 2 polarity */
    static const int32_t HRTIM_TIMD_FLTDR_DLYPRT_POS = INT32_C(10);      /** @brief Delayed protection */
    static const int32_t HRTIM_TIMD_FLTDR_DLYPRTEN_POS = INT32_C(9);     /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIMD_FLTDR_DTEN_POS = INT32_C(8);         /** @brief Deadtime enable */
    static const int32_t HRTIM_TIMD_FLTDR_DIDL1_POS = INT32_C(7);        /** @brief Output 1 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIMD_FLTDR_CHP1_POS = INT32_C(6);         /** @brief Output 1 chopper enable */
    static const int32_t HRTIM_TIMD_FLTDR_FAULT1_POS = INT32_C(4);       /** @brief Output 1 fault state */
    static const int32_t HRTIM_TIMD_FLTDR_IDLES1_POS = INT32_C(3);       /** @brief Output 1 idle state */
    static const int32_t HRTIM_TIMD_FLTDR_IDLEM1_POS = INT32_C(2);       /** @brief Output 1 idle mode */
    static const int32_t HRTIM_TIMD_FLTDR_POL1_POS = INT32_C(1);         /** @brief Output 1 polarity */
    static const int32_t HRTIM_TIMD_FLTDR_FLTLCK_POS = INT32_C(31);      /** @brief Fault sources lock */

    /**********************************************************************************************
     * @section HRTIM_TIME Definitions
     **********************************************************************************************/

    /** @subsection HRTIM_TIME IRQ interrupt definitions */

    static const int32_t HRTIM1_TIMD_IRQ = INT32_C(107);   /** @brief HRTIM1 timer D interrupt */

    /** @subsection HRTIM_TIME register array definitions */

    static _RW uint32_t* const HRTIM_TIME_CMPXER_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001769C),   /** @brief Timerx compare 1 register */
      (_RW uint32_t* const)UINT32_C(0x400176A4),   /** @brief Timerx compare 2 register */
      (_RW uint32_t* const)UINT32_C(0x400176A8),   /** @brief Timerx compare 3 register */
      (_RW uint32_t* const)UINT32_C(0x400176AC),   /** @brief Timerx compare 4 register */
    };

    /** @subsection HRTIM_TIME register definitions */

    static _RW uint32_t* const HRTIM_TIME_TIMECR_REG = (_RW uint32_t* const)UINT32_C(0x40017680);      /** @brief Timerx control register */
    static _RO uint32_t* const HRTIM_TIME_TIMEISR_REG = (_RO uint32_t* const)UINT32_C(0x40017684);     /** @brief Timerx interrupt status register */
    static _RW uint32_t* const HRTIM_TIME_TIMEICR_REG = (_RW uint32_t* const)UINT32_C(0x40017688);     /** @brief Timerx interrupt clear register */
    static _RW uint32_t* const HRTIM_TIME_TIMEDIER5_REG = (_RW uint32_t* const)UINT32_C(0x4001768C);   /** @brief TIMxDIER5 */
    static _RW uint32_t* const HRTIM_TIME_CNTER_REG = (_RW uint32_t* const)UINT32_C(0x40017690);       /** @brief Timerx counter register */
    static _RW uint32_t* const HRTIM_TIME_PERER_REG = (_RW uint32_t* const)UINT32_C(0x40017694);       /** @brief Timerx period register */
    static _RW uint32_t* const HRTIM_TIME_REPER_REG = (_RW uint32_t* const)UINT32_C(0x40017698);       /** @brief Timerx repetition register */
    static _RW uint32_t* const HRTIM_TIME_CMP1CER_REG = (_RW uint32_t* const)UINT32_C(0x400176A0);     /** @brief Timerx compare 1 compound register */
    static _RO uint32_t* const HRTIM_TIME_CPT1ER_REG = (_RO uint32_t* const)UINT32_C(0x400176B0);      /** @brief Timerx capture 1 register */
    static _RO uint32_t* const HRTIM_TIME_CPT2ER_REG = (_RO uint32_t* const)UINT32_C(0x400176B4);      /** @brief Timerx capture 2 register */
    static _RW uint32_t* const HRTIM_TIME_DTER_REG = (_RW uint32_t* const)UINT32_C(0x400176B8);        /** @brief Timerx deadtime register */
    static _RW uint32_t* const HRTIM_TIME_SETE1R_REG = (_RW uint32_t* const)UINT32_C(0x400176BC);      /** @brief Timerx output1 set register */
    static _RW uint32_t* const HRTIM_TIME_RSTE1R_REG = (_RW uint32_t* const)UINT32_C(0x400176C0);      /** @brief Timerx output1 reset register */
    static _RW uint32_t* const HRTIM_TIME_SETE2R_REG = (_RW uint32_t* const)UINT32_C(0x400176C4);      /** @brief Timerx output2 set register */
    static _RW uint32_t* const HRTIM_TIME_RSTE2R_REG = (_RW uint32_t* const)UINT32_C(0x400176C8);      /** @brief Timerx output2 reset register */
    static _RW uint32_t* const HRTIM_TIME_EEFER1_REG = (_RW uint32_t* const)UINT32_C(0x400176CC);      /** @brief Timerx external event filtering register 1 */
    static _RW uint32_t* const HRTIM_TIME_EEFER2_REG = (_RW uint32_t* const)UINT32_C(0x400176D0);      /** @brief Timerx external event filtering register 2 */
    static _RW uint32_t* const HRTIM_TIME_RSTER_REG = (_RW uint32_t* const)UINT32_C(0x400176D4);       /** @brief TimerA reset register */
    static _RW uint32_t* const HRTIM_TIME_CHPER_REG = (_RW uint32_t* const)UINT32_C(0x400176D8);       /** @brief Timerx chopper register */
    static _RW uint32_t* const HRTIM_TIME_CPT1ECR_REG = (_RW uint32_t* const)UINT32_C(0x400176DC);     /** @brief Timerx capture 2 control register */
    static _RW uint32_t* const HRTIM_TIME_CPT2ECR_REG = (_RW uint32_t* const)UINT32_C(0x400176E0);     /** @brief CPT2xCR */
    static _RW uint32_t* const HRTIM_TIME_OUTER_REG = (_RW uint32_t* const)UINT32_C(0x400176E4);       /** @brief Timerx output register */
    static _RW uint32_t* const HRTIM_TIME_FLTER_REG = (_RW uint32_t* const)UINT32_C(0x400176E8);       /** @brief Timerx fault register */

    /** @subsection HRTIM_TIME field mask array definitions */

    static const uint32_t HRTIM_TIME_TIMEISR_CMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIME_TIMEICR_CMPXC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Compare 1 interrupt flag clear */
      UINT32_C(0x00000002),   /** @brief Compare 2 interrupt flag clear */
      UINT32_C(0x00000004),   /** @brief Compare 3 interrupt flag clear */
      UINT32_C(0x00000008),   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_CMPXDE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00010000),   /** @brief CMP1DE */
      UINT32_C(0x00020000),   /** @brief CMP2DE */
      UINT32_C(0x00040000),   /** @brief CMP3DE */
      UINT32_C(0x00080000),   /** @brief CMP4DE */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_CMPXIE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief CMP1IE */
      UINT32_C(0x00000002),   /** @brief CMP2IE */
      UINT32_C(0x00000004),   /** @brief CMP3IE */
      UINT32_C(0x00000008),   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIME_SETE1R_EXTEVNTX_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief External event 2 */
      UINT32_C(0x00800000),   /** @brief External event 3 */
      UINT32_C(0x01000000),   /** @brief External event 4 */
      UINT32_C(0x02000000),   /** @brief External event 5 */
      UINT32_C(0x04000000),   /** @brief External event 6 */
      UINT32_C(0x08000000),   /** @brief External event 7 */
      UINT32_C(0x10000000),   /** @brief External event 8 */
      UINT32_C(0x20000000),   /** @brief External event 9 */
      UINT32_C(0x40000000),   /** @brief External event 10 */
    };

    static const uint32_t HRTIM_TIME_SETE1R_TIMEVNTX_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00001000),   /** @brief Timer event 1 */
      UINT32_C(0x00002000),   /** @brief Timer event 2 */
      UINT32_C(0x00004000),   /** @brief Timer event 3 */
      UINT32_C(0x00008000),   /** @brief Timer event 4 */
      UINT32_C(0x00010000),   /** @brief Timer event 5 */
      UINT32_C(0x00020000),   /** @brief Timer event 6 */
      UINT32_C(0x00040000),   /** @brief Timer event 7 */
      UINT32_C(0x00080000),   /** @brief Timer event 8 */
      UINT32_C(0x00100000),   /** @brief Timer event 9 */
    };

    static const uint32_t HRTIM_TIME_SETE1R_MSTCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Master compare 1 */
      UINT32_C(0x00000200),   /** @brief Master compare 2 */
      UINT32_C(0x00000400),   /** @brief Master compare 3 */
      UINT32_C(0x00000800),   /** @brief Master compare 4 */
    };

    static const uint32_t HRTIM_TIME_EEFER1_EEXFLTR_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000001E),   /** @brief External event 1 filter */
      UINT32_C(0x00000780),   /** @brief External event 2 filter */
      UINT32_C(0x0001E000),   /** @brief External event 3 filter */
      UINT32_C(0x00780000),   /** @brief External event 4 filter */
      UINT32_C(0x1E000000),   /** @brief External event 5 filter */
    };

    static const uint32_t HRTIM_TIME_EEFER1_EEXLTCH_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief External event 1 latch */
      UINT32_C(0x00000040),   /** @brief External event 2 latch */
      UINT32_C(0x00001000),   /** @brief External event 3 latch */
      UINT32_C(0x00040000),   /** @brief External event 4 latch */
      UINT32_C(0x01000000),   /** @brief External event 5 latch */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMDCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x10000000),   /** @brief Timer D compare 1 */
      UINT32_C(0x20000000),   /** @brief Timer D compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x40000000),   /** @brief Timer D compare 4 */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMCCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x02000000),   /** @brief Timer C compare 1 */
      UINT32_C(0x04000000),   /** @brief Timer C compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x08000000),   /** @brief Timer C compare 4 */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMBCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00400000),   /** @brief Timer B compare 1 */
      UINT32_C(0x00800000),   /** @brief Timer B compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x01000000),   /** @brief Timer B compare 4 */
    };

    static const uint32_t HRTIM_TIME_RSTER_TIMACMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00080000),   /** @brief Timer A compare 1 */
      UINT32_C(0x00100000),   /** @brief Timer A compare 2 */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00200000),   /** @brief Timer A compare 4 */
    };

    static const uint32_t HRTIM_TIME_CPT1ECR_EXEVXCPT_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief External event 2 capture */
      UINT32_C(0x00000010),   /** @brief External event 3 capture */
      UINT32_C(0x00000020),   /** @brief External event 4 capture */
      UINT32_C(0x00000040),   /** @brief External event 5 capture */
      UINT32_C(0x00000080),   /** @brief External event 6 capture */
      UINT32_C(0x00000100),   /** @brief External event 7 capture */
      UINT32_C(0x00000200),   /** @brief External event 8 capture */
      UINT32_C(0x00000400),   /** @brief External event 9 capture */
      UINT32_C(0x00000800),   /** @brief External event 10 capture */
    };

    static const uint32_t HRTIM_TIME_FLTER_FLTXEN_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 enable */
      UINT32_C(0x00000002),   /** @brief Fault 2 enable */
      UINT32_C(0x00000004),   /** @brief Fault 3 enable */
      UINT32_C(0x00000008),   /** @brief Fault 4 enable */
      UINT32_C(0x00000010),   /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIME field mask definitions */

    static const uint32_t HRTIM_TIME_TIMECR_UPDGAT_MASK = UINT32_C(0xF0000000);        /** @brief Update gating */
    static const uint32_t HRTIM_TIME_TIMECR_PREEN_MASK = UINT32_C(0x08000000);         /** @brief Preload enable */
    static const uint32_t HRTIM_TIME_TIMECR_DACSYNC_MASK = UINT32_C(0x06000000);       /** @brief AC synchronization */
    static const uint32_t HRTIM_TIME_TIMECR_MSTU_MASK = UINT32_C(0x01000000);          /** @brief Master timer update */
    static const uint32_t HRTIM_TIME_TIMECR_TEU_MASK = UINT32_C(0x00800000);           /** @brief TEU */
    static const uint32_t HRTIM_TIME_TIMECR_TDU_MASK = UINT32_C(0x00400000);           /** @brief TDU */
    static const uint32_t HRTIM_TIME_TIMECR_TCU_MASK = UINT32_C(0x00200000);           /** @brief TCU */
    static const uint32_t HRTIM_TIME_TIMECR_TBU_MASK = UINT32_C(0x00100000);           /** @brief TBU */
    static const uint32_t HRTIM_TIME_TIMECR_TXRSTU_MASK = UINT32_C(0x00040000);        /** @brief Timerx reset update */
    static const uint32_t HRTIM_TIME_TIMECR_TXREPU_MASK = UINT32_C(0x00020000);        /** @brief Timer x repetition update */
    static const uint32_t HRTIM_TIME_TIMECR_DELCMP4_MASK = UINT32_C(0x0000C000);       /** @brief Delayed CMP4 mode */
    static const uint32_t HRTIM_TIME_TIMECR_DELCMP2_MASK = UINT32_C(0x00003000);       /** @brief Delayed CMP2 mode */
    static const uint32_t HRTIM_TIME_TIMECR_SYNCSTRTX_MASK = UINT32_C(0x00000800);     /** @brief Synchronization starts timer x */
    static const uint32_t HRTIM_TIME_TIMECR_SYNCRSTX_MASK = UINT32_C(0x00000400);      /** @brief Synchronization resets timer x */
    static const uint32_t HRTIM_TIME_TIMECR_PSHPLL_MASK = UINT32_C(0x00000040);        /** @brief Push-Pull mode enable */
    static const uint32_t HRTIM_TIME_TIMECR_HALF_MASK = UINT32_C(0x00000020);          /** @brief Half mode enable */
    static const uint32_t HRTIM_TIME_TIMECR_RETRIG_MASK = UINT32_C(0x00000010);        /** @brief Re-triggerable mode */
    static const uint32_t HRTIM_TIME_TIMECR_CONT_MASK = UINT32_C(0x00000008);          /** @brief Continuous mode */
    static const uint32_t HRTIM_TIME_TIMECR_CK_PSCX_MASK = UINT32_C(0x00000007);       /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIME_TIMEISR_O2STAT_MASK = UINT32_C(0x00080000);       /** @brief Output 2 state */
    static const uint32_t HRTIM_TIME_TIMEISR_O1STAT_MASK = UINT32_C(0x00040000);       /** @brief Output 1 state */
    static const uint32_t HRTIM_TIME_TIMEISR_IPPSTAT_MASK = UINT32_C(0x00020000);      /** @brief Idle push pull status */
    static const uint32_t HRTIM_TIME_TIMEISR_CPPSTAT_MASK = UINT32_C(0x00010000);      /** @brief Current push pull status */
    static const uint32_t HRTIM_TIME_TIMEISR_DLYPRT_MASK = UINT32_C(0x00004000);       /** @brief Delayed protection flag */
    static const uint32_t HRTIM_TIME_TIMEISR_RST_MASK = UINT32_C(0x00002000);          /** @brief Reset interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_RSTX2_MASK = UINT32_C(0x00001000);        /** @brief Output 2 reset interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_SETX2_MASK = UINT32_C(0x00000800);        /** @brief Output 2 set interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_RSTX1_MASK = UINT32_C(0x00000400);        /** @brief Output 1 reset interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_SETX1_MASK = UINT32_C(0x00000200);        /** @brief Output 1 set interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_CPT2_MASK = UINT32_C(0x00000100);         /** @brief Capture2 interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_CPT1_MASK = UINT32_C(0x00000080);         /** @brief Capture1 interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_UPD_MASK = UINT32_C(0x00000040);          /** @brief Update interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEISR_REP_MASK = UINT32_C(0x00000010);          /** @brief Repetition interrupt flag */
    static const uint32_t HRTIM_TIME_TIMEICR_DLYPRTC_MASK = UINT32_C(0x00004000);      /** @brief Delayed protection flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_RSTC_MASK = UINT32_C(0x00002000);         /** @brief Reset interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_RSTX2C_MASK = UINT32_C(0x00001000);       /** @brief Output 2 reset flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_SET2XC_MASK = UINT32_C(0x00000800);       /** @brief Output 2 set flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_RSTX1C_MASK = UINT32_C(0x00000400);       /** @brief Output 1 reset flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_SET1XC_MASK = UINT32_C(0x00000200);       /** @brief Output 1 set flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_CPT2C_MASK = UINT32_C(0x00000100);        /** @brief Capture2 interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_CPT1C_MASK = UINT32_C(0x00000080);        /** @brief Capture1 interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_UPDC_MASK = UINT32_C(0x00000040);         /** @brief Update interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEICR_REPC_MASK = UINT32_C(0x00000010);         /** @brief Repetition interrupt flag clear */
    static const uint32_t HRTIM_TIME_TIMEDIER5_DLYPRTDE_MASK = UINT32_C(0x40000000);   /** @brief DLYPRTDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTDE_MASK = UINT32_C(0x20000000);      /** @brief RSTDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTX2DE_MASK = UINT32_C(0x10000000);    /** @brief RSTx2DE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SETX2DE_MASK = UINT32_C(0x08000000);    /** @brief SETx2DE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTX1DE_MASK = UINT32_C(0x04000000);    /** @brief RSTx1DE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SET1XDE_MASK = UINT32_C(0x02000000);    /** @brief SET1xDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_CPT2DE_MASK = UINT32_C(0x01000000);     /** @brief CPT2DE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_CPT1DE_MASK = UINT32_C(0x00800000);     /** @brief CPT1DE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_UPDDE_MASK = UINT32_C(0x00400000);      /** @brief UPDDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_REPDE_MASK = UINT32_C(0x00100000);      /** @brief REPDE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_DLYPRTIE_MASK = UINT32_C(0x00004000);   /** @brief DLYPRTIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTIE_MASK = UINT32_C(0x00002000);      /** @brief RSTIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTX2IE_MASK = UINT32_C(0x00001000);    /** @brief RSTx2IE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SETX2IE_MASK = UINT32_C(0x00000800);    /** @brief SETx2IE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RSTX1IE_MASK = UINT32_C(0x00000400);    /** @brief RSTx1IE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_SET1XIE_MASK = UINT32_C(0x00000200);    /** @brief SET1xIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_CPT2IE_MASK = UINT32_C(0x00000100);     /** @brief CPT2IE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_CPT1IE_MASK = UINT32_C(0x00000080);     /** @brief CPT1IE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_UPDIE_MASK = UINT32_C(0x00000040);      /** @brief UPDIE */
    static const uint32_t HRTIM_TIME_TIMEDIER5_REPIE_MASK = UINT32_C(0x00000010);      /** @brief REPIE */
    static const uint32_t HRTIM_TIME_CNTER_CNTX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIME_PERER_PERX_MASK = UINT32_C(0x0000FFFF);           /** @brief Timerx period value */
    static const uint32_t HRTIM_TIME_REPER_REPX_MASK = UINT32_C(0x000000FF);           /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIME_CMPXER_CMP1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIME_CMP1CER_REPX_MASK = UINT32_C(0x00FF0000);         /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const uint32_t HRTIM_TIME_CMP1CER_CMP1X_MASK = UINT32_C(0x0000FFFF);        /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIME_CMPXER_CMP2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 2 value */
    static const uint32_t HRTIM_TIME_CMPXER_CMP3X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 3 value */
    static const uint32_t HRTIM_TIME_CMPXER_CMP4X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx compare 4 value */
    static const uint32_t HRTIM_TIME_CPT1ER_CPT1X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 1 value */
    static const uint32_t HRTIM_TIME_CPT2ER_CPT2X_MASK = UINT32_C(0x0000FFFF);         /** @brief Timerx capture 2 value */
    static const uint32_t HRTIM_TIME_DTER_DTFLKX_MASK = UINT32_C(0x80000000);          /** @brief Deadtime falling lock */
    static const uint32_t HRTIM_TIME_DTER_DTFSLKX_MASK = UINT32_C(0x40000000);         /** @brief Deadtime falling sign lock */
    static const uint32_t HRTIM_TIME_DTER_SDTFX_MASK = UINT32_C(0x02000000);           /** @brief Sign deadtime falling value */
    static const uint32_t HRTIM_TIME_DTER_DTFX_MASK = UINT32_C(0x01FF0000);            /** @brief Deadtime falling value */
    static const uint32_t HRTIM_TIME_DTER_DTRLKX_MASK = UINT32_C(0x00008000);          /** @brief Deadtime rising lock */
    static const uint32_t HRTIM_TIME_DTER_DTRSLKX_MASK = UINT32_C(0x00004000);         /** @brief Deadtime rising sign lock */
    static const uint32_t HRTIM_TIME_DTER_DTPRSC_MASK = UINT32_C(0x00001C00);          /** @brief Deadtime prescaler */
    static const uint32_t HRTIM_TIME_DTER_SDTRX_MASK = UINT32_C(0x00000200);           /** @brief Sign deadtime rising value */
    static const uint32_t HRTIM_TIME_DTER_DTRX_MASK = UINT32_C(0x000001FF);            /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIME_SETE1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief Registers update (transfer preload to active) */
    static const uint32_t HRTIM_TIME_SETE1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief External event 1 */
    static const uint32_t HRTIM_TIME_SETE1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief Master period */
    static const uint32_t HRTIM_TIME_SETE1R_PER_MASK = UINT32_C(0x00000004);           /** @brief Timer A period */
    static const uint32_t HRTIM_TIME_SETE1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief Timer A resynchronizaton */
    static const uint32_t HRTIM_TIME_SETE1R_SST_MASK = UINT32_C(0x00000001);           /** @brief Software set trigger */
    static const uint32_t HRTIM_TIME_RSTE1R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIME_RSTE1R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIME_RSTE1R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIME_RSTE1R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIME_RSTE1R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIME_SETE2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIME_SETE2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIME_SETE2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIME_SETE2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIME_SETE2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIME_SETE2R_SST_MASK = UINT32_C(0x00000001);           /** @brief SST */
    static const uint32_t HRTIM_TIME_RSTE2R_UPDATE_MASK = UINT32_C(0x80000000);        /** @brief UPDATE */
    static const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT1_MASK = UINT32_C(0x00200000);      /** @brief EXTEVNT1 */
    static const uint32_t HRTIM_TIME_RSTE2R_MSTPER_MASK = UINT32_C(0x00000080);        /** @brief MSTPER */
    static const uint32_t HRTIM_TIME_RSTE2R_PER_MASK = UINT32_C(0x00000004);           /** @brief PER */
    static const uint32_t HRTIM_TIME_RSTE2R_RESYNC_MASK = UINT32_C(0x00000002);        /** @brief RESYNC */
    static const uint32_t HRTIM_TIME_RSTE2R_SRT_MASK = UINT32_C(0x00000001);           /** @brief SRT */
    static const uint32_t HRTIM_TIME_RSTER_EXTEVNT1_MASK = UINT32_C(0x00000200);       /** @brief External event 1 */
    static const uint32_t HRTIM_TIME_RSTER_MSTPER_MASK = UINT32_C(0x00000010);         /** @brief Master timer period */
    static const uint32_t HRTIM_TIME_RSTER_CMP4_MASK = UINT32_C(0x00000008);           /** @brief Timer A compare 4 reset */
    static const uint32_t HRTIM_TIME_RSTER_CMP2_MASK = UINT32_C(0x00000004);           /** @brief Timer A compare 2 reset */
    static const uint32_t HRTIM_TIME_RSTER_UPDT_MASK = UINT32_C(0x00000002);           /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIME_CHPER_STRTPW_MASK = UINT32_C(0x00000780);         /** @brief STRTPW */
    static const uint32_t HRTIM_TIME_CHPER_CHPDTY_MASK = UINT32_C(0x00000070);         /** @brief Timerx chopper duty cycle value */
    static const uint32_t HRTIM_TIME_CHPER_CHPFRQ_MASK = UINT32_C(0x0000000F);         /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIME_CPT1ECR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIME_CPT1ECR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIME_CPT1ECR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIME_CPT1ECR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIME_CPT1ECR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIME_CPT1ECR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIME_CPT1ECR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIME_CPT1ECR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIME_CPT1ECR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIME_CPT1ECR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIME_CPT1ECR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIME_CPT1ECR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIME_CPT2ECR_TDCMP2_MASK = UINT32_C(0x08000000);       /** @brief Timer D compare 2 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TDCMP1_MASK = UINT32_C(0x04000000);       /** @brief Timer D compare 1 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TD1RST_MASK = UINT32_C(0x02000000);       /** @brief Timer D output 1 reset */
    static const uint32_t HRTIM_TIME_CPT2ECR_TD1SET_MASK = UINT32_C(0x01000000);       /** @brief Timer D output 1 set */
    static const uint32_t HRTIM_TIME_CPT2ECR_TCCMP2_MASK = UINT32_C(0x00800000);       /** @brief Timer C compare 2 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TCCMP1_MASK = UINT32_C(0x00400000);       /** @brief Timer C compare 1 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TC1RST_MASK = UINT32_C(0x00200000);       /** @brief Timer C output 1 reset */
    static const uint32_t HRTIM_TIME_CPT2ECR_TC1SET_MASK = UINT32_C(0x00100000);       /** @brief Timer C output 1 set */
    static const uint32_t HRTIM_TIME_CPT2ECR_TBCMP2_MASK = UINT32_C(0x00080000);       /** @brief Timer B compare 2 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TBCMP1_MASK = UINT32_C(0x00040000);       /** @brief Timer B compare 1 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TB1RST_MASK = UINT32_C(0x00020000);       /** @brief Timer B output 1 reset */
    static const uint32_t HRTIM_TIME_CPT2ECR_TB1SET_MASK = UINT32_C(0x00010000);       /** @brief Timer B output 1 set */
    static const uint32_t HRTIM_TIME_CPT2ECR_TACMP2_MASK = UINT32_C(0x00008000);       /** @brief Timer A compare 2 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TACMP1_MASK = UINT32_C(0x00004000);       /** @brief Timer A compare 1 */
    static const uint32_t HRTIM_TIME_CPT2ECR_TA1RST_MASK = UINT32_C(0x00002000);       /** @brief Timer A output 1 reset */
    static const uint32_t HRTIM_TIME_CPT2ECR_TA1SET_MASK = UINT32_C(0x00001000);       /** @brief Timer A output 1 set */
    static const uint32_t HRTIM_TIME_CPT2ECR_EXEV1CPT_MASK = UINT32_C(0x00000004);     /** @brief External event 1 capture */
    static const uint32_t HRTIM_TIME_CPT2ECR_UDPCPT_MASK = UINT32_C(0x00000002);       /** @brief Update capture */
    static const uint32_t HRTIM_TIME_CPT2ECR_SWCPT_MASK = UINT32_C(0x00000001);        /** @brief Software capture */
    static const uint32_t HRTIM_TIME_OUTER_DIDL2_MASK = UINT32_C(0x00800000);          /** @brief Output 2 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIME_OUTER_CHP2_MASK = UINT32_C(0x00400000);           /** @brief Output 2 chopper enable */
    static const uint32_t HRTIM_TIME_OUTER_FAULT2_MASK = UINT32_C(0x00300000);         /** @brief Output 2 fault state */
    static const uint32_t HRTIM_TIME_OUTER_IDLES2_MASK = UINT32_C(0x00080000);         /** @brief Output 2 idle state */
    static const uint32_t HRTIM_TIME_OUTER_IDLEM2_MASK = UINT32_C(0x00040000);         /** @brief Output 2 idle mode */
    static const uint32_t HRTIM_TIME_OUTER_POL2_MASK = UINT32_C(0x00020000);           /** @brief Output 2 polarity */
    static const uint32_t HRTIM_TIME_OUTER_DLYPRT_MASK = UINT32_C(0x00001C00);         /** @brief Delayed protection */
    static const uint32_t HRTIM_TIME_OUTER_DLYPRTEN_MASK = UINT32_C(0x00000200);       /** @brief Delayed protection enable */
    static const uint32_t HRTIM_TIME_OUTER_DTEN_MASK = UINT32_C(0x00000100);           /** @brief Deadtime enable */
    static const uint32_t HRTIM_TIME_OUTER_DIDL1_MASK = UINT32_C(0x00000080);          /** @brief Output 1 deadtime upon burst mode idle entry */
    static const uint32_t HRTIM_TIME_OUTER_CHP1_MASK = UINT32_C(0x00000040);           /** @brief Output 1 chopper enable */
    static const uint32_t HRTIM_TIME_OUTER_FAULT1_MASK = UINT32_C(0x00000030);         /** @brief Output 1 fault state */
    static const uint32_t HRTIM_TIME_OUTER_IDLES1_MASK = UINT32_C(0x00000008);         /** @brief Output 1 idle state */
    static const uint32_t HRTIM_TIME_OUTER_IDLEM1_MASK = UINT32_C(0x00000004);         /** @brief Output 1 idle mode */
    static const uint32_t HRTIM_TIME_OUTER_POL1_MASK = UINT32_C(0x00000002);           /** @brief Output 1 polarity */
    static const uint32_t HRTIM_TIME_FLTER_FLTLCK_MASK = UINT32_C(0x80000000);         /** @brief Fault sources lock */

    /** @subsection HRTIM_TIME field position array definitions */

    static const int32_t HRTIM_TIME_FLTER_CMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag */
      INT32_C(1),    /** @brief Compare 2 interrupt flag */
      INT32_C(2),    /** @brief Compare 3 interrupt flag */
      INT32_C(3),    /** @brief Compare 4 interrupt flag */
    };

    static const int32_t HRTIM_TIME_FLTER_CMPXC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Compare 1 interrupt flag clear */
      INT32_C(1),    /** @brief Compare 2 interrupt flag clear */
      INT32_C(2),    /** @brief Compare 3 interrupt flag clear */
      INT32_C(3),    /** @brief Compare 4 interrupt flag clear */
    };

    static const int32_t HRTIM_TIME_FLTER_CMPXDE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief CMP1DE */
      INT32_C(17),   /** @brief CMP2DE */
      INT32_C(18),   /** @brief CMP3DE */
      INT32_C(19),   /** @brief CMP4DE */
    };

    static const int32_t HRTIM_TIME_FLTER_CMPXIE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief CMP1IE */
      INT32_C(1),    /** @brief CMP2IE */
      INT32_C(2),    /** @brief CMP3IE */
      INT32_C(3),    /** @brief CMP4IE */
    };

    static const int32_t HRTIM_TIME_FLTER_EXTEVNTX_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief External event 2 */
      INT32_C(23),   /** @brief External event 3 */
      INT32_C(24),   /** @brief External event 4 */
      INT32_C(25),   /** @brief External event 5 */
      INT32_C(26),   /** @brief External event 6 */
      INT32_C(27),   /** @brief External event 7 */
      INT32_C(28),   /** @brief External event 8 */
      INT32_C(29),   /** @brief External event 9 */
      INT32_C(30),   /** @brief External event 10 */
    };

    static const int32_t HRTIM_TIME_FLTER_TIMEVNTX_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(12),   /** @brief Timer event 1 */
      INT32_C(13),   /** @brief Timer event 2 */
      INT32_C(14),   /** @brief Timer event 3 */
      INT32_C(15),   /** @brief Timer event 4 */
      INT32_C(16),   /** @brief Timer event 5 */
      INT32_C(17),   /** @brief Timer event 6 */
      INT32_C(18),   /** @brief Timer event 7 */
      INT32_C(19),   /** @brief Timer event 8 */
      INT32_C(20),   /** @brief Timer event 9 */
    };

    static const int32_t HRTIM_TIME_FLTER_MSTCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Master compare 1 */
      INT32_C(9),    /** @brief Master compare 2 */
      INT32_C(10),   /** @brief Master compare 3 */
      INT32_C(11),   /** @brief Master compare 4 */
    };

    static const int32_t HRTIM_TIME_FLTER_EEXFLTR_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief External event 1 filter */
      INT32_C(7),    /** @brief External event 2 filter */
      INT32_C(13),   /** @brief External event 3 filter */
      INT32_C(19),   /** @brief External event 4 filter */
      INT32_C(25),   /** @brief External event 5 filter */
    };

    static const int32_t HRTIM_TIME_FLTER_EEXLTCH_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief External event 1 latch */
      INT32_C(6),    /** @brief External event 2 latch */
      INT32_C(12),   /** @brief External event 3 latch */
      INT32_C(18),   /** @brief External event 4 latch */
      INT32_C(24),   /** @brief External event 5 latch */
    };

    static const int32_t HRTIM_TIME_FLTER_TIMDCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(28),   /** @brief Timer D compare 1 */
      INT32_C(29),   /** @brief Timer D compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(30),   /** @brief Timer D compare 4 */
    };

    static const int32_t HRTIM_TIME_FLTER_TIMCCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(25),   /** @brief Timer C compare 1 */
      INT32_C(26),   /** @brief Timer C compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(27),   /** @brief Timer C compare 4 */
    };

    static const int32_t HRTIM_TIME_FLTER_TIMBCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(22),   /** @brief Timer B compare 1 */
      INT32_C(23),   /** @brief Timer B compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(24),   /** @brief Timer B compare 4 */
    };

    static const int32_t HRTIM_TIME_FLTER_TIMACMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(19),   /** @brief Timer A compare 1 */
      INT32_C(20),   /** @brief Timer A compare 2 */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(21),   /** @brief Timer A compare 4 */
    };

    static const int32_t HRTIM_TIME_FLTER_EXEVXCPT_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief External event 2 capture */
      INT32_C(4),    /** @brief External event 3 capture */
      INT32_C(5),    /** @brief External event 4 capture */
      INT32_C(6),    /** @brief External event 5 capture */
      INT32_C(7),    /** @brief External event 6 capture */
      INT32_C(8),    /** @brief External event 7 capture */
      INT32_C(9),    /** @brief External event 8 capture */
      INT32_C(10),   /** @brief External event 9 capture */
      INT32_C(11),   /** @brief External event 10 capture */
    };

    static const int32_t HRTIM_TIME_FLTER_FLTXEN_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 enable */
      INT32_C(1),    /** @brief Fault 2 enable */
      INT32_C(2),    /** @brief Fault 3 enable */
      INT32_C(3),    /** @brief Fault 4 enable */
      INT32_C(4),    /** @brief Fault 5 enable */
    };

    /** @subsection HRTIM_TIME field position definitions */

    static const int32_t HRTIM_TIME_FLTER_UPDGAT_POS = INT32_C(28);      /** @brief Update gating */
    static const int32_t HRTIM_TIME_FLTER_PREEN_POS = INT32_C(27);       /** @brief Preload enable */
    static const int32_t HRTIM_TIME_FLTER_DACSYNC_POS = INT32_C(25);     /** @brief AC synchronization */
    static const int32_t HRTIM_TIME_FLTER_MSTU_POS = INT32_C(24);        /** @brief Master timer update */
    static const int32_t HRTIM_TIME_FLTER_TEU_POS = INT32_C(23);         /** @brief TEU */
    static const int32_t HRTIM_TIME_FLTER_TDU_POS = INT32_C(22);         /** @brief TDU */
    static const int32_t HRTIM_TIME_FLTER_TCU_POS = INT32_C(21);         /** @brief TCU */
    static const int32_t HRTIM_TIME_FLTER_TBU_POS = INT32_C(20);         /** @brief TBU */
    static const int32_t HRTIM_TIME_FLTER_TXRSTU_POS = INT32_C(18);      /** @brief Timerx reset update */
    static const int32_t HRTIM_TIME_FLTER_TXREPU_POS = INT32_C(17);      /** @brief Timer x repetition update */
    static const int32_t HRTIM_TIME_FLTER_DELCMP4_POS = INT32_C(14);     /** @brief Delayed CMP4 mode */
    static const int32_t HRTIM_TIME_FLTER_DELCMP2_POS = INT32_C(12);     /** @brief Delayed CMP2 mode */
    static const int32_t HRTIM_TIME_FLTER_SYNCSTRTX_POS = INT32_C(11);   /** @brief Synchronization starts timer x */
    static const int32_t HRTIM_TIME_FLTER_SYNCRSTX_POS = INT32_C(10);    /** @brief Synchronization resets timer x */
    static const int32_t HRTIM_TIME_FLTER_PSHPLL_POS = INT32_C(6);       /** @brief Push-Pull mode enable */
    static const int32_t HRTIM_TIME_FLTER_HALF_POS = INT32_C(5);         /** @brief Half mode enable */
    static const int32_t HRTIM_TIME_FLTER_RETRIG_POS = INT32_C(4);       /** @brief Re-triggerable mode */
    static const int32_t HRTIM_TIME_FLTER_CONT_POS = INT32_C(3);         /** @brief Continuous mode */
    static const int32_t HRTIM_TIME_FLTER_CK_PSCX_POS = INT32_C(0);      /** @brief HRTIM timer x clock prescaler */
    static const int32_t HRTIM_TIME_FLTER_O2STAT_POS = INT32_C(19);      /** @brief Output 2 state */
    static const int32_t HRTIM_TIME_FLTER_O1STAT_POS = INT32_C(18);      /** @brief Output 1 state */
    static const int32_t HRTIM_TIME_FLTER_IPPSTAT_POS = INT32_C(17);     /** @brief Idle push pull status */
    static const int32_t HRTIM_TIME_FLTER_CPPSTAT_POS = INT32_C(16);     /** @brief Current push pull status */
    static const int32_t HRTIM_TIME_FLTER_DLYPRT_POS = INT32_C(14);      /** @brief Delayed protection flag */
    static const int32_t HRTIM_TIME_FLTER_RST_POS = INT32_C(13);         /** @brief Reset interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_RSTX2_POS = INT32_C(12);       /** @brief Output 2 reset interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_SETX2_POS = INT32_C(11);       /** @brief Output 2 set interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_RSTX1_POS = INT32_C(10);       /** @brief Output 1 reset interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_SETX1_POS = INT32_C(9);        /** @brief Output 1 set interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_CPT2_POS = INT32_C(8);         /** @brief Capture2 interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_CPT1_POS = INT32_C(7);         /** @brief Capture1 interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_UPD_POS = INT32_C(6);          /** @brief Update interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_REP_POS = INT32_C(4);          /** @brief Repetition interrupt flag */
    static const int32_t HRTIM_TIME_FLTER_DLYPRTC_POS = INT32_C(14);     /** @brief Delayed protection flag clear */
    static const int32_t HRTIM_TIME_FLTER_RSTC_POS = INT32_C(13);        /** @brief Reset interrupt flag clear */
    static const int32_t HRTIM_TIME_FLTER_RSTX2C_POS = INT32_C(12);      /** @brief Output 2 reset flag clear */
    static const int32_t HRTIM_TIME_FLTER_SET2XC_POS = INT32_C(11);      /** @brief Output 2 set flag clear */
    static const int32_t HRTIM_TIME_FLTER_RSTX1C_POS = INT32_C(10);      /** @brief Output 1 reset flag clear */
    static const int32_t HRTIM_TIME_FLTER_SET1XC_POS = INT32_C(9);       /** @brief Output 1 set flag clear */
    static const int32_t HRTIM_TIME_FLTER_CPT2C_POS = INT32_C(8);        /** @brief Capture2 interrupt flag clear */
    static const int32_t HRTIM_TIME_FLTER_CPT1C_POS = INT32_C(7);        /** @brief Capture1 interrupt flag clear */
    static const int32_t HRTIM_TIME_FLTER_UPDC_POS = INT32_C(6);         /** @brief Update interrupt flag clear */
    static const int32_t HRTIM_TIME_FLTER_REPC_POS = INT32_C(4);         /** @brief Repetition interrupt flag clear */
    static const int32_t HRTIM_TIME_FLTER_DLYPRTDE_POS = INT32_C(30);    /** @brief DLYPRTDE */
    static const int32_t HRTIM_TIME_FLTER_RSTDE_POS = INT32_C(29);       /** @brief RSTDE */
    static const int32_t HRTIM_TIME_FLTER_RSTX2DE_POS = INT32_C(28);     /** @brief RSTx2DE */
    static const int32_t HRTIM_TIME_FLTER_SETX2DE_POS = INT32_C(27);     /** @brief SETx2DE */
    static const int32_t HRTIM_TIME_FLTER_RSTX1DE_POS = INT32_C(26);     /** @brief RSTx1DE */
    static const int32_t HRTIM_TIME_FLTER_SET1XDE_POS = INT32_C(25);     /** @brief SET1xDE */
    static const int32_t HRTIM_TIME_FLTER_CPT2DE_POS = INT32_C(24);      /** @brief CPT2DE */
    static const int32_t HRTIM_TIME_FLTER_CPT1DE_POS = INT32_C(23);      /** @brief CPT1DE */
    static const int32_t HRTIM_TIME_FLTER_UPDDE_POS = INT32_C(22);       /** @brief UPDDE */
    static const int32_t HRTIM_TIME_FLTER_REPDE_POS = INT32_C(20);       /** @brief REPDE */
    static const int32_t HRTIM_TIME_FLTER_DLYPRTIE_POS = INT32_C(14);    /** @brief DLYPRTIE */
    static const int32_t HRTIM_TIME_FLTER_RSTIE_POS = INT32_C(13);       /** @brief RSTIE */
    static const int32_t HRTIM_TIME_FLTER_RSTX2IE_POS = INT32_C(12);     /** @brief RSTx2IE */
    static const int32_t HRTIM_TIME_FLTER_SETX2IE_POS = INT32_C(11);     /** @brief SETx2IE */
    static const int32_t HRTIM_TIME_FLTER_RSTX1IE_POS = INT32_C(10);     /** @brief RSTx1IE */
    static const int32_t HRTIM_TIME_FLTER_SET1XIE_POS = INT32_C(9);      /** @brief SET1xIE */
    static const int32_t HRTIM_TIME_FLTER_CPT2IE_POS = INT32_C(8);       /** @brief CPT2IE */
    static const int32_t HRTIM_TIME_FLTER_CPT1IE_POS = INT32_C(7);       /** @brief CPT1IE */
    static const int32_t HRTIM_TIME_FLTER_UPDIE_POS = INT32_C(6);        /** @brief UPDIE */
    static const int32_t HRTIM_TIME_FLTER_REPIE_POS = INT32_C(4);        /** @brief REPIE */
    static const int32_t HRTIM_TIME_FLTER_CNTX_POS = INT32_C(0);         /** @brief Timerx counter value */
    static const int32_t HRTIM_TIME_FLTER_PERX_POS = INT32_C(0);         /** @brief Timerx period value */
    static const int32_t HRTIM_TIME_FLTER_REPX_POS = INT32_C(0);         /** @brief Timerx repetition counter value */
    static const int32_t HRTIM_TIME_FLTER_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIME_FLTER_REPX_POS = INT32_C(16);        /** @brief Timerx repetition value (aliased from hrtim_repx register) */
    static const int32_t HRTIM_TIME_FLTER_CMP1X_POS = INT32_C(0);        /** @brief Timerx compare 1 value */
    static const int32_t HRTIM_TIME_FLTER_CMP2X_POS = INT32_C(0);        /** @brief Timerx compare 2 value */
    static const int32_t HRTIM_TIME_FLTER_CMP3X_POS = INT32_C(0);        /** @brief Timerx compare 3 value */
    static const int32_t HRTIM_TIME_FLTER_CMP4X_POS = INT32_C(0);        /** @brief Timerx compare 4 value */
    static const int32_t HRTIM_TIME_FLTER_CPT1X_POS = INT32_C(0);        /** @brief Timerx capture 1 value */
    static const int32_t HRTIM_TIME_FLTER_CPT2X_POS = INT32_C(0);        /** @brief Timerx capture 2 value */
    static const int32_t HRTIM_TIME_FLTER_DTFLKX_POS = INT32_C(31);      /** @brief Deadtime falling lock */
    static const int32_t HRTIM_TIME_FLTER_DTFSLKX_POS = INT32_C(30);     /** @brief Deadtime falling sign lock */
    static const int32_t HRTIM_TIME_FLTER_SDTFX_POS = INT32_C(25);       /** @brief Sign deadtime falling value */
    static const int32_t HRTIM_TIME_FLTER_DTFX_POS = INT32_C(16);        /** @brief Deadtime falling value */
    static const int32_t HRTIM_TIME_FLTER_DTRLKX_POS = INT32_C(15);      /** @brief Deadtime rising lock */
    static const int32_t HRTIM_TIME_FLTER_DTRSLKX_POS = INT32_C(14);     /** @brief Deadtime rising sign lock */
    static const int32_t HRTIM_TIME_FLTER_DTPRSC_POS = INT32_C(10);      /** @brief Deadtime prescaler */
    static const int32_t HRTIM_TIME_FLTER_SDTRX_POS = INT32_C(9);        /** @brief Sign deadtime rising value */
    static const int32_t HRTIM_TIME_FLTER_DTRX_POS = INT32_C(0);         /** @brief Deadtime rising value */
    static const int32_t HRTIM_TIME_FLTER_UPDATE_POS = INT32_C(31);      /** @brief Registers update (transfer preload to active) */
    static const int32_t HRTIM_TIME_FLTER_EXTEVNT1_POS = INT32_C(21);    /** @brief External event 1 */
    static const int32_t HRTIM_TIME_FLTER_MSTPER_POS = INT32_C(7);       /** @brief Master period */
    static const int32_t HRTIM_TIME_FLTER_PER_POS = INT32_C(2);          /** @brief Timer A period */
    static const int32_t HRTIM_TIME_FLTER_RESYNC_POS = INT32_C(1);       /** @brief Timer A resynchronizaton */
    static const int32_t HRTIM_TIME_FLTER_SST_POS = INT32_C(0);          /** @brief Software set trigger */
    static const int32_t HRTIM_TIME_FLTER_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIME_FLTER_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIME_FLTER_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIME_FLTER_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIME_FLTER_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIME_FLTER_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIME_FLTER_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIME_FLTER_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIME_FLTER_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIME_FLTER_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIME_FLTER_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIME_FLTER_SST_POS = INT32_C(0);          /** @brief SST */
    static const int32_t HRTIM_TIME_FLTER_UPDATE_POS = INT32_C(31);      /** @brief UPDATE */
    static const int32_t HRTIM_TIME_FLTER_EXTEVNT1_POS = INT32_C(21);    /** @brief EXTEVNT1 */
    static const int32_t HRTIM_TIME_FLTER_MSTPER_POS = INT32_C(7);       /** @brief MSTPER */
    static const int32_t HRTIM_TIME_FLTER_PER_POS = INT32_C(2);          /** @brief PER */
    static const int32_t HRTIM_TIME_FLTER_RESYNC_POS = INT32_C(1);       /** @brief RESYNC */
    static const int32_t HRTIM_TIME_FLTER_SRT_POS = INT32_C(0);          /** @brief SRT */
    static const int32_t HRTIM_TIME_FLTER_EXTEVNT1_POS = INT32_C(9);     /** @brief External event 1 */
    static const int32_t HRTIM_TIME_FLTER_MSTPER_POS = INT32_C(4);       /** @brief Master timer period */
    static const int32_t HRTIM_TIME_FLTER_CMP4_POS = INT32_C(3);         /** @brief Timer A compare 4 reset */
    static const int32_t HRTIM_TIME_FLTER_CMP2_POS = INT32_C(2);         /** @brief Timer A compare 2 reset */
    static const int32_t HRTIM_TIME_FLTER_UPDT_POS = INT32_C(1);         /** @brief Timer A update reset */
    static const int32_t HRTIM_TIME_FLTER_STRTPW_POS = INT32_C(7);       /** @brief STRTPW */
    static const int32_t HRTIM_TIME_FLTER_CHPDTY_POS = INT32_C(4);       /** @brief Timerx chopper duty cycle value */
    static const int32_t HRTIM_TIME_FLTER_CHPFRQ_POS = INT32_C(0);       /** @brief Timerx carrier frequency value */
    static const int32_t HRTIM_TIME_FLTER_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIME_FLTER_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIME_FLTER_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIME_FLTER_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIME_FLTER_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIME_FLTER_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIME_FLTER_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIME_FLTER_TDCMP2_POS = INT32_C(27);      /** @brief Timer D compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TDCMP1_POS = INT32_C(26);      /** @brief Timer D compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TD1RST_POS = INT32_C(25);      /** @brief Timer D output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TD1SET_POS = INT32_C(24);      /** @brief Timer D output 1 set */
    static const int32_t HRTIM_TIME_FLTER_TCCMP2_POS = INT32_C(23);      /** @brief Timer C compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TCCMP1_POS = INT32_C(22);      /** @brief Timer C compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TC1RST_POS = INT32_C(21);      /** @brief Timer C output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TC1SET_POS = INT32_C(20);      /** @brief Timer C output 1 set */
    static const int32_t HRTIM_TIME_FLTER_TBCMP2_POS = INT32_C(19);      /** @brief Timer B compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TBCMP1_POS = INT32_C(18);      /** @brief Timer B compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TB1RST_POS = INT32_C(17);      /** @brief Timer B output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TB1SET_POS = INT32_C(16);      /** @brief Timer B output 1 set */
    static const int32_t HRTIM_TIME_FLTER_TACMP2_POS = INT32_C(15);      /** @brief Timer A compare 2 */
    static const int32_t HRTIM_TIME_FLTER_TACMP1_POS = INT32_C(14);      /** @brief Timer A compare 1 */
    static const int32_t HRTIM_TIME_FLTER_TA1RST_POS = INT32_C(13);      /** @brief Timer A output 1 reset */
    static const int32_t HRTIM_TIME_FLTER_TA1SET_POS = INT32_C(12);      /** @brief Timer A output 1 set */
    static const int32_t HRTIM_TIME_FLTER_EXEV1CPT_POS = INT32_C(2);     /** @brief External event 1 capture */
    static const int32_t HRTIM_TIME_FLTER_UDPCPT_POS = INT32_C(1);       /** @brief Update capture */
    static const int32_t HRTIM_TIME_FLTER_SWCPT_POS = INT32_C(0);        /** @brief Software capture */
    static const int32_t HRTIM_TIME_FLTER_DIDL2_POS = INT32_C(23);       /** @brief Output 2 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIME_FLTER_CHP2_POS = INT32_C(22);        /** @brief Output 2 chopper enable */
    static const int32_t HRTIM_TIME_FLTER_FAULT2_POS = INT32_C(20);      /** @brief Output 2 fault state */
    static const int32_t HRTIM_TIME_FLTER_IDLES2_POS = INT32_C(19);      /** @brief Output 2 idle state */
    static const int32_t HRTIM_TIME_FLTER_IDLEM2_POS = INT32_C(18);      /** @brief Output 2 idle mode */
    static const int32_t HRTIM_TIME_FLTER_POL2_POS = INT32_C(17);        /** @brief Output 2 polarity */
    static const int32_t HRTIM_TIME_FLTER_DLYPRT_POS = INT32_C(10);      /** @brief Delayed protection */
    static const int32_t HRTIM_TIME_FLTER_DLYPRTEN_POS = INT32_C(9);     /** @brief Delayed protection enable */
    static const int32_t HRTIM_TIME_FLTER_DTEN_POS = INT32_C(8);         /** @brief Deadtime enable */
    static const int32_t HRTIM_TIME_FLTER_DIDL1_POS = INT32_C(7);        /** @brief Output 1 deadtime upon burst mode idle entry */
    static const int32_t HRTIM_TIME_FLTER_CHP1_POS = INT32_C(6);         /** @brief Output 1 chopper enable */
    static const int32_t HRTIM_TIME_FLTER_FAULT1_POS = INT32_C(4);       /** @brief Output 1 fault state */
    static const int32_t HRTIM_TIME_FLTER_IDLES1_POS = INT32_C(3);       /** @brief Output 1 idle state */
    static const int32_t HRTIM_TIME_FLTER_IDLEM1_POS = INT32_C(2);       /** @brief Output 1 idle mode */
    static const int32_t HRTIM_TIME_FLTER_POL1_POS = INT32_C(1);         /** @brief Output 1 polarity */
    static const int32_t HRTIM_TIME_FLTER_FLTLCK_POS = INT32_C(31);      /** @brief Fault sources lock */

    /**********************************************************************************************
     * @section HRTIM_COMMON Definitions
     **********************************************************************************************/

    /** @subsection HRTIM_COMMON IRQ interrupt definitions */

    static const int32_t HRTIM_TIME_IRQ = INT32_C(108);   /** @brief HRTIM1 timer E interrupt */

    /** @subsection HRTIM_COMMON register array definitions */

    static _RW uint32_t* const HRTIM_COMMON_ADCXR_REG[5] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x400177BC),   /** @brief ADC trigger 1 register */
      (_RW uint32_t* const)UINT32_C(0x400177C0),   /** @brief ADC trigger 2 register */
      (_RW uint32_t* const)UINT32_C(0x400177C4),   /** @brief ADC trigger 3 register */
      (_RW uint32_t* const)UINT32_C(0x400177C8),   /** @brief ADC trigger 4 register */
    };

    /** @subsection HRTIM_COMMON register definitions */

    static _RW uint32_t* const HRTIM_COMMON_CR1_REG = (_RW uint32_t* const)UINT32_C(0x40017780);       /** @brief Control register 1 */
    static _RW uint32_t* const HRTIM_COMMON_CR2_REG = (_RW uint32_t* const)UINT32_C(0x40017784);       /** @brief Control register 2 */
    static _RW uint32_t* const HRTIM_COMMON_ISR_REG = (_RW uint32_t* const)UINT32_C(0x40017788);       /** @brief Interrupt status register */
    static _RW uint32_t* const HRTIM_COMMON_ICR_REG = (_RW uint32_t* const)UINT32_C(0x4001778C);       /** @brief Interrupt clear register */
    static _RW uint32_t* const HRTIM_COMMON_IER_REG = (_RW uint32_t* const)UINT32_C(0x40017790);       /** @brief Interrupt enable register */
    static _RW uint32_t* const HRTIM_COMMON_OENR_REG = (_RW uint32_t* const)UINT32_C(0x40017794);      /** @brief Output enable register */
    static _RW uint32_t* const HRTIM_COMMON_DISR_REG = (_RW uint32_t* const)UINT32_C(0x40017798);      /** @brief DISR */
    static _RO uint32_t* const HRTIM_COMMON_ODSR_REG = (_RO uint32_t* const)UINT32_C(0x4001779C);      /** @brief Output disable status register */
    static _RW uint32_t* const HRTIM_COMMON_BMCR_REG = (_RW uint32_t* const)UINT32_C(0x400177A0);      /** @brief Burst mode control register */
    static _RW uint32_t* const HRTIM_COMMON_BMTRG_REG = (_RW uint32_t* const)UINT32_C(0x400177A4);     /** @brief BMTRG */
    static _RW uint32_t* const HRTIM_COMMON_BMCMPR6_REG = (_RW uint32_t* const)UINT32_C(0x400177A8);   /** @brief BMCMPR6 */
    static _RW uint32_t* const HRTIM_COMMON_BMPER_REG = (_RW uint32_t* const)UINT32_C(0x400177AC);     /** @brief Burst mode period register */
    static _RW uint32_t* const HRTIM_COMMON_EECR1_REG = (_RW uint32_t* const)UINT32_C(0x400177B0);     /** @brief Timer external event control register 1 */
    static _RW uint32_t* const HRTIM_COMMON_EECR2_REG = (_RW uint32_t* const)UINT32_C(0x400177B4);     /** @brief Timer external event control register 2 */
    static _RW uint32_t* const HRTIM_COMMON_EECR3_REG = (_RW uint32_t* const)UINT32_C(0x400177B8);     /** @brief Timer external event control register 3 */
    static _RW uint32_t* const HRTIM_COMMON_DLLCR_REG = (_RW uint32_t* const)UINT32_C(0x400177CC);     /** @brief DLL control register */
    static _RW uint32_t* const HRTIM_COMMON_FLTINR1_REG = (_RW uint32_t* const)UINT32_C(0x400177D0);   /** @brief HRTIM fault input register 1 */
    static _RW uint32_t* const HRTIM_COMMON_FLTINR2_REG = (_RW uint32_t* const)UINT32_C(0x400177D4);   /** @brief HRTIM fault input register 2 */
    static _RW uint32_t* const HRTIM_COMMON_BDMUPDR_REG = (_RW uint32_t* const)UINT32_C(0x400177D8);   /** @brief BDMUPDR */
    static _RW uint32_t* const HRTIM_COMMON_BDTXUPR_REG = (_RW uint32_t* const)UINT32_C(0x400177DC);   /** @brief Burst DMA timerx update register */
    static _RW uint32_t* const HRTIM_COMMON_BDMADR_REG = (_RW uint32_t* const)UINT32_C(0x400177E0);    /** @brief Burst DMA data register */

    /** @subsection HRTIM_COMMON field mask array definitions */

    static const uint32_t HRTIM_COMMON_CR1_ADXUSRC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00070000),   /** @brief ADC trigger 1 update source */
      UINT32_C(0x00380000),   /** @brief ADC trigger 2 update source */
      UINT32_C(0x01C00000),   /** @brief ADC trigger 3 update source */
      UINT32_C(0x0E000000),   /** @brief ADC trigger 4 update source */
    };

    static const uint32_t HRTIM_COMMON_ISR_FLTX_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 interrupt flag */
      UINT32_C(0x00000002),   /** @brief Fault 2 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Fault 3 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Fault 4 interrupt flag */
      UINT32_C(0x00000010),   /** @brief Fault 5 interrupt flag */
    };

    static const uint32_t HRTIM_COMMON_ICR_FLTXC_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 interrupt flag clear */
      UINT32_C(0x00000002),   /** @brief Fault 2 interrupt flag clear */
      UINT32_C(0x00000004),   /** @brief Fault 3 interrupt flag clear */
      UINT32_C(0x00000008),   /** @brief Fault 4 interrupt flag clear */
      UINT32_C(0x00000010),   /** @brief Fault 5 interrupt flag clear */
    };

    static const uint32_t HRTIM_COMMON_IER_FLTXIE_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Fault 1 interrupt enable */
      UINT32_C(0x00000002),   /** @brief Fault 2 interrupt enable */
      UINT32_C(0x00000004),   /** @brief Fault 3 interrupt enable */
      UINT32_C(0x00000008),   /** @brief Fault 4 interrupt enable */
      UINT32_C(0x00000010),   /** @brief Fault 5 interrupt enable */
    };

    static const uint32_t HRTIM_COMMON_BMTRG_MSTCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief MSTCMP1 */
      UINT32_C(0x00000010),   /** @brief MSTCMP2 */
      UINT32_C(0x00000020),   /** @brief MSTCMP3 */
      UINT32_C(0x00000040),   /** @brief MSTCMP4 */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EEXFAST_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000020),   /** @brief External event 1 fast mode */
      UINT32_C(0x00000800),   /** @brief External event 2 fast mode */
      UINT32_C(0x00020000),   /** @brief External event 3 fast mode */
      UINT32_C(0x00800000),   /** @brief External event 4 fast mode */
      UINT32_C(0x20000000),   /** @brief External event 5 fast mode */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EEXSNS_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000018),   /** @brief External event 1 sensitivity */
      UINT32_C(0x00000600),   /** @brief External event 2 sensitivity */
      UINT32_C(0x00018000),   /** @brief External event 3 sensitivity */
      UINT32_C(0x00600000),   /** @brief External event 4 sensitivity */
      UINT32_C(0x18000000),   /** @brief External event 5 sensitivity */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EEXPOL_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000004),   /** @brief External event 1 polarity */
      UINT32_C(0x00000100),   /** @brief External event 2 polarity */
      UINT32_C(0x00004000),   /** @brief External event 3 polarity */
      UINT32_C(0x00100000),   /** @brief External event 4 polarity */
      UINT32_C(0x04000000),   /** @brief External event 5 polarity */
    };

    static const uint32_t HRTIM_COMMON_EECR1_EEXSRC_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000003),   /** @brief External event 1 source */
      UINT32_C(0x000000C0),   /** @brief External event 2 source */
      UINT32_C(0x00003000),   /** @brief External event 3 source */
      UINT32_C(0x000C0000),   /** @brief External event 4 source */
      UINT32_C(0x03000000),   /** @brief External event 5 source */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD1TECX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x10000000),   /** @brief ADC trigger 1 on timer E compare 2 */
      UINT32_C(0x20000000),   /** @brief ADC trigger 1 on timer E compare 3 */
      UINT32_C(0x40000000),   /** @brief ADC trigger 1 on timer E compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD1TDCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x01000000),   /** @brief ADC trigger 1 on timer D compare 2 */
      UINT32_C(0x02000000),   /** @brief ADC trigger 1 on timer D compare 3 */
      UINT32_C(0x04000000),   /** @brief ADC trigger 1 on timer D compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD1TCCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00100000),   /** @brief ADC trigger 1 on timer C compare 2 */
      UINT32_C(0x00200000),   /** @brief ADC trigger 1 on timer C compare 3 */
      UINT32_C(0x00400000),   /** @brief ADC trigger 1 on timer C compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD1TBCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00008000),   /** @brief ADC trigger 1 on timer B compare 2 */
      UINT32_C(0x00010000),   /** @brief ADC trigger 1 on timer B compare 3 */
      UINT32_C(0x00020000),   /** @brief ADC trigger 1 on timer B compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD1TACX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000400),   /** @brief ADC trigger 1 on timer A compare 2 */
      UINT32_C(0x00000800),   /** @brief ADC trigger 1 on timer A compare 3 */
      UINT32_C(0x00001000),   /** @brief ADC trigger 1 on timer A compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD1EEVX_MASK[6] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000020),   /** @brief ADC trigger 1 on external event 1 */
      UINT32_C(0x00000040),   /** @brief ADC trigger 1 on external event 2 */
      UINT32_C(0x00000080),   /** @brief ADC trigger 1 on external event 3 */
      UINT32_C(0x00000100),   /** @brief ADC trigger 1 on external event 4 */
      UINT32_C(0x00000200),   /** @brief ADC trigger 1 on external event 5 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD1MCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief ADC trigger 1 on master compare 1 */
      UINT32_C(0x00000002),   /** @brief ADC trigger 1 on master compare 2 */
      UINT32_C(0x00000004),   /** @brief ADC trigger 1 on master compare 3 */
      UINT32_C(0x00000008),   /** @brief ADC trigger 1 on master compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD2TECX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x10000000),   /** @brief ADC trigger 2 on timer E compare 2 */
      UINT32_C(0x20000000),   /** @brief ADC trigger 2 on timer E compare 3 */
      UINT32_C(0x40000000),   /** @brief ADC trigger 2 on timer E compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD2TDCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00800000),   /** @brief ADC trigger 2 on timer D compare 2 */
      UINT32_C(0x01000000),   /** @brief ADC trigger 2 on timer D compare 3 */
      UINT32_C(0x02000000),   /** @brief ADC trigger 2 on timer D compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD2TCCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00040000),   /** @brief ADC trigger 2 on timer C compare 2 */
      UINT32_C(0x00080000),   /** @brief ADC trigger 2 on timer C compare 3 */
      UINT32_C(0x00100000),   /** @brief ADC trigger 2 on timer C compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD2TBCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00004000),   /** @brief ADC trigger 2 on timer B compare 2 */
      UINT32_C(0x00008000),   /** @brief ADC trigger 2 on timer B compare 3 */
      UINT32_C(0x00010000),   /** @brief ADC trigger 2 on timer B compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD2TACX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000400),   /** @brief ADC trigger 2 on timer A compare 2 */
      UINT32_C(0x00000800),   /** @brief ADC trigger 2 on timer A compare 3 */
      UINT32_C(0x00001000),   /** @brief ADC trigger 2 on timer A compare 4 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD2EEVX_MASK[11] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000020),   /** @brief ADC trigger 2 on external event 6 */
      UINT32_C(0x00000040),   /** @brief ADC trigger 2 on external event 7 */
      UINT32_C(0x00000080),   /** @brief ADC trigger 2 on external event 8 */
      UINT32_C(0x00000100),   /** @brief ADC trigger 2 on external event 9 */
      UINT32_C(0x00000200),   /** @brief ADC trigger 2 on external event 10 */
    };

    static const uint32_t HRTIM_COMMON_ADCXR_AD2MCX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief ADC trigger 2 on master compare 1 */
      UINT32_C(0x00000002),   /** @brief ADC trigger 2 on master compare 2 */
      UINT32_C(0x00000004),   /** @brief ADC trigger 2 on master compare 3 */
      UINT32_C(0x00000008),   /** @brief ADC trigger 2 on master compare 4 */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTXLCK_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000080),   /** @brief FLT1LCK */
      UINT32_C(0x00008000),   /** @brief FLT2LCK */
      UINT32_C(0x00800000),   /** @brief FLT3LCK */
      UINT32_C(0x80000000),   /** @brief FLT4LCK */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTXF_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000078),   /** @brief FLT1F */
      UINT32_C(0x00007800),   /** @brief FLT2F */
      UINT32_C(0x00780000),   /** @brief FLT3F */
      UINT32_C(0x78000000),   /** @brief FLT4F */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTXSRC_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000004),   /** @brief FLT1SRC */
      UINT32_C(0x00000400),   /** @brief FLT2SRC */
      UINT32_C(0x00040000),   /** @brief FLT3SRC */
      UINT32_C(0x04000000),   /** @brief FLT4SRC */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTXP_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief FLT1P */
      UINT32_C(0x00000200),   /** @brief FLT2P */
      UINT32_C(0x00020000),   /** @brief FLT3P */
      UINT32_C(0x02000000),   /** @brief FLT4P */
    };

    static const uint32_t HRTIM_COMMON_FLTINR1_FLTXE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief FLT1E */
      UINT32_C(0x00000100),   /** @brief FLT2E */
      UINT32_C(0x00010000),   /** @brief FLT3E */
      UINT32_C(0x01000000),   /** @brief FLT4E */
    };

    static const uint32_t HRTIM_COMMON_BDMUPDR_MCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief MCMP1 */
      UINT32_C(0x00000080),   /** @brief MCMP2 */
      UINT32_C(0x00000100),   /** @brief MCMP3 */
      UINT32_C(0x00000200),   /** @brief MCMP4 */
    };

    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCMPX_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000040),   /** @brief HRTIM_CMP1xR register update enable */
      UINT32_C(0x00000080),   /** @brief HRTIM_CMP2xR register update enable */
      UINT32_C(0x00000100),   /** @brief HRTIM_CMP3xR register update enable */
      UINT32_C(0x00000200),   /** @brief HRTIM_CMP4xR register update enable */
    };

    /** @subsection HRTIM_COMMON field mask definitions */

    static const uint32_t HRTIM_COMMON_CR1_TEUDIS_MASK = UINT32_C(0x00000020);          /** @brief Timer E update disable */
    static const uint32_t HRTIM_COMMON_CR1_TDUDIS_MASK = UINT32_C(0x00000010);          /** @brief Timer D update disable */
    static const uint32_t HRTIM_COMMON_CR1_TCUDIS_MASK = UINT32_C(0x00000008);          /** @brief Timer C update disable */
    static const uint32_t HRTIM_COMMON_CR1_TBUDIS_MASK = UINT32_C(0x00000004);          /** @brief Timer B update disable */
    static const uint32_t HRTIM_COMMON_CR1_TAUDIS_MASK = UINT32_C(0x00000002);          /** @brief Timer A update disable */
    static const uint32_t HRTIM_COMMON_CR1_MUDIS_MASK = UINT32_C(0x00000001);           /** @brief Master update disable */
    static const uint32_t HRTIM_COMMON_CR2_TERST_MASK = UINT32_C(0x00002000);           /** @brief Timer E counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TDRST_MASK = UINT32_C(0x00001000);           /** @brief Timer D counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TCRST_MASK = UINT32_C(0x00000800);           /** @brief Timer C counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TBRST_MASK = UINT32_C(0x00000400);           /** @brief Timer B counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TARST_MASK = UINT32_C(0x00000200);           /** @brief Timer A counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_MRST_MASK = UINT32_C(0x00000100);            /** @brief Master counter software reset */
    static const uint32_t HRTIM_COMMON_CR2_TESWU_MASK = UINT32_C(0x00000020);           /** @brief Timer E software update */
    static const uint32_t HRTIM_COMMON_CR2_TDSWU_MASK = UINT32_C(0x00000010);           /** @brief Timer D software update */
    static const uint32_t HRTIM_COMMON_CR2_TCSWU_MASK = UINT32_C(0x00000008);           /** @brief Timer C software update */
    static const uint32_t HRTIM_COMMON_CR2_TBSWU_MASK = UINT32_C(0x00000004);           /** @brief Timer B software update */
    static const uint32_t HRTIM_COMMON_CR2_TASWU_MASK = UINT32_C(0x00000002);           /** @brief Timer A software update */
    static const uint32_t HRTIM_COMMON_CR2_MSWU_MASK = UINT32_C(0x00000001);            /** @brief Master timer software update */
    static const uint32_t HRTIM_COMMON_ISR_BMPER_MASK = UINT32_C(0x00020000);           /** @brief Burst mode period interrupt flag */
    static const uint32_t HRTIM_COMMON_ISR_DLLRDY_MASK = UINT32_C(0x00010000);          /** @brief DLL ready interrupt flag */
    static const uint32_t HRTIM_COMMON_ISR_SYSFLT_MASK = UINT32_C(0x00000020);          /** @brief System fault interrupt flag */
    static const uint32_t HRTIM_COMMON_ICR_BMPERC_MASK = UINT32_C(0x00020000);          /** @brief Burst mode period flag clear */
    static const uint32_t HRTIM_COMMON_ICR_DLLRDYC_MASK = UINT32_C(0x00010000);         /** @brief DLL ready interrupt flag clear */
    static const uint32_t HRTIM_COMMON_ICR_SYSFLTC_MASK = UINT32_C(0x00000020);         /** @brief System fault interrupt flag clear */
    static const uint32_t HRTIM_COMMON_IER_BMPERIE_MASK = UINT32_C(0x00020000);         /** @brief Burst mode period interrupt enable */
    static const uint32_t HRTIM_COMMON_IER_DLLRDYIE_MASK = UINT32_C(0x00010000);        /** @brief DLL ready interrupt enable */
    static const uint32_t HRTIM_COMMON_IER_SYSFLTE_MASK = UINT32_C(0x00000020);         /** @brief System fault interrupt enable */
    static const uint32_t HRTIM_COMMON_OENR_TE2OEN_MASK = UINT32_C(0x00000200);         /** @brief Timer E output 2 enable */
    static const uint32_t HRTIM_COMMON_OENR_TE1OEN_MASK = UINT32_C(0x00000100);         /** @brief Timer E output 1 enable */
    static const uint32_t HRTIM_COMMON_OENR_TD2OEN_MASK = UINT32_C(0x00000080);         /** @brief Timer D output 2 enable */
    static const uint32_t HRTIM_COMMON_OENR_TD1OEN_MASK = UINT32_C(0x00000040);         /** @brief Timer D output 1 enable */
    static const uint32_t HRTIM_COMMON_OENR_TC2OEN_MASK = UINT32_C(0x00000020);         /** @brief Timer C output 2 enable */
    static const uint32_t HRTIM_COMMON_OENR_TC1OEN_MASK = UINT32_C(0x00000010);         /** @brief Timer C output 1 enable */
    static const uint32_t HRTIM_COMMON_OENR_TB2OEN_MASK = UINT32_C(0x00000008);         /** @brief Timer B output 2 enable */
    static const uint32_t HRTIM_COMMON_OENR_TB1OEN_MASK = UINT32_C(0x00000004);         /** @brief Timer B output 1 enable */
    static const uint32_t HRTIM_COMMON_OENR_TA2OEN_MASK = UINT32_C(0x00000002);         /** @brief Timer A output 2 enable */
    static const uint32_t HRTIM_COMMON_OENR_TA1OEN_MASK = UINT32_C(0x00000001);         /** @brief Timer A output 1 enable */
    static const uint32_t HRTIM_COMMON_DISR_TE2ODIS_MASK = UINT32_C(0x00000200);        /** @brief TE2ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TE1ODIS_MASK = UINT32_C(0x00000100);        /** @brief TE1ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TD2ODIS_MASK = UINT32_C(0x00000080);        /** @brief TD2ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TD1ODIS_MASK = UINT32_C(0x00000040);        /** @brief TD1ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TC2ODIS_MASK = UINT32_C(0x00000020);        /** @brief TC2ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TC1ODIS_MASK = UINT32_C(0x00000010);        /** @brief TC1ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TB2ODIS_MASK = UINT32_C(0x00000008);        /** @brief TB2ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TB1ODIS_MASK = UINT32_C(0x00000004);        /** @brief TB1ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TA2ODIS_MASK = UINT32_C(0x00000002);        /** @brief TA2ODIS */
    static const uint32_t HRTIM_COMMON_DISR_TA1ODIS_MASK = UINT32_C(0x00000001);        /** @brief TA1ODIS */
    static const uint32_t HRTIM_COMMON_ODSR_TE2ODS_MASK = UINT32_C(0x00000200);         /** @brief Timer E output 2 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TE1ODS_MASK = UINT32_C(0x00000100);         /** @brief Timer E output 1 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TD2ODS_MASK = UINT32_C(0x00000080);         /** @brief Timer D output 2 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TD1ODS_MASK = UINT32_C(0x00000040);         /** @brief Timer D output 1 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TC2ODS_MASK = UINT32_C(0x00000020);         /** @brief Timer C output 2 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TC1ODS_MASK = UINT32_C(0x00000010);         /** @brief Timer C output 1 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TB2ODS_MASK = UINT32_C(0x00000008);         /** @brief Timer B output 2 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TB1ODS_MASK = UINT32_C(0x00000004);         /** @brief Timer B output 1 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TA2ODS_MASK = UINT32_C(0x00000002);         /** @brief Timer A output 2 disable status */
    static const uint32_t HRTIM_COMMON_ODSR_TA1ODS_MASK = UINT32_C(0x00000001);         /** @brief Timer A output 1 disable status */
    static const uint32_t HRTIM_COMMON_BMCR_BMSTAT_MASK = UINT32_C(0x80000000);         /** @brief Burst mode status */
    static const uint32_t HRTIM_COMMON_BMCR_TEBM_MASK = UINT32_C(0x00200000);           /** @brief Timer E burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TDBM_MASK = UINT32_C(0x00100000);           /** @brief Timer D burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TCBM_MASK = UINT32_C(0x00080000);           /** @brief Timer C burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TBBM_MASK = UINT32_C(0x00040000);           /** @brief Timer B burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_TABM_MASK = UINT32_C(0x00020000);           /** @brief Timer A burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_MTBM_MASK = UINT32_C(0x00010000);           /** @brief Master timer burst mode */
    static const uint32_t HRTIM_COMMON_BMCR_BMPREN_MASK = UINT32_C(0x00000400);         /** @brief Burst mode preload enable */
    static const uint32_t HRTIM_COMMON_BMCR_BMPRSC_MASK = UINT32_C(0x000003C0);         /** @brief Burst mode prescaler */
    static const uint32_t HRTIM_COMMON_BMCR_BMCLK_MASK = UINT32_C(0x0000003C);          /** @brief Burst mode clock source */
    static const uint32_t HRTIM_COMMON_BMCR_BMOM_MASK = UINT32_C(0x00000002);           /** @brief Burst mode operating mode */
    static const uint32_t HRTIM_COMMON_BMCR_BME_MASK = UINT32_C(0x00000001);            /** @brief Burst mode enable */
    static const uint32_t HRTIM_COMMON_BMTRG_OCHPEV_MASK = UINT32_C(0x80000000);        /** @brief OCHPEV */
    static const uint32_t HRTIM_COMMON_BMTRG_TECMP2_MASK = UINT32_C(0x04000000);        /** @brief TECMP2 */
    static const uint32_t HRTIM_COMMON_BMTRG_TECMP1_MASK = UINT32_C(0x02000000);        /** @brief TECMP1 */
    static const uint32_t HRTIM_COMMON_BMTRG_TEREP_MASK = UINT32_C(0x01000000);         /** @brief TEREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TERST_MASK = UINT32_C(0x00800000);         /** @brief TERST */
    static const uint32_t HRTIM_COMMON_BMTRG_TDCMP2_MASK = UINT32_C(0x00400000);        /** @brief TDCMP2 */
    static const uint32_t HRTIM_COMMON_BMTRG_TDCMP1_MASK = UINT32_C(0x00200000);        /** @brief TDCMP1 */
    static const uint32_t HRTIM_COMMON_BMTRG_TDREP_MASK = UINT32_C(0x00100000);         /** @brief TDREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TDRST_MASK = UINT32_C(0x00080000);         /** @brief TDRST */
    static const uint32_t HRTIM_COMMON_BMTRG_TCCMP2_MASK = UINT32_C(0x00040000);        /** @brief TCCMP2 */
    static const uint32_t HRTIM_COMMON_BMTRG_TCCMP1_MASK = UINT32_C(0x00020000);        /** @brief TCCMP1 */
    static const uint32_t HRTIM_COMMON_BMTRG_TCREP_MASK = UINT32_C(0x00010000);         /** @brief TCREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TCRST_MASK = UINT32_C(0x00008000);         /** @brief TCRST */
    static const uint32_t HRTIM_COMMON_BMTRG_TBCMP2_MASK = UINT32_C(0x00004000);        /** @brief TBCMP2 */
    static const uint32_t HRTIM_COMMON_BMTRG_TBCMP1_MASK = UINT32_C(0x00002000);        /** @brief TBCMP1 */
    static const uint32_t HRTIM_COMMON_BMTRG_TBREP_MASK = UINT32_C(0x00001000);         /** @brief TBREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TBRST_MASK = UINT32_C(0x00000800);         /** @brief TBRST */
    static const uint32_t HRTIM_COMMON_BMTRG_TACMP2_MASK = UINT32_C(0x00000400);        /** @brief TACMP2 */
    static const uint32_t HRTIM_COMMON_BMTRG_TACMP1_MASK = UINT32_C(0x00000200);        /** @brief TACMP1 */
    static const uint32_t HRTIM_COMMON_BMTRG_TAREP_MASK = UINT32_C(0x00000100);         /** @brief TAREP */
    static const uint32_t HRTIM_COMMON_BMTRG_TARST_MASK = UINT32_C(0x00000080);         /** @brief TARST */
    static const uint32_t HRTIM_COMMON_BMTRG_MSTREP_MASK = UINT32_C(0x00000004);        /** @brief MSTREP */
    static const uint32_t HRTIM_COMMON_BMTRG_MSTRST_MASK = UINT32_C(0x00000002);        /** @brief MSTRST */
    static const uint32_t HRTIM_COMMON_BMTRG_SW_MASK = UINT32_C(0x00000001);            /** @brief SW */
    static const uint32_t HRTIM_COMMON_BMCMPR6_BMCMP_MASK = UINT32_C(0x0000FFFF);       /** @brief BMCMP */
    static const uint32_t HRTIM_COMMON_BMPER_BMPER_MASK = UINT32_C(0x0000FFFF);         /** @brief Burst mode period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TEPER_MASK = UINT32_C(0x80000000);      /** @brief ADC trigger 1 on timer E period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TDPER_MASK = UINT32_C(0x08000000);      /** @brief ADC trigger 1 on timer D period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TCPER_MASK = UINT32_C(0x00800000);      /** @brief ADC trigger 1 on timer C period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TBRST_MASK = UINT32_C(0x00080000);      /** @brief ADC trigger 1 on timer B reset */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TBPER_MASK = UINT32_C(0x00040000);      /** @brief ADC trigger 1 on timer B period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TARST_MASK = UINT32_C(0x00004000);      /** @brief ADC trigger 1 on timer A reset */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TAPER_MASK = UINT32_C(0x00002000);      /** @brief ADC trigger 1 on timer A period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1MPER_MASK = UINT32_C(0x00000010);       /** @brief ADC trigger 1 on master period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TERST_MASK = UINT32_C(0x80000000);      /** @brief ADC trigger 2 on timer E reset */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TDRST_MASK = UINT32_C(0x08000000);      /** @brief ADC trigger 2 on timer D reset */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TDPER_MASK = UINT32_C(0x04000000);      /** @brief ADC trigger 2 on timer D period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TCRST_MASK = UINT32_C(0x00400000);      /** @brief ADC trigger 2 on timer C reset */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TCPER_MASK = UINT32_C(0x00200000);      /** @brief ADC trigger 2 on timer C period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TBPER_MASK = UINT32_C(0x00020000);      /** @brief ADC trigger 2 on timer B period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TAPER_MASK = UINT32_C(0x00002000);      /** @brief ADC trigger 2 on timer A period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2MPER_MASK = UINT32_C(0x00000010);       /** @brief ADC trigger 2 on master period */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TEPER_MASK = UINT32_C(0x80000000);      /** @brief AD1TEPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TDPER_MASK = UINT32_C(0x08000000);      /** @brief AD1TDPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TCPER_MASK = UINT32_C(0x00800000);      /** @brief AD1TCPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TBRST_MASK = UINT32_C(0x00080000);      /** @brief AD1TBRST */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TBPER_MASK = UINT32_C(0x00040000);      /** @brief AD1TBPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TARST_MASK = UINT32_C(0x00004000);      /** @brief AD1TARST */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1TAPER_MASK = UINT32_C(0x00002000);      /** @brief AD1TAPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD1MPER_MASK = UINT32_C(0x00000010);       /** @brief AD1MPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TERST_MASK = UINT32_C(0x80000000);      /** @brief AD2TERST */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TDRST_MASK = UINT32_C(0x08000000);      /** @brief AD2TDRST */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TDPER_MASK = UINT32_C(0x04000000);      /** @brief AD2TDPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TCRST_MASK = UINT32_C(0x00400000);      /** @brief AD2TCRST */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TCPER_MASK = UINT32_C(0x00200000);      /** @brief AD2TCPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TBPER_MASK = UINT32_C(0x00020000);      /** @brief AD2TBPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2TAPER_MASK = UINT32_C(0x00002000);      /** @brief AD2TAPER */
    static const uint32_t HRTIM_COMMON_ADCXR_AD2MPER_MASK = UINT32_C(0x00000010);       /** @brief AD2MPER */
    static const uint32_t HRTIM_COMMON_DLLCR_CALRTE_MASK = UINT32_C(0x0000000C);        /** @brief DLL calibration rate */
    static const uint32_t HRTIM_COMMON_DLLCR_CALEN_MASK = UINT32_C(0x00000002);         /** @brief DLL calibration enable */
    static const uint32_t HRTIM_COMMON_DLLCR_CAL_MASK = UINT32_C(0x00000001);           /** @brief DLL calibration start */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLTSD_MASK = UINT32_C(0x03000000);       /** @brief FLTSD */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5LCK_MASK = UINT32_C(0x00000080);     /** @brief FLT5LCK */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5F_MASK = UINT32_C(0x00000078);       /** @brief FLT5F */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5SRC_MASK = UINT32_C(0x00000004);     /** @brief FLT5SRC */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5P_MASK = UINT32_C(0x00000002);       /** @brief FLT5P */
    static const uint32_t HRTIM_COMMON_FLTINR2_FLT5E_MASK = UINT32_C(0x00000001);       /** @brief FLT5E */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MREP_MASK = UINT32_C(0x00000020);        /** @brief MREP */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MPER_MASK = UINT32_C(0x00000010);        /** @brief MPER */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MCNT_MASK = UINT32_C(0x00000008);        /** @brief MCNT */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MDIER_MASK = UINT32_C(0x00000004);       /** @brief MDIER */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MICR_MASK = UINT32_C(0x00000002);        /** @brief MICR */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MCR_MASK = UINT32_C(0x00000001);         /** @brief MCR */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXFLTR_MASK = UINT32_C(0x00100000);    /** @brief HRTIM_FLTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXOUTR_MASK = UINT32_C(0x00080000);    /** @brief HRTIM_OUTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCHPR_MASK = UINT32_C(0x00040000);    /** @brief HRTIM_CHPxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXRSTR_MASK = UINT32_C(0x00020000);    /** @brief HRTIM_RSTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXEEFR2_MASK = UINT32_C(0x00010000);   /** @brief HRTIM_EEFxR2 register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXEEFR1_MASK = UINT32_C(0x00008000);   /** @brief HRTIM_EEFxR1 register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXRST2R_MASK = UINT32_C(0x00004000);   /** @brief HRTIM_RST2xR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXSET2R_MASK = UINT32_C(0x00002000);   /** @brief HRTIM_SET2xR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXRST1R_MASK = UINT32_C(0x00001000);   /** @brief HRTIM_RST1xR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXSET1R_MASK = UINT32_C(0x00000800);   /** @brief HRTIM_SET1xR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMX_DTXR_MASK = UINT32_C(0x00000400);   /** @brief HRTIM_DTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXREP_MASK = UINT32_C(0x00000020);     /** @brief HRTIM_REPxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXPER_MASK = UINT32_C(0x00000010);     /** @brief HRTIM_PERxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCNT_MASK = UINT32_C(0x00000008);     /** @brief HRTIM_CNTxR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXDIER_MASK = UINT32_C(0x00000004);    /** @brief HRTIM_TIMxDIER register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXICR_MASK = UINT32_C(0x00000002);     /** @brief HRTIM_TIMxICR register update enable */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCR_MASK = UINT32_C(0x00000001);      /** @brief HRTIM_TIMxCR register update enable */

    /** @subsection HRTIM_COMMON field position array definitions */

    static const int32_t HRTIM_COMMON_BDMADR_ADXUSRC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(16),   /** @brief ADC trigger 1 update source */
      INT32_C(19),   /** @brief ADC trigger 2 update source */
      INT32_C(22),   /** @brief ADC trigger 3 update source */
      INT32_C(25),   /** @brief ADC trigger 4 update source */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTX_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 interrupt flag */
      INT32_C(1),    /** @brief Fault 2 interrupt flag */
      INT32_C(2),    /** @brief Fault 3 interrupt flag */
      INT32_C(3),    /** @brief Fault 4 interrupt flag */
      INT32_C(4),    /** @brief Fault 5 interrupt flag */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTXC_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 interrupt flag clear */
      INT32_C(1),    /** @brief Fault 2 interrupt flag clear */
      INT32_C(2),    /** @brief Fault 3 interrupt flag clear */
      INT32_C(3),    /** @brief Fault 4 interrupt flag clear */
      INT32_C(4),    /** @brief Fault 5 interrupt flag clear */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTXIE_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Fault 1 interrupt enable */
      INT32_C(1),    /** @brief Fault 2 interrupt enable */
      INT32_C(2),    /** @brief Fault 3 interrupt enable */
      INT32_C(3),    /** @brief Fault 4 interrupt enable */
      INT32_C(4),    /** @brief Fault 5 interrupt enable */
    };

    static const int32_t HRTIM_COMMON_BDMADR_MSTCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief MSTCMP1 */
      INT32_C(4),    /** @brief MSTCMP2 */
      INT32_C(5),    /** @brief MSTCMP3 */
      INT32_C(6),    /** @brief MSTCMP4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_EEXFAST_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(5),    /** @brief External event 1 fast mode */
      INT32_C(11),   /** @brief External event 2 fast mode */
      INT32_C(17),   /** @brief External event 3 fast mode */
      INT32_C(23),   /** @brief External event 4 fast mode */
      INT32_C(29),   /** @brief External event 5 fast mode */
    };

    static const int32_t HRTIM_COMMON_BDMADR_EEXSNS_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief External event 1 sensitivity */
      INT32_C(9),    /** @brief External event 2 sensitivity */
      INT32_C(15),   /** @brief External event 3 sensitivity */
      INT32_C(21),   /** @brief External event 4 sensitivity */
      INT32_C(27),   /** @brief External event 5 sensitivity */
    };

    static const int32_t HRTIM_COMMON_BDMADR_EEXPOL_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(2),    /** @brief External event 1 polarity */
      INT32_C(8),    /** @brief External event 2 polarity */
      INT32_C(14),   /** @brief External event 3 polarity */
      INT32_C(20),   /** @brief External event 4 polarity */
      INT32_C(26),   /** @brief External event 5 polarity */
    };

    static const int32_t HRTIM_COMMON_BDMADR_EEXSRC_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief External event 1 source */
      INT32_C(6),    /** @brief External event 2 source */
      INT32_C(12),   /** @brief External event 3 source */
      INT32_C(18),   /** @brief External event 4 source */
      INT32_C(24),   /** @brief External event 5 source */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD1TECX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(28),   /** @brief ADC trigger 1 on timer E compare 2 */
      INT32_C(29),   /** @brief ADC trigger 1 on timer E compare 3 */
      INT32_C(30),   /** @brief ADC trigger 1 on timer E compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD1TDCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(24),   /** @brief ADC trigger 1 on timer D compare 2 */
      INT32_C(25),   /** @brief ADC trigger 1 on timer D compare 3 */
      INT32_C(26),   /** @brief ADC trigger 1 on timer D compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD1TCCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(20),   /** @brief ADC trigger 1 on timer C compare 2 */
      INT32_C(21),   /** @brief ADC trigger 1 on timer C compare 3 */
      INT32_C(22),   /** @brief ADC trigger 1 on timer C compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD1TBCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(15),   /** @brief ADC trigger 1 on timer B compare 2 */
      INT32_C(16),   /** @brief ADC trigger 1 on timer B compare 3 */
      INT32_C(17),   /** @brief ADC trigger 1 on timer B compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD1TACX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(10),   /** @brief ADC trigger 1 on timer A compare 2 */
      INT32_C(11),   /** @brief ADC trigger 1 on timer A compare 3 */
      INT32_C(12),   /** @brief ADC trigger 1 on timer A compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD1EEVX_POS[6] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(5),    /** @brief ADC trigger 1 on external event 1 */
      INT32_C(6),    /** @brief ADC trigger 1 on external event 2 */
      INT32_C(7),    /** @brief ADC trigger 1 on external event 3 */
      INT32_C(8),    /** @brief ADC trigger 1 on external event 4 */
      INT32_C(9),    /** @brief ADC trigger 1 on external event 5 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD1MCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief ADC trigger 1 on master compare 1 */
      INT32_C(1),    /** @brief ADC trigger 1 on master compare 2 */
      INT32_C(2),    /** @brief ADC trigger 1 on master compare 3 */
      INT32_C(3),    /** @brief ADC trigger 1 on master compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD2TECX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(28),   /** @brief ADC trigger 2 on timer E compare 2 */
      INT32_C(29),   /** @brief ADC trigger 2 on timer E compare 3 */
      INT32_C(30),   /** @brief ADC trigger 2 on timer E compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD2TDCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(23),   /** @brief ADC trigger 2 on timer D compare 2 */
      INT32_C(24),   /** @brief ADC trigger 2 on timer D compare 3 */
      INT32_C(25),   /** @brief ADC trigger 2 on timer D compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD2TCCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(18),   /** @brief ADC trigger 2 on timer C compare 2 */
      INT32_C(19),   /** @brief ADC trigger 2 on timer C compare 3 */
      INT32_C(20),   /** @brief ADC trigger 2 on timer C compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD2TBCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(14),   /** @brief ADC trigger 2 on timer B compare 2 */
      INT32_C(15),   /** @brief ADC trigger 2 on timer B compare 3 */
      INT32_C(16),   /** @brief ADC trigger 2 on timer B compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD2TACX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(10),   /** @brief ADC trigger 2 on timer A compare 2 */
      INT32_C(11),   /** @brief ADC trigger 2 on timer A compare 3 */
      INT32_C(12),   /** @brief ADC trigger 2 on timer A compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD2EEVX_POS[11] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(5),    /** @brief ADC trigger 2 on external event 6 */
      INT32_C(6),    /** @brief ADC trigger 2 on external event 7 */
      INT32_C(7),    /** @brief ADC trigger 2 on external event 8 */
      INT32_C(8),    /** @brief ADC trigger 2 on external event 9 */
      INT32_C(9),    /** @brief ADC trigger 2 on external event 10 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_AD2MCX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief ADC trigger 2 on master compare 1 */
      INT32_C(1),    /** @brief ADC trigger 2 on master compare 2 */
      INT32_C(2),    /** @brief ADC trigger 2 on master compare 3 */
      INT32_C(3),    /** @brief ADC trigger 2 on master compare 4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTXLCK_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(7),    /** @brief FLT1LCK */
      INT32_C(15),   /** @brief FLT2LCK */
      INT32_C(23),   /** @brief FLT3LCK */
      INT32_C(31),   /** @brief FLT4LCK */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTXF_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief FLT1F */
      INT32_C(11),   /** @brief FLT2F */
      INT32_C(19),   /** @brief FLT3F */
      INT32_C(27),   /** @brief FLT4F */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTXSRC_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(2),    /** @brief FLT1SRC */
      INT32_C(10),   /** @brief FLT2SRC */
      INT32_C(18),   /** @brief FLT3SRC */
      INT32_C(26),   /** @brief FLT4SRC */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTXP_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief FLT1P */
      INT32_C(9),    /** @brief FLT2P */
      INT32_C(17),   /** @brief FLT3P */
      INT32_C(25),   /** @brief FLT4P */
    };

    static const int32_t HRTIM_COMMON_BDMADR_FLTXE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief FLT1E */
      INT32_C(8),    /** @brief FLT2E */
      INT32_C(16),   /** @brief FLT3E */
      INT32_C(24),   /** @brief FLT4E */
    };

    static const int32_t HRTIM_COMMON_BDMADR_MCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief MCMP1 */
      INT32_C(7),    /** @brief MCMP2 */
      INT32_C(8),    /** @brief MCMP3 */
      INT32_C(9),    /** @brief MCMP4 */
    };

    static const int32_t HRTIM_COMMON_BDMADR_TIMXCMPX_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(6),    /** @brief HRTIM_CMP1xR register update enable */
      INT32_C(7),    /** @brief HRTIM_CMP2xR register update enable */
      INT32_C(8),    /** @brief HRTIM_CMP3xR register update enable */
      INT32_C(9),    /** @brief HRTIM_CMP4xR register update enable */
    };

    /** @subsection HRTIM_COMMON field position definitions */

    static const int32_t HRTIM_COMMON_BDMADR_TEUDIS_POS = INT32_C(5);       /** @brief Timer E update disable */
    static const int32_t HRTIM_COMMON_BDMADR_TDUDIS_POS = INT32_C(4);       /** @brief Timer D update disable */
    static const int32_t HRTIM_COMMON_BDMADR_TCUDIS_POS = INT32_C(3);       /** @brief Timer C update disable */
    static const int32_t HRTIM_COMMON_BDMADR_TBUDIS_POS = INT32_C(2);       /** @brief Timer B update disable */
    static const int32_t HRTIM_COMMON_BDMADR_TAUDIS_POS = INT32_C(1);       /** @brief Timer A update disable */
    static const int32_t HRTIM_COMMON_BDMADR_MUDIS_POS = INT32_C(0);        /** @brief Master update disable */
    static const int32_t HRTIM_COMMON_BDMADR_TERST_POS = INT32_C(13);       /** @brief Timer E counter software reset */
    static const int32_t HRTIM_COMMON_BDMADR_TDRST_POS = INT32_C(12);       /** @brief Timer D counter software reset */
    static const int32_t HRTIM_COMMON_BDMADR_TCRST_POS = INT32_C(11);       /** @brief Timer C counter software reset */
    static const int32_t HRTIM_COMMON_BDMADR_TBRST_POS = INT32_C(10);       /** @brief Timer B counter software reset */
    static const int32_t HRTIM_COMMON_BDMADR_TARST_POS = INT32_C(9);        /** @brief Timer A counter software reset */
    static const int32_t HRTIM_COMMON_BDMADR_MRST_POS = INT32_C(8);         /** @brief Master counter software reset */
    static const int32_t HRTIM_COMMON_BDMADR_TESWU_POS = INT32_C(5);        /** @brief Timer E software update */
    static const int32_t HRTIM_COMMON_BDMADR_TDSWU_POS = INT32_C(4);        /** @brief Timer D software update */
    static const int32_t HRTIM_COMMON_BDMADR_TCSWU_POS = INT32_C(3);        /** @brief Timer C software update */
    static const int32_t HRTIM_COMMON_BDMADR_TBSWU_POS = INT32_C(2);        /** @brief Timer B software update */
    static const int32_t HRTIM_COMMON_BDMADR_TASWU_POS = INT32_C(1);        /** @brief Timer A software update */
    static const int32_t HRTIM_COMMON_BDMADR_MSWU_POS = INT32_C(0);         /** @brief Master timer software update */
    static const int32_t HRTIM_COMMON_BDMADR_BMPER_POS = INT32_C(17);       /** @brief Burst mode period interrupt flag */
    static const int32_t HRTIM_COMMON_BDMADR_DLLRDY_POS = INT32_C(16);      /** @brief DLL ready interrupt flag */
    static const int32_t HRTIM_COMMON_BDMADR_SYSFLT_POS = INT32_C(5);       /** @brief System fault interrupt flag */
    static const int32_t HRTIM_COMMON_BDMADR_BMPERC_POS = INT32_C(17);      /** @brief Burst mode period flag clear */
    static const int32_t HRTIM_COMMON_BDMADR_DLLRDYC_POS = INT32_C(16);     /** @brief DLL ready interrupt flag clear */
    static const int32_t HRTIM_COMMON_BDMADR_SYSFLTC_POS = INT32_C(5);      /** @brief System fault interrupt flag clear */
    static const int32_t HRTIM_COMMON_BDMADR_BMPERIE_POS = INT32_C(17);     /** @brief Burst mode period interrupt enable */
    static const int32_t HRTIM_COMMON_BDMADR_DLLRDYIE_POS = INT32_C(16);    /** @brief DLL ready interrupt enable */
    static const int32_t HRTIM_COMMON_BDMADR_SYSFLTE_POS = INT32_C(5);      /** @brief System fault interrupt enable */
    static const int32_t HRTIM_COMMON_BDMADR_TE2OEN_POS = INT32_C(9);       /** @brief Timer E output 2 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TE1OEN_POS = INT32_C(8);       /** @brief Timer E output 1 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TD2OEN_POS = INT32_C(7);       /** @brief Timer D output 2 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TD1OEN_POS = INT32_C(6);       /** @brief Timer D output 1 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TC2OEN_POS = INT32_C(5);       /** @brief Timer C output 2 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TC1OEN_POS = INT32_C(4);       /** @brief Timer C output 1 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TB2OEN_POS = INT32_C(3);       /** @brief Timer B output 2 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TB1OEN_POS = INT32_C(2);       /** @brief Timer B output 1 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TA2OEN_POS = INT32_C(1);       /** @brief Timer A output 2 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TA1OEN_POS = INT32_C(0);       /** @brief Timer A output 1 enable */
    static const int32_t HRTIM_COMMON_BDMADR_TE2ODIS_POS = INT32_C(9);      /** @brief TE2ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TE1ODIS_POS = INT32_C(8);      /** @brief TE1ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TD2ODIS_POS = INT32_C(7);      /** @brief TD2ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TD1ODIS_POS = INT32_C(6);      /** @brief TD1ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TC2ODIS_POS = INT32_C(5);      /** @brief TC2ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TC1ODIS_POS = INT32_C(4);      /** @brief TC1ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TB2ODIS_POS = INT32_C(3);      /** @brief TB2ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TB1ODIS_POS = INT32_C(2);      /** @brief TB1ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TA2ODIS_POS = INT32_C(1);      /** @brief TA2ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TA1ODIS_POS = INT32_C(0);      /** @brief TA1ODIS */
    static const int32_t HRTIM_COMMON_BDMADR_TE2ODS_POS = INT32_C(9);       /** @brief Timer E output 2 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TE1ODS_POS = INT32_C(8);       /** @brief Timer E output 1 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TD2ODS_POS = INT32_C(7);       /** @brief Timer D output 2 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TD1ODS_POS = INT32_C(6);       /** @brief Timer D output 1 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TC2ODS_POS = INT32_C(5);       /** @brief Timer C output 2 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TC1ODS_POS = INT32_C(4);       /** @brief Timer C output 1 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TB2ODS_POS = INT32_C(3);       /** @brief Timer B output 2 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TB1ODS_POS = INT32_C(2);       /** @brief Timer B output 1 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TA2ODS_POS = INT32_C(1);       /** @brief Timer A output 2 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_TA1ODS_POS = INT32_C(0);       /** @brief Timer A output 1 disable status */
    static const int32_t HRTIM_COMMON_BDMADR_BMSTAT_POS = INT32_C(31);      /** @brief Burst mode status */
    static const int32_t HRTIM_COMMON_BDMADR_TEBM_POS = INT32_C(21);        /** @brief Timer E burst mode */
    static const int32_t HRTIM_COMMON_BDMADR_TDBM_POS = INT32_C(20);        /** @brief Timer D burst mode */
    static const int32_t HRTIM_COMMON_BDMADR_TCBM_POS = INT32_C(19);        /** @brief Timer C burst mode */
    static const int32_t HRTIM_COMMON_BDMADR_TBBM_POS = INT32_C(18);        /** @brief Timer B burst mode */
    static const int32_t HRTIM_COMMON_BDMADR_TABM_POS = INT32_C(17);        /** @brief Timer A burst mode */
    static const int32_t HRTIM_COMMON_BDMADR_MTBM_POS = INT32_C(16);        /** @brief Master timer burst mode */
    static const int32_t HRTIM_COMMON_BDMADR_BMPREN_POS = INT32_C(10);      /** @brief Burst mode preload enable */
    static const int32_t HRTIM_COMMON_BDMADR_BMPRSC_POS = INT32_C(6);       /** @brief Burst mode prescaler */
    static const int32_t HRTIM_COMMON_BDMADR_BMCLK_POS = INT32_C(2);        /** @brief Burst mode clock source */
    static const int32_t HRTIM_COMMON_BDMADR_BMOM_POS = INT32_C(1);         /** @brief Burst mode operating mode */
    static const int32_t HRTIM_COMMON_BDMADR_BME_POS = INT32_C(0);          /** @brief Burst mode enable */
    static const int32_t HRTIM_COMMON_BDMADR_OCHPEV_POS = INT32_C(31);      /** @brief OCHPEV */
    static const int32_t HRTIM_COMMON_BDMADR_TECMP2_POS = INT32_C(26);      /** @brief TECMP2 */
    static const int32_t HRTIM_COMMON_BDMADR_TECMP1_POS = INT32_C(25);      /** @brief TECMP1 */
    static const int32_t HRTIM_COMMON_BDMADR_TEREP_POS = INT32_C(24);       /** @brief TEREP */
    static const int32_t HRTIM_COMMON_BDMADR_TERST_POS = INT32_C(23);       /** @brief TERST */
    static const int32_t HRTIM_COMMON_BDMADR_TDCMP2_POS = INT32_C(22);      /** @brief TDCMP2 */
    static const int32_t HRTIM_COMMON_BDMADR_TDCMP1_POS = INT32_C(21);      /** @brief TDCMP1 */
    static const int32_t HRTIM_COMMON_BDMADR_TDREP_POS = INT32_C(20);       /** @brief TDREP */
    static const int32_t HRTIM_COMMON_BDMADR_TDRST_POS = INT32_C(19);       /** @brief TDRST */
    static const int32_t HRTIM_COMMON_BDMADR_TCCMP2_POS = INT32_C(18);      /** @brief TCCMP2 */
    static const int32_t HRTIM_COMMON_BDMADR_TCCMP1_POS = INT32_C(17);      /** @brief TCCMP1 */
    static const int32_t HRTIM_COMMON_BDMADR_TCREP_POS = INT32_C(16);       /** @brief TCREP */
    static const int32_t HRTIM_COMMON_BDMADR_TCRST_POS = INT32_C(15);       /** @brief TCRST */
    static const int32_t HRTIM_COMMON_BDMADR_TBCMP2_POS = INT32_C(14);      /** @brief TBCMP2 */
    static const int32_t HRTIM_COMMON_BDMADR_TBCMP1_POS = INT32_C(13);      /** @brief TBCMP1 */
    static const int32_t HRTIM_COMMON_BDMADR_TBREP_POS = INT32_C(12);       /** @brief TBREP */
    static const int32_t HRTIM_COMMON_BDMADR_TBRST_POS = INT32_C(11);       /** @brief TBRST */
    static const int32_t HRTIM_COMMON_BDMADR_TACMP2_POS = INT32_C(10);      /** @brief TACMP2 */
    static const int32_t HRTIM_COMMON_BDMADR_TACMP1_POS = INT32_C(9);       /** @brief TACMP1 */
    static const int32_t HRTIM_COMMON_BDMADR_TAREP_POS = INT32_C(8);        /** @brief TAREP */
    static const int32_t HRTIM_COMMON_BDMADR_TARST_POS = INT32_C(7);        /** @brief TARST */
    static const int32_t HRTIM_COMMON_BDMADR_MSTREP_POS = INT32_C(2);       /** @brief MSTREP */
    static const int32_t HRTIM_COMMON_BDMADR_MSTRST_POS = INT32_C(1);       /** @brief MSTRST */
    static const int32_t HRTIM_COMMON_BDMADR_SW_POS = INT32_C(0);           /** @brief SW */
    static const int32_t HRTIM_COMMON_BDMADR_BMCMP_POS = INT32_C(0);        /** @brief BMCMP */
    static const int32_t HRTIM_COMMON_BDMADR_BMPER_POS = INT32_C(0);        /** @brief Burst mode period */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TEPER_POS = INT32_C(31);    /** @brief ADC trigger 1 on timer E period */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TDPER_POS = INT32_C(27);    /** @brief ADC trigger 1 on timer D period */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TCPER_POS = INT32_C(23);    /** @brief ADC trigger 1 on timer C period */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TBRST_POS = INT32_C(19);    /** @brief ADC trigger 1 on timer B reset */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TBPER_POS = INT32_C(18);    /** @brief ADC trigger 1 on timer B period */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TARST_POS = INT32_C(14);    /** @brief ADC trigger 1 on timer A reset */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TAPER_POS = INT32_C(13);    /** @brief ADC trigger 1 on timer A period */
    static const int32_t HRTIM_COMMON_BDMADR_AD1MPER_POS = INT32_C(4);      /** @brief ADC trigger 1 on master period */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TERST_POS = INT32_C(31);    /** @brief ADC trigger 2 on timer E reset */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TDRST_POS = INT32_C(27);    /** @brief ADC trigger 2 on timer D reset */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TDPER_POS = INT32_C(26);    /** @brief ADC trigger 2 on timer D period */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TCRST_POS = INT32_C(22);    /** @brief ADC trigger 2 on timer C reset */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TCPER_POS = INT32_C(21);    /** @brief ADC trigger 2 on timer C period */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TBPER_POS = INT32_C(17);    /** @brief ADC trigger 2 on timer B period */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TAPER_POS = INT32_C(13);    /** @brief ADC trigger 2 on timer A period */
    static const int32_t HRTIM_COMMON_BDMADR_AD2MPER_POS = INT32_C(4);      /** @brief ADC trigger 2 on master period */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TEPER_POS = INT32_C(31);    /** @brief AD1TEPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TDPER_POS = INT32_C(27);    /** @brief AD1TDPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TCPER_POS = INT32_C(23);    /** @brief AD1TCPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TBRST_POS = INT32_C(19);    /** @brief AD1TBRST */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TBPER_POS = INT32_C(18);    /** @brief AD1TBPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TARST_POS = INT32_C(14);    /** @brief AD1TARST */
    static const int32_t HRTIM_COMMON_BDMADR_AD1TAPER_POS = INT32_C(13);    /** @brief AD1TAPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD1MPER_POS = INT32_C(4);      /** @brief AD1MPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TERST_POS = INT32_C(31);    /** @brief AD2TERST */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TDRST_POS = INT32_C(27);    /** @brief AD2TDRST */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TDPER_POS = INT32_C(26);    /** @brief AD2TDPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TCRST_POS = INT32_C(22);    /** @brief AD2TCRST */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TCPER_POS = INT32_C(21);    /** @brief AD2TCPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TBPER_POS = INT32_C(17);    /** @brief AD2TBPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD2TAPER_POS = INT32_C(13);    /** @brief AD2TAPER */
    static const int32_t HRTIM_COMMON_BDMADR_AD2MPER_POS = INT32_C(4);      /** @brief AD2MPER */
    static const int32_t HRTIM_COMMON_BDMADR_CALRTE_POS = INT32_C(2);       /** @brief DLL calibration rate */
    static const int32_t HRTIM_COMMON_BDMADR_CALEN_POS = INT32_C(1);        /** @brief DLL calibration enable */
    static const int32_t HRTIM_COMMON_BDMADR_CAL_POS = INT32_C(0);          /** @brief DLL calibration start */
    static const int32_t HRTIM_COMMON_BDMADR_FLTSD_POS = INT32_C(24);       /** @brief FLTSD */
    static const int32_t HRTIM_COMMON_BDMADR_FLT5LCK_POS = INT32_C(7);      /** @brief FLT5LCK */
    static const int32_t HRTIM_COMMON_BDMADR_FLT5F_POS = INT32_C(3);        /** @brief FLT5F */
    static const int32_t HRTIM_COMMON_BDMADR_FLT5SRC_POS = INT32_C(2);      /** @brief FLT5SRC */
    static const int32_t HRTIM_COMMON_BDMADR_FLT5P_POS = INT32_C(1);        /** @brief FLT5P */
    static const int32_t HRTIM_COMMON_BDMADR_FLT5E_POS = INT32_C(0);        /** @brief FLT5E */
    static const int32_t HRTIM_COMMON_BDMADR_MREP_POS = INT32_C(5);         /** @brief MREP */
    static const int32_t HRTIM_COMMON_BDMADR_MPER_POS = INT32_C(4);         /** @brief MPER */
    static const int32_t HRTIM_COMMON_BDMADR_MCNT_POS = INT32_C(3);         /** @brief MCNT */
    static const int32_t HRTIM_COMMON_BDMADR_MDIER_POS = INT32_C(2);        /** @brief MDIER */
    static const int32_t HRTIM_COMMON_BDMADR_MICR_POS = INT32_C(1);         /** @brief MICR */
    static const int32_t HRTIM_COMMON_BDMADR_MCR_POS = INT32_C(0);          /** @brief MCR */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXFLTR_POS = INT32_C(20);    /** @brief HRTIM_FLTxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXOUTR_POS = INT32_C(19);    /** @brief HRTIM_OUTxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXCHPR_POS = INT32_C(18);    /** @brief HRTIM_CHPxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXRSTR_POS = INT32_C(17);    /** @brief HRTIM_RSTxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXEEFR2_POS = INT32_C(16);   /** @brief HRTIM_EEFxR2 register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXEEFR1_POS = INT32_C(15);   /** @brief HRTIM_EEFxR1 register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXRST2R_POS = INT32_C(14);   /** @brief HRTIM_RST2xR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXSET2R_POS = INT32_C(13);   /** @brief HRTIM_SET2xR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXRST1R_POS = INT32_C(12);   /** @brief HRTIM_RST1xR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXSET1R_POS = INT32_C(11);   /** @brief HRTIM_SET1xR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMX_DTXR_POS = INT32_C(10);   /** @brief HRTIM_DTxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXREP_POS = INT32_C(5);      /** @brief HRTIM_REPxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXPER_POS = INT32_C(4);      /** @brief HRTIM_PERxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXCNT_POS = INT32_C(3);      /** @brief HRTIM_CNTxR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXDIER_POS = INT32_C(2);     /** @brief HRTIM_TIMxDIER register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXICR_POS = INT32_C(1);      /** @brief HRTIM_TIMxICR register update enable */
    static const int32_t HRTIM_COMMON_BDMADR_TIMXCR_POS = INT32_C(0);       /** @brief HRTIM_TIMxCR register update enable */

    /**********************************************************************************************
     * @section DFSDM Definitions
     **********************************************************************************************/

    /** @subsection DFSDM IRQ interrupt array definitions */

    static const int32_t DFSDM1_FLTX_IRQ[4] = {
      INT32_C(110),    /** @brief DFSDM1 filter 0 interrupt */
      INT32_C(111),    /** @brief DFSDM1 filter 1 interrupt */
      INT32_C(112),    /** @brief DFSDM1 filter 2 interrupt */
      INT32_C(113),    /** @brief DFSDM1 filter 3 interrupt */
    };

    /** @subsection DFSDM register array definitions */

    static _RW uint32_t* const DFSDM_CHCFGXR2_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x40017020),   /** @brief DFSDM channel configuration 0 register 2 */
      (_RW uint32_t* const)UINT32_C(0x40017024),   /** @brief DFSDM channel configuration 1 register 2 */
      (_RW uint32_t* const)UINT32_C(0x40017028),   /** @brief DFSDM channel configuration 2 register 2 */
      (_RW uint32_t* const)UINT32_C(0x4001702C),   /** @brief DFSDM channel configuration 3 register 2 */
      (_RW uint32_t* const)UINT32_C(0x40017030),   /** @brief DFSDM channel configuration 4 register 2 */
      (_RW uint32_t* const)UINT32_C(0x40017034),   /** @brief DFSDM channel configuration 5 register 2 */
      (_RW uint32_t* const)UINT32_C(0x40017038),   /** @brief DFSDM channel configuration 6 register 2 */
      (_RW uint32_t* const)UINT32_C(0x4001703C),   /** @brief DFSDM channel configuration 7 register 2 */
    };

    static _RW uint32_t* const DFSDM_AWSCDXR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x40017040),   /** @brief DFSDM analog watchdog and short-circuit detector register */
      (_RW uint32_t* const)UINT32_C(0x40017044),   /** @brief DFSDM analog watchdog and short-circuit detector register */
      (_RW uint32_t* const)UINT32_C(0x40017048),   /** @brief DFSDM analog watchdog and short-circuit detector register */
      (_RW uint32_t* const)UINT32_C(0x4001704C),   /** @brief DFSDM analog watchdog and short-circuit detector register */
      (_RW uint32_t* const)UINT32_C(0x40017050),   /** @brief DFSDM analog watchdog and short-circuit detector register */
      (_RW uint32_t* const)UINT32_C(0x40017054),   /** @brief DFSDM analog watchdog and short-circuit detector register */
      (_RW uint32_t* const)UINT32_C(0x40017058),   /** @brief DFSDM analog watchdog and short-circuit detector register */
      (_RW uint32_t* const)UINT32_C(0x4001705C),   /** @brief DFSDM analog watchdog and short-circuit detector register */
    };

    static _RO uint32_t* const DFSDM_CHWDATXR_REG[8] = {
      (_RO uint32_t* const)UINT32_C(0x40017060),   /** @brief DFSDM channel watchdog filter data register */
      (_RO uint32_t* const)UINT32_C(0x40017064),   /** @brief DFSDM channel watchdog filter data register */
      (_RO uint32_t* const)UINT32_C(0x40017068),   /** @brief DFSDM channel watchdog filter data register */
      (_RO uint32_t* const)UINT32_C(0x4001706C),   /** @brief DFSDM channel watchdog filter data register */
      (_RO uint32_t* const)UINT32_C(0x40017070),   /** @brief DFSDM channel watchdog filter data register */
      (_RO uint32_t* const)UINT32_C(0x40017074),   /** @brief DFSDM channel watchdog filter data register */
      (_RO uint32_t* const)UINT32_C(0x40017078),   /** @brief DFSDM channel watchdog filter data register */
      (_RO uint32_t* const)UINT32_C(0x4001707C),   /** @brief DFSDM channel watchdog filter data register */
    };

    static _RW uint32_t* const DFSDM_CHDATINXR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x40017080),   /** @brief DFSDM channel data input register */
      (_RW uint32_t* const)UINT32_C(0x40017084),   /** @brief DFSDM channel data input register */
      (_RW uint32_t* const)UINT32_C(0x40017088),   /** @brief DFSDM channel data input register */
      (_RW uint32_t* const)UINT32_C(0x4001708C),   /** @brief DFSDM channel data input register */
      (_RW uint32_t* const)UINT32_C(0x40017090),   /** @brief DFSDM channel data input register */
      (_RW uint32_t* const)UINT32_C(0x40017094),   /** @brief DFSDM channel data input register */
      (_RW uint32_t* const)UINT32_C(0x40017098),   /** @brief DFSDM channel data input register */
      (_RW uint32_t* const)UINT32_C(0x4001709C),   /** @brief DFSDM channel data input register */
    };

    static _RW uint32_t* const DFSDM_DFSDMX_CR2_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x400170B0),   /** @brief DFSDM control register 2 */
      (_RW uint32_t* const)UINT32_C(0x400170B4),   /** @brief DFSDM control register 2 */
      (_RW uint32_t* const)UINT32_C(0x400170B8),   /** @brief DFSDM control register 2 */
      (_RW uint32_t* const)UINT32_C(0x400170BC),   /** @brief DFSDM control register 2 */
    };

    static _RO uint32_t* const DFSDM_DFSDMX_ISR_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x400170C0),   /** @brief DFSDM interrupt and status register */
      (_RO uint32_t* const)UINT32_C(0x400170C4),   /** @brief DFSDM interrupt and status register */
      (_RO uint32_t* const)UINT32_C(0x400170C8),   /** @brief DFSDM interrupt and status register */
      (_RO uint32_t* const)UINT32_C(0x400170CC),   /** @brief DFSDM interrupt and status register */
    };

    static _RW uint32_t* const DFSDM_DFSDMX_ICR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x400170D0),   /** @brief DFSDM interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x400170D4),   /** @brief DFSDM interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x400170D8),   /** @brief DFSDM interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x400170DC),   /** @brief DFSDM interrupt flag clear register */
    };

    static _RW uint32_t* const DFSDM_DFSDMX_JCHGR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x400170E0),   /** @brief DFSDM injected channel group selection register */
      (_RW uint32_t* const)UINT32_C(0x400170E4),   /** @brief DFSDM injected channel group selection register */
      (_RW uint32_t* const)UINT32_C(0x400170E8),   /** @brief DFSDM injected channel group selection register */
      (_RW uint32_t* const)UINT32_C(0x400170EC),   /** @brief DFSDM injected channel group selection register */
    };

    static _RW uint32_t* const DFSDM_DFSDMX_FCR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x400170F0),   /** @brief DFSDM filter control register */
      (_RW uint32_t* const)UINT32_C(0x400170F4),   /** @brief DFSDM filter control register */
      (_RW uint32_t* const)UINT32_C(0x400170F8),   /** @brief DFSDM filter control register */
      (_RW uint32_t* const)UINT32_C(0x400170FC),   /** @brief DFSDM filter control register */
    };

    static _RO uint32_t* const DFSDM_DFSDMX_JDATAR_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x40017100),   /** @brief DFSDM data register for injected group */
      (_RO uint32_t* const)UINT32_C(0x40017104),   /** @brief DFSDM data register for injected group */
      (_RO uint32_t* const)UINT32_C(0x40017108),   /** @brief DFSDM data register for injected group */
      (_RO uint32_t* const)UINT32_C(0x4001710C),   /** @brief DFSDM data register for injected group */
    };

    static _RO uint32_t* const DFSDM_DFSDMX_RDATAR_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x40017110),   /** @brief DFSDM data register for the regular channel */
      (_RO uint32_t* const)UINT32_C(0x40017114),   /** @brief DFSDM data register for the regular channel */
      (_RO uint32_t* const)UINT32_C(0x40017118),   /** @brief DFSDM data register for the regular channel */
      (_RO uint32_t* const)UINT32_C(0x4001711C),   /** @brief DFSDM data register for the regular channel */
    };

    static _RW uint32_t* const DFSDM_DFSDMX_AWHTR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x40017120),   /** @brief DFSDM analog watchdog high threshold register */
      (_RW uint32_t* const)UINT32_C(0x40017124),   /** @brief DFSDM analog watchdog high threshold register */
      (_RW uint32_t* const)UINT32_C(0x40017128),   /** @brief DFSDM analog watchdog high threshold register */
      (_RW uint32_t* const)UINT32_C(0x4001712C),   /** @brief DFSDM analog watchdog high threshold register */
    };

    static _RW uint32_t* const DFSDM_DFSDMX_AWLTR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x40017130),   /** @brief DFSDM analog watchdog low threshold register */
      (_RW uint32_t* const)UINT32_C(0x40017134),   /** @brief DFSDM analog watchdog low threshold register */
      (_RW uint32_t* const)UINT32_C(0x40017138),   /** @brief DFSDM analog watchdog low threshold register */
      (_RW uint32_t* const)UINT32_C(0x4001713C),   /** @brief DFSDM analog watchdog low threshold register */
    };

    static _RO uint32_t* const DFSDM_DFSDMX_AWSR_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x40017140),   /** @brief DFSDM analog watchdog status register */
      (_RO uint32_t* const)UINT32_C(0x40017144),   /** @brief DFSDM analog watchdog status register */
      (_RO uint32_t* const)UINT32_C(0x40017148),   /** @brief DFSDM analog watchdog status register */
      (_RO uint32_t* const)UINT32_C(0x4001714C),   /** @brief DFSDM analog watchdog status register */
    };

    static _RW uint32_t* const DFSDM_DFSDMX_AWCFR_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0x40017150),   /** @brief DFSDM analog watchdog clear flag register */
      (_RW uint32_t* const)UINT32_C(0x40017154),   /** @brief DFSDM analog watchdog clear flag register */
      (_RW uint32_t* const)UINT32_C(0x40017158),   /** @brief DFSDM analog watchdog clear flag register */
      (_RW uint32_t* const)UINT32_C(0x4001715C),   /** @brief DFSDM analog watchdog clear flag register */
    };

    static _RO uint32_t* const DFSDM_DFSDMX_EXMAX_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x40017160),   /** @brief DFSDM extremes detector maximum register */
      (_RO uint32_t* const)UINT32_C(0x40017164),   /** @brief DFSDM extremes detector maximum register */
      (_RO uint32_t* const)UINT32_C(0x40017168),   /** @brief DFSDM extremes detector maximum register */
      (_RO uint32_t* const)UINT32_C(0x4001716C),   /** @brief DFSDM extremes detector maximum register */
    };

    static _RO uint32_t* const DFSDM_DFSDMX_EXMIN_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x40017170),   /** @brief DFSDM extremes detector minimum register */
      (_RO uint32_t* const)UINT32_C(0x40017174),   /** @brief DFSDM extremes detector minimum register */
      (_RO uint32_t* const)UINT32_C(0x40017178),   /** @brief DFSDM extremes detector minimum register */
      (_RO uint32_t* const)UINT32_C(0x4001717C),   /** @brief DFSDM extremes detector minimum register */
    };

    static _RO uint32_t* const DFSDM_DFSDMX_CNVTIMR_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0x40017180),   /** @brief DFSDM conversion timer register */
      (_RO uint32_t* const)UINT32_C(0x40017184),   /** @brief DFSDM conversion timer register */
      (_RO uint32_t* const)UINT32_C(0x40017188),   /** @brief DFSDM conversion timer register */
      (_RO uint32_t* const)UINT32_C(0x4001718C),   /** @brief DFSDM conversion timer register */
    };

    /** @subsection DFSDM register definitions */

    static _RW uint32_t* const DFSDM_CHCFG0R1_REG = (_RW uint32_t* const)UINT32_C(0x40017000);     /** @brief DFSDM channel configuration 0 register 1 */
    static _RW uint32_t* const DFSDM_CHCFG1R1_REG = (_RW uint32_t* const)UINT32_C(0x40017004);     /** @brief DFSDM channel configuration 1 register 1 */
    static _RW uint32_t* const DFSDM_CHCFG2R1_REG = (_RW uint32_t* const)UINT32_C(0x40017008);     /** @brief DFSDM channel configuration 2 register 1 */
    static _RW uint32_t* const DFSDM_CHCFG3R1_REG = (_RW uint32_t* const)UINT32_C(0x4001700C);     /** @brief DFSDM channel configuration 3 register 1 */
    static _RW uint32_t* const DFSDM_CHCFG4R1_REG = (_RW uint32_t* const)UINT32_C(0x40017010);     /** @brief DFSDM channel configuration 4 register 1 */
    static _RW uint32_t* const DFSDM_CHCFG5R1_REG = (_RW uint32_t* const)UINT32_C(0x40017014);     /** @brief DFSDM channel configuration 5 register 1 */
    static _RW uint32_t* const DFSDM_CHCFG6R1_REG = (_RW uint32_t* const)UINT32_C(0x40017018);     /** @brief DFSDM channel configuration 6 register 1 */
    static _RW uint32_t* const DFSDM_CHCFG7R1_REG = (_RW uint32_t* const)UINT32_C(0x4001701C);     /** @brief DFSDM channel configuration 7 register 1 */
    static _RW uint32_t* const DFSDM_DFSDM0_CR1_REG = (_RW uint32_t* const)UINT32_C(0x400170A0);   /** @brief DFSDM control register 1 */
    static _RW uint32_t* const DFSDM_DFSDM1_CR1_REG = (_RW uint32_t* const)UINT32_C(0x400170A4);   /** @brief DFSDM control register 1 */
    static _RW uint32_t* const DFSDM_DFSDM2_CR1_REG = (_RW uint32_t* const)UINT32_C(0x400170A8);   /** @brief DFSDM control register 1 */
    static _RW uint32_t* const DFSDM_DFSDM3_CR1_REG = (_RW uint32_t* const)UINT32_C(0x400170AC);   /** @brief DFSDM control register 1 */

    /** @subsection DFSDM field mask definitions */

    static const uint32_t DFSDM_CHCFG0R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 0 */
    static const uint32_t DFSDM_CHCFG0R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 0 */
    static const uint32_t DFSDM_CHCFG0R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 0 */
    static const uint32_t DFSDM_CHCFG0R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 0 */
    static const uint32_t DFSDM_CHCFG0R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 0 enable */
    static const uint32_t DFSDM_CHCFG0R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG0R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 0 */
    static const uint32_t DFSDM_CHCFG0R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG0R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG0R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG0R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFG1R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 1 */
    static const uint32_t DFSDM_CHCFG1R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 1 */
    static const uint32_t DFSDM_CHCFG1R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 1 */
    static const uint32_t DFSDM_CHCFG1R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 1 */
    static const uint32_t DFSDM_CHCFG1R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 1 enable */
    static const uint32_t DFSDM_CHCFG1R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG1R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 1 */
    static const uint32_t DFSDM_CHCFG1R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG1R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG1R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG1R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFG2R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 2 */
    static const uint32_t DFSDM_CHCFG2R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 2 */
    static const uint32_t DFSDM_CHCFG2R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 2 */
    static const uint32_t DFSDM_CHCFG2R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 2 */
    static const uint32_t DFSDM_CHCFG2R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 2 enable */
    static const uint32_t DFSDM_CHCFG2R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG2R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 2 */
    static const uint32_t DFSDM_CHCFG2R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG2R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG2R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG2R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFG3R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 3 */
    static const uint32_t DFSDM_CHCFG3R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 3 */
    static const uint32_t DFSDM_CHCFG3R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 3 */
    static const uint32_t DFSDM_CHCFG3R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 3 */
    static const uint32_t DFSDM_CHCFG3R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 3 enable */
    static const uint32_t DFSDM_CHCFG3R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG3R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 3 */
    static const uint32_t DFSDM_CHCFG3R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG3R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG3R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG3R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFG4R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 4 */
    static const uint32_t DFSDM_CHCFG4R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 4 */
    static const uint32_t DFSDM_CHCFG4R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 4 */
    static const uint32_t DFSDM_CHCFG4R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 4 */
    static const uint32_t DFSDM_CHCFG4R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 4 enable */
    static const uint32_t DFSDM_CHCFG4R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG4R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 4 */
    static const uint32_t DFSDM_CHCFG4R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG4R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG4R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG4R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFG5R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 5 */
    static const uint32_t DFSDM_CHCFG5R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 5 */
    static const uint32_t DFSDM_CHCFG5R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 5 */
    static const uint32_t DFSDM_CHCFG5R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 5 */
    static const uint32_t DFSDM_CHCFG5R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 5 enable */
    static const uint32_t DFSDM_CHCFG5R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG5R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 5 */
    static const uint32_t DFSDM_CHCFG5R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG5R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG5R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG5R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFG6R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 6 */
    static const uint32_t DFSDM_CHCFG6R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 6 */
    static const uint32_t DFSDM_CHCFG6R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 6 */
    static const uint32_t DFSDM_CHCFG6R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 6 */
    static const uint32_t DFSDM_CHCFG6R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 6 enable */
    static const uint32_t DFSDM_CHCFG6R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG6R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 6 */
    static const uint32_t DFSDM_CHCFG6R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG6R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG6R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG6R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFG7R1_SITP_MASK = UINT32_C(0x00000003);           /** @brief Serial interface type for channel 7 */
    static const uint32_t DFSDM_CHCFG7R1_SPICKSEL_MASK = UINT32_C(0x0000000C);       /** @brief SPI clock select for channel 7 */
    static const uint32_t DFSDM_CHCFG7R1_SCDEN_MASK = UINT32_C(0x00000020);          /** @brief Short-circuit detector enable on channel 7 */
    static const uint32_t DFSDM_CHCFG7R1_CKABEN_MASK = UINT32_C(0x00000040);         /** @brief Clock absence detector enable on channel 7 */
    static const uint32_t DFSDM_CHCFG7R1_CHEN_MASK = UINT32_C(0x00000080);           /** @brief Channel 7 enable */
    static const uint32_t DFSDM_CHCFG7R1_CHINSEL_MASK = UINT32_C(0x00000100);        /** @brief Channel inputs selection */
    static const uint32_t DFSDM_CHCFG7R1_DATMPX_MASK = UINT32_C(0x00003000);         /** @brief Input data multiplexer for channel 7 */
    static const uint32_t DFSDM_CHCFG7R1_DATPACK_MASK = UINT32_C(0x0000C000);        /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const uint32_t DFSDM_CHCFG7R1_CKOUTDIV_MASK = UINT32_C(0x00FF0000);       /** @brief Output serial clock divider */
    static const uint32_t DFSDM_CHCFG7R1_CKOUTSRC_MASK = UINT32_C(0x40000000);       /** @brief Output serial clock source selection */
    static const uint32_t DFSDM_CHCFG7R1_DFSDMEN_MASK = UINT32_C(0x80000000);        /** @brief Global enable for DFSDM interface */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 0 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 0 */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 1 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 1 */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 2 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 2 */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 3 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 3 */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 4 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 4 */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 5 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 5 */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 6 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 6 */
    static const uint32_t DFSDM_CHCFGXR2_DTRBS_MASK = UINT32_C(0x000000F8);          /** @brief Data right bit-shift for channel 7 */
    static const uint32_t DFSDM_CHCFGXR2_OFFSET_MASK = UINT32_C(0xFFFFFF00);         /** @brief 24-bit calibration offset for channel 7 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 0 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 0 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 0 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 0 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 1 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 1 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 1 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 1 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 2 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 2 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 2 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 2 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 3 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 3 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 3 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 3 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 4 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 4 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 4 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 4 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 5 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 5 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 5 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 5 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 6 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 6 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 6 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 6 */
    static const uint32_t DFSDM_AWSCDXR_SCDT_MASK = UINT32_C(0x000000FF);            /** @brief Short-circuit detector threshold for channel 7 */
    static const uint32_t DFSDM_AWSCDXR_BKSCD_MASK = UINT32_C(0x0000F000);           /** @brief Break signal assignment for short-circuit detector on channel 7 */
    static const uint32_t DFSDM_AWSCDXR_AWFOSR_MASK = UINT32_C(0x001F0000);          /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 7 */
    static const uint32_t DFSDM_AWSCDXR_AWFORD_MASK = UINT32_C(0x00C00000);          /** @brief Analog watchdog sinc filter order on channel 7 */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHWDATXR_WDATA_MASK = UINT32_C(0x0000FFFF);          /** @brief Input channel y watchdog data */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 0 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 1 */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 1 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 2 */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 2 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 3 */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 3 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 4 */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 4 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 5 */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 5 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 6 */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 6 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 7 */
    static const uint32_t DFSDM_CHDATINXR_INDAT0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data for channel 7 */
    static const uint32_t DFSDM_CHDATINXR_INDAT1_MASK = UINT32_C(0xFFFF0000);        /** @brief Input data for channel 8 */
    static const uint32_t DFSDM_DFSDM0_CR1_DFEN_MASK = UINT32_C(0x00000001);         /** @brief DFSDM enable */
    static const uint32_t DFSDM_DFSDM0_CR1_JSWSTART_MASK = UINT32_C(0x00000002);     /** @brief Start a conversion of the injected group of channels */
    static const uint32_t DFSDM_DFSDM0_CR1_JSYNC_MASK = UINT32_C(0x00000008);        /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const uint32_t DFSDM_DFSDM0_CR1_JSCAN_MASK = UINT32_C(0x00000010);        /** @brief Scanning conversion mode for injected conversions */
    static const uint32_t DFSDM_DFSDM0_CR1_JDMAEN_MASK = UINT32_C(0x00000020);       /** @brief DMA channel enabled to read data for the injected channel group */
    static const uint32_t DFSDM_DFSDM0_CR1_JEXTSEL_MASK = UINT32_C(0x00001F00);      /** @brief Trigger signal selection for launching injected conversions */
    static const uint32_t DFSDM_DFSDM0_CR1_JEXTEN_MASK = UINT32_C(0x00006000);       /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const uint32_t DFSDM_DFSDM0_CR1_RSWSTART_MASK = UINT32_C(0x00020000);     /** @brief Software start of a conversion on the regular channel */
    static const uint32_t DFSDM_DFSDM0_CR1_RCONT_MASK = UINT32_C(0x00040000);        /** @brief Continuous mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM0_CR1_RSYNC_MASK = UINT32_C(0x00080000);        /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const uint32_t DFSDM_DFSDM0_CR1_RDMAEN_MASK = UINT32_C(0x00200000);       /** @brief DMA channel enabled to read data for the regular conversion */
    static const uint32_t DFSDM_DFSDM0_CR1_RCH_MASK = UINT32_C(0x07000000);          /** @brief Regular channel selection */
    static const uint32_t DFSDM_DFSDM0_CR1_FAST_MASK = UINT32_C(0x20000000);         /** @brief Fast conversion mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM0_CR1_AWFSEL_MASK = UINT32_C(0x40000000);       /** @brief Analog watchdog fast mode select */
    static const uint32_t DFSDM_DFSDM1_CR1_DFEN_MASK = UINT32_C(0x00000001);         /** @brief DFSDM enable */
    static const uint32_t DFSDM_DFSDM1_CR1_JSWSTART_MASK = UINT32_C(0x00000002);     /** @brief Start a conversion of the injected group of channels */
    static const uint32_t DFSDM_DFSDM1_CR1_JSYNC_MASK = UINT32_C(0x00000008);        /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const uint32_t DFSDM_DFSDM1_CR1_JSCAN_MASK = UINT32_C(0x00000010);        /** @brief Scanning conversion mode for injected conversions */
    static const uint32_t DFSDM_DFSDM1_CR1_JDMAEN_MASK = UINT32_C(0x00000020);       /** @brief DMA channel enabled to read data for the injected channel group */
    static const uint32_t DFSDM_DFSDM1_CR1_JEXTSEL_MASK = UINT32_C(0x00001F00);      /** @brief Trigger signal selection for launching injected conversions */
    static const uint32_t DFSDM_DFSDM1_CR1_JEXTEN_MASK = UINT32_C(0x00006000);       /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const uint32_t DFSDM_DFSDM1_CR1_RSWSTART_MASK = UINT32_C(0x00020000);     /** @brief Software start of a conversion on the regular channel */
    static const uint32_t DFSDM_DFSDM1_CR1_RCONT_MASK = UINT32_C(0x00040000);        /** @brief Continuous mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM1_CR1_RSYNC_MASK = UINT32_C(0x00080000);        /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const uint32_t DFSDM_DFSDM1_CR1_RDMAEN_MASK = UINT32_C(0x00200000);       /** @brief DMA channel enabled to read data for the regular conversion */
    static const uint32_t DFSDM_DFSDM1_CR1_RCH_MASK = UINT32_C(0x07000000);          /** @brief Regular channel selection */
    static const uint32_t DFSDM_DFSDM1_CR1_FAST_MASK = UINT32_C(0x20000000);         /** @brief Fast conversion mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM1_CR1_AWFSEL_MASK = UINT32_C(0x40000000);       /** @brief Analog watchdog fast mode select */
    static const uint32_t DFSDM_DFSDM2_CR1_DFEN_MASK = UINT32_C(0x00000001);         /** @brief DFSDM enable */
    static const uint32_t DFSDM_DFSDM2_CR1_JSWSTART_MASK = UINT32_C(0x00000002);     /** @brief Start a conversion of the injected group of channels */
    static const uint32_t DFSDM_DFSDM2_CR1_JSYNC_MASK = UINT32_C(0x00000008);        /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const uint32_t DFSDM_DFSDM2_CR1_JSCAN_MASK = UINT32_C(0x00000010);        /** @brief Scanning conversion mode for injected conversions */
    static const uint32_t DFSDM_DFSDM2_CR1_JDMAEN_MASK = UINT32_C(0x00000020);       /** @brief DMA channel enabled to read data for the injected channel group */
    static const uint32_t DFSDM_DFSDM2_CR1_JEXTSEL_MASK = UINT32_C(0x00001F00);      /** @brief Trigger signal selection for launching injected conversions */
    static const uint32_t DFSDM_DFSDM2_CR1_JEXTEN_MASK = UINT32_C(0x00006000);       /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const uint32_t DFSDM_DFSDM2_CR1_RSWSTART_MASK = UINT32_C(0x00020000);     /** @brief Software start of a conversion on the regular channel */
    static const uint32_t DFSDM_DFSDM2_CR1_RCONT_MASK = UINT32_C(0x00040000);        /** @brief Continuous mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM2_CR1_RSYNC_MASK = UINT32_C(0x00080000);        /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const uint32_t DFSDM_DFSDM2_CR1_RDMAEN_MASK = UINT32_C(0x00200000);       /** @brief DMA channel enabled to read data for the regular conversion */
    static const uint32_t DFSDM_DFSDM2_CR1_RCH_MASK = UINT32_C(0x07000000);          /** @brief Regular channel selection */
    static const uint32_t DFSDM_DFSDM2_CR1_FAST_MASK = UINT32_C(0x20000000);         /** @brief Fast conversion mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM2_CR1_AWFSEL_MASK = UINT32_C(0x40000000);       /** @brief Analog watchdog fast mode select */
    static const uint32_t DFSDM_DFSDM3_CR1_DFEN_MASK = UINT32_C(0x00000001);         /** @brief DFSDM enable */
    static const uint32_t DFSDM_DFSDM3_CR1_JSWSTART_MASK = UINT32_C(0x00000002);     /** @brief Start a conversion of the injected group of channels */
    static const uint32_t DFSDM_DFSDM3_CR1_JSYNC_MASK = UINT32_C(0x00000008);        /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const uint32_t DFSDM_DFSDM3_CR1_JSCAN_MASK = UINT32_C(0x00000010);        /** @brief Scanning conversion mode for injected conversions */
    static const uint32_t DFSDM_DFSDM3_CR1_JDMAEN_MASK = UINT32_C(0x00000020);       /** @brief DMA channel enabled to read data for the injected channel group */
    static const uint32_t DFSDM_DFSDM3_CR1_JEXTSEL_MASK = UINT32_C(0x00001F00);      /** @brief Trigger signal selection for launching injected conversions */
    static const uint32_t DFSDM_DFSDM3_CR1_JEXTEN_MASK = UINT32_C(0x00006000);       /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const uint32_t DFSDM_DFSDM3_CR1_RSWSTART_MASK = UINT32_C(0x00020000);     /** @brief Software start of a conversion on the regular channel */
    static const uint32_t DFSDM_DFSDM3_CR1_RCONT_MASK = UINT32_C(0x00040000);        /** @brief Continuous mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM3_CR1_RSYNC_MASK = UINT32_C(0x00080000);        /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const uint32_t DFSDM_DFSDM3_CR1_RDMAEN_MASK = UINT32_C(0x00200000);       /** @brief DMA channel enabled to read data for the regular conversion */
    static const uint32_t DFSDM_DFSDM3_CR1_RCH_MASK = UINT32_C(0x07000000);          /** @brief Regular channel selection */
    static const uint32_t DFSDM_DFSDM3_CR1_FAST_MASK = UINT32_C(0x20000000);         /** @brief Fast conversion mode selection for regular conversions */
    static const uint32_t DFSDM_DFSDM3_CR1_AWFSEL_MASK = UINT32_C(0x40000000);       /** @brief Analog watchdog fast mode select */
    static const uint32_t DFSDM_DFSDMX_CR2_JEOCIE_MASK = UINT32_C(0x00000001);       /** @brief Injected end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_REOCIE_MASK = UINT32_C(0x00000002);       /** @brief Regular end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_JOVRIE_MASK = UINT32_C(0x00000004);       /** @brief Injected data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_ROVRIE_MASK = UINT32_C(0x00000008);       /** @brief Regular data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDIE_MASK = UINT32_C(0x00000010);        /** @brief Analog watchdog interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_SCDIE_MASK = UINT32_C(0x00000020);        /** @brief Short-circuit detector interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_CKABIE_MASK = UINT32_C(0x00000040);       /** @brief Clock absence interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_EXCH_MASK = UINT32_C(0x0000FF00);         /** @brief Extremes detector channel selection */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDCH_MASK = UINT32_C(0x00FF0000);        /** @brief Analog watchdog channel selection */
    static const uint32_t DFSDM_DFSDMX_CR2_JEOCIE_MASK = UINT32_C(0x00000001);       /** @brief Injected end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_REOCIE_MASK = UINT32_C(0x00000002);       /** @brief Regular end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_JOVRIE_MASK = UINT32_C(0x00000004);       /** @brief Injected data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_ROVRIE_MASK = UINT32_C(0x00000008);       /** @brief Regular data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDIE_MASK = UINT32_C(0x00000010);        /** @brief Analog watchdog interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_SCDIE_MASK = UINT32_C(0x00000020);        /** @brief Short-circuit detector interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_CKABIE_MASK = UINT32_C(0x00000040);       /** @brief Clock absence interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_EXCH_MASK = UINT32_C(0x0000FF00);         /** @brief Extremes detector channel selection */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDCH_MASK = UINT32_C(0x00FF0000);        /** @brief Analog watchdog channel selection */
    static const uint32_t DFSDM_DFSDMX_CR2_JEOCIE_MASK = UINT32_C(0x00000001);       /** @brief Injected end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_REOCIE_MASK = UINT32_C(0x00000002);       /** @brief Regular end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_JOVRIE_MASK = UINT32_C(0x00000004);       /** @brief Injected data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_ROVRIE_MASK = UINT32_C(0x00000008);       /** @brief Regular data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDIE_MASK = UINT32_C(0x00000010);        /** @brief Analog watchdog interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_SCDIE_MASK = UINT32_C(0x00000020);        /** @brief Short-circuit detector interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_CKABIE_MASK = UINT32_C(0x00000040);       /** @brief Clock absence interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_EXCH_MASK = UINT32_C(0x0000FF00);         /** @brief Extremes detector channel selection */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDCH_MASK = UINT32_C(0x00FF0000);        /** @brief Analog watchdog channel selection */
    static const uint32_t DFSDM_DFSDMX_CR2_JEOCIE_MASK = UINT32_C(0x00000001);       /** @brief Injected end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_REOCIE_MASK = UINT32_C(0x00000002);       /** @brief Regular end of conversion interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_JOVRIE_MASK = UINT32_C(0x00000004);       /** @brief Injected data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_ROVRIE_MASK = UINT32_C(0x00000008);       /** @brief Regular data overrun interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDIE_MASK = UINT32_C(0x00000010);        /** @brief Analog watchdog interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_SCDIE_MASK = UINT32_C(0x00000020);        /** @brief Short-circuit detector interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_CKABIE_MASK = UINT32_C(0x00000040);       /** @brief Clock absence interrupt enable */
    static const uint32_t DFSDM_DFSDMX_CR2_EXCH_MASK = UINT32_C(0x0000FF00);         /** @brief Extremes detector channel selection */
    static const uint32_t DFSDM_DFSDMX_CR2_AWDCH_MASK = UINT32_C(0x00FF0000);        /** @brief Analog watchdog channel selection */
    static const uint32_t DFSDM_DFSDMX_ISR_JEOCF_MASK = UINT32_C(0x00000001);        /** @brief End of injected conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_REOCF_MASK = UINT32_C(0x00000002);        /** @brief End of regular conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_JOVRF_MASK = UINT32_C(0x00000004);        /** @brief Injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_ROVRF_MASK = UINT32_C(0x00000008);        /** @brief Regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_AWDF_MASK = UINT32_C(0x00000010);         /** @brief Analog watchdog */
    static const uint32_t DFSDM_DFSDMX_ISR_JCIP_MASK = UINT32_C(0x00002000);         /** @brief Injected conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_RCIP_MASK = UINT32_C(0x00004000);         /** @brief Regular conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_CKABF_MASK = UINT32_C(0x00FF0000);        /** @brief Clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ISR_SCDF_MASK = UINT32_C(0xFF000000);         /** @brief Short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_ISR_JEOCF_MASK = UINT32_C(0x00000001);        /** @brief End of injected conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_REOCF_MASK = UINT32_C(0x00000002);        /** @brief End of regular conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_JOVRF_MASK = UINT32_C(0x00000004);        /** @brief Injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_ROVRF_MASK = UINT32_C(0x00000008);        /** @brief Regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_AWDF_MASK = UINT32_C(0x00000010);         /** @brief Analog watchdog */
    static const uint32_t DFSDM_DFSDMX_ISR_JCIP_MASK = UINT32_C(0x00002000);         /** @brief Injected conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_RCIP_MASK = UINT32_C(0x00004000);         /** @brief Regular conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_CKABF_MASK = UINT32_C(0x00FF0000);        /** @brief Clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ISR_SCDF_MASK = UINT32_C(0xFF000000);         /** @brief Short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_ISR_JEOCF_MASK = UINT32_C(0x00000001);        /** @brief End of injected conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_REOCF_MASK = UINT32_C(0x00000002);        /** @brief End of regular conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_JOVRF_MASK = UINT32_C(0x00000004);        /** @brief Injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_ROVRF_MASK = UINT32_C(0x00000008);        /** @brief Regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_AWDF_MASK = UINT32_C(0x00000010);         /** @brief Analog watchdog */
    static const uint32_t DFSDM_DFSDMX_ISR_JCIP_MASK = UINT32_C(0x00002000);         /** @brief Injected conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_RCIP_MASK = UINT32_C(0x00004000);         /** @brief Regular conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_CKABF_MASK = UINT32_C(0x00FF0000);        /** @brief Clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ISR_SCDF_MASK = UINT32_C(0xFF000000);         /** @brief Short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_ISR_JEOCF_MASK = UINT32_C(0x00000001);        /** @brief End of injected conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_REOCF_MASK = UINT32_C(0x00000002);        /** @brief End of regular conversion flag */
    static const uint32_t DFSDM_DFSDMX_ISR_JOVRF_MASK = UINT32_C(0x00000004);        /** @brief Injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_ROVRF_MASK = UINT32_C(0x00000008);        /** @brief Regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ISR_AWDF_MASK = UINT32_C(0x00000010);         /** @brief Analog watchdog */
    static const uint32_t DFSDM_DFSDMX_ISR_JCIP_MASK = UINT32_C(0x00002000);         /** @brief Injected conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_RCIP_MASK = UINT32_C(0x00004000);         /** @brief Regular conversion in progress status */
    static const uint32_t DFSDM_DFSDMX_ISR_CKABF_MASK = UINT32_C(0x00FF0000);        /** @brief Clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ISR_SCDF_MASK = UINT32_C(0xFF000000);         /** @brief Short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRJOVRF_MASK = UINT32_C(0x00000004);     /** @brief Clear the injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRROVRF_MASK = UINT32_C(0x00000008);     /** @brief Clear the regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRCKABF_MASK = UINT32_C(0x00FF0000);     /** @brief Clear the clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRSCDF_MASK = UINT32_C(0xFF000000);      /** @brief Clear the short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRJOVRF_MASK = UINT32_C(0x00000004);     /** @brief Clear the injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRROVRF_MASK = UINT32_C(0x00000008);     /** @brief Clear the regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRCKABF_MASK = UINT32_C(0x00FF0000);     /** @brief Clear the clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRSCDF_MASK = UINT32_C(0xFF000000);      /** @brief Clear the short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRJOVRF_MASK = UINT32_C(0x00000004);     /** @brief Clear the injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRROVRF_MASK = UINT32_C(0x00000008);     /** @brief Clear the regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRCKABF_MASK = UINT32_C(0x00FF0000);     /** @brief Clear the clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRSCDF_MASK = UINT32_C(0xFF000000);      /** @brief Clear the short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRJOVRF_MASK = UINT32_C(0x00000004);     /** @brief Clear the injected conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRROVRF_MASK = UINT32_C(0x00000008);     /** @brief Clear the regular conversion overrun flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRCKABF_MASK = UINT32_C(0x00FF0000);     /** @brief Clear the clock absence flag */
    static const uint32_t DFSDM_DFSDMX_ICR_CLRSCDF_MASK = UINT32_C(0xFF000000);      /** @brief Clear the short-circuit detector flag */
    static const uint32_t DFSDM_DFSDMX_JCHGR_JCHG_MASK = UINT32_C(0x000000FF);       /** @brief Injected channel group selection */
    static const uint32_t DFSDM_DFSDMX_JCHGR_JCHG_MASK = UINT32_C(0x000000FF);       /** @brief Injected channel group selection */
    static const uint32_t DFSDM_DFSDMX_JCHGR_JCHG_MASK = UINT32_C(0x000000FF);       /** @brief Injected channel group selection */
    static const uint32_t DFSDM_DFSDMX_JCHGR_JCHG_MASK = UINT32_C(0x000000FF);       /** @brief Injected channel group selection */
    static const uint32_t DFSDM_DFSDMX_FCR_IOSR_MASK = UINT32_C(0x000000FF);         /** @brief Integrator oversampling ratio (averaging length) */
    static const uint32_t DFSDM_DFSDMX_FCR_FOSR_MASK = UINT32_C(0x03FF0000);         /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const uint32_t DFSDM_DFSDMX_FCR_FORD_MASK = UINT32_C(0xE0000000);         /** @brief Sinc filter order */
    static const uint32_t DFSDM_DFSDMX_FCR_IOSR_MASK = UINT32_C(0x000000FF);         /** @brief Integrator oversampling ratio (averaging length) */
    static const uint32_t DFSDM_DFSDMX_FCR_FOSR_MASK = UINT32_C(0x03FF0000);         /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const uint32_t DFSDM_DFSDMX_FCR_FORD_MASK = UINT32_C(0xE0000000);         /** @brief Sinc filter order */
    static const uint32_t DFSDM_DFSDMX_FCR_IOSR_MASK = UINT32_C(0x000000FF);         /** @brief Integrator oversampling ratio (averaging length) */
    static const uint32_t DFSDM_DFSDMX_FCR_FOSR_MASK = UINT32_C(0x03FF0000);         /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const uint32_t DFSDM_DFSDMX_FCR_FORD_MASK = UINT32_C(0xE0000000);         /** @brief Sinc filter order */
    static const uint32_t DFSDM_DFSDMX_FCR_IOSR_MASK = UINT32_C(0x000000FF);         /** @brief Integrator oversampling ratio (averaging length) */
    static const uint32_t DFSDM_DFSDMX_FCR_FOSR_MASK = UINT32_C(0x03FF0000);         /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const uint32_t DFSDM_DFSDMX_FCR_FORD_MASK = UINT32_C(0xE0000000);         /** @brief Sinc filter order */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATACH_MASK = UINT32_C(0x00000007);   /** @brief Injected channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Injected group conversion data */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATACH_MASK = UINT32_C(0x00000007);   /** @brief Injected channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Injected group conversion data */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATACH_MASK = UINT32_C(0x00000007);   /** @brief Injected channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Injected group conversion data */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATACH_MASK = UINT32_C(0x00000007);   /** @brief Injected channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_JDATAR_JDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Injected group conversion data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATACH_MASK = UINT32_C(0x00000007);   /** @brief Regular channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RPEND_MASK = UINT32_C(0x00000010);     /** @brief Regular channel pending data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Regular channel conversion data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATACH_MASK = UINT32_C(0x00000007);   /** @brief Regular channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RPEND_MASK = UINT32_C(0x00000010);     /** @brief Regular channel pending data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Regular channel conversion data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATACH_MASK = UINT32_C(0x00000007);   /** @brief Regular channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RPEND_MASK = UINT32_C(0x00000010);     /** @brief Regular channel pending data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Regular channel conversion data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATACH_MASK = UINT32_C(0x00000007);   /** @brief Regular channel most recently converted */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RPEND_MASK = UINT32_C(0x00000010);     /** @brief Regular channel pending data */
    static const uint32_t DFSDM_DFSDMX_RDATAR_RDATA_MASK = UINT32_C(0xFFFFFF00);     /** @brief Regular channel conversion data */
    static const uint32_t DFSDM_DFSDMX_AWHTR_BKAWH_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog high threshold event */
    static const uint32_t DFSDM_DFSDMX_AWHTR_AWHT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog high threshold */
    static const uint32_t DFSDM_DFSDMX_AWHTR_BKAWH_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog high threshold event */
    static const uint32_t DFSDM_DFSDMX_AWHTR_AWHT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog high threshold */
    static const uint32_t DFSDM_DFSDMX_AWHTR_BKAWH_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog high threshold event */
    static const uint32_t DFSDM_DFSDMX_AWHTR_AWHT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog high threshold */
    static const uint32_t DFSDM_DFSDMX_AWHTR_BKAWH_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog high threshold event */
    static const uint32_t DFSDM_DFSDMX_AWHTR_AWHT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog high threshold */
    static const uint32_t DFSDM_DFSDMX_AWLTR_BKAWL_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog low threshold event */
    static const uint32_t DFSDM_DFSDMX_AWLTR_AWLT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog low threshold */
    static const uint32_t DFSDM_DFSDMX_AWLTR_BKAWL_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog low threshold event */
    static const uint32_t DFSDM_DFSDMX_AWLTR_AWLT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog low threshold */
    static const uint32_t DFSDM_DFSDMX_AWLTR_BKAWL_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog low threshold event */
    static const uint32_t DFSDM_DFSDMX_AWLTR_AWLT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog low threshold */
    static const uint32_t DFSDM_DFSDMX_AWLTR_BKAWL_MASK = UINT32_C(0x0000000F);      /** @brief Break signal assignment to analog watchdog low threshold event */
    static const uint32_t DFSDM_DFSDMX_AWLTR_AWLT_MASK = UINT32_C(0xFFFFFF00);       /** @brief Analog watchdog low threshold */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWLTF_MASK = UINT32_C(0x000000FF);       /** @brief Analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWHTF_MASK = UINT32_C(0x0000FF00);       /** @brief Analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWLTF_MASK = UINT32_C(0x000000FF);       /** @brief Analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWHTF_MASK = UINT32_C(0x0000FF00);       /** @brief Analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWLTF_MASK = UINT32_C(0x000000FF);       /** @brief Analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWHTF_MASK = UINT32_C(0x0000FF00);       /** @brief Analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWLTF_MASK = UINT32_C(0x000000FF);       /** @brief Analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWSR_AWHTF_MASK = UINT32_C(0x0000FF00);       /** @brief Analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWLTF_MASK = UINT32_C(0x000000FF);   /** @brief Clear the analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWHTF_MASK = UINT32_C(0x0000FF00);   /** @brief Clear the analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWLTF_MASK = UINT32_C(0x000000FF);   /** @brief Clear the analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWHTF_MASK = UINT32_C(0x0000FF00);   /** @brief Clear the analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWLTF_MASK = UINT32_C(0x000000FF);   /** @brief Clear the analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWHTF_MASK = UINT32_C(0x0000FF00);   /** @brief Clear the analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWLTF_MASK = UINT32_C(0x000000FF);   /** @brief Clear the analog watchdog low threshold flag */
    static const uint32_t DFSDM_DFSDMX_AWCFR_CLRAWHTF_MASK = UINT32_C(0x0000FF00);   /** @brief Clear the analog watchdog high threshold flag */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAXCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector maximum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAX_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector maximum value */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAXCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector maximum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAX_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector maximum value */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAXCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector maximum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAX_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector maximum value */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAXCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector maximum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMAX_EXMAX_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector maximum value */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMINCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector minimum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMIN_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector minimum value */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMINCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector minimum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMIN_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector minimum value */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMINCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector minimum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMIN_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector minimum value */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMINCH_MASK = UINT32_C(0x00000007);    /** @brief Extremes detector minimum data channel */
    static const uint32_t DFSDM_DFSDMX_EXMIN_EXMIN_MASK = UINT32_C(0xFFFFFF00);      /** @brief Extremes detector minimum value */
    static const uint32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_MASK = UINT32_C(0xFFFFFFF0);   /** @brief 28-bit timer counting conversion time */
    static const uint32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_MASK = UINT32_C(0xFFFFFFF0);   /** @brief 28-bit timer counting conversion time */
    static const uint32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_MASK = UINT32_C(0xFFFFFFF0);   /** @brief 28-bit timer counting conversion time */
    static const uint32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_MASK = UINT32_C(0xFFFFFFF0);   /** @brief 28-bit timer counting conversion time */

    /** @subsection DFSDM field position definitions */

    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 0 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 1 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 2 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 3 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 4 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 5 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 6 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SITP_POS = INT32_C(0);        /** @brief Serial interface type for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SPICKSEL_POS = INT32_C(2);    /** @brief SPI clock select for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDEN_POS = INT32_C(5);       /** @brief Short-circuit detector enable on channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABEN_POS = INT32_C(6);      /** @brief Clock absence detector enable on channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHEN_POS = INT32_C(7);        /** @brief Channel 7 enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CHINSEL_POS = INT32_C(8);     /** @brief Channel inputs selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATMPX_POS = INT32_C(12);     /** @brief Input data multiplexer for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DATPACK_POS = INT32_C(14);    /** @brief Data packing mode in dfsdm_chdatinyr register */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTDIV_POS = INT32_C(16);   /** @brief Output serial clock divider */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKOUTSRC_POS = INT32_C(30);   /** @brief Output serial clock source selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFSDMEN_POS = INT32_C(31);    /** @brief Global enable for DFSDM interface */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DTRBS_POS = INT32_C(3);       /** @brief Data right bit-shift for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_OFFSET_POS = INT32_C(8);      /** @brief 24-bit calibration offset for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDT_POS = INT32_C(0);        /** @brief Short-circuit detector threshold for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKSCD_POS = INT32_C(12);      /** @brief Break signal assignment for short-circuit detector on channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFOSR_POS = INT32_C(16);     /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFORD_POS = INT32_C(22);     /** @brief Analog watchdog sinc filter order on channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_WDATA_POS = INT32_C(0);       /** @brief Input channel y watchdog data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 1 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 2 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 3 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 4 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 5 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 6 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT0_POS = INT32_C(0);      /** @brief Input data for channel 7 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_INDAT1_POS = INT32_C(16);     /** @brief Input data for channel 8 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFEN_POS = INT32_C(0);        /** @brief DFSDM enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSWSTART_POS = INT32_C(1);    /** @brief Start a conversion of the injected group of channels */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSYNC_POS = INT32_C(3);       /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSCAN_POS = INT32_C(4);       /** @brief Scanning conversion mode for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDMAEN_POS = INT32_C(5);      /** @brief DMA channel enabled to read data for the injected channel group */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTSEL_POS = INT32_C(8);     /** @brief Trigger signal selection for launching injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTEN_POS = INT32_C(13);     /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSWSTART_POS = INT32_C(17);   /** @brief Software start of a conversion on the regular channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCONT_POS = INT32_C(18);      /** @brief Continuous mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSYNC_POS = INT32_C(19);      /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDMAEN_POS = INT32_C(21);     /** @brief DMA channel enabled to read data for the regular conversion */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCH_POS = INT32_C(24);        /** @brief Regular channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FAST_POS = INT32_C(29);       /** @brief Fast conversion mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFSEL_POS = INT32_C(30);     /** @brief Analog watchdog fast mode select */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFEN_POS = INT32_C(0);        /** @brief DFSDM enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSWSTART_POS = INT32_C(1);    /** @brief Start a conversion of the injected group of channels */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSYNC_POS = INT32_C(3);       /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSCAN_POS = INT32_C(4);       /** @brief Scanning conversion mode for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDMAEN_POS = INT32_C(5);      /** @brief DMA channel enabled to read data for the injected channel group */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTSEL_POS = INT32_C(8);     /** @brief Trigger signal selection for launching injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTEN_POS = INT32_C(13);     /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSWSTART_POS = INT32_C(17);   /** @brief Software start of a conversion on the regular channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCONT_POS = INT32_C(18);      /** @brief Continuous mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSYNC_POS = INT32_C(19);      /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDMAEN_POS = INT32_C(21);     /** @brief DMA channel enabled to read data for the regular conversion */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCH_POS = INT32_C(24);        /** @brief Regular channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FAST_POS = INT32_C(29);       /** @brief Fast conversion mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFSEL_POS = INT32_C(30);     /** @brief Analog watchdog fast mode select */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFEN_POS = INT32_C(0);        /** @brief DFSDM enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSWSTART_POS = INT32_C(1);    /** @brief Start a conversion of the injected group of channels */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSYNC_POS = INT32_C(3);       /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSCAN_POS = INT32_C(4);       /** @brief Scanning conversion mode for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDMAEN_POS = INT32_C(5);      /** @brief DMA channel enabled to read data for the injected channel group */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTSEL_POS = INT32_C(8);     /** @brief Trigger signal selection for launching injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTEN_POS = INT32_C(13);     /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSWSTART_POS = INT32_C(17);   /** @brief Software start of a conversion on the regular channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCONT_POS = INT32_C(18);      /** @brief Continuous mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSYNC_POS = INT32_C(19);      /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDMAEN_POS = INT32_C(21);     /** @brief DMA channel enabled to read data for the regular conversion */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCH_POS = INT32_C(24);        /** @brief Regular channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FAST_POS = INT32_C(29);       /** @brief Fast conversion mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFSEL_POS = INT32_C(30);     /** @brief Analog watchdog fast mode select */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_DFEN_POS = INT32_C(0);        /** @brief DFSDM enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSWSTART_POS = INT32_C(1);    /** @brief Start a conversion of the injected group of channels */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSYNC_POS = INT32_C(3);       /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JSCAN_POS = INT32_C(4);       /** @brief Scanning conversion mode for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDMAEN_POS = INT32_C(5);      /** @brief DMA channel enabled to read data for the injected channel group */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTSEL_POS = INT32_C(8);     /** @brief Trigger signal selection for launching injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEXTEN_POS = INT32_C(13);     /** @brief Trigger enable and trigger edge selection for injected conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSWSTART_POS = INT32_C(17);   /** @brief Software start of a conversion on the regular channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCONT_POS = INT32_C(18);      /** @brief Continuous mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RSYNC_POS = INT32_C(19);      /** @brief Launch regular conversion synchronously with DFSDM0 */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDMAEN_POS = INT32_C(21);     /** @brief DMA channel enabled to read data for the regular conversion */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCH_POS = INT32_C(24);        /** @brief Regular channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FAST_POS = INT32_C(29);       /** @brief Fast conversion mode selection for regular conversions */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWFSEL_POS = INT32_C(30);     /** @brief Analog watchdog fast mode select */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCIE_POS = INT32_C(0);      /** @brief Injected end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCIE_POS = INT32_C(1);      /** @brief Regular end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRIE_POS = INT32_C(2);      /** @brief Injected data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRIE_POS = INT32_C(3);      /** @brief Regular data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDIE_POS = INT32_C(4);       /** @brief Analog watchdog interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDIE_POS = INT32_C(5);       /** @brief Short-circuit detector interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABIE_POS = INT32_C(6);      /** @brief Clock absence interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXCH_POS = INT32_C(8);        /** @brief Extremes detector channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDCH_POS = INT32_C(16);      /** @brief Analog watchdog channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCIE_POS = INT32_C(0);      /** @brief Injected end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCIE_POS = INT32_C(1);      /** @brief Regular end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRIE_POS = INT32_C(2);      /** @brief Injected data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRIE_POS = INT32_C(3);      /** @brief Regular data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDIE_POS = INT32_C(4);       /** @brief Analog watchdog interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDIE_POS = INT32_C(5);       /** @brief Short-circuit detector interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABIE_POS = INT32_C(6);      /** @brief Clock absence interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXCH_POS = INT32_C(8);        /** @brief Extremes detector channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDCH_POS = INT32_C(16);      /** @brief Analog watchdog channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCIE_POS = INT32_C(0);      /** @brief Injected end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCIE_POS = INT32_C(1);      /** @brief Regular end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRIE_POS = INT32_C(2);      /** @brief Injected data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRIE_POS = INT32_C(3);      /** @brief Regular data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDIE_POS = INT32_C(4);       /** @brief Analog watchdog interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDIE_POS = INT32_C(5);       /** @brief Short-circuit detector interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABIE_POS = INT32_C(6);      /** @brief Clock absence interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXCH_POS = INT32_C(8);        /** @brief Extremes detector channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDCH_POS = INT32_C(16);      /** @brief Analog watchdog channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCIE_POS = INT32_C(0);      /** @brief Injected end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCIE_POS = INT32_C(1);      /** @brief Regular end of conversion interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRIE_POS = INT32_C(2);      /** @brief Injected data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRIE_POS = INT32_C(3);      /** @brief Regular data overrun interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDIE_POS = INT32_C(4);       /** @brief Analog watchdog interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDIE_POS = INT32_C(5);       /** @brief Short-circuit detector interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABIE_POS = INT32_C(6);      /** @brief Clock absence interrupt enable */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXCH_POS = INT32_C(8);        /** @brief Extremes detector channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDCH_POS = INT32_C(16);      /** @brief Analog watchdog channel selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCF_POS = INT32_C(0);       /** @brief End of injected conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCF_POS = INT32_C(1);       /** @brief End of regular conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRF_POS = INT32_C(2);       /** @brief Injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRF_POS = INT32_C(3);       /** @brief Regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDF_POS = INT32_C(4);        /** @brief Analog watchdog */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCIP_POS = INT32_C(13);       /** @brief Injected conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCIP_POS = INT32_C(14);       /** @brief Regular conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABF_POS = INT32_C(16);      /** @brief Clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDF_POS = INT32_C(24);       /** @brief Short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCF_POS = INT32_C(0);       /** @brief End of injected conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCF_POS = INT32_C(1);       /** @brief End of regular conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRF_POS = INT32_C(2);       /** @brief Injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRF_POS = INT32_C(3);       /** @brief Regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDF_POS = INT32_C(4);        /** @brief Analog watchdog */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCIP_POS = INT32_C(13);       /** @brief Injected conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCIP_POS = INT32_C(14);       /** @brief Regular conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABF_POS = INT32_C(16);      /** @brief Clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDF_POS = INT32_C(24);       /** @brief Short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCF_POS = INT32_C(0);       /** @brief End of injected conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCF_POS = INT32_C(1);       /** @brief End of regular conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRF_POS = INT32_C(2);       /** @brief Injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRF_POS = INT32_C(3);       /** @brief Regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDF_POS = INT32_C(4);        /** @brief Analog watchdog */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCIP_POS = INT32_C(13);       /** @brief Injected conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCIP_POS = INT32_C(14);       /** @brief Regular conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABF_POS = INT32_C(16);      /** @brief Clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDF_POS = INT32_C(24);       /** @brief Short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JEOCF_POS = INT32_C(0);       /** @brief End of injected conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_REOCF_POS = INT32_C(1);       /** @brief End of regular conversion flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JOVRF_POS = INT32_C(2);       /** @brief Injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_ROVRF_POS = INT32_C(3);       /** @brief Regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWDF_POS = INT32_C(4);        /** @brief Analog watchdog */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCIP_POS = INT32_C(13);       /** @brief Injected conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RCIP_POS = INT32_C(14);       /** @brief Regular conversion in progress status */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CKABF_POS = INT32_C(16);      /** @brief Clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_SCDF_POS = INT32_C(24);       /** @brief Short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRJOVRF_POS = INT32_C(2);    /** @brief Clear the injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRROVRF_POS = INT32_C(3);    /** @brief Clear the regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRCKABF_POS = INT32_C(16);   /** @brief Clear the clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRSCDF_POS = INT32_C(24);    /** @brief Clear the short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRJOVRF_POS = INT32_C(2);    /** @brief Clear the injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRROVRF_POS = INT32_C(3);    /** @brief Clear the regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRCKABF_POS = INT32_C(16);   /** @brief Clear the clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRSCDF_POS = INT32_C(24);    /** @brief Clear the short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRJOVRF_POS = INT32_C(2);    /** @brief Clear the injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRROVRF_POS = INT32_C(3);    /** @brief Clear the regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRCKABF_POS = INT32_C(16);   /** @brief Clear the clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRSCDF_POS = INT32_C(24);    /** @brief Clear the short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRJOVRF_POS = INT32_C(2);    /** @brief Clear the injected conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRROVRF_POS = INT32_C(3);    /** @brief Clear the regular conversion overrun flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRCKABF_POS = INT32_C(16);   /** @brief Clear the clock absence flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRSCDF_POS = INT32_C(24);    /** @brief Clear the short-circuit detector flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCHG_POS = INT32_C(0);        /** @brief Injected channel group selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCHG_POS = INT32_C(0);        /** @brief Injected channel group selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCHG_POS = INT32_C(0);        /** @brief Injected channel group selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JCHG_POS = INT32_C(0);        /** @brief Injected channel group selection */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_IOSR_POS = INT32_C(0);        /** @brief Integrator oversampling ratio (averaging length) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FOSR_POS = INT32_C(16);       /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FORD_POS = INT32_C(29);       /** @brief Sinc filter order */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_IOSR_POS = INT32_C(0);        /** @brief Integrator oversampling ratio (averaging length) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FOSR_POS = INT32_C(16);       /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FORD_POS = INT32_C(29);       /** @brief Sinc filter order */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_IOSR_POS = INT32_C(0);        /** @brief Integrator oversampling ratio (averaging length) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FOSR_POS = INT32_C(16);       /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FORD_POS = INT32_C(29);       /** @brief Sinc filter order */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_IOSR_POS = INT32_C(0);        /** @brief Integrator oversampling ratio (averaging length) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FOSR_POS = INT32_C(16);       /** @brief Sinc filter oversampling ratio (decimation rate) */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_FORD_POS = INT32_C(29);       /** @brief Sinc filter order */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATACH_POS = INT32_C(0);     /** @brief Injected channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATA_POS = INT32_C(8);       /** @brief Injected group conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATACH_POS = INT32_C(0);     /** @brief Injected channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATA_POS = INT32_C(8);       /** @brief Injected group conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATACH_POS = INT32_C(0);     /** @brief Injected channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATA_POS = INT32_C(8);       /** @brief Injected group conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATACH_POS = INT32_C(0);     /** @brief Injected channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_JDATA_POS = INT32_C(8);       /** @brief Injected group conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATACH_POS = INT32_C(0);     /** @brief Regular channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RPEND_POS = INT32_C(4);       /** @brief Regular channel pending data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATA_POS = INT32_C(8);       /** @brief Regular channel conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATACH_POS = INT32_C(0);     /** @brief Regular channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RPEND_POS = INT32_C(4);       /** @brief Regular channel pending data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATA_POS = INT32_C(8);       /** @brief Regular channel conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATACH_POS = INT32_C(0);     /** @brief Regular channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RPEND_POS = INT32_C(4);       /** @brief Regular channel pending data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATA_POS = INT32_C(8);       /** @brief Regular channel conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATACH_POS = INT32_C(0);     /** @brief Regular channel most recently converted */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RPEND_POS = INT32_C(4);       /** @brief Regular channel pending data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_RDATA_POS = INT32_C(8);       /** @brief Regular channel conversion data */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWH_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog high threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHT_POS = INT32_C(8);        /** @brief Analog watchdog high threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWH_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog high threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHT_POS = INT32_C(8);        /** @brief Analog watchdog high threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWH_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog high threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHT_POS = INT32_C(8);        /** @brief Analog watchdog high threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWH_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog high threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHT_POS = INT32_C(8);        /** @brief Analog watchdog high threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWL_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog low threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLT_POS = INT32_C(8);        /** @brief Analog watchdog low threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWL_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog low threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLT_POS = INT32_C(8);        /** @brief Analog watchdog low threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWL_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog low threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLT_POS = INT32_C(8);        /** @brief Analog watchdog low threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_BKAWL_POS = INT32_C(0);       /** @brief Break signal assignment to analog watchdog low threshold event */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLT_POS = INT32_C(8);        /** @brief Analog watchdog low threshold */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLTF_POS = INT32_C(0);       /** @brief Analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHTF_POS = INT32_C(8);       /** @brief Analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLTF_POS = INT32_C(0);       /** @brief Analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHTF_POS = INT32_C(8);       /** @brief Analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLTF_POS = INT32_C(0);       /** @brief Analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHTF_POS = INT32_C(8);       /** @brief Analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWLTF_POS = INT32_C(0);       /** @brief Analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_AWHTF_POS = INT32_C(8);       /** @brief Analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWLTF_POS = INT32_C(0);    /** @brief Clear the analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWHTF_POS = INT32_C(8);    /** @brief Clear the analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWLTF_POS = INT32_C(0);    /** @brief Clear the analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWHTF_POS = INT32_C(8);    /** @brief Clear the analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWLTF_POS = INT32_C(0);    /** @brief Clear the analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWHTF_POS = INT32_C(8);    /** @brief Clear the analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWLTF_POS = INT32_C(0);    /** @brief Clear the analog watchdog low threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CLRAWHTF_POS = INT32_C(8);    /** @brief Clear the analog watchdog high threshold flag */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAXCH_POS = INT32_C(0);     /** @brief Extremes detector maximum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAX_POS = INT32_C(8);       /** @brief Extremes detector maximum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAXCH_POS = INT32_C(0);     /** @brief Extremes detector maximum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAX_POS = INT32_C(8);       /** @brief Extremes detector maximum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAXCH_POS = INT32_C(0);     /** @brief Extremes detector maximum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAX_POS = INT32_C(8);       /** @brief Extremes detector maximum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAXCH_POS = INT32_C(0);     /** @brief Extremes detector maximum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMAX_POS = INT32_C(8);       /** @brief Extremes detector maximum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMINCH_POS = INT32_C(0);     /** @brief Extremes detector minimum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMIN_POS = INT32_C(8);       /** @brief Extremes detector minimum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMINCH_POS = INT32_C(0);     /** @brief Extremes detector minimum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMIN_POS = INT32_C(8);       /** @brief Extremes detector minimum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMINCH_POS = INT32_C(0);     /** @brief Extremes detector minimum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMIN_POS = INT32_C(8);       /** @brief Extremes detector minimum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMINCH_POS = INT32_C(0);     /** @brief Extremes detector minimum data channel */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_EXMIN_POS = INT32_C(8);       /** @brief Extremes detector minimum value */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_POS = INT32_C(4);      /** @brief 28-bit timer counting conversion time */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_POS = INT32_C(4);      /** @brief 28-bit timer counting conversion time */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_POS = INT32_C(4);      /** @brief 28-bit timer counting conversion time */
    static const int32_t DFSDM_DFSDMX_CNVTIMR_CNVCNT_POS = INT32_C(4);      /** @brief 28-bit timer counting conversion time */

    /**********************************************************************************************
     * @section TIM1X Definitions
     **********************************************************************************************/

    /** @subsection TIM1X IRQ interrupt array definitions */

    static const int32_t TIMX_IRQ[17] = {
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(28),     /** @brief TIM2 global interrupt */
      INT32_C(28),     /** @brief TIM2 global interrupt */
      INT32_C(28),     /** @brief TIM2 global interrupt */
      INT32_C(28),     /** @brief TIM2 global interrupt */
      INT32_C(29),     /** @brief TIM3 global interrupt */
      INT32_C(30),     /** @brief TIM4 global interrupt */
      INT32_C(50),     /** @brief TIM5 global interrupt */
      INT32_C(55),     /** @brief TIM7 global interrupt */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(117),    /** @brief TIM16 global interrupt */
    };

    /** @subsection TIM1X register array definitions */

    static _RW uint32_t* const TIM1X_CR1_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014400),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40014800),   /** @brief Control register 1 */
    };

    static _RW uint32_t* const TIM1X_CR2_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014404),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40014804),   /** @brief Control register 2 */
    };

    static _RW uint32_t* const TIM1X_DIER_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001440C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4001480C),   /** @brief DMA/Interrupt enable register */
    };

    static _RW uint32_t* const TIM1X_SR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014410),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40014810),   /** @brief Status register */
    };

    static _RW uint32_t* const TIM1X_EGR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014414),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40014814),   /** @brief Event generation register */
    };

    static _RW uint32_t* const TIM1X_CCMR1_OUTPUT_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014418),   /** @brief Capture/compare mode register (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40014818),   /** @brief Capture/compare mode register (output mode) */
    };

    static _RW uint32_t* const TIM1X_CCMR1_INPUT_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014418),   /** @brief Capture/compare mode register (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40014818),   /** @brief Capture/compare mode register (output mode) */
    };

    static _RW uint32_t* const TIM1X_CCER_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014420),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x40014820),   /** @brief Capture/compare enable register */
    };

    static _RW uint32_t* const TIM1X_CNT_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014424),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40014824),   /** @brief Counter */
    };

    static _RW uint32_t* const TIM1X_PSC_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014428),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40014828),   /** @brief Prescaler */
    };

    static _RW uint32_t* const TIM1X_ARR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001442C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4001482C),   /** @brief Auto-reload register */
    };

    static _RW uint32_t* const TIM1X_RCR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014430),   /** @brief Repetition counter register */
      (_RW uint32_t* const)UINT32_C(0x40014830),   /** @brief Repetition counter register */
    };

    static _RW uint32_t* const TIM1X_CCR1_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014434),   /** @brief Capture/compare register 1 */
      (_RW uint32_t* const)UINT32_C(0x40014834),   /** @brief Capture/compare register 1 */
    };

    static _RW uint32_t* const TIM1X_BDTR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014444),   /** @brief Break and dead-time register */
      (_RW uint32_t* const)UINT32_C(0x40014844),   /** @brief Break and dead-time register */
    };

    static _RW uint32_t* const TIM1X_DCR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014448),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x40014848),   /** @brief DMA control register */
    };

    static _RW uint32_t* const TIM1X_DMAR_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001444C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x4001484C),   /** @brief DMA address for full transfer */
    };

    static _RW uint32_t* const TIM1X_TIM16_AF1_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014460),   /** @brief TIM16 alternate function register 1 */
      (_RW uint32_t* const)UINT32_C(0x40014860),   /** @brief TIM17 alternate function register 1 */
    };

    static _RW uint32_t* const TIM1X_TIM16_TISEL_REG[8] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40014468),   /** @brief TIM16 input selection register */
      (_RW uint32_t* const)UINT32_C(0x40014868),   /** @brief TIM17 input selection register */
    };

    /** @subsection TIM1X field mask definitions */

    static const uint32_t TIM1X_CR1_CEN_MASK = UINT32_C(0x00000001);               /** @brief Counter enable */
    static const uint32_t TIM1X_CR1_UDIS_MASK = UINT32_C(0x00000002);              /** @brief Update disable */
    static const uint32_t TIM1X_CR1_URS_MASK = UINT32_C(0x00000004);               /** @brief Update request source */
    static const uint32_t TIM1X_CR1_OPM_MASK = UINT32_C(0x00000008);               /** @brief One-pulse mode */
    static const uint32_t TIM1X_CR1_ARPE_MASK = UINT32_C(0x00000080);              /** @brief Auto-reload preload enable */
    static const uint32_t TIM1X_CR1_CKD_MASK = UINT32_C(0x00000300);               /** @brief Clock division */
    static const uint32_t TIM1X_CR1_UIFREMAP_MASK = UINT32_C(0x00000800);          /** @brief UIF status bit remapping */
    static const uint32_t TIM1X_CR2_OIS1N_MASK = UINT32_C(0x00000200);             /** @brief Output idle state 1 */
    static const uint32_t TIM1X_CR2_OIS1_MASK = UINT32_C(0x00000100);              /** @brief Output idle state 1 */
    static const uint32_t TIM1X_CR2_CCDS_MASK = UINT32_C(0x00000008);              /** @brief Capture/compare DMA selection */
    static const uint32_t TIM1X_CR2_CCUS_MASK = UINT32_C(0x00000004);              /** @brief Capture/compare control update selection */
    static const uint32_t TIM1X_CR2_CCPC_MASK = UINT32_C(0x00000001);              /** @brief Capture/compare preloaded control */
    static const uint32_t TIM1X_DIER_UIE_MASK = UINT32_C(0x00000001);              /** @brief Update interrupt enable */
    static const uint32_t TIM1X_DIER_CC1IE_MASK = UINT32_C(0x00000002);            /** @brief Capture/Compare 1 interrupt enable */
    static const uint32_t TIM1X_DIER_COMIE_MASK = UINT32_C(0x00000020);            /** @brief COM interrupt enable */
    static const uint32_t TIM1X_DIER_BIE_MASK = UINT32_C(0x00000080);              /** @brief Break interrupt enable */
    static const uint32_t TIM1X_DIER_UDE_MASK = UINT32_C(0x00000100);              /** @brief Update DMA request enable */
    static const uint32_t TIM1X_DIER_CC1DE_MASK = UINT32_C(0x00000200);            /** @brief Capture/Compare 1 DMA request enable */
    static const uint32_t TIM1X_DIER_COMDE_MASK = UINT32_C(0x00002000);            /** @brief COM DMA request enable */
    static const uint32_t TIM1X_SR_CC1OF_MASK = UINT32_C(0x00000200);              /** @brief Capture/Compare 1 overcapture flag */
    static const uint32_t TIM1X_SR_BIF_MASK = UINT32_C(0x00000080);                /** @brief Break interrupt flag */
    static const uint32_t TIM1X_SR_COMIF_MASK = UINT32_C(0x00000020);              /** @brief COM interrupt flag */
    static const uint32_t TIM1X_SR_CC1IF_MASK = UINT32_C(0x00000002);              /** @brief Capture/compare 1 interrupt flag */
    static const uint32_t TIM1X_SR_UIF_MASK = UINT32_C(0x00000001);                /** @brief Update interrupt flag */
    static const uint32_t TIM1X_EGR_BG_MASK = UINT32_C(0x00000080);                /** @brief Break generation */
    static const uint32_t TIM1X_EGR_COMG_MASK = UINT32_C(0x00000020);              /** @brief Capture/Compare control update generation */
    static const uint32_t TIM1X_EGR_CC1G_MASK = UINT32_C(0x00000002);              /** @brief Capture/compare 1 generation */
    static const uint32_t TIM1X_EGR_UG_MASK = UINT32_C(0x00000001);                /** @brief Update generation */
    static const uint32_t TIM1X_CCMR1_OUTPUT_CC1S_MASK = UINT32_C(0x00000003);     /** @brief Capture/Compare 1 selection */
    static const uint32_t TIM1X_CCMR1_OUTPUT_OC1FE_MASK = UINT32_C(0x00000004);    /** @brief Output compare 1 fast enable */
    static const uint32_t TIM1X_CCMR1_OUTPUT_OC1PE_MASK = UINT32_C(0x00000008);    /** @brief Output compare 1 preload enable */
    static const uint32_t TIM1X_CCMR1_OUTPUT_OC1M_MASK = UINT32_C(0x00000070);     /** @brief Output compare 1 mode */
    static const uint32_t TIM1X_CCMR1_OUTPUT_OC1M_3_MASK = UINT32_C(0x00010000);   /** @brief Output compare 1 mode */
    static const uint32_t TIM1X_CCMR1_INPUT_IC1F_MASK = UINT32_C(0x000000F0);      /** @brief Input capture 1 filter */
    static const uint32_t TIM1X_CCMR1_INPUT_IC1PSC_MASK = UINT32_C(0x0000000C);    /** @brief Input capture 1 prescaler */
    static const uint32_t TIM1X_CCMR1_INPUT_CC1S_MASK = UINT32_C(0x00000003);      /** @brief Capture/Compare 1 selection */
    static const uint32_t TIM1X_CCER_CC1NP_MASK = UINT32_C(0x00000008);            /** @brief Capture/Compare 1 output polarity */
    static const uint32_t TIM1X_CCER_CC1NE_MASK = UINT32_C(0x00000004);            /** @brief Capture/Compare 1 complementary output enable */
    static const uint32_t TIM1X_CCER_CC1P_MASK = UINT32_C(0x00000002);             /** @brief Capture/Compare 1 output polarity */
    static const uint32_t TIM1X_CCER_CC1E_MASK = UINT32_C(0x00000001);             /** @brief Capture/Compare 1 output enable */
    static const uint32_t TIM1X_CNT_CNT_MASK = UINT32_C(0x0000FFFF);               /** @brief Counter value */
    static const uint32_t TIM1X_CNT_UIFCPY_MASK = UINT32_C(0x80000000);            /** @brief UIF copy */
    static const uint32_t TIM1X_PSC_PSC_MASK = UINT32_C(0x0000FFFF);               /** @brief Prescaler value */
    static const uint32_t TIM1X_ARR_ARR_MASK = UINT32_C(0x0000FFFF);               /** @brief Auto-reload value */
    static const uint32_t TIM1X_RCR_REP_MASK = UINT32_C(0x000000FF);               /** @brief Repetition counter value */
    static const uint32_t TIM1X_CCR1_CCR1_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare 1 value */
    static const uint32_t TIM1X_BDTR_DTG_MASK = UINT32_C(0x000000FF);              /** @brief Dead-time generator setup */
    static const uint32_t TIM1X_BDTR_LOCK_MASK = UINT32_C(0x00000300);             /** @brief Lock configuration */
    static const uint32_t TIM1X_BDTR_OSSI_MASK = UINT32_C(0x00000400);             /** @brief Off-state selection for idle mode */
    static const uint32_t TIM1X_BDTR_OSSR_MASK = UINT32_C(0x00000800);             /** @brief Off-state selection for run mode */
    static const uint32_t TIM1X_BDTR_BKE_MASK = UINT32_C(0x00001000);              /** @brief Break enable */
    static const uint32_t TIM1X_BDTR_BKP_MASK = UINT32_C(0x00002000);              /** @brief Break polarity */
    static const uint32_t TIM1X_BDTR_AOE_MASK = UINT32_C(0x00004000);              /** @brief Automatic output enable */
    static const uint32_t TIM1X_BDTR_MOE_MASK = UINT32_C(0x00008000);              /** @brief Main output enable */
    static const uint32_t TIM1X_BDTR_BKF_MASK = UINT32_C(0x000F0000);              /** @brief Break filter */
    static const uint32_t TIM1X_DCR_DBL_MASK = UINT32_C(0x00001F00);               /** @brief DMA burst length */
    static const uint32_t TIM1X_DCR_DBA_MASK = UINT32_C(0x0000001F);               /** @brief DMA base address */
    static const uint32_t TIM1X_DMAR_DMAB_MASK = UINT32_C(0x0000FFFF);             /** @brief DMA register for burst accesses */
    static const uint32_t TIM1X_TIM16_AF1_BKINE_MASK = UINT32_C(0x00000001);       /** @brief BRK BKIN input enable */
    static const uint32_t TIM1X_TIM16_AF1_BKCMP1E_MASK = UINT32_C(0x00000002);     /** @brief BRK COMP1 enable */
    static const uint32_t TIM1X_TIM16_AF1_BKCMP2E_MASK = UINT32_C(0x00000004);     /** @brief BRK COMP2 enable */
    static const uint32_t TIM1X_TIM16_AF1_BKDFBK1E_MASK = UINT32_C(0x00000100);    /** @brief BRK dfsdm1_break[1] enable */
    static const uint32_t TIM1X_TIM16_AF1_BKINP_MASK = UINT32_C(0x00000200);       /** @brief BRK BKIN input polarity */
    static const uint32_t TIM1X_TIM16_AF1_BKCMP1P_MASK = UINT32_C(0x00000400);     /** @brief BRK COMP1 input polarity */
    static const uint32_t TIM1X_TIM16_AF1_BKCMP2P_MASK = UINT32_C(0x00000800);     /** @brief BRK COMP2 input polarity */
    static const uint32_t TIM1X_TIM16_TISEL_TI1SEL_MASK = UINT32_C(0x0000000F);    /** @brief Selects TI1[0] to TI1[15] input */

    /** @subsection TIM1X field position definitions */

    static const int32_t TIM1X_TIM16_TISEL_CEN_POS = INT32_C(0);         /** @brief Counter enable */
    static const int32_t TIM1X_TIM16_TISEL_UDIS_POS = INT32_C(1);        /** @brief Update disable */
    static const int32_t TIM1X_TIM16_TISEL_URS_POS = INT32_C(2);         /** @brief Update request source */
    static const int32_t TIM1X_TIM16_TISEL_OPM_POS = INT32_C(3);         /** @brief One-pulse mode */
    static const int32_t TIM1X_TIM16_TISEL_ARPE_POS = INT32_C(7);        /** @brief Auto-reload preload enable */
    static const int32_t TIM1X_TIM16_TISEL_CKD_POS = INT32_C(8);         /** @brief Clock division */
    static const int32_t TIM1X_TIM16_TISEL_UIFREMAP_POS = INT32_C(11);   /** @brief UIF status bit remapping */
    static const int32_t TIM1X_TIM16_TISEL_OIS1N_POS = INT32_C(9);       /** @brief Output idle state 1 */
    static const int32_t TIM1X_TIM16_TISEL_OIS1_POS = INT32_C(8);        /** @brief Output idle state 1 */
    static const int32_t TIM1X_TIM16_TISEL_CCDS_POS = INT32_C(3);        /** @brief Capture/compare DMA selection */
    static const int32_t TIM1X_TIM16_TISEL_CCUS_POS = INT32_C(2);        /** @brief Capture/compare control update selection */
    static const int32_t TIM1X_TIM16_TISEL_CCPC_POS = INT32_C(0);        /** @brief Capture/compare preloaded control */
    static const int32_t TIM1X_TIM16_TISEL_UIE_POS = INT32_C(0);         /** @brief Update interrupt enable */
    static const int32_t TIM1X_TIM16_TISEL_CC1IE_POS = INT32_C(1);       /** @brief Capture/Compare 1 interrupt enable */
    static const int32_t TIM1X_TIM16_TISEL_COMIE_POS = INT32_C(5);       /** @brief COM interrupt enable */
    static const int32_t TIM1X_TIM16_TISEL_BIE_POS = INT32_C(7);         /** @brief Break interrupt enable */
    static const int32_t TIM1X_TIM16_TISEL_UDE_POS = INT32_C(8);         /** @brief Update DMA request enable */
    static const int32_t TIM1X_TIM16_TISEL_CC1DE_POS = INT32_C(9);       /** @brief Capture/Compare 1 DMA request enable */
    static const int32_t TIM1X_TIM16_TISEL_COMDE_POS = INT32_C(13);      /** @brief COM DMA request enable */
    static const int32_t TIM1X_TIM16_TISEL_CC1OF_POS = INT32_C(9);       /** @brief Capture/Compare 1 overcapture flag */
    static const int32_t TIM1X_TIM16_TISEL_BIF_POS = INT32_C(7);         /** @brief Break interrupt flag */
    static const int32_t TIM1X_TIM16_TISEL_COMIF_POS = INT32_C(5);       /** @brief COM interrupt flag */
    static const int32_t TIM1X_TIM16_TISEL_CC1IF_POS = INT32_C(1);       /** @brief Capture/compare 1 interrupt flag */
    static const int32_t TIM1X_TIM16_TISEL_UIF_POS = INT32_C(0);         /** @brief Update interrupt flag */
    static const int32_t TIM1X_TIM16_TISEL_BG_POS = INT32_C(7);          /** @brief Break generation */
    static const int32_t TIM1X_TIM16_TISEL_COMG_POS = INT32_C(5);        /** @brief Capture/Compare control update generation */
    static const int32_t TIM1X_TIM16_TISEL_CC1G_POS = INT32_C(1);        /** @brief Capture/compare 1 generation */
    static const int32_t TIM1X_TIM16_TISEL_UG_POS = INT32_C(0);          /** @brief Update generation */
    static const int32_t TIM1X_TIM16_TISEL_CC1S_POS = INT32_C(0);        /** @brief Capture/Compare 1 selection */
    static const int32_t TIM1X_TIM16_TISEL_OC1FE_POS = INT32_C(2);       /** @brief Output compare 1 fast enable */
    static const int32_t TIM1X_TIM16_TISEL_OC1PE_POS = INT32_C(3);       /** @brief Output compare 1 preload enable */
    static const int32_t TIM1X_TIM16_TISEL_OC1M_POS = INT32_C(4);        /** @brief Output compare 1 mode */
    static const int32_t TIM1X_TIM16_TISEL_OC1M_3_POS = INT32_C(16);     /** @brief Output compare 1 mode */
    static const int32_t TIM1X_TIM16_TISEL_IC1F_POS = INT32_C(4);        /** @brief Input capture 1 filter */
    static const int32_t TIM1X_TIM16_TISEL_IC1PSC_POS = INT32_C(2);      /** @brief Input capture 1 prescaler */
    static const int32_t TIM1X_TIM16_TISEL_CC1S_POS = INT32_C(0);        /** @brief Capture/Compare 1 selection */
    static const int32_t TIM1X_TIM16_TISEL_CC1NP_POS = INT32_C(3);       /** @brief Capture/Compare 1 output polarity */
    static const int32_t TIM1X_TIM16_TISEL_CC1NE_POS = INT32_C(2);       /** @brief Capture/Compare 1 complementary output enable */
    static const int32_t TIM1X_TIM16_TISEL_CC1P_POS = INT32_C(1);        /** @brief Capture/Compare 1 output polarity */
    static const int32_t TIM1X_TIM16_TISEL_CC1E_POS = INT32_C(0);        /** @brief Capture/Compare 1 output enable */
    static const int32_t TIM1X_TIM16_TISEL_CNT_POS = INT32_C(0);         /** @brief Counter value */
    static const int32_t TIM1X_TIM16_TISEL_UIFCPY_POS = INT32_C(31);     /** @brief UIF copy */
    static const int32_t TIM1X_TIM16_TISEL_PSC_POS = INT32_C(0);         /** @brief Prescaler value */
    static const int32_t TIM1X_TIM16_TISEL_ARR_POS = INT32_C(0);         /** @brief Auto-reload value */
    static const int32_t TIM1X_TIM16_TISEL_REP_POS = INT32_C(0);         /** @brief Repetition counter value */
    static const int32_t TIM1X_TIM16_TISEL_CCR1_POS = INT32_C(0);        /** @brief Capture/Compare 1 value */
    static const int32_t TIM1X_TIM16_TISEL_DTG_POS = INT32_C(0);         /** @brief Dead-time generator setup */
    static const int32_t TIM1X_TIM16_TISEL_LOCK_POS = INT32_C(8);        /** @brief Lock configuration */
    static const int32_t TIM1X_TIM16_TISEL_OSSI_POS = INT32_C(10);       /** @brief Off-state selection for idle mode */
    static const int32_t TIM1X_TIM16_TISEL_OSSR_POS = INT32_C(11);       /** @brief Off-state selection for run mode */
    static const int32_t TIM1X_TIM16_TISEL_BKE_POS = INT32_C(12);        /** @brief Break enable */
    static const int32_t TIM1X_TIM16_TISEL_BKP_POS = INT32_C(13);        /** @brief Break polarity */
    static const int32_t TIM1X_TIM16_TISEL_AOE_POS = INT32_C(14);        /** @brief Automatic output enable */
    static const int32_t TIM1X_TIM16_TISEL_MOE_POS = INT32_C(15);        /** @brief Main output enable */
    static const int32_t TIM1X_TIM16_TISEL_BKF_POS = INT32_C(16);        /** @brief Break filter */
    static const int32_t TIM1X_TIM16_TISEL_DBL_POS = INT32_C(8);         /** @brief DMA burst length */
    static const int32_t TIM1X_TIM16_TISEL_DBA_POS = INT32_C(0);         /** @brief DMA base address */
    static const int32_t TIM1X_TIM16_TISEL_DMAB_POS = INT32_C(0);        /** @brief DMA register for burst accesses */
    static const int32_t TIM1X_TIM16_TISEL_BKINE_POS = INT32_C(0);       /** @brief BRK BKIN input enable */
    static const int32_t TIM1X_TIM16_TISEL_BKCMP1E_POS = INT32_C(1);     /** @brief BRK COMP1 enable */
    static const int32_t TIM1X_TIM16_TISEL_BKCMP2E_POS = INT32_C(2);     /** @brief BRK COMP2 enable */
    static const int32_t TIM1X_TIM16_TISEL_BKDFBK1E_POS = INT32_C(8);    /** @brief BRK dfsdm1_break[1] enable */
    static const int32_t TIM1X_TIM16_TISEL_BKINP_POS = INT32_C(9);       /** @brief BRK BKIN input polarity */
    static const int32_t TIM1X_TIM16_TISEL_BKCMP1P_POS = INT32_C(10);    /** @brief BRK COMP1 input polarity */
    static const int32_t TIM1X_TIM16_TISEL_BKCMP2P_POS = INT32_C(11);    /** @brief BRK COMP2 input polarity */
    static const int32_t TIM1X_TIM16_TISEL_TI1SEL_POS = INT32_C(0);      /** @brief Selects TI1[0] to TI1[15] input */

    /**********************************************************************************************
     * @section TIM15 Definitions
     **********************************************************************************************/

    /** @subsection TIM15 IRQ interrupt array definitions */

    static const int32_t TIM1X_IRQ[8] = {
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(116),    /** @brief TIM15 global interrupt */
      INT32_C(-1),     /** @brief Invalid index. */
      INT32_C(118),    /** @brief TIM17 global interrupt */
    };

    /** @subsection TIM15 register definitions */

    static _RW uint32_t* const TIM15_CR1_REG = (_RW uint32_t* const)UINT32_C(0x40014000);            /** @brief Control register 1 */
    static _RW uint32_t* const TIM15_CR2_REG = (_RW uint32_t* const)UINT32_C(0x40014004);            /** @brief Control register 2 */
    static _RW uint32_t* const TIM15_SMCR_REG = (_RW uint32_t* const)UINT32_C(0x40014008);           /** @brief Slave mode control register */
    static _RW uint32_t* const TIM15_DIER_REG = (_RW uint32_t* const)UINT32_C(0x4001400C);           /** @brief DMA/Interrupt enable register */
    static _RW uint32_t* const TIM15_SR_REG = (_RW uint32_t* const)UINT32_C(0x40014010);             /** @brief Status register */
    static _RW uint32_t* const TIM15_EGR_REG = (_RW uint32_t* const)UINT32_C(0x40014014);            /** @brief Event generation register */
    static _RW uint32_t* const TIM15_CCMR1_OUTPUT_REG = (_RW uint32_t* const)UINT32_C(0x40014018);   /** @brief Capture/compare mode register (output mode) */
    static _RW uint32_t* const TIM15_CCMR1_INPUT_REG = (_RW uint32_t* const)UINT32_C(0x40014018);    /** @brief Capture/compare mode register 1 (input mode) */
    static _RW uint32_t* const TIM15_CCER_REG = (_RW uint32_t* const)UINT32_C(0x40014020);           /** @brief Capture/compare enable register */
    static _RW uint32_t* const TIM15_CNT_REG = (_RW uint32_t* const)UINT32_C(0x40014024);            /** @brief Counter */
    static _RW uint32_t* const TIM15_PSC_REG = (_RW uint32_t* const)UINT32_C(0x40014028);            /** @brief Prescaler */
    static _RW uint32_t* const TIM15_ARR_REG = (_RW uint32_t* const)UINT32_C(0x4001402C);            /** @brief Auto-reload register */
    static _RW uint32_t* const TIM15_RCR_REG = (_RW uint32_t* const)UINT32_C(0x40014030);            /** @brief Repetition counter register */
    static _RW uint32_t* const TIM15_CCR1_REG = (_RW uint32_t* const)UINT32_C(0x40014034);           /** @brief Capture/compare register 1 */
    static _RW uint32_t* const TIM15_CCR2_REG = (_RW uint32_t* const)UINT32_C(0x40014038);           /** @brief Capture/compare register 2 */
    static _RW uint32_t* const TIM15_BDTR_REG = (_RW uint32_t* const)UINT32_C(0x40014044);           /** @brief Break and dead-time register */
    static _RW uint32_t* const TIM15_DCR_REG = (_RW uint32_t* const)UINT32_C(0x40014048);            /** @brief DMA control register */
    static _RW uint32_t* const TIM15_DMAR_REG = (_RW uint32_t* const)UINT32_C(0x4001404C);           /** @brief DMA address for full transfer */
    static _RW uint32_t* const TIM15_AF1_REG = (_RW uint32_t* const)UINT32_C(0x40014060);            /** @brief TIM15 alternate fdfsdm1_breakon register 1 */
    static _RW uint32_t* const TIM15_TISEL_REG = (_RW uint32_t* const)UINT32_C(0x40014068);          /** @brief TIM15 input selection register */

    /** @subsection TIM15 field mask definitions */

    static const uint32_t TIM15_CR1_CEN_MASK = UINT32_C(0x00000001);               /** @brief Counter enable */
    static const uint32_t TIM15_CR1_UDIS_MASK = UINT32_C(0x00000002);              /** @brief Update disable */
    static const uint32_t TIM15_CR1_URS_MASK = UINT32_C(0x00000004);               /** @brief Update request source */
    static const uint32_t TIM15_CR1_OPM_MASK = UINT32_C(0x00000008);               /** @brief One-pulse mode */
    static const uint32_t TIM15_CR1_ARPE_MASK = UINT32_C(0x00000080);              /** @brief Auto-reload preload enable */
    static const uint32_t TIM15_CR1_CKD_MASK = UINT32_C(0x00000300);               /** @brief Clock division */
    static const uint32_t TIM15_CR1_UIFREMAP_MASK = UINT32_C(0x00000800);          /** @brief UIF status bit remapping */
    static const uint32_t TIM15_CR2_CCPC_MASK = UINT32_C(0x00000001);              /** @brief Capture/compare preloaded control */
    static const uint32_t TIM15_CR2_CCUS_MASK = UINT32_C(0x00000004);              /** @brief Capture/compare control update selection */
    static const uint32_t TIM15_CR2_CCDS_MASK = UINT32_C(0x00000008);              /** @brief Capture/compare DMA selection */
    static const uint32_t TIM15_CR2_MMS_MASK = UINT32_C(0x00000070);               /** @brief Master mode selection */
    static const uint32_t TIM15_CR2_TI1S_MASK = UINT32_C(0x00000080);              /** @brief TI1 selection */
    static const uint32_t TIM15_CR2_OIS1_MASK = UINT32_C(0x00000100);              /** @brief Output idle state 1 */
    static const uint32_t TIM15_CR2_OIS1N_MASK = UINT32_C(0x00000200);             /** @brief Output idle state 1 */
    static const uint32_t TIM15_CR2_OIS2_MASK = UINT32_C(0x00000400);              /** @brief Output idle state 2 */
    static const uint32_t TIM15_SMCR_SMS_MASK = UINT32_C(0x00000007);              /** @brief Slave mode selection */
    static const uint32_t TIM15_SMCR_TS_2_0_MASK = UINT32_C(0x00000070);           /** @brief Trigger selection */
    static const uint32_t TIM15_SMCR_MSM_MASK = UINT32_C(0x00000080);              /** @brief Master/Slave mode */
    static const uint32_t TIM15_SMCR_SMS_3_MASK = UINT32_C(0x00010000);            /** @brief Slave mode selection bit 3 */
    static const uint32_t TIM15_SMCR_TS_4_3_MASK = UINT32_C(0x00300000);           /** @brief Trigger selection - bit 4:3 */
    static const uint32_t TIM15_DIER_UIE_MASK = UINT32_C(0x00000001);              /** @brief Update interrupt enable */
    static const uint32_t TIM15_DIER_CC1IE_MASK = UINT32_C(0x00000002);            /** @brief Capture/Compare 1 interrupt enable */
    static const uint32_t TIM15_DIER_CC2IE_MASK = UINT32_C(0x00000004);            /** @brief Capture/Compare 2 interrupt enable */
    static const uint32_t TIM15_DIER_COMIE_MASK = UINT32_C(0x00000020);            /** @brief COM interrupt enable */
    static const uint32_t TIM15_DIER_TIE_MASK = UINT32_C(0x00000040);              /** @brief Trigger interrupt enable */
    static const uint32_t TIM15_DIER_BIE_MASK = UINT32_C(0x00000080);              /** @brief Break interrupt enable */
    static const uint32_t TIM15_DIER_UDE_MASK = UINT32_C(0x00000100);              /** @brief Update DMA request enable */
    static const uint32_t TIM15_DIER_CC1DE_MASK = UINT32_C(0x00000200);            /** @brief Capture/Compare 1 DMA request enable */
    static const uint32_t TIM15_DIER_CC2DE_MASK = UINT32_C(0x00000400);            /** @brief Capture/Compare 2 DMA request enable */
    static const uint32_t TIM15_DIER_COMDE_MASK = UINT32_C(0x00002000);            /** @brief COM DMA request enable */
    static const uint32_t TIM15_DIER_TDE_MASK = UINT32_C(0x00004000);              /** @brief Trigger DMA request enable */
    static const uint32_t TIM15_SR_CC2OF_MASK = UINT32_C(0x00000400);              /** @brief Capture/compare 2 overcapture flag */
    static const uint32_t TIM15_SR_CC1OF_MASK = UINT32_C(0x00000200);              /** @brief Capture/Compare 1 overcapture flag */
    static const uint32_t TIM15_SR_BIF_MASK = UINT32_C(0x00000080);                /** @brief Break interrupt flag */
    static const uint32_t TIM15_SR_TIF_MASK = UINT32_C(0x00000040);                /** @brief Trigger interrupt flag */
    static const uint32_t TIM15_SR_COMIF_MASK = UINT32_C(0x00000020);              /** @brief COM interrupt flag */
    static const uint32_t TIM15_SR_CC2IF_MASK = UINT32_C(0x00000004);              /** @brief Capture/Compare 2 interrupt flag */
    static const uint32_t TIM15_SR_CC1IF_MASK = UINT32_C(0x00000002);              /** @brief Capture/compare 1 interrupt flag */
    static const uint32_t TIM15_SR_UIF_MASK = UINT32_C(0x00000001);                /** @brief Update interrupt flag */
    static const uint32_t TIM15_EGR_BG_MASK = UINT32_C(0x00000080);                /** @brief Break generation */
    static const uint32_t TIM15_EGR_TG_MASK = UINT32_C(0x00000040);                /** @brief Trigger generation */
    static const uint32_t TIM15_EGR_COMG_MASK = UINT32_C(0x00000020);              /** @brief Capture/Compare control update generation */
    static const uint32_t TIM15_EGR_CC2G_MASK = UINT32_C(0x00000004);              /** @brief Capture/compare 2 generation */
    static const uint32_t TIM15_EGR_CC1G_MASK = UINT32_C(0x00000002);              /** @brief Capture/compare 1 generation */
    static const uint32_t TIM15_EGR_UG_MASK = UINT32_C(0x00000001);                /** @brief Update generation */
    static const uint32_t TIM15_CCMR1_OUTPUT_CC1S_MASK = UINT32_C(0x00000003);     /** @brief Capture/Compare 1 selection */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC1FE_MASK = UINT32_C(0x00000004);    /** @brief Output compare 1 fast enable */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC1PE_MASK = UINT32_C(0x00000008);    /** @brief Output compare 1 preload enable */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC1M_MASK = UINT32_C(0x00000070);     /** @brief Output compare 1 mode */
    static const uint32_t TIM15_CCMR1_OUTPUT_CC2S_MASK = UINT32_C(0x00000300);     /** @brief Capture/Compare 2 selection */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC2FE_MASK = UINT32_C(0x00000400);    /** @brief Output compare 2 fast enable */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC2PE_MASK = UINT32_C(0x00000800);    /** @brief Output compare 2 preload enable */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC2M_MASK = UINT32_C(0x00007000);     /** @brief Output compare 2 mode */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC1M_3_MASK = UINT32_C(0x00010000);   /** @brief Output compare 1 mode bit 3 */
    static const uint32_t TIM15_CCMR1_OUTPUT_OC2M_3_MASK = UINT32_C(0x01000000);   /** @brief Output compare 2 mode bit 3 */
    static const uint32_t TIM15_CCMR1_INPUT_IC2F_MASK = UINT32_C(0x0000F000);      /** @brief Input capture 2 filter */
    static const uint32_t TIM15_CCMR1_INPUT_IC2PSC_MASK = UINT32_C(0x00000C00);    /** @brief Input capture 2 prescaler */
    static const uint32_t TIM15_CCMR1_INPUT_CC2S_MASK = UINT32_C(0x00000300);      /** @brief Capture/Compare 2 selection */
    static const uint32_t TIM15_CCMR1_INPUT_IC1F_MASK = UINT32_C(0x000000F0);      /** @brief Input capture 1 filter */
    static const uint32_t TIM15_CCMR1_INPUT_IC1PSC_MASK = UINT32_C(0x0000000C);    /** @brief Input capture 1 prescaler */
    static const uint32_t TIM15_CCMR1_INPUT_CC1S_MASK = UINT32_C(0x00000003);      /** @brief Capture/Compare 1 selection */
    static const uint32_t TIM15_CCER_CC2NP_MASK = UINT32_C(0x00000080);            /** @brief Capture/Compare 2 output polarity */
    static const uint32_t TIM15_CCER_CC2P_MASK = UINT32_C(0x00000020);             /** @brief Capture/Compare 2 output polarity */
    static const uint32_t TIM15_CCER_CC2E_MASK = UINT32_C(0x00000010);             /** @brief Capture/Compare 2 output enable */
    static const uint32_t TIM15_CCER_CC1NP_MASK = UINT32_C(0x00000008);            /** @brief Capture/Compare 1 output polarity */
    static const uint32_t TIM15_CCER_CC1NE_MASK = UINT32_C(0x00000004);            /** @brief Capture/Compare 1 complementary output enable */
    static const uint32_t TIM15_CCER_CC1P_MASK = UINT32_C(0x00000002);             /** @brief Capture/Compare 1 output polarity */
    static const uint32_t TIM15_CCER_CC1E_MASK = UINT32_C(0x00000001);             /** @brief Capture/Compare 1 output enable */
    static const uint32_t TIM15_CNT_CNT_MASK = UINT32_C(0x0000FFFF);               /** @brief Counter value */
    static const uint32_t TIM15_CNT_UIFCPY_MASK = UINT32_C(0x80000000);            /** @brief UIF copy */
    static const uint32_t TIM15_PSC_PSC_MASK = UINT32_C(0x0000FFFF);               /** @brief Prescaler value */
    static const uint32_t TIM15_ARR_ARR_MASK = UINT32_C(0x0000FFFF);               /** @brief Auto-reload value */
    static const uint32_t TIM15_RCR_REP_MASK = UINT32_C(0x000000FF);               /** @brief Repetition counter value */
    static const uint32_t TIM15_CCR1_CCR1_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare 1 value */
    static const uint32_t TIM15_CCR2_CCR2_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare 2 value */
    static const uint32_t TIM15_BDTR_MOE_MASK = UINT32_C(0x00008000);              /** @brief Main output enable */
    static const uint32_t TIM15_BDTR_AOE_MASK = UINT32_C(0x00004000);              /** @brief Automatic output enable */
    static const uint32_t TIM15_BDTR_BKP_MASK = UINT32_C(0x00002000);              /** @brief Break polarity */
    static const uint32_t TIM15_BDTR_BKE_MASK = UINT32_C(0x00001000);              /** @brief Break enable */
    static const uint32_t TIM15_BDTR_OSSR_MASK = UINT32_C(0x00000800);             /** @brief Off-state selection for run mode */
    static const uint32_t TIM15_BDTR_OSSI_MASK = UINT32_C(0x00000400);             /** @brief Off-state selection for idle mode */
    static const uint32_t TIM15_BDTR_LOCK_MASK = UINT32_C(0x00000300);             /** @brief Lock configuration */
    static const uint32_t TIM15_BDTR_DTG_MASK = UINT32_C(0x000000FF);              /** @brief Dead-time generator setup */
    static const uint32_t TIM15_BDTR_BKF_MASK = UINT32_C(0x000F0000);              /** @brief Break filter */
    static const uint32_t TIM15_DCR_DBL_MASK = UINT32_C(0x00001F00);               /** @brief DMA burst length */
    static const uint32_t TIM15_DCR_DBA_MASK = UINT32_C(0x0000001F);               /** @brief DMA base address */
    static const uint32_t TIM15_DMAR_DMAB_MASK = UINT32_C(0x0000FFFF);             /** @brief DMA register for burst accesses */
    static const uint32_t TIM15_AF1_BKINE_MASK = UINT32_C(0x00000001);             /** @brief BRK BKIN input enable */
    static const uint32_t TIM15_AF1_BKCMP1E_MASK = UINT32_C(0x00000002);           /** @brief BRK COMP1 enable */
    static const uint32_t TIM15_AF1_BKCMP2E_MASK = UINT32_C(0x00000004);           /** @brief BRK COMP2 enable */
    static const uint32_t TIM15_AF1_BKDF1BK0E_MASK = UINT32_C(0x00000100);         /** @brief BRK dfsdm1_break[0] enable */
    static const uint32_t TIM15_AF1_BKINP_MASK = UINT32_C(0x00000200);             /** @brief BRK BKIN input polarity */
    static const uint32_t TIM15_AF1_BKCMP1P_MASK = UINT32_C(0x00000400);           /** @brief BRK COMP1 input polarity */
    static const uint32_t TIM15_AF1_BKCMP2P_MASK = UINT32_C(0x00000800);           /** @brief BRK COMP2 input polarity */
    static const uint32_t TIM15_TISEL_TI1SEL_MASK = UINT32_C(0x0000000F);          /** @brief Selects TI1[0] to TI1[15] input */
    static const uint32_t TIM15_TISEL_TI2SEL_MASK = UINT32_C(0x00000F00);          /** @brief Selects TI2[0] to TI2[15] input */

    /** @subsection TIM15 field position definitions */

    static const int32_t TIM15_TISEL_CEN_POS = INT32_C(0);          /** @brief Counter enable */
    static const int32_t TIM15_TISEL_UDIS_POS = INT32_C(1);         /** @brief Update disable */
    static const int32_t TIM15_TISEL_URS_POS = INT32_C(2);          /** @brief Update request source */
    static const int32_t TIM15_TISEL_OPM_POS = INT32_C(3);          /** @brief One-pulse mode */
    static const int32_t TIM15_TISEL_ARPE_POS = INT32_C(7);         /** @brief Auto-reload preload enable */
    static const int32_t TIM15_TISEL_CKD_POS = INT32_C(8);          /** @brief Clock division */
    static const int32_t TIM15_TISEL_UIFREMAP_POS = INT32_C(11);    /** @brief UIF status bit remapping */
    static const int32_t TIM15_TISEL_CCPC_POS = INT32_C(0);         /** @brief Capture/compare preloaded control */
    static const int32_t TIM15_TISEL_CCUS_POS = INT32_C(2);         /** @brief Capture/compare control update selection */
    static const int32_t TIM15_TISEL_CCDS_POS = INT32_C(3);         /** @brief Capture/compare DMA selection */
    static const int32_t TIM15_TISEL_MMS_POS = INT32_C(4);          /** @brief Master mode selection */
    static const int32_t TIM15_TISEL_TI1S_POS = INT32_C(7);         /** @brief TI1 selection */
    static const int32_t TIM15_TISEL_OIS1_POS = INT32_C(8);         /** @brief Output idle state 1 */
    static const int32_t TIM15_TISEL_OIS1N_POS = INT32_C(9);        /** @brief Output idle state 1 */
    static const int32_t TIM15_TISEL_OIS2_POS = INT32_C(10);        /** @brief Output idle state 2 */
    static const int32_t TIM15_TISEL_SMS_POS = INT32_C(0);          /** @brief Slave mode selection */
    static const int32_t TIM15_TISEL_TS_2_0_POS = INT32_C(4);       /** @brief Trigger selection */
    static const int32_t TIM15_TISEL_MSM_POS = INT32_C(7);          /** @brief Master/Slave mode */
    static const int32_t TIM15_TISEL_SMS_3_POS = INT32_C(16);       /** @brief Slave mode selection bit 3 */
    static const int32_t TIM15_TISEL_TS_4_3_POS = INT32_C(20);      /** @brief Trigger selection - bit 4:3 */
    static const int32_t TIM15_TISEL_UIE_POS = INT32_C(0);          /** @brief Update interrupt enable */
    static const int32_t TIM15_TISEL_CC1IE_POS = INT32_C(1);        /** @brief Capture/Compare 1 interrupt enable */
    static const int32_t TIM15_TISEL_CC2IE_POS = INT32_C(2);        /** @brief Capture/Compare 2 interrupt enable */
    static const int32_t TIM15_TISEL_COMIE_POS = INT32_C(5);        /** @brief COM interrupt enable */
    static const int32_t TIM15_TISEL_TIE_POS = INT32_C(6);          /** @brief Trigger interrupt enable */
    static const int32_t TIM15_TISEL_BIE_POS = INT32_C(7);          /** @brief Break interrupt enable */
    static const int32_t TIM15_TISEL_UDE_POS = INT32_C(8);          /** @brief Update DMA request enable */
    static const int32_t TIM15_TISEL_CC1DE_POS = INT32_C(9);        /** @brief Capture/Compare 1 DMA request enable */
    static const int32_t TIM15_TISEL_CC2DE_POS = INT32_C(10);       /** @brief Capture/Compare 2 DMA request enable */
    static const int32_t TIM15_TISEL_COMDE_POS = INT32_C(13);       /** @brief COM DMA request enable */
    static const int32_t TIM15_TISEL_TDE_POS = INT32_C(14);         /** @brief Trigger DMA request enable */
    static const int32_t TIM15_TISEL_CC2OF_POS = INT32_C(10);       /** @brief Capture/compare 2 overcapture flag */
    static const int32_t TIM15_TISEL_CC1OF_POS = INT32_C(9);        /** @brief Capture/Compare 1 overcapture flag */
    static const int32_t TIM15_TISEL_BIF_POS = INT32_C(7);          /** @brief Break interrupt flag */
    static const int32_t TIM15_TISEL_TIF_POS = INT32_C(6);          /** @brief Trigger interrupt flag */
    static const int32_t TIM15_TISEL_COMIF_POS = INT32_C(5);        /** @brief COM interrupt flag */
    static const int32_t TIM15_TISEL_CC2IF_POS = INT32_C(2);        /** @brief Capture/Compare 2 interrupt flag */
    static const int32_t TIM15_TISEL_CC1IF_POS = INT32_C(1);        /** @brief Capture/compare 1 interrupt flag */
    static const int32_t TIM15_TISEL_UIF_POS = INT32_C(0);          /** @brief Update interrupt flag */
    static const int32_t TIM15_TISEL_BG_POS = INT32_C(7);           /** @brief Break generation */
    static const int32_t TIM15_TISEL_TG_POS = INT32_C(6);           /** @brief Trigger generation */
    static const int32_t TIM15_TISEL_COMG_POS = INT32_C(5);         /** @brief Capture/Compare control update generation */
    static const int32_t TIM15_TISEL_CC2G_POS = INT32_C(2);         /** @brief Capture/compare 2 generation */
    static const int32_t TIM15_TISEL_CC1G_POS = INT32_C(1);         /** @brief Capture/compare 1 generation */
    static const int32_t TIM15_TISEL_UG_POS = INT32_C(0);           /** @brief Update generation */
    static const int32_t TIM15_TISEL_CC1S_POS = INT32_C(0);         /** @brief Capture/Compare 1 selection */
    static const int32_t TIM15_TISEL_OC1FE_POS = INT32_C(2);        /** @brief Output compare 1 fast enable */
    static const int32_t TIM15_TISEL_OC1PE_POS = INT32_C(3);        /** @brief Output compare 1 preload enable */
    static const int32_t TIM15_TISEL_OC1M_POS = INT32_C(4);         /** @brief Output compare 1 mode */
    static const int32_t TIM15_TISEL_CC2S_POS = INT32_C(8);         /** @brief Capture/Compare 2 selection */
    static const int32_t TIM15_TISEL_OC2FE_POS = INT32_C(10);       /** @brief Output compare 2 fast enable */
    static const int32_t TIM15_TISEL_OC2PE_POS = INT32_C(11);       /** @brief Output compare 2 preload enable */
    static const int32_t TIM15_TISEL_OC2M_POS = INT32_C(12);        /** @brief Output compare 2 mode */
    static const int32_t TIM15_TISEL_OC1M_3_POS = INT32_C(16);      /** @brief Output compare 1 mode bit 3 */
    static const int32_t TIM15_TISEL_OC2M_3_POS = INT32_C(24);      /** @brief Output compare 2 mode bit 3 */
    static const int32_t TIM15_TISEL_IC2F_POS = INT32_C(12);        /** @brief Input capture 2 filter */
    static const int32_t TIM15_TISEL_IC2PSC_POS = INT32_C(10);      /** @brief Input capture 2 prescaler */
    static const int32_t TIM15_TISEL_CC2S_POS = INT32_C(8);         /** @brief Capture/Compare 2 selection */
    static const int32_t TIM15_TISEL_IC1F_POS = INT32_C(4);         /** @brief Input capture 1 filter */
    static const int32_t TIM15_TISEL_IC1PSC_POS = INT32_C(2);       /** @brief Input capture 1 prescaler */
    static const int32_t TIM15_TISEL_CC1S_POS = INT32_C(0);         /** @brief Capture/Compare 1 selection */
    static const int32_t TIM15_TISEL_CC2NP_POS = INT32_C(7);        /** @brief Capture/Compare 2 output polarity */
    static const int32_t TIM15_TISEL_CC2P_POS = INT32_C(5);         /** @brief Capture/Compare 2 output polarity */
    static const int32_t TIM15_TISEL_CC2E_POS = INT32_C(4);         /** @brief Capture/Compare 2 output enable */
    static const int32_t TIM15_TISEL_CC1NP_POS = INT32_C(3);        /** @brief Capture/Compare 1 output polarity */
    static const int32_t TIM15_TISEL_CC1NE_POS = INT32_C(2);        /** @brief Capture/Compare 1 complementary output enable */
    static const int32_t TIM15_TISEL_CC1P_POS = INT32_C(1);         /** @brief Capture/Compare 1 output polarity */
    static const int32_t TIM15_TISEL_CC1E_POS = INT32_C(0);         /** @brief Capture/Compare 1 output enable */
    static const int32_t TIM15_TISEL_CNT_POS = INT32_C(0);          /** @brief Counter value */
    static const int32_t TIM15_TISEL_UIFCPY_POS = INT32_C(31);      /** @brief UIF copy */
    static const int32_t TIM15_TISEL_PSC_POS = INT32_C(0);          /** @brief Prescaler value */
    static const int32_t TIM15_TISEL_ARR_POS = INT32_C(0);          /** @brief Auto-reload value */
    static const int32_t TIM15_TISEL_REP_POS = INT32_C(0);          /** @brief Repetition counter value */
    static const int32_t TIM15_TISEL_CCR1_POS = INT32_C(0);         /** @brief Capture/Compare 1 value */
    static const int32_t TIM15_TISEL_CCR2_POS = INT32_C(0);         /** @brief Capture/Compare 2 value */
    static const int32_t TIM15_TISEL_MOE_POS = INT32_C(15);         /** @brief Main output enable */
    static const int32_t TIM15_TISEL_AOE_POS = INT32_C(14);         /** @brief Automatic output enable */
    static const int32_t TIM15_TISEL_BKP_POS = INT32_C(13);         /** @brief Break polarity */
    static const int32_t TIM15_TISEL_BKE_POS = INT32_C(12);         /** @brief Break enable */
    static const int32_t TIM15_TISEL_OSSR_POS = INT32_C(11);        /** @brief Off-state selection for run mode */
    static const int32_t TIM15_TISEL_OSSI_POS = INT32_C(10);        /** @brief Off-state selection for idle mode */
    static const int32_t TIM15_TISEL_LOCK_POS = INT32_C(8);         /** @brief Lock configuration */
    static const int32_t TIM15_TISEL_DTG_POS = INT32_C(0);          /** @brief Dead-time generator setup */
    static const int32_t TIM15_TISEL_BKF_POS = INT32_C(16);         /** @brief Break filter */
    static const int32_t TIM15_TISEL_DBL_POS = INT32_C(8);          /** @brief DMA burst length */
    static const int32_t TIM15_TISEL_DBA_POS = INT32_C(0);          /** @brief DMA base address */
    static const int32_t TIM15_TISEL_DMAB_POS = INT32_C(0);         /** @brief DMA register for burst accesses */
    static const int32_t TIM15_TISEL_BKINE_POS = INT32_C(0);        /** @brief BRK BKIN input enable */
    static const int32_t TIM15_TISEL_BKCMP1E_POS = INT32_C(1);      /** @brief BRK COMP1 enable */
    static const int32_t TIM15_TISEL_BKCMP2E_POS = INT32_C(2);      /** @brief BRK COMP2 enable */
    static const int32_t TIM15_TISEL_BKDF1BK0E_POS = INT32_C(8);    /** @brief BRK dfsdm1_break[0] enable */
    static const int32_t TIM15_TISEL_BKINP_POS = INT32_C(9);        /** @brief BRK BKIN input polarity */
    static const int32_t TIM15_TISEL_BKCMP1P_POS = INT32_C(10);     /** @brief BRK COMP1 input polarity */
    static const int32_t TIM15_TISEL_BKCMP2P_POS = INT32_C(11);     /** @brief BRK COMP2 input polarity */
    static const int32_t TIM15_TISEL_TI1SEL_POS = INT32_C(0);       /** @brief Selects TI1[0] to TI1[15] input */
    static const int32_t TIM15_TISEL_TI2SEL_POS = INT32_C(8);       /** @brief Selects TI2[0] to TI2[15] input */

    /**********************************************************************************************
     * @section USARTX Definitions
     **********************************************************************************************/

    /** @subsection USARTX IRQ interrupt array definitions */

    static const int32_t USARTX_IRQ[7] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(37),    /** @brief USART1 global interrupt */
      INT32_C(38),    /** @brief USART2 global interrupt */
      INT32_C(39),    /** @brief USART3 global interrupt */
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(71),    /** @brief USART6 global interrupt */
    };

    /** @subsection USARTX register array definitions */

    static _RW uint32_t* const USARTX_CR1_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011000),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40004400),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40004800),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011400),   /** @brief Control register 1 */
    };

    static _RW uint32_t* const USARTX_CR2_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011004),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40004404),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40004804),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011404),   /** @brief Control register 2 */
    };

    static _RW uint32_t* const USARTX_CR3_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011008),   /** @brief Control register 3 */
      (_RW uint32_t* const)UINT32_C(0x40004408),   /** @brief Control register 3 */
      (_RW uint32_t* const)UINT32_C(0x40004808),   /** @brief Control register 3 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011408),   /** @brief Control register 3 */
    };

    static _RW uint32_t* const USARTX_BRR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001100C),   /** @brief Baud rate register */
      (_RW uint32_t* const)UINT32_C(0x4000440C),   /** @brief Baud rate register */
      (_RW uint32_t* const)UINT32_C(0x4000480C),   /** @brief Baud rate register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001140C),   /** @brief Baud rate register */
    };

    static _RW uint32_t* const USARTX_GTPR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011010),   /** @brief Guard time and prescaler register */
      (_RW uint32_t* const)UINT32_C(0x40004410),   /** @brief Guard time and prescaler register */
      (_RW uint32_t* const)UINT32_C(0x40004810),   /** @brief Guard time and prescaler register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011410),   /** @brief Guard time and prescaler register */
    };

    static _RW uint32_t* const USARTX_RTOR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011014),   /** @brief Receiver timeout register */
      (_RW uint32_t* const)UINT32_C(0x40004414),   /** @brief Receiver timeout register */
      (_RW uint32_t* const)UINT32_C(0x40004814),   /** @brief Receiver timeout register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011414),   /** @brief Receiver timeout register */
    };

    static _RW uint32_t* const USARTX_RQR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011018),   /** @brief Request register */
      (_RW uint32_t* const)UINT32_C(0x40004418),   /** @brief Request register */
      (_RW uint32_t* const)UINT32_C(0x40004818),   /** @brief Request register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011418),   /** @brief Request register */
    };

    static _RO uint32_t* const USARTX_ISR_REG[7] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4001101C),   /** @brief Interrupt & status register */
      (_RO uint32_t* const)UINT32_C(0x4000441C),   /** @brief Interrupt & status register */
      (_RO uint32_t* const)UINT32_C(0x4000481C),   /** @brief Interrupt & status register */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4001141C),   /** @brief Interrupt & status register */
    };

    static _RW uint32_t* const USARTX_ICR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011020),   /** @brief Interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x40004420),   /** @brief Interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x40004820),   /** @brief Interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011420),   /** @brief Interrupt flag clear register */
    };

    static _RO uint32_t* const USARTX_RDR_REG[7] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40011024),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40004424),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40004824),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40011424),   /** @brief Receive data register */
    };

    static _RW uint32_t* const USARTX_TDR_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011028),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40004428),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40004828),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40011428),   /** @brief Transmit data register */
    };

    static _RW uint32_t* const USARTX_PRESC_REG[7] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001102C),   /** @brief USART prescaler register */
      (_RW uint32_t* const)UINT32_C(0x4000442C),   /** @brief USART prescaler register */
      (_RW uint32_t* const)UINT32_C(0x4000482C),   /** @brief USART prescaler register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001142C),   /** @brief USART prescaler register */
    };

    /** @subsection USARTX field mask array definitions */

    static const uint32_t USARTX_CR1_DEATX_MASK[5] = {
      UINT32_C(0x00200000),   /** @brief DEAT0 */
      UINT32_C(0x00400000),   /** @brief DEAT1 */
      UINT32_C(0x00800000),   /** @brief DEAT2 */
      UINT32_C(0x01000000),   /** @brief DEAT3 */
      UINT32_C(0x02000000),   /** @brief Driver enable assertion time */
    };

    static const uint32_t USARTX_CR1_DEDTX_MASK[5] = {
      UINT32_C(0x00010000),   /** @brief DEDT0 */
      UINT32_C(0x00020000),   /** @brief DEDT1 */
      UINT32_C(0x00040000),   /** @brief DEDT2 */
      UINT32_C(0x00080000),   /** @brief DEDT3 */
      UINT32_C(0x00100000),   /** @brief Driver enable de-assertion time */
    };

    /** @subsection USARTX field mask definitions */

    static const uint32_t USARTX_CR1_RXFFIE_MASK = UINT32_C(0x80000000);        /** @brief RXFIFO full interrupt enable */
    static const uint32_t USARTX_CR1_TXFEIE_MASK = UINT32_C(0x40000000);        /** @brief TXFIFO empty interrupt enable */
    static const uint32_t USARTX_CR1_FIFOEN_MASK = UINT32_C(0x20000000);        /** @brief FIFO mode enable */
    static const uint32_t USARTX_CR1_M1_MASK = UINT32_C(0x10000000);            /** @brief Word length */
    static const uint32_t USARTX_CR1_EOBIE_MASK = UINT32_C(0x08000000);         /** @brief End of block interrupt enable */
    static const uint32_t USARTX_CR1_RTOIE_MASK = UINT32_C(0x04000000);         /** @brief Receiver timeout interrupt enable */
    static const uint32_t USARTX_CR1_OVER8_MASK = UINT32_C(0x00008000);         /** @brief Oversampling mode */
    static const uint32_t USARTX_CR1_CMIE_MASK = UINT32_C(0x00004000);          /** @brief Character match interrupt enable */
    static const uint32_t USARTX_CR1_MME_MASK = UINT32_C(0x00002000);           /** @brief Mute mode enable */
    static const uint32_t USARTX_CR1_M0_MASK = UINT32_C(0x00001000);            /** @brief Word length */
    static const uint32_t USARTX_CR1_WAKE_MASK = UINT32_C(0x00000800);          /** @brief Receiver wakeup method */
    static const uint32_t USARTX_CR1_PCE_MASK = UINT32_C(0x00000400);           /** @brief Parity control enable */
    static const uint32_t USARTX_CR1_PS_MASK = UINT32_C(0x00000200);            /** @brief Parity selection */
    static const uint32_t USARTX_CR1_PEIE_MASK = UINT32_C(0x00000100);          /** @brief PE interrupt enable */
    static const uint32_t USARTX_CR1_TXEIE_MASK = UINT32_C(0x00000080);         /** @brief Interrupt enable */
    static const uint32_t USARTX_CR1_TCIE_MASK = UINT32_C(0x00000040);          /** @brief Transmission complete interrupt enable */
    static const uint32_t USARTX_CR1_RXNEIE_MASK = UINT32_C(0x00000020);        /** @brief RXNE interrupt enable */
    static const uint32_t USARTX_CR1_IDLEIE_MASK = UINT32_C(0x00000010);        /** @brief IDLE interrupt enable */
    static const uint32_t USARTX_CR1_TE_MASK = UINT32_C(0x00000008);            /** @brief Transmitter enable */
    static const uint32_t USARTX_CR1_RE_MASK = UINT32_C(0x00000004);            /** @brief Receiver enable */
    static const uint32_t USARTX_CR1_UESM_MASK = UINT32_C(0x00000002);          /** @brief USART enable in stop mode */
    static const uint32_t USARTX_CR1_UE_MASK = UINT32_C(0x00000001);            /** @brief USART enable */
    static const uint32_t USARTX_CR2_ADD4_7_MASK = UINT32_C(0xF0000000);        /** @brief Address of the USART node */
    static const uint32_t USARTX_CR2_ADD0_3_MASK = UINT32_C(0x0F000000);        /** @brief Address of the USART node */
    static const uint32_t USARTX_CR2_RTOEN_MASK = UINT32_C(0x00800000);         /** @brief Receiver timeout enable */
    static const uint32_t USARTX_CR2_ABRMOD1_MASK = UINT32_C(0x00400000);       /** @brief Auto baud rate mode */
    static const uint32_t USARTX_CR2_ABRMOD0_MASK = UINT32_C(0x00200000);       /** @brief ABRMOD0 */
    static const uint32_t USARTX_CR2_ABREN_MASK = UINT32_C(0x00100000);         /** @brief Auto baud rate enable */
    static const uint32_t USARTX_CR2_MSBFIRST_MASK = UINT32_C(0x00080000);      /** @brief Most significant bit first */
    static const uint32_t USARTX_CR2_TAINV_MASK = UINT32_C(0x00040000);         /** @brief Binary data inversion */
    static const uint32_t USARTX_CR2_TXINV_MASK = UINT32_C(0x00020000);         /** @brief TX pin active level inversion */
    static const uint32_t USARTX_CR2_RXINV_MASK = UINT32_C(0x00010000);         /** @brief RX pin active level inversion */
    static const uint32_t USARTX_CR2_SWAP_MASK = UINT32_C(0x00008000);          /** @brief Swap TX/RX pins */
    static const uint32_t USARTX_CR2_LINEN_MASK = UINT32_C(0x00004000);         /** @brief LIN mode enable */
    static const uint32_t USARTX_CR2_STOP_MASK = UINT32_C(0x00003000);          /** @brief STOP bits */
    static const uint32_t USARTX_CR2_CLKEN_MASK = UINT32_C(0x00000800);         /** @brief Clock enable */
    static const uint32_t USARTX_CR2_CPOL_MASK = UINT32_C(0x00000400);          /** @brief Clock polarity */
    static const uint32_t USARTX_CR2_CPHA_MASK = UINT32_C(0x00000200);          /** @brief Clock phase */
    static const uint32_t USARTX_CR2_LBCL_MASK = UINT32_C(0x00000100);          /** @brief Last bit clock pulse */
    static const uint32_t USARTX_CR2_LBDIE_MASK = UINT32_C(0x00000040);         /** @brief LIN break detection interrupt enable */
    static const uint32_t USARTX_CR2_LBDL_MASK = UINT32_C(0x00000020);          /** @brief LIN break detection length */
    static const uint32_t USARTX_CR2_ADDM7_MASK = UINT32_C(0x00000010);         /** @brief 7-bit address detection/4-bit address detection */
    static const uint32_t USARTX_CR2_DIS_NSS_MASK = UINT32_C(0x00000008);       /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const uint32_t USARTX_CR2_SLVEN_MASK = UINT32_C(0x00000001);         /** @brief Synchronous slave mode enable */
    static const uint32_t USARTX_CR3_TXFTCFG_MASK = UINT32_C(0xE0000000);       /** @brief TXFIFO threshold configuration */
    static const uint32_t USARTX_CR3_RXFTIE_MASK = UINT32_C(0x10000000);        /** @brief RXFIFO threshold interrupt enable */
    static const uint32_t USARTX_CR3_RXFTCFG_MASK = UINT32_C(0x0E000000);       /** @brief Receive FIFO threshold configuration */
    static const uint32_t USARTX_CR3_TCBGTIE_MASK = UINT32_C(0x01000000);       /** @brief Transmission complete before guard time, interrupt enable */
    static const uint32_t USARTX_CR3_TXFTIE_MASK = UINT32_C(0x00800000);        /** @brief TXFIFO threshold interrupt enable */
    static const uint32_t USARTX_CR3_WUFIE_MASK = UINT32_C(0x00400000);         /** @brief Wakeup from stop mode interrupt enable */
    static const uint32_t USARTX_CR3_WUS_MASK = UINT32_C(0x00300000);           /** @brief Wakeup from stop mode interrupt flag selection */
    static const uint32_t USARTX_CR3_SCARCNT_MASK = UINT32_C(0x000E0000);       /** @brief Smartcard auto-retry count */
    static const uint32_t USARTX_CR3_DEP_MASK = UINT32_C(0x00008000);           /** @brief Driver enable polarity selection */
    static const uint32_t USARTX_CR3_DEM_MASK = UINT32_C(0x00004000);           /** @brief Driver enable mode */
    static const uint32_t USARTX_CR3_DDRE_MASK = UINT32_C(0x00002000);          /** @brief DMA disable on reception error */
    static const uint32_t USARTX_CR3_OVRDIS_MASK = UINT32_C(0x00001000);        /** @brief Overrun disable */
    static const uint32_t USARTX_CR3_ONEBIT_MASK = UINT32_C(0x00000800);        /** @brief One sample bit method enable */
    static const uint32_t USARTX_CR3_CTSIE_MASK = UINT32_C(0x00000400);         /** @brief CTS interrupt enable */
    static const uint32_t USARTX_CR3_CTSE_MASK = UINT32_C(0x00000200);          /** @brief CTS enable */
    static const uint32_t USARTX_CR3_RTSE_MASK = UINT32_C(0x00000100);          /** @brief RTS enable */
    static const uint32_t USARTX_CR3_DMAT_MASK = UINT32_C(0x00000080);          /** @brief DMA enable transmitter */
    static const uint32_t USARTX_CR3_DMAR_MASK = UINT32_C(0x00000040);          /** @brief DMA enable receiver */
    static const uint32_t USARTX_CR3_SCEN_MASK = UINT32_C(0x00000020);          /** @brief Smartcard mode enable */
    static const uint32_t USARTX_CR3_NACK_MASK = UINT32_C(0x00000010);          /** @brief Smartcard NACK enable */
    static const uint32_t USARTX_CR3_HDSEL_MASK = UINT32_C(0x00000008);         /** @brief Half-duplex selection */
    static const uint32_t USARTX_CR3_IRLP_MASK = UINT32_C(0x00000004);          /** @brief Ir low-power */
    static const uint32_t USARTX_CR3_IREN_MASK = UINT32_C(0x00000002);          /** @brief Ir mode enable */
    static const uint32_t USARTX_CR3_EIE_MASK = UINT32_C(0x00000001);           /** @brief Error interrupt enable */
    static const uint32_t USARTX_BRR_BRR_4_15_MASK = UINT32_C(0x0000FFF0);      /** @brief DIV_Mantissa */
    static const uint32_t USARTX_BRR_BRR_0_3_MASK = UINT32_C(0x0000000F);       /** @brief DIV_Fraction */
    static const uint32_t USARTX_GTPR_GT_MASK = UINT32_C(0x0000FF00);           /** @brief Guard time value */
    static const uint32_t USARTX_GTPR_PSC_MASK = UINT32_C(0x000000FF);          /** @brief Prescaler value */
    static const uint32_t USARTX_RTOR_BLEN_MASK = UINT32_C(0xFF000000);         /** @brief Block length */
    static const uint32_t USARTX_RTOR_RTO_MASK = UINT32_C(0x00FFFFFF);          /** @brief Receiver timeout value */
    static const uint32_t USARTX_RQR_TXFRQ_MASK = UINT32_C(0x00000010);         /** @brief Transmit data flush request */
    static const uint32_t USARTX_RQR_RXFRQ_MASK = UINT32_C(0x00000008);         /** @brief Receive data flush request */
    static const uint32_t USARTX_RQR_MMRQ_MASK = UINT32_C(0x00000004);          /** @brief Mute mode request */
    static const uint32_t USARTX_RQR_SBKRQ_MASK = UINT32_C(0x00000002);         /** @brief Send break request */
    static const uint32_t USARTX_RQR_ABRRQ_MASK = UINT32_C(0x00000001);         /** @brief Auto baud rate request */
    static const uint32_t USARTX_ISR_TXFT_MASK = UINT32_C(0x08000000);          /** @brief TXFIFO threshold flag */
    static const uint32_t USARTX_ISR_RXFT_MASK = UINT32_C(0x04000000);          /** @brief RXFIFO threshold flag */
    static const uint32_t USARTX_ISR_TCBGT_MASK = UINT32_C(0x02000000);         /** @brief Transmission complete before guard time flag */
    static const uint32_t USARTX_ISR_RXFF_MASK = UINT32_C(0x01000000);          /** @brief RXFIFO full */
    static const uint32_t USARTX_ISR_TXFE_MASK = UINT32_C(0x00800000);          /** @brief TXFIFO empty */
    static const uint32_t USARTX_ISR_REACK_MASK = UINT32_C(0x00400000);         /** @brief REACK */
    static const uint32_t USARTX_ISR_TEACK_MASK = UINT32_C(0x00200000);         /** @brief TEACK */
    static const uint32_t USARTX_ISR_WUF_MASK = UINT32_C(0x00100000);           /** @brief WUF */
    static const uint32_t USARTX_ISR_RWU_MASK = UINT32_C(0x00080000);           /** @brief RWU */
    static const uint32_t USARTX_ISR_SBKF_MASK = UINT32_C(0x00040000);          /** @brief SBKF */
    static const uint32_t USARTX_ISR_CMF_MASK = UINT32_C(0x00020000);           /** @brief CMF */
    static const uint32_t USARTX_ISR_BUSY_MASK = UINT32_C(0x00010000);          /** @brief BUSY */
    static const uint32_t USARTX_ISR_ABRF_MASK = UINT32_C(0x00008000);          /** @brief ABRF */
    static const uint32_t USARTX_ISR_ABRE_MASK = UINT32_C(0x00004000);          /** @brief ABRE */
    static const uint32_t USARTX_ISR_UDR_MASK = UINT32_C(0x00002000);           /** @brief SPI slave underrun error flag */
    static const uint32_t USARTX_ISR_EOBF_MASK = UINT32_C(0x00001000);          /** @brief EOBF */
    static const uint32_t USARTX_ISR_RTOF_MASK = UINT32_C(0x00000800);          /** @brief RTOF */
    static const uint32_t USARTX_ISR_CTS_MASK = UINT32_C(0x00000400);           /** @brief CTS */
    static const uint32_t USARTX_ISR_CTSIF_MASK = UINT32_C(0x00000200);         /** @brief CTSIF */
    static const uint32_t USARTX_ISR_LBDF_MASK = UINT32_C(0x00000100);          /** @brief LBDF */
    static const uint32_t USARTX_ISR_TXE_MASK = UINT32_C(0x00000080);           /** @brief TXE */
    static const uint32_t USARTX_ISR_TC_MASK = UINT32_C(0x00000040);            /** @brief TC */
    static const uint32_t USARTX_ISR_RXNE_MASK = UINT32_C(0x00000020);          /** @brief RXNE */
    static const uint32_t USARTX_ISR_IDLE_MASK = UINT32_C(0x00000010);          /** @brief IDLE */
    static const uint32_t USARTX_ISR_ORE_MASK = UINT32_C(0x00000008);           /** @brief ORE */
    static const uint32_t USARTX_ISR_NF_MASK = UINT32_C(0x00000004);            /** @brief NF */
    static const uint32_t USARTX_ISR_FE_MASK = UINT32_C(0x00000002);            /** @brief FE */
    static const uint32_t USARTX_ISR_PE_MASK = UINT32_C(0x00000001);            /** @brief PE */
    static const uint32_t USARTX_ICR_WUCF_MASK = UINT32_C(0x00100000);          /** @brief Wakeup from stop mode clear flag */
    static const uint32_t USARTX_ICR_CMCF_MASK = UINT32_C(0x00020000);          /** @brief Character match clear flag */
    static const uint32_t USARTX_ICR_UDRCF_MASK = UINT32_C(0x00002000);         /** @brief SPI slave underrun clear flag */
    static const uint32_t USARTX_ICR_EOBCF_MASK = UINT32_C(0x00001000);         /** @brief End of block clear flag */
    static const uint32_t USARTX_ICR_RTOCF_MASK = UINT32_C(0x00000800);         /** @brief Receiver timeout clear flag */
    static const uint32_t USARTX_ICR_CTSCF_MASK = UINT32_C(0x00000200);         /** @brief CTS clear flag */
    static const uint32_t USARTX_ICR_LBDCF_MASK = UINT32_C(0x00000100);         /** @brief LIN break detection clear flag */
    static const uint32_t USARTX_ICR_TCBGTC_MASK = UINT32_C(0x00000080);        /** @brief Transmission complete before guard time clear flag */
    static const uint32_t USARTX_ICR_TCCF_MASK = UINT32_C(0x00000040);          /** @brief Transmission complete clear flag */
    static const uint32_t USARTX_ICR_TXFECF_MASK = UINT32_C(0x00000020);        /** @brief TXFIFO empty clear flag */
    static const uint32_t USARTX_ICR_IDLECF_MASK = UINT32_C(0x00000010);        /** @brief Idle line detected clear flag */
    static const uint32_t USARTX_ICR_ORECF_MASK = UINT32_C(0x00000008);         /** @brief Overrun error clear flag */
    static const uint32_t USARTX_ICR_NCF_MASK = UINT32_C(0x00000004);           /** @brief Noise detected clear flag */
    static const uint32_t USARTX_ICR_FECF_MASK = UINT32_C(0x00000002);          /** @brief Framing error clear flag */
    static const uint32_t USARTX_ICR_PECF_MASK = UINT32_C(0x00000001);          /** @brief Parity error clear flag */
    static const uint32_t USARTX_RDR_RDR_MASK = UINT32_C(0x000001FF);           /** @brief Receive data value */
    static const uint32_t USARTX_TDR_TDR_MASK = UINT32_C(0x000001FF);           /** @brief Transmit data value */
    static const uint32_t USARTX_PRESC_PRESCALER_MASK = UINT32_C(0x0000000F);   /** @brief Clock prescaler */

    /** @subsection USARTX field position array definitions */

    static const int32_t USARTX_PRESC_DEATX_POS[5] = {
      INT32_C(21),   /** @brief DEAT0 */
      INT32_C(22),   /** @brief DEAT1 */
      INT32_C(23),   /** @brief DEAT2 */
      INT32_C(24),   /** @brief DEAT3 */
      INT32_C(25),   /** @brief Driver enable assertion time */
    };

    static const int32_t USARTX_PRESC_DEDTX_POS[5] = {
      INT32_C(16),   /** @brief DEDT0 */
      INT32_C(17),   /** @brief DEDT1 */
      INT32_C(18),   /** @brief DEDT2 */
      INT32_C(19),   /** @brief DEDT3 */
      INT32_C(20),   /** @brief Driver enable de-assertion time */
    };

    /** @subsection USARTX field position definitions */

    static const int32_t USARTX_PRESC_RXFFIE_POS = INT32_C(31);      /** @brief RXFIFO full interrupt enable */
    static const int32_t USARTX_PRESC_TXFEIE_POS = INT32_C(30);      /** @brief TXFIFO empty interrupt enable */
    static const int32_t USARTX_PRESC_FIFOEN_POS = INT32_C(29);      /** @brief FIFO mode enable */
    static const int32_t USARTX_PRESC_M1_POS = INT32_C(28);          /** @brief Word length */
    static const int32_t USARTX_PRESC_EOBIE_POS = INT32_C(27);       /** @brief End of block interrupt enable */
    static const int32_t USARTX_PRESC_RTOIE_POS = INT32_C(26);       /** @brief Receiver timeout interrupt enable */
    static const int32_t USARTX_PRESC_OVER8_POS = INT32_C(15);       /** @brief Oversampling mode */
    static const int32_t USARTX_PRESC_CMIE_POS = INT32_C(14);        /** @brief Character match interrupt enable */
    static const int32_t USARTX_PRESC_MME_POS = INT32_C(13);         /** @brief Mute mode enable */
    static const int32_t USARTX_PRESC_M0_POS = INT32_C(12);          /** @brief Word length */
    static const int32_t USARTX_PRESC_WAKE_POS = INT32_C(11);        /** @brief Receiver wakeup method */
    static const int32_t USARTX_PRESC_PCE_POS = INT32_C(10);         /** @brief Parity control enable */
    static const int32_t USARTX_PRESC_PS_POS = INT32_C(9);           /** @brief Parity selection */
    static const int32_t USARTX_PRESC_PEIE_POS = INT32_C(8);         /** @brief PE interrupt enable */
    static const int32_t USARTX_PRESC_TXEIE_POS = INT32_C(7);        /** @brief Interrupt enable */
    static const int32_t USARTX_PRESC_TCIE_POS = INT32_C(6);         /** @brief Transmission complete interrupt enable */
    static const int32_t USARTX_PRESC_RXNEIE_POS = INT32_C(5);       /** @brief RXNE interrupt enable */
    static const int32_t USARTX_PRESC_IDLEIE_POS = INT32_C(4);       /** @brief IDLE interrupt enable */
    static const int32_t USARTX_PRESC_TE_POS = INT32_C(3);           /** @brief Transmitter enable */
    static const int32_t USARTX_PRESC_RE_POS = INT32_C(2);           /** @brief Receiver enable */
    static const int32_t USARTX_PRESC_UESM_POS = INT32_C(1);         /** @brief USART enable in stop mode */
    static const int32_t USARTX_PRESC_UE_POS = INT32_C(0);           /** @brief USART enable */
    static const int32_t USARTX_PRESC_ADD4_7_POS = INT32_C(28);      /** @brief Address of the USART node */
    static const int32_t USARTX_PRESC_ADD0_3_POS = INT32_C(24);      /** @brief Address of the USART node */
    static const int32_t USARTX_PRESC_RTOEN_POS = INT32_C(23);       /** @brief Receiver timeout enable */
    static const int32_t USARTX_PRESC_ABRMOD1_POS = INT32_C(22);     /** @brief Auto baud rate mode */
    static const int32_t USARTX_PRESC_ABRMOD0_POS = INT32_C(21);     /** @brief ABRMOD0 */
    static const int32_t USARTX_PRESC_ABREN_POS = INT32_C(20);       /** @brief Auto baud rate enable */
    static const int32_t USARTX_PRESC_MSBFIRST_POS = INT32_C(19);    /** @brief Most significant bit first */
    static const int32_t USARTX_PRESC_TAINV_POS = INT32_C(18);       /** @brief Binary data inversion */
    static const int32_t USARTX_PRESC_TXINV_POS = INT32_C(17);       /** @brief TX pin active level inversion */
    static const int32_t USARTX_PRESC_RXINV_POS = INT32_C(16);       /** @brief RX pin active level inversion */
    static const int32_t USARTX_PRESC_SWAP_POS = INT32_C(15);        /** @brief Swap TX/RX pins */
    static const int32_t USARTX_PRESC_LINEN_POS = INT32_C(14);       /** @brief LIN mode enable */
    static const int32_t USARTX_PRESC_STOP_POS = INT32_C(12);        /** @brief STOP bits */
    static const int32_t USARTX_PRESC_CLKEN_POS = INT32_C(11);       /** @brief Clock enable */
    static const int32_t USARTX_PRESC_CPOL_POS = INT32_C(10);        /** @brief Clock polarity */
    static const int32_t USARTX_PRESC_CPHA_POS = INT32_C(9);         /** @brief Clock phase */
    static const int32_t USARTX_PRESC_LBCL_POS = INT32_C(8);         /** @brief Last bit clock pulse */
    static const int32_t USARTX_PRESC_LBDIE_POS = INT32_C(6);        /** @brief LIN break detection interrupt enable */
    static const int32_t USARTX_PRESC_LBDL_POS = INT32_C(5);         /** @brief LIN break detection length */
    static const int32_t USARTX_PRESC_ADDM7_POS = INT32_C(4);        /** @brief 7-bit address detection/4-bit address detection */
    static const int32_t USARTX_PRESC_DIS_NSS_POS = INT32_C(3);      /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const int32_t USARTX_PRESC_SLVEN_POS = INT32_C(0);        /** @brief Synchronous slave mode enable */
    static const int32_t USARTX_PRESC_TXFTCFG_POS = INT32_C(29);     /** @brief TXFIFO threshold configuration */
    static const int32_t USARTX_PRESC_RXFTIE_POS = INT32_C(28);      /** @brief RXFIFO threshold interrupt enable */
    static const int32_t USARTX_PRESC_RXFTCFG_POS = INT32_C(25);     /** @brief Receive FIFO threshold configuration */
    static const int32_t USARTX_PRESC_TCBGTIE_POS = INT32_C(24);     /** @brief Transmission complete before guard time, interrupt enable */
    static const int32_t USARTX_PRESC_TXFTIE_POS = INT32_C(23);      /** @brief TXFIFO threshold interrupt enable */
    static const int32_t USARTX_PRESC_WUFIE_POS = INT32_C(22);       /** @brief Wakeup from stop mode interrupt enable */
    static const int32_t USARTX_PRESC_WUS_POS = INT32_C(20);         /** @brief Wakeup from stop mode interrupt flag selection */
    static const int32_t USARTX_PRESC_SCARCNT_POS = INT32_C(17);     /** @brief Smartcard auto-retry count */
    static const int32_t USARTX_PRESC_DEP_POS = INT32_C(15);         /** @brief Driver enable polarity selection */
    static const int32_t USARTX_PRESC_DEM_POS = INT32_C(14);         /** @brief Driver enable mode */
    static const int32_t USARTX_PRESC_DDRE_POS = INT32_C(13);        /** @brief DMA disable on reception error */
    static const int32_t USARTX_PRESC_OVRDIS_POS = INT32_C(12);      /** @brief Overrun disable */
    static const int32_t USARTX_PRESC_ONEBIT_POS = INT32_C(11);      /** @brief One sample bit method enable */
    static const int32_t USARTX_PRESC_CTSIE_POS = INT32_C(10);       /** @brief CTS interrupt enable */
    static const int32_t USARTX_PRESC_CTSE_POS = INT32_C(9);         /** @brief CTS enable */
    static const int32_t USARTX_PRESC_RTSE_POS = INT32_C(8);         /** @brief RTS enable */
    static const int32_t USARTX_PRESC_DMAT_POS = INT32_C(7);         /** @brief DMA enable transmitter */
    static const int32_t USARTX_PRESC_DMAR_POS = INT32_C(6);         /** @brief DMA enable receiver */
    static const int32_t USARTX_PRESC_SCEN_POS = INT32_C(5);         /** @brief Smartcard mode enable */
    static const int32_t USARTX_PRESC_NACK_POS = INT32_C(4);         /** @brief Smartcard NACK enable */
    static const int32_t USARTX_PRESC_HDSEL_POS = INT32_C(3);        /** @brief Half-duplex selection */
    static const int32_t USARTX_PRESC_IRLP_POS = INT32_C(2);         /** @brief Ir low-power */
    static const int32_t USARTX_PRESC_IREN_POS = INT32_C(1);         /** @brief Ir mode enable */
    static const int32_t USARTX_PRESC_EIE_POS = INT32_C(0);          /** @brief Error interrupt enable */
    static const int32_t USARTX_PRESC_BRR_4_15_POS = INT32_C(4);     /** @brief DIV_Mantissa */
    static const int32_t USARTX_PRESC_BRR_0_3_POS = INT32_C(0);      /** @brief DIV_Fraction */
    static const int32_t USARTX_PRESC_GT_POS = INT32_C(8);           /** @brief Guard time value */
    static const int32_t USARTX_PRESC_PSC_POS = INT32_C(0);          /** @brief Prescaler value */
    static const int32_t USARTX_PRESC_BLEN_POS = INT32_C(24);        /** @brief Block length */
    static const int32_t USARTX_PRESC_RTO_POS = INT32_C(0);          /** @brief Receiver timeout value */
    static const int32_t USARTX_PRESC_TXFRQ_POS = INT32_C(4);        /** @brief Transmit data flush request */
    static const int32_t USARTX_PRESC_RXFRQ_POS = INT32_C(3);        /** @brief Receive data flush request */
    static const int32_t USARTX_PRESC_MMRQ_POS = INT32_C(2);         /** @brief Mute mode request */
    static const int32_t USARTX_PRESC_SBKRQ_POS = INT32_C(1);        /** @brief Send break request */
    static const int32_t USARTX_PRESC_ABRRQ_POS = INT32_C(0);        /** @brief Auto baud rate request */
    static const int32_t USARTX_PRESC_TXFT_POS = INT32_C(27);        /** @brief TXFIFO threshold flag */
    static const int32_t USARTX_PRESC_RXFT_POS = INT32_C(26);        /** @brief RXFIFO threshold flag */
    static const int32_t USARTX_PRESC_TCBGT_POS = INT32_C(25);       /** @brief Transmission complete before guard time flag */
    static const int32_t USARTX_PRESC_RXFF_POS = INT32_C(24);        /** @brief RXFIFO full */
    static const int32_t USARTX_PRESC_TXFE_POS = INT32_C(23);        /** @brief TXFIFO empty */
    static const int32_t USARTX_PRESC_REACK_POS = INT32_C(22);       /** @brief REACK */
    static const int32_t USARTX_PRESC_TEACK_POS = INT32_C(21);       /** @brief TEACK */
    static const int32_t USARTX_PRESC_WUF_POS = INT32_C(20);         /** @brief WUF */
    static const int32_t USARTX_PRESC_RWU_POS = INT32_C(19);         /** @brief RWU */
    static const int32_t USARTX_PRESC_SBKF_POS = INT32_C(18);        /** @brief SBKF */
    static const int32_t USARTX_PRESC_CMF_POS = INT32_C(17);         /** @brief CMF */
    static const int32_t USARTX_PRESC_BUSY_POS = INT32_C(16);        /** @brief BUSY */
    static const int32_t USARTX_PRESC_ABRF_POS = INT32_C(15);        /** @brief ABRF */
    static const int32_t USARTX_PRESC_ABRE_POS = INT32_C(14);        /** @brief ABRE */
    static const int32_t USARTX_PRESC_UDR_POS = INT32_C(13);         /** @brief SPI slave underrun error flag */
    static const int32_t USARTX_PRESC_EOBF_POS = INT32_C(12);        /** @brief EOBF */
    static const int32_t USARTX_PRESC_RTOF_POS = INT32_C(11);        /** @brief RTOF */
    static const int32_t USARTX_PRESC_CTS_POS = INT32_C(10);         /** @brief CTS */
    static const int32_t USARTX_PRESC_CTSIF_POS = INT32_C(9);        /** @brief CTSIF */
    static const int32_t USARTX_PRESC_LBDF_POS = INT32_C(8);         /** @brief LBDF */
    static const int32_t USARTX_PRESC_TXE_POS = INT32_C(7);          /** @brief TXE */
    static const int32_t USARTX_PRESC_TC_POS = INT32_C(6);           /** @brief TC */
    static const int32_t USARTX_PRESC_RXNE_POS = INT32_C(5);         /** @brief RXNE */
    static const int32_t USARTX_PRESC_IDLE_POS = INT32_C(4);         /** @brief IDLE */
    static const int32_t USARTX_PRESC_ORE_POS = INT32_C(3);          /** @brief ORE */
    static const int32_t USARTX_PRESC_NF_POS = INT32_C(2);           /** @brief NF */
    static const int32_t USARTX_PRESC_FE_POS = INT32_C(1);           /** @brief FE */
    static const int32_t USARTX_PRESC_PE_POS = INT32_C(0);           /** @brief PE */
    static const int32_t USARTX_PRESC_WUCF_POS = INT32_C(20);        /** @brief Wakeup from stop mode clear flag */
    static const int32_t USARTX_PRESC_CMCF_POS = INT32_C(17);        /** @brief Character match clear flag */
    static const int32_t USARTX_PRESC_UDRCF_POS = INT32_C(13);       /** @brief SPI slave underrun clear flag */
    static const int32_t USARTX_PRESC_EOBCF_POS = INT32_C(12);       /** @brief End of block clear flag */
    static const int32_t USARTX_PRESC_RTOCF_POS = INT32_C(11);       /** @brief Receiver timeout clear flag */
    static const int32_t USARTX_PRESC_CTSCF_POS = INT32_C(9);        /** @brief CTS clear flag */
    static const int32_t USARTX_PRESC_LBDCF_POS = INT32_C(8);        /** @brief LIN break detection clear flag */
    static const int32_t USARTX_PRESC_TCBGTC_POS = INT32_C(7);       /** @brief Transmission complete before guard time clear flag */
    static const int32_t USARTX_PRESC_TCCF_POS = INT32_C(6);         /** @brief Transmission complete clear flag */
    static const int32_t USARTX_PRESC_TXFECF_POS = INT32_C(5);       /** @brief TXFIFO empty clear flag */
    static const int32_t USARTX_PRESC_IDLECF_POS = INT32_C(4);       /** @brief Idle line detected clear flag */
    static const int32_t USARTX_PRESC_ORECF_POS = INT32_C(3);        /** @brief Overrun error clear flag */
    static const int32_t USARTX_PRESC_NCF_POS = INT32_C(2);          /** @brief Noise detected clear flag */
    static const int32_t USARTX_PRESC_FECF_POS = INT32_C(1);         /** @brief Framing error clear flag */
    static const int32_t USARTX_PRESC_PECF_POS = INT32_C(0);         /** @brief Parity error clear flag */
    static const int32_t USARTX_PRESC_RDR_POS = INT32_C(0);          /** @brief Receive data value */
    static const int32_t USARTX_PRESC_TDR_POS = INT32_C(0);          /** @brief Transmit data value */
    static const int32_t USARTX_PRESC_PRESCALER_POS = INT32_C(0);    /** @brief Clock prescaler */

    /**********************************************************************************************
     * @section UARTX Definitions
     **********************************************************************************************/

    /** @subsection UARTX IRQ interrupt array definitions */

    static const int32_t UARTX_IRQ[9] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(52),    /** @brief UART4 global interrupt */
      INT32_C(53),    /** @brief UART5 global interrupt */
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(82),    /** @brief UART7 global interrupt */
      INT32_C(83),    /** @brief UART8 global interrupt */
    };

    /** @subsection UARTX register array definitions */

    static _RW uint32_t* const UARTX_CR1_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C00),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40005000),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007800),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40007C00),   /** @brief Control register 1 */
    };

    static _RW uint32_t* const UARTX_CR2_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C04),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40005004),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007804),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40007C04),   /** @brief Control register 2 */
    };

    static _RW uint32_t* const UARTX_CR3_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C08),   /** @brief Control register 3 */
      (_RW uint32_t* const)UINT32_C(0x40005008),   /** @brief Control register 3 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007808),   /** @brief Control register 3 */
      (_RW uint32_t* const)UINT32_C(0x40007C08),   /** @brief Control register 3 */
    };

    static _RW uint32_t* const UARTX_BRR_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C0C),   /** @brief Baud rate register */
      (_RW uint32_t* const)UINT32_C(0x4000500C),   /** @brief Baud rate register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000780C),   /** @brief Baud rate register */
      (_RW uint32_t* const)UINT32_C(0x40007C0C),   /** @brief Baud rate register */
    };

    static _RW uint32_t* const UARTX_GTPR_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C10),   /** @brief Guard time and prescaler register */
      (_RW uint32_t* const)UINT32_C(0x40005010),   /** @brief Guard time and prescaler register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007810),   /** @brief Guard time and prescaler register */
      (_RW uint32_t* const)UINT32_C(0x40007C10),   /** @brief Guard time and prescaler register */
    };

    static _RW uint32_t* const UARTX_RTOR_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C14),   /** @brief Receiver timeout register */
      (_RW uint32_t* const)UINT32_C(0x40005014),   /** @brief Receiver timeout register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007814),   /** @brief Receiver timeout register */
      (_RW uint32_t* const)UINT32_C(0x40007C14),   /** @brief Receiver timeout register */
    };

    static _RW uint32_t* const UARTX_RQR_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C18),   /** @brief Request register */
      (_RW uint32_t* const)UINT32_C(0x40005018),   /** @brief Request register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007818),   /** @brief Request register */
      (_RW uint32_t* const)UINT32_C(0x40007C18),   /** @brief Request register */
    };

    static _RO uint32_t* const UARTX_ISR_REG[9] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40004C1C),   /** @brief Interrupt & status register */
      (_RO uint32_t* const)UINT32_C(0x4000501C),   /** @brief Interrupt & status register */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000781C),   /** @brief Interrupt & status register */
      (_RO uint32_t* const)UINT32_C(0x40007C1C),   /** @brief Interrupt & status register */
    };

    static _RW uint32_t* const UARTX_ICR_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C20),   /** @brief Interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x40005020),   /** @brief Interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007820),   /** @brief Interrupt flag clear register */
      (_RW uint32_t* const)UINT32_C(0x40007C20),   /** @brief Interrupt flag clear register */
    };

    static _RO uint32_t* const UARTX_RDR_REG[9] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40004C24),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40005024),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x40007824),   /** @brief Receive data register */
      (_RO uint32_t* const)UINT32_C(0x40007C24),   /** @brief Receive data register */
    };

    static _RW uint32_t* const UARTX_TDR_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C28),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40005028),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40007828),   /** @brief Transmit data register */
      (_RW uint32_t* const)UINT32_C(0x40007C28),   /** @brief Transmit data register */
    };

    static _RW uint32_t* const UARTX_PRESC_REG[9] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40004C2C),   /** @brief USART prescaler register */
      (_RW uint32_t* const)UINT32_C(0x4000502C),   /** @brief USART prescaler register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000782C),   /** @brief USART prescaler register */
      (_RW uint32_t* const)UINT32_C(0x40007C2C),   /** @brief USART prescaler register */
    };

    /** @subsection UARTX field mask array definitions */

    static const uint32_t UARTX_CR1_DEATX_MASK[5] = {
      UINT32_C(0x00200000),   /** @brief DEAT0 */
      UINT32_C(0x00400000),   /** @brief DEAT1 */
      UINT32_C(0x00800000),   /** @brief DEAT2 */
      UINT32_C(0x01000000),   /** @brief DEAT3 */
      UINT32_C(0x02000000),   /** @brief Driver enable assertion time */
    };

    static const uint32_t UARTX_CR1_DEDTX_MASK[5] = {
      UINT32_C(0x00010000),   /** @brief DEDT0 */
      UINT32_C(0x00020000),   /** @brief DEDT1 */
      UINT32_C(0x00040000),   /** @brief DEDT2 */
      UINT32_C(0x00080000),   /** @brief DEDT3 */
      UINT32_C(0x00100000),   /** @brief Driver enable de-assertion time */
    };

    /** @subsection UARTX field mask definitions */

    static const uint32_t UARTX_CR1_RXFFIE_MASK = UINT32_C(0x80000000);        /** @brief RXFIFO full interrupt enable */
    static const uint32_t UARTX_CR1_TXFEIE_MASK = UINT32_C(0x40000000);        /** @brief TXFIFO empty interrupt enable */
    static const uint32_t UARTX_CR1_FIFOEN_MASK = UINT32_C(0x20000000);        /** @brief FIFO mode enable */
    static const uint32_t UARTX_CR1_M1_MASK = UINT32_C(0x10000000);            /** @brief Word length */
    static const uint32_t UARTX_CR1_EOBIE_MASK = UINT32_C(0x08000000);         /** @brief End of block interrupt enable */
    static const uint32_t UARTX_CR1_RTOIE_MASK = UINT32_C(0x04000000);         /** @brief Receiver timeout interrupt enable */
    static const uint32_t UARTX_CR1_OVER8_MASK = UINT32_C(0x00008000);         /** @brief Oversampling mode */
    static const uint32_t UARTX_CR1_CMIE_MASK = UINT32_C(0x00004000);          /** @brief Character match interrupt enable */
    static const uint32_t UARTX_CR1_MME_MASK = UINT32_C(0x00002000);           /** @brief Mute mode enable */
    static const uint32_t UARTX_CR1_M0_MASK = UINT32_C(0x00001000);            /** @brief Word length */
    static const uint32_t UARTX_CR1_WAKE_MASK = UINT32_C(0x00000800);          /** @brief Receiver wakeup method */
    static const uint32_t UARTX_CR1_PCE_MASK = UINT32_C(0x00000400);           /** @brief Parity control enable */
    static const uint32_t UARTX_CR1_PS_MASK = UINT32_C(0x00000200);            /** @brief Parity selection */
    static const uint32_t UARTX_CR1_PEIE_MASK = UINT32_C(0x00000100);          /** @brief PE interrupt enable */
    static const uint32_t UARTX_CR1_TXEIE_MASK = UINT32_C(0x00000080);         /** @brief Interrupt enable */
    static const uint32_t UARTX_CR1_TCIE_MASK = UINT32_C(0x00000040);          /** @brief Transmission complete interrupt enable */
    static const uint32_t UARTX_CR1_RXNEIE_MASK = UINT32_C(0x00000020);        /** @brief RXNE interrupt enable */
    static const uint32_t UARTX_CR1_IDLEIE_MASK = UINT32_C(0x00000010);        /** @brief IDLE interrupt enable */
    static const uint32_t UARTX_CR1_TE_MASK = UINT32_C(0x00000008);            /** @brief Transmitter enable */
    static const uint32_t UARTX_CR1_RE_MASK = UINT32_C(0x00000004);            /** @brief Receiver enable */
    static const uint32_t UARTX_CR1_UESM_MASK = UINT32_C(0x00000002);          /** @brief USART enable in stop mode */
    static const uint32_t UARTX_CR1_UE_MASK = UINT32_C(0x00000001);            /** @brief USART enable */
    static const uint32_t UARTX_CR2_ADD4_7_MASK = UINT32_C(0xF0000000);        /** @brief Address of the USART node */
    static const uint32_t UARTX_CR2_ADD0_3_MASK = UINT32_C(0x0F000000);        /** @brief Address of the USART node */
    static const uint32_t UARTX_CR2_RTOEN_MASK = UINT32_C(0x00800000);         /** @brief Receiver timeout enable */
    static const uint32_t UARTX_CR2_ABRMOD1_MASK = UINT32_C(0x00400000);       /** @brief Auto baud rate mode */
    static const uint32_t UARTX_CR2_ABRMOD0_MASK = UINT32_C(0x00200000);       /** @brief ABRMOD0 */
    static const uint32_t UARTX_CR2_ABREN_MASK = UINT32_C(0x00100000);         /** @brief Auto baud rate enable */
    static const uint32_t UARTX_CR2_MSBFIRST_MASK = UINT32_C(0x00080000);      /** @brief Most significant bit first */
    static const uint32_t UARTX_CR2_TAINV_MASK = UINT32_C(0x00040000);         /** @brief Binary data inversion */
    static const uint32_t UARTX_CR2_TXINV_MASK = UINT32_C(0x00020000);         /** @brief TX pin active level inversion */
    static const uint32_t UARTX_CR2_RXINV_MASK = UINT32_C(0x00010000);         /** @brief RX pin active level inversion */
    static const uint32_t UARTX_CR2_SWAP_MASK = UINT32_C(0x00008000);          /** @brief Swap TX/RX pins */
    static const uint32_t UARTX_CR2_LINEN_MASK = UINT32_C(0x00004000);         /** @brief LIN mode enable */
    static const uint32_t UARTX_CR2_STOP_MASK = UINT32_C(0x00003000);          /** @brief STOP bits */
    static const uint32_t UARTX_CR2_CLKEN_MASK = UINT32_C(0x00000800);         /** @brief Clock enable */
    static const uint32_t UARTX_CR2_CPOL_MASK = UINT32_C(0x00000400);          /** @brief Clock polarity */
    static const uint32_t UARTX_CR2_CPHA_MASK = UINT32_C(0x00000200);          /** @brief Clock phase */
    static const uint32_t UARTX_CR2_LBCL_MASK = UINT32_C(0x00000100);          /** @brief Last bit clock pulse */
    static const uint32_t UARTX_CR2_LBDIE_MASK = UINT32_C(0x00000040);         /** @brief LIN break detection interrupt enable */
    static const uint32_t UARTX_CR2_LBDL_MASK = UINT32_C(0x00000020);          /** @brief LIN break detection length */
    static const uint32_t UARTX_CR2_ADDM7_MASK = UINT32_C(0x00000010);         /** @brief 7-bit address detection/4-bit address detection */
    static const uint32_t UARTX_CR2_DIS_NSS_MASK = UINT32_C(0x00000008);       /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const uint32_t UARTX_CR2_SLVEN_MASK = UINT32_C(0x00000001);         /** @brief Synchronous slave mode enable */
    static const uint32_t UARTX_CR3_TXFTCFG_MASK = UINT32_C(0xE0000000);       /** @brief TXFIFO threshold configuration */
    static const uint32_t UARTX_CR3_RXFTIE_MASK = UINT32_C(0x10000000);        /** @brief RXFIFO threshold interrupt enable */
    static const uint32_t UARTX_CR3_RXFTCFG_MASK = UINT32_C(0x0E000000);       /** @brief Receive FIFO threshold configuration */
    static const uint32_t UARTX_CR3_TCBGTIE_MASK = UINT32_C(0x01000000);       /** @brief Transmission complete before guard time, interrupt enable */
    static const uint32_t UARTX_CR3_TXFTIE_MASK = UINT32_C(0x00800000);        /** @brief TXFIFO threshold interrupt enable */
    static const uint32_t UARTX_CR3_WUFIE_MASK = UINT32_C(0x00400000);         /** @brief Wakeup from stop mode interrupt enable */
    static const uint32_t UARTX_CR3_WUS_MASK = UINT32_C(0x00300000);           /** @brief Wakeup from stop mode interrupt flag selection */
    static const uint32_t UARTX_CR3_SCARCNT_MASK = UINT32_C(0x000E0000);       /** @brief Smartcard auto-retry count */
    static const uint32_t UARTX_CR3_DEP_MASK = UINT32_C(0x00008000);           /** @brief Driver enable polarity selection */
    static const uint32_t UARTX_CR3_DEM_MASK = UINT32_C(0x00004000);           /** @brief Driver enable mode */
    static const uint32_t UARTX_CR3_DDRE_MASK = UINT32_C(0x00002000);          /** @brief DMA disable on reception error */
    static const uint32_t UARTX_CR3_OVRDIS_MASK = UINT32_C(0x00001000);        /** @brief Overrun disable */
    static const uint32_t UARTX_CR3_ONEBIT_MASK = UINT32_C(0x00000800);        /** @brief One sample bit method enable */
    static const uint32_t UARTX_CR3_CTSIE_MASK = UINT32_C(0x00000400);         /** @brief CTS interrupt enable */
    static const uint32_t UARTX_CR3_CTSE_MASK = UINT32_C(0x00000200);          /** @brief CTS enable */
    static const uint32_t UARTX_CR3_RTSE_MASK = UINT32_C(0x00000100);          /** @brief RTS enable */
    static const uint32_t UARTX_CR3_DMAT_MASK = UINT32_C(0x00000080);          /** @brief DMA enable transmitter */
    static const uint32_t UARTX_CR3_DMAR_MASK = UINT32_C(0x00000040);          /** @brief DMA enable receiver */
    static const uint32_t UARTX_CR3_SCEN_MASK = UINT32_C(0x00000020);          /** @brief Smartcard mode enable */
    static const uint32_t UARTX_CR3_NACK_MASK = UINT32_C(0x00000010);          /** @brief Smartcard NACK enable */
    static const uint32_t UARTX_CR3_HDSEL_MASK = UINT32_C(0x00000008);         /** @brief Half-duplex selection */
    static const uint32_t UARTX_CR3_IRLP_MASK = UINT32_C(0x00000004);          /** @brief Ir low-power */
    static const uint32_t UARTX_CR3_IREN_MASK = UINT32_C(0x00000002);          /** @brief Ir mode enable */
    static const uint32_t UARTX_CR3_EIE_MASK = UINT32_C(0x00000001);           /** @brief Error interrupt enable */
    static const uint32_t UARTX_BRR_BRR_4_15_MASK = UINT32_C(0x0000FFF0);      /** @brief DIV_Mantissa */
    static const uint32_t UARTX_BRR_BRR_0_3_MASK = UINT32_C(0x0000000F);       /** @brief DIV_Fraction */
    static const uint32_t UARTX_GTPR_GT_MASK = UINT32_C(0x0000FF00);           /** @brief Guard time value */
    static const uint32_t UARTX_GTPR_PSC_MASK = UINT32_C(0x000000FF);          /** @brief Prescaler value */
    static const uint32_t UARTX_RTOR_BLEN_MASK = UINT32_C(0xFF000000);         /** @brief Block length */
    static const uint32_t UARTX_RTOR_RTO_MASK = UINT32_C(0x00FFFFFF);          /** @brief Receiver timeout value */
    static const uint32_t UARTX_RQR_TXFRQ_MASK = UINT32_C(0x00000010);         /** @brief Transmit data flush request */
    static const uint32_t UARTX_RQR_RXFRQ_MASK = UINT32_C(0x00000008);         /** @brief Receive data flush request */
    static const uint32_t UARTX_RQR_MMRQ_MASK = UINT32_C(0x00000004);          /** @brief Mute mode request */
    static const uint32_t UARTX_RQR_SBKRQ_MASK = UINT32_C(0x00000002);         /** @brief Send break request */
    static const uint32_t UARTX_RQR_ABRRQ_MASK = UINT32_C(0x00000001);         /** @brief Auto baud rate request */
    static const uint32_t UARTX_ISR_TXFT_MASK = UINT32_C(0x08000000);          /** @brief TXFIFO threshold flag */
    static const uint32_t UARTX_ISR_RXFT_MASK = UINT32_C(0x04000000);          /** @brief RXFIFO threshold flag */
    static const uint32_t UARTX_ISR_TCBGT_MASK = UINT32_C(0x02000000);         /** @brief Transmission complete before guard time flag */
    static const uint32_t UARTX_ISR_RXFF_MASK = UINT32_C(0x01000000);          /** @brief RXFIFO full */
    static const uint32_t UARTX_ISR_TXFE_MASK = UINT32_C(0x00800000);          /** @brief TXFIFO empty */
    static const uint32_t UARTX_ISR_REACK_MASK = UINT32_C(0x00400000);         /** @brief REACK */
    static const uint32_t UARTX_ISR_TEACK_MASK = UINT32_C(0x00200000);         /** @brief TEACK */
    static const uint32_t UARTX_ISR_WUF_MASK = UINT32_C(0x00100000);           /** @brief WUF */
    static const uint32_t UARTX_ISR_RWU_MASK = UINT32_C(0x00080000);           /** @brief RWU */
    static const uint32_t UARTX_ISR_SBKF_MASK = UINT32_C(0x00040000);          /** @brief SBKF */
    static const uint32_t UARTX_ISR_CMF_MASK = UINT32_C(0x00020000);           /** @brief CMF */
    static const uint32_t UARTX_ISR_BUSY_MASK = UINT32_C(0x00010000);          /** @brief BUSY */
    static const uint32_t UARTX_ISR_ABRF_MASK = UINT32_C(0x00008000);          /** @brief ABRF */
    static const uint32_t UARTX_ISR_ABRE_MASK = UINT32_C(0x00004000);          /** @brief ABRE */
    static const uint32_t UARTX_ISR_UDR_MASK = UINT32_C(0x00002000);           /** @brief SPI slave underrun error flag */
    static const uint32_t UARTX_ISR_EOBF_MASK = UINT32_C(0x00001000);          /** @brief EOBF */
    static const uint32_t UARTX_ISR_RTOF_MASK = UINT32_C(0x00000800);          /** @brief RTOF */
    static const uint32_t UARTX_ISR_CTS_MASK = UINT32_C(0x00000400);           /** @brief CTS */
    static const uint32_t UARTX_ISR_CTSIF_MASK = UINT32_C(0x00000200);         /** @brief CTSIF */
    static const uint32_t UARTX_ISR_LBDF_MASK = UINT32_C(0x00000100);          /** @brief LBDF */
    static const uint32_t UARTX_ISR_TXE_MASK = UINT32_C(0x00000080);           /** @brief TXE */
    static const uint32_t UARTX_ISR_TC_MASK = UINT32_C(0x00000040);            /** @brief TC */
    static const uint32_t UARTX_ISR_RXNE_MASK = UINT32_C(0x00000020);          /** @brief RXNE */
    static const uint32_t UARTX_ISR_IDLE_MASK = UINT32_C(0x00000010);          /** @brief IDLE */
    static const uint32_t UARTX_ISR_ORE_MASK = UINT32_C(0x00000008);           /** @brief ORE */
    static const uint32_t UARTX_ISR_NF_MASK = UINT32_C(0x00000004);            /** @brief NF */
    static const uint32_t UARTX_ISR_FE_MASK = UINT32_C(0x00000002);            /** @brief FE */
    static const uint32_t UARTX_ISR_PE_MASK = UINT32_C(0x00000001);            /** @brief PE */
    static const uint32_t UARTX_ICR_WUCF_MASK = UINT32_C(0x00100000);          /** @brief Wakeup from stop mode clear flag */
    static const uint32_t UARTX_ICR_CMCF_MASK = UINT32_C(0x00020000);          /** @brief Character match clear flag */
    static const uint32_t UARTX_ICR_UDRCF_MASK = UINT32_C(0x00002000);         /** @brief SPI slave underrun clear flag */
    static const uint32_t UARTX_ICR_EOBCF_MASK = UINT32_C(0x00001000);         /** @brief End of block clear flag */
    static const uint32_t UARTX_ICR_RTOCF_MASK = UINT32_C(0x00000800);         /** @brief Receiver timeout clear flag */
    static const uint32_t UARTX_ICR_CTSCF_MASK = UINT32_C(0x00000200);         /** @brief CTS clear flag */
    static const uint32_t UARTX_ICR_LBDCF_MASK = UINT32_C(0x00000100);         /** @brief LIN break detection clear flag */
    static const uint32_t UARTX_ICR_TCBGTC_MASK = UINT32_C(0x00000080);        /** @brief Transmission complete before guard time clear flag */
    static const uint32_t UARTX_ICR_TCCF_MASK = UINT32_C(0x00000040);          /** @brief Transmission complete clear flag */
    static const uint32_t UARTX_ICR_TXFECF_MASK = UINT32_C(0x00000020);        /** @brief TXFIFO empty clear flag */
    static const uint32_t UARTX_ICR_IDLECF_MASK = UINT32_C(0x00000010);        /** @brief Idle line detected clear flag */
    static const uint32_t UARTX_ICR_ORECF_MASK = UINT32_C(0x00000008);         /** @brief Overrun error clear flag */
    static const uint32_t UARTX_ICR_NCF_MASK = UINT32_C(0x00000004);           /** @brief Noise detected clear flag */
    static const uint32_t UARTX_ICR_FECF_MASK = UINT32_C(0x00000002);          /** @brief Framing error clear flag */
    static const uint32_t UARTX_ICR_PECF_MASK = UINT32_C(0x00000001);          /** @brief Parity error clear flag */
    static const uint32_t UARTX_RDR_RDR_MASK = UINT32_C(0x000001FF);           /** @brief Receive data value */
    static const uint32_t UARTX_TDR_TDR_MASK = UINT32_C(0x000001FF);           /** @brief Transmit data value */
    static const uint32_t UARTX_PRESC_PRESCALER_MASK = UINT32_C(0x0000000F);   /** @brief Clock prescaler */

    /** @subsection UARTX field position array definitions */

    static const int32_t UARTX_PRESC_DEATX_POS[5] = {
      INT32_C(21),   /** @brief DEAT0 */
      INT32_C(22),   /** @brief DEAT1 */
      INT32_C(23),   /** @brief DEAT2 */
      INT32_C(24),   /** @brief DEAT3 */
      INT32_C(25),   /** @brief Driver enable assertion time */
    };

    static const int32_t UARTX_PRESC_DEDTX_POS[5] = {
      INT32_C(16),   /** @brief DEDT0 */
      INT32_C(17),   /** @brief DEDT1 */
      INT32_C(18),   /** @brief DEDT2 */
      INT32_C(19),   /** @brief DEDT3 */
      INT32_C(20),   /** @brief Driver enable de-assertion time */
    };

    /** @subsection UARTX field position definitions */

    static const int32_t UARTX_PRESC_RXFFIE_POS = INT32_C(31);      /** @brief RXFIFO full interrupt enable */
    static const int32_t UARTX_PRESC_TXFEIE_POS = INT32_C(30);      /** @brief TXFIFO empty interrupt enable */
    static const int32_t UARTX_PRESC_FIFOEN_POS = INT32_C(29);      /** @brief FIFO mode enable */
    static const int32_t UARTX_PRESC_M1_POS = INT32_C(28);          /** @brief Word length */
    static const int32_t UARTX_PRESC_EOBIE_POS = INT32_C(27);       /** @brief End of block interrupt enable */
    static const int32_t UARTX_PRESC_RTOIE_POS = INT32_C(26);       /** @brief Receiver timeout interrupt enable */
    static const int32_t UARTX_PRESC_OVER8_POS = INT32_C(15);       /** @brief Oversampling mode */
    static const int32_t UARTX_PRESC_CMIE_POS = INT32_C(14);        /** @brief Character match interrupt enable */
    static const int32_t UARTX_PRESC_MME_POS = INT32_C(13);         /** @brief Mute mode enable */
    static const int32_t UARTX_PRESC_M0_POS = INT32_C(12);          /** @brief Word length */
    static const int32_t UARTX_PRESC_WAKE_POS = INT32_C(11);        /** @brief Receiver wakeup method */
    static const int32_t UARTX_PRESC_PCE_POS = INT32_C(10);         /** @brief Parity control enable */
    static const int32_t UARTX_PRESC_PS_POS = INT32_C(9);           /** @brief Parity selection */
    static const int32_t UARTX_PRESC_PEIE_POS = INT32_C(8);         /** @brief PE interrupt enable */
    static const int32_t UARTX_PRESC_TXEIE_POS = INT32_C(7);        /** @brief Interrupt enable */
    static const int32_t UARTX_PRESC_TCIE_POS = INT32_C(6);         /** @brief Transmission complete interrupt enable */
    static const int32_t UARTX_PRESC_RXNEIE_POS = INT32_C(5);       /** @brief RXNE interrupt enable */
    static const int32_t UARTX_PRESC_IDLEIE_POS = INT32_C(4);       /** @brief IDLE interrupt enable */
    static const int32_t UARTX_PRESC_TE_POS = INT32_C(3);           /** @brief Transmitter enable */
    static const int32_t UARTX_PRESC_RE_POS = INT32_C(2);           /** @brief Receiver enable */
    static const int32_t UARTX_PRESC_UESM_POS = INT32_C(1);         /** @brief USART enable in stop mode */
    static const int32_t UARTX_PRESC_UE_POS = INT32_C(0);           /** @brief USART enable */
    static const int32_t UARTX_PRESC_ADD4_7_POS = INT32_C(28);      /** @brief Address of the USART node */
    static const int32_t UARTX_PRESC_ADD0_3_POS = INT32_C(24);      /** @brief Address of the USART node */
    static const int32_t UARTX_PRESC_RTOEN_POS = INT32_C(23);       /** @brief Receiver timeout enable */
    static const int32_t UARTX_PRESC_ABRMOD1_POS = INT32_C(22);     /** @brief Auto baud rate mode */
    static const int32_t UARTX_PRESC_ABRMOD0_POS = INT32_C(21);     /** @brief ABRMOD0 */
    static const int32_t UARTX_PRESC_ABREN_POS = INT32_C(20);       /** @brief Auto baud rate enable */
    static const int32_t UARTX_PRESC_MSBFIRST_POS = INT32_C(19);    /** @brief Most significant bit first */
    static const int32_t UARTX_PRESC_TAINV_POS = INT32_C(18);       /** @brief Binary data inversion */
    static const int32_t UARTX_PRESC_TXINV_POS = INT32_C(17);       /** @brief TX pin active level inversion */
    static const int32_t UARTX_PRESC_RXINV_POS = INT32_C(16);       /** @brief RX pin active level inversion */
    static const int32_t UARTX_PRESC_SWAP_POS = INT32_C(15);        /** @brief Swap TX/RX pins */
    static const int32_t UARTX_PRESC_LINEN_POS = INT32_C(14);       /** @brief LIN mode enable */
    static const int32_t UARTX_PRESC_STOP_POS = INT32_C(12);        /** @brief STOP bits */
    static const int32_t UARTX_PRESC_CLKEN_POS = INT32_C(11);       /** @brief Clock enable */
    static const int32_t UARTX_PRESC_CPOL_POS = INT32_C(10);        /** @brief Clock polarity */
    static const int32_t UARTX_PRESC_CPHA_POS = INT32_C(9);         /** @brief Clock phase */
    static const int32_t UARTX_PRESC_LBCL_POS = INT32_C(8);         /** @brief Last bit clock pulse */
    static const int32_t UARTX_PRESC_LBDIE_POS = INT32_C(6);        /** @brief LIN break detection interrupt enable */
    static const int32_t UARTX_PRESC_LBDL_POS = INT32_C(5);         /** @brief LIN break detection length */
    static const int32_t UARTX_PRESC_ADDM7_POS = INT32_C(4);        /** @brief 7-bit address detection/4-bit address detection */
    static const int32_t UARTX_PRESC_DIS_NSS_POS = INT32_C(3);      /** @brief When the DSI_NSS bit is set, the NSS pin input is ignored */
    static const int32_t UARTX_PRESC_SLVEN_POS = INT32_C(0);        /** @brief Synchronous slave mode enable */
    static const int32_t UARTX_PRESC_TXFTCFG_POS = INT32_C(29);     /** @brief TXFIFO threshold configuration */
    static const int32_t UARTX_PRESC_RXFTIE_POS = INT32_C(28);      /** @brief RXFIFO threshold interrupt enable */
    static const int32_t UARTX_PRESC_RXFTCFG_POS = INT32_C(25);     /** @brief Receive FIFO threshold configuration */
    static const int32_t UARTX_PRESC_TCBGTIE_POS = INT32_C(24);     /** @brief Transmission complete before guard time, interrupt enable */
    static const int32_t UARTX_PRESC_TXFTIE_POS = INT32_C(23);      /** @brief TXFIFO threshold interrupt enable */
    static const int32_t UARTX_PRESC_WUFIE_POS = INT32_C(22);       /** @brief Wakeup from stop mode interrupt enable */
    static const int32_t UARTX_PRESC_WUS_POS = INT32_C(20);         /** @brief Wakeup from stop mode interrupt flag selection */
    static const int32_t UARTX_PRESC_SCARCNT_POS = INT32_C(17);     /** @brief Smartcard auto-retry count */
    static const int32_t UARTX_PRESC_DEP_POS = INT32_C(15);         /** @brief Driver enable polarity selection */
    static const int32_t UARTX_PRESC_DEM_POS = INT32_C(14);         /** @brief Driver enable mode */
    static const int32_t UARTX_PRESC_DDRE_POS = INT32_C(13);        /** @brief DMA disable on reception error */
    static const int32_t UARTX_PRESC_OVRDIS_POS = INT32_C(12);      /** @brief Overrun disable */
    static const int32_t UARTX_PRESC_ONEBIT_POS = INT32_C(11);      /** @brief One sample bit method enable */
    static const int32_t UARTX_PRESC_CTSIE_POS = INT32_C(10);       /** @brief CTS interrupt enable */
    static const int32_t UARTX_PRESC_CTSE_POS = INT32_C(9);         /** @brief CTS enable */
    static const int32_t UARTX_PRESC_RTSE_POS = INT32_C(8);         /** @brief RTS enable */
    static const int32_t UARTX_PRESC_DMAT_POS = INT32_C(7);         /** @brief DMA enable transmitter */
    static const int32_t UARTX_PRESC_DMAR_POS = INT32_C(6);         /** @brief DMA enable receiver */
    static const int32_t UARTX_PRESC_SCEN_POS = INT32_C(5);         /** @brief Smartcard mode enable */
    static const int32_t UARTX_PRESC_NACK_POS = INT32_C(4);         /** @brief Smartcard NACK enable */
    static const int32_t UARTX_PRESC_HDSEL_POS = INT32_C(3);        /** @brief Half-duplex selection */
    static const int32_t UARTX_PRESC_IRLP_POS = INT32_C(2);         /** @brief Ir low-power */
    static const int32_t UARTX_PRESC_IREN_POS = INT32_C(1);         /** @brief Ir mode enable */
    static const int32_t UARTX_PRESC_EIE_POS = INT32_C(0);          /** @brief Error interrupt enable */
    static const int32_t UARTX_PRESC_BRR_4_15_POS = INT32_C(4);     /** @brief DIV_Mantissa */
    static const int32_t UARTX_PRESC_BRR_0_3_POS = INT32_C(0);      /** @brief DIV_Fraction */
    static const int32_t UARTX_PRESC_GT_POS = INT32_C(8);           /** @brief Guard time value */
    static const int32_t UARTX_PRESC_PSC_POS = INT32_C(0);          /** @brief Prescaler value */
    static const int32_t UARTX_PRESC_BLEN_POS = INT32_C(24);        /** @brief Block length */
    static const int32_t UARTX_PRESC_RTO_POS = INT32_C(0);          /** @brief Receiver timeout value */
    static const int32_t UARTX_PRESC_TXFRQ_POS = INT32_C(4);        /** @brief Transmit data flush request */
    static const int32_t UARTX_PRESC_RXFRQ_POS = INT32_C(3);        /** @brief Receive data flush request */
    static const int32_t UARTX_PRESC_MMRQ_POS = INT32_C(2);         /** @brief Mute mode request */
    static const int32_t UARTX_PRESC_SBKRQ_POS = INT32_C(1);        /** @brief Send break request */
    static const int32_t UARTX_PRESC_ABRRQ_POS = INT32_C(0);        /** @brief Auto baud rate request */
    static const int32_t UARTX_PRESC_TXFT_POS = INT32_C(27);        /** @brief TXFIFO threshold flag */
    static const int32_t UARTX_PRESC_RXFT_POS = INT32_C(26);        /** @brief RXFIFO threshold flag */
    static const int32_t UARTX_PRESC_TCBGT_POS = INT32_C(25);       /** @brief Transmission complete before guard time flag */
    static const int32_t UARTX_PRESC_RXFF_POS = INT32_C(24);        /** @brief RXFIFO full */
    static const int32_t UARTX_PRESC_TXFE_POS = INT32_C(23);        /** @brief TXFIFO empty */
    static const int32_t UARTX_PRESC_REACK_POS = INT32_C(22);       /** @brief REACK */
    static const int32_t UARTX_PRESC_TEACK_POS = INT32_C(21);       /** @brief TEACK */
    static const int32_t UARTX_PRESC_WUF_POS = INT32_C(20);         /** @brief WUF */
    static const int32_t UARTX_PRESC_RWU_POS = INT32_C(19);         /** @brief RWU */
    static const int32_t UARTX_PRESC_SBKF_POS = INT32_C(18);        /** @brief SBKF */
    static const int32_t UARTX_PRESC_CMF_POS = INT32_C(17);         /** @brief CMF */
    static const int32_t UARTX_PRESC_BUSY_POS = INT32_C(16);        /** @brief BUSY */
    static const int32_t UARTX_PRESC_ABRF_POS = INT32_C(15);        /** @brief ABRF */
    static const int32_t UARTX_PRESC_ABRE_POS = INT32_C(14);        /** @brief ABRE */
    static const int32_t UARTX_PRESC_UDR_POS = INT32_C(13);         /** @brief SPI slave underrun error flag */
    static const int32_t UARTX_PRESC_EOBF_POS = INT32_C(12);        /** @brief EOBF */
    static const int32_t UARTX_PRESC_RTOF_POS = INT32_C(11);        /** @brief RTOF */
    static const int32_t UARTX_PRESC_CTS_POS = INT32_C(10);         /** @brief CTS */
    static const int32_t UARTX_PRESC_CTSIF_POS = INT32_C(9);        /** @brief CTSIF */
    static const int32_t UARTX_PRESC_LBDF_POS = INT32_C(8);         /** @brief LBDF */
    static const int32_t UARTX_PRESC_TXE_POS = INT32_C(7);          /** @brief TXE */
    static const int32_t UARTX_PRESC_TC_POS = INT32_C(6);           /** @brief TC */
    static const int32_t UARTX_PRESC_RXNE_POS = INT32_C(5);         /** @brief RXNE */
    static const int32_t UARTX_PRESC_IDLE_POS = INT32_C(4);         /** @brief IDLE */
    static const int32_t UARTX_PRESC_ORE_POS = INT32_C(3);          /** @brief ORE */
    static const int32_t UARTX_PRESC_NF_POS = INT32_C(2);           /** @brief NF */
    static const int32_t UARTX_PRESC_FE_POS = INT32_C(1);           /** @brief FE */
    static const int32_t UARTX_PRESC_PE_POS = INT32_C(0);           /** @brief PE */
    static const int32_t UARTX_PRESC_WUCF_POS = INT32_C(20);        /** @brief Wakeup from stop mode clear flag */
    static const int32_t UARTX_PRESC_CMCF_POS = INT32_C(17);        /** @brief Character match clear flag */
    static const int32_t UARTX_PRESC_UDRCF_POS = INT32_C(13);       /** @brief SPI slave underrun clear flag */
    static const int32_t UARTX_PRESC_EOBCF_POS = INT32_C(12);       /** @brief End of block clear flag */
    static const int32_t UARTX_PRESC_RTOCF_POS = INT32_C(11);       /** @brief Receiver timeout clear flag */
    static const int32_t UARTX_PRESC_CTSCF_POS = INT32_C(9);        /** @brief CTS clear flag */
    static const int32_t UARTX_PRESC_LBDCF_POS = INT32_C(8);        /** @brief LIN break detection clear flag */
    static const int32_t UARTX_PRESC_TCBGTC_POS = INT32_C(7);       /** @brief Transmission complete before guard time clear flag */
    static const int32_t UARTX_PRESC_TCCF_POS = INT32_C(6);         /** @brief Transmission complete clear flag */
    static const int32_t UARTX_PRESC_TXFECF_POS = INT32_C(5);       /** @brief TXFIFO empty clear flag */
    static const int32_t UARTX_PRESC_IDLECF_POS = INT32_C(4);       /** @brief Idle line detected clear flag */
    static const int32_t UARTX_PRESC_ORECF_POS = INT32_C(3);        /** @brief Overrun error clear flag */
    static const int32_t UARTX_PRESC_NCF_POS = INT32_C(2);          /** @brief Noise detected clear flag */
    static const int32_t UARTX_PRESC_FECF_POS = INT32_C(1);         /** @brief Framing error clear flag */
    static const int32_t UARTX_PRESC_PECF_POS = INT32_C(0);         /** @brief Parity error clear flag */
    static const int32_t UARTX_PRESC_RDR_POS = INT32_C(0);          /** @brief Receive data value */
    static const int32_t UARTX_PRESC_TDR_POS = INT32_C(0);          /** @brief Transmit data value */
    static const int32_t UARTX_PRESC_PRESCALER_POS = INT32_C(0);    /** @brief Clock prescaler */

    /**********************************************************************************************
     * @section TIMX Definitions
     **********************************************************************************************/

    /** @subsection TIMX IRQ interrupt definitions */

    static const int32_t TIM1_BRK_IRQ = INT32_C(24);       /** @brief TIM1 break interrupt */
    static const int32_t TIM1_UP_IRQ = INT32_C(25);        /** @brief TIM1 update interrupt */
    static const int32_t TIM1_TRG_COM_IRQ = INT32_C(26);   /** @brief TIM1 trigger and commutation */
    static const int32_t TIM_CC_IRQ = INT32_C(27);         /** @brief TIM1 capture / compare */

    /** @subsection TIMX register array definitions */

    static _RW uint32_t* const TIMX_CR1_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010000),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000000),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000400),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000800),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000C00),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40001000),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40001400),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40010400),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001800),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40001C00),   /** @brief Control register 1 */
      (_RW uint32_t* const)UINT32_C(0x40002000),   /** @brief Control register 1 */
    };

    static _RW uint32_t* const TIMX_CR2_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010004),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40000004),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40000404),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40000804),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40000C04),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40001004),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40001404),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40010404),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001804),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40001C04),   /** @brief Control register 2 */
      (_RW uint32_t* const)UINT32_C(0x40002004),   /** @brief Control register 2 */
    };

    static _RW uint32_t* const TIMX_SMCR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010008),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x40000008),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x40000408),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x40000808),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x40000C08),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010408),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001808),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x40001C08),   /** @brief Slave mode control register */
      (_RW uint32_t* const)UINT32_C(0x40002008),   /** @brief Slave mode control register */
    };

    static _RW uint32_t* const TIMX_DIER_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001000C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000000C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000040C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000080C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x40000C0C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000100C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000140C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4001040C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000180C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x40001C0C),   /** @brief DMA/Interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000200C),   /** @brief DMA/Interrupt enable register */
    };

    static _RW uint32_t* const TIMX_SR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010010),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40000010),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40000410),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40000810),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40000C10),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40001010),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40001410),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40010410),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001810),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40001C10),   /** @brief Status register */
      (_RW uint32_t* const)UINT32_C(0x40002010),   /** @brief Status register */
    };

    static _RW uint32_t* const TIMX_EGR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010014),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40000014),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40000414),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40000814),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40000C14),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40001014),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40001414),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40010414),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001814),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40001C14),   /** @brief Event generation register */
      (_RW uint32_t* const)UINT32_C(0x40002014),   /** @brief Event generation register */
    };

    static _RW uint32_t* const TIMX_CCMR1_OUTPUT_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010018),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000018),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000418),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000818),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000C18),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010418),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001818),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40001C18),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40002018),   /** @brief Capture/compare mode register 1 (output mode) */
    };

    static _RW uint32_t* const TIMX_CCMR1_INPUT_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010018),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000018),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000418),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000818),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000C18),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010418),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001818),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40001C18),   /** @brief Capture/compare mode register 1 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40002018),   /** @brief Capture/compare mode register 1 (output mode) */
    };

    static _RW uint32_t* const TIMX_CCMR2_OUTPUT_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001001C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000001C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000041C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000081C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000C1C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001041C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000181C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40001C1C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000201C),   /** @brief Capture/compare mode register 2 (output mode) */
    };

    static _RW uint32_t* const TIMX_CCMR2_INPUT_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001001C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000001C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000041C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000081C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40000C1C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001041C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000181C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x40001C1C),   /** @brief Capture/compare mode register 2 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x4000201C),   /** @brief Capture/compare mode register 2 (output mode) */
    };

    static _RW uint32_t* const TIMX_CCER_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010020),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x40000020),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x40000420),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x40000820),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x40000C20),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010420),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001820),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x40001C20),   /** @brief Capture/compare enable register */
      (_RW uint32_t* const)UINT32_C(0x40002020),   /** @brief Capture/compare enable register */
    };

    static _RW uint32_t* const TIMX_CNT_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010024),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40000024),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40000424),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40000824),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40000C24),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40001024),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40001424),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40010424),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001824),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40001C24),   /** @brief Counter */
      (_RW uint32_t* const)UINT32_C(0x40002024),   /** @brief Counter */
    };

    static _RW uint32_t* const TIMX_PSC_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010028),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40000028),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40000428),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40000828),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40000C28),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40001028),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40001428),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40010428),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001828),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40001C28),   /** @brief Prescaler */
      (_RW uint32_t* const)UINT32_C(0x40002028),   /** @brief Prescaler */
    };

    static _RW uint32_t* const TIMX_ARR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001002C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4000002C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4000042C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4000082C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x40000C2C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4000102C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4000142C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4001042C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000182C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x40001C2C),   /** @brief Auto-reload register */
      (_RW uint32_t* const)UINT32_C(0x4000202C),   /** @brief Auto-reload register */
    };

    static _RW uint32_t* const TIMX_CCRX_REG[15][6] = {
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40010034),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40010038),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x4001003C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40010040),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x40010058),   /** @brief Capture/compare register 5 */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40000034),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40000038),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x4000003C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40000040),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40000434),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40000438),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x4000043C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40000440),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40000834),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40000838),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x4000083C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40000840),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40000C34),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40000C38),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x40000C3C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40000C40),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40010434),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40010438),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x4001043C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40010440),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x40010458),   /** @brief Capture/compare register 5 */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40001834),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40001838),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x4000183C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40001840),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40001C34),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40001C38),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x40001C3C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40001C40),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
      {
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
        (_RW uint32_t* const)UINT32_C(0x40002034),   /** @brief Capture/compare register 1 */
        (_RW uint32_t* const)UINT32_C(0x40002038),   /** @brief Capture/compare register 2 */
        (_RW uint32_t* const)UINT32_C(0x4000203C),   /** @brief Capture/compare register 3 */
        (_RW uint32_t* const)UINT32_C(0x40002040),   /** @brief Capture/compare register 4 */
        (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      },
    };

    static _RW uint32_t* const TIMX_DCR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010048),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x40000048),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x40000448),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x40000848),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x40000C48),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010448),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001848),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x40001C48),   /** @brief DMA control register */
      (_RW uint32_t* const)UINT32_C(0x40002048),   /** @brief DMA control register */
    };

    static _RW uint32_t* const TIMX_DMAR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001004C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x4000004C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x4000044C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x4000084C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x40000C4C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001044C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000184C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x40001C4C),   /** @brief DMA address for full transfer */
      (_RW uint32_t* const)UINT32_C(0x4000204C),   /** @brief DMA address for full transfer */
    };

    static _RW uint32_t* const TIMX_RCR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010030),   /** @brief Repetition counter register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010430),   /** @brief Repetition counter register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static _RW uint32_t* const TIMX_BDTR_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010044),   /** @brief Break and dead-time register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010444),   /** @brief Break and dead-time register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static _RW uint32_t* const TIMX_CCMR3_OUTPUT_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010054),   /** @brief Capture/compare mode register 3 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010454),   /** @brief Capture/compare mode register 3 (output mode) */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static _RW uint32_t* const TIMX_CRR6_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001005C),   /** @brief Capture/compare register 6 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4001045C),   /** @brief Capture/compare register 6 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static _RW uint32_t* const TIMX_AF1_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010060),   /** @brief TIM1 alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000060),   /** @brief TIM alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000460),   /** @brief TIM alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000860),   /** @brief TIM alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x40000C60),   /** @brief TIM alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010460),   /** @brief TIM1 alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001860),   /** @brief TIM alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x40001C60),   /** @brief TIM alternate function option register 1 */
      (_RW uint32_t* const)UINT32_C(0x40002060),   /** @brief TIM alternate function option register 1 */
    };

    static _RW uint32_t* const TIMX_AF2_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010064),   /** @brief TIM1 alternate function odfsdm1_breakster 2 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010464),   /** @brief TIM1 alternate function odfsdm1_breakster 2 */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
    };

    static _RW uint32_t* const TIMX_TISEL_REG[15] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010068),   /** @brief TIM1 timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x40000068),   /** @brief TIM timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x40000468),   /** @brief TIM timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x40000868),   /** @brief TIM timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x40000C68),   /** @brief TIM timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40010468),   /** @brief TIM1 timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x40001868),   /** @brief TIM timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x40001C68),   /** @brief TIM timer input selection register */
      (_RW uint32_t* const)UINT32_C(0x40002068),   /** @brief TIM timer input selection register */
    };

    /** @subsection TIMX field mask array definitions */

    static const uint32_t TIMX_CR2_OISX_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000100),   /** @brief Output idle state 1 */
      UINT32_C(0x00000400),   /** @brief Output idle state 2 */
      UINT32_C(0x00001000),   /** @brief Output idle state 3 */
      UINT32_C(0x00004000),   /** @brief Output idle state 4 */
      UINT32_C(0x00010000),   /** @brief Output idle state 5 */
      UINT32_C(0x00040000),   /** @brief Output idle state 6 */
    };

    static const uint32_t TIMX_CR2_OISXN_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief Output idle state 1 */
      UINT32_C(0x00000800),   /** @brief Output idle state 2 */
      UINT32_C(0x00002000),   /** @brief Output idle state 3 */
    };

    static const uint32_t TIMX_DIER_CCXDE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief Capture/Compare 1 DMA request enable */
      UINT32_C(0x00000400),   /** @brief Capture/Compare 2 DMA request enable */
      UINT32_C(0x00000800),   /** @brief Capture/Compare 3 DMA request enable */
      UINT32_C(0x00001000),   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const uint32_t TIMX_DIER_CCXIE_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief Capture/Compare 1 interrupt enable */
      UINT32_C(0x00000004),   /** @brief Capture/Compare 2 interrupt enable */
      UINT32_C(0x00000008),   /** @brief Capture/Compare 3 interrupt enable */
      UINT32_C(0x00000010),   /** @brief Capture/Compare 4 interrupt enable */
    };

    static const uint32_t TIMX_SR_CCXIF_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief Capture/compare 1 interrupt flag */
      UINT32_C(0x00000004),   /** @brief Capture/Compare 2 interrupt flag */
      UINT32_C(0x00000008),   /** @brief Capture/Compare 3 interrupt flag */
      UINT32_C(0x00000010),   /** @brief Capture/Compare 4 interrupt flag */
      UINT32_C(0x00010000),   /** @brief Compare 5 interrupt flag */
      UINT32_C(0x00020000),   /** @brief Compare 6 interrupt flag */
    };

    static const uint32_t TIMX_SR_CCXOF_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000200),   /** @brief Capture/Compare 1 overcapture flag */
      UINT32_C(0x00000400),   /** @brief Capture/compare 2 overcapture flag */
      UINT32_C(0x00000800),   /** @brief Capture/Compare 3 overcapture flag */
      UINT32_C(0x00001000),   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const uint32_t TIMX_EGR_CCXG_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief Capture/compare 1 generation */
      UINT32_C(0x00000004),   /** @brief Capture/compare 2 generation */
      UINT32_C(0x00000008),   /** @brief Capture/compare 3 generation */
      UINT32_C(0x00000010),   /** @brief Capture/compare 4 generation */
    };

    static const uint32_t TIMX_CCER_CCXE_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000001),   /** @brief Capture/Compare 1 output enable */
      UINT32_C(0x00000010),   /** @brief Capture/Compare 2 output enable */
      UINT32_C(0x00000100),   /** @brief Capture/Compare 3 output enable */
      UINT32_C(0x00001000),   /** @brief Capture/Compare 4 output enable */
      UINT32_C(0x00010000),   /** @brief Capture/Compare 5 output enable */
      UINT32_C(0x00100000),   /** @brief Capture/Compare 6 output enable */
    };

    static const uint32_t TIMX_CCER_CCXP_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief Capture/Compare 1 output polarity */
      UINT32_C(0x00000020),   /** @brief Capture/Compare 2 output polarity */
      UINT32_C(0x00000200),   /** @brief Capture/Compare 3 output polarity */
      UINT32_C(0x00002000),   /** @brief Capture/Compare 3 output polarity */
      UINT32_C(0x00020000),   /** @brief Capture/Compare 5 output polarity */
      UINT32_C(0x00200000),   /** @brief Capture/Compare 6 output polarity */
    };

    static const uint32_t TIMX_CCER_CCXNE_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000004),   /** @brief Capture/Compare 1 complementary output enable */
      UINT32_C(0x00000040),   /** @brief Capture/Compare 2 complementary output enable */
      UINT32_C(0x00000400),   /** @brief Capture/Compare 3 complementary output enable */
    };

    static const uint32_t TIMX_CCER_CCXNP_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000008),   /** @brief Capture/Compare 1 output polarity */
      UINT32_C(0x00000080),   /** @brief Capture/Compare 2 output polarity */
      UINT32_C(0x00000800),   /** @brief Capture/Compare 3 output polarity */
      UINT32_C(0x00008000),   /** @brief Capture/Compare 4 complementary output polarity */
    };

    static const uint32_t TIMX_CCRX_GC5CX_MASK[4] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x20000000),   /** @brief Group channel 5 and channel 1 */
      UINT32_C(0x40000000),   /** @brief Group channel 5 and channel 2 */
      UINT32_C(0x80000000),   /** @brief Group channel 5 and channel 3 */
    };

    static const uint32_t TIMX_TISEL_TIXSEL_MASK[5] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x0000000F),   /** @brief Selects TI1[0] to TI1[15] input */
      UINT32_C(0x00000F00),   /** @brief Selects TI2[0] to TI2[15] input */
      UINT32_C(0x000F0000),   /** @brief Selects TI3[0] to TI3[15] input */
      UINT32_C(0x0F000000),   /** @brief Selects TI4[0] to TI4[15] input */
    };

    /** @subsection TIMX field mask definitions */

    static const uint32_t TIMX_CR1_CEN_MASK = UINT32_C(0x00000001);               /** @brief Counter enable */
    static const uint32_t TIMX_CR1_UDIS_MASK = UINT32_C(0x00000002);              /** @brief Update disable */
    static const uint32_t TIMX_CR1_URS_MASK = UINT32_C(0x00000004);               /** @brief Update request source */
    static const uint32_t TIMX_CR1_OPM_MASK = UINT32_C(0x00000008);               /** @brief One-pulse mode */
    static const uint32_t TIMX_CR1_DIR_MASK = UINT32_C(0x00000010);               /** @brief Direction */
    static const uint32_t TIMX_CR1_CMS_MASK = UINT32_C(0x00000060);               /** @brief Center-aligned mode selection */
    static const uint32_t TIMX_CR1_ARPE_MASK = UINT32_C(0x00000080);              /** @brief Auto-reload preload enable */
    static const uint32_t TIMX_CR1_CKD_MASK = UINT32_C(0x00000300);               /** @brief Clock division */
    static const uint32_t TIMX_CR1_UIFREMAP_MASK = UINT32_C(0x00000800);          /** @brief UIF status bit remapping */
    static const uint32_t TIMX_CR2_MMS2_MASK = UINT32_C(0x00F00000);              /** @brief Master mode selection 2 */
    static const uint32_t TIMX_CR2_TI1S_MASK = UINT32_C(0x00000080);              /** @brief TI1 selection */
    static const uint32_t TIMX_CR2_MMS_MASK = UINT32_C(0x00000070);               /** @brief Master mode selection */
    static const uint32_t TIMX_CR2_CCDS_MASK = UINT32_C(0x00000008);              /** @brief Capture/compare DMA selection */
    static const uint32_t TIMX_CR2_CCUS_MASK = UINT32_C(0x00000004);              /** @brief Capture/compare control update selection */
    static const uint32_t TIMX_CR2_CCPC_MASK = UINT32_C(0x00000001);              /** @brief Capture/compare preloaded control */
    static const uint32_t TIMX_SMCR_SMS_MASK = UINT32_C(0x00000007);              /** @brief Slave mode selection */
    static const uint32_t TIMX_SMCR_TS_MASK = UINT32_C(0x00000070);               /** @brief Trigger selection */
    static const uint32_t TIMX_SMCR_MSM_MASK = UINT32_C(0x00000080);              /** @brief Master/Slave mode */
    static const uint32_t TIMX_SMCR_ETF_MASK = UINT32_C(0x00000F00);              /** @brief External trigger filter */
    static const uint32_t TIMX_SMCR_ETPS_MASK = UINT32_C(0x00003000);             /** @brief External trigger prescaler */
    static const uint32_t TIMX_SMCR_ECE_MASK = UINT32_C(0x00004000);              /** @brief External clock enable */
    static const uint32_t TIMX_SMCR_ETP_MASK = UINT32_C(0x00008000);              /** @brief External trigger polarity */
    static const uint32_t TIMX_SMCR_SMS_3_MASK = UINT32_C(0x00010000);            /** @brief Slave mode selection - bit 3 */
    static const uint32_t TIMX_SMCR_TS_4_3_MASK = UINT32_C(0x00300000);           /** @brief Trigger selection - bit 4:3 */
    static const uint32_t TIMX_DIER_TDE_MASK = UINT32_C(0x00004000);              /** @brief Trigger DMA request enable */
    static const uint32_t TIMX_DIER_COMDE_MASK = UINT32_C(0x00002000);            /** @brief COM DMA request enable */
    static const uint32_t TIMX_DIER_UDE_MASK = UINT32_C(0x00000100);              /** @brief Update DMA request enable */
    static const uint32_t TIMX_DIER_TIE_MASK = UINT32_C(0x00000040);              /** @brief Trigger interrupt enable */
    static const uint32_t TIMX_DIER_UIE_MASK = UINT32_C(0x00000001);              /** @brief Update interrupt enable */
    static const uint32_t TIMX_DIER_BIE_MASK = UINT32_C(0x00000080);              /** @brief Break interrupt enable */
    static const uint32_t TIMX_DIER_COMIE_MASK = UINT32_C(0x00000020);            /** @brief COM interrupt enable */
    static const uint32_t TIMX_SR_SBIF_MASK = UINT32_C(0x00002000);               /** @brief System break interrupt flag */
    static const uint32_t TIMX_SR_B2IF_MASK = UINT32_C(0x00000100);               /** @brief Break 2 interrupt flag */
    static const uint32_t TIMX_SR_BIF_MASK = UINT32_C(0x00000080);                /** @brief Break interrupt flag */
    static const uint32_t TIMX_SR_TIF_MASK = UINT32_C(0x00000040);                /** @brief Trigger interrupt flag */
    static const uint32_t TIMX_SR_COMIF_MASK = UINT32_C(0x00000020);              /** @brief COM interrupt flag */
    static const uint32_t TIMX_SR_UIF_MASK = UINT32_C(0x00000001);                /** @brief Update interrupt flag */
    static const uint32_t TIMX_EGR_UG_MASK = UINT32_C(0x00000001);                /** @brief Update generation */
    static const uint32_t TIMX_EGR_COMG_MASK = UINT32_C(0x00000020);              /** @brief Capture/Compare control update generation */
    static const uint32_t TIMX_EGR_TG_MASK = UINT32_C(0x00000040);                /** @brief Trigger generation */
    static const uint32_t TIMX_EGR_BG_MASK = UINT32_C(0x00000080);                /** @brief Break generation */
    static const uint32_t TIMX_EGR_B2G_MASK = UINT32_C(0x00000100);               /** @brief Break 2 generation */
    static const uint32_t TIMX_CCMR1_OUTPUT_CC1S_MASK = UINT32_C(0x00000003);     /** @brief Capture/Compare 1 selection */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC1FE_MASK = UINT32_C(0x00000004);    /** @brief Output compare 1 fast enable */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC1PE_MASK = UINT32_C(0x00000008);    /** @brief Output compare 1 preload enable */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC1M_MASK = UINT32_C(0x00000070);     /** @brief Output compare 1 mode */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC1CE_MASK = UINT32_C(0x00000080);    /** @brief Output compare 1 clear enable */
    static const uint32_t TIMX_CCMR1_OUTPUT_CC2S_MASK = UINT32_C(0x00000300);     /** @brief Capture/Compare 2 selection */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC2FE_MASK = UINT32_C(0x00000400);    /** @brief Output compare 2 fast enable */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC2PE_MASK = UINT32_C(0x00000800);    /** @brief Output compare 2 preload enable */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC2M_MASK = UINT32_C(0x00007000);     /** @brief Output compare 2 mode */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC2CE_MASK = UINT32_C(0x00008000);    /** @brief Output compare 2 clear enable */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC1M_3_MASK = UINT32_C(0x00010000);   /** @brief Output compare 1 mode - bit 3 */
    static const uint32_t TIMX_CCMR1_OUTPUT_OC2M_3_MASK = UINT32_C(0x01000000);   /** @brief Output compare 2 mode - bit 3 */
    static const uint32_t TIMX_CCMR1_INPUT_IC2F_MASK = UINT32_C(0x0000F000);      /** @brief Input capture 2 filter */
    static const uint32_t TIMX_CCMR1_INPUT_IC2PCS_MASK = UINT32_C(0x00000C00);    /** @brief Input capture 2 prescaler */
    static const uint32_t TIMX_CCMR1_INPUT_CC2S_MASK = UINT32_C(0x00000300);      /** @brief Capture/Compare 2 selection */
    static const uint32_t TIMX_CCMR1_INPUT_IC1F_MASK = UINT32_C(0x000000F0);      /** @brief Input capture 1 filter */
    static const uint32_t TIMX_CCMR1_INPUT_ICPCS_MASK = UINT32_C(0x0000000C);     /** @brief Input capture 1 prescaler */
    static const uint32_t TIMX_CCMR1_INPUT_CC1S_MASK = UINT32_C(0x00000003);      /** @brief Capture/Compare 1 selection */
    static const uint32_t TIMX_CCMR2_OUTPUT_CC3S_MASK = UINT32_C(0x00000003);     /** @brief Capture/Compare 3 selection */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC3FE_MASK = UINT32_C(0x00000004);    /** @brief Output compare 3 fast enable */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC3PE_MASK = UINT32_C(0x00000008);    /** @brief Output compare 3 preload enable */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC3M_MASK = UINT32_C(0x00000070);     /** @brief Output compare 3 mode */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC3CE_MASK = UINT32_C(0x00000080);    /** @brief Output compare 3 clear enable */
    static const uint32_t TIMX_CCMR2_OUTPUT_CC4S_MASK = UINT32_C(0x00000300);     /** @brief Capture/Compare 4 selection */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC4FE_MASK = UINT32_C(0x00000400);    /** @brief Output compare 4 fast enable */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC4PE_MASK = UINT32_C(0x00000800);    /** @brief Output compare 4 preload enable */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC4M_MASK = UINT32_C(0x00007000);     /** @brief Output compare 4 mode */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC4CE_MASK = UINT32_C(0x00008000);    /** @brief Output compare 4 clear enable */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC3M_3_MASK = UINT32_C(0x00010000);   /** @brief Output compare 3 mode - bit 3 */
    static const uint32_t TIMX_CCMR2_OUTPUT_OC4M_4_MASK = UINT32_C(0x01000000);   /** @brief Output compare 4 mode - bit 3 */
    static const uint32_t TIMX_CCMR2_INPUT_IC4F_MASK = UINT32_C(0x0000F000);      /** @brief Input capture 4 filter */
    static const uint32_t TIMX_CCMR2_INPUT_IC4PSC_MASK = UINT32_C(0x00000C00);    /** @brief Input capture 4 prescaler */
    static const uint32_t TIMX_CCMR2_INPUT_CC4S_MASK = UINT32_C(0x00000300);      /** @brief Capture/Compare 4 selection */
    static const uint32_t TIMX_CCMR2_INPUT_IC3F_MASK = UINT32_C(0x000000F0);      /** @brief Input capture 3 filter */
    static const uint32_t TIMX_CCMR2_INPUT_IC3PSC_MASK = UINT32_C(0x0000000C);    /** @brief Input capture 3 prescaler */
    static const uint32_t TIMX_CCMR2_INPUT_CC3S_MASK = UINT32_C(0x00000003);      /** @brief Capture/compare 3 selection */
    static const uint32_t TIMX_CNT_CNT_MASK = UINT32_C(0x0000FFFF);               /** @brief Counter value */
    static const uint32_t TIMX_CNT_UIFCPY_MASK = UINT32_C(0x80000000);            /** @brief UIF copy */
    static const uint32_t TIMX_PSC_PSC_MASK = UINT32_C(0x0000FFFF);               /** @brief Prescaler value */
    static const uint32_t TIMX_ARR_ARR_MASK = UINT32_C(0x0000FFFF);               /** @brief Auto-reload value */
    static const uint32_t TIMX_CCRX_CCR1_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare 1 value */
    static const uint32_t TIMX_CCRX_CCR2_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare 2 value */
    static const uint32_t TIMX_CCRX_CCR3_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare value */
    static const uint32_t TIMX_CCRX_CCR4_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare value */
    static const uint32_t TIMX_DCR_DBL_MASK = UINT32_C(0x00001F00);               /** @brief DMA burst length */
    static const uint32_t TIMX_DCR_DBA_MASK = UINT32_C(0x0000001F);               /** @brief DMA base address */
    static const uint32_t TIMX_DMAR_DMAB_MASK = UINT32_C(0x0000FFFF);             /** @brief DMA register for burst accesses */
    static const uint32_t TIMX_RCR_REP_MASK = UINT32_C(0x000000FF);               /** @brief Repetition counter value */
    static const uint32_t TIMX_BDTR_DTG_MASK = UINT32_C(0x000000FF);              /** @brief Dead-time generator setup */
    static const uint32_t TIMX_BDTR_LOCK_MASK = UINT32_C(0x00000300);             /** @brief Lock configuration */
    static const uint32_t TIMX_BDTR_OSSI_MASK = UINT32_C(0x00000400);             /** @brief Off-state selection for idle mode */
    static const uint32_t TIMX_BDTR_OSSR_MASK = UINT32_C(0x00000800);             /** @brief Off-state selection for run mode */
    static const uint32_t TIMX_BDTR_BKE_MASK = UINT32_C(0x00001000);              /** @brief Break enable */
    static const uint32_t TIMX_BDTR_BKP_MASK = UINT32_C(0x00002000);              /** @brief Break polarity */
    static const uint32_t TIMX_BDTR_AOE_MASK = UINT32_C(0x00004000);              /** @brief Automatic output enable */
    static const uint32_t TIMX_BDTR_MOE_MASK = UINT32_C(0x00008000);              /** @brief Main output enable */
    static const uint32_t TIMX_BDTR_BKF_MASK = UINT32_C(0x000F0000);              /** @brief Break filter */
    static const uint32_t TIMX_BDTR_BK2F_MASK = UINT32_C(0x00F00000);             /** @brief Break 2 filter */
    static const uint32_t TIMX_BDTR_BK2E_MASK = UINT32_C(0x01000000);             /** @brief Break 2 enable */
    static const uint32_t TIMX_BDTR_BK2P_MASK = UINT32_C(0x02000000);             /** @brief Break 2 polarity */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC5FE_MASK = UINT32_C(0x00000004);    /** @brief Output compare 5 fast enable */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC5PE_MASK = UINT32_C(0x00000008);    /** @brief Output compare 5 preload enable */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC5M_MASK = UINT32_C(0x00000070);     /** @brief Output compare 5 mode */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC5CE_MASK = UINT32_C(0x00000080);    /** @brief Output compare 5 clear enable */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC6FE_MASK = UINT32_C(0x00000400);    /** @brief Output compare 6 fast enable */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC6PE_MASK = UINT32_C(0x00000800);    /** @brief Output compare 6 preload enable */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC6M_MASK = UINT32_C(0x00007000);     /** @brief Output compare 6 mode */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC6CE_MASK = UINT32_C(0x00008000);    /** @brief Output compare 6 clear enable */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC5M3_MASK = UINT32_C(0x00010000);    /** @brief Output compare 5 mode */
    static const uint32_t TIMX_CCMR3_OUTPUT_OC6M3_MASK = UINT32_C(0x01000000);    /** @brief Output compare 6 mode */
    static const uint32_t TIMX_CCRX_CCR5_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare 5 value */
    static const uint32_t TIMX_CRR6_CCR6_MASK = UINT32_C(0x0000FFFF);             /** @brief Capture/Compare 6 value */
    static const uint32_t TIMX_AF1_BKINE_MASK = UINT32_C(0x00000001);             /** @brief BRK BKIN input enable */
    static const uint32_t TIMX_AF1_BKCMP1E_MASK = UINT32_C(0x00000002);           /** @brief BRK COMP1 enable */
    static const uint32_t TIMX_AF1_BKCMP2E_MASK = UINT32_C(0x00000004);           /** @brief BRK COMP2 enable */
    static const uint32_t TIMX_AF1_BKDF1BK0E_MASK = UINT32_C(0x00000100);         /** @brief BRK dfsdm1_break[0] enable */
    static const uint32_t TIMX_AF1_BKINP_MASK = UINT32_C(0x00000200);             /** @brief BRK BKIN input polarity */
    static const uint32_t TIMX_AF1_BKCMP1P_MASK = UINT32_C(0x00000400);           /** @brief BRK COMP1 input polarity */
    static const uint32_t TIMX_AF1_BKCMP2P_MASK = UINT32_C(0x00000800);           /** @brief BRK COMP2 input polarity */
    static const uint32_t TIMX_AF1_ETRSEL_MASK = UINT32_C(0x0003C000);            /** @brief ETR source selection */
    static const uint32_t TIMX_AF2_BK2INE_MASK = UINT32_C(0x00000001);            /** @brief BRK2 BKIN input enable */
    static const uint32_t TIMX_AF2_BK2CMP1E_MASK = UINT32_C(0x00000002);          /** @brief BRK2 COMP1 enable */
    static const uint32_t TIMX_AF2_BK2CMP2E_MASK = UINT32_C(0x00000004);          /** @brief BRK2 COMP2 enable */
    static const uint32_t TIMX_AF2_BK2DF1BK1E_MASK = UINT32_C(0x00000100);        /** @brief BRK2 dfsdm1_break[1] enable */
    static const uint32_t TIMX_AF2_BK2INP_MASK = UINT32_C(0x00000200);            /** @brief BRK2 BKIN2 input polarity */
    static const uint32_t TIMX_AF2_BK2CMP1P_MASK = UINT32_C(0x00000400);          /** @brief BRK2 COMP1 input polarit */
    static const uint32_t TIMX_AF2_BK2CMP2P_MASK = UINT32_C(0x00000800);          /** @brief BRK2 COMP2 input polarity */

    /** @subsection TIMX field position array definitions */

    static const int32_t TIMX_TISEL_OISX_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(8),    /** @brief Output idle state 1 */
      INT32_C(10),   /** @brief Output idle state 2 */
      INT32_C(12),   /** @brief Output idle state 3 */
      INT32_C(14),   /** @brief Output idle state 4 */
      INT32_C(16),   /** @brief Output idle state 5 */
      INT32_C(18),   /** @brief Output idle state 6 */
    };

    static const int32_t TIMX_TISEL_OISXN_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief Output idle state 1 */
      INT32_C(11),   /** @brief Output idle state 2 */
      INT32_C(13),   /** @brief Output idle state 3 */
    };

    static const int32_t TIMX_TISEL_CCXDE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief Capture/Compare 1 DMA request enable */
      INT32_C(10),   /** @brief Capture/Compare 2 DMA request enable */
      INT32_C(11),   /** @brief Capture/Compare 3 DMA request enable */
      INT32_C(12),   /** @brief Capture/Compare 4 DMA request enable */
    };

    static const int32_t TIMX_TISEL_CCXIE_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief Capture/Compare 1 interrupt enable */
      INT32_C(2),    /** @brief Capture/Compare 2 interrupt enable */
      INT32_C(3),    /** @brief Capture/Compare 3 interrupt enable */
      INT32_C(4),    /** @brief Capture/Compare 4 interrupt enable */
    };

    static const int32_t TIMX_TISEL_CCXIF_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief Capture/compare 1 interrupt flag */
      INT32_C(2),    /** @brief Capture/Compare 2 interrupt flag */
      INT32_C(3),    /** @brief Capture/Compare 3 interrupt flag */
      INT32_C(4),    /** @brief Capture/Compare 4 interrupt flag */
      INT32_C(16),   /** @brief Compare 5 interrupt flag */
      INT32_C(17),   /** @brief Compare 6 interrupt flag */
    };

    static const int32_t TIMX_TISEL_CCXOF_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(9),    /** @brief Capture/Compare 1 overcapture flag */
      INT32_C(10),   /** @brief Capture/compare 2 overcapture flag */
      INT32_C(11),   /** @brief Capture/Compare 3 overcapture flag */
      INT32_C(12),   /** @brief Capture/Compare 4 overcapture flag */
    };

    static const int32_t TIMX_TISEL_CCXG_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief Capture/compare 1 generation */
      INT32_C(2),    /** @brief Capture/compare 2 generation */
      INT32_C(3),    /** @brief Capture/compare 3 generation */
      INT32_C(4),    /** @brief Capture/compare 4 generation */
    };

    static const int32_t TIMX_TISEL_CCXE_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Capture/Compare 1 output enable */
      INT32_C(4),    /** @brief Capture/Compare 2 output enable */
      INT32_C(8),    /** @brief Capture/Compare 3 output enable */
      INT32_C(12),   /** @brief Capture/Compare 4 output enable */
      INT32_C(16),   /** @brief Capture/Compare 5 output enable */
      INT32_C(20),   /** @brief Capture/Compare 6 output enable */
    };

    static const int32_t TIMX_TISEL_CCXP_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief Capture/Compare 1 output polarity */
      INT32_C(5),    /** @brief Capture/Compare 2 output polarity */
      INT32_C(9),    /** @brief Capture/Compare 3 output polarity */
      INT32_C(13),   /** @brief Capture/Compare 3 output polarity */
      INT32_C(17),   /** @brief Capture/Compare 5 output polarity */
      INT32_C(21),   /** @brief Capture/Compare 6 output polarity */
    };

    static const int32_t TIMX_TISEL_CCXNE_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(2),    /** @brief Capture/Compare 1 complementary output enable */
      INT32_C(6),    /** @brief Capture/Compare 2 complementary output enable */
      INT32_C(10),   /** @brief Capture/Compare 3 complementary output enable */
    };

    static const int32_t TIMX_TISEL_CCXNP_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(3),    /** @brief Capture/Compare 1 output polarity */
      INT32_C(7),    /** @brief Capture/Compare 2 output polarity */
      INT32_C(11),   /** @brief Capture/Compare 3 output polarity */
      INT32_C(15),   /** @brief Capture/Compare 4 complementary output polarity */
    };

    static const int32_t TIMX_TISEL_GC5CX_POS[4] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(29),   /** @brief Group channel 5 and channel 1 */
      INT32_C(30),   /** @brief Group channel 5 and channel 2 */
      INT32_C(31),   /** @brief Group channel 5 and channel 3 */
    };

    static const int32_t TIMX_TISEL_TIXSEL_POS[5] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Selects TI1[0] to TI1[15] input */
      INT32_C(8),    /** @brief Selects TI2[0] to TI2[15] input */
      INT32_C(16),   /** @brief Selects TI3[0] to TI3[15] input */
      INT32_C(24),   /** @brief Selects TI4[0] to TI4[15] input */
    };

    /** @subsection TIMX field position definitions */

    static const int32_t TIMX_TISEL_CEN_POS = INT32_C(0);           /** @brief Counter enable */
    static const int32_t TIMX_TISEL_UDIS_POS = INT32_C(1);          /** @brief Update disable */
    static const int32_t TIMX_TISEL_URS_POS = INT32_C(2);           /** @brief Update request source */
    static const int32_t TIMX_TISEL_OPM_POS = INT32_C(3);           /** @brief One-pulse mode */
    static const int32_t TIMX_TISEL_DIR_POS = INT32_C(4);           /** @brief Direction */
    static const int32_t TIMX_TISEL_CMS_POS = INT32_C(5);           /** @brief Center-aligned mode selection */
    static const int32_t TIMX_TISEL_ARPE_POS = INT32_C(7);          /** @brief Auto-reload preload enable */
    static const int32_t TIMX_TISEL_CKD_POS = INT32_C(8);           /** @brief Clock division */
    static const int32_t TIMX_TISEL_UIFREMAP_POS = INT32_C(11);     /** @brief UIF status bit remapping */
    static const int32_t TIMX_TISEL_MMS2_POS = INT32_C(20);         /** @brief Master mode selection 2 */
    static const int32_t TIMX_TISEL_TI1S_POS = INT32_C(7);          /** @brief TI1 selection */
    static const int32_t TIMX_TISEL_MMS_POS = INT32_C(4);           /** @brief Master mode selection */
    static const int32_t TIMX_TISEL_CCDS_POS = INT32_C(3);          /** @brief Capture/compare DMA selection */
    static const int32_t TIMX_TISEL_CCUS_POS = INT32_C(2);          /** @brief Capture/compare control update selection */
    static const int32_t TIMX_TISEL_CCPC_POS = INT32_C(0);          /** @brief Capture/compare preloaded control */
    static const int32_t TIMX_TISEL_SMS_POS = INT32_C(0);           /** @brief Slave mode selection */
    static const int32_t TIMX_TISEL_TS_POS = INT32_C(4);            /** @brief Trigger selection */
    static const int32_t TIMX_TISEL_MSM_POS = INT32_C(7);           /** @brief Master/Slave mode */
    static const int32_t TIMX_TISEL_ETF_POS = INT32_C(8);           /** @brief External trigger filter */
    static const int32_t TIMX_TISEL_ETPS_POS = INT32_C(12);         /** @brief External trigger prescaler */
    static const int32_t TIMX_TISEL_ECE_POS = INT32_C(14);          /** @brief External clock enable */
    static const int32_t TIMX_TISEL_ETP_POS = INT32_C(15);          /** @brief External trigger polarity */
    static const int32_t TIMX_TISEL_SMS_3_POS = INT32_C(16);        /** @brief Slave mode selection - bit 3 */
    static const int32_t TIMX_TISEL_TS_4_3_POS = INT32_C(20);       /** @brief Trigger selection - bit 4:3 */
    static const int32_t TIMX_TISEL_TDE_POS = INT32_C(14);          /** @brief Trigger DMA request enable */
    static const int32_t TIMX_TISEL_COMDE_POS = INT32_C(13);        /** @brief COM DMA request enable */
    static const int32_t TIMX_TISEL_UDE_POS = INT32_C(8);           /** @brief Update DMA request enable */
    static const int32_t TIMX_TISEL_TIE_POS = INT32_C(6);           /** @brief Trigger interrupt enable */
    static const int32_t TIMX_TISEL_UIE_POS = INT32_C(0);           /** @brief Update interrupt enable */
    static const int32_t TIMX_TISEL_BIE_POS = INT32_C(7);           /** @brief Break interrupt enable */
    static const int32_t TIMX_TISEL_COMIE_POS = INT32_C(5);         /** @brief COM interrupt enable */
    static const int32_t TIMX_TISEL_SBIF_POS = INT32_C(13);         /** @brief System break interrupt flag */
    static const int32_t TIMX_TISEL_B2IF_POS = INT32_C(8);          /** @brief Break 2 interrupt flag */
    static const int32_t TIMX_TISEL_BIF_POS = INT32_C(7);           /** @brief Break interrupt flag */
    static const int32_t TIMX_TISEL_TIF_POS = INT32_C(6);           /** @brief Trigger interrupt flag */
    static const int32_t TIMX_TISEL_COMIF_POS = INT32_C(5);         /** @brief COM interrupt flag */
    static const int32_t TIMX_TISEL_UIF_POS = INT32_C(0);           /** @brief Update interrupt flag */
    static const int32_t TIMX_TISEL_UG_POS = INT32_C(0);            /** @brief Update generation */
    static const int32_t TIMX_TISEL_COMG_POS = INT32_C(5);          /** @brief Capture/Compare control update generation */
    static const int32_t TIMX_TISEL_TG_POS = INT32_C(6);            /** @brief Trigger generation */
    static const int32_t TIMX_TISEL_BG_POS = INT32_C(7);            /** @brief Break generation */
    static const int32_t TIMX_TISEL_B2G_POS = INT32_C(8);           /** @brief Break 2 generation */
    static const int32_t TIMX_TISEL_CC1S_POS = INT32_C(0);          /** @brief Capture/Compare 1 selection */
    static const int32_t TIMX_TISEL_OC1FE_POS = INT32_C(2);         /** @brief Output compare 1 fast enable */
    static const int32_t TIMX_TISEL_OC1PE_POS = INT32_C(3);         /** @brief Output compare 1 preload enable */
    static const int32_t TIMX_TISEL_OC1M_POS = INT32_C(4);          /** @brief Output compare 1 mode */
    static const int32_t TIMX_TISEL_OC1CE_POS = INT32_C(7);         /** @brief Output compare 1 clear enable */
    static const int32_t TIMX_TISEL_CC2S_POS = INT32_C(8);          /** @brief Capture/Compare 2 selection */
    static const int32_t TIMX_TISEL_OC2FE_POS = INT32_C(10);        /** @brief Output compare 2 fast enable */
    static const int32_t TIMX_TISEL_OC2PE_POS = INT32_C(11);        /** @brief Output compare 2 preload enable */
    static const int32_t TIMX_TISEL_OC2M_POS = INT32_C(12);         /** @brief Output compare 2 mode */
    static const int32_t TIMX_TISEL_OC2CE_POS = INT32_C(15);        /** @brief Output compare 2 clear enable */
    static const int32_t TIMX_TISEL_OC1M_3_POS = INT32_C(16);       /** @brief Output compare 1 mode - bit 3 */
    static const int32_t TIMX_TISEL_OC2M_3_POS = INT32_C(24);       /** @brief Output compare 2 mode - bit 3 */
    static const int32_t TIMX_TISEL_IC2F_POS = INT32_C(12);         /** @brief Input capture 2 filter */
    static const int32_t TIMX_TISEL_IC2PCS_POS = INT32_C(10);       /** @brief Input capture 2 prescaler */
    static const int32_t TIMX_TISEL_CC2S_POS = INT32_C(8);          /** @brief Capture/Compare 2 selection */
    static const int32_t TIMX_TISEL_IC1F_POS = INT32_C(4);          /** @brief Input capture 1 filter */
    static const int32_t TIMX_TISEL_ICPCS_POS = INT32_C(2);         /** @brief Input capture 1 prescaler */
    static const int32_t TIMX_TISEL_CC1S_POS = INT32_C(0);          /** @brief Capture/Compare 1 selection */
    static const int32_t TIMX_TISEL_CC3S_POS = INT32_C(0);          /** @brief Capture/Compare 3 selection */
    static const int32_t TIMX_TISEL_OC3FE_POS = INT32_C(2);         /** @brief Output compare 3 fast enable */
    static const int32_t TIMX_TISEL_OC3PE_POS = INT32_C(3);         /** @brief Output compare 3 preload enable */
    static const int32_t TIMX_TISEL_OC3M_POS = INT32_C(4);          /** @brief Output compare 3 mode */
    static const int32_t TIMX_TISEL_OC3CE_POS = INT32_C(7);         /** @brief Output compare 3 clear enable */
    static const int32_t TIMX_TISEL_CC4S_POS = INT32_C(8);          /** @brief Capture/Compare 4 selection */
    static const int32_t TIMX_TISEL_OC4FE_POS = INT32_C(10);        /** @brief Output compare 4 fast enable */
    static const int32_t TIMX_TISEL_OC4PE_POS = INT32_C(11);        /** @brief Output compare 4 preload enable */
    static const int32_t TIMX_TISEL_OC4M_POS = INT32_C(12);         /** @brief Output compare 4 mode */
    static const int32_t TIMX_TISEL_OC4CE_POS = INT32_C(15);        /** @brief Output compare 4 clear enable */
    static const int32_t TIMX_TISEL_OC3M_3_POS = INT32_C(16);       /** @brief Output compare 3 mode - bit 3 */
    static const int32_t TIMX_TISEL_OC4M_4_POS = INT32_C(24);       /** @brief Output compare 4 mode - bit 3 */
    static const int32_t TIMX_TISEL_IC4F_POS = INT32_C(12);         /** @brief Input capture 4 filter */
    static const int32_t TIMX_TISEL_IC4PSC_POS = INT32_C(10);       /** @brief Input capture 4 prescaler */
    static const int32_t TIMX_TISEL_CC4S_POS = INT32_C(8);          /** @brief Capture/Compare 4 selection */
    static const int32_t TIMX_TISEL_IC3F_POS = INT32_C(4);          /** @brief Input capture 3 filter */
    static const int32_t TIMX_TISEL_IC3PSC_POS = INT32_C(2);        /** @brief Input capture 3 prescaler */
    static const int32_t TIMX_TISEL_CC3S_POS = INT32_C(0);          /** @brief Capture/compare 3 selection */
    static const int32_t TIMX_TISEL_CNT_POS = INT32_C(0);           /** @brief Counter value */
    static const int32_t TIMX_TISEL_UIFCPY_POS = INT32_C(31);       /** @brief UIF copy */
    static const int32_t TIMX_TISEL_PSC_POS = INT32_C(0);           /** @brief Prescaler value */
    static const int32_t TIMX_TISEL_ARR_POS = INT32_C(0);           /** @brief Auto-reload value */
    static const int32_t TIMX_TISEL_CCR1_POS = INT32_C(0);          /** @brief Capture/Compare 1 value */
    static const int32_t TIMX_TISEL_CCR2_POS = INT32_C(0);          /** @brief Capture/Compare 2 value */
    static const int32_t TIMX_TISEL_CCR3_POS = INT32_C(0);          /** @brief Capture/Compare value */
    static const int32_t TIMX_TISEL_CCR4_POS = INT32_C(0);          /** @brief Capture/Compare value */
    static const int32_t TIMX_TISEL_DBL_POS = INT32_C(8);           /** @brief DMA burst length */
    static const int32_t TIMX_TISEL_DBA_POS = INT32_C(0);           /** @brief DMA base address */
    static const int32_t TIMX_TISEL_DMAB_POS = INT32_C(0);          /** @brief DMA register for burst accesses */
    static const int32_t TIMX_TISEL_REP_POS = INT32_C(0);           /** @brief Repetition counter value */
    static const int32_t TIMX_TISEL_DTG_POS = INT32_C(0);           /** @brief Dead-time generator setup */
    static const int32_t TIMX_TISEL_LOCK_POS = INT32_C(8);          /** @brief Lock configuration */
    static const int32_t TIMX_TISEL_OSSI_POS = INT32_C(10);         /** @brief Off-state selection for idle mode */
    static const int32_t TIMX_TISEL_OSSR_POS = INT32_C(11);         /** @brief Off-state selection for run mode */
    static const int32_t TIMX_TISEL_BKE_POS = INT32_C(12);          /** @brief Break enable */
    static const int32_t TIMX_TISEL_BKP_POS = INT32_C(13);          /** @brief Break polarity */
    static const int32_t TIMX_TISEL_AOE_POS = INT32_C(14);          /** @brief Automatic output enable */
    static const int32_t TIMX_TISEL_MOE_POS = INT32_C(15);          /** @brief Main output enable */
    static const int32_t TIMX_TISEL_BKF_POS = INT32_C(16);          /** @brief Break filter */
    static const int32_t TIMX_TISEL_BK2F_POS = INT32_C(20);         /** @brief Break 2 filter */
    static const int32_t TIMX_TISEL_BK2E_POS = INT32_C(24);         /** @brief Break 2 enable */
    static const int32_t TIMX_TISEL_BK2P_POS = INT32_C(25);         /** @brief Break 2 polarity */
    static const int32_t TIMX_TISEL_OC5FE_POS = INT32_C(2);         /** @brief Output compare 5 fast enable */
    static const int32_t TIMX_TISEL_OC5PE_POS = INT32_C(3);         /** @brief Output compare 5 preload enable */
    static const int32_t TIMX_TISEL_OC5M_POS = INT32_C(4);          /** @brief Output compare 5 mode */
    static const int32_t TIMX_TISEL_OC5CE_POS = INT32_C(7);         /** @brief Output compare 5 clear enable */
    static const int32_t TIMX_TISEL_OC6FE_POS = INT32_C(10);        /** @brief Output compare 6 fast enable */
    static const int32_t TIMX_TISEL_OC6PE_POS = INT32_C(11);        /** @brief Output compare 6 preload enable */
    static const int32_t TIMX_TISEL_OC6M_POS = INT32_C(12);         /** @brief Output compare 6 mode */
    static const int32_t TIMX_TISEL_OC6CE_POS = INT32_C(15);        /** @brief Output compare 6 clear enable */
    static const int32_t TIMX_TISEL_OC5M3_POS = INT32_C(16);        /** @brief Output compare 5 mode */
    static const int32_t TIMX_TISEL_OC6M3_POS = INT32_C(24);        /** @brief Output compare 6 mode */
    static const int32_t TIMX_TISEL_CCR5_POS = INT32_C(0);          /** @brief Capture/Compare 5 value */
    static const int32_t TIMX_TISEL_CCR6_POS = INT32_C(0);          /** @brief Capture/Compare 6 value */
    static const int32_t TIMX_TISEL_BKINE_POS = INT32_C(0);         /** @brief BRK BKIN input enable */
    static const int32_t TIMX_TISEL_BKCMP1E_POS = INT32_C(1);       /** @brief BRK COMP1 enable */
    static const int32_t TIMX_TISEL_BKCMP2E_POS = INT32_C(2);       /** @brief BRK COMP2 enable */
    static const int32_t TIMX_TISEL_BKDF1BK0E_POS = INT32_C(8);     /** @brief BRK dfsdm1_break[0] enable */
    static const int32_t TIMX_TISEL_BKINP_POS = INT32_C(9);         /** @brief BRK BKIN input polarity */
    static const int32_t TIMX_TISEL_BKCMP1P_POS = INT32_C(10);      /** @brief BRK COMP1 input polarity */
    static const int32_t TIMX_TISEL_BKCMP2P_POS = INT32_C(11);      /** @brief BRK COMP2 input polarity */
    static const int32_t TIMX_TISEL_ETRSEL_POS = INT32_C(14);       /** @brief ETR source selection */
    static const int32_t TIMX_TISEL_BK2INE_POS = INT32_C(0);        /** @brief BRK2 BKIN input enable */
    static const int32_t TIMX_TISEL_BK2CMP1E_POS = INT32_C(1);      /** @brief BRK2 COMP1 enable */
    static const int32_t TIMX_TISEL_BK2CMP2E_POS = INT32_C(2);      /** @brief BRK2 COMP2 enable */
    static const int32_t TIMX_TISEL_BK2DF1BK1E_POS = INT32_C(8);    /** @brief BRK2 dfsdm1_break[1] enable */
    static const int32_t TIMX_TISEL_BK2INP_POS = INT32_C(9);        /** @brief BRK2 BKIN2 input polarity */
    static const int32_t TIMX_TISEL_BK2CMP1P_POS = INT32_C(10);     /** @brief BRK2 COMP1 input polarit */
    static const int32_t TIMX_TISEL_BK2CMP2P_POS = INT32_C(11);     /** @brief BRK2 COMP2 input polarity */

    /**********************************************************************************************
     * @section FDCANX Definitions
     **********************************************************************************************/

    /** @subsection FDCANX IRQ interrupt array definitions */

    static const int32_t FDCANX_IT0_IRQ[3] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(19),    /** @brief FDCAN1 interrupt 0 */
      INT32_C(20),    /** @brief FDCAN2 interrupt 0 */
    };

    static const int32_t FDCAN1_ITX_IRQ[2] = {
      INT32_C(-1),    /** @brief Invalid index. */
      INT32_C(21),    /** @brief FDCAN1 interrupt 1 */
    };

    /** @subsection FDCANX IRQ interrupt definitions */

    static const int32_t FDCAN_CAL_IRQ = INT32_C(63);   /** @brief CAN2TX interrupts */

    /** @subsection FDCANX register array definitions */

    static _RO uint32_t* const FDCANX_CREL_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A000),   /** @brief FDCAN core release register */
      (_RO uint32_t* const)UINT32_C(0x4000A400),   /** @brief FDCAN core release register */
    };

    static _RO uint32_t* const FDCANX_ENDN_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A004),   /** @brief FDCAN core release register */
      (_RO uint32_t* const)UINT32_C(0x4000A404),   /** @brief FDCAN core release register */
    };

    static _RO uint32_t* const FDCANX_DBTP_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A00C),   /** @brief FDCAN data bit timing and prescaler register */
      (_RO uint32_t* const)UINT32_C(0x4000A40C),   /** @brief FDCAN data bit timing and prescaler register */
    };

    static _RO uint32_t* const FDCANX_TEST_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A010),   /** @brief FDCAN test register */
      (_RO uint32_t* const)UINT32_C(0x4000A410),   /** @brief FDCAN test register */
    };

    static _RO uint32_t* const FDCANX_RWD_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A014),   /** @brief FDCAN RAM watchdog register */
      (_RO uint32_t* const)UINT32_C(0x4000A414),   /** @brief FDCAN RAM watchdog register */
    };

    static _RW uint32_t* const FDCANX_CCCR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A018),   /** @brief FDCAN CC control register */
      (_RW uint32_t* const)UINT32_C(0x4000A418),   /** @brief FDCAN CC control register */
    };

    static _RW uint32_t* const FDCANX_NBTP_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A01C),   /** @brief FDCAN nominal bit timing and prescaler register */
      (_RW uint32_t* const)UINT32_C(0x4000A41C),   /** @brief FDCAN nominal bit timing and prescaler register */
    };

    static _RW uint32_t* const FDCANX_TSCC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A020),   /** @brief FDCAN timestamp counter configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A420),   /** @brief FDCAN timestamp counter configuration register */
    };

    static _RW uint32_t* const FDCANX_TSCV_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A024),   /** @brief FDCAN timestamp counter value register */
      (_RW uint32_t* const)UINT32_C(0x4000A424),   /** @brief FDCAN timestamp counter value register */
    };

    static _RW uint32_t* const FDCANX_TOCC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A028),   /** @brief FDCAN timeout counter configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A428),   /** @brief FDCAN timeout counter configuration register */
    };

    static _RW uint32_t* const FDCANX_TOCV_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A02C),   /** @brief FDCAN timeout counter value register */
      (_RW uint32_t* const)UINT32_C(0x4000A42C),   /** @brief FDCAN timeout counter value register */
    };

    static _RW uint32_t* const FDCANX_ECR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A040),   /** @brief FDCAN error counter register */
      (_RW uint32_t* const)UINT32_C(0x4000A440),   /** @brief FDCAN error counter register */
    };

    static _RW uint32_t* const FDCANX_PSR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A044),   /** @brief FDCAN protocol status register */
      (_RW uint32_t* const)UINT32_C(0x4000A444),   /** @brief FDCAN protocol status register */
    };

    static _RO uint32_t* const FDCANX_TDCR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A048),   /** @brief FDCAN transmitter delay compensation register */
      (_RO uint32_t* const)UINT32_C(0x4000A448),   /** @brief FDCAN transmitter delay compensation register */
    };

    static _RO uint32_t* const FDCANX_IR_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A050),   /** @brief FDCAN interrupt register */
      (_RO uint32_t* const)UINT32_C(0x4000A450),   /** @brief FDCAN interrupt register */
    };

    static _RO uint32_t* const FDCANX_IE_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A054),   /** @brief FDCAN interrupt enable register */
      (_RO uint32_t* const)UINT32_C(0x4000A454),   /** @brief FDCAN interrupt enable register */
    };

    static _RO uint32_t* const FDCANX_ILS_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A058),   /** @brief FDCAN interrupt line select register */
      (_RO uint32_t* const)UINT32_C(0x4000A458),   /** @brief FDCAN interrupt line select register */
    };

    static _RW uint32_t* const FDCANX_ILE_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A05C),   /** @brief FDCAN interrupt line enable register */
      (_RW uint32_t* const)UINT32_C(0x4000A45C),   /** @brief FDCAN interrupt line enable register */
    };

    static _RW uint32_t* const FDCANX_GFC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A080),   /** @brief FDCAN global filter configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A480),   /** @brief FDCAN global filter configuration register */
    };

    static _RW uint32_t* const FDCANX_SIDFC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A084),   /** @brief FDCAN standard ID filter configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A484),   /** @brief FDCAN standard ID filter configuration register */
    };

    static _RW uint32_t* const FDCANX_XIDFC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A088),   /** @brief FDCAN extended ID filter configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A488),   /** @brief FDCAN extended ID filter configuration register */
    };

    static _RW uint32_t* const FDCANX_XIDAM_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A090),   /** @brief FDCAN extended ID and mask register */
      (_RW uint32_t* const)UINT32_C(0x4000A490),   /** @brief FDCAN extended ID and mask register */
    };

    static _RO uint32_t* const FDCANX_HPMS_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A094),   /** @brief FDCAN high priority message status register */
      (_RO uint32_t* const)UINT32_C(0x4000A494),   /** @brief FDCAN high priority message status register */
    };

    static _RO uint32_t* const FDCANX_NDAT1_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A098),   /** @brief FDCAN new data 1 register */
      (_RO uint32_t* const)UINT32_C(0x4000A498),   /** @brief FDCAN new data 1 register */
    };

    static _RO uint32_t* const FDCANX_NDAT2_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A09C),   /** @brief FDCAN new data 2 register */
      (_RO uint32_t* const)UINT32_C(0x4000A49C),   /** @brief FDCAN new data 2 register */
    };

    static _RW uint32_t* const FDCANX_RXF0C_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0A0),   /** @brief FDCAN rx FIFO 0 configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A4A0),   /** @brief FDCAN rx FIFO 0 configuration register */
    };

    static _RW uint32_t* const FDCANX_RXF0S_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0A4),   /** @brief FDCAN rx FIFO 0 status register */
      (_RW uint32_t* const)UINT32_C(0x4000A4A4),   /** @brief FDCAN rx FIFO 0 status register */
    };

    static _RW uint32_t* const FDCANX_RXF0A_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0A8),   /** @brief CAN rx FIFO 0 acknowledge register */
      (_RW uint32_t* const)UINT32_C(0x4000A4A8),   /** @brief CAN rx FIFO 0 acknowledge register */
    };

    static _RW uint32_t* const FDCANX_RXBC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0AC),   /** @brief FDCAN rx buffer configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A4AC),   /** @brief FDCAN rx buffer configuration register */
    };

    static _RW uint32_t* const FDCANX_RXF1C_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0B0),   /** @brief FDCAN rx FIFO 1 configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A4B0),   /** @brief FDCAN rx FIFO 1 configuration register */
    };

    static _RW uint32_t* const FDCANX_RXF1S_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0B4),   /** @brief FDCAN rx FIFO 1 status register */
      (_RW uint32_t* const)UINT32_C(0x4000A4B4),   /** @brief FDCAN rx FIFO 1 status register */
    };

    static _RW uint32_t* const FDCANX_RXF1A_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0B8),   /** @brief FDCAN rx FIFO 1 acknowledge register */
      (_RW uint32_t* const)UINT32_C(0x4000A4B8),   /** @brief FDCAN rx FIFO 1 acknowledge register */
    };

    static _RW uint32_t* const FDCANX_RXESC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0BC),   /** @brief FDCAN rx buffer element size configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A4BC),   /** @brief FDCAN rx buffer element size configuration register */
    };

    static _RW uint32_t* const FDCANX_TXBC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0C0),   /** @brief FDCAN tx buffer configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A4C0),   /** @brief FDCAN tx buffer configuration register */
    };

    static _RO uint32_t* const FDCANX_TXFQS_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A0C4),   /** @brief FDCAN tx fifo/queue status register */
      (_RO uint32_t* const)UINT32_C(0x4000A4C4),   /** @brief FDCAN tx fifo/queue status register */
    };

    static _RW uint32_t* const FDCANX_TXESC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0C8),   /** @brief FDCAN tx buffer element size configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A4C8),   /** @brief FDCAN tx buffer element size configuration register */
    };

    static _RO uint32_t* const FDCANX_TXBRP_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A0CC),   /** @brief FDCAN tx buffer request pending register */
      (_RO uint32_t* const)UINT32_C(0x4000A4CC),   /** @brief FDCAN tx buffer request pending register */
    };

    static _RW uint32_t* const FDCANX_TXBAR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0D0),   /** @brief FDCAN tx buffer add request register */
      (_RW uint32_t* const)UINT32_C(0x4000A4D0),   /** @brief FDCAN tx buffer add request register */
    };

    static _RW uint32_t* const FDCANX_TXBCR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0D4),   /** @brief FDCAN tx buffer cancellation request register */
      (_RW uint32_t* const)UINT32_C(0x4000A4D4),   /** @brief FDCAN tx buffer cancellation request register */
    };

    static _RW uint32_t* const FDCANX_TXBTO_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0D8),   /** @brief FDCAN tx buffer transmission occurred register */
      (_RW uint32_t* const)UINT32_C(0x4000A4D8),   /** @brief FDCAN tx buffer transmission occurred register */
    };

    static _RO uint32_t* const FDCANX_TXBCF_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A0DC),   /** @brief FDCAN tx buffer cancellation finished register */
      (_RO uint32_t* const)UINT32_C(0x4000A4DC),   /** @brief FDCAN tx buffer cancellation finished register */
    };

    static _RW uint32_t* const FDCANX_TXBTIE_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0E0),   /** @brief FDCAN tx buffer transmission interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000A4E0),   /** @brief FDCAN tx buffer transmission interrupt enable register */
    };

    static _RW uint32_t* const FDCANX_TXBCIE_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0E4),   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000A4E4),   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
    };

    static _RW uint32_t* const FDCANX_TXEFC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0F0),   /** @brief FDCAN tx event FIFO configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A4F0),   /** @brief FDCAN tx event FIFO configuration register */
    };

    static _RW uint32_t* const FDCANX_TXEFS_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0F4),   /** @brief FDCAN tx event FIFO status register */
      (_RW uint32_t* const)UINT32_C(0x4000A4F4),   /** @brief FDCAN tx event FIFO status register */
    };

    static _RW uint32_t* const FDCANX_TXEFA_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A0F8),   /** @brief FDCAN tx event FIFO acknowledge register */
      (_RW uint32_t* const)UINT32_C(0x4000A4F8),   /** @brief FDCAN tx event FIFO acknowledge register */
    };

    static _RW uint32_t* const FDCANX_TTTMC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A100),   /** @brief FDCAN TT trigger memory configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A500),   /** @brief FDCAN TT trigger memory configuration register */
    };

    static _RW uint32_t* const FDCANX_TTRMC_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A104),   /** @brief FDCAN TT reference message configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A504),   /** @brief FDCAN TT reference message configuration register */
    };

    static _RW uint32_t* const FDCANX_TTOCF_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A108),   /** @brief FDCAN TT operation configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A508),   /** @brief FDCAN TT operation configuration register */
    };

    static _RW uint32_t* const FDCANX_TTMLM_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A10C),   /** @brief FDCAN TT matrix limits register */
      (_RW uint32_t* const)UINT32_C(0x4000A50C),   /** @brief FDCAN TT matrix limits register */
    };

    static _RW uint32_t* const FDCANX_TURCF_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A110),   /** @brief FDCAN TUR configuration register */
      (_RW uint32_t* const)UINT32_C(0x4000A510),   /** @brief FDCAN TUR configuration register */
    };

    static _RW uint32_t* const FDCANX_TTOCN_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A114),   /** @brief FDCAN TT operation control register */
      (_RW uint32_t* const)UINT32_C(0x4000A514),   /** @brief FDCAN TT operation control register */
    };

    static _RW uint32_t* const FDCANX_CAN_TTGTP_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A118),   /** @brief FDCAN TT global time preset register */
      (_RW uint32_t* const)UINT32_C(0x4000A518),   /** @brief FDCAN TT global time preset register */
    };

    static _RW uint32_t* const FDCANX_TTTMK_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A11C),   /** @brief FDCAN TT time mark register */
      (_RW uint32_t* const)UINT32_C(0x4000A51C),   /** @brief FDCAN TT time mark register */
    };

    static _RW uint32_t* const FDCANX_TTIR_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A120),   /** @brief FDCAN TT interrupt register */
      (_RW uint32_t* const)UINT32_C(0x4000A520),   /** @brief FDCAN TT interrupt register */
    };

    static _RW uint32_t* const FDCANX_TTIE_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A124),   /** @brief FDCAN TT interrupt enable register */
      (_RW uint32_t* const)UINT32_C(0x4000A524),   /** @brief FDCAN TT interrupt enable register */
    };

    static _RW uint32_t* const FDCANX_TTILS_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A128),   /** @brief FDCAN TT interrupt line select register */
      (_RW uint32_t* const)UINT32_C(0x4000A528),   /** @brief FDCAN TT interrupt line select register */
    };

    static _RW uint32_t* const FDCANX_TTOST_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A12C),   /** @brief FDCAN TT operation status register */
      (_RW uint32_t* const)UINT32_C(0x4000A52C),   /** @brief FDCAN TT operation status register */
    };

    static _RO uint32_t* const FDCANX_TURNA_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A130),   /** @brief FDCAN TUR numerator actual register */
      (_RO uint32_t* const)UINT32_C(0x4000A530),   /** @brief FDCAN TUR numerator actual register */
    };

    static _RO uint32_t* const FDCANX_TTLGT_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A134),   /** @brief FDCAN TT local and global time register */
      (_RO uint32_t* const)UINT32_C(0x4000A534),   /** @brief FDCAN TT local and global time register */
    };

    static _RO uint32_t* const FDCANX_TTCTC_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A138),   /** @brief FDCAN TT cycle time and count register */
      (_RO uint32_t* const)UINT32_C(0x4000A538),   /** @brief FDCAN TT cycle time and count register */
    };

    static _RO uint32_t* const FDCANX_TTCPT_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A13C),   /** @brief FDCAN TT capture time register */
      (_RO uint32_t* const)UINT32_C(0x4000A53C),   /** @brief FDCAN TT capture time register */
    };

    static _RO uint32_t* const FDCANX_TTCSM_REG[3] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4000A140),   /** @brief FDCAN TT cycle sync mark register */
      (_RO uint32_t* const)UINT32_C(0x4000A540),   /** @brief FDCAN TT cycle sync mark register */
    };

    static _RW uint32_t* const FDCANX_TTTS_REG[3] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x4000A300),   /** @brief FDCAN TT trigger select register */
      (_RW uint32_t* const)UINT32_C(0x4000A700),   /** @brief FDCAN TT trigger select register */
    };

    /** @subsection FDCANX field mask array definitions */

    static const uint32_t FDCANX_NDAT1_NDX_MASK[32] = {
      UINT32_C(0x00000001),   /** @brief New data */
      UINT32_C(0x00000002),   /** @brief New data */
      UINT32_C(0x00000004),   /** @brief New data */
      UINT32_C(0x00000008),   /** @brief New data */
      UINT32_C(0x00000010),   /** @brief New data */
      UINT32_C(0x00000020),   /** @brief New data */
      UINT32_C(0x00000040),   /** @brief New data */
      UINT32_C(0x00000080),   /** @brief New data */
      UINT32_C(0x00000100),   /** @brief New data */
      UINT32_C(0x00000200),   /** @brief New data */
      UINT32_C(0x00000400),   /** @brief New data */
      UINT32_C(0x00000800),   /** @brief New data */
      UINT32_C(0x00001000),   /** @brief New data */
      UINT32_C(0x00002000),   /** @brief New data */
      UINT32_C(0x00004000),   /** @brief New data */
      UINT32_C(0x00008000),   /** @brief New data */
      UINT32_C(0x00010000),   /** @brief New data */
      UINT32_C(0x00020000),   /** @brief New data */
      UINT32_C(0x00040000),   /** @brief New data */
      UINT32_C(0x00080000),   /** @brief New data */
      UINT32_C(0x00100000),   /** @brief New data */
      UINT32_C(0x00200000),   /** @brief New data */
      UINT32_C(0x00400000),   /** @brief New data */
      UINT32_C(0x00800000),   /** @brief New data */
      UINT32_C(0x01000000),   /** @brief New data */
      UINT32_C(0x02000000),   /** @brief New data */
      UINT32_C(0x04000000),   /** @brief New data */
      UINT32_C(0x08000000),   /** @brief New data */
      UINT32_C(0x10000000),   /** @brief New data */
      UINT32_C(0x20000000),   /** @brief New data */
      UINT32_C(0x40000000),   /** @brief New data */
      UINT32_C(0x80000000),   /** @brief New data */
    };

    static const uint32_t FDCANX_NDAT2_ND3X_MASK[10] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000002),   /** @brief New data */
      UINT32_C(0x00000004),   /** @brief New data */
      UINT32_C(0x00000008),   /** @brief New data */
      UINT32_C(0x00000010),   /** @brief New data */
      UINT32_C(0x00000020),   /** @brief New data */
      UINT32_C(0x00000040),   /** @brief New data */
      UINT32_C(0x00000080),   /** @brief New data */
    };

    /** @subsection FDCANX field mask definitions */

    static const uint32_t FDCANX_CREL_REL_MASK = UINT32_C(0xF0000000);        /** @brief Core release */
    static const uint32_t FDCANX_CREL_STEP_MASK = UINT32_C(0x0F000000);       /** @brief Step of core release */
    static const uint32_t FDCANX_CREL_SUBSTEP_MASK = UINT32_C(0x00F00000);    /** @brief Sub-step of core release */
    static const uint32_t FDCANX_CREL_YEAR_MASK = UINT32_C(0x000F0000);       /** @brief Timestamp year */
    static const uint32_t FDCANX_CREL_MON_MASK = UINT32_C(0x0000FF00);        /** @brief Timestamp month */
    static const uint32_t FDCANX_CREL_DAY_MASK = UINT32_C(0x000000FF);        /** @brief Timestamp day */
    static const uint32_t FDCANX_DBTP_DSJW_MASK = UINT32_C(0x0000000F);       /** @brief Synchronization jump width */
    static const uint32_t FDCANX_DBTP_DTSEG2_MASK = UINT32_C(0x000000F0);     /** @brief Data time segment after sample point */
    static const uint32_t FDCANX_DBTP_DTSEG1_MASK = UINT32_C(0x00001F00);     /** @brief Data time segment after sample point */
    static const uint32_t FDCANX_DBTP_DBRP_MASK = UINT32_C(0x001F0000);       /** @brief Data bit rate prescaler */
    static const uint32_t FDCANX_DBTP_TDC_MASK = UINT32_C(0x00800000);        /** @brief Transceiver delay compensation */
    static const uint32_t FDCANX_TEST_LBCK_MASK = UINT32_C(0x00000010);       /** @brief Loop back mode */
    static const uint32_t FDCANX_TEST_TX_MASK = UINT32_C(0x00000060);         /** @brief Loop back mode */
    static const uint32_t FDCANX_TEST_RX_MASK = UINT32_C(0x00000080);         /** @brief Control of transmit pin */
    static const uint32_t FDCANX_RWD_WDV_MASK = UINT32_C(0x0000FF00);         /** @brief Watchdog value */
    static const uint32_t FDCANX_RWD_WDC_MASK = UINT32_C(0x000000FF);         /** @brief Watchdog configuration */
    static const uint32_t FDCANX_CCCR_INIT_MASK = UINT32_C(0x00000001);       /** @brief Initialization */
    static const uint32_t FDCANX_CCCR_CCE_MASK = UINT32_C(0x00000002);        /** @brief Configuration change enable */
    static const uint32_t FDCANX_CCCR_ASM_MASK = UINT32_C(0x00000004);        /** @brief ASM restricted operation mode */
    static const uint32_t FDCANX_CCCR_CSA_MASK = UINT32_C(0x00000008);        /** @brief Clock stop acknowledge */
    static const uint32_t FDCANX_CCCR_CSR_MASK = UINT32_C(0x00000010);        /** @brief Clock stop request */
    static const uint32_t FDCANX_CCCR_MON_MASK = UINT32_C(0x00000020);        /** @brief Bus monitoring mode */
    static const uint32_t FDCANX_CCCR_DAR_MASK = UINT32_C(0x00000040);        /** @brief Disable automatic retransmission */
    static const uint32_t FDCANX_CCCR_TEST_MASK = UINT32_C(0x00000080);       /** @brief Test mode enable */
    static const uint32_t FDCANX_CCCR_FDOE_MASK = UINT32_C(0x00000100);       /** @brief FD operation enable */
    static const uint32_t FDCANX_CCCR_BSE_MASK = UINT32_C(0x00000200);        /** @brief FDCAN bit rate switching */
    static const uint32_t FDCANX_CCCR_PXHD_MASK = UINT32_C(0x00001000);       /** @brief Protocol exception handling disable */
    static const uint32_t FDCANX_CCCR_EFBI_MASK = UINT32_C(0x00002000);       /** @brief Edge filtering during bus integration */
    static const uint32_t FDCANX_CCCR_TXP_MASK = UINT32_C(0x00004000);        /** @brief TXP */
    static const uint32_t FDCANX_CCCR_NISO_MASK = UINT32_C(0x00008000);       /** @brief Non ISO operation */
    static const uint32_t FDCANX_NBTP_NSJW_MASK = UINT32_C(0xFE000000);       /** @brief NSJW: nominal (re)synchronization jump width */
    static const uint32_t FDCANX_NBTP_NBRP_MASK = UINT32_C(0x01FF0000);       /** @brief Bit rate prescaler */
    static const uint32_t FDCANX_NBTP_NTSEG1_MASK = UINT32_C(0x0000FF00);     /** @brief Nominal time segment before sample point */
    static const uint32_t FDCANX_NBTP_TSEG2_MASK = UINT32_C(0x0000007F);      /** @brief Nominal time segment after sample point */
    static const uint32_t FDCANX_TSCC_TCP_MASK = UINT32_C(0x000F0000);        /** @brief Timestamp counter prescaler */
    static const uint32_t FDCANX_TSCC_TSS_MASK = UINT32_C(0x00000003);        /** @brief Timestamp select */
    static const uint32_t FDCANX_TSCV_TSC_MASK = UINT32_C(0x0000FFFF);        /** @brief Timestamp counter */
    static const uint32_t FDCANX_TOCC_ETOC_MASK = UINT32_C(0x00000001);       /** @brief Enable timeout counter */
    static const uint32_t FDCANX_TOCC_TOS_MASK = UINT32_C(0x00000006);        /** @brief Timeout select */
    static const uint32_t FDCANX_TOCC_TOP_MASK = UINT32_C(0xFFFF0000);        /** @brief Timeout period */
    static const uint32_t FDCANX_TOCV_TOC_MASK = UINT32_C(0x0000FFFF);        /** @brief Timeout counter */
    static const uint32_t FDCANX_ECR_CEL_MASK = UINT32_C(0x00FF0000);         /** @brief AN error logging */
    static const uint32_t FDCANX_ECR_RP_MASK = UINT32_C(0x00008000);          /** @brief Receive error passive */
    static const uint32_t FDCANX_ECR_TREC_MASK = UINT32_C(0x00007F00);        /** @brief Receive error counter */
    static const uint32_t FDCANX_ECR_TEC_MASK = UINT32_C(0x000000FF);         /** @brief Transmit error counter */
    static const uint32_t FDCANX_PSR_LEC_MASK = UINT32_C(0x00000007);         /** @brief Last error code */
    static const uint32_t FDCANX_PSR_ACT_MASK = UINT32_C(0x00000018);         /** @brief Activity */
    static const uint32_t FDCANX_PSR_EP_MASK = UINT32_C(0x00000020);          /** @brief Error passive */
    static const uint32_t FDCANX_PSR_EW_MASK = UINT32_C(0x00000040);          /** @brief Warning status */
    static const uint32_t FDCANX_PSR_BO_MASK = UINT32_C(0x00000080);          /** @brief Bus_Off status */
    static const uint32_t FDCANX_PSR_DLEC_MASK = UINT32_C(0x00000700);        /** @brief Data last error code */
    static const uint32_t FDCANX_PSR_RESI_MASK = UINT32_C(0x00000800);        /** @brief ESI flag of last received FDCAN message */
    static const uint32_t FDCANX_PSR_RBRS_MASK = UINT32_C(0x00001000);        /** @brief BRS flag of last received FDCAN message */
    static const uint32_t FDCANX_PSR_REDL_MASK = UINT32_C(0x00002000);        /** @brief Received FDCAN message */
    static const uint32_t FDCANX_PSR_PXE_MASK = UINT32_C(0x00004000);         /** @brief Protocol exception event */
    static const uint32_t FDCANX_PSR_TDCV_MASK = UINT32_C(0x007F0000);        /** @brief Transmitter delay compensation value */
    static const uint32_t FDCANX_TDCR_TDCF_MASK = UINT32_C(0x0000007F);       /** @brief Transmitter delay compensation filter window length */
    static const uint32_t FDCANX_TDCR_TDCO_MASK = UINT32_C(0x00007F00);       /** @brief Transmitter delay compensation offset */
    static const uint32_t FDCANX_IR_RF0N_MASK = UINT32_C(0x00000001);         /** @brief Rx FIFO 0 new message */
    static const uint32_t FDCANX_IR_RF0W_MASK = UINT32_C(0x00000002);         /** @brief Rx FIFO 0 full */
    static const uint32_t FDCANX_IR_RF0F_MASK = UINT32_C(0x00000004);         /** @brief Rx FIFO 0 full */
    static const uint32_t FDCANX_IR_RF0L_MASK = UINT32_C(0x00000008);         /** @brief Rx FIFO 0 message lost */
    static const uint32_t FDCANX_IR_RF1N_MASK = UINT32_C(0x00000010);         /** @brief Rx FIFO 1 new message */
    static const uint32_t FDCANX_IR_RF1W_MASK = UINT32_C(0x00000020);         /** @brief Rx FIFO 1 watermark reached */
    static const uint32_t FDCANX_IR_RF1F_MASK = UINT32_C(0x00000040);         /** @brief Rx FIFO 1 watermark reached */
    static const uint32_t FDCANX_IR_RF1L_MASK = UINT32_C(0x00000080);         /** @brief Rx FIFO 1 message lost */
    static const uint32_t FDCANX_IR_HPM_MASK = UINT32_C(0x00000100);          /** @brief High priority message */
    static const uint32_t FDCANX_IR_TC_MASK = UINT32_C(0x00000200);           /** @brief Transmission completed */
    static const uint32_t FDCANX_IR_TCF_MASK = UINT32_C(0x00000400);          /** @brief Transmission cancellation finished */
    static const uint32_t FDCANX_IR_TEF_MASK = UINT32_C(0x00000800);          /** @brief Tx FIFO empty */
    static const uint32_t FDCANX_IR_TEFN_MASK = UINT32_C(0x00001000);         /** @brief Tx event FIFO new entry */
    static const uint32_t FDCANX_IR_TEFW_MASK = UINT32_C(0x00002000);         /** @brief Tx event FIFO watermark reached */
    static const uint32_t FDCANX_IR_TEFF_MASK = UINT32_C(0x00004000);         /** @brief Tx event FIFO full */
    static const uint32_t FDCANX_IR_TEFL_MASK = UINT32_C(0x00008000);         /** @brief Tx event FIFO element lost */
    static const uint32_t FDCANX_IR_TSW_MASK = UINT32_C(0x00010000);          /** @brief Timestamp wraparound */
    static const uint32_t FDCANX_IR_MRAF_MASK = UINT32_C(0x00020000);         /** @brief Message RAM access failure */
    static const uint32_t FDCANX_IR_TOO_MASK = UINT32_C(0x00040000);          /** @brief Timeout occurred */
    static const uint32_t FDCANX_IR_DRX_MASK = UINT32_C(0x00080000);          /** @brief Message stored to dedicated rx buffer */
    static const uint32_t FDCANX_IR_ELO_MASK = UINT32_C(0x00400000);          /** @brief Error logging overflow */
    static const uint32_t FDCANX_IR_EP_MASK = UINT32_C(0x00800000);           /** @brief Error passive */
    static const uint32_t FDCANX_IR_EW_MASK = UINT32_C(0x01000000);           /** @brief Warning status */
    static const uint32_t FDCANX_IR_BO_MASK = UINT32_C(0x02000000);           /** @brief Bus_Off status */
    static const uint32_t FDCANX_IR_WDI_MASK = UINT32_C(0x04000000);          /** @brief Watchdog interrupt */
    static const uint32_t FDCANX_IR_PEA_MASK = UINT32_C(0x08000000);          /** @brief Protocol error in arbitration phase (nominal bit time is used) */
    static const uint32_t FDCANX_IR_PED_MASK = UINT32_C(0x10000000);          /** @brief Protocol error in data phase (data bit time is used) */
    static const uint32_t FDCANX_IR_ARA_MASK = UINT32_C(0x20000000);          /** @brief Access to reserved address */
    static const uint32_t FDCANX_IE_RF0NE_MASK = UINT32_C(0x00000001);        /** @brief Rx FIFO 0 new message enable */
    static const uint32_t FDCANX_IE_RF0WE_MASK = UINT32_C(0x00000002);        /** @brief Rx FIFO 0 full enable */
    static const uint32_t FDCANX_IE_RF0FE_MASK = UINT32_C(0x00000004);        /** @brief Rx FIFO 0 full enable */
    static const uint32_t FDCANX_IE_RF0LE_MASK = UINT32_C(0x00000008);        /** @brief Rx FIFO 0 message lost enable */
    static const uint32_t FDCANX_IE_RF1NE_MASK = UINT32_C(0x00000010);        /** @brief Rx FIFO 1 new message enable */
    static const uint32_t FDCANX_IE_RF1WE_MASK = UINT32_C(0x00000020);        /** @brief Rx FIFO 1 watermark reached enable */
    static const uint32_t FDCANX_IE_RF1FE_MASK = UINT32_C(0x00000040);        /** @brief Rx FIFO 1 watermark reached enable */
    static const uint32_t FDCANX_IE_RF1LE_MASK = UINT32_C(0x00000080);        /** @brief Rx FIFO 1 message lost enable */
    static const uint32_t FDCANX_IE_HPME_MASK = UINT32_C(0x00000100);         /** @brief High priority message enable */
    static const uint32_t FDCANX_IE_TCE_MASK = UINT32_C(0x00000200);          /** @brief Transmission completed enable */
    static const uint32_t FDCANX_IE_TCFE_MASK = UINT32_C(0x00000400);         /** @brief Transmission cancellation finished enable */
    static const uint32_t FDCANX_IE_TEFE_MASK = UINT32_C(0x00000800);         /** @brief Tx FIFO empty enable */
    static const uint32_t FDCANX_IE_TEFNE_MASK = UINT32_C(0x00001000);        /** @brief Tx event FIFO new entry enable */
    static const uint32_t FDCANX_IE_TEFWE_MASK = UINT32_C(0x00002000);        /** @brief Tx event FIFO watermark reached enable */
    static const uint32_t FDCANX_IE_TEFFE_MASK = UINT32_C(0x00004000);        /** @brief Tx event FIFO full enable */
    static const uint32_t FDCANX_IE_TEFLE_MASK = UINT32_C(0x00008000);        /** @brief Tx event FIFO element lost enable */
    static const uint32_t FDCANX_IE_TSWE_MASK = UINT32_C(0x00010000);         /** @brief Timestamp wraparound enable */
    static const uint32_t FDCANX_IE_MRAFE_MASK = UINT32_C(0x00020000);        /** @brief Message RAM access failure enable */
    static const uint32_t FDCANX_IE_TOOE_MASK = UINT32_C(0x00040000);         /** @brief Timeout occurred enable */
    static const uint32_t FDCANX_IE_DRXE_MASK = UINT32_C(0x00080000);         /** @brief Message stored to dedicated rx buffer enable */
    static const uint32_t FDCANX_IE_BECE_MASK = UINT32_C(0x00100000);         /** @brief Bit error corrected interrupt enable */
    static const uint32_t FDCANX_IE_BEUE_MASK = UINT32_C(0x00200000);         /** @brief Bit error uncorrected interrupt enable */
    static const uint32_t FDCANX_IE_ELOE_MASK = UINT32_C(0x00400000);         /** @brief Error logging overflow enable */
    static const uint32_t FDCANX_IE_EPE_MASK = UINT32_C(0x00800000);          /** @brief Error passive enable */
    static const uint32_t FDCANX_IE_EWE_MASK = UINT32_C(0x01000000);          /** @brief Warning status enable */
    static const uint32_t FDCANX_IE_BOE_MASK = UINT32_C(0x02000000);          /** @brief Bus_Off status enable */
    static const uint32_t FDCANX_IE_WDIE_MASK = UINT32_C(0x04000000);         /** @brief Watchdog interrupt enable */
    static const uint32_t FDCANX_IE_PEAE_MASK = UINT32_C(0x08000000);         /** @brief Protocol error in arbitration phase enable */
    static const uint32_t FDCANX_IE_PEDE_MASK = UINT32_C(0x10000000);         /** @brief Protocol error in data phase enable */
    static const uint32_t FDCANX_IE_ARAE_MASK = UINT32_C(0x20000000);         /** @brief Access to reserved address enable */
    static const uint32_t FDCANX_ILS_RF0NL_MASK = UINT32_C(0x00000001);       /** @brief Rx FIFO 0 new message interrupt line */
    static const uint32_t FDCANX_ILS_RF0WL_MASK = UINT32_C(0x00000002);       /** @brief Rx FIFO 0 watermark reached interrupt line */
    static const uint32_t FDCANX_ILS_RF0FL_MASK = UINT32_C(0x00000004);       /** @brief Rx FIFO 0 full interrupt line */
    static const uint32_t FDCANX_ILS_RF0LL_MASK = UINT32_C(0x00000008);       /** @brief Rx FIFO 0 message lost interrupt line */
    static const uint32_t FDCANX_ILS_RF1NL_MASK = UINT32_C(0x00000010);       /** @brief Rx FIFO 1 new message interrupt line */
    static const uint32_t FDCANX_ILS_RF1WL_MASK = UINT32_C(0x00000020);       /** @brief Rx FIFO 1 watermark reached interrupt line */
    static const uint32_t FDCANX_ILS_RF1FL_MASK = UINT32_C(0x00000040);       /** @brief Rx FIFO 1 full interrupt line */
    static const uint32_t FDCANX_ILS_RF1LL_MASK = UINT32_C(0x00000080);       /** @brief Rx FIFO 1 message lost interrupt line */
    static const uint32_t FDCANX_ILS_HPML_MASK = UINT32_C(0x00000100);        /** @brief High priority message interrupt line */
    static const uint32_t FDCANX_ILS_TCL_MASK = UINT32_C(0x00000200);         /** @brief Transmission completed interrupt line */
    static const uint32_t FDCANX_ILS_TCFL_MASK = UINT32_C(0x00000400);        /** @brief Transmission cancellation finished interrupt line */
    static const uint32_t FDCANX_ILS_TEFL_MASK = UINT32_C(0x00000800);        /** @brief Tx FIFO empty interrupt line */
    static const uint32_t FDCANX_ILS_TEFNL_MASK = UINT32_C(0x00001000);       /** @brief Tx event FIFO new entry interrupt line */
    static const uint32_t FDCANX_ILS_TEFWL_MASK = UINT32_C(0x00002000);       /** @brief Tx event FIFO watermark reached interrupt line */
    static const uint32_t FDCANX_ILS_TEFFL_MASK = UINT32_C(0x00004000);       /** @brief Tx event FIFO full interrupt line */
    static const uint32_t FDCANX_ILS_TEFLL_MASK = UINT32_C(0x00008000);       /** @brief Tx event FIFO element lost interrupt line */
    static const uint32_t FDCANX_ILS_TSWL_MASK = UINT32_C(0x00010000);        /** @brief Timestamp wraparound interrupt line */
    static const uint32_t FDCANX_ILS_MRAFL_MASK = UINT32_C(0x00020000);       /** @brief Message RAM access failure interrupt line */
    static const uint32_t FDCANX_ILS_TOOL_MASK = UINT32_C(0x00040000);        /** @brief Timeout occurred interrupt line */
    static const uint32_t FDCANX_ILS_DRXL_MASK = UINT32_C(0x00080000);        /** @brief Message stored to dedicated rx buffer interrupt line */
    static const uint32_t FDCANX_ILS_BECL_MASK = UINT32_C(0x00100000);        /** @brief Bit error corrected interrupt line */
    static const uint32_t FDCANX_ILS_BEUL_MASK = UINT32_C(0x00200000);        /** @brief Bit error uncorrected interrupt line */
    static const uint32_t FDCANX_ILS_ELOL_MASK = UINT32_C(0x00400000);        /** @brief Error logging overflow interrupt line */
    static const uint32_t FDCANX_ILS_EPL_MASK = UINT32_C(0x00800000);         /** @brief Error passive interrupt line */
    static const uint32_t FDCANX_ILS_EWL_MASK = UINT32_C(0x01000000);         /** @brief Warning status interrupt line */
    static const uint32_t FDCANX_ILS_BOL_MASK = UINT32_C(0x02000000);         /** @brief Bus_Off status */
    static const uint32_t FDCANX_ILS_WDIL_MASK = UINT32_C(0x04000000);        /** @brief Watchdog interrupt line */
    static const uint32_t FDCANX_ILS_PEAL_MASK = UINT32_C(0x08000000);        /** @brief Protocol error in arbitration phase line */
    static const uint32_t FDCANX_ILS_PEDL_MASK = UINT32_C(0x10000000);        /** @brief Protocol error in data phase line */
    static const uint32_t FDCANX_ILS_ARAL_MASK = UINT32_C(0x20000000);        /** @brief Access to reserved address line */
    static const uint32_t FDCANX_ILE_EINT0_MASK = UINT32_C(0x00000001);       /** @brief Enable interrupt line 0 */
    static const uint32_t FDCANX_ILE_EINT1_MASK = UINT32_C(0x00000002);       /** @brief Enable interrupt line 1 */
    static const uint32_t FDCANX_GFC_RRFE_MASK = UINT32_C(0x00000001);        /** @brief Reject remote frames extended */
    static const uint32_t FDCANX_GFC_RRFS_MASK = UINT32_C(0x00000002);        /** @brief Reject remote frames standard */
    static const uint32_t FDCANX_GFC_ANFE_MASK = UINT32_C(0x0000000C);        /** @brief Accept non-matching frames extended */
    static const uint32_t FDCANX_GFC_ANFS_MASK = UINT32_C(0x00000030);        /** @brief Accept non-matching frames standard */
    static const uint32_t FDCANX_SIDFC_FLSSA_MASK = UINT32_C(0x0000FFFC);     /** @brief Filter list standard start address */
    static const uint32_t FDCANX_SIDFC_LSS_MASK = UINT32_C(0x00FF0000);       /** @brief List size standard */
    static const uint32_t FDCANX_XIDFC_FLESA_MASK = UINT32_C(0x0000FFFC);     /** @brief Filter list standard start address */
    static const uint32_t FDCANX_XIDFC_LSE_MASK = UINT32_C(0x00FF0000);       /** @brief List size extended */
    static const uint32_t FDCANX_XIDAM_EIDM_MASK = UINT32_C(0x1FFFFFFF);      /** @brief Extended ID mask */
    static const uint32_t FDCANX_HPMS_BIDX_MASK = UINT32_C(0x0000003F);       /** @brief Buffer index */
    static const uint32_t FDCANX_HPMS_MSI_MASK = UINT32_C(0x000000C0);        /** @brief Message storage indicator */
    static const uint32_t FDCANX_HPMS_FIDX_MASK = UINT32_C(0x00007F00);       /** @brief Filter index */
    static const uint32_t FDCANX_HPMS_FLST_MASK = UINT32_C(0x00008000);       /** @brief Filter list */
    static const uint32_t FDCANX_RXF0C_F0SA_MASK = UINT32_C(0x0000FFFC);      /** @brief Rx FIFO 0 start address */
    static const uint32_t FDCANX_RXF0C_F0S_MASK = UINT32_C(0x00FF0000);       /** @brief Rx FIFO 0 size */
    static const uint32_t FDCANX_RXF0C_F0WM_MASK = UINT32_C(0xFF000000);      /** @brief FIFO 0 watermark */
    static const uint32_t FDCANX_RXF0S_F0FL_MASK = UINT32_C(0x0000007F);      /** @brief Rx FIFO 0 fill level */
    static const uint32_t FDCANX_RXF0S_F0G_MASK = UINT32_C(0x00003F00);       /** @brief Rx FIFO 0 get index */
    static const uint32_t FDCANX_RXF0S_F0P_MASK = UINT32_C(0x003F0000);       /** @brief Rx FIFO 0 put index */
    static const uint32_t FDCANX_RXF0S_F0F_MASK = UINT32_C(0x01000000);       /** @brief Rx FIFO 0 full */
    static const uint32_t FDCANX_RXF0S_RF0L_MASK = UINT32_C(0x02000000);      /** @brief Rx FIFO 0 message lost */
    static const uint32_t FDCANX_RXF0A_FA01_MASK = UINT32_C(0x0000003F);      /** @brief Rx FIFO 0 acknowledge index */
    static const uint32_t FDCANX_RXBC_RBSA_MASK = UINT32_C(0x0000FFFC);       /** @brief Rx buffer start address */
    static const uint32_t FDCANX_RXF1C_F1SA_MASK = UINT32_C(0x0000FFFC);      /** @brief Rx FIFO 1 start address */
    static const uint32_t FDCANX_RXF1C_F1S_MASK = UINT32_C(0x007F0000);       /** @brief Rx FIFO 1 size */
    static const uint32_t FDCANX_RXF1C_F1WM_MASK = UINT32_C(0x7F000000);      /** @brief Rx FIFO 1 watermark */
    static const uint32_t FDCANX_RXF1S_F1FL_MASK = UINT32_C(0x0000007F);      /** @brief Rx FIFO 1 fill level */
    static const uint32_t FDCANX_RXF1S_F1GI_MASK = UINT32_C(0x00007F00);      /** @brief Rx FIFO 1 get index */
    static const uint32_t FDCANX_RXF1S_F1PI_MASK = UINT32_C(0x007F0000);      /** @brief Rx FIFO 1 put index */
    static const uint32_t FDCANX_RXF1S_F1F_MASK = UINT32_C(0x01000000);       /** @brief Rx FIFO 1 full */
    static const uint32_t FDCANX_RXF1S_RF1L_MASK = UINT32_C(0x02000000);      /** @brief Rx FIFO 1 message lost */
    static const uint32_t FDCANX_RXF1S_DMS_MASK = UINT32_C(0xC0000000);       /** @brief Debug message status */
    static const uint32_t FDCANX_RXF1A_F1AI_MASK = UINT32_C(0x0000003F);      /** @brief Rx FIFO 1 acknowledge index */
    static const uint32_t FDCANX_RXESC_F0DS_MASK = UINT32_C(0x00000007);      /** @brief Rx FIFO 1 data field size: */
    static const uint32_t FDCANX_RXESC_F1DS_MASK = UINT32_C(0x00000070);      /** @brief Rx FIFO 0 data field size: */
    static const uint32_t FDCANX_RXESC_RBDS_MASK = UINT32_C(0x00000700);      /** @brief Rx buffer data field size: */
    static const uint32_t FDCANX_TXBC_TBSA_MASK = UINT32_C(0x0000FFFC);       /** @brief Tx buffers start address */
    static const uint32_t FDCANX_TXBC_NDTB_MASK = UINT32_C(0x003F0000);       /** @brief Number of dedicated transmit buffers */
    static const uint32_t FDCANX_TXBC_TFQS_MASK = UINT32_C(0x3F000000);       /** @brief Transmit fifo/queue size */
    static const uint32_t FDCANX_TXBC_TFQM_MASK = UINT32_C(0x40000000);       /** @brief Tx fifo/queue mode */
    static const uint32_t FDCANX_TXFQS_TFFL_MASK = UINT32_C(0x0000003F);      /** @brief Tx FIFO free level */
    static const uint32_t FDCANX_TXFQS_TFGI_MASK = UINT32_C(0x00001F00);      /** @brief TFGI */
    static const uint32_t FDCANX_TXFQS_TFQPI_MASK = UINT32_C(0x001F0000);     /** @brief Tx fifo/queue put index */
    static const uint32_t FDCANX_TXFQS_TFQF_MASK = UINT32_C(0x00200000);      /** @brief Tx fifo/queue full */
    static const uint32_t FDCANX_TXESC_TBDS_MASK = UINT32_C(0x00000007);      /** @brief Tx buffer data field size: */
    static const uint32_t FDCANX_TXEFC_EFSA_MASK = UINT32_C(0x0000FFFC);      /** @brief Event FIFO start address */
    static const uint32_t FDCANX_TXEFC_EFS_MASK = UINT32_C(0x003F0000);       /** @brief Event FIFO size */
    static const uint32_t FDCANX_TXEFC_EFWM_MASK = UINT32_C(0x3F000000);      /** @brief Event FIFO watermark */
    static const uint32_t FDCANX_TXEFS_EFFL_MASK = UINT32_C(0x0000003F);      /** @brief Event FIFO fill level */
    static const uint32_t FDCANX_TXEFS_EFGI_MASK = UINT32_C(0x00001F00);      /** @brief Event FIFO get index. */
    static const uint32_t FDCANX_TXEFS_EFF_MASK = UINT32_C(0x01000000);       /** @brief Event FIFO full. */
    static const uint32_t FDCANX_TXEFS_TEFL_MASK = UINT32_C(0x02000000);      /** @brief Tx event FIFO element lost. */
    static const uint32_t FDCANX_TXEFA_EFAI_MASK = UINT32_C(0x0000001F);      /** @brief Event FIFO acknowledge index */
    static const uint32_t FDCANX_TTTMC_TMSA_MASK = UINT32_C(0x0000FFFC);      /** @brief Trigger memory start address */
    static const uint32_t FDCANX_TTTMC_TME_MASK = UINT32_C(0x007F0000);       /** @brief Trigger memory elements */
    static const uint32_t FDCANX_TTRMC_RID_MASK = UINT32_C(0x1FFFFFFF);       /** @brief Reference identifier. */
    static const uint32_t FDCANX_TTRMC_XTD_MASK = UINT32_C(0x40000000);       /** @brief Extended identifier */
    static const uint32_t FDCANX_TTRMC_RMPS_MASK = UINT32_C(0x80000000);      /** @brief Reference message payload select */
    static const uint32_t FDCANX_TTOCF_OM_MASK = UINT32_C(0x00000003);        /** @brief Operation mode */
    static const uint32_t FDCANX_TTOCF_GEN_MASK = UINT32_C(0x00000008);       /** @brief Gap enable */
    static const uint32_t FDCANX_TTOCF_TM_MASK = UINT32_C(0x00000010);        /** @brief Time master */
    static const uint32_t FDCANX_TTOCF_LDSDL_MASK = UINT32_C(0x000000E0);     /** @brief LD of synchronization deviation limit */
    static const uint32_t FDCANX_TTOCF_IRTO_MASK = UINT32_C(0x00007F00);      /** @brief Initial reference trigger offset */
    static const uint32_t FDCANX_TTOCF_EECS_MASK = UINT32_C(0x00008000);      /** @brief Enable external clock synchronization */
    static const uint32_t FDCANX_TTOCF_AWL_MASK = UINT32_C(0x00FF0000);       /** @brief Application watchdog limit */
    static const uint32_t FDCANX_TTOCF_EGTF_MASK = UINT32_C(0x01000000);      /** @brief Enable global time filtering */
    static const uint32_t FDCANX_TTOCF_ECC_MASK = UINT32_C(0x02000000);       /** @brief Enable clock calibration */
    static const uint32_t FDCANX_TTOCF_EVTP_MASK = UINT32_C(0x04000000);      /** @brief Event trigger polarity */
    static const uint32_t FDCANX_TTMLM_CCM_MASK = UINT32_C(0x0000003F);       /** @brief Cycle count max */
    static const uint32_t FDCANX_TTMLM_CSS_MASK = UINT32_C(0x000000C0);       /** @brief Cycle start synchronization */
    static const uint32_t FDCANX_TTMLM_TXEW_MASK = UINT32_C(0x00000F00);      /** @brief Tx enable window */
    static const uint32_t FDCANX_TTMLM_ENTT_MASK = UINT32_C(0x0FFF0000);      /** @brief Expected number of tx triggers */
    static const uint32_t FDCANX_TURCF_NCL_MASK = UINT32_C(0x0000FFFF);       /** @brief Numerator configuration low. */
    static const uint32_t FDCANX_TURCF_DC_MASK = UINT32_C(0x3FFF0000);        /** @brief Denominator configuration. */
    static const uint32_t FDCANX_TURCF_ELT_MASK = UINT32_C(0x80000000);       /** @brief Enable local time */
    static const uint32_t FDCANX_TTOCN_SGT_MASK = UINT32_C(0x00000001);       /** @brief Set global time */
    static const uint32_t FDCANX_TTOCN_ECS_MASK = UINT32_C(0x00000002);       /** @brief External clock synchronization */
    static const uint32_t FDCANX_TTOCN_SWP_MASK = UINT32_C(0x00000004);       /** @brief Stop watch polarity */
    static const uint32_t FDCANX_TTOCN_SWS_MASK = UINT32_C(0x00000018);       /** @brief Stop watch source. */
    static const uint32_t FDCANX_TTOCN_RTIE_MASK = UINT32_C(0x00000020);      /** @brief Register time mark interrupt pulse enable */
    static const uint32_t FDCANX_TTOCN_TMC_MASK = UINT32_C(0x000000C0);       /** @brief Register time mark compare */
    static const uint32_t FDCANX_TTOCN_TTIE_MASK = UINT32_C(0x00000100);      /** @brief Trigger time mark interrupt pulse enable */
    static const uint32_t FDCANX_TTOCN_GCS_MASK = UINT32_C(0x00000200);       /** @brief Gap control select */
    static const uint32_t FDCANX_TTOCN_FGP_MASK = UINT32_C(0x00000400);       /** @brief Finish gap. */
    static const uint32_t FDCANX_TTOCN_TMG_MASK = UINT32_C(0x00000800);       /** @brief Time mark gap */
    static const uint32_t FDCANX_TTOCN_NIG_MASK = UINT32_C(0x00001000);       /** @brief Next is gap */
    static const uint32_t FDCANX_TTOCN_ESCN_MASK = UINT32_C(0x00002000);      /** @brief External synchronization control */
    static const uint32_t FDCANX_TTOCN_LCKC_MASK = UINT32_C(0x00008000);      /** @brief TT operation control register locked */
    static const uint32_t FDCANX_CAN_TTGTP_NCL_MASK = UINT32_C(0x0000FFFF);   /** @brief Time preset */
    static const uint32_t FDCANX_CAN_TTGTP_CTP_MASK = UINT32_C(0xFFFF0000);   /** @brief Cycle time target phase */
    static const uint32_t FDCANX_TTTMK_TM_MASK = UINT32_C(0x0000FFFF);        /** @brief Time mark */
    static const uint32_t FDCANX_TTTMK_TICC_MASK = UINT32_C(0x007F0000);      /** @brief Time mark cycle code */
    static const uint32_t FDCANX_TTTMK_LCKM_MASK = UINT32_C(0x80000000);      /** @brief TT time mark register locked */
    static const uint32_t FDCANX_TTIR_SBC_MASK = UINT32_C(0x00000001);        /** @brief Start of basic cycle */
    static const uint32_t FDCANX_TTIR_SMC_MASK = UINT32_C(0x00000002);        /** @brief Start of matrix cycle */
    static const uint32_t FDCANX_TTIR_CSM_MASK = UINT32_C(0x00000004);        /** @brief Change of synchronization mode */
    static const uint32_t FDCANX_TTIR_SOG_MASK = UINT32_C(0x00000008);        /** @brief Start of gap */
    static const uint32_t FDCANX_TTIR_RTMI_MASK = UINT32_C(0x00000010);       /** @brief Register time mark interrupt. */
    static const uint32_t FDCANX_TTIR_TTMI_MASK = UINT32_C(0x00000020);       /** @brief Trigger time mark event internal */
    static const uint32_t FDCANX_TTIR_SWE_MASK = UINT32_C(0x00000040);        /** @brief Stop watch event */
    static const uint32_t FDCANX_TTIR_GTW_MASK = UINT32_C(0x00000080);        /** @brief Global time wrap */
    static const uint32_t FDCANX_TTIR_GTD_MASK = UINT32_C(0x00000100);        /** @brief Global time discontinuity */
    static const uint32_t FDCANX_TTIR_GTE_MASK = UINT32_C(0x00000200);        /** @brief Global time error */
    static const uint32_t FDCANX_TTIR_TXU_MASK = UINT32_C(0x00000400);        /** @brief Tx count underflow */
    static const uint32_t FDCANX_TTIR_TXO_MASK = UINT32_C(0x00000800);        /** @brief Tx count overflow */
    static const uint32_t FDCANX_TTIR_SE1_MASK = UINT32_C(0x00001000);        /** @brief Scheduling error 1 */
    static const uint32_t FDCANX_TTIR_SE2_MASK = UINT32_C(0x00002000);        /** @brief Scheduling error 2 */
    static const uint32_t FDCANX_TTIR_ELC_MASK = UINT32_C(0x00004000);        /** @brief Error level changed. */
    static const uint32_t FDCANX_TTIR_IWTG_MASK = UINT32_C(0x00008000);       /** @brief Initialization watch trigger */
    static const uint32_t FDCANX_TTIR_WT_MASK = UINT32_C(0x00010000);         /** @brief Watch trigger */
    static const uint32_t FDCANX_TTIR_AW_MASK = UINT32_C(0x00020000);         /** @brief Application watchdog */
    static const uint32_t FDCANX_TTIR_CER_MASK = UINT32_C(0x00040000);        /** @brief Configuration error */
    static const uint32_t FDCANX_TTIE_SBCE_MASK = UINT32_C(0x00000001);       /** @brief Start of basic cycle interrupt enable */
    static const uint32_t FDCANX_TTIE_SMCE_MASK = UINT32_C(0x00000002);       /** @brief Start of matrix cycle interrupt enable */
    static const uint32_t FDCANX_TTIE_CSME_MASK = UINT32_C(0x00000004);       /** @brief Change of synchronization mode interrupt enable */
    static const uint32_t FDCANX_TTIE_SOGE_MASK = UINT32_C(0x00000008);       /** @brief Start of gap interrupt enable */
    static const uint32_t FDCANX_TTIE_RTMIE_MASK = UINT32_C(0x00000010);      /** @brief Register time mark interrupt enable */
    static const uint32_t FDCANX_TTIE_TTMIE_MASK = UINT32_C(0x00000020);      /** @brief Trigger time mark event internal interrupt enable */
    static const uint32_t FDCANX_TTIE_SWEE_MASK = UINT32_C(0x00000040);       /** @brief Stop watch event interrupt enable */
    static const uint32_t FDCANX_TTIE_GTWE_MASK = UINT32_C(0x00000080);       /** @brief Global time wrap interrupt enable */
    static const uint32_t FDCANX_TTIE_GTDE_MASK = UINT32_C(0x00000100);       /** @brief Global time discontinuity interrupt enable */
    static const uint32_t FDCANX_TTIE_GTEE_MASK = UINT32_C(0x00000200);       /** @brief Global time error interrupt enable */
    static const uint32_t FDCANX_TTIE_TXUE_MASK = UINT32_C(0x00000400);       /** @brief Tx count underflow interrupt enable */
    static const uint32_t FDCANX_TTIE_TXOE_MASK = UINT32_C(0x00000800);       /** @brief Tx count overflow interrupt enable */
    static const uint32_t FDCANX_TTIE_SE1E_MASK = UINT32_C(0x00001000);       /** @brief Scheduling error 1 interrupt enable */
    static const uint32_t FDCANX_TTIE_SE2E_MASK = UINT32_C(0x00002000);       /** @brief Scheduling error 2 interrupt enable */
    static const uint32_t FDCANX_TTIE_ELCE_MASK = UINT32_C(0x00004000);       /** @brief Change error level interrupt enable */
    static const uint32_t FDCANX_TTIE_IWTGE_MASK = UINT32_C(0x00008000);      /** @brief Initialization watch trigger interrupt enable */
    static const uint32_t FDCANX_TTIE_WTE_MASK = UINT32_C(0x00010000);        /** @brief Watch trigger interrupt enable */
    static const uint32_t FDCANX_TTIE_AWE_MASK = UINT32_C(0x00020000);        /** @brief Application watchdog interrupt enable */
    static const uint32_t FDCANX_TTIE_CERE_MASK = UINT32_C(0x00040000);       /** @brief Configuration error interrupt enable */
    static const uint32_t FDCANX_TTILS_SBCL_MASK = UINT32_C(0x00000001);      /** @brief Start of basic cycle interrupt line */
    static const uint32_t FDCANX_TTILS_SMCL_MASK = UINT32_C(0x00000002);      /** @brief Start of matrix cycle interrupt line */
    static const uint32_t FDCANX_TTILS_CSML_MASK = UINT32_C(0x00000004);      /** @brief Change of synchronization mode interrupt line */
    static const uint32_t FDCANX_TTILS_SOGL_MASK = UINT32_C(0x00000008);      /** @brief Start of gap interrupt line */
    static const uint32_t FDCANX_TTILS_RTMIL_MASK = UINT32_C(0x00000010);     /** @brief Register time mark interrupt line */
    static const uint32_t FDCANX_TTILS_TTMIL_MASK = UINT32_C(0x00000020);     /** @brief Trigger time mark event internal interrupt line */
    static const uint32_t FDCANX_TTILS_SWEL_MASK = UINT32_C(0x00000040);      /** @brief Stop watch event interrupt line */
    static const uint32_t FDCANX_TTILS_GTWL_MASK = UINT32_C(0x00000080);      /** @brief Global time wrap interrupt line */
    static const uint32_t FDCANX_TTILS_GTDL_MASK = UINT32_C(0x00000100);      /** @brief Global time discontinuity interrupt line */
    static const uint32_t FDCANX_TTILS_GTEL_MASK = UINT32_C(0x00000200);      /** @brief Global time error interrupt line */
    static const uint32_t FDCANX_TTILS_TXUL_MASK = UINT32_C(0x00000400);      /** @brief Tx count underflow interrupt line */
    static const uint32_t FDCANX_TTILS_TXOL_MASK = UINT32_C(0x00000800);      /** @brief Tx count overflow interrupt line */
    static const uint32_t FDCANX_TTILS_SE1L_MASK = UINT32_C(0x00001000);      /** @brief Scheduling error 1 interrupt line */
    static const uint32_t FDCANX_TTILS_SE2L_MASK = UINT32_C(0x00002000);      /** @brief Scheduling error 2 interrupt line */
    static const uint32_t FDCANX_TTILS_ELCL_MASK = UINT32_C(0x00004000);      /** @brief Change error level interrupt line */
    static const uint32_t FDCANX_TTILS_IWTGL_MASK = UINT32_C(0x00008000);     /** @brief Initialization watch trigger interrupt line */
    static const uint32_t FDCANX_TTILS_WTL_MASK = UINT32_C(0x00010000);       /** @brief Watch trigger interrupt line */
    static const uint32_t FDCANX_TTILS_AWL_MASK = UINT32_C(0x00020000);       /** @brief Application watchdog interrupt line */
    static const uint32_t FDCANX_TTILS_CERL_MASK = UINT32_C(0x00040000);      /** @brief Configuration error interrupt line */
    static const uint32_t FDCANX_TTOST_EL_MASK = UINT32_C(0x00000003);        /** @brief Error level */
    static const uint32_t FDCANX_TTOST_MS_MASK = UINT32_C(0x0000000C);        /** @brief Master state. */
    static const uint32_t FDCANX_TTOST_SYS_MASK = UINT32_C(0x00000030);       /** @brief Synchronization state */
    static const uint32_t FDCANX_TTOST_GTP_MASK = UINT32_C(0x00000040);       /** @brief Quality of global time phase */
    static const uint32_t FDCANX_TTOST_QCS_MASK = UINT32_C(0x00000080);       /** @brief Quality of clock speed */
    static const uint32_t FDCANX_TTOST_RTO_MASK = UINT32_C(0x0000FF00);       /** @brief Reference trigger offset */
    static const uint32_t FDCANX_TTOST_WGTD_MASK = UINT32_C(0x00400000);      /** @brief Wait for global time discontinuity */
    static const uint32_t FDCANX_TTOST_GFI_MASK = UINT32_C(0x00800000);       /** @brief Gap finished indicator. */
    static const uint32_t FDCANX_TTOST_TMP_MASK = UINT32_C(0x07000000);       /** @brief Time master priority */
    static const uint32_t FDCANX_TTOST_GSI_MASK = UINT32_C(0x08000000);       /** @brief Gap started indicator. */
    static const uint32_t FDCANX_TTOST_WFE_MASK = UINT32_C(0x10000000);       /** @brief Wait for event */
    static const uint32_t FDCANX_TTOST_AWE_MASK = UINT32_C(0x20000000);       /** @brief Application watchdog event */
    static const uint32_t FDCANX_TTOST_WECS_MASK = UINT32_C(0x40000000);      /** @brief Wait for external clock synchronization */
    static const uint32_t FDCANX_TTOST_SPL_MASK = UINT32_C(0x80000000);       /** @brief Schedule phase lock */
    static const uint32_t FDCANX_TURNA_NAV_MASK = UINT32_C(0x0003FFFF);       /** @brief Numerator actual value */
    static const uint32_t FDCANX_TTLGT_LT_MASK = UINT32_C(0x0000FFFF);        /** @brief Local time */
    static const uint32_t FDCANX_TTLGT_GT_MASK = UINT32_C(0xFFFF0000);        /** @brief Global time */
    static const uint32_t FDCANX_TTCTC_CT_MASK = UINT32_C(0x0000FFFF);        /** @brief Cycle time */
    static const uint32_t FDCANX_TTCTC_CC_MASK = UINT32_C(0x003F0000);        /** @brief Cycle count */
    static const uint32_t FDCANX_TTCPT_CT_MASK = UINT32_C(0x0000003F);        /** @brief Cycle count value */
    static const uint32_t FDCANX_TTCPT_SWV_MASK = UINT32_C(0xFFFF0000);       /** @brief Stop watch value */
    static const uint32_t FDCANX_TTCSM_CSM_MASK = UINT32_C(0x0000FFFF);       /** @brief Cycle sync mark */
    static const uint32_t FDCANX_TTTS_SWTDEL_MASK = UINT32_C(0x00000003);     /** @brief Stop watch trigger input selection */
    static const uint32_t FDCANX_TTTS_EVTSEL_MASK = UINT32_C(0x00000030);     /** @brief Event trigger input selection */

    /** @subsection FDCANX field position array definitions */

    static const int32_t FDCANX_TTTS_NDX_POS[32] = {
      INT32_C(0),    /** @brief New data */
      INT32_C(1),    /** @brief New data */
      INT32_C(2),    /** @brief New data */
      INT32_C(3),    /** @brief New data */
      INT32_C(4),    /** @brief New data */
      INT32_C(5),    /** @brief New data */
      INT32_C(6),    /** @brief New data */
      INT32_C(7),    /** @brief New data */
      INT32_C(8),    /** @brief New data */
      INT32_C(9),    /** @brief New data */
      INT32_C(10),   /** @brief New data */
      INT32_C(11),   /** @brief New data */
      INT32_C(12),   /** @brief New data */
      INT32_C(13),   /** @brief New data */
      INT32_C(14),   /** @brief New data */
      INT32_C(15),   /** @brief New data */
      INT32_C(16),   /** @brief New data */
      INT32_C(17),   /** @brief New data */
      INT32_C(18),   /** @brief New data */
      INT32_C(19),   /** @brief New data */
      INT32_C(20),   /** @brief New data */
      INT32_C(21),   /** @brief New data */
      INT32_C(22),   /** @brief New data */
      INT32_C(23),   /** @brief New data */
      INT32_C(24),   /** @brief New data */
      INT32_C(25),   /** @brief New data */
      INT32_C(26),   /** @brief New data */
      INT32_C(27),   /** @brief New data */
      INT32_C(28),   /** @brief New data */
      INT32_C(29),   /** @brief New data */
      INT32_C(30),   /** @brief New data */
      INT32_C(31),   /** @brief New data */
    };

    static const int32_t FDCANX_TTTS_ND3X_POS[10] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(1),    /** @brief New data */
      INT32_C(2),    /** @brief New data */
      INT32_C(3),    /** @brief New data */
      INT32_C(4),    /** @brief New data */
      INT32_C(5),    /** @brief New data */
      INT32_C(6),    /** @brief New data */
      INT32_C(7),    /** @brief New data */
    };

    /** @subsection FDCANX field position definitions */

    static const int32_t FDCANX_TTTS_REL_POS = INT32_C(28);       /** @brief Core release */
    static const int32_t FDCANX_TTTS_STEP_POS = INT32_C(24);      /** @brief Step of core release */
    static const int32_t FDCANX_TTTS_SUBSTEP_POS = INT32_C(20);   /** @brief Sub-step of core release */
    static const int32_t FDCANX_TTTS_YEAR_POS = INT32_C(16);      /** @brief Timestamp year */
    static const int32_t FDCANX_TTTS_MON_POS = INT32_C(8);        /** @brief Timestamp month */
    static const int32_t FDCANX_TTTS_DAY_POS = INT32_C(0);        /** @brief Timestamp day */
    static const int32_t FDCANX_TTTS_DSJW_POS = INT32_C(0);       /** @brief Synchronization jump width */
    static const int32_t FDCANX_TTTS_DTSEG2_POS = INT32_C(4);     /** @brief Data time segment after sample point */
    static const int32_t FDCANX_TTTS_DTSEG1_POS = INT32_C(8);     /** @brief Data time segment after sample point */
    static const int32_t FDCANX_TTTS_DBRP_POS = INT32_C(16);      /** @brief Data bit rate prescaler */
    static const int32_t FDCANX_TTTS_TDC_POS = INT32_C(23);       /** @brief Transceiver delay compensation */
    static const int32_t FDCANX_TTTS_LBCK_POS = INT32_C(4);       /** @brief Loop back mode */
    static const int32_t FDCANX_TTTS_TX_POS = INT32_C(5);         /** @brief Loop back mode */
    static const int32_t FDCANX_TTTS_RX_POS = INT32_C(7);         /** @brief Control of transmit pin */
    static const int32_t FDCANX_TTTS_WDV_POS = INT32_C(8);        /** @brief Watchdog value */
    static const int32_t FDCANX_TTTS_WDC_POS = INT32_C(0);        /** @brief Watchdog configuration */
    static const int32_t FDCANX_TTTS_INIT_POS = INT32_C(0);       /** @brief Initialization */
    static const int32_t FDCANX_TTTS_CCE_POS = INT32_C(1);        /** @brief Configuration change enable */
    static const int32_t FDCANX_TTTS_ASM_POS = INT32_C(2);        /** @brief ASM restricted operation mode */
    static const int32_t FDCANX_TTTS_CSA_POS = INT32_C(3);        /** @brief Clock stop acknowledge */
    static const int32_t FDCANX_TTTS_CSR_POS = INT32_C(4);        /** @brief Clock stop request */
    static const int32_t FDCANX_TTTS_MON_POS = INT32_C(5);        /** @brief Bus monitoring mode */
    static const int32_t FDCANX_TTTS_DAR_POS = INT32_C(6);        /** @brief Disable automatic retransmission */
    static const int32_t FDCANX_TTTS_TEST_POS = INT32_C(7);       /** @brief Test mode enable */
    static const int32_t FDCANX_TTTS_FDOE_POS = INT32_C(8);       /** @brief FD operation enable */
    static const int32_t FDCANX_TTTS_BSE_POS = INT32_C(9);        /** @brief FDCAN bit rate switching */
    static const int32_t FDCANX_TTTS_PXHD_POS = INT32_C(12);      /** @brief Protocol exception handling disable */
    static const int32_t FDCANX_TTTS_EFBI_POS = INT32_C(13);      /** @brief Edge filtering during bus integration */
    static const int32_t FDCANX_TTTS_TXP_POS = INT32_C(14);       /** @brief TXP */
    static const int32_t FDCANX_TTTS_NISO_POS = INT32_C(15);      /** @brief Non ISO operation */
    static const int32_t FDCANX_TTTS_NSJW_POS = INT32_C(25);      /** @brief NSJW: nominal (re)synchronization jump width */
    static const int32_t FDCANX_TTTS_NBRP_POS = INT32_C(16);      /** @brief Bit rate prescaler */
    static const int32_t FDCANX_TTTS_NTSEG1_POS = INT32_C(8);     /** @brief Nominal time segment before sample point */
    static const int32_t FDCANX_TTTS_TSEG2_POS = INT32_C(0);      /** @brief Nominal time segment after sample point */
    static const int32_t FDCANX_TTTS_TCP_POS = INT32_C(16);       /** @brief Timestamp counter prescaler */
    static const int32_t FDCANX_TTTS_TSS_POS = INT32_C(0);        /** @brief Timestamp select */
    static const int32_t FDCANX_TTTS_TSC_POS = INT32_C(0);        /** @brief Timestamp counter */
    static const int32_t FDCANX_TTTS_ETOC_POS = INT32_C(0);       /** @brief Enable timeout counter */
    static const int32_t FDCANX_TTTS_TOS_POS = INT32_C(1);        /** @brief Timeout select */
    static const int32_t FDCANX_TTTS_TOP_POS = INT32_C(16);       /** @brief Timeout period */
    static const int32_t FDCANX_TTTS_TOC_POS = INT32_C(0);        /** @brief Timeout counter */
    static const int32_t FDCANX_TTTS_CEL_POS = INT32_C(16);       /** @brief AN error logging */
    static const int32_t FDCANX_TTTS_RP_POS = INT32_C(15);        /** @brief Receive error passive */
    static const int32_t FDCANX_TTTS_TREC_POS = INT32_C(8);       /** @brief Receive error counter */
    static const int32_t FDCANX_TTTS_TEC_POS = INT32_C(0);        /** @brief Transmit error counter */
    static const int32_t FDCANX_TTTS_LEC_POS = INT32_C(0);        /** @brief Last error code */
    static const int32_t FDCANX_TTTS_ACT_POS = INT32_C(3);        /** @brief Activity */
    static const int32_t FDCANX_TTTS_EP_POS = INT32_C(5);         /** @brief Error passive */
    static const int32_t FDCANX_TTTS_EW_POS = INT32_C(6);         /** @brief Warning status */
    static const int32_t FDCANX_TTTS_BO_POS = INT32_C(7);         /** @brief Bus_Off status */
    static const int32_t FDCANX_TTTS_DLEC_POS = INT32_C(8);       /** @brief Data last error code */
    static const int32_t FDCANX_TTTS_RESI_POS = INT32_C(11);      /** @brief ESI flag of last received FDCAN message */
    static const int32_t FDCANX_TTTS_RBRS_POS = INT32_C(12);      /** @brief BRS flag of last received FDCAN message */
    static const int32_t FDCANX_TTTS_REDL_POS = INT32_C(13);      /** @brief Received FDCAN message */
    static const int32_t FDCANX_TTTS_PXE_POS = INT32_C(14);       /** @brief Protocol exception event */
    static const int32_t FDCANX_TTTS_TDCV_POS = INT32_C(16);      /** @brief Transmitter delay compensation value */
    static const int32_t FDCANX_TTTS_TDCF_POS = INT32_C(0);       /** @brief Transmitter delay compensation filter window length */
    static const int32_t FDCANX_TTTS_TDCO_POS = INT32_C(8);       /** @brief Transmitter delay compensation offset */
    static const int32_t FDCANX_TTTS_RF0N_POS = INT32_C(0);       /** @brief Rx FIFO 0 new message */
    static const int32_t FDCANX_TTTS_RF0W_POS = INT32_C(1);       /** @brief Rx FIFO 0 full */
    static const int32_t FDCANX_TTTS_RF0F_POS = INT32_C(2);       /** @brief Rx FIFO 0 full */
    static const int32_t FDCANX_TTTS_RF0L_POS = INT32_C(3);       /** @brief Rx FIFO 0 message lost */
    static const int32_t FDCANX_TTTS_RF1N_POS = INT32_C(4);       /** @brief Rx FIFO 1 new message */
    static const int32_t FDCANX_TTTS_RF1W_POS = INT32_C(5);       /** @brief Rx FIFO 1 watermark reached */
    static const int32_t FDCANX_TTTS_RF1F_POS = INT32_C(6);       /** @brief Rx FIFO 1 watermark reached */
    static const int32_t FDCANX_TTTS_RF1L_POS = INT32_C(7);       /** @brief Rx FIFO 1 message lost */
    static const int32_t FDCANX_TTTS_HPM_POS = INT32_C(8);        /** @brief High priority message */
    static const int32_t FDCANX_TTTS_TC_POS = INT32_C(9);         /** @brief Transmission completed */
    static const int32_t FDCANX_TTTS_TCF_POS = INT32_C(10);       /** @brief Transmission cancellation finished */
    static const int32_t FDCANX_TTTS_TEF_POS = INT32_C(11);       /** @brief Tx FIFO empty */
    static const int32_t FDCANX_TTTS_TEFN_POS = INT32_C(12);      /** @brief Tx event FIFO new entry */
    static const int32_t FDCANX_TTTS_TEFW_POS = INT32_C(13);      /** @brief Tx event FIFO watermark reached */
    static const int32_t FDCANX_TTTS_TEFF_POS = INT32_C(14);      /** @brief Tx event FIFO full */
    static const int32_t FDCANX_TTTS_TEFL_POS = INT32_C(15);      /** @brief Tx event FIFO element lost */
    static const int32_t FDCANX_TTTS_TSW_POS = INT32_C(16);       /** @brief Timestamp wraparound */
    static const int32_t FDCANX_TTTS_MRAF_POS = INT32_C(17);      /** @brief Message RAM access failure */
    static const int32_t FDCANX_TTTS_TOO_POS = INT32_C(18);       /** @brief Timeout occurred */
    static const int32_t FDCANX_TTTS_DRX_POS = INT32_C(19);       /** @brief Message stored to dedicated rx buffer */
    static const int32_t FDCANX_TTTS_ELO_POS = INT32_C(22);       /** @brief Error logging overflow */
    static const int32_t FDCANX_TTTS_EP_POS = INT32_C(23);        /** @brief Error passive */
    static const int32_t FDCANX_TTTS_EW_POS = INT32_C(24);        /** @brief Warning status */
    static const int32_t FDCANX_TTTS_BO_POS = INT32_C(25);        /** @brief Bus_Off status */
    static const int32_t FDCANX_TTTS_WDI_POS = INT32_C(26);       /** @brief Watchdog interrupt */
    static const int32_t FDCANX_TTTS_PEA_POS = INT32_C(27);       /** @brief Protocol error in arbitration phase (nominal bit time is used) */
    static const int32_t FDCANX_TTTS_PED_POS = INT32_C(28);       /** @brief Protocol error in data phase (data bit time is used) */
    static const int32_t FDCANX_TTTS_ARA_POS = INT32_C(29);       /** @brief Access to reserved address */
    static const int32_t FDCANX_TTTS_RF0NE_POS = INT32_C(0);      /** @brief Rx FIFO 0 new message enable */
    static const int32_t FDCANX_TTTS_RF0WE_POS = INT32_C(1);      /** @brief Rx FIFO 0 full enable */
    static const int32_t FDCANX_TTTS_RF0FE_POS = INT32_C(2);      /** @brief Rx FIFO 0 full enable */
    static const int32_t FDCANX_TTTS_RF0LE_POS = INT32_C(3);      /** @brief Rx FIFO 0 message lost enable */
    static const int32_t FDCANX_TTTS_RF1NE_POS = INT32_C(4);      /** @brief Rx FIFO 1 new message enable */
    static const int32_t FDCANX_TTTS_RF1WE_POS = INT32_C(5);      /** @brief Rx FIFO 1 watermark reached enable */
    static const int32_t FDCANX_TTTS_RF1FE_POS = INT32_C(6);      /** @brief Rx FIFO 1 watermark reached enable */
    static const int32_t FDCANX_TTTS_RF1LE_POS = INT32_C(7);      /** @brief Rx FIFO 1 message lost enable */
    static const int32_t FDCANX_TTTS_HPME_POS = INT32_C(8);       /** @brief High priority message enable */
    static const int32_t FDCANX_TTTS_TCE_POS = INT32_C(9);        /** @brief Transmission completed enable */
    static const int32_t FDCANX_TTTS_TCFE_POS = INT32_C(10);      /** @brief Transmission cancellation finished enable */
    static const int32_t FDCANX_TTTS_TEFE_POS = INT32_C(11);      /** @brief Tx FIFO empty enable */
    static const int32_t FDCANX_TTTS_TEFNE_POS = INT32_C(12);     /** @brief Tx event FIFO new entry enable */
    static const int32_t FDCANX_TTTS_TEFWE_POS = INT32_C(13);     /** @brief Tx event FIFO watermark reached enable */
    static const int32_t FDCANX_TTTS_TEFFE_POS = INT32_C(14);     /** @brief Tx event FIFO full enable */
    static const int32_t FDCANX_TTTS_TEFLE_POS = INT32_C(15);     /** @brief Tx event FIFO element lost enable */
    static const int32_t FDCANX_TTTS_TSWE_POS = INT32_C(16);      /** @brief Timestamp wraparound enable */
    static const int32_t FDCANX_TTTS_MRAFE_POS = INT32_C(17);     /** @brief Message RAM access failure enable */
    static const int32_t FDCANX_TTTS_TOOE_POS = INT32_C(18);      /** @brief Timeout occurred enable */
    static const int32_t FDCANX_TTTS_DRXE_POS = INT32_C(19);      /** @brief Message stored to dedicated rx buffer enable */
    static const int32_t FDCANX_TTTS_BECE_POS = INT32_C(20);      /** @brief Bit error corrected interrupt enable */
    static const int32_t FDCANX_TTTS_BEUE_POS = INT32_C(21);      /** @brief Bit error uncorrected interrupt enable */
    static const int32_t FDCANX_TTTS_ELOE_POS = INT32_C(22);      /** @brief Error logging overflow enable */
    static const int32_t FDCANX_TTTS_EPE_POS = INT32_C(23);       /** @brief Error passive enable */
    static const int32_t FDCANX_TTTS_EWE_POS = INT32_C(24);       /** @brief Warning status enable */
    static const int32_t FDCANX_TTTS_BOE_POS = INT32_C(25);       /** @brief Bus_Off status enable */
    static const int32_t FDCANX_TTTS_WDIE_POS = INT32_C(26);      /** @brief Watchdog interrupt enable */
    static const int32_t FDCANX_TTTS_PEAE_POS = INT32_C(27);      /** @brief Protocol error in arbitration phase enable */
    static const int32_t FDCANX_TTTS_PEDE_POS = INT32_C(28);      /** @brief Protocol error in data phase enable */
    static const int32_t FDCANX_TTTS_ARAE_POS = INT32_C(29);      /** @brief Access to reserved address enable */
    static const int32_t FDCANX_TTTS_RF0NL_POS = INT32_C(0);      /** @brief Rx FIFO 0 new message interrupt line */
    static const int32_t FDCANX_TTTS_RF0WL_POS = INT32_C(1);      /** @brief Rx FIFO 0 watermark reached interrupt line */
    static const int32_t FDCANX_TTTS_RF0FL_POS = INT32_C(2);      /** @brief Rx FIFO 0 full interrupt line */
    static const int32_t FDCANX_TTTS_RF0LL_POS = INT32_C(3);      /** @brief Rx FIFO 0 message lost interrupt line */
    static const int32_t FDCANX_TTTS_RF1NL_POS = INT32_C(4);      /** @brief Rx FIFO 1 new message interrupt line */
    static const int32_t FDCANX_TTTS_RF1WL_POS = INT32_C(5);      /** @brief Rx FIFO 1 watermark reached interrupt line */
    static const int32_t FDCANX_TTTS_RF1FL_POS = INT32_C(6);      /** @brief Rx FIFO 1 full interrupt line */
    static const int32_t FDCANX_TTTS_RF1LL_POS = INT32_C(7);      /** @brief Rx FIFO 1 message lost interrupt line */
    static const int32_t FDCANX_TTTS_HPML_POS = INT32_C(8);       /** @brief High priority message interrupt line */
    static const int32_t FDCANX_TTTS_TCL_POS = INT32_C(9);        /** @brief Transmission completed interrupt line */
    static const int32_t FDCANX_TTTS_TCFL_POS = INT32_C(10);      /** @brief Transmission cancellation finished interrupt line */
    static const int32_t FDCANX_TTTS_TEFL_POS = INT32_C(11);      /** @brief Tx FIFO empty interrupt line */
    static const int32_t FDCANX_TTTS_TEFNL_POS = INT32_C(12);     /** @brief Tx event FIFO new entry interrupt line */
    static const int32_t FDCANX_TTTS_TEFWL_POS = INT32_C(13);     /** @brief Tx event FIFO watermark reached interrupt line */
    static const int32_t FDCANX_TTTS_TEFFL_POS = INT32_C(14);     /** @brief Tx event FIFO full interrupt line */
    static const int32_t FDCANX_TTTS_TEFLL_POS = INT32_C(15);     /** @brief Tx event FIFO element lost interrupt line */
    static const int32_t FDCANX_TTTS_TSWL_POS = INT32_C(16);      /** @brief Timestamp wraparound interrupt line */
    static const int32_t FDCANX_TTTS_MRAFL_POS = INT32_C(17);     /** @brief Message RAM access failure interrupt line */
    static const int32_t FDCANX_TTTS_TOOL_POS = INT32_C(18);      /** @brief Timeout occurred interrupt line */
    static const int32_t FDCANX_TTTS_DRXL_POS = INT32_C(19);      /** @brief Message stored to dedicated rx buffer interrupt line */
    static const int32_t FDCANX_TTTS_BECL_POS = INT32_C(20);      /** @brief Bit error corrected interrupt line */
    static const int32_t FDCANX_TTTS_BEUL_POS = INT32_C(21);      /** @brief Bit error uncorrected interrupt line */
    static const int32_t FDCANX_TTTS_ELOL_POS = INT32_C(22);      /** @brief Error logging overflow interrupt line */
    static const int32_t FDCANX_TTTS_EPL_POS = INT32_C(23);       /** @brief Error passive interrupt line */
    static const int32_t FDCANX_TTTS_EWL_POS = INT32_C(24);       /** @brief Warning status interrupt line */
    static const int32_t FDCANX_TTTS_BOL_POS = INT32_C(25);       /** @brief Bus_Off status */
    static const int32_t FDCANX_TTTS_WDIL_POS = INT32_C(26);      /** @brief Watchdog interrupt line */
    static const int32_t FDCANX_TTTS_PEAL_POS = INT32_C(27);      /** @brief Protocol error in arbitration phase line */
    static const int32_t FDCANX_TTTS_PEDL_POS = INT32_C(28);      /** @brief Protocol error in data phase line */
    static const int32_t FDCANX_TTTS_ARAL_POS = INT32_C(29);      /** @brief Access to reserved address line */
    static const int32_t FDCANX_TTTS_EINT0_POS = INT32_C(0);      /** @brief Enable interrupt line 0 */
    static const int32_t FDCANX_TTTS_EINT1_POS = INT32_C(1);      /** @brief Enable interrupt line 1 */
    static const int32_t FDCANX_TTTS_RRFE_POS = INT32_C(0);       /** @brief Reject remote frames extended */
    static const int32_t FDCANX_TTTS_RRFS_POS = INT32_C(1);       /** @brief Reject remote frames standard */
    static const int32_t FDCANX_TTTS_ANFE_POS = INT32_C(2);       /** @brief Accept non-matching frames extended */
    static const int32_t FDCANX_TTTS_ANFS_POS = INT32_C(4);       /** @brief Accept non-matching frames standard */
    static const int32_t FDCANX_TTTS_FLSSA_POS = INT32_C(2);      /** @brief Filter list standard start address */
    static const int32_t FDCANX_TTTS_LSS_POS = INT32_C(16);       /** @brief List size standard */
    static const int32_t FDCANX_TTTS_FLESA_POS = INT32_C(2);      /** @brief Filter list standard start address */
    static const int32_t FDCANX_TTTS_LSE_POS = INT32_C(16);       /** @brief List size extended */
    static const int32_t FDCANX_TTTS_EIDM_POS = INT32_C(0);       /** @brief Extended ID mask */
    static const int32_t FDCANX_TTTS_BIDX_POS = INT32_C(0);       /** @brief Buffer index */
    static const int32_t FDCANX_TTTS_MSI_POS = INT32_C(6);        /** @brief Message storage indicator */
    static const int32_t FDCANX_TTTS_FIDX_POS = INT32_C(8);       /** @brief Filter index */
    static const int32_t FDCANX_TTTS_FLST_POS = INT32_C(15);      /** @brief Filter list */
    static const int32_t FDCANX_TTTS_F0SA_POS = INT32_C(2);       /** @brief Rx FIFO 0 start address */
    static const int32_t FDCANX_TTTS_F0S_POS = INT32_C(16);       /** @brief Rx FIFO 0 size */
    static const int32_t FDCANX_TTTS_F0WM_POS = INT32_C(24);      /** @brief FIFO 0 watermark */
    static const int32_t FDCANX_TTTS_F0FL_POS = INT32_C(0);       /** @brief Rx FIFO 0 fill level */
    static const int32_t FDCANX_TTTS_F0G_POS = INT32_C(8);        /** @brief Rx FIFO 0 get index */
    static const int32_t FDCANX_TTTS_F0P_POS = INT32_C(16);       /** @brief Rx FIFO 0 put index */
    static const int32_t FDCANX_TTTS_F0F_POS = INT32_C(24);       /** @brief Rx FIFO 0 full */
    static const int32_t FDCANX_TTTS_RF0L_POS = INT32_C(25);      /** @brief Rx FIFO 0 message lost */
    static const int32_t FDCANX_TTTS_FA01_POS = INT32_C(0);       /** @brief Rx FIFO 0 acknowledge index */
    static const int32_t FDCANX_TTTS_RBSA_POS = INT32_C(2);       /** @brief Rx buffer start address */
    static const int32_t FDCANX_TTTS_F1SA_POS = INT32_C(2);       /** @brief Rx FIFO 1 start address */
    static const int32_t FDCANX_TTTS_F1S_POS = INT32_C(16);       /** @brief Rx FIFO 1 size */
    static const int32_t FDCANX_TTTS_F1WM_POS = INT32_C(24);      /** @brief Rx FIFO 1 watermark */
    static const int32_t FDCANX_TTTS_F1FL_POS = INT32_C(0);       /** @brief Rx FIFO 1 fill level */
    static const int32_t FDCANX_TTTS_F1GI_POS = INT32_C(8);       /** @brief Rx FIFO 1 get index */
    static const int32_t FDCANX_TTTS_F1PI_POS = INT32_C(16);      /** @brief Rx FIFO 1 put index */
    static const int32_t FDCANX_TTTS_F1F_POS = INT32_C(24);       /** @brief Rx FIFO 1 full */
    static const int32_t FDCANX_TTTS_RF1L_POS = INT32_C(25);      /** @brief Rx FIFO 1 message lost */
    static const int32_t FDCANX_TTTS_DMS_POS = INT32_C(30);       /** @brief Debug message status */
    static const int32_t FDCANX_TTTS_F1AI_POS = INT32_C(0);       /** @brief Rx FIFO 1 acknowledge index */
    static const int32_t FDCANX_TTTS_F0DS_POS = INT32_C(0);       /** @brief Rx FIFO 1 data field size: */
    static const int32_t FDCANX_TTTS_F1DS_POS = INT32_C(4);       /** @brief Rx FIFO 0 data field size: */
    static const int32_t FDCANX_TTTS_RBDS_POS = INT32_C(8);       /** @brief Rx buffer data field size: */
    static const int32_t FDCANX_TTTS_TBSA_POS = INT32_C(2);       /** @brief Tx buffers start address */
    static const int32_t FDCANX_TTTS_NDTB_POS = INT32_C(16);      /** @brief Number of dedicated transmit buffers */
    static const int32_t FDCANX_TTTS_TFQS_POS = INT32_C(24);      /** @brief Transmit fifo/queue size */
    static const int32_t FDCANX_TTTS_TFQM_POS = INT32_C(30);      /** @brief Tx fifo/queue mode */
    static const int32_t FDCANX_TTTS_TFFL_POS = INT32_C(0);       /** @brief Tx FIFO free level */
    static const int32_t FDCANX_TTTS_TFGI_POS = INT32_C(8);       /** @brief TFGI */
    static const int32_t FDCANX_TTTS_TFQPI_POS = INT32_C(16);     /** @brief Tx fifo/queue put index */
    static const int32_t FDCANX_TTTS_TFQF_POS = INT32_C(21);      /** @brief Tx fifo/queue full */
    static const int32_t FDCANX_TTTS_TBDS_POS = INT32_C(0);       /** @brief Tx buffer data field size: */
    static const int32_t FDCANX_TTTS_EFSA_POS = INT32_C(2);       /** @brief Event FIFO start address */
    static const int32_t FDCANX_TTTS_EFS_POS = INT32_C(16);       /** @brief Event FIFO size */
    static const int32_t FDCANX_TTTS_EFWM_POS = INT32_C(24);      /** @brief Event FIFO watermark */
    static const int32_t FDCANX_TTTS_EFFL_POS = INT32_C(0);       /** @brief Event FIFO fill level */
    static const int32_t FDCANX_TTTS_EFGI_POS = INT32_C(8);       /** @brief Event FIFO get index. */
    static const int32_t FDCANX_TTTS_EFF_POS = INT32_C(24);       /** @brief Event FIFO full. */
    static const int32_t FDCANX_TTTS_TEFL_POS = INT32_C(25);      /** @brief Tx event FIFO element lost. */
    static const int32_t FDCANX_TTTS_EFAI_POS = INT32_C(0);       /** @brief Event FIFO acknowledge index */
    static const int32_t FDCANX_TTTS_TMSA_POS = INT32_C(2);       /** @brief Trigger memory start address */
    static const int32_t FDCANX_TTTS_TME_POS = INT32_C(16);       /** @brief Trigger memory elements */
    static const int32_t FDCANX_TTTS_RID_POS = INT32_C(0);        /** @brief Reference identifier. */
    static const int32_t FDCANX_TTTS_XTD_POS = INT32_C(30);       /** @brief Extended identifier */
    static const int32_t FDCANX_TTTS_RMPS_POS = INT32_C(31);      /** @brief Reference message payload select */
    static const int32_t FDCANX_TTTS_OM_POS = INT32_C(0);         /** @brief Operation mode */
    static const int32_t FDCANX_TTTS_GEN_POS = INT32_C(3);        /** @brief Gap enable */
    static const int32_t FDCANX_TTTS_TM_POS = INT32_C(4);         /** @brief Time master */
    static const int32_t FDCANX_TTTS_LDSDL_POS = INT32_C(5);      /** @brief LD of synchronization deviation limit */
    static const int32_t FDCANX_TTTS_IRTO_POS = INT32_C(8);       /** @brief Initial reference trigger offset */
    static const int32_t FDCANX_TTTS_EECS_POS = INT32_C(15);      /** @brief Enable external clock synchronization */
    static const int32_t FDCANX_TTTS_AWL_POS = INT32_C(16);       /** @brief Application watchdog limit */
    static const int32_t FDCANX_TTTS_EGTF_POS = INT32_C(24);      /** @brief Enable global time filtering */
    static const int32_t FDCANX_TTTS_ECC_POS = INT32_C(25);       /** @brief Enable clock calibration */
    static const int32_t FDCANX_TTTS_EVTP_POS = INT32_C(26);      /** @brief Event trigger polarity */
    static const int32_t FDCANX_TTTS_CCM_POS = INT32_C(0);        /** @brief Cycle count max */
    static const int32_t FDCANX_TTTS_CSS_POS = INT32_C(6);        /** @brief Cycle start synchronization */
    static const int32_t FDCANX_TTTS_TXEW_POS = INT32_C(8);       /** @brief Tx enable window */
    static const int32_t FDCANX_TTTS_ENTT_POS = INT32_C(16);      /** @brief Expected number of tx triggers */
    static const int32_t FDCANX_TTTS_NCL_POS = INT32_C(0);        /** @brief Numerator configuration low. */
    static const int32_t FDCANX_TTTS_DC_POS = INT32_C(16);        /** @brief Denominator configuration. */
    static const int32_t FDCANX_TTTS_ELT_POS = INT32_C(31);       /** @brief Enable local time */
    static const int32_t FDCANX_TTTS_SGT_POS = INT32_C(0);        /** @brief Set global time */
    static const int32_t FDCANX_TTTS_ECS_POS = INT32_C(1);        /** @brief External clock synchronization */
    static const int32_t FDCANX_TTTS_SWP_POS = INT32_C(2);        /** @brief Stop watch polarity */
    static const int32_t FDCANX_TTTS_SWS_POS = INT32_C(3);        /** @brief Stop watch source. */
    static const int32_t FDCANX_TTTS_RTIE_POS = INT32_C(5);       /** @brief Register time mark interrupt pulse enable */
    static const int32_t FDCANX_TTTS_TMC_POS = INT32_C(6);        /** @brief Register time mark compare */
    static const int32_t FDCANX_TTTS_TTIE_POS = INT32_C(8);       /** @brief Trigger time mark interrupt pulse enable */
    static const int32_t FDCANX_TTTS_GCS_POS = INT32_C(9);        /** @brief Gap control select */
    static const int32_t FDCANX_TTTS_FGP_POS = INT32_C(10);       /** @brief Finish gap. */
    static const int32_t FDCANX_TTTS_TMG_POS = INT32_C(11);       /** @brief Time mark gap */
    static const int32_t FDCANX_TTTS_NIG_POS = INT32_C(12);       /** @brief Next is gap */
    static const int32_t FDCANX_TTTS_ESCN_POS = INT32_C(13);      /** @brief External synchronization control */
    static const int32_t FDCANX_TTTS_LCKC_POS = INT32_C(15);      /** @brief TT operation control register locked */
    static const int32_t FDCANX_TTTS_NCL_POS = INT32_C(0);        /** @brief Time preset */
    static const int32_t FDCANX_TTTS_CTP_POS = INT32_C(16);       /** @brief Cycle time target phase */
    static const int32_t FDCANX_TTTS_TM_POS = INT32_C(0);         /** @brief Time mark */
    static const int32_t FDCANX_TTTS_TICC_POS = INT32_C(16);      /** @brief Time mark cycle code */
    static const int32_t FDCANX_TTTS_LCKM_POS = INT32_C(31);      /** @brief TT time mark register locked */
    static const int32_t FDCANX_TTTS_SBC_POS = INT32_C(0);        /** @brief Start of basic cycle */
    static const int32_t FDCANX_TTTS_SMC_POS = INT32_C(1);        /** @brief Start of matrix cycle */
    static const int32_t FDCANX_TTTS_CSM_POS = INT32_C(2);        /** @brief Change of synchronization mode */
    static const int32_t FDCANX_TTTS_SOG_POS = INT32_C(3);        /** @brief Start of gap */
    static const int32_t FDCANX_TTTS_RTMI_POS = INT32_C(4);       /** @brief Register time mark interrupt. */
    static const int32_t FDCANX_TTTS_TTMI_POS = INT32_C(5);       /** @brief Trigger time mark event internal */
    static const int32_t FDCANX_TTTS_SWE_POS = INT32_C(6);        /** @brief Stop watch event */
    static const int32_t FDCANX_TTTS_GTW_POS = INT32_C(7);        /** @brief Global time wrap */
    static const int32_t FDCANX_TTTS_GTD_POS = INT32_C(8);        /** @brief Global time discontinuity */
    static const int32_t FDCANX_TTTS_GTE_POS = INT32_C(9);        /** @brief Global time error */
    static const int32_t FDCANX_TTTS_TXU_POS = INT32_C(10);       /** @brief Tx count underflow */
    static const int32_t FDCANX_TTTS_TXO_POS = INT32_C(11);       /** @brief Tx count overflow */
    static const int32_t FDCANX_TTTS_SE1_POS = INT32_C(12);       /** @brief Scheduling error 1 */
    static const int32_t FDCANX_TTTS_SE2_POS = INT32_C(13);       /** @brief Scheduling error 2 */
    static const int32_t FDCANX_TTTS_ELC_POS = INT32_C(14);       /** @brief Error level changed. */
    static const int32_t FDCANX_TTTS_IWTG_POS = INT32_C(15);      /** @brief Initialization watch trigger */
    static const int32_t FDCANX_TTTS_WT_POS = INT32_C(16);        /** @brief Watch trigger */
    static const int32_t FDCANX_TTTS_AW_POS = INT32_C(17);        /** @brief Application watchdog */
    static const int32_t FDCANX_TTTS_CER_POS = INT32_C(18);       /** @brief Configuration error */
    static const int32_t FDCANX_TTTS_SBCE_POS = INT32_C(0);       /** @brief Start of basic cycle interrupt enable */
    static const int32_t FDCANX_TTTS_SMCE_POS = INT32_C(1);       /** @brief Start of matrix cycle interrupt enable */
    static const int32_t FDCANX_TTTS_CSME_POS = INT32_C(2);       /** @brief Change of synchronization mode interrupt enable */
    static const int32_t FDCANX_TTTS_SOGE_POS = INT32_C(3);       /** @brief Start of gap interrupt enable */
    static const int32_t FDCANX_TTTS_RTMIE_POS = INT32_C(4);      /** @brief Register time mark interrupt enable */
    static const int32_t FDCANX_TTTS_TTMIE_POS = INT32_C(5);      /** @brief Trigger time mark event internal interrupt enable */
    static const int32_t FDCANX_TTTS_SWEE_POS = INT32_C(6);       /** @brief Stop watch event interrupt enable */
    static const int32_t FDCANX_TTTS_GTWE_POS = INT32_C(7);       /** @brief Global time wrap interrupt enable */
    static const int32_t FDCANX_TTTS_GTDE_POS = INT32_C(8);       /** @brief Global time discontinuity interrupt enable */
    static const int32_t FDCANX_TTTS_GTEE_POS = INT32_C(9);       /** @brief Global time error interrupt enable */
    static const int32_t FDCANX_TTTS_TXUE_POS = INT32_C(10);      /** @brief Tx count underflow interrupt enable */
    static const int32_t FDCANX_TTTS_TXOE_POS = INT32_C(11);      /** @brief Tx count overflow interrupt enable */
    static const int32_t FDCANX_TTTS_SE1E_POS = INT32_C(12);      /** @brief Scheduling error 1 interrupt enable */
    static const int32_t FDCANX_TTTS_SE2E_POS = INT32_C(13);      /** @brief Scheduling error 2 interrupt enable */
    static const int32_t FDCANX_TTTS_ELCE_POS = INT32_C(14);      /** @brief Change error level interrupt enable */
    static const int32_t FDCANX_TTTS_IWTGE_POS = INT32_C(15);     /** @brief Initialization watch trigger interrupt enable */
    static const int32_t FDCANX_TTTS_WTE_POS = INT32_C(16);       /** @brief Watch trigger interrupt enable */
    static const int32_t FDCANX_TTTS_AWE_POS = INT32_C(17);       /** @brief Application watchdog interrupt enable */
    static const int32_t FDCANX_TTTS_CERE_POS = INT32_C(18);      /** @brief Configuration error interrupt enable */
    static const int32_t FDCANX_TTTS_SBCL_POS = INT32_C(0);       /** @brief Start of basic cycle interrupt line */
    static const int32_t FDCANX_TTTS_SMCL_POS = INT32_C(1);       /** @brief Start of matrix cycle interrupt line */
    static const int32_t FDCANX_TTTS_CSML_POS = INT32_C(2);       /** @brief Change of synchronization mode interrupt line */
    static const int32_t FDCANX_TTTS_SOGL_POS = INT32_C(3);       /** @brief Start of gap interrupt line */
    static const int32_t FDCANX_TTTS_RTMIL_POS = INT32_C(4);      /** @brief Register time mark interrupt line */
    static const int32_t FDCANX_TTTS_TTMIL_POS = INT32_C(5);      /** @brief Trigger time mark event internal interrupt line */
    static const int32_t FDCANX_TTTS_SWEL_POS = INT32_C(6);       /** @brief Stop watch event interrupt line */
    static const int32_t FDCANX_TTTS_GTWL_POS = INT32_C(7);       /** @brief Global time wrap interrupt line */
    static const int32_t FDCANX_TTTS_GTDL_POS = INT32_C(8);       /** @brief Global time discontinuity interrupt line */
    static const int32_t FDCANX_TTTS_GTEL_POS = INT32_C(9);       /** @brief Global time error interrupt line */
    static const int32_t FDCANX_TTTS_TXUL_POS = INT32_C(10);      /** @brief Tx count underflow interrupt line */
    static const int32_t FDCANX_TTTS_TXOL_POS = INT32_C(11);      /** @brief Tx count overflow interrupt line */
    static const int32_t FDCANX_TTTS_SE1L_POS = INT32_C(12);      /** @brief Scheduling error 1 interrupt line */
    static const int32_t FDCANX_TTTS_SE2L_POS = INT32_C(13);      /** @brief Scheduling error 2 interrupt line */
    static const int32_t FDCANX_TTTS_ELCL_POS = INT32_C(14);      /** @brief Change error level interrupt line */
    static const int32_t FDCANX_TTTS_IWTGL_POS = INT32_C(15);     /** @brief Initialization watch trigger interrupt line */
    static const int32_t FDCANX_TTTS_WTL_POS = INT32_C(16);       /** @brief Watch trigger interrupt line */
    static const int32_t FDCANX_TTTS_AWL_POS = INT32_C(17);       /** @brief Application watchdog interrupt line */
    static const int32_t FDCANX_TTTS_CERL_POS = INT32_C(18);      /** @brief Configuration error interrupt line */
    static const int32_t FDCANX_TTTS_EL_POS = INT32_C(0);         /** @brief Error level */
    static const int32_t FDCANX_TTTS_MS_POS = INT32_C(2);         /** @brief Master state. */
    static const int32_t FDCANX_TTTS_SYS_POS = INT32_C(4);        /** @brief Synchronization state */
    static const int32_t FDCANX_TTTS_GTP_POS = INT32_C(6);        /** @brief Quality of global time phase */
    static const int32_t FDCANX_TTTS_QCS_POS = INT32_C(7);        /** @brief Quality of clock speed */
    static const int32_t FDCANX_TTTS_RTO_POS = INT32_C(8);        /** @brief Reference trigger offset */
    static const int32_t FDCANX_TTTS_WGTD_POS = INT32_C(22);      /** @brief Wait for global time discontinuity */
    static const int32_t FDCANX_TTTS_GFI_POS = INT32_C(23);       /** @brief Gap finished indicator. */
    static const int32_t FDCANX_TTTS_TMP_POS = INT32_C(24);       /** @brief Time master priority */
    static const int32_t FDCANX_TTTS_GSI_POS = INT32_C(27);       /** @brief Gap started indicator. */
    static const int32_t FDCANX_TTTS_WFE_POS = INT32_C(28);       /** @brief Wait for event */
    static const int32_t FDCANX_TTTS_AWE_POS = INT32_C(29);       /** @brief Application watchdog event */
    static const int32_t FDCANX_TTTS_WECS_POS = INT32_C(30);      /** @brief Wait for external clock synchronization */
    static const int32_t FDCANX_TTTS_SPL_POS = INT32_C(31);       /** @brief Schedule phase lock */
    static const int32_t FDCANX_TTTS_NAV_POS = INT32_C(0);        /** @brief Numerator actual value */
    static const int32_t FDCANX_TTTS_LT_POS = INT32_C(0);         /** @brief Local time */
    static const int32_t FDCANX_TTTS_GT_POS = INT32_C(16);        /** @brief Global time */
    static const int32_t FDCANX_TTTS_CT_POS = INT32_C(0);         /** @brief Cycle time */
    static const int32_t FDCANX_TTTS_CC_POS = INT32_C(16);        /** @brief Cycle count */
    static const int32_t FDCANX_TTTS_CT_POS = INT32_C(0);         /** @brief Cycle count value */
    static const int32_t FDCANX_TTTS_SWV_POS = INT32_C(16);       /** @brief Stop watch value */
    static const int32_t FDCANX_TTTS_CSM_POS = INT32_C(0);        /** @brief Cycle sync mark */
    static const int32_t FDCANX_TTTS_SWTDEL_POS = INT32_C(0);     /** @brief Stop watch trigger input selection */
    static const int32_t FDCANX_TTTS_EVTSEL_POS = INT32_C(4);     /** @brief Event trigger input selection */

    /**********************************************************************************************
     * @section CAN_CCU Definitions
     **********************************************************************************************/

    /** @subsection CAN_CCU register definitions */

    static _RW uint32_t* const CAN_CCU_CREL_REG = (_RW uint32_t* const)UINT32_C(0x4000A800);    /** @brief Clock calibration unit core release register */
    static _RW uint32_t* const CAN_CCU_CCFG_REG = (_RW uint32_t* const)UINT32_C(0x4000A804);    /** @brief Calibration configuration register */
    static _RW uint32_t* const CAN_CCU_CSTAT_REG = (_RW uint32_t* const)UINT32_C(0x4000A808);   /** @brief Calibration status register */
    static _RW uint32_t* const CAN_CCU_CWD_REG = (_RW uint32_t* const)UINT32_C(0x4000A80C);     /** @brief Calibration watchdog register */
    static _RW uint32_t* const CAN_CCU_IR_REG = (_RW uint32_t* const)UINT32_C(0x4000A810);      /** @brief Clock calibration unit interrupt register */
    static _RW uint32_t* const CAN_CCU_IE_REG = (_RW uint32_t* const)UINT32_C(0x4000A814);      /** @brief Clock calibration unit interrupt enable register */

    /** @subsection CAN_CCU field mask definitions */

    static const uint32_t CAN_CCU_CREL_DAY_MASK = UINT32_C(0x000000FF);       /** @brief Time stamp day */
    static const uint32_t CAN_CCU_CREL_MON_MASK = UINT32_C(0x0000FF00);       /** @brief Time stamp month */
    static const uint32_t CAN_CCU_CREL_YEAR_MASK = UINT32_C(0x000F0000);      /** @brief Time stamp year */
    static const uint32_t CAN_CCU_CREL_SUBSTEP_MASK = UINT32_C(0x00F00000);   /** @brief Sub-step of core release */
    static const uint32_t CAN_CCU_CREL_STEP_MASK = UINT32_C(0x0F000000);      /** @brief Step of core release */
    static const uint32_t CAN_CCU_CREL_REL_MASK = UINT32_C(0xF0000000);       /** @brief Core release */
    static const uint32_t CAN_CCU_CCFG_TQBT_MASK = UINT32_C(0x0000001F);      /** @brief Time quanta per bit time */
    static const uint32_t CAN_CCU_CCFG_BCC_MASK = UINT32_C(0x00000040);       /** @brief Bypass clock calibration */
    static const uint32_t CAN_CCU_CCFG_CFL_MASK = UINT32_C(0x00000080);       /** @brief Calibration field length */
    static const uint32_t CAN_CCU_CCFG_OCPM_MASK = UINT32_C(0x0000FF00);      /** @brief Oscillator clock periods minimum */
    static const uint32_t CAN_CCU_CCFG_CDIV_MASK = UINT32_C(0x000F0000);      /** @brief Clock divider */
    static const uint32_t CAN_CCU_CCFG_SWR_MASK = UINT32_C(0x80000000);       /** @brief Software reset */
    static const uint32_t CAN_CCU_CSTAT_OCPC_MASK = UINT32_C(0x0003FFFF);     /** @brief Oscillator clock period counter */
    static const uint32_t CAN_CCU_CSTAT_TQC_MASK = UINT32_C(0x1FFC0000);      /** @brief Time quanta counter */
    static const uint32_t CAN_CCU_CSTAT_CALS_MASK = UINT32_C(0xC0000000);     /** @brief Calibration state */
    static const uint32_t CAN_CCU_CWD_WDC_MASK = UINT32_C(0x0000FFFF);        /** @brief WDC */
    static const uint32_t CAN_CCU_CWD_WDV_MASK = UINT32_C(0xFFFF0000);        /** @brief WDV */
    static const uint32_t CAN_CCU_IR_CWE_MASK = UINT32_C(0x00000001);         /** @brief Calibration watchdog event */
    static const uint32_t CAN_CCU_IR_CSC_MASK = UINT32_C(0x00000002);         /** @brief Calibration state changed */
    static const uint32_t CAN_CCU_IE_CWEE_MASK = UINT32_C(0x00000001);        /** @brief Calibration watchdog event enable */
    static const uint32_t CAN_CCU_IE_CSCE_MASK = UINT32_C(0x00000002);        /** @brief Calibration state changed enable */

    /** @subsection CAN_CCU field position definitions */

    static const int32_t CAN_CCU_IE_DAY_POS = INT32_C(0);        /** @brief Time stamp day */
    static const int32_t CAN_CCU_IE_MON_POS = INT32_C(8);        /** @brief Time stamp month */
    static const int32_t CAN_CCU_IE_YEAR_POS = INT32_C(16);      /** @brief Time stamp year */
    static const int32_t CAN_CCU_IE_SUBSTEP_POS = INT32_C(20);   /** @brief Sub-step of core release */
    static const int32_t CAN_CCU_IE_STEP_POS = INT32_C(24);      /** @brief Step of core release */
    static const int32_t CAN_CCU_IE_REL_POS = INT32_C(28);       /** @brief Core release */
    static const int32_t CAN_CCU_IE_TQBT_POS = INT32_C(0);       /** @brief Time quanta per bit time */
    static const int32_t CAN_CCU_IE_BCC_POS = INT32_C(6);        /** @brief Bypass clock calibration */
    static const int32_t CAN_CCU_IE_CFL_POS = INT32_C(7);        /** @brief Calibration field length */
    static const int32_t CAN_CCU_IE_OCPM_POS = INT32_C(8);       /** @brief Oscillator clock periods minimum */
    static const int32_t CAN_CCU_IE_CDIV_POS = INT32_C(16);      /** @brief Clock divider */
    static const int32_t CAN_CCU_IE_SWR_POS = INT32_C(31);       /** @brief Software reset */
    static const int32_t CAN_CCU_IE_OCPC_POS = INT32_C(0);       /** @brief Oscillator clock period counter */
    static const int32_t CAN_CCU_IE_TQC_POS = INT32_C(18);       /** @brief Time quanta counter */
    static const int32_t CAN_CCU_IE_CALS_POS = INT32_C(30);      /** @brief Calibration state */
    static const int32_t CAN_CCU_IE_WDC_POS = INT32_C(0);        /** @brief WDC */
    static const int32_t CAN_CCU_IE_WDV_POS = INT32_C(16);       /** @brief WDV */
    static const int32_t CAN_CCU_IE_CWE_POS = INT32_C(0);        /** @brief Calibration watchdog event */
    static const int32_t CAN_CCU_IE_CSC_POS = INT32_C(1);        /** @brief Calibration state changed */
    static const int32_t CAN_CCU_IE_CWEE_POS = INT32_C(0);       /** @brief Calibration watchdog event enable */
    static const int32_t CAN_CCU_IE_CSCE_POS = INT32_C(1);       /** @brief Calibration state changed enable */

    /**********************************************************************************************
     * @section MDIOS Definitions
     **********************************************************************************************/

    /** @subsection MDIOS IRQ interrupt definitions */

    static const int32_t MDIOS_WKUP_IRQ = INT32_C(119);   /** @brief MDIOS wakeup */
    static const int32_t MDIOS_IRQ = INT32_C(120);        /** @brief MDIOS global interrupt */

    /** @subsection MDIOS register array definitions */

    static _RO uint32_t* const MDIOS_DINRX_REG[32] = {
      (_RO uint32_t* const)UINT32_C(0x4000941C),   /** @brief MDIOS input data register 0 */
      (_RO uint32_t* const)UINT32_C(0x40009420),   /** @brief MDIOS input data register 1 */
      (_RO uint32_t* const)UINT32_C(0x40009424),   /** @brief MDIOS input data register 2 */
      (_RO uint32_t* const)UINT32_C(0x40009428),   /** @brief MDIOS input data register 3 */
      (_RO uint32_t* const)UINT32_C(0x4000942C),   /** @brief MDIOS input data register 4 */
      (_RO uint32_t* const)UINT32_C(0x40009430),   /** @brief MDIOS input data register 5 */
      (_RO uint32_t* const)UINT32_C(0x40009434),   /** @brief MDIOS input data register 6 */
      (_RO uint32_t* const)UINT32_C(0x40009438),   /** @brief MDIOS input data register 7 */
      (_RO uint32_t* const)UINT32_C(0x4000943C),   /** @brief MDIOS input data register 8 */
      (_RO uint32_t* const)UINT32_C(0x40009440),   /** @brief MDIOS input data register 9 */
      (_RO uint32_t* const)UINT32_C(0x40009444),   /** @brief MDIOS input data register 10 */
      (_RO uint32_t* const)UINT32_C(0x40009448),   /** @brief MDIOS input data register 11 */
      (_RO uint32_t* const)UINT32_C(0x4000944C),   /** @brief MDIOS input data register 12 */
      (_RO uint32_t* const)UINT32_C(0x40009450),   /** @brief MDIOS input data register 13 */
      (_RO uint32_t* const)UINT32_C(0x40009454),   /** @brief MDIOS input data register 14 */
      (_RO uint32_t* const)UINT32_C(0x40009458),   /** @brief MDIOS input data register 15 */
      (_RO uint32_t* const)UINT32_C(0x4000945C),   /** @brief MDIOS input data register 16 */
      (_RO uint32_t* const)UINT32_C(0x40009460),   /** @brief MDIOS input data register 17 */
      (_RO uint32_t* const)UINT32_C(0x40009464),   /** @brief MDIOS input data register 18 */
      (_RO uint32_t* const)UINT32_C(0x40009468),   /** @brief MDIOS input data register 19 */
      (_RO uint32_t* const)UINT32_C(0x4000946C),   /** @brief MDIOS input data register 20 */
      (_RO uint32_t* const)UINT32_C(0x40009470),   /** @brief MDIOS input data register 21 */
      (_RO uint32_t* const)UINT32_C(0x40009474),   /** @brief MDIOS input data register 22 */
      (_RO uint32_t* const)UINT32_C(0x40009478),   /** @brief MDIOS input data register 23 */
      (_RO uint32_t* const)UINT32_C(0x4000947C),   /** @brief MDIOS input data register 24 */
      (_RO uint32_t* const)UINT32_C(0x40009480),   /** @brief MDIOS input data register 25 */
      (_RO uint32_t* const)UINT32_C(0x40009484),   /** @brief MDIOS input data register 26 */
      (_RO uint32_t* const)UINT32_C(0x40009488),   /** @brief MDIOS input data register 27 */
      (_RO uint32_t* const)UINT32_C(0x4000948C),   /** @brief MDIOS input data register 28 */
      (_RO uint32_t* const)UINT32_C(0x40009490),   /** @brief MDIOS input data register 29 */
      (_RO uint32_t* const)UINT32_C(0x40009494),   /** @brief MDIOS input data register 30 */
      (_RO uint32_t* const)UINT32_C(0x40009498),   /** @brief MDIOS input data register 31 */
    };

    static _RW uint32_t* const MDIOS_DOUTRX_REG[32] = {
      (_RW uint32_t* const)UINT32_C(0x4000949C),   /** @brief MDIOS output data register 0 */
      (_RW uint32_t* const)UINT32_C(0x400094A0),   /** @brief MDIOS output data register 1 */
      (_RW uint32_t* const)UINT32_C(0x400094A4),   /** @brief MDIOS output data register 2 */
      (_RW uint32_t* const)UINT32_C(0x400094A8),   /** @brief MDIOS output data register 3 */
      (_RW uint32_t* const)UINT32_C(0x400094AC),   /** @brief MDIOS output data register 4 */
      (_RW uint32_t* const)UINT32_C(0x400094B0),   /** @brief MDIOS output data register 5 */
      (_RW uint32_t* const)UINT32_C(0x400094B4),   /** @brief MDIOS output data register 6 */
      (_RW uint32_t* const)UINT32_C(0x400094B8),   /** @brief MDIOS output data register 7 */
      (_RW uint32_t* const)UINT32_C(0x400094BC),   /** @brief MDIOS output data register 8 */
      (_RW uint32_t* const)UINT32_C(0x400094C0),   /** @brief MDIOS output data register 9 */
      (_RW uint32_t* const)UINT32_C(0x400094C4),   /** @brief MDIOS output data register 10 */
      (_RW uint32_t* const)UINT32_C(0x400094C8),   /** @brief MDIOS output data register 11 */
      (_RW uint32_t* const)UINT32_C(0x400094CC),   /** @brief MDIOS output data register 12 */
      (_RW uint32_t* const)UINT32_C(0x400094D0),   /** @brief MDIOS output data register 13 */
      (_RW uint32_t* const)UINT32_C(0x400094D4),   /** @brief MDIOS output data register 14 */
      (_RW uint32_t* const)UINT32_C(0x400094D8),   /** @brief MDIOS output data register 15 */
      (_RW uint32_t* const)UINT32_C(0x400094DC),   /** @brief MDIOS output data register 16 */
      (_RW uint32_t* const)UINT32_C(0x400094E0),   /** @brief MDIOS output data register 17 */
      (_RW uint32_t* const)UINT32_C(0x400094E4),   /** @brief MDIOS output data register 18 */
      (_RW uint32_t* const)UINT32_C(0x400094E8),   /** @brief MDIOS output data register 19 */
      (_RW uint32_t* const)UINT32_C(0x400094EC),   /** @brief MDIOS output data register 20 */
      (_RW uint32_t* const)UINT32_C(0x400094F0),   /** @brief MDIOS output data register 21 */
      (_RW uint32_t* const)UINT32_C(0x400094F4),   /** @brief MDIOS output data register 22 */
      (_RW uint32_t* const)UINT32_C(0x400094F8),   /** @brief MDIOS output data register 23 */
      (_RW uint32_t* const)UINT32_C(0x400094FC),   /** @brief MDIOS output data register 24 */
      (_RW uint32_t* const)UINT32_C(0x40009500),   /** @brief MDIOS output data register 25 */
      (_RW uint32_t* const)UINT32_C(0x40009504),   /** @brief MDIOS output data register 26 */
      (_RW uint32_t* const)UINT32_C(0x40009508),   /** @brief MDIOS output data register 27 */
      (_RW uint32_t* const)UINT32_C(0x4000950C),   /** @brief MDIOS output data register 28 */
      (_RW uint32_t* const)UINT32_C(0x40009510),   /** @brief MDIOS output data register 29 */
      (_RW uint32_t* const)UINT32_C(0x40009514),   /** @brief MDIOS output data register 30 */
      (_RW uint32_t* const)UINT32_C(0x40009518),   /** @brief MDIOS output data register 31 */
    };

    /** @subsection MDIOS register definitions */

    static _RW uint32_t* const MDIOS_CR_REG = (_RW uint32_t* const)UINT32_C(0x40009400);      /** @brief MDIOS configuration register */
    static _RO uint32_t* const MDIOS_WRFR_REG = (_RO uint32_t* const)UINT32_C(0x40009404);    /** @brief MDIOS write flag register */
    static _RW uint32_t* const MDIOS_CWRFR_REG = (_RW uint32_t* const)UINT32_C(0x40009408);   /** @brief MDIOS clear write flag register */
    static _RO uint32_t* const MDIOS_RDFR_REG = (_RO uint32_t* const)UINT32_C(0x4000940C);    /** @brief MDIOS read flag register */
    static _RW uint32_t* const MDIOS_CRDFR_REG = (_RW uint32_t* const)UINT32_C(0x40009410);   /** @brief MDIOS clear read flag register */
    static _RO uint32_t* const MDIOS_SR_REG = (_RO uint32_t* const)UINT32_C(0x40009414);      /** @brief MDIOS status register */
    static _RW uint32_t* const MDIOS_CLRFR_REG = (_RW uint32_t* const)UINT32_C(0x40009418);   /** @brief MDIOS clear flag register */

    /** @subsection MDIOS field mask definitions */

    static const uint32_t MDIOS_CR_EN_MASK = UINT32_C(0x00000001);             /** @brief Peripheral enable */
    static const uint32_t MDIOS_CR_WRIE_MASK = UINT32_C(0x00000002);           /** @brief Register write interrupt enable */
    static const uint32_t MDIOS_CR_RDIE_MASK = UINT32_C(0x00000004);           /** @brief Register read interrupt enable */
    static const uint32_t MDIOS_CR_EIE_MASK = UINT32_C(0x00000008);            /** @brief Error interrupt enable */
    static const uint32_t MDIOS_CR_DPC_MASK = UINT32_C(0x00000080);            /** @brief Disable preamble check */
    static const uint32_t MDIOS_CR_PORT_ADDRESS_MASK = UINT32_C(0x00001F00);   /** @brief Slaves's address */
    static const uint32_t MDIOS_SR_PERF_MASK = UINT32_C(0x00000001);           /** @brief Preamble error flag */
    static const uint32_t MDIOS_SR_SERF_MASK = UINT32_C(0x00000002);           /** @brief Start error flag */
    static const uint32_t MDIOS_SR_TERF_MASK = UINT32_C(0x00000004);           /** @brief Turnaround error flag */
    static const uint32_t MDIOS_CLRFR_CPERF_MASK = UINT32_C(0x00000001);       /** @brief Clear the preamble error flag */
    static const uint32_t MDIOS_CLRFR_CSERF_MASK = UINT32_C(0x00000002);       /** @brief Clear the start error flag */
    static const uint32_t MDIOS_CLRFR_CTERF_MASK = UINT32_C(0x00000004);       /** @brief Clear the turnaround error flag */
    static const uint32_t MDIOS_DINRX_DIN0_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN1_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN2_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN3_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN4_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN5_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN6_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN7_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN8_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN9_MASK = UINT32_C(0x0000FFFF);        /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN10_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN11_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN12_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN13_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN14_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN15_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN16_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN17_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN18_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN19_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN20_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN21_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN22_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN23_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN24_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN25_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN26_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN27_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN28_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN29_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN30_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DINRX_DIN31_MASK = UINT32_C(0x0000FFFF);       /** @brief Input data received from MDIO master during write frames */
    static const uint32_t MDIOS_DOUTRX_DOUT0_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT1_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT2_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT3_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT4_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT5_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT6_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT7_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT8_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT9_MASK = UINT32_C(0x0000FFFF);      /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT10_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT11_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT12_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT13_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT14_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT15_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT16_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT17_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT18_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT19_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT20_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT21_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT22_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT23_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT24_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT25_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT26_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT27_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT28_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT29_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT30_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */
    static const uint32_t MDIOS_DOUTRX_DOUT31_MASK = UINT32_C(0x0000FFFF);     /** @brief Output data sent to MDIO master during read frames */

    /** @subsection MDIOS field position definitions */

    static const int32_t MDIOS_DOUTRX_EN_POS = INT32_C(0);             /** @brief Peripheral enable */
    static const int32_t MDIOS_DOUTRX_WRIE_POS = INT32_C(1);           /** @brief Register write interrupt enable */
    static const int32_t MDIOS_DOUTRX_RDIE_POS = INT32_C(2);           /** @brief Register read interrupt enable */
    static const int32_t MDIOS_DOUTRX_EIE_POS = INT32_C(3);            /** @brief Error interrupt enable */
    static const int32_t MDIOS_DOUTRX_DPC_POS = INT32_C(7);            /** @brief Disable preamble check */
    static const int32_t MDIOS_DOUTRX_PORT_ADDRESS_POS = INT32_C(8);   /** @brief Slaves's address */
    static const int32_t MDIOS_DOUTRX_PERF_POS = INT32_C(0);           /** @brief Preamble error flag */
    static const int32_t MDIOS_DOUTRX_SERF_POS = INT32_C(1);           /** @brief Start error flag */
    static const int32_t MDIOS_DOUTRX_TERF_POS = INT32_C(2);           /** @brief Turnaround error flag */
    static const int32_t MDIOS_DOUTRX_CPERF_POS = INT32_C(0);          /** @brief Clear the preamble error flag */
    static const int32_t MDIOS_DOUTRX_CSERF_POS = INT32_C(1);          /** @brief Clear the start error flag */
    static const int32_t MDIOS_DOUTRX_CTERF_POS = INT32_C(2);          /** @brief Clear the turnaround error flag */
    static const int32_t MDIOS_DOUTRX_DIN0_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN1_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN2_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN3_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN4_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN5_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN6_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN7_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN8_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN9_POS = INT32_C(0);           /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN10_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN11_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN12_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN13_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN14_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN15_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN16_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN17_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN18_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN19_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN20_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN21_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN22_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN23_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN24_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN25_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN26_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN27_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN28_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN29_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN30_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DIN31_POS = INT32_C(0);          /** @brief Input data received from MDIO master during write frames */
    static const int32_t MDIOS_DOUTRX_DOUT0_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT1_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT2_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT3_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT4_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT5_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT6_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT7_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT8_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT9_POS = INT32_C(0);          /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT10_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT11_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT12_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT13_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT14_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT15_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT16_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT17_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT18_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT19_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT20_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT21_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT22_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT23_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT24_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT25_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT26_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT27_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT28_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT29_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT30_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */
    static const int32_t MDIOS_DOUTRX_DOUT31_POS = INT32_C(0);         /** @brief Output data sent to MDIO master during read frames */

    /**********************************************************************************************
     * @section OPAMP Definitions
     **********************************************************************************************/

    /** @subsection OPAMP register definitions */

    static _RW uint32_t* const OPAMP_OPAMP1_CSR_REG = (_RW uint32_t* const)UINT32_C(0x40009000);     /** @brief OPAMP1 control/status register */
    static _RW uint32_t* const OPAMP_OPAMP1_OTR_REG = (_RW uint32_t* const)UINT32_C(0x40009004);     /** @brief OPAMP1 offset trimming register in normal mode */
    static _RW uint32_t* const OPAMP_OPAMP1_HSOTR_REG = (_RW uint32_t* const)UINT32_C(0x40009008);   /** @brief OPAMP1 offset trimming register in low-power mode */
    static _RW uint32_t* const OPAMP_OPAMP2_CSR_REG = (_RW uint32_t* const)UINT32_C(0x40009010);     /** @brief OPAMP2 control/status register */
    static _RW uint32_t* const OPAMP_OPAMP2_OTR_REG = (_RW uint32_t* const)UINT32_C(0x40009014);     /** @brief OPAMP2 offset trimming register in normal mode */
    static _RW uint32_t* const OPAMP_OPAMP2_HSOTR_REG = (_RW uint32_t* const)UINT32_C(0x40009018);   /** @brief OPAMP2 offset trimming register in low-power mode */

    /** @subsection OPAMP field mask definitions */

    static const uint32_t OPAMP_OPAMP1_CSR_OPAEN_MASK = UINT32_C(0x00000001);             /** @brief Operational amplifier enable */
    static const uint32_t OPAMP_OPAMP1_CSR_FORCE_VP_MASK = UINT32_C(0x00000002);          /** @brief Force internal reference on VP (reserved for test */
    static const uint32_t OPAMP_OPAMP1_CSR_VP_SEL_MASK = UINT32_C(0x0000000C);            /** @brief Operational amplifier PGA mode */
    static const uint32_t OPAMP_OPAMP1_CSR_VM_SEL_MASK = UINT32_C(0x00000060);            /** @brief Inverting input selection */
    static const uint32_t OPAMP_OPAMP1_CSR_OPAHSM_MASK = UINT32_C(0x00000100);            /** @brief Operational amplifier high-speed mode */
    static const uint32_t OPAMP_OPAMP1_CSR_CALON_MASK = UINT32_C(0x00000800);             /** @brief Calibration mode enabled */
    static const uint32_t OPAMP_OPAMP1_CSR_CALSEL_MASK = UINT32_C(0x00003000);            /** @brief Calibration selection */
    static const uint32_t OPAMP_OPAMP1_CSR_PGA_GAIN_MASK = UINT32_C(0x0003C000);          /** @brief Allows to switch from AOP offset trimmed values to AOP offset */
    static const uint32_t OPAMP_OPAMP1_CSR_USERTRIM_MASK = UINT32_C(0x00040000);          /** @brief User trimming enable */
    static const uint32_t OPAMP_OPAMP1_CSR_TSTREF_MASK = UINT32_C(0x20000000);            /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const uint32_t OPAMP_OPAMP1_CSR_CALOUT_MASK = UINT32_C(0x40000000);            /** @brief Operational amplifier calibration output */
    static const uint32_t OPAMP_OPAMP1_OTR_TRIMOFFSETN_MASK = UINT32_C(0x0000001F);       /** @brief Trim for NMOS differential pairs */
    static const uint32_t OPAMP_OPAMP1_OTR_TRIMOFFSETP_MASK = UINT32_C(0x00001F00);       /** @brief Trim for PMOS differential pairs */
    static const uint32_t OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN_MASK = UINT32_C(0x0000001F);   /** @brief Trim for NMOS differential pairs */
    static const uint32_t OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP_MASK = UINT32_C(0x00001F00);   /** @brief Trim for PMOS differential pairs */
    static const uint32_t OPAMP_OPAMP2_CSR_OPAEN_MASK = UINT32_C(0x00000001);             /** @brief Operational amplifier enable */
    static const uint32_t OPAMP_OPAMP2_CSR_FORCE_VP_MASK = UINT32_C(0x00000002);          /** @brief Force internal reference on VP (reserved for test) */
    static const uint32_t OPAMP_OPAMP2_CSR_VM_SEL_MASK = UINT32_C(0x00000060);            /** @brief Inverting input selection */
    static const uint32_t OPAMP_OPAMP2_CSR_OPAHSM_MASK = UINT32_C(0x00000100);            /** @brief Operational amplifier high-speed mode */
    static const uint32_t OPAMP_OPAMP2_CSR_CALON_MASK = UINT32_C(0x00000800);             /** @brief Calibration mode enabled */
    static const uint32_t OPAMP_OPAMP2_CSR_CALSEL_MASK = UINT32_C(0x00003000);            /** @brief Calibration selection */
    static const uint32_t OPAMP_OPAMP2_CSR_PGA_GAIN_MASK = UINT32_C(0x0003C000);          /** @brief Operational amplifier programmable amplifier gain value */
    static const uint32_t OPAMP_OPAMP2_CSR_USERTRIM_MASK = UINT32_C(0x00040000);          /** @brief User trimming enable */
    static const uint32_t OPAMP_OPAMP2_CSR_TSTREF_MASK = UINT32_C(0x20000000);            /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const uint32_t OPAMP_OPAMP2_CSR_CALOUT_MASK = UINT32_C(0x40000000);            /** @brief Operational amplifier calibration output */
    static const uint32_t OPAMP_OPAMP2_OTR_TRIMOFFSETN_MASK = UINT32_C(0x0000001F);       /** @brief Trim for NMOS differential pairs */
    static const uint32_t OPAMP_OPAMP2_OTR_TRIMOFFSETP_MASK = UINT32_C(0x00001F00);       /** @brief Trim for PMOS differential pairs */
    static const uint32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN_MASK = UINT32_C(0x0000001F);   /** @brief Trim for NMOS differential pairs */
    static const uint32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP_MASK = UINT32_C(0x00001F00);   /** @brief Trim for PMOS differential pairs */

    /** @subsection OPAMP field position definitions */

    static const int32_t OPAMP_OPAMP2_HSOTR_OPAEN_POS = INT32_C(0);            /** @brief Operational amplifier enable */
    static const int32_t OPAMP_OPAMP2_HSOTR_FORCE_VP_POS = INT32_C(1);         /** @brief Force internal reference on VP (reserved for test */
    static const int32_t OPAMP_OPAMP2_HSOTR_VP_SEL_POS = INT32_C(2);           /** @brief Operational amplifier PGA mode */
    static const int32_t OPAMP_OPAMP2_HSOTR_VM_SEL_POS = INT32_C(5);           /** @brief Inverting input selection */
    static const int32_t OPAMP_OPAMP2_HSOTR_OPAHSM_POS = INT32_C(8);           /** @brief Operational amplifier high-speed mode */
    static const int32_t OPAMP_OPAMP2_HSOTR_CALON_POS = INT32_C(11);           /** @brief Calibration mode enabled */
    static const int32_t OPAMP_OPAMP2_HSOTR_CALSEL_POS = INT32_C(12);          /** @brief Calibration selection */
    static const int32_t OPAMP_OPAMP2_HSOTR_PGA_GAIN_POS = INT32_C(14);        /** @brief Allows to switch from AOP offset trimmed values to AOP offset */
    static const int32_t OPAMP_OPAMP2_HSOTR_USERTRIM_POS = INT32_C(18);        /** @brief User trimming enable */
    static const int32_t OPAMP_OPAMP2_HSOTR_TSTREF_POS = INT32_C(29);          /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const int32_t OPAMP_OPAMP2_HSOTR_CALOUT_POS = INT32_C(30);          /** @brief Operational amplifier calibration output */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMOFFSETN_POS = INT32_C(0);      /** @brief Trim for NMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMOFFSETP_POS = INT32_C(8);      /** @brief Trim for PMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN_POS = INT32_C(0);    /** @brief Trim for NMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP_POS = INT32_C(8);    /** @brief Trim for PMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_HSOTR_OPAEN_POS = INT32_C(0);            /** @brief Operational amplifier enable */
    static const int32_t OPAMP_OPAMP2_HSOTR_FORCE_VP_POS = INT32_C(1);         /** @brief Force internal reference on VP (reserved for test) */
    static const int32_t OPAMP_OPAMP2_HSOTR_VM_SEL_POS = INT32_C(5);           /** @brief Inverting input selection */
    static const int32_t OPAMP_OPAMP2_HSOTR_OPAHSM_POS = INT32_C(8);           /** @brief Operational amplifier high-speed mode */
    static const int32_t OPAMP_OPAMP2_HSOTR_CALON_POS = INT32_C(11);           /** @brief Calibration mode enabled */
    static const int32_t OPAMP_OPAMP2_HSOTR_CALSEL_POS = INT32_C(12);          /** @brief Calibration selection */
    static const int32_t OPAMP_OPAMP2_HSOTR_PGA_GAIN_POS = INT32_C(14);        /** @brief Operational amplifier programmable amplifier gain value */
    static const int32_t OPAMP_OPAMP2_HSOTR_USERTRIM_POS = INT32_C(18);        /** @brief User trimming enable */
    static const int32_t OPAMP_OPAMP2_HSOTR_TSTREF_POS = INT32_C(29);          /** @brief OPAMP calibration reference voltage output control (reserved for test) */
    static const int32_t OPAMP_OPAMP2_HSOTR_CALOUT_POS = INT32_C(30);          /** @brief Operational amplifier calibration output */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMOFFSETN_POS = INT32_C(0);      /** @brief Trim for NMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMOFFSETP_POS = INT32_C(8);      /** @brief Trim for PMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN_POS = INT32_C(0);    /** @brief Trim for NMOS differential pairs */
    static const int32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP_POS = INT32_C(8);    /** @brief Trim for PMOS differential pairs */

    /**********************************************************************************************
     * @section SWPMI Definitions
     **********************************************************************************************/

    /** @subsection SWPMI IRQ interrupt definitions */

    static const int32_t SWPMI1_IRQ = INT32_C(115);   /** @brief SWPMI global interrupt */

    /** @subsection SWPMI register definitions */

    static _RW uint32_t* const SWPMI_CR_REG = (_RW uint32_t* const)UINT32_C(0x40008800);    /** @brief SWPMI configuration/control register */
    static _RW uint32_t* const SWPMI_BRR_REG = (_RW uint32_t* const)UINT32_C(0x40008804);   /** @brief SWPMI bitrate register */
    static _RO uint32_t* const SWPMI_ISR_REG = (_RO uint32_t* const)UINT32_C(0x4000880C);   /** @brief SWPMI interrupt and status register */
    static _RW uint32_t* const SWPMI_ICR_REG = (_RW uint32_t* const)UINT32_C(0x40008810);   /** @brief SWPMI interrupt flag clear register */
    static _RW uint32_t* const SWPMI_IER_REG = (_RW uint32_t* const)UINT32_C(0x40008814);   /** @brief SWPMI interrupt enable register */
    static _RO uint32_t* const SWPMI_RFL_REG = (_RO uint32_t* const)UINT32_C(0x40008818);   /** @brief SWPMI receive frame length register */
    static _RW uint32_t* const SWPMI_TDR_REG = (_RW uint32_t* const)UINT32_C(0x4000881C);   /** @brief SWPMI transmit data register */
    static _RO uint32_t* const SWPMI_RDR_REG = (_RO uint32_t* const)UINT32_C(0x40008820);   /** @brief SWPMI receive data register */
    static _RW uint32_t* const SWPMI_OR_REG = (_RW uint32_t* const)UINT32_C(0x40008824);    /** @brief SWPMI option register */

    /** @subsection SWPMI field mask definitions */

    static const uint32_t SWPMI_CR_RXDMA_MASK = UINT32_C(0x00000001);       /** @brief Reception DMA enable */
    static const uint32_t SWPMI_CR_TXDMA_MASK = UINT32_C(0x00000002);       /** @brief Transmission DMA enable */
    static const uint32_t SWPMI_CR_RXMODE_MASK = UINT32_C(0x00000004);      /** @brief Reception buffering mode */
    static const uint32_t SWPMI_CR_TXMODE_MASK = UINT32_C(0x00000008);      /** @brief Transmission buffering mode */
    static const uint32_t SWPMI_CR_LPBK_MASK = UINT32_C(0x00000010);        /** @brief Loopback mode enable */
    static const uint32_t SWPMI_CR_SWPACT_MASK = UINT32_C(0x00000020);      /** @brief Single wire protocol master interface activate */
    static const uint32_t SWPMI_CR_DEACT_MASK = UINT32_C(0x00000400);       /** @brief Single wire protocol master interface deactivate */
    static const uint32_t SWPMI_CR_SWPTEN_MASK = UINT32_C(0x00000800);      /** @brief Single wire protocol master transceiver enable */
    static const uint32_t SWPMI_BRR_BR_MASK = UINT32_C(0x000000FF);         /** @brief Bitrate prescaler */
    static const uint32_t SWPMI_ISR_RXBFF_MASK = UINT32_C(0x00000001);      /** @brief Receive buffer full flag */
    static const uint32_t SWPMI_ISR_TXBEF_MASK = UINT32_C(0x00000002);      /** @brief Transmit buffer empty flag */
    static const uint32_t SWPMI_ISR_RXBERF_MASK = UINT32_C(0x00000004);     /** @brief Receive CRC error flag */
    static const uint32_t SWPMI_ISR_RXOVRF_MASK = UINT32_C(0x00000008);     /** @brief Receive overrun error flag */
    static const uint32_t SWPMI_ISR_TXUNRF_MASK = UINT32_C(0x00000010);     /** @brief Transmit underrun error flag */
    static const uint32_t SWPMI_ISR_RXNE_MASK = UINT32_C(0x00000020);       /** @brief Receive data register not empty */
    static const uint32_t SWPMI_ISR_TXE_MASK = UINT32_C(0x00000040);        /** @brief Transmit data register empty */
    static const uint32_t SWPMI_ISR_TCF_MASK = UINT32_C(0x00000080);        /** @brief Transfer complete flag */
    static const uint32_t SWPMI_ISR_SRF_MASK = UINT32_C(0x00000100);        /** @brief Slave resume flag */
    static const uint32_t SWPMI_ISR_SUSP_MASK = UINT32_C(0x00000200);       /** @brief SUSPEND flag */
    static const uint32_t SWPMI_ISR_DEACTF_MASK = UINT32_C(0x00000400);     /** @brief DEACTIVATED flag */
    static const uint32_t SWPMI_ISR_RDYF_MASK = UINT32_C(0x00000800);       /** @brief Transceiver ready flag */
    static const uint32_t SWPMI_ICR_CRXBFF_MASK = UINT32_C(0x00000001);     /** @brief Clear receive buffer full flag */
    static const uint32_t SWPMI_ICR_CTXBEF_MASK = UINT32_C(0x00000002);     /** @brief Clear transmit buffer empty flag */
    static const uint32_t SWPMI_ICR_CRXBERF_MASK = UINT32_C(0x00000004);    /** @brief Clear receive CRC error flag */
    static const uint32_t SWPMI_ICR_CRXOVRF_MASK = UINT32_C(0x00000008);    /** @brief Clear receive overrun error flag */
    static const uint32_t SWPMI_ICR_CTXUNRF_MASK = UINT32_C(0x00000010);    /** @brief Clear transmit underrun error flag */
    static const uint32_t SWPMI_ICR_CTCF_MASK = UINT32_C(0x00000080);       /** @brief Clear transfer complete flag */
    static const uint32_t SWPMI_ICR_CSRF_MASK = UINT32_C(0x00000100);       /** @brief Clear slave resume flag */
    static const uint32_t SWPMI_ICR_CRDYF_MASK = UINT32_C(0x00000800);      /** @brief Clear transceiver ready flag */
    static const uint32_t SWPMI_IER_RXBFIE_MASK = UINT32_C(0x00000001);     /** @brief Receive buffer full interrupt enable */
    static const uint32_t SWPMI_IER_TXBEIE_MASK = UINT32_C(0x00000002);     /** @brief Transmit buffer empty interrupt enable */
    static const uint32_t SWPMI_IER_RXBERIE_MASK = UINT32_C(0x00000004);    /** @brief Receive CRC error interrupt enable */
    static const uint32_t SWPMI_IER_RXOVRIE_MASK = UINT32_C(0x00000008);    /** @brief Receive overrun error interrupt enable */
    static const uint32_t SWPMI_IER_TXUNRIE_MASK = UINT32_C(0x00000010);    /** @brief Transmit underrun error interrupt enable */
    static const uint32_t SWPMI_IER_RIE_MASK = UINT32_C(0x00000020);        /** @brief Receive interrupt enable */
    static const uint32_t SWPMI_IER_TIE_MASK = UINT32_C(0x00000040);        /** @brief Transmit interrupt enable */
    static const uint32_t SWPMI_IER_TCIE_MASK = UINT32_C(0x00000080);       /** @brief Transmit complete interrupt enable */
    static const uint32_t SWPMI_IER_SRIE_MASK = UINT32_C(0x00000100);       /** @brief Slave resume interrupt enable */
    static const uint32_t SWPMI_IER_RDYIE_MASK = UINT32_C(0x00000800);      /** @brief Transceiver ready interrupt enable */
    static const uint32_t SWPMI_RFL_RFL_MASK = UINT32_C(0x0000001F);        /** @brief Receive frame length */
    static const uint32_t SWPMI_OR_SWP_TBYP_MASK = UINT32_C(0x00000001);    /** @brief SWP transceiver bypass */
    static const uint32_t SWPMI_OR_SWP_CLASS_MASK = UINT32_C(0x00000002);   /** @brief SWP class selection */

    /** @subsection SWPMI field position definitions */

    static const int32_t SWPMI_OR_RXDMA_POS = INT32_C(0);        /** @brief Reception DMA enable */
    static const int32_t SWPMI_OR_TXDMA_POS = INT32_C(1);        /** @brief Transmission DMA enable */
    static const int32_t SWPMI_OR_RXMODE_POS = INT32_C(2);       /** @brief Reception buffering mode */
    static const int32_t SWPMI_OR_TXMODE_POS = INT32_C(3);       /** @brief Transmission buffering mode */
    static const int32_t SWPMI_OR_LPBK_POS = INT32_C(4);         /** @brief Loopback mode enable */
    static const int32_t SWPMI_OR_SWPACT_POS = INT32_C(5);       /** @brief Single wire protocol master interface activate */
    static const int32_t SWPMI_OR_DEACT_POS = INT32_C(10);       /** @brief Single wire protocol master interface deactivate */
    static const int32_t SWPMI_OR_SWPTEN_POS = INT32_C(11);      /** @brief Single wire protocol master transceiver enable */
    static const int32_t SWPMI_OR_BR_POS = INT32_C(0);           /** @brief Bitrate prescaler */
    static const int32_t SWPMI_OR_RXBFF_POS = INT32_C(0);        /** @brief Receive buffer full flag */
    static const int32_t SWPMI_OR_TXBEF_POS = INT32_C(1);        /** @brief Transmit buffer empty flag */
    static const int32_t SWPMI_OR_RXBERF_POS = INT32_C(2);       /** @brief Receive CRC error flag */
    static const int32_t SWPMI_OR_RXOVRF_POS = INT32_C(3);       /** @brief Receive overrun error flag */
    static const int32_t SWPMI_OR_TXUNRF_POS = INT32_C(4);       /** @brief Transmit underrun error flag */
    static const int32_t SWPMI_OR_RXNE_POS = INT32_C(5);         /** @brief Receive data register not empty */
    static const int32_t SWPMI_OR_TXE_POS = INT32_C(6);          /** @brief Transmit data register empty */
    static const int32_t SWPMI_OR_TCF_POS = INT32_C(7);          /** @brief Transfer complete flag */
    static const int32_t SWPMI_OR_SRF_POS = INT32_C(8);          /** @brief Slave resume flag */
    static const int32_t SWPMI_OR_SUSP_POS = INT32_C(9);         /** @brief SUSPEND flag */
    static const int32_t SWPMI_OR_DEACTF_POS = INT32_C(10);      /** @brief DEACTIVATED flag */
    static const int32_t SWPMI_OR_RDYF_POS = INT32_C(11);        /** @brief Transceiver ready flag */
    static const int32_t SWPMI_OR_CRXBFF_POS = INT32_C(0);       /** @brief Clear receive buffer full flag */
    static const int32_t SWPMI_OR_CTXBEF_POS = INT32_C(1);       /** @brief Clear transmit buffer empty flag */
    static const int32_t SWPMI_OR_CRXBERF_POS = INT32_C(2);      /** @brief Clear receive CRC error flag */
    static const int32_t SWPMI_OR_CRXOVRF_POS = INT32_C(3);      /** @brief Clear receive overrun error flag */
    static const int32_t SWPMI_OR_CTXUNRF_POS = INT32_C(4);      /** @brief Clear transmit underrun error flag */
    static const int32_t SWPMI_OR_CTCF_POS = INT32_C(7);         /** @brief Clear transfer complete flag */
    static const int32_t SWPMI_OR_CSRF_POS = INT32_C(8);         /** @brief Clear slave resume flag */
    static const int32_t SWPMI_OR_CRDYF_POS = INT32_C(11);       /** @brief Clear transceiver ready flag */
    static const int32_t SWPMI_OR_RXBFIE_POS = INT32_C(0);       /** @brief Receive buffer full interrupt enable */
    static const int32_t SWPMI_OR_TXBEIE_POS = INT32_C(1);       /** @brief Transmit buffer empty interrupt enable */
    static const int32_t SWPMI_OR_RXBERIE_POS = INT32_C(2);      /** @brief Receive CRC error interrupt enable */
    static const int32_t SWPMI_OR_RXOVRIE_POS = INT32_C(3);      /** @brief Receive overrun error interrupt enable */
    static const int32_t SWPMI_OR_TXUNRIE_POS = INT32_C(4);      /** @brief Transmit underrun error interrupt enable */
    static const int32_t SWPMI_OR_RIE_POS = INT32_C(5);          /** @brief Receive interrupt enable */
    static const int32_t SWPMI_OR_TIE_POS = INT32_C(6);          /** @brief Transmit interrupt enable */
    static const int32_t SWPMI_OR_TCIE_POS = INT32_C(7);         /** @brief Transmit complete interrupt enable */
    static const int32_t SWPMI_OR_SRIE_POS = INT32_C(8);         /** @brief Slave resume interrupt enable */
    static const int32_t SWPMI_OR_RDYIE_POS = INT32_C(11);       /** @brief Transceiver ready interrupt enable */
    static const int32_t SWPMI_OR_RFL_POS = INT32_C(0);          /** @brief Receive frame length */
    static const int32_t SWPMI_OR_SWP_TBYP_POS = INT32_C(0);     /** @brief SWP transceiver bypass */
    static const int32_t SWPMI_OR_SWP_CLASS_POS = INT32_C(1);    /** @brief SWP class selection */

    /**********************************************************************************************
     * @section NVIC Definitions
     **********************************************************************************************/

    /** @subsection NVIC register array definitions */

    static _RW uint32_t* const NVIC_ISERX_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0xE000E100),   /** @brief Interrupt set-enable register */
      (_RW uint32_t* const)UINT32_C(0xE000E104),   /** @brief Interrupt set-enable register */
      (_RW uint32_t* const)UINT32_C(0xE000E108),   /** @brief Interrupt set-enable register */
      (_RW uint32_t* const)UINT32_C(0xE000E10C),   /** @brief Interrupt set-enable register */
    };

    static _RW uint32_t* const NVIC_ICERX_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0xE000E180),   /** @brief Interrupt clear-enable register */
      (_RW uint32_t* const)UINT32_C(0xE000E184),   /** @brief Interrupt clear-enable register */
      (_RW uint32_t* const)UINT32_C(0xE000E188),   /** @brief Interrupt clear-enable register */
      (_RW uint32_t* const)UINT32_C(0xE000E18C),   /** @brief Interrupt clear-enable register */
    };

    static _RW uint32_t* const NVIC_ISPRX_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0xE000E200),   /** @brief Interrupt set-pending register */
      (_RW uint32_t* const)UINT32_C(0xE000E204),   /** @brief Interrupt set-pending register */
      (_RW uint32_t* const)UINT32_C(0xE000E208),   /** @brief Interrupt set-pending register */
      (_RW uint32_t* const)UINT32_C(0xE000E20C),   /** @brief Interrupt set-pending register */
    };

    static _RW uint32_t* const NVIC_ICPRX_REG[4] = {
      (_RW uint32_t* const)UINT32_C(0xE000E280),   /** @brief Interrupt clear-pending register */
      (_RW uint32_t* const)UINT32_C(0xE000E284),   /** @brief Interrupt clear-pending register */
      (_RW uint32_t* const)UINT32_C(0xE000E288),   /** @brief Interrupt clear-pending register */
      (_RW uint32_t* const)UINT32_C(0xE000E2C0),   /** @brief Interrupt clear-pending register */
    };

    static _RO uint32_t* const NVIC_IABRX_REG[4] = {
      (_RO uint32_t* const)UINT32_C(0xE000E300),   /** @brief Interrupt active bit register */
      (_RO uint32_t* const)UINT32_C(0xE000E304),   /** @brief Interrupt active bit register */
      (_RO uint32_t* const)UINT32_C(0xE000E308),   /** @brief Interrupt active bit register */
      (_RO uint32_t* const)UINT32_C(0xE000E30C),   /** @brief Interrupt active bit register */
    };

    static _RW uint32_t* const NVIC_IPRX_REG[39] = {
      (_RW uint32_t* const)UINT32_C(0xE000E400),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E404),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E408),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E40C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E410),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E414),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E418),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E41C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E420),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E424),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E428),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E42C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E430),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E434),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E438),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E43C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E440),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E444),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E448),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E44C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E450),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E454),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E458),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E45C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E460),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E464),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E468),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E46C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E470),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E474),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E478),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E47C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E480),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E484),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E488),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E48C),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E490),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E494),   /** @brief Interrupt priority register */
      (_RW uint32_t* const)UINT32_C(0xE000E498),   /** @brief Interrupt priority register */
    };

    /** @subsection NVIC field mask array definitions */

    static const uint32_t NVIC_IPRX_IPR_NX_MASK[4] = {
      UINT32_C(0x000000FF),   /** @brief IPR_N0 */
      UINT32_C(0x0000FF00),   /** @brief IPR_N1 */
      UINT32_C(0x00FF0000),   /** @brief IPR_N2 */
      UINT32_C(0xFF000000),   /** @brief IPR_N3 */
    };

    /** @subsection NVIC field position array definitions */

    static const int32_t NVIC_IPRX_IPR_NX_POS[4] = {
      INT32_C(0),    /** @brief IPR_N0 */
      INT32_C(8),    /** @brief IPR_N1 */
      INT32_C(16),   /** @brief IPR_N2 */
      INT32_C(24),   /** @brief IPR_N3 */
    };

    /**********************************************************************************************
     * @section MPU Definitions
     **********************************************************************************************/

    /** @subsection MPU register definitions */

    static _RO uint32_t* const MPU_TYPER_REG = (_RO uint32_t* const)UINT32_C(0xE000ED90);   /** @brief MPU type register */
    static _RO uint32_t* const MPU_CTRL_REG = (_RO uint32_t* const)UINT32_C(0xE000ED94);    /** @brief MPU control register */
    static _RW uint32_t* const MPU_RNR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED98);     /** @brief MPU region number register */
    static _RW uint32_t* const MPU_RBAR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED9C);    /** @brief MPU region base address register */
    static _RW uint32_t* const MPU_RASR_REG = (_RW uint32_t* const)UINT32_C(0xE000EDA0);    /** @brief MPU region attribute and size register */

    /** @subsection MPU field mask definitions */

    static const uint32_t MPU_TYPER_SEPARATE_MASK = UINT32_C(0x00000001);    /** @brief Separate flag */
    static const uint32_t MPU_TYPER_DREGION_MASK = UINT32_C(0x0000FF00);     /** @brief Number of MPU data regions */
    static const uint32_t MPU_TYPER_IREGION_MASK = UINT32_C(0x00FF0000);     /** @brief Number of MPU instruction regions */
    static const uint32_t MPU_CTRL_ENABLE_MASK = UINT32_C(0x00000001);       /** @brief Enables the MPU */
    static const uint32_t MPU_CTRL_HFNMIENA_MASK = UINT32_C(0x00000002);     /** @brief Enables the operation of MPU during hard fault */
    static const uint32_t MPU_CTRL_PRIVDEFENA_MASK = UINT32_C(0x00000004);   /** @brief Enable priviliged software access to default memory map */
    static const uint32_t MPU_RNR_REGION_MASK = UINT32_C(0x000000FF);        /** @brief MPU region */
    static const uint32_t MPU_RBAR_REGION_MASK = UINT32_C(0x0000000F);       /** @brief MPU region field */
    static const uint32_t MPU_RBAR_VALID_MASK = UINT32_C(0x00000010);        /** @brief MPU region number valid */
    static const uint32_t MPU_RBAR_ADDR_MASK = UINT32_C(0xFFFFFFE0);         /** @brief Region base address field */
    static const uint32_t MPU_RASR_ENABLE_MASK = UINT32_C(0x00000001);       /** @brief Region enable bit. */
    static const uint32_t MPU_RASR_SIZE_MASK = UINT32_C(0x0000003E);         /** @brief Size of the MPU protection region */
    static const uint32_t MPU_RASR_SRD_MASK = UINT32_C(0x0000FF00);          /** @brief Subregion disable bits */
    static const uint32_t MPU_RASR_B_MASK = UINT32_C(0x00010000);            /** @brief Memory attribute */
    static const uint32_t MPU_RASR_C_MASK = UINT32_C(0x00020000);            /** @brief Memory attribute */
    static const uint32_t MPU_RASR_S_MASK = UINT32_C(0x00040000);            /** @brief Shareable memory attribute */
    static const uint32_t MPU_RASR_TEX_MASK = UINT32_C(0x00380000);          /** @brief Memory attribute */
    static const uint32_t MPU_RASR_AP_MASK = UINT32_C(0x07000000);           /** @brief Access permission */
    static const uint32_t MPU_RASR_XN_MASK = UINT32_C(0x10000000);           /** @brief Instruction access disable bit */

    /** @subsection MPU field position definitions */

    static const int32_t MPU_RASR_SEPARATE_POS = INT32_C(0);      /** @brief Separate flag */
    static const int32_t MPU_RASR_DREGION_POS = INT32_C(8);       /** @brief Number of MPU data regions */
    static const int32_t MPU_RASR_IREGION_POS = INT32_C(16);      /** @brief Number of MPU instruction regions */
    static const int32_t MPU_RASR_ENABLE_POS = INT32_C(0);        /** @brief Enables the MPU */
    static const int32_t MPU_RASR_HFNMIENA_POS = INT32_C(1);      /** @brief Enables the operation of MPU during hard fault */
    static const int32_t MPU_RASR_PRIVDEFENA_POS = INT32_C(2);    /** @brief Enable priviliged software access to default memory map */
    static const int32_t MPU_RASR_REGION_POS = INT32_C(0);        /** @brief MPU region */
    static const int32_t MPU_RASR_REGION_POS = INT32_C(0);        /** @brief MPU region field */
    static const int32_t MPU_RASR_VALID_POS = INT32_C(4);         /** @brief MPU region number valid */
    static const int32_t MPU_RASR_ADDR_POS = INT32_C(5);          /** @brief Region base address field */
    static const int32_t MPU_RASR_ENABLE_POS = INT32_C(0);        /** @brief Region enable bit. */
    static const int32_t MPU_RASR_SIZE_POS = INT32_C(1);          /** @brief Size of the MPU protection region */
    static const int32_t MPU_RASR_SRD_POS = INT32_C(8);           /** @brief Subregion disable bits */
    static const int32_t MPU_RASR_B_POS = INT32_C(16);            /** @brief Memory attribute */
    static const int32_t MPU_RASR_C_POS = INT32_C(17);            /** @brief Memory attribute */
    static const int32_t MPU_RASR_S_POS = INT32_C(18);            /** @brief Shareable memory attribute */
    static const int32_t MPU_RASR_TEX_POS = INT32_C(19);          /** @brief Memory attribute */
    static const int32_t MPU_RASR_AP_POS = INT32_C(24);           /** @brief Access permission */
    static const int32_t MPU_RASR_XN_POS = INT32_C(28);           /** @brief Instruction access disable bit */

    /**********************************************************************************************
     * @section STK Definitions
     **********************************************************************************************/

    /** @subsection STK register definitions */

    static _RW uint32_t* const STK_CSR_REG = (_RW uint32_t* const)UINT32_C(0xE000E010);     /** @brief SysTick control and status register */
    static _RW uint32_t* const STK_RVR_REG = (_RW uint32_t* const)UINT32_C(0xE000E014);     /** @brief SysTick reload value register */
    static _RW uint32_t* const STK_CVR_REG = (_RW uint32_t* const)UINT32_C(0xE000E018);     /** @brief SysTick current value register */
    static _RW uint32_t* const STK_CALIB_REG = (_RW uint32_t* const)UINT32_C(0xE000E01C);   /** @brief SysTick calibration value register */

    /** @subsection STK field mask definitions */

    static const uint32_t STK_CSR_ENABLE_MASK = UINT32_C(0x00000001);      /** @brief Counter enable */
    static const uint32_t STK_CSR_TICKINT_MASK = UINT32_C(0x00000002);     /** @brief SysTick exception request enable */
    static const uint32_t STK_CSR_CLKSOURCE_MASK = UINT32_C(0x00000004);   /** @brief Clock source selection */
    static const uint32_t STK_CSR_COUNTFLAG_MASK = UINT32_C(0x00010000);   /** @brief COUNTFLAG */
    static const uint32_t STK_RVR_RELOAD_MASK = UINT32_C(0x00FFFFFF);      /** @brief RELOAD value */
    static const uint32_t STK_CVR_CURRENT_MASK = UINT32_C(0x00FFFFFF);     /** @brief Current counter value */
    static const uint32_t STK_CALIB_TENMS_MASK = UINT32_C(0x00FFFFFF);     /** @brief Calibration value */
    static const uint32_t STK_CALIB_SKEW_MASK = UINT32_C(0x40000000);      /** @brief SKEW flag: indicates whether the TENMS value is exact */
    static const uint32_t STK_CALIB_NOREF_MASK = UINT32_C(0x80000000);     /** @brief NOREF flag. Reads as zero */

    /** @subsection STK field position definitions */

    static const int32_t STK_CALIB_ENABLE_POS = INT32_C(0);       /** @brief Counter enable */
    static const int32_t STK_CALIB_TICKINT_POS = INT32_C(1);      /** @brief SysTick exception request enable */
    static const int32_t STK_CALIB_CLKSOURCE_POS = INT32_C(2);    /** @brief Clock source selection */
    static const int32_t STK_CALIB_COUNTFLAG_POS = INT32_C(16);   /** @brief COUNTFLAG */
    static const int32_t STK_CALIB_RELOAD_POS = INT32_C(0);       /** @brief RELOAD value */
    static const int32_t STK_CALIB_CURRENT_POS = INT32_C(0);      /** @brief Current counter value */
    static const int32_t STK_CALIB_TENMS_POS = INT32_C(0);        /** @brief Calibration value */
    static const int32_t STK_CALIB_SKEW_POS = INT32_C(30);        /** @brief SKEW flag: indicates whether the TENMS value is exact */
    static const int32_t STK_CALIB_NOREF_POS = INT32_C(31);       /** @brief NOREF flag. Reads as zero */

    /**********************************************************************************************
     * @section NVIC_STIR Definitions
     **********************************************************************************************/

    /** @subsection NVIC_STIR register definitions */

    static _RW uint32_t* const NVIC_STIR_STIR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF00);   /** @brief Software trigger interrupt register */

    /** @subsection NVIC_STIR field mask definitions */

    static const uint32_t NVIC_STIR_STIR_INTID_MASK = UINT32_C(0x000001FF);   /** @brief Software generated interrupt ID */

    /** @subsection NVIC_STIR field position definitions */

    static const int32_t NVIC_STIR_STIR_INTID_POS = INT32_C(0);   /** @brief Software generated interrupt ID */

    /**********************************************************************************************
     * @section FPU_CPACR Definitions
     **********************************************************************************************/

    /** @subsection FPU_CPACR register definitions */

    static _RW uint32_t* const FPU_CPACR_CPACR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED88);   /** @brief Coprocessor access control register */

    /** @subsection FPU_CPACR field mask definitions */

    static const uint32_t FPU_CPACR_CPACR_CP_MASK = UINT32_C(0x00F00000);   /** @brief CP */

    /** @subsection FPU_CPACR field position definitions */

    static const int32_t FPU_CPACR_CPACR_CP_POS = INT32_C(20);   /** @brief CP */

    /**********************************************************************************************
     * @section SCB_ACTRL Definitions
     **********************************************************************************************/

    /** @subsection SCB_ACTRL register definitions */

    static _RW uint32_t* const SCB_ACTRL_ACTRL_REG = (_RW uint32_t* const)UINT32_C(0xE000E008);   /** @brief Auxiliary control register */

    /** @subsection SCB_ACTRL field mask definitions */

    static const uint32_t SCB_ACTRL_ACTRL_DISFOLD_MASK = UINT32_C(0x00000004);          /** @brief DISFOLD */
    static const uint32_t SCB_ACTRL_ACTRL_FPEXCODIS_MASK = UINT32_C(0x00000400);        /** @brief FPEXCODIS */
    static const uint32_t SCB_ACTRL_ACTRL_DISRAMODE_MASK = UINT32_C(0x00000800);        /** @brief DISRAMODE */
    static const uint32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH_MASK = UINT32_C(0x00001000);   /** @brief DISITMATBFLUSH */

    /** @subsection SCB_ACTRL field position definitions */

    static const int32_t SCB_ACTRL_ACTRL_DISFOLD_POS = INT32_C(2);           /** @brief DISFOLD */
    static const int32_t SCB_ACTRL_ACTRL_FPEXCODIS_POS = INT32_C(10);        /** @brief FPEXCODIS */
    static const int32_t SCB_ACTRL_ACTRL_DISRAMODE_POS = INT32_C(11);        /** @brief DISRAMODE */
    static const int32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH_POS = INT32_C(12);   /** @brief DISITMATBFLUSH */

    /**********************************************************************************************
     * @section FPU Definitions
     **********************************************************************************************/

    /** @subsection FPU IRQ interrupt definitions */

    static const int32_t FPU_IRQ = INT32_C(81);   /** @brief Floating point unit interrupt */

    /** @subsection FPU register definitions */

    static _RW uint32_t* const FPU_FPCCR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF34);   /** @brief Floating-point context control register */
    static _RW uint32_t* const FPU_FPCAR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF38);   /** @brief Floating-point context address register */
    static _RW uint32_t* const FPU_FPSCR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF3C);   /** @brief Floating-point status control register */

    /** @subsection FPU field mask definitions */

    static const uint32_t FPU_FPCCR_LSPACT_MASK = UINT32_C(0x00000001);    /** @brief LSPACT */
    static const uint32_t FPU_FPCCR_USER_MASK = UINT32_C(0x00000002);      /** @brief USER */
    static const uint32_t FPU_FPCCR_THREAD_MASK = UINT32_C(0x00000008);    /** @brief THREAD */
    static const uint32_t FPU_FPCCR_HFRDY_MASK = UINT32_C(0x00000010);     /** @brief HFRDY */
    static const uint32_t FPU_FPCCR_MMRDY_MASK = UINT32_C(0x00000020);     /** @brief MMRDY */
    static const uint32_t FPU_FPCCR_BFRDY_MASK = UINT32_C(0x00000040);     /** @brief BFRDY */
    static const uint32_t FPU_FPCCR_MONRDY_MASK = UINT32_C(0x00000100);    /** @brief MONRDY */
    static const uint32_t FPU_FPCCR_LSPEN_MASK = UINT32_C(0x40000000);     /** @brief LSPEN */
    static const uint32_t FPU_FPCCR_ASPEN_MASK = UINT32_C(0x80000000);     /** @brief ASPEN */
    static const uint32_t FPU_FPCAR_ADDRESS_MASK = UINT32_C(0xFFFFFFF8);   /** @brief Location of unpopulated floating-point */
    static const uint32_t FPU_FPSCR_IOC_MASK = UINT32_C(0x00000001);       /** @brief Invalid operation cumulative exception bit */
    static const uint32_t FPU_FPSCR_DZC_MASK = UINT32_C(0x00000002);       /** @brief Division by zero cumulative exception bit. */
    static const uint32_t FPU_FPSCR_OFC_MASK = UINT32_C(0x00000004);       /** @brief Overflow cumulative exception bit */
    static const uint32_t FPU_FPSCR_UFC_MASK = UINT32_C(0x00000008);       /** @brief Underflow cumulative exception bit */
    static const uint32_t FPU_FPSCR_IXC_MASK = UINT32_C(0x00000010);       /** @brief Inexact cumulative exception bit */
    static const uint32_t FPU_FPSCR_IDC_MASK = UINT32_C(0x00000080);       /** @brief Input denormal cumulative exception bit. */
    static const uint32_t FPU_FPSCR_RMODE_MASK = UINT32_C(0x00C00000);     /** @brief Rounding mode control field */
    static const uint32_t FPU_FPSCR_FZ_MASK = UINT32_C(0x01000000);        /** @brief Flush-to-zero mode control bit: */
    static const uint32_t FPU_FPSCR_DN_MASK = UINT32_C(0x02000000);        /** @brief Default nan mode control bit */
    static const uint32_t FPU_FPSCR_AHP_MASK = UINT32_C(0x04000000);       /** @brief Alternative half-precision control bit */
    static const uint32_t FPU_FPSCR_V_MASK = UINT32_C(0x10000000);         /** @brief Overflow condition code flag */
    static const uint32_t FPU_FPSCR_C_MASK = UINT32_C(0x20000000);         /** @brief Carry condition code flag */
    static const uint32_t FPU_FPSCR_Z_MASK = UINT32_C(0x40000000);         /** @brief Zero condition code flag */
    static const uint32_t FPU_FPSCR_N_MASK = UINT32_C(0x80000000);         /** @brief Negative condition code flag */

    /** @subsection FPU field position definitions */

    static const int32_t FPU_FPSCR_LSPACT_POS = INT32_C(0);     /** @brief LSPACT */
    static const int32_t FPU_FPSCR_USER_POS = INT32_C(1);       /** @brief USER */
    static const int32_t FPU_FPSCR_THREAD_POS = INT32_C(3);     /** @brief THREAD */
    static const int32_t FPU_FPSCR_HFRDY_POS = INT32_C(4);      /** @brief HFRDY */
    static const int32_t FPU_FPSCR_MMRDY_POS = INT32_C(5);      /** @brief MMRDY */
    static const int32_t FPU_FPSCR_BFRDY_POS = INT32_C(6);      /** @brief BFRDY */
    static const int32_t FPU_FPSCR_MONRDY_POS = INT32_C(8);     /** @brief MONRDY */
    static const int32_t FPU_FPSCR_LSPEN_POS = INT32_C(30);     /** @brief LSPEN */
    static const int32_t FPU_FPSCR_ASPEN_POS = INT32_C(31);     /** @brief ASPEN */
    static const int32_t FPU_FPSCR_ADDRESS_POS = INT32_C(3);    /** @brief Location of unpopulated floating-point */
    static const int32_t FPU_FPSCR_IOC_POS = INT32_C(0);        /** @brief Invalid operation cumulative exception bit */
    static const int32_t FPU_FPSCR_DZC_POS = INT32_C(1);        /** @brief Division by zero cumulative exception bit. */
    static const int32_t FPU_FPSCR_OFC_POS = INT32_C(2);        /** @brief Overflow cumulative exception bit */
    static const int32_t FPU_FPSCR_UFC_POS = INT32_C(3);        /** @brief Underflow cumulative exception bit */
    static const int32_t FPU_FPSCR_IXC_POS = INT32_C(4);        /** @brief Inexact cumulative exception bit */
    static const int32_t FPU_FPSCR_IDC_POS = INT32_C(7);        /** @brief Input denormal cumulative exception bit. */
    static const int32_t FPU_FPSCR_RMODE_POS = INT32_C(22);     /** @brief Rounding mode control field */
    static const int32_t FPU_FPSCR_FZ_POS = INT32_C(24);        /** @brief Flush-to-zero mode control bit: */
    static const int32_t FPU_FPSCR_DN_POS = INT32_C(25);        /** @brief Default nan mode control bit */
    static const int32_t FPU_FPSCR_AHP_POS = INT32_C(26);       /** @brief Alternative half-precision control bit */
    static const int32_t FPU_FPSCR_V_POS = INT32_C(28);         /** @brief Overflow condition code flag */
    static const int32_t FPU_FPSCR_C_POS = INT32_C(29);         /** @brief Carry condition code flag */
    static const int32_t FPU_FPSCR_Z_POS = INT32_C(30);         /** @brief Zero condition code flag */
    static const int32_t FPU_FPSCR_N_POS = INT32_C(31);         /** @brief Negative condition code flag */

    /**********************************************************************************************
     * @section SCB Definitions
     **********************************************************************************************/

    /** @subsection SCB register definitions */

    static _RO uint32_t* const SCB_CPUID_REG = (_RO uint32_t* const)UINT32_C(0xE000ED00);                  /** @brief CPUID base register */
    static _RW uint32_t* const SCB_ICSR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED04);                   /** @brief Interrupt control and state register */
    static _RW uint32_t* const SCB_VTOR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED08);                   /** @brief Vector table offset register */
    static _RW uint32_t* const SCB_AIRCR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED0C);                  /** @brief Application interrupt and reset control register */
    static _RW uint32_t* const SCB_SCR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED10);                    /** @brief System control register */
    static _RW uint32_t* const SCB_CCR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED14);                    /** @brief Configuration and control register */
    static _RW uint32_t* const SCB_SHPR1_REG = (_RW uint32_t* const)UINT32_C(0xE000ED18);                  /** @brief System handler priority registers */
    static _RW uint32_t* const SCB_SHPR2_REG = (_RW uint32_t* const)UINT32_C(0xE000ED1C);                  /** @brief System handler priority registers */
    static _RW uint32_t* const SCB_SHPR3_REG = (_RW uint32_t* const)UINT32_C(0xE000ED20);                  /** @brief System handler priority registers */
    static _RW uint32_t* const SCB_SHCRS_REG = (_RW uint32_t* const)UINT32_C(0xE000ED24);                  /** @brief System handler control and state register */
    static _RW uint32_t* const SCB_CFSR_UFSR_BFSR_MMFSR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED28);   /** @brief Configurable fault status register */
    static _RW uint32_t* const SCB_HFSR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED2C);                   /** @brief Hard fault status register */
    static _RW uint32_t* const SCB_MMFAR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED34);                  /** @brief Memory management fault address register */
    static _RW uint32_t* const SCB_BFAR_REG = (_RW uint32_t* const)UINT32_C(0xE000ED38);                   /** @brief Bus fault address register */

    /** @subsection SCB field mask array definitions */

    static const uint32_t SCB_SHPR1_PRI_X_MASK[7] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x000000FF),   /** @brief Priority of system handler 4 */
      UINT32_C(0x0000FF00),   /** @brief Priority of system handler 5 */
      UINT32_C(0x00FF0000),   /** @brief Priority of system handler 6 */
    };

    /** @subsection SCB field mask definitions */

    static const uint32_t SCB_CPUID_REVISION_MASK = UINT32_C(0x0000000F);                     /** @brief Revision number */
    static const uint32_t SCB_CPUID_PARTNO_MASK = UINT32_C(0x0000FFF0);                       /** @brief Part number of the processor */
    static const uint32_t SCB_CPUID_CONSTANT_MASK = UINT32_C(0x000F0000);                     /** @brief Reads as 0xf */
    static const uint32_t SCB_CPUID_VARIANT_MASK = UINT32_C(0x00F00000);                      /** @brief Variant number */
    static const uint32_t SCB_CPUID_IMPLEMENTER_MASK = UINT32_C(0xFF000000);                  /** @brief Implementer code */
    static const uint32_t SCB_ICSR_VECTACTIVE_MASK = UINT32_C(0x000001FF);                    /** @brief Active vector */
    static const uint32_t SCB_ICSR_RETTOBASE_MASK = UINT32_C(0x00000800);                     /** @brief Return to base level */
    static const uint32_t SCB_ICSR_VECTPENDING_MASK = UINT32_C(0x0007F000);                   /** @brief Pending vector */
    static const uint32_t SCB_ICSR_ISRPENDING_MASK = UINT32_C(0x00400000);                    /** @brief Interrupt pending flag */
    static const uint32_t SCB_ICSR_PENDSTCLR_MASK = UINT32_C(0x02000000);                     /** @brief SysTick exception clear-pending bit */
    static const uint32_t SCB_ICSR_PENDSTSET_MASK = UINT32_C(0x04000000);                     /** @brief SysTick exception set-pending bit */
    static const uint32_t SCB_ICSR_PENDSVCLR_MASK = UINT32_C(0x08000000);                     /** @brief PendSV clear-pending bit */
    static const uint32_t SCB_ICSR_PENDSVSET_MASK = UINT32_C(0x10000000);                     /** @brief PendSV set-pending bit */
    static const uint32_t SCB_ICSR_NMIPENDSET_MASK = UINT32_C(0x80000000);                    /** @brief NMI set-pending bit. */
    static const uint32_t SCB_VTOR_TBLOFF_MASK = UINT32_C(0x3FFFFE00);                        /** @brief Vector table base offset field */
    static const uint32_t SCB_AIRCR_VECTRESET_MASK = UINT32_C(0x00000001);                    /** @brief VECTRESET */
    static const uint32_t SCB_AIRCR_VECTCLRACTIVE_MASK = UINT32_C(0x00000002);                /** @brief VECTCLRACTIVE */
    static const uint32_t SCB_AIRCR_SYSRESETREQ_MASK = UINT32_C(0x00000004);                  /** @brief SYSRESETREQ */
    static const uint32_t SCB_AIRCR_PRIGROUP_MASK = UINT32_C(0x00000700);                     /** @brief PRIGROUP */
    static const uint32_t SCB_AIRCR_ENDIANESS_MASK = UINT32_C(0x00008000);                    /** @brief ENDIANESS */
    static const uint32_t SCB_AIRCR_VECTKEYSTAT_MASK = UINT32_C(0xFFFF0000);                  /** @brief Register key */
    static const uint32_t SCB_SCR_SLEEPONEXIT_MASK = UINT32_C(0x00000002);                    /** @brief SLEEPONEXIT */
    static const uint32_t SCB_SCR_SLEEPDEEP_MASK = UINT32_C(0x00000004);                      /** @brief SLEEPDEEP */
    static const uint32_t SCB_SCR_SEVEONPEND_MASK = UINT32_C(0x00000010);                     /** @brief Send event on pending bit */
    static const uint32_t SCB_CCR_NONBASETHRDENA_MASK = UINT32_C(0x00000001);                 /** @brief Configures how the processor enters thread mode */
    static const uint32_t SCB_CCR_USERSETMPEND_MASK = UINT32_C(0x00000002);                   /** @brief USERSETMPEND */
    static const uint32_t SCB_CCR_UNALIGN__TRP_MASK = UINT32_C(0x00000008);                   /** @brief UNALIGN_ TRP */
    static const uint32_t SCB_CCR_DIV_0_TRP_MASK = UINT32_C(0x00000010);                      /** @brief DIV_0_TRP */
    static const uint32_t SCB_CCR_BFHFNMIGN_MASK = UINT32_C(0x00000100);                      /** @brief BFHFNMIGN */
    static const uint32_t SCB_CCR_STKALIGN_MASK = UINT32_C(0x00000200);                       /** @brief STKALIGN */
    static const uint32_t SCB_CCR_DC_MASK = UINT32_C(0x00010000);                             /** @brief DC */
    static const uint32_t SCB_CCR_IC_MASK = UINT32_C(0x00020000);                             /** @brief IC */
    static const uint32_t SCB_CCR_BP_MASK = UINT32_C(0x00040000);                             /** @brief BP */
    static const uint32_t SCB_SHPR2_PRI_11_MASK = UINT32_C(0xFF000000);                       /** @brief Priority of system handler 11 */
    static const uint32_t SCB_SHPR3_PRI_14_MASK = UINT32_C(0x00FF0000);                       /** @brief Priority of system handler 14 */
    static const uint32_t SCB_SHPR3_PRI_15_MASK = UINT32_C(0xFF000000);                       /** @brief Priority of system handler 15 */
    static const uint32_t SCB_SHCRS_MEMFAULTACT_MASK = UINT32_C(0x00000001);                  /** @brief Memory management fault exception active bit */
    static const uint32_t SCB_SHCRS_BUSFAULTACT_MASK = UINT32_C(0x00000002);                  /** @brief Bus fault exception active bit */
    static const uint32_t SCB_SHCRS_USGFAULTACT_MASK = UINT32_C(0x00000008);                  /** @brief Usage fault exception active bit */
    static const uint32_t SCB_SHCRS_SVCALLACT_MASK = UINT32_C(0x00000080);                    /** @brief SVC call active bit */
    static const uint32_t SCB_SHCRS_MONITORACT_MASK = UINT32_C(0x00000100);                   /** @brief Debug monitor active bit */
    static const uint32_t SCB_SHCRS_PENDSVACT_MASK = UINT32_C(0x00000400);                    /** @brief PendSV exception active bit */
    static const uint32_t SCB_SHCRS_SYSTICKACT_MASK = UINT32_C(0x00000800);                   /** @brief SysTick exception active bit */
    static const uint32_t SCB_SHCRS_USGFAULTPENDED_MASK = UINT32_C(0x00001000);               /** @brief Usage fault exception pending bit */
    static const uint32_t SCB_SHCRS_MEMFAULTPENDED_MASK = UINT32_C(0x00002000);               /** @brief Memory management fault exception pending bit */
    static const uint32_t SCB_SHCRS_BUSFAULTPENDED_MASK = UINT32_C(0x00004000);               /** @brief Bus fault exception pending bit */
    static const uint32_t SCB_SHCRS_SVCALLPENDED_MASK = UINT32_C(0x00008000);                 /** @brief SVC call pending bit */
    static const uint32_t SCB_SHCRS_MEMFAULTENA_MASK = UINT32_C(0x00010000);                  /** @brief Memory management fault enable bit */
    static const uint32_t SCB_SHCRS_BUSFAULTENA_MASK = UINT32_C(0x00020000);                  /** @brief Bus fault enable bit */
    static const uint32_t SCB_SHCRS_USGFAULTENA_MASK = UINT32_C(0x00040000);                  /** @brief Usage fault enable bit */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_MASK = UINT32_C(0x00000001);      /** @brief IACCVIOL */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL_MASK = UINT32_C(0x00000002);      /** @brief DACCVIOL */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_MASK = UINT32_C(0x00000008);     /** @brief MUNSTKERR */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_MASK = UINT32_C(0x00000010);       /** @brief MSTKERR */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_MASK = UINT32_C(0x00000020);       /** @brief MLSPERR */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_MASK = UINT32_C(0x00000080);     /** @brief MMARVALID */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_MASK = UINT32_C(0x00000100);       /** @brief Instruction bus error */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_MASK = UINT32_C(0x00000200);     /** @brief Precise data bus error */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_MASK = UINT32_C(0x00000400);   /** @brief Imprecise data bus error */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_MASK = UINT32_C(0x00000800);      /** @brief Bus fault on unstacking for a return from exception */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_MASK = UINT32_C(0x00001000);        /** @brief Bus fault on stacking for exception entry */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_MASK = UINT32_C(0x00002000);        /** @brief Bus fault on floating-point lazy state preservation */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_MASK = UINT32_C(0x00008000);     /** @brief Bus fault address register (BFAR) valid flag */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_MASK = UINT32_C(0x00010000);    /** @brief Undefined instruction usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_MASK = UINT32_C(0x00020000);      /** @brief Invalid state usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_MASK = UINT32_C(0x00040000);         /** @brief Invalid PC load usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_MASK = UINT32_C(0x00080000);          /** @brief No coprocessor usage fault. */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_MASK = UINT32_C(0x01000000);     /** @brief Unaligned access usage fault */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_MASK = UINT32_C(0x02000000);     /** @brief Divide by zero usage fault */
    static const uint32_t SCB_HFSR_VECTTBL_MASK = UINT32_C(0x00000002);                       /** @brief Vector table hard fault */
    static const uint32_t SCB_HFSR_FORCED_MASK = UINT32_C(0x40000000);                        /** @brief Forced hard fault */
    static const uint32_t SCB_HFSR_DEBUG_VT_MASK = UINT32_C(0x80000000);                      /** @brief Reserved for debug use */

    /** @subsection SCB field position array definitions */

    static const int32_t SCB_BFAR_PRI_X_POS[7] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief Priority of system handler 4 */
      INT32_C(8),    /** @brief Priority of system handler 5 */
      INT32_C(16),   /** @brief Priority of system handler 6 */
    };

    /** @subsection SCB field position definitions */

    static const int32_t SCB_BFAR_REVISION_POS = INT32_C(0);          /** @brief Revision number */
    static const int32_t SCB_BFAR_PARTNO_POS = INT32_C(4);            /** @brief Part number of the processor */
    static const int32_t SCB_BFAR_CONSTANT_POS = INT32_C(16);         /** @brief Reads as 0xf */
    static const int32_t SCB_BFAR_VARIANT_POS = INT32_C(20);          /** @brief Variant number */
    static const int32_t SCB_BFAR_IMPLEMENTER_POS = INT32_C(24);      /** @brief Implementer code */
    static const int32_t SCB_BFAR_VECTACTIVE_POS = INT32_C(0);        /** @brief Active vector */
    static const int32_t SCB_BFAR_RETTOBASE_POS = INT32_C(11);        /** @brief Return to base level */
    static const int32_t SCB_BFAR_VECTPENDING_POS = INT32_C(12);      /** @brief Pending vector */
    static const int32_t SCB_BFAR_ISRPENDING_POS = INT32_C(22);       /** @brief Interrupt pending flag */
    static const int32_t SCB_BFAR_PENDSTCLR_POS = INT32_C(25);        /** @brief SysTick exception clear-pending bit */
    static const int32_t SCB_BFAR_PENDSTSET_POS = INT32_C(26);        /** @brief SysTick exception set-pending bit */
    static const int32_t SCB_BFAR_PENDSVCLR_POS = INT32_C(27);        /** @brief PendSV clear-pending bit */
    static const int32_t SCB_BFAR_PENDSVSET_POS = INT32_C(28);        /** @brief PendSV set-pending bit */
    static const int32_t SCB_BFAR_NMIPENDSET_POS = INT32_C(31);       /** @brief NMI set-pending bit. */
    static const int32_t SCB_BFAR_TBLOFF_POS = INT32_C(9);            /** @brief Vector table base offset field */
    static const int32_t SCB_BFAR_VECTRESET_POS = INT32_C(0);         /** @brief VECTRESET */
    static const int32_t SCB_BFAR_VECTCLRACTIVE_POS = INT32_C(1);     /** @brief VECTCLRACTIVE */
    static const int32_t SCB_BFAR_SYSRESETREQ_POS = INT32_C(2);       /** @brief SYSRESETREQ */
    static const int32_t SCB_BFAR_PRIGROUP_POS = INT32_C(8);          /** @brief PRIGROUP */
    static const int32_t SCB_BFAR_ENDIANESS_POS = INT32_C(15);        /** @brief ENDIANESS */
    static const int32_t SCB_BFAR_VECTKEYSTAT_POS = INT32_C(16);      /** @brief Register key */
    static const int32_t SCB_BFAR_SLEEPONEXIT_POS = INT32_C(1);       /** @brief SLEEPONEXIT */
    static const int32_t SCB_BFAR_SLEEPDEEP_POS = INT32_C(2);         /** @brief SLEEPDEEP */
    static const int32_t SCB_BFAR_SEVEONPEND_POS = INT32_C(4);        /** @brief Send event on pending bit */
    static const int32_t SCB_BFAR_NONBASETHRDENA_POS = INT32_C(0);    /** @brief Configures how the processor enters thread mode */
    static const int32_t SCB_BFAR_USERSETMPEND_POS = INT32_C(1);      /** @brief USERSETMPEND */
    static const int32_t SCB_BFAR_UNALIGN__TRP_POS = INT32_C(3);      /** @brief UNALIGN_ TRP */
    static const int32_t SCB_BFAR_DIV_0_TRP_POS = INT32_C(4);         /** @brief DIV_0_TRP */
    static const int32_t SCB_BFAR_BFHFNMIGN_POS = INT32_C(8);         /** @brief BFHFNMIGN */
    static const int32_t SCB_BFAR_STKALIGN_POS = INT32_C(9);          /** @brief STKALIGN */
    static const int32_t SCB_BFAR_DC_POS = INT32_C(16);               /** @brief DC */
    static const int32_t SCB_BFAR_IC_POS = INT32_C(17);               /** @brief IC */
    static const int32_t SCB_BFAR_BP_POS = INT32_C(18);               /** @brief BP */
    static const int32_t SCB_BFAR_PRI_11_POS = INT32_C(24);           /** @brief Priority of system handler 11 */
    static const int32_t SCB_BFAR_PRI_14_POS = INT32_C(16);           /** @brief Priority of system handler 14 */
    static const int32_t SCB_BFAR_PRI_15_POS = INT32_C(24);           /** @brief Priority of system handler 15 */
    static const int32_t SCB_BFAR_MEMFAULTACT_POS = INT32_C(0);       /** @brief Memory management fault exception active bit */
    static const int32_t SCB_BFAR_BUSFAULTACT_POS = INT32_C(1);       /** @brief Bus fault exception active bit */
    static const int32_t SCB_BFAR_USGFAULTACT_POS = INT32_C(3);       /** @brief Usage fault exception active bit */
    static const int32_t SCB_BFAR_SVCALLACT_POS = INT32_C(7);         /** @brief SVC call active bit */
    static const int32_t SCB_BFAR_MONITORACT_POS = INT32_C(8);        /** @brief Debug monitor active bit */
    static const int32_t SCB_BFAR_PENDSVACT_POS = INT32_C(10);        /** @brief PendSV exception active bit */
    static const int32_t SCB_BFAR_SYSTICKACT_POS = INT32_C(11);       /** @brief SysTick exception active bit */
    static const int32_t SCB_BFAR_USGFAULTPENDED_POS = INT32_C(12);   /** @brief Usage fault exception pending bit */
    static const int32_t SCB_BFAR_MEMFAULTPENDED_POS = INT32_C(13);   /** @brief Memory management fault exception pending bit */
    static const int32_t SCB_BFAR_BUSFAULTPENDED_POS = INT32_C(14);   /** @brief Bus fault exception pending bit */
    static const int32_t SCB_BFAR_SVCALLPENDED_POS = INT32_C(15);     /** @brief SVC call pending bit */
    static const int32_t SCB_BFAR_MEMFAULTENA_POS = INT32_C(16);      /** @brief Memory management fault enable bit */
    static const int32_t SCB_BFAR_BUSFAULTENA_POS = INT32_C(17);      /** @brief Bus fault enable bit */
    static const int32_t SCB_BFAR_USGFAULTENA_POS = INT32_C(18);      /** @brief Usage fault enable bit */
    static const int32_t SCB_BFAR_IACCVIOL_POS = INT32_C(0);          /** @brief IACCVIOL */
    static const int32_t SCB_BFAR_DACCVIOL_POS = INT32_C(1);          /** @brief DACCVIOL */
    static const int32_t SCB_BFAR_MUNSTKERR_POS = INT32_C(3);         /** @brief MUNSTKERR */
    static const int32_t SCB_BFAR_MSTKERR_POS = INT32_C(4);           /** @brief MSTKERR */
    static const int32_t SCB_BFAR_MLSPERR_POS = INT32_C(5);           /** @brief MLSPERR */
    static const int32_t SCB_BFAR_MMARVALID_POS = INT32_C(7);         /** @brief MMARVALID */
    static const int32_t SCB_BFAR_IBUSERR_POS = INT32_C(8);           /** @brief Instruction bus error */
    static const int32_t SCB_BFAR_PRECISERR_POS = INT32_C(9);         /** @brief Precise data bus error */
    static const int32_t SCB_BFAR_IMPRECISERR_POS = INT32_C(10);      /** @brief Imprecise data bus error */
    static const int32_t SCB_BFAR_UNSTKERR_POS = INT32_C(11);         /** @brief Bus fault on unstacking for a return from exception */
    static const int32_t SCB_BFAR_STKERR_POS = INT32_C(12);           /** @brief Bus fault on stacking for exception entry */
    static const int32_t SCB_BFAR_LSPERR_POS = INT32_C(13);           /** @brief Bus fault on floating-point lazy state preservation */
    static const int32_t SCB_BFAR_BFARVALID_POS = INT32_C(15);        /** @brief Bus fault address register (BFAR) valid flag */
    static const int32_t SCB_BFAR_UNDEFINSTR_POS = INT32_C(16);       /** @brief Undefined instruction usage fault */
    static const int32_t SCB_BFAR_INVSTATE_POS = INT32_C(17);         /** @brief Invalid state usage fault */
    static const int32_t SCB_BFAR_INVPC_POS = INT32_C(18);            /** @brief Invalid PC load usage fault */
    static const int32_t SCB_BFAR_NOCP_POS = INT32_C(19);             /** @brief No coprocessor usage fault. */
    static const int32_t SCB_BFAR_UNALIGNED_POS = INT32_C(24);        /** @brief Unaligned access usage fault */
    static const int32_t SCB_BFAR_DIVBYZERO_POS = INT32_C(25);        /** @brief Divide by zero usage fault */
    static const int32_t SCB_BFAR_VECTTBL_POS = INT32_C(1);           /** @brief Vector table hard fault */
    static const int32_t SCB_BFAR_FORCED_POS = INT32_C(30);           /** @brief Forced hard fault */
    static const int32_t SCB_BFAR_DEBUG_VT_POS = INT32_C(31);         /** @brief Reserved for debug use */

    /**********************************************************************************************
     * @section PF Definitions
     **********************************************************************************************/

    /** @subsection PF register definitions */

    static _RO uint32_t* const PF_CLIDR_REG = (_RO uint32_t* const)UINT32_C(0xE000ED78);    /** @brief Cache level ID register */
    static _RO uint32_t* const PF_CTR_REG = (_RO uint32_t* const)UINT32_C(0xE000ED7C);      /** @brief Cache type register */
    static _RO uint32_t* const PF_CCSIDR_REG = (_RO uint32_t* const)UINT32_C(0xE000ED80);   /** @brief Cache size ID register */

    /** @subsection PF field mask array definitions */

    static const uint32_t PF_CLIDR_CLX_MASK[8] = {
      UINT32_C(0x00000000),   /** @brief Invalid index. */
      UINT32_C(0x00000007),   /** @brief CL1 */
      UINT32_C(0x00000038),   /** @brief CL2 */
      UINT32_C(0x000001C0),   /** @brief CL3 */
      UINT32_C(0x00000E00),   /** @brief CL4 */
      UINT32_C(0x00007000),   /** @brief CL5 */
      UINT32_C(0x00038000),   /** @brief CL6 */
      UINT32_C(0x001C0000),   /** @brief CL7 */
    };

    /** @subsection PF field mask definitions */

    static const uint32_t PF_CLIDR_LOUIS_MASK = UINT32_C(0x00E00000);            /** @brief LoUIS */
    static const uint32_t PF_CLIDR_LOC_MASK = UINT32_C(0x07000000);              /** @brief LoC */
    static const uint32_t PF_CLIDR_LOU_MASK = UINT32_C(0x38000000);              /** @brief LoU */
    static const uint32_t PF_CTR__IMINLINE_MASK = UINT32_C(0x0000000F);          /** @brief IminLine */
    static const uint32_t PF_CTR_DMINLINE_MASK = UINT32_C(0x000F0000);           /** @brief DMinLine */
    static const uint32_t PF_CTR_ERG_MASK = UINT32_C(0x00F00000);                /** @brief ERG */
    static const uint32_t PF_CTR_CWG_MASK = UINT32_C(0x0F000000);                /** @brief CWG */
    static const uint32_t PF_CTR_FORMAT_MASK = UINT32_C(0xE0000000);             /** @brief Format */
    static const uint32_t PF_CCSIDR_LINESIZE_MASK = UINT32_C(0x00000007);        /** @brief LineSize */
    static const uint32_t PF_CCSIDR_ASSOCIATIVITY_MASK = UINT32_C(0x00001FF8);   /** @brief Associativity */
    static const uint32_t PF_CCSIDR_NUMSETS_MASK = UINT32_C(0x0FFFE000);         /** @brief NumSets */
    static const uint32_t PF_CCSIDR_WA_MASK = UINT32_C(0x10000000);              /** @brief WA */
    static const uint32_t PF_CCSIDR_RA_MASK = UINT32_C(0x20000000);              /** @brief RA */
    static const uint32_t PF_CCSIDR_WB_MASK = UINT32_C(0x40000000);              /** @brief WB */
    static const uint32_t PF_CCSIDR_WT_MASK = UINT32_C(0x80000000);              /** @brief WT */

    /** @subsection PF field position array definitions */

    static const int32_t PF_CCSIDR_CLX_POS[8] = {
      INT32_C(-1),   /** @brief Invalid index. */
      INT32_C(0),    /** @brief CL1 */
      INT32_C(3),    /** @brief CL2 */
      INT32_C(6),    /** @brief CL3 */
      INT32_C(9),    /** @brief CL4 */
      INT32_C(12),   /** @brief CL5 */
      INT32_C(15),   /** @brief CL6 */
      INT32_C(18),   /** @brief CL7 */
    };

    /** @subsection PF field position definitions */

    static const int32_t PF_CCSIDR_LOUIS_POS = INT32_C(21);           /** @brief LoUIS */
    static const int32_t PF_CCSIDR_LOC_POS = INT32_C(24);             /** @brief LoC */
    static const int32_t PF_CCSIDR_LOU_POS = INT32_C(27);             /** @brief LoU */
    static const int32_t PF_CCSIDR__IMINLINE_POS = INT32_C(0);        /** @brief IminLine */
    static const int32_t PF_CCSIDR_DMINLINE_POS = INT32_C(16);        /** @brief DMinLine */
    static const int32_t PF_CCSIDR_ERG_POS = INT32_C(20);             /** @brief ERG */
    static const int32_t PF_CCSIDR_CWG_POS = INT32_C(24);             /** @brief CWG */
    static const int32_t PF_CCSIDR_FORMAT_POS = INT32_C(29);          /** @brief Format */
    static const int32_t PF_CCSIDR_LINESIZE_POS = INT32_C(0);         /** @brief LineSize */
    static const int32_t PF_CCSIDR_ASSOCIATIVITY_POS = INT32_C(3);    /** @brief Associativity */
    static const int32_t PF_CCSIDR_NUMSETS_POS = INT32_C(13);         /** @brief NumSets */
    static const int32_t PF_CCSIDR_WA_POS = INT32_C(28);              /** @brief WA */
    static const int32_t PF_CCSIDR_RA_POS = INT32_C(29);              /** @brief RA */
    static const int32_t PF_CCSIDR_WB_POS = INT32_C(30);              /** @brief WB */
    static const int32_t PF_CCSIDR_WT_POS = INT32_C(31);              /** @brief WT */

    /**********************************************************************************************
     * @section AC Definitions
     **********************************************************************************************/

    /** @subsection AC register definitions */

    static _RW uint32_t* const AC_ITCMCR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF90);   /** @brief Instruction and data tightly-coupled memory control registers */
    static _RW uint32_t* const AC_DTCMCR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF94);   /** @brief Instruction and data tightly-coupled memory control registers */
    static _RW uint32_t* const AC_AHBPCR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF98);   /** @brief AHBP control register */
    static _RW uint32_t* const AC_CACR_REG = (_RW uint32_t* const)UINT32_C(0xE000EF9C);     /** @brief Auxiliary cache control register */
    static _RW uint32_t* const AC_AHBSCR_REG = (_RW uint32_t* const)UINT32_C(0xE000EFA0);   /** @brief AHB slave control register */
    static _RW uint32_t* const AC_ABFSR_REG = (_RW uint32_t* const)UINT32_C(0xE000EFA8);    /** @brief Auxiliary bus fault status register */

    /** @subsection AC field mask definitions */

    static const uint32_t AC_ITCMCR_EN_MASK = UINT32_C(0x00000001);          /** @brief EN */
    static const uint32_t AC_ITCMCR_RMW_MASK = UINT32_C(0x00000002);         /** @brief RMW */
    static const uint32_t AC_ITCMCR_RETEN_MASK = UINT32_C(0x00000004);       /** @brief RETEN */
    static const uint32_t AC_ITCMCR_SZ_MASK = UINT32_C(0x00000078);          /** @brief SZ */
    static const uint32_t AC_DTCMCR_EN_MASK = UINT32_C(0x00000001);          /** @brief EN */
    static const uint32_t AC_DTCMCR_RMW_MASK = UINT32_C(0x00000002);         /** @brief RMW */
    static const uint32_t AC_DTCMCR_RETEN_MASK = UINT32_C(0x00000004);       /** @brief RETEN */
    static const uint32_t AC_DTCMCR_SZ_MASK = UINT32_C(0x00000078);          /** @brief SZ */
    static const uint32_t AC_AHBPCR_EN_MASK = UINT32_C(0x00000001);          /** @brief EN */
    static const uint32_t AC_AHBPCR_SZ_MASK = UINT32_C(0x0000000E);          /** @brief SZ */
    static const uint32_t AC_CACR_SIWT_MASK = UINT32_C(0x00000001);          /** @brief SIWT */
    static const uint32_t AC_CACR_ECCEN_MASK = UINT32_C(0x00000002);         /** @brief ECCEN */
    static const uint32_t AC_CACR_FORCEWT_MASK = UINT32_C(0x00000004);       /** @brief FORCEWT */
    static const uint32_t AC_AHBSCR_CTL_MASK = UINT32_C(0x00000003);         /** @brief CTL */
    static const uint32_t AC_AHBSCR_TPRI_MASK = UINT32_C(0x000007FC);        /** @brief TPRI */
    static const uint32_t AC_AHBSCR_INITCOUNT_MASK = UINT32_C(0x0000F800);   /** @brief INITCOUNT */
    static const uint32_t AC_ABFSR_ITCM_MASK = UINT32_C(0x00000001);         /** @brief ITCM */
    static const uint32_t AC_ABFSR_DTCM_MASK = UINT32_C(0x00000002);         /** @brief DTCM */
    static const uint32_t AC_ABFSR_AHBP_MASK = UINT32_C(0x00000004);         /** @brief AHBP */
    static const uint32_t AC_ABFSR_AXIM_MASK = UINT32_C(0x00000008);         /** @brief AXIM */
    static const uint32_t AC_ABFSR_EPPB_MASK = UINT32_C(0x00000010);         /** @brief EPPB */
    static const uint32_t AC_ABFSR_AXIMTYPE_MASK = UINT32_C(0x00000300);     /** @brief AXIMTYPE */

    /** @subsection AC field position definitions */

    static const int32_t AC_ABFSR_EN_POS = INT32_C(0);           /** @brief EN */
    static const int32_t AC_ABFSR_RMW_POS = INT32_C(1);          /** @brief RMW */
    static const int32_t AC_ABFSR_RETEN_POS = INT32_C(2);        /** @brief RETEN */
    static const int32_t AC_ABFSR_SZ_POS = INT32_C(3);           /** @brief SZ */
    static const int32_t AC_ABFSR_EN_POS = INT32_C(0);           /** @brief EN */
    static const int32_t AC_ABFSR_RMW_POS = INT32_C(1);          /** @brief RMW */
    static const int32_t AC_ABFSR_RETEN_POS = INT32_C(2);        /** @brief RETEN */
    static const int32_t AC_ABFSR_SZ_POS = INT32_C(3);           /** @brief SZ */
    static const int32_t AC_ABFSR_EN_POS = INT32_C(0);           /** @brief EN */
    static const int32_t AC_ABFSR_SZ_POS = INT32_C(1);           /** @brief SZ */
    static const int32_t AC_ABFSR_SIWT_POS = INT32_C(0);         /** @brief SIWT */
    static const int32_t AC_ABFSR_ECCEN_POS = INT32_C(1);        /** @brief ECCEN */
    static const int32_t AC_ABFSR_FORCEWT_POS = INT32_C(2);      /** @brief FORCEWT */
    static const int32_t AC_ABFSR_CTL_POS = INT32_C(0);          /** @brief CTL */
    static const int32_t AC_ABFSR_TPRI_POS = INT32_C(2);         /** @brief TPRI */
    static const int32_t AC_ABFSR_INITCOUNT_POS = INT32_C(11);   /** @brief INITCOUNT */
    static const int32_t AC_ABFSR_ITCM_POS = INT32_C(0);         /** @brief ITCM */
    static const int32_t AC_ABFSR_DTCM_POS = INT32_C(1);         /** @brief DTCM */
    static const int32_t AC_ABFSR_AHBP_POS = INT32_C(2);         /** @brief AHBP */
    static const int32_t AC_ABFSR_AXIM_POS = INT32_C(3);         /** @brief AXIM */
    static const int32_t AC_ABFSR_EPPB_POS = INT32_C(4);         /** @brief EPPB */
    static const int32_t AC_ABFSR_AXIMTYPE_POS = INT32_C(8);     /** @brief AXIMTYPE */

    /**********************************************************************************************
     * @section RAMECC1 Definitions
     **********************************************************************************************/

    /** @subsection RAMECC1 register array definitions */

    static _RO uint32_t* const RAMECC1_MXFDRH_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x52009050),   /** @brief RAMECC monitor x failing data high register */
      (_RO uint32_t* const)UINT32_C(0x52009070),   /** @brief RAMECC monitor x failing data high register */
      (_RO uint32_t* const)UINT32_C(0x52009090),   /** @brief RAMECC monitor x failing data high register */
      (_RO uint32_t* const)UINT32_C(0x520090B0),   /** @brief RAMECC monitor x failing data high register */
    };

    static _RO uint32_t* const RAMECC1_MXFECR_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x52009058),   /** @brief RAMECC monitor x failing ECC error code register */
      (_RO uint32_t* const)UINT32_C(0x5200907C),   /** @brief RAMECC monitor x failing ECC error code register */
      (_RO uint32_t* const)UINT32_C(0x52009090),   /** @brief RAMECC monitor x failing ECC error code register */
      (_RO uint32_t* const)UINT32_C(0x520090B4),   /** @brief RAMECC monitor x failing ECC error code register */
    };

    static _RO uint32_t* const RAMECC1_MXCR_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x52009060),   /** @brief RAMECC monitor x configuration register */
      (_RO uint32_t* const)UINT32_C(0x52009080),   /** @brief RAMECC monitor x configuration register */
      (_RO uint32_t* const)UINT32_C(0x520090A0),   /** @brief RAMECC monitor x configuration register */
    };

    static _RO uint32_t* const RAMECC1_MXSR_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x52009064),   /** @brief RAMECC monitor x status register */
      (_RO uint32_t* const)UINT32_C(0x52009084),   /** @brief RAMECC monitor x status register */
      (_RO uint32_t* const)UINT32_C(0x520090A4),   /** @brief RAMECC monitor x status register */
    };

    static _RW uint32_t* const RAMECC1_MXFAR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x52009068),   /** @brief RAMECC monitor x failing address register */
      (_RW uint32_t* const)UINT32_C(0x52009088),   /** @brief RAMECC monitor x failing address register */
      (_RW uint32_t* const)UINT32_C(0x520090A8),   /** @brief RAMECC monitor x failing address register */
    };

    static _RO uint32_t* const RAMECC1_MXFDRL_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x5200906C),   /** @brief RAMECC monitor x failing data low register */
      (_RO uint32_t* const)UINT32_C(0x5200908C),   /** @brief RAMECC monitor x failing data low register */
      (_RO uint32_t* const)UINT32_C(0x520090AC),   /** @brief RAMECC monitor x failing data low register */
    };

    /** @subsection RAMECC1 register definitions */

    static _RW uint32_t* const RAMECC1_IER_REG = (_RW uint32_t* const)UINT32_C(0x52009000);      /** @brief RAMECC interrupt enable register */
    static _RW uint32_t* const RAMECC1_M1CR_REG = (_RW uint32_t* const)UINT32_C(0x52009020);     /** @brief RAMECC monitor x configuration register */
    static _RW uint32_t* const RAMECC1_M1SR_REG = (_RW uint32_t* const)UINT32_C(0x52009024);     /** @brief RAMECC monitor x status register */
    static _RW uint32_t* const RAMECC1_M1FAR_REG = (_RW uint32_t* const)UINT32_C(0x52009028);    /** @brief RAMECC monitor x failing address register */
    static _RW uint32_t* const RAMECC1_M1FDRL_REG = (_RW uint32_t* const)UINT32_C(0x5200902C);   /** @brief RAMECC monitor x failing data low register */
    static _RW uint32_t* const RAMECC1_M1FDRH_REG = (_RW uint32_t* const)UINT32_C(0x52009030);   /** @brief RAMECC monitor x failing data high register */
    static _RW uint32_t* const RAMECC1_M1FECR_REG = (_RW uint32_t* const)UINT32_C(0x52009034);   /** @brief RAMECC monitor x failing ECC error code register */
    static _RW uint32_t* const RAMECC1_M2CR_REG = (_RW uint32_t* const)UINT32_C(0x52009040);     /** @brief RAMECC monitor x configuration register */
    static _RW uint32_t* const RAMECC1_M2SR_REG = (_RW uint32_t* const)UINT32_C(0x52009044);     /** @brief RAMECC monitor x status register */
    static _RW uint32_t* const RAMECC1_M2FAR_REG = (_RW uint32_t* const)UINT32_C(0x52009048);    /** @brief RAMECC monitor x failing address register */
    static _RW uint32_t* const RAMECC1_M2FDRL_REG = (_RW uint32_t* const)UINT32_C(0x5200904C);   /** @brief RAMECC monitor x failing data low register */

    /** @subsection RAMECC1 field mask definitions */

    static const uint32_t RAMECC1_IER_GIE_MASK = UINT32_C(0x00000001);            /** @brief Global interrupt enable */
    static const uint32_t RAMECC1_IER_GECCSEIE__MASK = UINT32_C(0x00000002);      /** @brief Global ECC single error interrupt enable */
    static const uint32_t RAMECC1_IER_GECCDEIE_MASK = UINT32_C(0x00000004);       /** @brief Global ECC double error interrupt enable */
    static const uint32_t RAMECC1_IER_GECCDEBWIE_MASK = UINT32_C(0x00000008);     /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCSEIE_MASK = UINT32_C(0x00000004);       /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCDEIE_MASK = UINT32_C(0x00000008);       /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCDEBWIE_MASK = UINT32_C(0x00000010);     /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1CR_ECCELEN_MASK = UINT32_C(0x00000020);       /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1SR_ECCSEIE_MASK = UINT32_C(0x00000004);       /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1SR_ECCDEIE_MASK = UINT32_C(0x00000008);       /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1SR_ECCDEBWIE_MASK = UINT32_C(0x00000010);     /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1SR_ECCELEN_MASK = UINT32_C(0x00000020);       /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FAR_ECCSEIE_MASK = UINT32_C(0x00000004);      /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1FAR_ECCDEIE_MASK = UINT32_C(0x00000008);      /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1FAR_ECCDEBWIE_MASK = UINT32_C(0x00000010);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1FAR_ECCELEN_MASK = UINT32_C(0x00000020);      /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FDRL_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1FDRL_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1FDRL_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1FDRL_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FDRH_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC1_M1FDRH_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC1_M1FDRH_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC1_M1FDRH_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC1_M1FECR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M1FECR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M1FECR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2CR_SEDCF_MASK = UINT32_C(0x00000001);         /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2CR_DEDF_MASK = UINT32_C(0x00000002);          /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2CR_DEBWDF_MASK = UINT32_C(0x00000004);        /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2SR_SEDCF_MASK = UINT32_C(0x00000001);         /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2SR_DEDF_MASK = UINT32_C(0x00000002);          /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2SR_DEBWDF_MASK = UINT32_C(0x00000004);        /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2FAR_SEDCF_MASK = UINT32_C(0x00000001);        /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2FAR_DEDF_MASK = UINT32_C(0x00000002);         /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2FAR_DEBWDF_MASK = UINT32_C(0x00000004);       /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC1_M2FDRL_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC1_M2FDRL_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC1_M2FDRL_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */

    /** @subsection RAMECC1 field position definitions */

    static const int32_t RAMECC1_MXFECR_GIE_POS = INT32_C(0);          /** @brief Global interrupt enable */
    static const int32_t RAMECC1_MXFECR_GECCSEIE__POS = INT32_C(1);    /** @brief Global ECC single error interrupt enable */
    static const int32_t RAMECC1_MXFECR_GECCDEIE_POS = INT32_C(2);     /** @brief Global ECC double error interrupt enable */
    static const int32_t RAMECC1_MXFECR_GECCDEBWIE_POS = INT32_C(3);   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC1_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC1_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC1_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC1_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC1_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC1_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC1_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC1_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC1_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */

    /**********************************************************************************************
     * @section RAMECC2 Definitions
     **********************************************************************************************/

    /** @subsection RAMECC2 register array definitions */

    static _RW uint32_t* const RAMECC2_MXCR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x48023020),   /** @brief RAMECC monitor x configuration register */
      (_RW uint32_t* const)UINT32_C(0x48023040),   /** @brief RAMECC monitor x configuration register */
      (_RW uint32_t* const)UINT32_C(0x48023060),   /** @brief RAMECC monitor x configuration register */
      (_RW uint32_t* const)UINT32_C(0x48023080),   /** @brief RAMECC monitor x configuration register */
      (_RW uint32_t* const)UINT32_C(0x480230A0),   /** @brief RAMECC monitor x configuration register */
    };

    static _RW uint32_t* const RAMECC2_MXSR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x48023024),   /** @brief RAMECC monitor x status register */
      (_RW uint32_t* const)UINT32_C(0x48023044),   /** @brief RAMECC monitor x status register */
      (_RW uint32_t* const)UINT32_C(0x48023064),   /** @brief RAMECC monitor x status register */
      (_RW uint32_t* const)UINT32_C(0x48023084),   /** @brief RAMECC monitor x status register */
      (_RW uint32_t* const)UINT32_C(0x480230A4),   /** @brief RAMECC monitor x status register */
    };

    static _RO uint32_t* const RAMECC2_MXFAR_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x48023028),   /** @brief RAMECC monitor x failing address register */
      (_RO uint32_t* const)UINT32_C(0x48023048),   /** @brief RAMECC monitor x failing address register */
      (_RO uint32_t* const)UINT32_C(0x48023068),   /** @brief RAMECC monitor x failing address register */
      (_RO uint32_t* const)UINT32_C(0x48023088),   /** @brief RAMECC monitor x failing address register */
      (_RO uint32_t* const)UINT32_C(0x480230A8),   /** @brief RAMECC monitor x failing address register */
    };

    static _RO uint32_t* const RAMECC2_MXFDRL_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x4802302C),   /** @brief RAMECC monitor x failing data low register */
      (_RO uint32_t* const)UINT32_C(0x4802304C),   /** @brief RAMECC monitor x failing data low register */
      (_RO uint32_t* const)UINT32_C(0x4802306C),   /** @brief RAMECC monitor x failing data low register */
      (_RO uint32_t* const)UINT32_C(0x4802308C),   /** @brief RAMECC monitor x failing data low register */
      (_RO uint32_t* const)UINT32_C(0x480230AC),   /** @brief RAMECC monitor x failing data low register */
    };

    static _RO uint32_t* const RAMECC2_MXFDRH_REG[6] = {
      (_RO uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RO uint32_t* const)UINT32_C(0x48023030),   /** @brief RAMECC monitor x failing data high register */
      (_RO uint32_t* const)UINT32_C(0x48023050),   /** @brief RAMECC monitor x failing data high register */
      (_RO uint32_t* const)UINT32_C(0x48023070),   /** @brief RAMECC monitor x failing data high register */
      (_RO uint32_t* const)UINT32_C(0x48023090),   /** @brief RAMECC monitor x failing data high register */
      (_RO uint32_t* const)UINT32_C(0x480230B0),   /** @brief RAMECC monitor x failing data high register */
    };

    static _RW uint32_t* const RAMECC2_MXFECR_REG[6] = {
      (_RW uint32_t* const)UINT32_C(0x00000000),   /** @brief Invalid index. */
      (_RW uint32_t* const)UINT32_C(0x48023034),   /** @brief RAMECC monitor x failing ECC error code register */
      (_RW uint32_t* const)UINT32_C(0x48023058),   /** @brief RAMECC monitor x failing ECC error code register */
      (_RW uint32_t* const)UINT32_C(0x4802307C),   /** @brief RAMECC monitor x failing ECC error code register */
      (_RW uint32_t* const)UINT32_C(0x48023090),   /** @brief RAMECC monitor x failing ECC error code register */
      (_RW uint32_t* const)UINT32_C(0x480230B4),   /** @brief RAMECC monitor x failing ECC error code register */
    };

    /** @subsection RAMECC2 register definitions */

    static _RW uint32_t* const RAMECC2_IER_REG = (_RW uint32_t* const)UINT32_C(0x48023000);   /** @brief RAMECC interrupt enable register */

    /** @subsection RAMECC2 field mask definitions */

    static const uint32_t RAMECC2_IER_GIE_MASK = UINT32_C(0x00000001);          /** @brief Global interrupt enable */
    static const uint32_t RAMECC2_IER_GECCSEIE__MASK = UINT32_C(0x00000002);    /** @brief Global ECC single error interrupt enable */
    static const uint32_t RAMECC2_IER_GECCDEIE_MASK = UINT32_C(0x00000004);     /** @brief Global ECC double error interrupt enable */
    static const uint32_t RAMECC2_IER_GECCDEBWIE_MASK = UINT32_C(0x00000008);   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC2_MXCR_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC2_MXCR_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC2_MXCR_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC2_MXCR_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC2_MXCR_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC2_MXSR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC2_MXSR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC2_MXSR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC2_MXSR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC2_MXSR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC2_MXSR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC2_MXSR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC2_MXSR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC2_MXSR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC2_MXSR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC2_MXSR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC2_MXSR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC2_MXSR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC2_MXSR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC2_MXSR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */

    /** @subsection RAMECC2 field position definitions */

    static const int32_t RAMECC2_MXFECR_GIE_POS = INT32_C(0);          /** @brief Global interrupt enable */
    static const int32_t RAMECC2_MXFECR_GECCSEIE__POS = INT32_C(1);    /** @brief Global ECC single error interrupt enable */
    static const int32_t RAMECC2_MXFECR_GECCDEIE_POS = INT32_C(2);     /** @brief Global ECC double error interrupt enable */
    static const int32_t RAMECC2_MXFECR_GECCDEBWIE_POS = INT32_C(3);   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC2_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC2_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC2_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC2_MXFECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC2_MXFECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC2_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC2_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC2_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC2_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC2_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC2_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC2_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC2_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC2_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC2_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC2_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC2_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC2_MXFECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC2_MXFECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC2_MXFECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */

    /**********************************************************************************************
     * @section RAMECC3 Definitions
     **********************************************************************************************/

    /** @subsection RAMECC3 register definitions */

    static _RW uint32_t* const RAMECC3_IER_REG = (_RW uint32_t* const)UINT32_C(0x58027000);      /** @brief RAMECC interrupt enable register */
    static _RW uint32_t* const RAMECC3_M1CR_REG = (_RW uint32_t* const)UINT32_C(0x58027020);     /** @brief RAMECC monitor x configuration register */
    static _RW uint32_t* const RAMECC3_M2CR_REG = (_RW uint32_t* const)UINT32_C(0x58027040);     /** @brief RAMECC monitor x configuration register */
    static _RW uint32_t* const RAMECC3_M1SR_REG = (_RW uint32_t* const)UINT32_C(0x58027024);     /** @brief RAMECC monitor x status register */
    static _RW uint32_t* const RAMECC3_M2SR_REG = (_RW uint32_t* const)UINT32_C(0x58027044);     /** @brief RAMECC monitor x status register */
    static _RO uint32_t* const RAMECC3_M1FAR_REG = (_RO uint32_t* const)UINT32_C(0x58027028);    /** @brief RAMECC monitor x failing address register */
    static _RO uint32_t* const RAMECC3_M2FAR_REG = (_RO uint32_t* const)UINT32_C(0x58027048);    /** @brief RAMECC monitor x failing address register */
    static _RO uint32_t* const RAMECC3_M1FDRL_REG = (_RO uint32_t* const)UINT32_C(0x5802702C);   /** @brief RAMECC monitor x failing data low register */
    static _RO uint32_t* const RAMECC3_M2FDRL_REG = (_RO uint32_t* const)UINT32_C(0x5802704C);   /** @brief RAMECC monitor x failing data low register */
    static _RO uint32_t* const RAMECC3_M1FDRH_REG = (_RO uint32_t* const)UINT32_C(0x58027030);   /** @brief RAMECC monitor x failing data high register */
    static _RW uint32_t* const RAMECC3_M2FDRH_REG = (_RW uint32_t* const)UINT32_C(0x58027050);   /** @brief RAMECC monitor x failing data high register */
    static _RW uint32_t* const RAMECC3_M1FECR_REG = (_RW uint32_t* const)UINT32_C(0x58027034);   /** @brief RAMECC monitor x failing ECC error code register */
    static _RW uint32_t* const RAMECC3_M2FECR_REG = (_RW uint32_t* const)UINT32_C(0x58027058);   /** @brief RAMECC monitor x failing ECC error code register */

    /** @subsection RAMECC3 field mask definitions */

    static const uint32_t RAMECC3_IER_GIE_MASK = UINT32_C(0x00000001);          /** @brief Global interrupt enable */
    static const uint32_t RAMECC3_IER_GECCSEIE__MASK = UINT32_C(0x00000002);    /** @brief Global ECC single error interrupt enable */
    static const uint32_t RAMECC3_IER_GECCDEIE_MASK = UINT32_C(0x00000004);     /** @brief Global ECC double error interrupt enable */
    static const uint32_t RAMECC3_IER_GECCDEBWIE_MASK = UINT32_C(0x00000008);   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC3_M1CR_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC3_M1CR_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC3_M1CR_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC3_M1CR_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC3_M2CR_ECCSEIE_MASK = UINT32_C(0x00000004);     /** @brief ECC single error interrupt enable */
    static const uint32_t RAMECC3_M2CR_ECCDEIE_MASK = UINT32_C(0x00000008);     /** @brief ECC double error interrupt enable */
    static const uint32_t RAMECC3_M2CR_ECCDEBWIE_MASK = UINT32_C(0x00000010);   /** @brief ECC double error on byte write (BW) interrupt enable */
    static const uint32_t RAMECC3_M2CR_ECCELEN_MASK = UINT32_C(0x00000020);     /** @brief ECC error latching enable */
    static const uint32_t RAMECC3_M1SR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC3_M1SR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC3_M1SR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */
    static const uint32_t RAMECC3_M2SR_SEDCF_MASK = UINT32_C(0x00000001);       /** @brief ECC single error detected and corrected flag */
    static const uint32_t RAMECC3_M2SR_DEDF_MASK = UINT32_C(0x00000002);        /** @brief ECC double error detected flag */
    static const uint32_t RAMECC3_M2SR_DEBWDF_MASK = UINT32_C(0x00000004);      /** @brief ECC double error on byte write (BW) detected flag */

    /** @subsection RAMECC3 field position definitions */

    static const int32_t RAMECC3_M2FECR_GIE_POS = INT32_C(0);          /** @brief Global interrupt enable */
    static const int32_t RAMECC3_M2FECR_GECCSEIE__POS = INT32_C(1);    /** @brief Global ECC single error interrupt enable */
    static const int32_t RAMECC3_M2FECR_GECCDEIE_POS = INT32_C(2);     /** @brief Global ECC double error interrupt enable */
    static const int32_t RAMECC3_M2FECR_GECCDEBWIE_POS = INT32_C(3);   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC3_M2FECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC3_M2FECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC3_M2FECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC3_M2FECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC3_M2FECR_ECCSEIE_POS = INT32_C(2);      /** @brief ECC single error interrupt enable */
    static const int32_t RAMECC3_M2FECR_ECCDEIE_POS = INT32_C(3);      /** @brief ECC double error interrupt enable */
    static const int32_t RAMECC3_M2FECR_ECCDEBWIE_POS = INT32_C(4);    /** @brief ECC double error on byte write (BW) interrupt enable */
    static const int32_t RAMECC3_M2FECR_ECCELEN_POS = INT32_C(5);      /** @brief ECC error latching enable */
    static const int32_t RAMECC3_M2FECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC3_M2FECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC3_M2FECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */
    static const int32_t RAMECC3_M2FECR_SEDCF_POS = INT32_C(0);        /** @brief ECC single error detected and corrected flag */
    static const int32_t RAMECC3_M2FECR_DEDF_POS = INT32_C(1);         /** @brief ECC double error detected flag */
    static const int32_t RAMECC3_M2FECR_DEBWDF_POS = INT32_C(2);       /** @brief ECC double error on byte write (BW) detected flag */

    /**********************************************************************************************
     * @section ART Definitions
     **********************************************************************************************/

    /** @subsection ART register definitions */

    static _RW uint32_t* const ART_CTR_REG = (_RW uint32_t* const)UINT32_C(0x40024400);   /** @brief Control register */

    /** @subsection ART field mask definitions */

    static const uint32_t ART_CTR_EN_MASK = UINT32_C(0x00000001);           /** @brief Cache enable */
    static const uint32_t ART_CTR_PCACHEADDR_MASK = UINT32_C(0x000FFF00);   /** @brief Cacheable page index */

    /** @subsection ART field position definitions */

    static const int32_t ART_CTR_EN_POS = INT32_C(0);           /** @brief Cache enable */
    static const int32_t ART_CTR_PCACHEADDR_POS = INT32_C(8);   /** @brief Cacheable page index */

