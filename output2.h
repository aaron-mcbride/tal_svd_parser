    #include <stdint.h>

    #define RO_ const volatile
    #define RW_ volatile

    /**********************************************************************************************
     * @section COMP1 Register Definitions
     **********************************************************************************************/

    /**** @subsection COMP1 Register Pointer Definitions ****/

    static RO_ uint32_t* const COMP1_SR_PTR   = (RO_ uint32_t*)0x58003800U;   /** @brief Comparator status register */
    static RW_ uint32_t* const COMP1_ICFR_PTR = (RW_ uint32_t*)0x58003804U;   /** @brief Comparator interrupt clear flag register */
    static RW_ uint32_t* const COMP1_OR_PTR   = (RW_ uint32_t*)0x58003808U;   /** @brief Comparator option register */

    static RW_ uint32_t* const COMP1_CFGRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x58003810U,   /** @brief Comparator configuration register 2 */
      [1] = (RW_ uint32_t*)0x5800380CU   /** @brief Comparator configuration register 1 */
    };

    /**** @subsection COMP1 Register Reset Value Definitions ****/

    static const uint32_t COMP1_SR_RST   = 0x00000000U;   /** @brief Comparator status register */
    static const uint32_t COMP1_ICFR_RST = 0x00000000U;   /** @brief Comparator interrupt clear flag register */
    static const uint32_t COMP1_OR_RST   = 0x00000000U;   /** @brief Comparator option register */

    static const uint32_t COMP1_CFGRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Comparator configuration register 2 */
      [1] = 0x00000000U   /** @brief Comparator configuration register 1 */
    };

    /**** @subsection COMP1 Register Value Type Definitions ****/

    typedef uint32_t COMP1_SR_vt;      /** @brief COMP1_SR register value type. */
    typedef uint32_t COMP1_ICFR_vt;    /** @brief COMP1_ICFR register value type. */
    typedef uint32_t COMP1_OR_vt;      /** @brief COMP1_OR register value type. */
    typedef uint32_t COMP1_CFGRx_vt;   /** @brief COMP1_CFGRx register value type. */

    /**** @subsection COMP1 Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* COMP1_SR_pt;      /** @brief COMP1_SR pointer register pointer type. */
    typedef RW_ uint32_t* COMP1_ICFR_pt;    /** @brief COMP1_ICFR pointer register pointer type. */
    typedef RW_ uint32_t* COMP1_OR_pt;      /** @brief COMP1_OR pointer register pointer type. */
    typedef RW_ uint32_t* COMP1_CFGRx_pt;   /** @brief COMP1_CFGRx pointer register pointer type. */

    /**** @subsection COMP1 Field Mask Definitions ****/

    static const uint32_t COMP1_OR_OR_MASK = 0xFFFFF800U;   /** @brief Option register */

    static const uint32_t COMP1_SR_CxIF_MASK[3] = {
      [2] = 0x00020000U,   /** @brief COMP channel 2 interrupt flag */
      [1] = 0x00010000U   /** @brief COMP channel 1 interrupt flag */
    };

    static const uint32_t COMP1_ICFR_CCxIF_MASK[3] = {
      [2] = 0x00020000U,   /** @brief Clear COMP channel 2 interrupt flag */
      [1] = 0x00010000U   /** @brief Clear COMP channel 1 interrupt flag */
    };

    static const uint32_t COMP1_CFGRx_LOCK_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Lock bit */
      [1] = 0x80000000U   /** @brief Lock bit */
    };

    /**********************************************************************************************
     * @section CRS Register Definitions
     **********************************************************************************************/

    /**** @subsection CRS Register Pointer Definitions ****/

    static RW_ uint32_t* const CRS_CR_PTR   = (RW_ uint32_t*)0x40008400U;   /** @brief CRS control register */
    static RW_ uint32_t* const CRS_CFGR_PTR = (RW_ uint32_t*)0x40008404U;   /** @brief This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected. */
    static RO_ uint32_t* const CRS_ISR_PTR  = (RO_ uint32_t*)0x40008408U;   /** @brief CRS interrupt and status register */
    static RW_ uint32_t* const CRS_ICR_PTR  = (RW_ uint32_t*)0x4000840CU;   /** @brief CRS interrupt flag clear register */

    /**** @subsection CRS Register Reset Value Definitions ****/

    static const uint32_t CRS_CR_RST   = 0x00002000U;   /** @brief CRS control register */
    static const uint32_t CRS_CFGR_RST = 0x2022BB7FU;   /** @brief This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected. */
    static const uint32_t CRS_ISR_RST  = 0x00000000U;   /** @brief CRS interrupt and status register */
    static const uint32_t CRS_ICR_RST  = 0x00000000U;   /** @brief CRS interrupt flag clear register */

    /**** @subsection CRS Register Value Type Definitions ****/

    typedef uint32_t CRS_CR_vt;     /** @brief CRS_CR register value type. */
    typedef uint32_t CRS_CFGR_vt;   /** @brief CRS_CFGR register value type. */
    typedef uint32_t CRS_ISR_vt;    /** @brief CRS_ISR register value type. */
    typedef uint32_t CRS_ICR_vt;    /** @brief CRS_ICR register value type. */

    /**** @subsection CRS Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* CRS_CR_pt;     /** @brief CRS_CR pointer register pointer type. */
    typedef RW_ uint32_t* CRS_CFGR_pt;   /** @brief CRS_CFGR pointer register pointer type. */
    typedef RO_ uint32_t* CRS_ISR_pt;    /** @brief CRS_ISR pointer register pointer type. */
    typedef RW_ uint32_t* CRS_ICR_pt;    /** @brief CRS_ICR pointer register pointer type. */

    /**** @subsection CRS Field Mask Definitions ****/

    static const uint32_t CRS_CR_TRIM_MASK      = 0x00003F00U;   /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
    static const uint32_t CRS_CFGR_SYNCPOL_MASK = 0x80000000U;   /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
    static const uint32_t CRS_ISR_FECAP_MASK    = 0xFFFF0000U;   /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
    static const uint32_t CRS_ICR_ESYNCC_MASK   = 0x00000008U;   /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

    /**********************************************************************************************
     * @section DAC Register Definitions
     **********************************************************************************************/

    /**** @subsection DAC Register Pointer Definitions ****/

    static RW_ uint32_t* const DAC_CR_PTR      = (RW_ uint32_t*)0x40007400U;   /** @brief DAC control register */
    static RW_ uint32_t* const DAC_SWTRGR_PTR  = (RW_ uint32_t*)0x40007404U;   /** @brief DAC software trigger register */
    static RW_ uint32_t* const DAC_DHR12LD_PTR = (RW_ uint32_t*)0x40007424U;   /** @brief DUAL DAC 12-bit left aligned data holding register */
    static RW_ uint32_t* const DAC_SR_PTR      = (RW_ uint32_t*)0x40007434U;   /** @brief DAC status register */
    static RW_ uint32_t* const DAC_CCR_PTR     = (RW_ uint32_t*)0x40007438U;   /** @brief DAC calibration control register */
    static RW_ uint32_t* const DAC_MCR_PTR     = (RW_ uint32_t*)0x4000743CU;   /** @brief DAC mode control register */
    static RW_ uint32_t* const DAC_SHHR_PTR    = (RW_ uint32_t*)0x40007448U;   /** @brief DAC sample and hold hold time register */
    static RW_ uint32_t* const DAC_SHRR_PTR    = (RW_ uint32_t*)0x4000744CU;   /** @brief DAC sample and hold refresh time register */

    static RW_ uint32_t* const DAC_DHR12Rx_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40007410U,   /** @brief DAC channel1 8-bit right aligned data holding register */
      [2] = (RW_ uint32_t*)0x40007414U,   /** @brief DAC channel2 12-bit right aligned data holding register */
      [1] = (RW_ uint32_t*)0x40007408U   /** @brief DAC channel1 12-bit right-aligned data holding register */
    };

    static RW_ uint32_t* const DAC_DHR12Lx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40007418U,   /** @brief DAC channel2 12-bit left aligned data holding register */
      [1] = (RW_ uint32_t*)0x4000740CU   /** @brief DAC channel1 12-bit left aligned data holding register */
    };

    static RW_ uint32_t* const DAC_DHRxR2_PTR[13] = {
      [1]  = (RW_ uint32_t*)0x40007410U,   /** @brief DAC channel1 8-bit right aligned data holding register */
      [12] = (RW_ uint32_t*)0x40007414U,   /** @brief DAC channel2 12-bit right aligned data holding register */
      [8]  = (RW_ uint32_t*)0x4000741CU   /** @brief DAC channel2 8-bit right-aligned data holding register */
    };

    static RW_ uint32_t* const DAC_DHRxRD_PTR[13] = {
      [8]  = (RW_ uint32_t*)0x40007428U,   /** @brief DUAL DAC 8-bit right aligned data holding register */
      [12] = (RW_ uint32_t*)0x40007420U   /** @brief Dual DAC 12-bit right-aligned data holding register */
    };

    static RO_ uint32_t* const DAC_DORx_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40007430U,   /** @brief DAC channel2 data output register */
      [1] = (RO_ uint32_t*)0x4000742CU   /** @brief DAC channel1 data output register */
    };

    static RW_ uint32_t* const DAC_SHSRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40007444U,   /** @brief DAC sample and hold sample time register 2 */
      [1] = (RW_ uint32_t*)0x40007440U   /** @brief DAC sample and hold sample time register 1 */
    };

    /**** @subsection DAC Register Reset Value Definitions ****/

    static const uint32_t DAC_CR_RST      = 0x00000000U;   /** @brief DAC control register */
    static const uint32_t DAC_SWTRGR_RST  = 0x00000000U;   /** @brief DAC software trigger register */
    static const uint32_t DAC_DHR12LD_RST = 0x00000000U;   /** @brief DUAL DAC 12-bit left aligned data holding register */
    static const uint32_t DAC_SR_RST      = 0x00000000U;   /** @brief DAC status register */
    static const uint32_t DAC_CCR_RST     = 0x00000000U;   /** @brief DAC calibration control register */
    static const uint32_t DAC_MCR_RST     = 0x00000000U;   /** @brief DAC mode control register */
    static const uint32_t DAC_SHHR_RST    = 0x00010001U;   /** @brief DAC sample and hold hold time register */
    static const uint32_t DAC_SHRR_RST    = 0x00010001U;   /** @brief DAC sample and hold refresh time register */

    static const uint32_t DAC_DHR12Rx_RST[9] = {
      [8] = 0x00000000U,   /** @brief DAC channel1 8-bit right aligned data holding register */
      [2] = 0x00000000U,   /** @brief DAC channel2 12-bit right aligned data holding register */
      [1] = 0x00000000U   /** @brief DAC channel1 12-bit right-aligned data holding register */
    };

    static const uint32_t DAC_DHR12Lx_RST[3] = {
      [2] = 0x00000000U,   /** @brief DAC channel2 12-bit left aligned data holding register */
      [1] = 0x00000000U   /** @brief DAC channel1 12-bit left aligned data holding register */
    };

    static const uint32_t DAC_DHRxR2_RST[13] = {
      [1]  = 0x00000000U,   /** @brief DAC channel1 8-bit right aligned data holding register */
      [12] = 0x00000000U,   /** @brief DAC channel2 12-bit right aligned data holding register */
      [8]  = 0x00000000U   /** @brief DAC channel2 8-bit right-aligned data holding register */
    };

    static const uint32_t DAC_DHRxRD_RST[13] = {
      [8]  = 0x00000000U,   /** @brief DUAL DAC 8-bit right aligned data holding register */
      [12] = 0x00000000U   /** @brief Dual DAC 12-bit right-aligned data holding register */
    };

    static const uint32_t DAC_DORx_RST[3] = {
      [2] = 0x00000000U,   /** @brief DAC channel2 data output register */
      [1] = 0x00000000U   /** @brief DAC channel1 data output register */
    };

    static const uint32_t DAC_SHSRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief DAC sample and hold sample time register 2 */
      [1] = 0x00000000U   /** @brief DAC sample and hold sample time register 1 */
    };

    /**** @subsection DAC Register Value Type Definitions ****/

    typedef uint32_t DAC_CR_vt;        /** @brief DAC_CR register value type. */
    typedef uint32_t DAC_SWTRGR_vt;    /** @brief DAC_SWTRGR register value type. */
    typedef uint32_t DAC_DHR12Rx_vt;   /** @brief DAC_DHR12Rx register value type. */
    typedef uint32_t DAC_DHR12Lx_vt;   /** @brief DAC_DHR12Lx register value type. */
    typedef uint32_t DAC_DHRxR2_vt;    /** @brief DAC_DHRxR2 register value type. */
    typedef uint32_t DAC_DHRxRD_vt;    /** @brief DAC_DHRxRD register value type. */
    typedef uint32_t DAC_DHR12LD_vt;   /** @brief DAC_DHR12LD register value type. */
    typedef uint32_t DAC_DORx_vt;      /** @brief DAC_DORx register value type. */
    typedef uint32_t DAC_SR_vt;        /** @brief DAC_SR register value type. */
    typedef uint32_t DAC_CCR_vt;       /** @brief DAC_CCR register value type. */
    typedef uint32_t DAC_MCR_vt;       /** @brief DAC_MCR register value type. */
    typedef uint32_t DAC_SHSRx_vt;     /** @brief DAC_SHSRx register value type. */
    typedef uint32_t DAC_SHHR_vt;      /** @brief DAC_SHHR register value type. */
    typedef uint32_t DAC_SHRR_vt;      /** @brief DAC_SHRR register value type. */

    /**** @subsection DAC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* DAC_CR_pt;        /** @brief DAC_CR pointer register pointer type. */
    typedef RW_ uint32_t* DAC_SWTRGR_pt;    /** @brief DAC_SWTRGR pointer register pointer type. */
    typedef RW_ uint32_t* DAC_DHR12Rx_pt;   /** @brief DAC_DHR12Rx pointer register pointer type. */
    typedef RW_ uint32_t* DAC_DHR12Lx_pt;   /** @brief DAC_DHR12Lx pointer register pointer type. */
    typedef RW_ uint32_t* DAC_DHRxR2_pt;    /** @brief DAC_DHRxR2 pointer register pointer type. */
    typedef RW_ uint32_t* DAC_DHRxRD_pt;    /** @brief DAC_DHRxRD pointer register pointer type. */
    typedef RW_ uint32_t* DAC_DHR12LD_pt;   /** @brief DAC_DHR12LD pointer register pointer type. */
    typedef RO_ uint32_t* DAC_DORx_pt;      /** @brief DAC_DORx pointer register pointer type. */
    typedef RW_ uint32_t* DAC_SR_pt;        /** @brief DAC_SR pointer register pointer type. */
    typedef RW_ uint32_t* DAC_CCR_pt;       /** @brief DAC_CCR pointer register pointer type. */
    typedef RW_ uint32_t* DAC_MCR_pt;       /** @brief DAC_MCR pointer register pointer type. */
    typedef RW_ uint32_t* DAC_SHSRx_pt;     /** @brief DAC_SHSRx pointer register pointer type. */
    typedef RW_ uint32_t* DAC_SHHR_pt;      /** @brief DAC_SHHR pointer register pointer type. */
    typedef RW_ uint32_t* DAC_SHRR_pt;      /** @brief DAC_SHRR pointer register pointer type. */

    /**** @subsection DAC Field Mask Definitions ****/

    static const uint32_t DAC_CR_CENx_MASK[3] = {
      [2] = 0x40000000U,   /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
      [1] = 0x00004000U   /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    };

    static const uint32_t DAC_SWTRGR_SWTRIGx_MASK[3] = {
      [2] = 0x00000002U,   /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
      [1] = 0x00000001U   /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
    };

    static const uint32_t DAC_DHR12Rx_DACCxDHR_MASK[9] = {
      [8] = 0x000000FFU,   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
      [2] = 0x00000FFFU,   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
      [1] = 0x00000FFFU   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    };

    static const uint32_t DAC_DHR12Lx_DACCxDHR_MASK[3] = {
      [2] = 0x0000FFF0U,   /** @brief DAC channel2 12-bit left-aligned data these bits are written by software which specify 12-bit data for DAC channel2. */
      [1] = 0x0000FFF0U   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    };

    static const uint32_t DAC_DHRxR2_DACCxDHR_MASK[13] = {
      [1]  = 0x000000FFU,   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
      [12] = 0x00000FFFU,   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
      [8]  = 0x000000FFU   /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
    };

    static const uint32_t DAC_DHR12LD_DACCxDHR_MASK[3] = {
      [2] = 0xFFF00000U,   /** @brief DAC channel2 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
      [1] = 0x0000FFF0U   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    };

    static const uint32_t DAC_DORx_DACCxDOR_MASK[3] = {
      [2] = 0x00000FFFU,   /** @brief DAC channel2 data output these bits are read-only, they contain data output for DAC channel2. */
      [1] = 0x00000FFFU   /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
    };

    static const uint32_t DAC_SR_BWSTx_MASK[3] = {
      [2] = 0x80000000U,   /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
      [1] = 0x00008000U   /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
    };

    static const uint32_t DAC_CCR_OTRIMx_MASK[3] = {
      [2] = 0x001F0000U,   /** @brief DAC channel 2 offset trimming value */
      [1] = 0x0000001FU   /** @brief DAC channel 1 offset trimming value */
    };

    static const uint32_t DAC_MCR_MODEx_MASK[3] = {
      [2] = 0x00070000U,   /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode */
      [1] = 0x00000007U   /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode */
    };

    static const uint32_t DAC_SHSRx_TSAMPLEx_MASK[3] = {
      [2] = 0x000003FFU,   /** @brief DAC channel 2 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel2 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */
      [1] = 0x000003FFU   /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */
    };

    static const uint32_t DAC_SHHR_THOLDx_MASK[3] = {
      [2] = 0x03FF0000U,   /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI */
      [1] = 0x000003FFU   /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI */
    };

    static const uint32_t DAC_SHRR_TREFRESHx_MASK[3] = {
      [2] = 0x00FF0000U,   /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
      [1] = 0x000000FFU   /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
    };

    static const uint32_t DAC_DHRxRD_DACCxDHR_MASK[13][3] = {
      [8] = {
        [2] = 0x0000FF00U,   /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
        [1] = 0x000000FFU   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
      },
      [12] = {
        [2] = 0x0FFF0000U,   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
        [1] = 0x00000FFFU   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
      }
    };

    /**********************************************************************************************
     * @section BDMA Register Definitions
     **********************************************************************************************/

    /**** @subsection BDMA Register Pointer Definitions ****/

    static RO_ uint32_t* const BDMA_ISR_PTR  = (RO_ uint32_t*)0x58025400U;   /** @brief DMA interrupt status register */
    static RW_ uint32_t* const BDMA_IFCR_PTR = (RW_ uint32_t*)0x58025404U;   /** @brief DMA interrupt flag clear register */

    static RW_ uint32_t* const BDMA_CCRx_PTR[9] = {
      [2] = (RW_ uint32_t*)0x5802541CU,   /** @brief DMA channel x configuration register */
      [3] = (RW_ uint32_t*)0x58025430U,   /** @brief DMA channel x configuration register */
      [4] = (RW_ uint32_t*)0x58025444U,   /** @brief DMA channel x configuration register */
      [5] = (RW_ uint32_t*)0x58025458U,   /** @brief DMA channel x configuration register */
      [6] = (RW_ uint32_t*)0x5802546CU,   /** @brief DMA channel x configuration register */
      [7] = (RW_ uint32_t*)0x58025480U,   /** @brief DMA channel x configuration register */
      [8] = (RW_ uint32_t*)0x58025494U,   /** @brief DMA channel x configuration register */
      [1] = (RW_ uint32_t*)0x58025408U   /** @brief DMA channel x configuration register */
    };

    static RW_ uint32_t* const BDMA_CNDTRx_PTR[9] = {
      [2] = (RW_ uint32_t*)0x58025420U,   /** @brief DMA channel x number of data register */
      [3] = (RW_ uint32_t*)0x58025434U,   /** @brief DMA channel x number of data register */
      [4] = (RW_ uint32_t*)0x58025448U,   /** @brief DMA channel x number of data register */
      [5] = (RW_ uint32_t*)0x5802545CU,   /** @brief DMA channel x number of data register */
      [6] = (RW_ uint32_t*)0x58025470U,   /** @brief DMA channel x number of data register */
      [7] = (RW_ uint32_t*)0x58025484U,   /** @brief DMA channel x number of data register */
      [8] = (RW_ uint32_t*)0x58025498U,   /** @brief DMA channel x number of data register */
      [1] = (RW_ uint32_t*)0x5802540CU   /** @brief DMA channel x number of data register */
    };

    static RW_ uint32_t* const BDMA_CPARx_PTR[9] = {
      [2] = (RW_ uint32_t*)0x58025424U,   /** @brief This register must not be written when the channel is enabled. */
      [3] = (RW_ uint32_t*)0x58025438U,   /** @brief This register must not be written when the channel is enabled. */
      [4] = (RW_ uint32_t*)0x5802544CU,   /** @brief This register must not be written when the channel is enabled. */
      [5] = (RW_ uint32_t*)0x58025460U,   /** @brief This register must not be written when the channel is enabled. */
      [6] = (RW_ uint32_t*)0x58025474U,   /** @brief This register must not be written when the channel is enabled. */
      [7] = (RW_ uint32_t*)0x58025488U,   /** @brief This register must not be written when the channel is enabled. */
      [8] = (RW_ uint32_t*)0x5802549CU,   /** @brief This register must not be written when the channel is enabled. */
      [1] = (RW_ uint32_t*)0x58025410U   /** @brief This register must not be written when the channel is enabled. */
    };

    static RW_ uint32_t* const BDMA_CMARx_PTR[9] = {
      [2] = (RW_ uint32_t*)0x58025428U,   /** @brief This register must not be written when the channel is enabled. */
      [3] = (RW_ uint32_t*)0x5802543CU,   /** @brief This register must not be written when the channel is enabled. */
      [4] = (RW_ uint32_t*)0x58025450U,   /** @brief This register must not be written when the channel is enabled. */
      [5] = (RW_ uint32_t*)0x58025464U,   /** @brief This register must not be written when the channel is enabled. */
      [6] = (RW_ uint32_t*)0x58025478U,   /** @brief This register must not be written when the channel is enabled. */
      [7] = (RW_ uint32_t*)0x5802548CU,   /** @brief This register must not be written when the channel is enabled. */
      [8] = (RW_ uint32_t*)0x580254A0U,   /** @brief This register must not be written when the channel is enabled. */
      [1] = (RW_ uint32_t*)0x58025414U   /** @brief This register must not be written when the channel is enabled. */
    };

    /**** @subsection BDMA Register Reset Value Definitions ****/

    static const uint32_t BDMA_ISR_RST  = 0x00000000U;   /** @brief DMA interrupt status register */
    static const uint32_t BDMA_IFCR_RST = 0x00000000U;   /** @brief DMA interrupt flag clear register */

    static const uint32_t BDMA_CCRx_RST[9] = {
      [2] = 0x00000000U,   /** @brief DMA channel x configuration register */
      [3] = 0x00000000U,   /** @brief DMA channel x configuration register */
      [4] = 0x00000000U,   /** @brief DMA channel x configuration register */
      [5] = 0x00000000U,   /** @brief DMA channel x configuration register */
      [6] = 0x00000000U,   /** @brief DMA channel x configuration register */
      [7] = 0x00000000U,   /** @brief DMA channel x configuration register */
      [8] = 0x00000000U,   /** @brief DMA channel x configuration register */
      [1] = 0x00000000U   /** @brief DMA channel x configuration register */
    };

    static const uint32_t BDMA_CNDTRx_RST[9] = {
      [2] = 0x00000000U,   /** @brief DMA channel x number of data register */
      [3] = 0x00000000U,   /** @brief DMA channel x number of data register */
      [4] = 0x00000000U,   /** @brief DMA channel x number of data register */
      [5] = 0x00000000U,   /** @brief DMA channel x number of data register */
      [6] = 0x00000000U,   /** @brief DMA channel x number of data register */
      [7] = 0x00000000U,   /** @brief DMA channel x number of data register */
      [8] = 0x00000000U,   /** @brief DMA channel x number of data register */
      [1] = 0x00000000U   /** @brief DMA channel x number of data register */
    };

    static const uint32_t BDMA_CPARx_RST[9] = {
      [2] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [3] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [4] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [5] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [6] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [7] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [8] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [1] = 0x00000000U   /** @brief This register must not be written when the channel is enabled. */
    };

    static const uint32_t BDMA_CMARx_RST[9] = {
      [2] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [3] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [4] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [5] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [6] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [7] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [8] = 0x00000000U,   /** @brief This register must not be written when the channel is enabled. */
      [1] = 0x00000000U   /** @brief This register must not be written when the channel is enabled. */
    };

    /**** @subsection BDMA Register Value Type Definitions ****/

    typedef uint32_t BDMA_ISR_vt;      /** @brief BDMA_ISR register value type. */
    typedef uint32_t BDMA_IFCR_vt;     /** @brief BDMA_IFCR register value type. */
    typedef uint32_t BDMA_CCRx_vt;     /** @brief BDMA_CCRx register value type. */
    typedef uint32_t BDMA_CNDTRx_vt;   /** @brief BDMA_CNDTRx register value type. */
    typedef uint32_t BDMA_CPARx_vt;    /** @brief BDMA_CPARx register value type. */
    typedef uint32_t BDMA_CMARx_vt;    /** @brief BDMA_CMARx register value type. */

    /**** @subsection BDMA Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* BDMA_ISR_pt;      /** @brief BDMA_ISR pointer register pointer type. */
    typedef RW_ uint32_t* BDMA_IFCR_pt;     /** @brief BDMA_IFCR pointer register pointer type. */
    typedef RW_ uint32_t* BDMA_CCRx_pt;     /** @brief BDMA_CCRx pointer register pointer type. */
    typedef RW_ uint32_t* BDMA_CNDTRx_pt;   /** @brief BDMA_CNDTRx pointer register pointer type. */
    typedef RW_ uint32_t* BDMA_CPARx_pt;    /** @brief BDMA_CPARx pointer register pointer type. */
    typedef RW_ uint32_t* BDMA_CMARx_pt;    /** @brief BDMA_CMARx pointer register pointer type. */

    /**** @subsection BDMA Field Mask Definitions ****/

    static const uint32_t BDMA_ISR_TEIFx_MASK[9] = {
      [2] = 0x00000080U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [3] = 0x00000800U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [4] = 0x00008000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [5] = 0x00080000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [6] = 0x00800000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [7] = 0x08000000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [8] = 0x80000000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
      [1] = 0x00000008U   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    };

    static const uint32_t BDMA_IFCR_CTEIFx_MASK[9] = {
      [2] = 0x00000080U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [3] = 0x00000800U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [4] = 0x00008000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [5] = 0x00080000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [6] = 0x00800000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [7] = 0x08000000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [8] = 0x80000000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
      [1] = 0x00000008U   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_CCRx_MEM2MEM_MASK[9] = {
      [2] = 0x00004000U,   /** @brief Memory to memory mode this bit is set and cleared by software. */
      [3] = 0x00004000U,   /** @brief Memory to memory mode this bit is set and cleared by software. */
      [4] = 0x00004000U,   /** @brief Memory to memory mode this bit is set and cleared by software. */
      [5] = 0x00004000U,   /** @brief Memory to memory mode this bit is set and cleared by software. */
      [6] = 0x00004000U,   /** @brief Memory to memory mode this bit is set and cleared by software. */
      [7] = 0x00004000U,   /** @brief Memory to memory mode this bit is set and cleared by software. */
      [8] = 0x00004000U,   /** @brief Memory to memory mode this bit is set and cleared by software. */
      [1] = 0x00004000U   /** @brief Memory to memory mode this bit is set and cleared by software. */
    };

    static const uint32_t BDMA_CNDTRx_NDT_MASK[9] = {
      [2] = 0x0000FFFFU,   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
      [3] = 0x0000FFFFU,   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
      [4] = 0x0000FFFFU,   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
      [5] = 0x0000FFFFU,   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
      [6] = 0x0000FFFFU,   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
      [7] = 0x0000FFFFU,   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
      [8] = 0x0000FFFFU,   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
      [1] = 0x0000FFFFU   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */
    };

    static const uint32_t BDMA_CPARx_PA_MASK[9] = {
      [2] = 0xFFFFFFFFU,   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
      [3] = 0xFFFFFFFFU,   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
      [4] = 0xFFFFFFFFU,   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
      [5] = 0xFFFFFFFFU,   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
      [6] = 0xFFFFFFFFU,   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
      [7] = 0xFFFFFFFFU,   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
      [8] = 0xFFFFFFFFU,   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
      [1] = 0xFFFFFFFFU   /** @brief Peripheral address base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address. */
    };

    static const uint32_t BDMA_CMARx_MA_MASK[9] = {
      [2] = 0xFFFFFFFFU,   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
      [3] = 0xFFFFFFFFU,   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
      [4] = 0xFFFFFFFFU,   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
      [5] = 0xFFFFFFFFU,   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
      [6] = 0xFFFFFFFFU,   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
      [7] = 0xFFFFFFFFU,   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
      [8] = 0xFFFFFFFFU,   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
      [1] = 0xFFFFFFFFU   /** @brief Memory address base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address. */
    };

    /**********************************************************************************************
     * @section DMA2D Register Definitions
     **********************************************************************************************/

    /**** @subsection DMA2D Register Pointer Definitions ****/

    static RW_ uint32_t* const DMA2D_CR_PTR      = (RW_ uint32_t*)0x52001000U;   /** @brief DMA2D control register */
    static RO_ uint32_t* const DMA2D_ISR_PTR     = (RO_ uint32_t*)0x52001004U;   /** @brief DMA2D interrupt status register */
    static RW_ uint32_t* const DMA2D_IFCR_PTR    = (RW_ uint32_t*)0x52001008U;   /** @brief DMA2D interrupt flag clear register */
    static RW_ uint32_t* const DMA2D_FGMAR_PTR   = (RW_ uint32_t*)0x5200100CU;   /** @brief DMA2D foreground memory address register */
    static RW_ uint32_t* const DMA2D_FGOR_PTR    = (RW_ uint32_t*)0x52001010U;   /** @brief DMA2D foreground offset register */
    static RW_ uint32_t* const DMA2D_BGMAR_PTR   = (RW_ uint32_t*)0x52001014U;   /** @brief DMA2D background memory address register */
    static RW_ uint32_t* const DMA2D_BGOR_PTR    = (RW_ uint32_t*)0x52001018U;   /** @brief DMA2D background offset register */
    static RW_ uint32_t* const DMA2D_FGPFCCR_PTR = (RW_ uint32_t*)0x5200101CU;   /** @brief DMA2D foreground PFC control register */
    static RW_ uint32_t* const DMA2D_FGCOLR_PTR  = (RW_ uint32_t*)0x52001020U;   /** @brief DMA2D foreground color register */
    static RW_ uint32_t* const DMA2D_BGPFCCR_PTR = (RW_ uint32_t*)0x52001024U;   /** @brief DMA2D background PFC control register */
    static RW_ uint32_t* const DMA2D_BGCOLR_PTR  = (RW_ uint32_t*)0x52001028U;   /** @brief DMA2D background color register */
    static RW_ uint32_t* const DMA2D_FGCMAR_PTR  = (RW_ uint32_t*)0x5200102CU;   /** @brief DMA2D foreground CLUT memory address register */
    static RW_ uint32_t* const DMA2D_BGCMAR_PTR  = (RW_ uint32_t*)0x52001030U;   /** @brief DMA2D background CLUT memory address register */
    static RW_ uint32_t* const DMA2D_OPFCCR_PTR  = (RW_ uint32_t*)0x52001034U;   /** @brief DMA2D output PFC control register */
    static RW_ uint32_t* const DMA2D_OCOLR_PTR   = (RW_ uint32_t*)0x52001038U;   /** @brief DMA2D output color register */
    static RW_ uint32_t* const DMA2D_OMAR_PTR    = (RW_ uint32_t*)0x5200103CU;   /** @brief DMA2D output memory address register */
    static RW_ uint32_t* const DMA2D_OOR_PTR     = (RW_ uint32_t*)0x52001040U;   /** @brief DMA2D output offset register */
    static RW_ uint32_t* const DMA2D_NLR_PTR     = (RW_ uint32_t*)0x52001044U;   /** @brief DMA2D number of line register */
    static RW_ uint32_t* const DMA2D_LWR_PTR     = (RW_ uint32_t*)0x52001048U;   /** @brief DMA2D line watermark register */
    static RW_ uint32_t* const DMA2D_AMTCR_PTR   = (RW_ uint32_t*)0x5200104CU;   /** @brief DMA2D AXI master timer configuration register */

    /**** @subsection DMA2D Register Reset Value Definitions ****/

    static const uint32_t DMA2D_CR_RST      = 0x00000000U;   /** @brief DMA2D control register */
    static const uint32_t DMA2D_ISR_RST     = 0x00000000U;   /** @brief DMA2D interrupt status register */
    static const uint32_t DMA2D_IFCR_RST    = 0x00000000U;   /** @brief DMA2D interrupt flag clear register */
    static const uint32_t DMA2D_FGMAR_RST   = 0x00000000U;   /** @brief DMA2D foreground memory address register */
    static const uint32_t DMA2D_FGOR_RST    = 0x00000000U;   /** @brief DMA2D foreground offset register */
    static const uint32_t DMA2D_BGMAR_RST   = 0x00000000U;   /** @brief DMA2D background memory address register */
    static const uint32_t DMA2D_BGOR_RST    = 0x00000000U;   /** @brief DMA2D background offset register */
    static const uint32_t DMA2D_FGPFCCR_RST = 0x00000000U;   /** @brief DMA2D foreground PFC control register */
    static const uint32_t DMA2D_FGCOLR_RST  = 0x00000000U;   /** @brief DMA2D foreground color register */
    static const uint32_t DMA2D_BGPFCCR_RST = 0x00000000U;   /** @brief DMA2D background PFC control register */
    static const uint32_t DMA2D_BGCOLR_RST  = 0x00000000U;   /** @brief DMA2D background color register */
    static const uint32_t DMA2D_FGCMAR_RST  = 0x00000000U;   /** @brief DMA2D foreground CLUT memory address register */
    static const uint32_t DMA2D_BGCMAR_RST  = 0x00000000U;   /** @brief DMA2D background CLUT memory address register */
    static const uint32_t DMA2D_OPFCCR_RST  = 0x00000000U;   /** @brief DMA2D output PFC control register */
    static const uint32_t DMA2D_OCOLR_RST   = 0x00000000U;   /** @brief DMA2D output color register */
    static const uint32_t DMA2D_OMAR_RST    = 0x00000000U;   /** @brief DMA2D output memory address register */
    static const uint32_t DMA2D_OOR_RST     = 0x00000000U;   /** @brief DMA2D output offset register */
    static const uint32_t DMA2D_NLR_RST     = 0x00000000U;   /** @brief DMA2D number of line register */
    static const uint32_t DMA2D_LWR_RST     = 0x00000000U;   /** @brief DMA2D line watermark register */
    static const uint32_t DMA2D_AMTCR_RST   = 0x00000000U;   /** @brief DMA2D AXI master timer configuration register */

    /**** @subsection DMA2D Register Value Type Definitions ****/

    typedef uint32_t DMA2D_CR_vt;        /** @brief DMA2D_CR register value type. */
    typedef uint32_t DMA2D_ISR_vt;       /** @brief DMA2D_ISR register value type. */
    typedef uint32_t DMA2D_IFCR_vt;      /** @brief DMA2D_IFCR register value type. */
    typedef uint32_t DMA2D_FGMAR_vt;     /** @brief DMA2D_FGMAR register value type. */
    typedef uint32_t DMA2D_FGOR_vt;      /** @brief DMA2D_FGOR register value type. */
    typedef uint32_t DMA2D_BGMAR_vt;     /** @brief DMA2D_BGMAR register value type. */
    typedef uint32_t DMA2D_BGOR_vt;      /** @brief DMA2D_BGOR register value type. */
    typedef uint32_t DMA2D_FGPFCCR_vt;   /** @brief DMA2D_FGPFCCR register value type. */
    typedef uint32_t DMA2D_FGCOLR_vt;    /** @brief DMA2D_FGCOLR register value type. */
    typedef uint32_t DMA2D_BGPFCCR_vt;   /** @brief DMA2D_BGPFCCR register value type. */
    typedef uint32_t DMA2D_BGCOLR_vt;    /** @brief DMA2D_BGCOLR register value type. */
    typedef uint32_t DMA2D_FGCMAR_vt;    /** @brief DMA2D_FGCMAR register value type. */
    typedef uint32_t DMA2D_BGCMAR_vt;    /** @brief DMA2D_BGCMAR register value type. */
    typedef uint32_t DMA2D_OPFCCR_vt;    /** @brief DMA2D_OPFCCR register value type. */
    typedef uint32_t DMA2D_OCOLR_vt;     /** @brief DMA2D_OCOLR register value type. */
    typedef uint32_t DMA2D_OMAR_vt;      /** @brief DMA2D_OMAR register value type. */
    typedef uint32_t DMA2D_OOR_vt;       /** @brief DMA2D_OOR register value type. */
    typedef uint32_t DMA2D_NLR_vt;       /** @brief DMA2D_NLR register value type. */
    typedef uint32_t DMA2D_LWR_vt;       /** @brief DMA2D_LWR register value type. */
    typedef uint32_t DMA2D_AMTCR_vt;     /** @brief DMA2D_AMTCR register value type. */

    /**** @subsection DMA2D Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* DMA2D_CR_pt;        /** @brief DMA2D_CR pointer register pointer type. */
    typedef RO_ uint32_t* DMA2D_ISR_pt;       /** @brief DMA2D_ISR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_IFCR_pt;      /** @brief DMA2D_IFCR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_FGMAR_pt;     /** @brief DMA2D_FGMAR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_FGOR_pt;      /** @brief DMA2D_FGOR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_BGMAR_pt;     /** @brief DMA2D_BGMAR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_BGOR_pt;      /** @brief DMA2D_BGOR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_FGPFCCR_pt;   /** @brief DMA2D_FGPFCCR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_FGCOLR_pt;    /** @brief DMA2D_FGCOLR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_BGPFCCR_pt;   /** @brief DMA2D_BGPFCCR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_BGCOLR_pt;    /** @brief DMA2D_BGCOLR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_FGCMAR_pt;    /** @brief DMA2D_FGCMAR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_BGCMAR_pt;    /** @brief DMA2D_BGCMAR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_OPFCCR_pt;    /** @brief DMA2D_OPFCCR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_OCOLR_pt;     /** @brief DMA2D_OCOLR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_OMAR_pt;      /** @brief DMA2D_OMAR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_OOR_pt;       /** @brief DMA2D_OOR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_NLR_pt;       /** @brief DMA2D_NLR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_LWR_pt;       /** @brief DMA2D_LWR pointer register pointer type. */
    typedef RW_ uint32_t* DMA2D_AMTCR_pt;     /** @brief DMA2D_AMTCR pointer register pointer type. */

    /**** @subsection DMA2D Field Mask Definitions ****/

    static const uint32_t DMA2D_CR_MODE_MASK       = 0x00030000U;   /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
    static const uint32_t DMA2D_ISR_CEIF_MASK      = 0x00000020U;   /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
    static const uint32_t DMA2D_IFCR_CCEIF_MASK    = 0x00000020U;   /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register */
    static const uint32_t DMA2D_FGMAR_MA_MASK      = 0xFFFFFFFFU;   /** @brief Memory address address of the data used for the foreground image. This register can only be written when data transfers are disabled. Once the data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. A 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned. */
    static const uint32_t DMA2D_FGOR_LO_MASK       = 0x00003FFFU;   /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const uint32_t DMA2D_BGMAR_MA_MASK      = 0xFFFFFFFFU;   /** @brief Memory address address of the data used for the background image. This register can only be written when data transfers are disabled. Once a data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. A 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned. */
    static const uint32_t DMA2D_BGOR_LO_MASK       = 0x00003FFFU;   /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
    static const uint32_t DMA2D_FGPFCCR_ALPHA_MASK = 0xFF000000U;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
    static const uint32_t DMA2D_FGCOLR_RED_MASK    = 0x00FF0000U;   /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGPFCCR_ALPHA_MASK = 0xFF000000U;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_BGCOLR_RED_MASK    = 0x00FF0000U;   /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_FGCMAR_MA_MASK     = 0xFFFFFFFFU;   /** @brief Memory address address of the data used for the CLUT address dedicated to the foreground image. This register can only be written when no transfer is ongoing. Once the CLUT transfer has started, this register is read-only. If the foreground CLUT format is 32-bit, the address must be 32-bit aligned. */
    static const uint32_t DMA2D_BGCMAR_MA_MASK     = 0xFFFFFFFFU;   /** @brief Memory address address of the data used for the CLUT address dedicated to the background image. This register can only be written when no transfer is on going. Once the CLUT transfer has started, this register is read-only. If the background CLUT format is 32-bit, the address must be 32-bit aligned. */
    static const uint32_t DMA2D_OPFCCR_RBS_MASK    = 0x00200000U;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
    static const uint32_t DMA2D_OCOLR_ALPHA_MASK   = 0xFF000000U;   /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_OMAR_MA_MASK       = 0xFFFFFFFFU;   /** @brief Memory address address of the data used for the output FIFO. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. The address alignment must match the image format selected e.g. A 32-bit per pixel format must be 32-bit aligned and a 16-bit per pixel format must be 16-bit aligned. */
    static const uint32_t DMA2D_OOR_LO_MASK        = 0x00003FFFU;   /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_NLR_PL_MASK        = 0x3FFF0000U;   /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
    static const uint32_t DMA2D_LWR_LW_MASK        = 0x0000FFFFU;   /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
    static const uint32_t DMA2D_AMTCR_DT_MASK      = 0x0000FF00U;   /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

    /**********************************************************************************************
     * @section DMAMUX Register Definitions
     **********************************************************************************************/

    /**** @subsection DMAMUX Register Pointer Definitions ****/

    static RO_ uint32_t* const DMAMUXx_RGSR_PTR[3] = {
      [1] = (RO_ uint32_t*)0x40020940U,   /** @brief DMAMux - DMA request generator status register */
      [2] = (RO_ uint32_t*)0x58025940U   /** @brief DMAMux - DMA request generator status register */
    };

    static RW_ uint32_t* const DMAMUXx_RGCFR_PTR[3] = {
      [1] = (RW_ uint32_t*)0x40020944U,   /** @brief DMAMux - DMA request generator clear flag register */
      [2] = (RW_ uint32_t*)0x58025944U   /** @brief DMAMux - DMA request generator clear flag register */
    };

    static RO_ uint32_t* const DMAMUXx_CSR_PTR[3] = {
      [1] = (RO_ uint32_t*)0x40020880U,   /** @brief DMAMUX request line multiplexer interrupt channel status register */
      [2] = (RO_ uint32_t*)0x58025880U   /** @brief DMAMUX request line multiplexer interrupt channel status register */
    };

    static RW_ uint32_t* const DMAMUXx_CFR_PTR[3] = {
      [1] = (RW_ uint32_t*)0x40020884U,   /** @brief DMAMUX request line multiplexer interrupt clear flag register */
      [2] = (RW_ uint32_t*)0x58025884U   /** @brief DMAMUX request line multiplexer interrupt clear flag register */
    };

    /**** @subsection DMAMUX Register Reset Value Definitions ****/

    static const uint32_t DMAMUXx_RGSR_RST[3] = {
      [1] = 0x00000000U,   /** @brief DMAMux - DMA request generator status register */
      [2] = 0x00000000U   /** @brief DMAMux - DMA request generator status register */
    };

    static const uint32_t DMAMUXx_RGCFR_RST[3] = {
      [1] = 0x00000000U,   /** @brief DMAMux - DMA request generator clear flag register */
      [2] = 0x00000000U   /** @brief DMAMux - DMA request generator clear flag register */
    };

    static const uint32_t DMAMUXx_CSR_RST[3] = {
      [1] = 0x00000000U,   /** @brief DMAMUX request line multiplexer interrupt channel status register */
      [2] = 0x00000000U   /** @brief DMAMUX request line multiplexer interrupt channel status register */
    };

    static const uint32_t DMAMUXx_CFR_RST[3] = {
      [1] = 0x00000000U,   /** @brief DMAMUX request line multiplexer interrupt clear flag register */
      [2] = 0x00000000U   /** @brief DMAMUX request line multiplexer interrupt clear flag register */
    };

    /**** @subsection DMAMUX Register Value Type Definitions ****/

    typedef uint32_t DMAMUXx_CxCR_vt;    /** @brief DMAMUXx_CxCR register value type. */
    typedef uint32_t DMAMUXx_RGxCR_vt;   /** @brief DMAMUXx_RGxCR register value type. */
    typedef uint32_t DMAMUXx_RGSR_vt;    /** @brief DMAMUXx_RGSR register value type. */
    typedef uint32_t DMAMUXx_RGCFR_vt;   /** @brief DMAMUXx_RGCFR register value type. */
    typedef uint32_t DMAMUXx_CSR_vt;     /** @brief DMAMUXx_CSR register value type. */
    typedef uint32_t DMAMUXx_CFR_vt;     /** @brief DMAMUXx_CFR register value type. */

    /**** @subsection DMAMUX Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* DMAMUXx_CxCR_pt;    /** @brief DMAMUXx_CxCR pointer register pointer type. */
    typedef RW_ uint32_t* DMAMUXx_RGxCR_pt;   /** @brief DMAMUXx_RGxCR pointer register pointer type. */
    typedef RO_ uint32_t* DMAMUXx_RGSR_pt;    /** @brief DMAMUXx_RGSR pointer register pointer type. */
    typedef RW_ uint32_t* DMAMUXx_RGCFR_pt;   /** @brief DMAMUXx_RGCFR pointer register pointer type. */
    typedef RO_ uint32_t* DMAMUXx_CSR_pt;     /** @brief DMAMUXx_CSR pointer register pointer type. */
    typedef RW_ uint32_t* DMAMUXx_CFR_pt;     /** @brief DMAMUXx_CFR pointer register pointer type. */

    /**** @subsection DMAMUX Field Mask Definitions ****/

    static const uint32_t DMAMUXx_RGSR_OF_MASK[3] = {
      [1] = 0x000000FFU,   /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
      [2] = 0x000000FFU   /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
    };

    static const uint32_t DMAMUXx_RGCFR_COF_MASK[3] = {
      [1] = 0x000000FFU,   /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
      [2] = 0x000000FFU   /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
    };

    static const uint32_t DMAMUXx_CSR_SOF_MASK[3] = {
      [1] = 0x0000FFFFU,   /** @brief Synchronization overrun event flag */
      [2] = 0x0000FFFFU   /** @brief Synchronization overrun event flag */
    };

    static const uint32_t DMAMUXx_CFR_CSOF_MASK[3] = {
      [1] = 0x0000FFFFU,   /** @brief Clear synchronization overrun event flag */
      [2] = 0x0000FFFFU   /** @brief Clear synchronization overrun event flag */
    };

    static const uint32_t DMAMUXx_CxCR_SYNC_ID_MASK[3][16] = {
      [1] = {
        [1]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [2]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [3]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [4]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [5]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [6]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [7]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [8]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [9]  = 0x1F000000U,   /** @brief Synchronization input selected */
        [10] = 0x1F000000U,   /** @brief Synchronization input selected */
        [11] = 0x1F000000U,   /** @brief Synchronization input selected */
        [12] = 0x1F000000U,   /** @brief Synchronization input selected */
        [13] = 0x1F000000U,   /** @brief Synchronization input selected */
        [14] = 0x1F000000U,   /** @brief Synchronization input selected */
        [15] = 0x1F000000U,   /** @brief Synchronization input selected */
        [0]  = 0x1F000000U   /** @brief Synchronization input selected */
      },
      [2] = {
        [1] = 0x1F000000U,   /** @brief Synchronization input selected */
        [2] = 0x1F000000U,   /** @brief Synchronization input selected */
        [3] = 0x1F000000U,   /** @brief Synchronization input selected */
        [4] = 0x1F000000U,   /** @brief Synchronization input selected */
        [5] = 0x1F000000U,   /** @brief Synchronization input selected */
        [6] = 0x1F000000U,   /** @brief Synchronization input selected */
        [7] = 0x1F000000U,   /** @brief Synchronization input selected */
        [0] = 0x1F000000U   /** @brief Synchronization input selected */
      }
    };

    static const uint32_t DMAMUXx_RGxCR_GNBREQ_MASK[3][8] = {
      [1] = {
        [1] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [2] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [3] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [4] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [5] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [6] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [7] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [0] = 0x00F80000U   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
      },
      [2] = {
        [1] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [2] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [3] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [4] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [5] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [6] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [7] = 0x00F80000U,   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
        [0] = 0x00F80000U   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
      }
    };

    /**********************************************************************************************
     * @section FMC Register Definitions
     **********************************************************************************************/

    /**** @subsection FMC Register Pointer Definitions ****/

    static RW_ uint32_t* const FMC_PCR_PTR   = (RW_ uint32_t*)0x52004080U;   /** @brief NAND flash control registers */
    static RW_ uint32_t* const FMC_SR_PTR    = (RW_ uint32_t*)0x52004084U;   /** @brief This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.this is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.the ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty. */
    static RW_ uint32_t* const FMC_PMEM_PTR  = (RW_ uint32_t*)0x52004088U;   /** @brief The FMC_PMEM read/write register contains the timing information for NAND flash memory bank. This information is used to access either the common memory space of the NAND flash for command, address write access and data read/write access. */
    static RW_ uint32_t* const FMC_PATT_PTR  = (RW_ uint32_t*)0x5200408CU;   /** @brief The FMC_PATT read/write register contains the timing information for NAND flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND flash for the last address write access if the timing must differ from that of previous accesses (for ready/busy management, refer to section20.8.5: NAND flash prewait feature). */
    static RO_ uint32_t* const FMC_ECCR_PTR  = (RO_ uint32_t*)0x52004094U;   /** @brief This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND flash memory page at the correct address (refer to section20.8.6: computation of the error correction code (ECC) in NAND flash memory), the data read/written from/to the NAND flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1. */
    static RW_ uint32_t* const FMC_SDCMR_PTR = (RW_ uint32_t*)0x52004150U;   /** @brief This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the self-refresh and the power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks. */
    static RW_ uint32_t* const FMC_SDRTR_PTR = (RW_ uint32_t*)0x52004154U;   /** @brief This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the refresh timer count value.examplewhere 64 ms is the SDRAM refresh period.the refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.as soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.if a memory access is in progress, the auto-refresh request is delayed. However, if the memory access and auto-refresh requests are generated simultaneously, the auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.this register is common to SDRAM bank 1 and bank 2. */
    static RO_ uint32_t* const FMC_SDSR_PTR  = (RO_ uint32_t*)0x52004158U;   /** @brief SDRAM status register */

    static RW_ uint32_t* const FMC_BCRx_PTR[5] = {
      [2] = (RW_ uint32_t*)0x52004008U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [3] = (RW_ uint32_t*)0x52004010U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [4] = (RW_ uint32_t*)0x52004018U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [1] = (RW_ uint32_t*)0x52004000U   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    };

    static RW_ uint32_t* const FMC_BTRx_PTR[5] = {
      [2] = (RW_ uint32_t*)0x5200400CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [3] = (RW_ uint32_t*)0x52004014U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [4] = (RW_ uint32_t*)0x5200401CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [1] = (RW_ uint32_t*)0x52004004U   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    };

    static RW_ uint32_t* const FMC_BWTRx_PTR[5] = {
      [2] = (RW_ uint32_t*)0x5200410CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [3] = (RW_ uint32_t*)0x52004114U,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [4] = (RW_ uint32_t*)0x5200411CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [1] = (RW_ uint32_t*)0x52004104U   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    };

    static RW_ uint32_t* const FMC_SDCRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52004144U,   /** @brief This register contains the control parameters for each SDRAM memory bank */
      [1] = (RW_ uint32_t*)0x52004140U   /** @brief This register contains the control parameters for each SDRAM memory bank */
    };

    static RW_ uint32_t* const FMC_SDTRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5200414CU,   /** @brief This register contains the timing parameters of each SDRAM bank */
      [1] = (RW_ uint32_t*)0x52004148U   /** @brief This register contains the timing parameters of each SDRAM bank */
    };

    /**** @subsection FMC Register Reset Value Definitions ****/

    static const uint32_t FMC_PCR_RST   = 0x00000018U;   /** @brief NAND flash control registers */
    static const uint32_t FMC_SR_RST    = 0x00000040U;   /** @brief This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.this is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.the ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty. */
    static const uint32_t FMC_PMEM_RST  = 0xFCFCFCFCU;   /** @brief The FMC_PMEM read/write register contains the timing information for NAND flash memory bank. This information is used to access either the common memory space of the NAND flash for command, address write access and data read/write access. */
    static const uint32_t FMC_PATT_RST  = 0xFCFCFCFCU;   /** @brief The FMC_PATT read/write register contains the timing information for NAND flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND flash for the last address write access if the timing must differ from that of previous accesses (for ready/busy management, refer to section20.8.5: NAND flash prewait feature). */
    static const uint32_t FMC_ECCR_RST  = 0x00000000U;   /** @brief This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND flash memory page at the correct address (refer to section20.8.6: computation of the error correction code (ECC) in NAND flash memory), the data read/written from/to the NAND flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1. */
    static const uint32_t FMC_SDCMR_RST = 0x00000000U;   /** @brief This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the self-refresh and the power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks. */
    static const uint32_t FMC_SDRTR_RST = 0x00000000U;   /** @brief This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the refresh timer count value.examplewhere 64 ms is the SDRAM refresh period.the refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.as soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.if a memory access is in progress, the auto-refresh request is delayed. However, if the memory access and auto-refresh requests are generated simultaneously, the auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.this register is common to SDRAM bank 1 and bank 2. */
    static const uint32_t FMC_SDSR_RST  = 0x00000000U;   /** @brief SDRAM status register */

    static const uint32_t FMC_BCRx_RST[5] = {
      [2] = 0x000030D2U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [3] = 0x000030D2U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [4] = 0x000030D2U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
      [1] = 0x000030DBU   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    };

    static const uint32_t FMC_BTRx_RST[5] = {
      [2] = 0x0FFFFFFFU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [3] = 0x0FFFFFFFU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [4] = 0x0FFFFFFFU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
      [1] = 0x0FFFFFFFU   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    };

    static const uint32_t FMC_BWTRx_RST[5] = {
      [2] = 0x0FFFFFFFU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [3] = 0x0FFFFFFFU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [4] = 0x0FFFFFFFU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
      [1] = 0x0FFFFFFFU   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    };

    static const uint32_t FMC_SDCRx_RST[3] = {
      [2] = 0x000002D0U,   /** @brief This register contains the control parameters for each SDRAM memory bank */
      [1] = 0x000002D0U   /** @brief This register contains the control parameters for each SDRAM memory bank */
    };

    static const uint32_t FMC_SDTRx_RST[3] = {
      [2] = 0x0FFFFFFFU,   /** @brief This register contains the timing parameters of each SDRAM bank */
      [1] = 0x0FFFFFFFU   /** @brief This register contains the timing parameters of each SDRAM bank */
    };

    /**** @subsection FMC Register Value Type Definitions ****/

    typedef uint32_t FMC_BCRx_vt;    /** @brief FMC_BCRx register value type. */
    typedef uint32_t FMC_BTRx_vt;    /** @brief FMC_BTRx register value type. */
    typedef uint32_t FMC_PCR_vt;     /** @brief FMC_PCR register value type. */
    typedef uint32_t FMC_SR_vt;      /** @brief FMC_SR register value type. */
    typedef uint32_t FMC_PMEM_vt;    /** @brief FMC_PMEM register value type. */
    typedef uint32_t FMC_PATT_vt;    /** @brief FMC_PATT register value type. */
    typedef uint32_t FMC_ECCR_vt;    /** @brief FMC_ECCR register value type. */
    typedef uint32_t FMC_BWTRx_vt;   /** @brief FMC_BWTRx register value type. */
    typedef uint32_t FMC_SDCRx_vt;   /** @brief FMC_SDCRx register value type. */
    typedef uint32_t FMC_SDTRx_vt;   /** @brief FMC_SDTRx register value type. */
    typedef uint32_t FMC_SDCMR_vt;   /** @brief FMC_SDCMR register value type. */
    typedef uint32_t FMC_SDRTR_vt;   /** @brief FMC_SDRTR register value type. */
    typedef uint32_t FMC_SDSR_vt;    /** @brief FMC_SDSR register value type. */

    /**** @subsection FMC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* FMC_BCRx_pt;    /** @brief FMC_BCRx pointer register pointer type. */
    typedef RW_ uint32_t* FMC_BTRx_pt;    /** @brief FMC_BTRx pointer register pointer type. */
    typedef RW_ uint32_t* FMC_PCR_pt;     /** @brief FMC_PCR pointer register pointer type. */
    typedef RW_ uint32_t* FMC_SR_pt;      /** @brief FMC_SR pointer register pointer type. */
    typedef RW_ uint32_t* FMC_PMEM_pt;    /** @brief FMC_PMEM pointer register pointer type. */
    typedef RW_ uint32_t* FMC_PATT_pt;    /** @brief FMC_PATT pointer register pointer type. */
    typedef RO_ uint32_t* FMC_ECCR_pt;    /** @brief FMC_ECCR pointer register pointer type. */
    typedef RW_ uint32_t* FMC_BWTRx_pt;   /** @brief FMC_BWTRx pointer register pointer type. */
    typedef RW_ uint32_t* FMC_SDCRx_pt;   /** @brief FMC_SDCRx pointer register pointer type. */
    typedef RW_ uint32_t* FMC_SDTRx_pt;   /** @brief FMC_SDTRx pointer register pointer type. */
    typedef RW_ uint32_t* FMC_SDCMR_pt;   /** @brief FMC_SDCMR pointer register pointer type. */
    typedef RW_ uint32_t* FMC_SDRTR_pt;   /** @brief FMC_SDRTR pointer register pointer type. */
    typedef RO_ uint32_t* FMC_SDSR_pt;    /** @brief FMC_SDSR pointer register pointer type. */

    /**** @subsection FMC Field Mask Definitions ****/

    static const uint32_t FMC_PCR_ECCPS_MASK   = 0x000E0000U;   /** @brief ECC page size. These bits define the page size for the extended ECC: */
    static const uint32_t FMC_SR_FEMPT_MASK    = 0x00000040U;   /** @brief FIFO empty. Read-only bit that provides the status of the FIFO */
    static const uint32_t FMC_PMEM_MEMHIZ_MASK = 0xFF000000U;   /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions: */
    static const uint32_t FMC_PATT_ATTHIZ_MASK = 0xFF000000U;   /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction: */
    static const uint32_t FMC_ECCR_ECC_MASK    = 0xFFFFFFFFU;   /** @brief ECC result this field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields. */
    static const uint32_t FMC_SDCMR_MRD_MASK   = 0x007FFE00U;   /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
    static const uint32_t FMC_SDRTR_REIE_MASK  = 0x00004000U;   /** @brief RES interrupt enable */

    static const uint32_t FMC_BCRx_FMCEN_MASK[5] = {
      [2] = 0x80000000U,   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
      [3] = 0x80000000U,   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
      [4] = 0x80000000U,   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
      [1] = 0x80000000U   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
    };

    static const uint32_t FMC_BTRx_ACCMOD_MASK[5] = {
      [2] = 0x30000000U,   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
      [3] = 0x30000000U,   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
      [4] = 0x30000000U,   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
      [1] = 0x30000000U   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    };

    static const uint32_t FMC_BWTRx_ACCMOD_MASK[5] = {
      [2] = 0x30000000U,   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
      [3] = 0x30000000U,   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
      [4] = 0x30000000U,   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
      [1] = 0x30000000U   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
    };

    static const uint32_t FMC_SDCRx_RPIPE_MASK[3] = {
      [2] = 0x00006000U,   /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
      [1] = 0x00006000U   /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
    };

    static const uint32_t FMC_SDTRx_TRCD_MASK[3] = {
      [2] = 0x0F000000U,   /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
      [1] = 0x0F000000U   /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
    };

    static const uint32_t FMC_SDSR_MODESx_MASK[3] = {
      [2] = 0x00000018U,   /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */
      [1] = 0x00000006U   /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
    };

    /**********************************************************************************************
     * @section CEC Register Definitions
     **********************************************************************************************/

    /**** @subsection CEC Register Pointer Definitions ****/

    static RW_ uint32_t* const CEC_CR_PTR   = (RW_ uint32_t*)0x40006C00U;   /** @brief CEC control register */
    static RW_ uint32_t* const CEC_CFGR_PTR = (RW_ uint32_t*)0x40006C04U;   /** @brief This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0. */
    static RW_ uint32_t* const CEC_TXDR_PTR = (RW_ uint32_t*)0x40006C08U;   /** @brief CEC tx data register */
    static RO_ uint32_t* const CEC_RXDR_PTR = (RO_ uint32_t*)0x40006C0CU;   /** @brief CEC rx data register */
    static RW_ uint32_t* const CEC_ISR_PTR  = (RW_ uint32_t*)0x40006C10U;   /** @brief CEC interrupt and status register */
    static RW_ uint32_t* const CEC_IER_PTR  = (RW_ uint32_t*)0x40006C14U;   /** @brief CEC interrupt enable register */

    /**** @subsection CEC Register Reset Value Definitions ****/

    static const uint32_t CEC_CR_RST   = 0x00000000U;   /** @brief CEC control register */
    static const uint32_t CEC_CFGR_RST = 0x00000000U;   /** @brief This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0. */
    static const uint32_t CEC_TXDR_RST = 0x00000000U;   /** @brief CEC tx data register */
    static const uint32_t CEC_RXDR_RST = 0x00000000U;   /** @brief CEC rx data register */
    static const uint32_t CEC_ISR_RST  = 0x00000000U;   /** @brief CEC interrupt and status register */
    static const uint32_t CEC_IER_RST  = 0x00000000U;   /** @brief CEC interrupt enable register */

    /**** @subsection CEC Register Value Type Definitions ****/

    typedef uint32_t CEC_CR_vt;     /** @brief CEC_CR register value type. */
    typedef uint32_t CEC_CFGR_vt;   /** @brief CEC_CFGR register value type. */
    typedef uint32_t CEC_TXDR_vt;   /** @brief CEC_TXDR register value type. */
    typedef uint32_t CEC_RXDR_vt;   /** @brief CEC_RXDR register value type. */
    typedef uint32_t CEC_ISR_vt;    /** @brief CEC_ISR register value type. */
    typedef uint32_t CEC_IER_vt;    /** @brief CEC_IER register value type. */

    /**** @subsection CEC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* CEC_CR_pt;     /** @brief CEC_CR pointer register pointer type. */
    typedef RW_ uint32_t* CEC_CFGR_pt;   /** @brief CEC_CFGR pointer register pointer type. */
    typedef RW_ uint32_t* CEC_TXDR_pt;   /** @brief CEC_TXDR pointer register pointer type. */
    typedef RO_ uint32_t* CEC_RXDR_pt;   /** @brief CEC_RXDR pointer register pointer type. */
    typedef RW_ uint32_t* CEC_ISR_pt;    /** @brief CEC_ISR pointer register pointer type. */
    typedef RW_ uint32_t* CEC_IER_pt;    /** @brief CEC_IER pointer register pointer type. */

    /**** @subsection CEC Field Mask Definitions ****/

    static const uint32_t CEC_CR_TXEOM_MASK    = 0x00000004U;   /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message) */
    static const uint32_t CEC_CFGR_LSTN_MASK   = 0x80000000U;   /** @brief Listen mode LSTN bit is set and cleared by software. */
    static const uint32_t CEC_TXDR_TXD_MASK    = 0x000000FFU;   /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 */
    static const uint32_t CEC_RXDR_RXD_MASK    = 0x000000FFU;   /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
    static const uint32_t CEC_ISR_TXACKE_MASK  = 0x00001000U;   /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
    static const uint32_t CEC_IER_TXACKIE_MASK = 0x00001000U;   /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

    /**********************************************************************************************
     * @section HSEM Register Definitions
     **********************************************************************************************/

    /**** @subsection HSEM Register Pointer Definitions ****/

    static RW_ uint32_t* const HSEM_HSEM_IER_PTR  = (RW_ uint32_t*)0x58026500U;   /** @brief HSEM interrupt enable register */
    static RO_ uint32_t* const HSEM_HSEM_ICR_PTR  = (RO_ uint32_t*)0x58026504U;   /** @brief HSEM interrupt clear register */
    static RO_ uint32_t* const HSEM_HSEM_ISR_PTR  = (RO_ uint32_t*)0x58026508U;   /** @brief HSEM interrupt status register */
    static RO_ uint32_t* const HSEM_HSEM_MISR_PTR = (RO_ uint32_t*)0x5802650CU;   /** @brief HSEM masked interrupt status register */
    static RW_ uint32_t* const HSEM_HSEM_CR_PTR   = (RW_ uint32_t*)0x58026540U;   /** @brief HSEM clear register */
    static RW_ uint32_t* const HSEM_HSEM_KEYR_PTR = (RW_ uint32_t*)0x58026544U;   /** @brief HSEM interrupt clear register */

    static RW_ uint32_t* const HSEM_HSEM_Rx_PTR[32] = {
      [1]  = (RW_ uint32_t*)0x58026404U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [2]  = (RW_ uint32_t*)0x58026408U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [3]  = (RW_ uint32_t*)0x5802640CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [4]  = (RW_ uint32_t*)0x58026410U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [5]  = (RW_ uint32_t*)0x58026414U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [6]  = (RW_ uint32_t*)0x58026418U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [7]  = (RW_ uint32_t*)0x5802641CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [8]  = (RW_ uint32_t*)0x58026420U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [9]  = (RW_ uint32_t*)0x58026424U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [10] = (RW_ uint32_t*)0x58026428U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [11] = (RW_ uint32_t*)0x5802642CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [12] = (RW_ uint32_t*)0x58026430U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [13] = (RW_ uint32_t*)0x58026434U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [14] = (RW_ uint32_t*)0x58026438U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [15] = (RW_ uint32_t*)0x5802643CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [16] = (RW_ uint32_t*)0x58026440U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [17] = (RW_ uint32_t*)0x58026444U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [18] = (RW_ uint32_t*)0x58026448U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [19] = (RW_ uint32_t*)0x5802644CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [20] = (RW_ uint32_t*)0x58026450U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [21] = (RW_ uint32_t*)0x58026454U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [22] = (RW_ uint32_t*)0x58026458U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [23] = (RW_ uint32_t*)0x5802645CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [24] = (RW_ uint32_t*)0x58026460U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [25] = (RW_ uint32_t*)0x58026464U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [26] = (RW_ uint32_t*)0x58026468U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [27] = (RW_ uint32_t*)0x5802646CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [28] = (RW_ uint32_t*)0x58026470U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [29] = (RW_ uint32_t*)0x58026474U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [30] = (RW_ uint32_t*)0x58026478U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [31] = (RW_ uint32_t*)0x5802647CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [0]  = (RW_ uint32_t*)0x58026400U   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    };

    static RO_ uint32_t* const HSEM_HSEM_RLRx_PTR[32] = {
      [1]  = (RO_ uint32_t*)0x58026484U,   /** @brief HSEM read lock register */
      [2]  = (RO_ uint32_t*)0x58026488U,   /** @brief HSEM read lock register */
      [3]  = (RO_ uint32_t*)0x5802648CU,   /** @brief HSEM read lock register */
      [4]  = (RO_ uint32_t*)0x58026490U,   /** @brief HSEM read lock register */
      [5]  = (RO_ uint32_t*)0x58026494U,   /** @brief HSEM read lock register */
      [6]  = (RO_ uint32_t*)0x58026498U,   /** @brief HSEM read lock register */
      [7]  = (RO_ uint32_t*)0x5802649CU,   /** @brief HSEM read lock register */
      [8]  = (RO_ uint32_t*)0x580264A0U,   /** @brief HSEM read lock register */
      [9]  = (RO_ uint32_t*)0x580264A4U,   /** @brief HSEM read lock register */
      [10] = (RO_ uint32_t*)0x580264A8U,   /** @brief HSEM read lock register */
      [11] = (RO_ uint32_t*)0x580264ACU,   /** @brief HSEM read lock register */
      [12] = (RO_ uint32_t*)0x580264B0U,   /** @brief HSEM read lock register */
      [13] = (RO_ uint32_t*)0x580264B4U,   /** @brief HSEM read lock register */
      [14] = (RO_ uint32_t*)0x580264B8U,   /** @brief HSEM read lock register */
      [15] = (RO_ uint32_t*)0x580264BCU,   /** @brief HSEM read lock register */
      [16] = (RO_ uint32_t*)0x580264C0U,   /** @brief HSEM read lock register */
      [17] = (RO_ uint32_t*)0x580264C4U,   /** @brief HSEM read lock register */
      [18] = (RO_ uint32_t*)0x580264C8U,   /** @brief HSEM read lock register */
      [19] = (RO_ uint32_t*)0x580264CCU,   /** @brief HSEM read lock register */
      [20] = (RO_ uint32_t*)0x580264D0U,   /** @brief HSEM read lock register */
      [21] = (RO_ uint32_t*)0x580264D4U,   /** @brief HSEM read lock register */
      [22] = (RO_ uint32_t*)0x580264D8U,   /** @brief HSEM read lock register */
      [23] = (RO_ uint32_t*)0x580264DCU,   /** @brief HSEM read lock register */
      [24] = (RO_ uint32_t*)0x580264E0U,   /** @brief HSEM read lock register */
      [25] = (RO_ uint32_t*)0x580264E4U,   /** @brief HSEM read lock register */
      [26] = (RO_ uint32_t*)0x580264E8U,   /** @brief HSEM read lock register */
      [27] = (RO_ uint32_t*)0x580264ECU,   /** @brief HSEM read lock register */
      [28] = (RO_ uint32_t*)0x580264F0U,   /** @brief HSEM read lock register */
      [29] = (RO_ uint32_t*)0x580264F4U,   /** @brief HSEM read lock register */
      [30] = (RO_ uint32_t*)0x580264F8U,   /** @brief HSEM read lock register */
      [31] = (RO_ uint32_t*)0x580264FCU,   /** @brief HSEM read lock register */
      [0]  = (RO_ uint32_t*)0x58026480U   /** @brief HSEM read lock register */
    };

    /**** @subsection HSEM Register Reset Value Definitions ****/

    static const uint32_t HSEM_HSEM_IER_RST  = 0x00000000U;   /** @brief HSEM interrupt enable register */
    static const uint32_t HSEM_HSEM_ICR_RST  = 0x00000000U;   /** @brief HSEM interrupt clear register */
    static const uint32_t HSEM_HSEM_ISR_RST  = 0x00000000U;   /** @brief HSEM interrupt status register */
    static const uint32_t HSEM_HSEM_MISR_RST = 0x00000000U;   /** @brief HSEM masked interrupt status register */
    static const uint32_t HSEM_HSEM_CR_RST   = 0x00000000U;   /** @brief HSEM clear register */
    static const uint32_t HSEM_HSEM_KEYR_RST = 0x00000000U;   /** @brief HSEM interrupt clear register */

    static const uint32_t HSEM_HSEM_Rx_RST[32] = {
      [1]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [2]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [3]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [4]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [5]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [6]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [7]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [8]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [9]  = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [10] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [11] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [12] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [13] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [14] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [15] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [16] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [17] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [18] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [19] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [20] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [21] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [22] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [23] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [24] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [25] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [26] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [27] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [28] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [29] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [30] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [31] = 0x00000000U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
      [0]  = 0x00000000U   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    };

    static const uint32_t HSEM_HSEM_RLRx_RST[32] = {
      [1]  = 0x00000000U,   /** @brief HSEM read lock register */
      [2]  = 0x00000000U,   /** @brief HSEM read lock register */
      [3]  = 0x00000000U,   /** @brief HSEM read lock register */
      [4]  = 0x00000000U,   /** @brief HSEM read lock register */
      [5]  = 0x00000000U,   /** @brief HSEM read lock register */
      [6]  = 0x00000000U,   /** @brief HSEM read lock register */
      [7]  = 0x00000000U,   /** @brief HSEM read lock register */
      [8]  = 0x00000000U,   /** @brief HSEM read lock register */
      [9]  = 0x00000000U,   /** @brief HSEM read lock register */
      [10] = 0x00000000U,   /** @brief HSEM read lock register */
      [11] = 0x00000000U,   /** @brief HSEM read lock register */
      [12] = 0x00000000U,   /** @brief HSEM read lock register */
      [13] = 0x00000000U,   /** @brief HSEM read lock register */
      [14] = 0x00000000U,   /** @brief HSEM read lock register */
      [15] = 0x00000000U,   /** @brief HSEM read lock register */
      [16] = 0x00000000U,   /** @brief HSEM read lock register */
      [17] = 0x00000000U,   /** @brief HSEM read lock register */
      [18] = 0x00000000U,   /** @brief HSEM read lock register */
      [19] = 0x00000000U,   /** @brief HSEM read lock register */
      [20] = 0x00000000U,   /** @brief HSEM read lock register */
      [21] = 0x00000000U,   /** @brief HSEM read lock register */
      [22] = 0x00000000U,   /** @brief HSEM read lock register */
      [23] = 0x00000000U,   /** @brief HSEM read lock register */
      [24] = 0x00000000U,   /** @brief HSEM read lock register */
      [25] = 0x00000000U,   /** @brief HSEM read lock register */
      [26] = 0x00000000U,   /** @brief HSEM read lock register */
      [27] = 0x00000000U,   /** @brief HSEM read lock register */
      [28] = 0x00000000U,   /** @brief HSEM read lock register */
      [29] = 0x00000000U,   /** @brief HSEM read lock register */
      [30] = 0x00000000U,   /** @brief HSEM read lock register */
      [31] = 0x00000000U,   /** @brief HSEM read lock register */
      [0]  = 0x00000000U   /** @brief HSEM read lock register */
    };

    /**** @subsection HSEM Register Value Type Definitions ****/

    typedef uint32_t HSEM_HSEM_Rx_vt;     /** @brief HSEM_HSEM_Rx register value type. */
    typedef uint32_t HSEM_HSEM_RLRx_vt;   /** @brief HSEM_HSEM_RLRx register value type. */
    typedef uint32_t HSEM_HSEM_IER_vt;    /** @brief HSEM_HSEM_IER register value type. */
    typedef uint32_t HSEM_HSEM_ICR_vt;    /** @brief HSEM_HSEM_ICR register value type. */
    typedef uint32_t HSEM_HSEM_ISR_vt;    /** @brief HSEM_HSEM_ISR register value type. */
    typedef uint32_t HSEM_HSEM_MISR_vt;   /** @brief HSEM_HSEM_MISR register value type. */
    typedef uint32_t HSEM_HSEM_CR_vt;     /** @brief HSEM_HSEM_CR register value type. */
    typedef uint32_t HSEM_HSEM_KEYR_vt;   /** @brief HSEM_HSEM_KEYR register value type. */

    /**** @subsection HSEM Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HSEM_HSEM_Rx_pt;     /** @brief HSEM_HSEM_Rx pointer register pointer type. */
    typedef RO_ uint32_t* HSEM_HSEM_RLRx_pt;   /** @brief HSEM_HSEM_RLRx pointer register pointer type. */
    typedef RW_ uint32_t* HSEM_HSEM_IER_pt;    /** @brief HSEM_HSEM_IER pointer register pointer type. */
    typedef RO_ uint32_t* HSEM_HSEM_ICR_pt;    /** @brief HSEM_HSEM_ICR pointer register pointer type. */
    typedef RO_ uint32_t* HSEM_HSEM_ISR_pt;    /** @brief HSEM_HSEM_ISR pointer register pointer type. */
    typedef RO_ uint32_t* HSEM_HSEM_MISR_pt;   /** @brief HSEM_HSEM_MISR pointer register pointer type. */
    typedef RW_ uint32_t* HSEM_HSEM_CR_pt;     /** @brief HSEM_HSEM_CR pointer register pointer type. */
    typedef RW_ uint32_t* HSEM_HSEM_KEYR_pt;   /** @brief HSEM_HSEM_KEYR pointer register pointer type. */

    /**** @subsection HSEM Field Mask Definitions ****/

    static const uint32_t HSEM_HSEM_CR_KEY_MASK   = 0xFFFF0000U;   /** @brief Semaphore clear key */
    static const uint32_t HSEM_HSEM_KEYR_KEY_MASK = 0xFFFF0000U;   /** @brief Semaphore clear key */

    static const uint32_t HSEM_HSEM_Rx_LOCK_MASK[32] = {
      [1]  = 0x80000000U,   /** @brief Lock indication */
      [2]  = 0x80000000U,   /** @brief Lock indication */
      [3]  = 0x80000000U,   /** @brief Lock indication */
      [4]  = 0x80000000U,   /** @brief Lock indication */
      [5]  = 0x80000000U,   /** @brief Lock indication */
      [6]  = 0x80000000U,   /** @brief Lock indication */
      [7]  = 0x80000000U,   /** @brief Lock indication */
      [8]  = 0x80000000U,   /** @brief Lock indication */
      [9]  = 0x80000000U,   /** @brief Lock indication */
      [10] = 0x80000000U,   /** @brief Lock indication */
      [11] = 0x80000000U,   /** @brief Lock indication */
      [12] = 0x80000000U,   /** @brief Lock indication */
      [13] = 0x80000000U,   /** @brief Lock indication */
      [14] = 0x80000000U,   /** @brief Lock indication */
      [15] = 0x80000000U,   /** @brief Lock indication */
      [16] = 0x80000000U,   /** @brief Lock indication */
      [17] = 0x80000000U,   /** @brief Lock indication */
      [18] = 0x80000000U,   /** @brief Lock indication */
      [19] = 0x80000000U,   /** @brief Lock indication */
      [20] = 0x80000000U,   /** @brief Lock indication */
      [21] = 0x80000000U,   /** @brief Lock indication */
      [22] = 0x80000000U,   /** @brief Lock indication */
      [23] = 0x80000000U,   /** @brief Lock indication */
      [24] = 0x80000000U,   /** @brief Lock indication */
      [25] = 0x80000000U,   /** @brief Lock indication */
      [26] = 0x80000000U,   /** @brief Lock indication */
      [27] = 0x80000000U,   /** @brief Lock indication */
      [28] = 0x80000000U,   /** @brief Lock indication */
      [29] = 0x80000000U,   /** @brief Lock indication */
      [30] = 0x80000000U,   /** @brief Lock indication */
      [31] = 0x80000000U,   /** @brief Lock indication */
      [0]  = 0x80000000U   /** @brief Lock indication */
    };

    static const uint32_t HSEM_HSEM_RLRx_LOCK_MASK[32] = {
      [1]  = 0x80000000U,   /** @brief Lock indication */
      [2]  = 0x80000000U,   /** @brief Lock indication */
      [3]  = 0x80000000U,   /** @brief Lock indication */
      [4]  = 0x80000000U,   /** @brief Lock indication */
      [5]  = 0x80000000U,   /** @brief Lock indication */
      [6]  = 0x80000000U,   /** @brief Lock indication */
      [7]  = 0x80000000U,   /** @brief Lock indication */
      [8]  = 0x80000000U,   /** @brief Lock indication */
      [9]  = 0x80000000U,   /** @brief Lock indication */
      [10] = 0x80000000U,   /** @brief Lock indication */
      [11] = 0x80000000U,   /** @brief Lock indication */
      [12] = 0x80000000U,   /** @brief Lock indication */
      [13] = 0x80000000U,   /** @brief Lock indication */
      [14] = 0x80000000U,   /** @brief Lock indication */
      [15] = 0x80000000U,   /** @brief Lock indication */
      [16] = 0x80000000U,   /** @brief Lock indication */
      [17] = 0x80000000U,   /** @brief Lock indication */
      [18] = 0x80000000U,   /** @brief Lock indication */
      [19] = 0x80000000U,   /** @brief Lock indication */
      [20] = 0x80000000U,   /** @brief Lock indication */
      [21] = 0x80000000U,   /** @brief Lock indication */
      [22] = 0x80000000U,   /** @brief Lock indication */
      [23] = 0x80000000U,   /** @brief Lock indication */
      [24] = 0x80000000U,   /** @brief Lock indication */
      [25] = 0x80000000U,   /** @brief Lock indication */
      [26] = 0x80000000U,   /** @brief Lock indication */
      [27] = 0x80000000U,   /** @brief Lock indication */
      [28] = 0x80000000U,   /** @brief Lock indication */
      [29] = 0x80000000U,   /** @brief Lock indication */
      [30] = 0x80000000U,   /** @brief Lock indication */
      [31] = 0x80000000U,   /** @brief Lock indication */
      [0]  = 0x80000000U   /** @brief Lock indication */
    };

    static const uint32_t HSEM_HSEM_IER_ISEMx_MASK[32] = {
      [1]  = 0x00000002U,   /** @brief Interrupt semaphore n enable bit */
      [2]  = 0x00000004U,   /** @brief Interrupt semaphore n enable bit */
      [3]  = 0x00000008U,   /** @brief Interrupt semaphore n enable bit */
      [4]  = 0x00000010U,   /** @brief Interrupt semaphore n enable bit */
      [5]  = 0x00000020U,   /** @brief Interrupt semaphore n enable bit */
      [6]  = 0x00000040U,   /** @brief Interrupt semaphore n enable bit */
      [7]  = 0x00000080U,   /** @brief Interrupt semaphore n enable bit */
      [8]  = 0x00000100U,   /** @brief Interrupt semaphore n enable bit */
      [9]  = 0x00000200U,   /** @brief Interrupt semaphore n enable bit */
      [10] = 0x00000400U,   /** @brief Interrupt semaphore n enable bit */
      [11] = 0x00000800U,   /** @brief Interrupt semaphore n enable bit */
      [12] = 0x00001000U,   /** @brief Interrupt semaphore n enable bit */
      [13] = 0x00002000U,   /** @brief Interrupt semaphore n enable bit */
      [14] = 0x00004000U,   /** @brief Interrupt semaphore n enable bit */
      [15] = 0x00008000U,   /** @brief Interrupt semaphore n enable bit */
      [16] = 0x00010000U,   /** @brief Interrupt semaphore n enable bit */
      [17] = 0x00020000U,   /** @brief Interrupt semaphore n enable bit */
      [18] = 0x00040000U,   /** @brief Interrupt semaphore n enable bit */
      [19] = 0x00080000U,   /** @brief Interrupt semaphore n enable bit */
      [20] = 0x00100000U,   /** @brief Interrupt semaphore n enable bit */
      [21] = 0x00200000U,   /** @brief Interrupt semaphore n enable bit */
      [22] = 0x00400000U,   /** @brief Interrupt semaphore n enable bit */
      [23] = 0x00800000U,   /** @brief Interrupt semaphore n enable bit */
      [24] = 0x01000000U,   /** @brief Interrupt semaphore n enable bit */
      [25] = 0x02000000U,   /** @brief Interrupt semaphore n enable bit */
      [26] = 0x04000000U,   /** @brief Interrupt semaphore n enable bit */
      [27] = 0x08000000U,   /** @brief Interrupt semaphore n enable bit */
      [28] = 0x10000000U,   /** @brief Interrupt semaphore n enable bit */
      [29] = 0x20000000U,   /** @brief Interrupt semaphore n enable bit */
      [30] = 0x40000000U,   /** @brief Interrupt semaphore n enable bit */
      [31] = 0x80000000U,   /** @brief Interrupt(N) semaphore n enable bit. */
      [0]  = 0x00000001U   /** @brief Interrupt semaphore n enable bit */
    };

    static const uint32_t HSEM_HSEM_ICR_ISEMx_MASK[32] = {
      [1]  = 0x00000002U,   /** @brief Interrupt(N) semaphore n clear bit */
      [2]  = 0x00000004U,   /** @brief Interrupt(N) semaphore n clear bit */
      [3]  = 0x00000008U,   /** @brief Interrupt(N) semaphore n clear bit */
      [4]  = 0x00000010U,   /** @brief Interrupt(N) semaphore n clear bit */
      [5]  = 0x00000020U,   /** @brief Interrupt(N) semaphore n clear bit */
      [6]  = 0x00000040U,   /** @brief Interrupt(N) semaphore n clear bit */
      [7]  = 0x00000080U,   /** @brief Interrupt(N) semaphore n clear bit */
      [8]  = 0x00000100U,   /** @brief Interrupt(N) semaphore n clear bit */
      [9]  = 0x00000200U,   /** @brief Interrupt(N) semaphore n clear bit */
      [10] = 0x00000400U,   /** @brief Interrupt(N) semaphore n clear bit */
      [11] = 0x00000800U,   /** @brief Interrupt(N) semaphore n clear bit */
      [12] = 0x00001000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [13] = 0x00002000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [14] = 0x00004000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [15] = 0x00008000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [16] = 0x00010000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [17] = 0x00020000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [18] = 0x00040000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [19] = 0x00080000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [20] = 0x00100000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [21] = 0x00200000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [22] = 0x00400000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [23] = 0x00800000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [24] = 0x01000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [25] = 0x02000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [26] = 0x04000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [27] = 0x08000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [28] = 0x10000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [29] = 0x20000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [30] = 0x40000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [31] = 0x80000000U,   /** @brief Interrupt(N) semaphore n clear bit */
      [0]  = 0x00000001U   /** @brief Interrupt(N) semaphore n clear bit */
    };

    static const uint32_t HSEM_HSEM_ISR_ISEMx_MASK[32] = {
      [1]  = 0x00000002U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [2]  = 0x00000004U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [3]  = 0x00000008U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [4]  = 0x00000010U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [5]  = 0x00000020U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [6]  = 0x00000040U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [7]  = 0x00000080U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [8]  = 0x00000100U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [9]  = 0x00000200U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [10] = 0x00000400U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [11] = 0x00000800U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [12] = 0x00001000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [13] = 0x00002000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [14] = 0x00004000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [15] = 0x00008000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [16] = 0x00010000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [17] = 0x00020000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [18] = 0x00040000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [19] = 0x00080000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [20] = 0x00100000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [21] = 0x00200000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [22] = 0x00400000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [23] = 0x00800000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [24] = 0x01000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [25] = 0x02000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [26] = 0x04000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [27] = 0x08000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [28] = 0x10000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [29] = 0x20000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [30] = 0x40000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [31] = 0x80000000U,   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
      [0]  = 0x00000001U   /** @brief Interrupt(N) semaphore n status bit before enable (mask) */
    };

    static const uint32_t HSEM_HSEM_MISR_ISEMx_MASK[32] = {
      [1]  = 0x00000002U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [2]  = 0x00000004U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [3]  = 0x00000008U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [4]  = 0x00000010U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [5]  = 0x00000020U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [6]  = 0x00000040U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [7]  = 0x00000080U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [8]  = 0x00000100U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [9]  = 0x00000200U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [10] = 0x00000400U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [11] = 0x00000800U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [12] = 0x00001000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [13] = 0x00002000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [14] = 0x00004000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [15] = 0x00008000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [16] = 0x00010000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [17] = 0x00020000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [18] = 0x00040000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [19] = 0x00080000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [20] = 0x00100000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [21] = 0x00200000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [22] = 0x00400000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [23] = 0x00800000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [24] = 0x01000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [25] = 0x02000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [26] = 0x04000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [27] = 0x08000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [28] = 0x10000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [29] = 0x20000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [30] = 0x40000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [31] = 0x80000000U,   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
      [0]  = 0x00000001U   /** @brief Masked interrupt(n) semaphore n status bit after enable (mask) */
    };

    /**********************************************************************************************
     * @section I2C Register Definitions
     **********************************************************************************************/

    /**** @subsection I2C Register Pointer Definitions ****/

    static RW_ uint32_t* const I2Cx_TIMINGR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x40005810U,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t*)0x40005C10U,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t*)0x58001C10U,   /** @brief Access: no wait states */
      [1] = (RW_ uint32_t*)0x40005410U   /** @brief Access: no wait states */
    };

    static RW_ uint32_t* const I2Cx_TIMEOUTR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x40005814U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [3] = (RW_ uint32_t*)0x40005C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [4] = (RW_ uint32_t*)0x58001C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [1] = (RW_ uint32_t*)0x40005414U   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static RW_ uint32_t* const I2Cx_ISR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x40005818U,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t*)0x40005C18U,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t*)0x58001C18U,   /** @brief Access: no wait states */
      [1] = (RW_ uint32_t*)0x40005418U   /** @brief Access: no wait states */
    };

    static RW_ uint32_t* const I2Cx_ICR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x4000581CU,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t*)0x40005C1CU,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t*)0x58001C1CU,   /** @brief Access: no wait states */
      [1] = (RW_ uint32_t*)0x4000541CU   /** @brief Access: no wait states */
    };

    static RO_ uint32_t* const I2Cx_PECR_PTR[5] = {
      [2] = (RO_ uint32_t*)0x40005820U,   /** @brief Access: no wait states */
      [3] = (RO_ uint32_t*)0x40005C20U,   /** @brief Access: no wait states */
      [4] = (RO_ uint32_t*)0x58001C20U,   /** @brief Access: no wait states */
      [1] = (RO_ uint32_t*)0x40005420U   /** @brief Access: no wait states */
    };

    static RO_ uint32_t* const I2Cx_RXDR_PTR[5] = {
      [2] = (RO_ uint32_t*)0x40005824U,   /** @brief Access: no wait states */
      [3] = (RO_ uint32_t*)0x40005C24U,   /** @brief Access: no wait states */
      [4] = (RO_ uint32_t*)0x58001C24U,   /** @brief Access: no wait states */
      [1] = (RO_ uint32_t*)0x40005424U   /** @brief Access: no wait states */
    };

    static RW_ uint32_t* const I2Cx_TXDR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x40005828U,   /** @brief Access: no wait states */
      [3] = (RW_ uint32_t*)0x40005C28U,   /** @brief Access: no wait states */
      [4] = (RW_ uint32_t*)0x58001C28U,   /** @brief Access: no wait states */
      [1] = (RW_ uint32_t*)0x40005428U   /** @brief Access: no wait states */
    };

    /**** @subsection I2C Register Reset Value Definitions ****/

    static const uint32_t I2Cx_TIMINGR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Access: no wait states */
      [3] = 0x00000000U,   /** @brief Access: no wait states */
      [4] = 0x00000000U,   /** @brief Access: no wait states */
      [1] = 0x00000000U   /** @brief Access: no wait states */
    };

    static const uint32_t I2Cx_TIMEOUTR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [3] = 0x00000000U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [4] = 0x00000000U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [1] = 0x00000000U   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    };

    static const uint32_t I2Cx_ISR_RST[5] = {
      [2] = 0x00000001U,   /** @brief Access: no wait states */
      [3] = 0x00000001U,   /** @brief Access: no wait states */
      [4] = 0x00000001U,   /** @brief Access: no wait states */
      [1] = 0x00000001U   /** @brief Access: no wait states */
    };

    static const uint32_t I2Cx_ICR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Access: no wait states */
      [3] = 0x00000000U,   /** @brief Access: no wait states */
      [4] = 0x00000000U,   /** @brief Access: no wait states */
      [1] = 0x00000000U   /** @brief Access: no wait states */
    };

    static const uint32_t I2Cx_PECR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Access: no wait states */
      [3] = 0x00000000U,   /** @brief Access: no wait states */
      [4] = 0x00000000U,   /** @brief Access: no wait states */
      [1] = 0x00000000U   /** @brief Access: no wait states */
    };

    static const uint32_t I2Cx_RXDR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Access: no wait states */
      [3] = 0x00000000U,   /** @brief Access: no wait states */
      [4] = 0x00000000U,   /** @brief Access: no wait states */
      [1] = 0x00000000U   /** @brief Access: no wait states */
    };

    static const uint32_t I2Cx_TXDR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Access: no wait states */
      [3] = 0x00000000U,   /** @brief Access: no wait states */
      [4] = 0x00000000U,   /** @brief Access: no wait states */
      [1] = 0x00000000U   /** @brief Access: no wait states */
    };

    /**** @subsection I2C Register Value Type Definitions ****/

    typedef uint32_t I2Cx_CRx_vt;        /** @brief I2Cx_CRx register value type. */
    typedef uint32_t I2Cx_OARx_vt;       /** @brief I2Cx_OARx register value type. */
    typedef uint32_t I2Cx_TIMINGR_vt;    /** @brief I2Cx_TIMINGR register value type. */
    typedef uint32_t I2Cx_TIMEOUTR_vt;   /** @brief I2Cx_TIMEOUTR register value type. */
    typedef uint32_t I2Cx_ISR_vt;        /** @brief I2Cx_ISR register value type. */
    typedef uint32_t I2Cx_ICR_vt;        /** @brief I2Cx_ICR register value type. */
    typedef uint32_t I2Cx_PECR_vt;       /** @brief I2Cx_PECR register value type. */
    typedef uint32_t I2Cx_RXDR_vt;       /** @brief I2Cx_RXDR register value type. */
    typedef uint32_t I2Cx_TXDR_vt;       /** @brief I2Cx_TXDR register value type. */

    /**** @subsection I2C Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* I2Cx_CRx_pt;        /** @brief I2Cx_CRx pointer register pointer type. */
    typedef RW_ uint32_t* I2Cx_OARx_pt;       /** @brief I2Cx_OARx pointer register pointer type. */
    typedef RW_ uint32_t* I2Cx_TIMINGR_pt;    /** @brief I2Cx_TIMINGR pointer register pointer type. */
    typedef RW_ uint32_t* I2Cx_TIMEOUTR_pt;   /** @brief I2Cx_TIMEOUTR pointer register pointer type. */
    typedef RW_ uint32_t* I2Cx_ISR_pt;        /** @brief I2Cx_ISR pointer register pointer type. */
    typedef RW_ uint32_t* I2Cx_ICR_pt;        /** @brief I2Cx_ICR pointer register pointer type. */
    typedef RO_ uint32_t* I2Cx_PECR_pt;       /** @brief I2Cx_PECR pointer register pointer type. */
    typedef RO_ uint32_t* I2Cx_RXDR_pt;       /** @brief I2Cx_RXDR pointer register pointer type. */
    typedef RW_ uint32_t* I2Cx_TXDR_pt;       /** @brief I2Cx_TXDR pointer register pointer type. */

    /**** @subsection I2C Field Mask Definitions ****/

    static const uint32_t I2Cx_CRx_PECEN_MASK[5] = {
      [2] = 0x00800000U,   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
      [3] = 0x00800000U,   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
      [4] = 0x00800000U,   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
      [1] = 0x00800000U   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    };

    static const uint32_t I2Cx_TIMINGR_PRESC_MASK[5] = {
      [2] = 0xF0000000U,   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
      [3] = 0xF0000000U,   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
      [4] = 0xF0000000U,   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
      [1] = 0xF0000000U   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
    };

    static const uint32_t I2Cx_TIMEOUTR_TEXTEN_MASK[5] = {
      [2] = 0x80000000U,   /** @brief Extended clock timeout enable */
      [3] = 0x80000000U,   /** @brief Extended clock timeout enable */
      [4] = 0x80000000U,   /** @brief Extended clock timeout enable */
      [1] = 0x80000000U   /** @brief Extended clock timeout enable */
    };

    static const uint32_t I2Cx_ISR_ADDCODE_MASK[5] = {
      [2] = 0x00FE0000U,   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
      [3] = 0x00FE0000U,   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
      [4] = 0x00FE0000U,   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
      [1] = 0x00FE0000U   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
    };

    static const uint32_t I2Cx_ICR_ALERTCF_MASK[5] = {
      [2] = 0x00002000U,   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
      [3] = 0x00002000U,   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
      [4] = 0x00002000U,   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
      [1] = 0x00002000U   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
    };

    static const uint32_t I2Cx_PECR_PEC_MASK[5] = {
      [2] = 0x000000FFU,   /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
      [3] = 0x000000FFU,   /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
      [4] = 0x000000FFU,   /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
      [1] = 0x000000FFU   /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
    };

    static const uint32_t I2Cx_RXDR_RXDATA_MASK[5] = {
      [2] = 0x000000FFU,   /** @brief 8-bit receive data data byte received from the I2C bus. */
      [3] = 0x000000FFU,   /** @brief 8-bit receive data data byte received from the I2C bus. */
      [4] = 0x000000FFU,   /** @brief 8-bit receive data data byte received from the I2C bus. */
      [1] = 0x000000FFU   /** @brief 8-bit receive data data byte received from the I2C bus. */
    };

    static const uint32_t I2Cx_TXDR_TXDATA_MASK[5] = {
      [2] = 0x000000FFU,   /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */
      [3] = 0x000000FFU,   /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */
      [4] = 0x000000FFU,   /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */
      [1] = 0x000000FFU   /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */
    };

    static const uint32_t I2Cx_OARx_OAxEN_MASK[5][3] = {
      [2] = {
        [2] = 0x00008000U,   /** @brief Own address 2 enable */
        [1] = 0x00008000U   /** @brief Own address 1 enable */
      },
      [3] = {
        [2] = 0x00008000U,   /** @brief Own address 2 enable */
        [1] = 0x00008000U   /** @brief Own address 1 enable */
      },
      [4] = {
        [2] = 0x00008000U,   /** @brief Own address 2 enable */
        [1] = 0x00008000U   /** @brief Own address 1 enable */
      },
      [1] = {
        [2] = 0x00008000U,   /** @brief Own address 2 enable */
        [1] = 0x00008000U   /** @brief Own address 1 enable */
      }
    };

    /**********************************************************************************************
     * @section GPIOA Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOA Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOA_MODER_PTR   = (RW_ uint32_t*)0x58020000U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOA_OTYPER_PTR  = (RW_ uint32_t*)0x58020004U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOA_OSPEEDR_PTR = (RW_ uint32_t*)0x58020008U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOA_PUPDR_PTR   = (RW_ uint32_t*)0x5802000CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOA_IDR_PTR     = (RO_ uint32_t*)0x58020010U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOA_ODR_PTR     = (RW_ uint32_t*)0x58020014U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOA_BSRR_PTR    = (RW_ uint32_t*)0x58020018U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOA_LCKR_PTR    = (RW_ uint32_t*)0x5802001CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOA_AFRL_PTR    = (RW_ uint32_t*)0x58020020U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOA_AFRH_PTR    = (RW_ uint32_t*)0x58020024U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOA Register Reset Value Definitions ****/

    static const uint32_t GPIOA_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOA_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOA_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOA_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOA_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOA_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOA_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOA_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOA_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOA_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOA Register Value Type Definitions ****/

    typedef uint32_t GPIOA_MODER_vt;     /** @brief GPIOA_MODER register value type. */
    typedef uint32_t GPIOA_OTYPER_vt;    /** @brief GPIOA_OTYPER register value type. */
    typedef uint32_t GPIOA_OSPEEDR_vt;   /** @brief GPIOA_OSPEEDR register value type. */
    typedef uint32_t GPIOA_PUPDR_vt;     /** @brief GPIOA_PUPDR register value type. */
    typedef uint32_t GPIOA_IDR_vt;       /** @brief GPIOA_IDR register value type. */
    typedef uint32_t GPIOA_ODR_vt;       /** @brief GPIOA_ODR register value type. */
    typedef uint32_t GPIOA_BSRR_vt;      /** @brief GPIOA_BSRR register value type. */
    typedef uint32_t GPIOA_LCKR_vt;      /** @brief GPIOA_LCKR register value type. */
    typedef uint32_t GPIOA_AFRL_vt;      /** @brief GPIOA_AFRL register value type. */
    typedef uint32_t GPIOA_AFRH_vt;      /** @brief GPIOA_AFRH register value type. */

    /**** @subsection GPIOA Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOA_MODER_pt;     /** @brief GPIOA_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_OTYPER_pt;    /** @brief GPIOA_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_OSPEEDR_pt;   /** @brief GPIOA_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_PUPDR_pt;     /** @brief GPIOA_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOA_IDR_pt;       /** @brief GPIOA_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_ODR_pt;       /** @brief GPIOA_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_BSRR_pt;      /** @brief GPIOA_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_LCKR_pt;      /** @brief GPIOA_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_AFRL_pt;      /** @brief GPIOA_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOA_AFRH_pt;      /** @brief GPIOA_AFRH pointer register pointer type. */

    /**** @subsection GPIOA Field Mask Definitions ****/

    static const uint32_t GPIOA_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOA_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOA_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOA_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOA_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOA_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOA_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOA_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOA_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOA_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOB Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOB Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOB_MODER_PTR   = (RW_ uint32_t*)0x58020400U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOB_OTYPER_PTR  = (RW_ uint32_t*)0x58020404U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOB_OSPEEDR_PTR = (RW_ uint32_t*)0x58020408U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOB_PUPDR_PTR   = (RW_ uint32_t*)0x5802040CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOB_IDR_PTR     = (RO_ uint32_t*)0x58020410U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOB_ODR_PTR     = (RW_ uint32_t*)0x58020414U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOB_BSRR_PTR    = (RW_ uint32_t*)0x58020418U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOB_LCKR_PTR    = (RW_ uint32_t*)0x5802041CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOB_AFRL_PTR    = (RW_ uint32_t*)0x58020420U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOB_AFRH_PTR    = (RW_ uint32_t*)0x58020424U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOB Register Reset Value Definitions ****/

    static const uint32_t GPIOB_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOB_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOB_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOB_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOB_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOB_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOB_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOB_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOB_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOB_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOB Register Value Type Definitions ****/

    typedef uint32_t GPIOB_MODER_vt;     /** @brief GPIOB_MODER register value type. */
    typedef uint32_t GPIOB_OTYPER_vt;    /** @brief GPIOB_OTYPER register value type. */
    typedef uint32_t GPIOB_OSPEEDR_vt;   /** @brief GPIOB_OSPEEDR register value type. */
    typedef uint32_t GPIOB_PUPDR_vt;     /** @brief GPIOB_PUPDR register value type. */
    typedef uint32_t GPIOB_IDR_vt;       /** @brief GPIOB_IDR register value type. */
    typedef uint32_t GPIOB_ODR_vt;       /** @brief GPIOB_ODR register value type. */
    typedef uint32_t GPIOB_BSRR_vt;      /** @brief GPIOB_BSRR register value type. */
    typedef uint32_t GPIOB_LCKR_vt;      /** @brief GPIOB_LCKR register value type. */
    typedef uint32_t GPIOB_AFRL_vt;      /** @brief GPIOB_AFRL register value type. */
    typedef uint32_t GPIOB_AFRH_vt;      /** @brief GPIOB_AFRH register value type. */

    /**** @subsection GPIOB Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOB_MODER_pt;     /** @brief GPIOB_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_OTYPER_pt;    /** @brief GPIOB_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_OSPEEDR_pt;   /** @brief GPIOB_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_PUPDR_pt;     /** @brief GPIOB_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOB_IDR_pt;       /** @brief GPIOB_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_ODR_pt;       /** @brief GPIOB_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_BSRR_pt;      /** @brief GPIOB_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_LCKR_pt;      /** @brief GPIOB_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_AFRL_pt;      /** @brief GPIOB_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOB_AFRH_pt;      /** @brief GPIOB_AFRH pointer register pointer type. */

    /**** @subsection GPIOB Field Mask Definitions ****/

    static const uint32_t GPIOB_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOB_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOB_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOB_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOB_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOB_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOB_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOB_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOB_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOB_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOC Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOC Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOC_MODER_PTR   = (RW_ uint32_t*)0x58020800U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOC_OTYPER_PTR  = (RW_ uint32_t*)0x58020804U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOC_OSPEEDR_PTR = (RW_ uint32_t*)0x58020808U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOC_PUPDR_PTR   = (RW_ uint32_t*)0x5802080CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOC_IDR_PTR     = (RO_ uint32_t*)0x58020810U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOC_ODR_PTR     = (RW_ uint32_t*)0x58020814U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOC_BSRR_PTR    = (RW_ uint32_t*)0x58020818U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOC_LCKR_PTR    = (RW_ uint32_t*)0x5802081CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOC_AFRL_PTR    = (RW_ uint32_t*)0x58020820U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOC_AFRH_PTR    = (RW_ uint32_t*)0x58020824U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOC Register Reset Value Definitions ****/

    static const uint32_t GPIOC_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOC_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOC_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOC_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOC_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOC_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOC_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOC_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOC_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOC_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOC Register Value Type Definitions ****/

    typedef uint32_t GPIOC_MODER_vt;     /** @brief GPIOC_MODER register value type. */
    typedef uint32_t GPIOC_OTYPER_vt;    /** @brief GPIOC_OTYPER register value type. */
    typedef uint32_t GPIOC_OSPEEDR_vt;   /** @brief GPIOC_OSPEEDR register value type. */
    typedef uint32_t GPIOC_PUPDR_vt;     /** @brief GPIOC_PUPDR register value type. */
    typedef uint32_t GPIOC_IDR_vt;       /** @brief GPIOC_IDR register value type. */
    typedef uint32_t GPIOC_ODR_vt;       /** @brief GPIOC_ODR register value type. */
    typedef uint32_t GPIOC_BSRR_vt;      /** @brief GPIOC_BSRR register value type. */
    typedef uint32_t GPIOC_LCKR_vt;      /** @brief GPIOC_LCKR register value type. */
    typedef uint32_t GPIOC_AFRL_vt;      /** @brief GPIOC_AFRL register value type. */
    typedef uint32_t GPIOC_AFRH_vt;      /** @brief GPIOC_AFRH register value type. */

    /**** @subsection GPIOC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOC_MODER_pt;     /** @brief GPIOC_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_OTYPER_pt;    /** @brief GPIOC_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_OSPEEDR_pt;   /** @brief GPIOC_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_PUPDR_pt;     /** @brief GPIOC_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOC_IDR_pt;       /** @brief GPIOC_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_ODR_pt;       /** @brief GPIOC_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_BSRR_pt;      /** @brief GPIOC_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_LCKR_pt;      /** @brief GPIOC_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_AFRL_pt;      /** @brief GPIOC_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOC_AFRH_pt;      /** @brief GPIOC_AFRH pointer register pointer type. */

    /**** @subsection GPIOC Field Mask Definitions ****/

    static const uint32_t GPIOC_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOC_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOC_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOC_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOC_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOC_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOC_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOC_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOC_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOC_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOD Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOD Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOD_MODER_PTR   = (RW_ uint32_t*)0x58020C00U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOD_OTYPER_PTR  = (RW_ uint32_t*)0x58020C04U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOD_OSPEEDR_PTR = (RW_ uint32_t*)0x58020C08U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOD_PUPDR_PTR   = (RW_ uint32_t*)0x58020C0CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOD_IDR_PTR     = (RO_ uint32_t*)0x58020C10U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOD_ODR_PTR     = (RW_ uint32_t*)0x58020C14U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOD_BSRR_PTR    = (RW_ uint32_t*)0x58020C18U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOD_LCKR_PTR    = (RW_ uint32_t*)0x58020C1CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOD_AFRL_PTR    = (RW_ uint32_t*)0x58020C20U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOD_AFRH_PTR    = (RW_ uint32_t*)0x58020C24U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOD Register Reset Value Definitions ****/

    static const uint32_t GPIOD_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOD_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOD_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOD_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOD_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOD_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOD_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOD_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOD_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOD_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOD Register Value Type Definitions ****/

    typedef uint32_t GPIOD_MODER_vt;     /** @brief GPIOD_MODER register value type. */
    typedef uint32_t GPIOD_OTYPER_vt;    /** @brief GPIOD_OTYPER register value type. */
    typedef uint32_t GPIOD_OSPEEDR_vt;   /** @brief GPIOD_OSPEEDR register value type. */
    typedef uint32_t GPIOD_PUPDR_vt;     /** @brief GPIOD_PUPDR register value type. */
    typedef uint32_t GPIOD_IDR_vt;       /** @brief GPIOD_IDR register value type. */
    typedef uint32_t GPIOD_ODR_vt;       /** @brief GPIOD_ODR register value type. */
    typedef uint32_t GPIOD_BSRR_vt;      /** @brief GPIOD_BSRR register value type. */
    typedef uint32_t GPIOD_LCKR_vt;      /** @brief GPIOD_LCKR register value type. */
    typedef uint32_t GPIOD_AFRL_vt;      /** @brief GPIOD_AFRL register value type. */
    typedef uint32_t GPIOD_AFRH_vt;      /** @brief GPIOD_AFRH register value type. */

    /**** @subsection GPIOD Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOD_MODER_pt;     /** @brief GPIOD_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_OTYPER_pt;    /** @brief GPIOD_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_OSPEEDR_pt;   /** @brief GPIOD_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_PUPDR_pt;     /** @brief GPIOD_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOD_IDR_pt;       /** @brief GPIOD_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_ODR_pt;       /** @brief GPIOD_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_BSRR_pt;      /** @brief GPIOD_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_LCKR_pt;      /** @brief GPIOD_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_AFRL_pt;      /** @brief GPIOD_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOD_AFRH_pt;      /** @brief GPIOD_AFRH pointer register pointer type. */

    /**** @subsection GPIOD Field Mask Definitions ****/

    static const uint32_t GPIOD_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOD_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOD_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOD_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOD_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOD_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOD_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOD_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOD_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOD_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOE Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOE Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOE_MODER_PTR   = (RW_ uint32_t*)0x58021000U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOE_OTYPER_PTR  = (RW_ uint32_t*)0x58021004U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOE_OSPEEDR_PTR = (RW_ uint32_t*)0x58021008U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOE_PUPDR_PTR   = (RW_ uint32_t*)0x5802100CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOE_IDR_PTR     = (RO_ uint32_t*)0x58021010U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOE_ODR_PTR     = (RW_ uint32_t*)0x58021014U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOE_BSRR_PTR    = (RW_ uint32_t*)0x58021018U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOE_LCKR_PTR    = (RW_ uint32_t*)0x5802101CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOE_AFRL_PTR    = (RW_ uint32_t*)0x58021020U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOE_AFRH_PTR    = (RW_ uint32_t*)0x58021024U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOE Register Reset Value Definitions ****/

    static const uint32_t GPIOE_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOE_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOE_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOE_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOE_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOE_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOE_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOE_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOE_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOE_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOE Register Value Type Definitions ****/

    typedef uint32_t GPIOE_MODER_vt;     /** @brief GPIOE_MODER register value type. */
    typedef uint32_t GPIOE_OTYPER_vt;    /** @brief GPIOE_OTYPER register value type. */
    typedef uint32_t GPIOE_OSPEEDR_vt;   /** @brief GPIOE_OSPEEDR register value type. */
    typedef uint32_t GPIOE_PUPDR_vt;     /** @brief GPIOE_PUPDR register value type. */
    typedef uint32_t GPIOE_IDR_vt;       /** @brief GPIOE_IDR register value type. */
    typedef uint32_t GPIOE_ODR_vt;       /** @brief GPIOE_ODR register value type. */
    typedef uint32_t GPIOE_BSRR_vt;      /** @brief GPIOE_BSRR register value type. */
    typedef uint32_t GPIOE_LCKR_vt;      /** @brief GPIOE_LCKR register value type. */
    typedef uint32_t GPIOE_AFRL_vt;      /** @brief GPIOE_AFRL register value type. */
    typedef uint32_t GPIOE_AFRH_vt;      /** @brief GPIOE_AFRH register value type. */

    /**** @subsection GPIOE Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOE_MODER_pt;     /** @brief GPIOE_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_OTYPER_pt;    /** @brief GPIOE_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_OSPEEDR_pt;   /** @brief GPIOE_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_PUPDR_pt;     /** @brief GPIOE_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOE_IDR_pt;       /** @brief GPIOE_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_ODR_pt;       /** @brief GPIOE_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_BSRR_pt;      /** @brief GPIOE_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_LCKR_pt;      /** @brief GPIOE_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_AFRL_pt;      /** @brief GPIOE_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOE_AFRH_pt;      /** @brief GPIOE_AFRH pointer register pointer type. */

    /**** @subsection GPIOE Field Mask Definitions ****/

    static const uint32_t GPIOE_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOE_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOE_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOE_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOE_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOE_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOE_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOE_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOE_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOE_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOF Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOF Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOF_MODER_PTR   = (RW_ uint32_t*)0x58021400U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOF_OTYPER_PTR  = (RW_ uint32_t*)0x58021404U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOF_OSPEEDR_PTR = (RW_ uint32_t*)0x58021408U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOF_PUPDR_PTR   = (RW_ uint32_t*)0x5802140CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOF_IDR_PTR     = (RO_ uint32_t*)0x58021410U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOF_ODR_PTR     = (RW_ uint32_t*)0x58021414U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOF_BSRR_PTR    = (RW_ uint32_t*)0x58021418U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOF_LCKR_PTR    = (RW_ uint32_t*)0x5802141CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOF_AFRL_PTR    = (RW_ uint32_t*)0x58021420U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOF_AFRH_PTR    = (RW_ uint32_t*)0x58021424U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOF Register Reset Value Definitions ****/

    static const uint32_t GPIOF_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOF_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOF_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOF_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOF_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOF_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOF_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOF_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOF_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOF_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOF Register Value Type Definitions ****/

    typedef uint32_t GPIOF_MODER_vt;     /** @brief GPIOF_MODER register value type. */
    typedef uint32_t GPIOF_OTYPER_vt;    /** @brief GPIOF_OTYPER register value type. */
    typedef uint32_t GPIOF_OSPEEDR_vt;   /** @brief GPIOF_OSPEEDR register value type. */
    typedef uint32_t GPIOF_PUPDR_vt;     /** @brief GPIOF_PUPDR register value type. */
    typedef uint32_t GPIOF_IDR_vt;       /** @brief GPIOF_IDR register value type. */
    typedef uint32_t GPIOF_ODR_vt;       /** @brief GPIOF_ODR register value type. */
    typedef uint32_t GPIOF_BSRR_vt;      /** @brief GPIOF_BSRR register value type. */
    typedef uint32_t GPIOF_LCKR_vt;      /** @brief GPIOF_LCKR register value type. */
    typedef uint32_t GPIOF_AFRL_vt;      /** @brief GPIOF_AFRL register value type. */
    typedef uint32_t GPIOF_AFRH_vt;      /** @brief GPIOF_AFRH register value type. */

    /**** @subsection GPIOF Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOF_MODER_pt;     /** @brief GPIOF_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_OTYPER_pt;    /** @brief GPIOF_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_OSPEEDR_pt;   /** @brief GPIOF_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_PUPDR_pt;     /** @brief GPIOF_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOF_IDR_pt;       /** @brief GPIOF_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_ODR_pt;       /** @brief GPIOF_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_BSRR_pt;      /** @brief GPIOF_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_LCKR_pt;      /** @brief GPIOF_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_AFRL_pt;      /** @brief GPIOF_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOF_AFRH_pt;      /** @brief GPIOF_AFRH pointer register pointer type. */

    /**** @subsection GPIOF Field Mask Definitions ****/

    static const uint32_t GPIOF_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOF_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOF_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOF_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOF_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOF_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOF_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOF_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOF_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOF_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOG Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOG Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOG_MODER_PTR   = (RW_ uint32_t*)0x58021800U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOG_OTYPER_PTR  = (RW_ uint32_t*)0x58021804U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOG_OSPEEDR_PTR = (RW_ uint32_t*)0x58021808U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOG_PUPDR_PTR   = (RW_ uint32_t*)0x5802180CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOG_IDR_PTR     = (RO_ uint32_t*)0x58021810U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOG_ODR_PTR     = (RW_ uint32_t*)0x58021814U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOG_BSRR_PTR    = (RW_ uint32_t*)0x58021818U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOG_LCKR_PTR    = (RW_ uint32_t*)0x5802181CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOG_AFRL_PTR    = (RW_ uint32_t*)0x58021820U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOG_AFRH_PTR    = (RW_ uint32_t*)0x58021824U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOG Register Reset Value Definitions ****/

    static const uint32_t GPIOG_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOG_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOG_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOG_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOG_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOG_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOG_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOG_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOG_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOG_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOG Register Value Type Definitions ****/

    typedef uint32_t GPIOG_MODER_vt;     /** @brief GPIOG_MODER register value type. */
    typedef uint32_t GPIOG_OTYPER_vt;    /** @brief GPIOG_OTYPER register value type. */
    typedef uint32_t GPIOG_OSPEEDR_vt;   /** @brief GPIOG_OSPEEDR register value type. */
    typedef uint32_t GPIOG_PUPDR_vt;     /** @brief GPIOG_PUPDR register value type. */
    typedef uint32_t GPIOG_IDR_vt;       /** @brief GPIOG_IDR register value type. */
    typedef uint32_t GPIOG_ODR_vt;       /** @brief GPIOG_ODR register value type. */
    typedef uint32_t GPIOG_BSRR_vt;      /** @brief GPIOG_BSRR register value type. */
    typedef uint32_t GPIOG_LCKR_vt;      /** @brief GPIOG_LCKR register value type. */
    typedef uint32_t GPIOG_AFRL_vt;      /** @brief GPIOG_AFRL register value type. */
    typedef uint32_t GPIOG_AFRH_vt;      /** @brief GPIOG_AFRH register value type. */

    /**** @subsection GPIOG Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOG_MODER_pt;     /** @brief GPIOG_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_OTYPER_pt;    /** @brief GPIOG_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_OSPEEDR_pt;   /** @brief GPIOG_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_PUPDR_pt;     /** @brief GPIOG_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOG_IDR_pt;       /** @brief GPIOG_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_ODR_pt;       /** @brief GPIOG_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_BSRR_pt;      /** @brief GPIOG_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_LCKR_pt;      /** @brief GPIOG_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_AFRL_pt;      /** @brief GPIOG_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOG_AFRH_pt;      /** @brief GPIOG_AFRH pointer register pointer type. */

    /**** @subsection GPIOG Field Mask Definitions ****/

    static const uint32_t GPIOG_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOG_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOG_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOG_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOG_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOG_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOG_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOG_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOG_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOG_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOH Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOH Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOH_MODER_PTR   = (RW_ uint32_t*)0x58021C00U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOH_OTYPER_PTR  = (RW_ uint32_t*)0x58021C04U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOH_OSPEEDR_PTR = (RW_ uint32_t*)0x58021C08U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOH_PUPDR_PTR   = (RW_ uint32_t*)0x58021C0CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOH_IDR_PTR     = (RO_ uint32_t*)0x58021C10U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOH_ODR_PTR     = (RW_ uint32_t*)0x58021C14U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOH_BSRR_PTR    = (RW_ uint32_t*)0x58021C18U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOH_LCKR_PTR    = (RW_ uint32_t*)0x58021C1CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOH_AFRL_PTR    = (RW_ uint32_t*)0x58021C20U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOH_AFRH_PTR    = (RW_ uint32_t*)0x58021C24U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOH Register Reset Value Definitions ****/

    static const uint32_t GPIOH_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOH_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOH_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOH_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOH_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOH_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOH_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOH_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOH_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOH_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOH Register Value Type Definitions ****/

    typedef uint32_t GPIOH_MODER_vt;     /** @brief GPIOH_MODER register value type. */
    typedef uint32_t GPIOH_OTYPER_vt;    /** @brief GPIOH_OTYPER register value type. */
    typedef uint32_t GPIOH_OSPEEDR_vt;   /** @brief GPIOH_OSPEEDR register value type. */
    typedef uint32_t GPIOH_PUPDR_vt;     /** @brief GPIOH_PUPDR register value type. */
    typedef uint32_t GPIOH_IDR_vt;       /** @brief GPIOH_IDR register value type. */
    typedef uint32_t GPIOH_ODR_vt;       /** @brief GPIOH_ODR register value type. */
    typedef uint32_t GPIOH_BSRR_vt;      /** @brief GPIOH_BSRR register value type. */
    typedef uint32_t GPIOH_LCKR_vt;      /** @brief GPIOH_LCKR register value type. */
    typedef uint32_t GPIOH_AFRL_vt;      /** @brief GPIOH_AFRL register value type. */
    typedef uint32_t GPIOH_AFRH_vt;      /** @brief GPIOH_AFRH register value type. */

    /**** @subsection GPIOH Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOH_MODER_pt;     /** @brief GPIOH_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_OTYPER_pt;    /** @brief GPIOH_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_OSPEEDR_pt;   /** @brief GPIOH_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_PUPDR_pt;     /** @brief GPIOH_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOH_IDR_pt;       /** @brief GPIOH_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_ODR_pt;       /** @brief GPIOH_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_BSRR_pt;      /** @brief GPIOH_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_LCKR_pt;      /** @brief GPIOH_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_AFRL_pt;      /** @brief GPIOH_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOH_AFRH_pt;      /** @brief GPIOH_AFRH pointer register pointer type. */

    /**** @subsection GPIOH Field Mask Definitions ****/

    static const uint32_t GPIOH_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOH_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOH_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOH_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOH_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOH_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOH_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOH_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOH_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOH_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOI Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOI Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOI_MODER_PTR   = (RW_ uint32_t*)0x58022000U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOI_OTYPER_PTR  = (RW_ uint32_t*)0x58022004U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOI_OSPEEDR_PTR = (RW_ uint32_t*)0x58022008U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOI_PUPDR_PTR   = (RW_ uint32_t*)0x5802200CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOI_IDR_PTR     = (RO_ uint32_t*)0x58022010U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOI_ODR_PTR     = (RW_ uint32_t*)0x58022014U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOI_BSRR_PTR    = (RW_ uint32_t*)0x58022018U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOI_LCKR_PTR    = (RW_ uint32_t*)0x5802201CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOI_AFRL_PTR    = (RW_ uint32_t*)0x58022020U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOI_AFRH_PTR    = (RW_ uint32_t*)0x58022024U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOI Register Reset Value Definitions ****/

    static const uint32_t GPIOI_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOI_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOI_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOI_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOI_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOI_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOI_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOI_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOI_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOI_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOI Register Value Type Definitions ****/

    typedef uint32_t GPIOI_MODER_vt;     /** @brief GPIOI_MODER register value type. */
    typedef uint32_t GPIOI_OTYPER_vt;    /** @brief GPIOI_OTYPER register value type. */
    typedef uint32_t GPIOI_OSPEEDR_vt;   /** @brief GPIOI_OSPEEDR register value type. */
    typedef uint32_t GPIOI_PUPDR_vt;     /** @brief GPIOI_PUPDR register value type. */
    typedef uint32_t GPIOI_IDR_vt;       /** @brief GPIOI_IDR register value type. */
    typedef uint32_t GPIOI_ODR_vt;       /** @brief GPIOI_ODR register value type. */
    typedef uint32_t GPIOI_BSRR_vt;      /** @brief GPIOI_BSRR register value type. */
    typedef uint32_t GPIOI_LCKR_vt;      /** @brief GPIOI_LCKR register value type. */
    typedef uint32_t GPIOI_AFRL_vt;      /** @brief GPIOI_AFRL register value type. */
    typedef uint32_t GPIOI_AFRH_vt;      /** @brief GPIOI_AFRH register value type. */

    /**** @subsection GPIOI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOI_MODER_pt;     /** @brief GPIOI_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_OTYPER_pt;    /** @brief GPIOI_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_OSPEEDR_pt;   /** @brief GPIOI_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_PUPDR_pt;     /** @brief GPIOI_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOI_IDR_pt;       /** @brief GPIOI_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_ODR_pt;       /** @brief GPIOI_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_BSRR_pt;      /** @brief GPIOI_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_LCKR_pt;      /** @brief GPIOI_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_AFRL_pt;      /** @brief GPIOI_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOI_AFRH_pt;      /** @brief GPIOI_AFRH pointer register pointer type. */

    /**** @subsection GPIOI Field Mask Definitions ****/

    static const uint32_t GPIOI_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOI_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOI_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOI_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOI_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOI_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOI_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOI_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOI_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOI_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOJ Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOJ Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOJ_MODER_PTR   = (RW_ uint32_t*)0x58022400U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOJ_OTYPER_PTR  = (RW_ uint32_t*)0x58022404U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOJ_OSPEEDR_PTR = (RW_ uint32_t*)0x58022408U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOJ_PUPDR_PTR   = (RW_ uint32_t*)0x5802240CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOJ_IDR_PTR     = (RO_ uint32_t*)0x58022410U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOJ_ODR_PTR     = (RW_ uint32_t*)0x58022414U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOJ_BSRR_PTR    = (RW_ uint32_t*)0x58022418U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOJ_LCKR_PTR    = (RW_ uint32_t*)0x5802241CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOJ_AFRL_PTR    = (RW_ uint32_t*)0x58022420U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOJ_AFRH_PTR    = (RW_ uint32_t*)0x58022424U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOJ Register Reset Value Definitions ****/

    static const uint32_t GPIOJ_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOJ_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOJ_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOJ_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOJ_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOJ_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOJ_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOJ_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOJ_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOJ_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOJ Register Value Type Definitions ****/

    typedef uint32_t GPIOJ_MODER_vt;     /** @brief GPIOJ_MODER register value type. */
    typedef uint32_t GPIOJ_OTYPER_vt;    /** @brief GPIOJ_OTYPER register value type. */
    typedef uint32_t GPIOJ_OSPEEDR_vt;   /** @brief GPIOJ_OSPEEDR register value type. */
    typedef uint32_t GPIOJ_PUPDR_vt;     /** @brief GPIOJ_PUPDR register value type. */
    typedef uint32_t GPIOJ_IDR_vt;       /** @brief GPIOJ_IDR register value type. */
    typedef uint32_t GPIOJ_ODR_vt;       /** @brief GPIOJ_ODR register value type. */
    typedef uint32_t GPIOJ_BSRR_vt;      /** @brief GPIOJ_BSRR register value type. */
    typedef uint32_t GPIOJ_LCKR_vt;      /** @brief GPIOJ_LCKR register value type. */
    typedef uint32_t GPIOJ_AFRL_vt;      /** @brief GPIOJ_AFRL register value type. */
    typedef uint32_t GPIOJ_AFRH_vt;      /** @brief GPIOJ_AFRH register value type. */

    /**** @subsection GPIOJ Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOJ_MODER_pt;     /** @brief GPIOJ_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_OTYPER_pt;    /** @brief GPIOJ_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_OSPEEDR_pt;   /** @brief GPIOJ_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_PUPDR_pt;     /** @brief GPIOJ_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOJ_IDR_pt;       /** @brief GPIOJ_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_ODR_pt;       /** @brief GPIOJ_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_BSRR_pt;      /** @brief GPIOJ_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_LCKR_pt;      /** @brief GPIOJ_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_AFRL_pt;      /** @brief GPIOJ_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOJ_AFRH_pt;      /** @brief GPIOJ_AFRH pointer register pointer type. */

    /**** @subsection GPIOJ Field Mask Definitions ****/

    static const uint32_t GPIOJ_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOJ_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOJ_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOJ_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOJ_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOJ_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOJ_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOJ_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOJ_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOJ_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section GPIOK Register Definitions
     **********************************************************************************************/

    /**** @subsection GPIOK Register Pointer Definitions ****/

    static RW_ uint32_t* const GPIOK_MODER_PTR   = (RW_ uint32_t*)0x58022800U;   /** @brief GPIO port mode register */
    static RW_ uint32_t* const GPIOK_OTYPER_PTR  = (RW_ uint32_t*)0x58022804U;   /** @brief GPIO port output type register */
    static RW_ uint32_t* const GPIOK_OSPEEDR_PTR = (RW_ uint32_t*)0x58022808U;   /** @brief GPIO port output speed register */
    static RW_ uint32_t* const GPIOK_PUPDR_PTR   = (RW_ uint32_t*)0x5802280CU;   /** @brief GPIO port pull-up/pull-down register */
    static RO_ uint32_t* const GPIOK_IDR_PTR     = (RO_ uint32_t*)0x58022810U;   /** @brief GPIO port input data register */
    static RW_ uint32_t* const GPIOK_ODR_PTR     = (RW_ uint32_t*)0x58022814U;   /** @brief GPIO port output data register */
    static RW_ uint32_t* const GPIOK_BSRR_PTR    = (RW_ uint32_t*)0x58022818U;   /** @brief GPIO port bit set/reset register */
    static RW_ uint32_t* const GPIOK_LCKR_PTR    = (RW_ uint32_t*)0x5802281CU;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static RW_ uint32_t* const GPIOK_AFRL_PTR    = (RW_ uint32_t*)0x58022820U;   /** @brief GPIO alternate function low register */
    static RW_ uint32_t* const GPIOK_AFRH_PTR    = (RW_ uint32_t*)0x58022824U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOK Register Reset Value Definitions ****/

    static const uint32_t GPIOK_MODER_RST   = 0xABFFFFFFU;   /** @brief GPIO port mode register */
    static const uint32_t GPIOK_OTYPER_RST  = 0x00000000U;   /** @brief GPIO port output type register */
    static const uint32_t GPIOK_OSPEEDR_RST = 0x0C000000U;   /** @brief GPIO port output speed register */
    static const uint32_t GPIOK_PUPDR_RST   = 0x12100000U;   /** @brief GPIO port pull-up/pull-down register */
    static const uint32_t GPIOK_IDR_RST     = 0x00000000U;   /** @brief GPIO port input data register */
    static const uint32_t GPIOK_ODR_RST     = 0x00000000U;   /** @brief GPIO port output data register */
    static const uint32_t GPIOK_BSRR_RST    = 0x00000000U;   /** @brief GPIO port bit set/reset register */
    static const uint32_t GPIOK_LCKR_RST    = 0x00000000U;   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    static const uint32_t GPIOK_AFRL_RST    = 0x00000000U;   /** @brief GPIO alternate function low register */
    static const uint32_t GPIOK_AFRH_RST    = 0x00000000U;   /** @brief GPIO alternate function high register */

    /**** @subsection GPIOK Register Value Type Definitions ****/

    typedef uint32_t GPIOK_MODER_vt;     /** @brief GPIOK_MODER register value type. */
    typedef uint32_t GPIOK_OTYPER_vt;    /** @brief GPIOK_OTYPER register value type. */
    typedef uint32_t GPIOK_OSPEEDR_vt;   /** @brief GPIOK_OSPEEDR register value type. */
    typedef uint32_t GPIOK_PUPDR_vt;     /** @brief GPIOK_PUPDR register value type. */
    typedef uint32_t GPIOK_IDR_vt;       /** @brief GPIOK_IDR register value type. */
    typedef uint32_t GPIOK_ODR_vt;       /** @brief GPIOK_ODR register value type. */
    typedef uint32_t GPIOK_BSRR_vt;      /** @brief GPIOK_BSRR register value type. */
    typedef uint32_t GPIOK_LCKR_vt;      /** @brief GPIOK_LCKR register value type. */
    typedef uint32_t GPIOK_AFRL_vt;      /** @brief GPIOK_AFRL register value type. */
    typedef uint32_t GPIOK_AFRH_vt;      /** @brief GPIOK_AFRH register value type. */

    /**** @subsection GPIOK Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* GPIOK_MODER_pt;     /** @brief GPIOK_MODER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_OTYPER_pt;    /** @brief GPIOK_OTYPER pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_OSPEEDR_pt;   /** @brief GPIOK_OSPEEDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_PUPDR_pt;     /** @brief GPIOK_PUPDR pointer register pointer type. */
    typedef RO_ uint32_t* GPIOK_IDR_pt;       /** @brief GPIOK_IDR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_ODR_pt;       /** @brief GPIOK_ODR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_BSRR_pt;      /** @brief GPIOK_BSRR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_LCKR_pt;      /** @brief GPIOK_LCKR pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_AFRL_pt;      /** @brief GPIOK_AFRL pointer register pointer type. */
    typedef RW_ uint32_t* GPIOK_AFRH_pt;      /** @brief GPIOK_AFRH pointer register pointer type. */

    /**** @subsection GPIOK Field Mask Definitions ****/

    static const uint32_t GPIOK_LCKR_LCKK_MASK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

    static const uint32_t GPIOK_MODER_MODEx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    };

    static const uint32_t GPIOK_OTYPER_OTx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
      [0]  = 0x00000001U   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    };

    static const uint32_t GPIOK_OSPEEDR_OSPEEDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    };

    static const uint32_t GPIOK_PUPDR_PUPDx_MASK[16] = {
      [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
      [0]  = 0x00000003U   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    };

    static const uint32_t GPIOK_IDR_IDx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
      [0]  = 0x00000001U   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    };

    static const uint32_t GPIOK_ODR_ODx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
      [0]  = 0x00000001U   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    };

    static const uint32_t GPIOK_BSRR_BRx_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
      [0]  = 0x00010000U   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    };

    static const uint32_t GPIOK_AFRL_AFSELx_MASK[8] = {
      [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
      [0] = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    };

    static const uint32_t GPIOK_AFRH_AFSELx_MASK[16] = {
      [9]  = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [10] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [11] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [12] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [13] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [14] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [15] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
      [8]  = 0x0000000FU   /** @brief [3:0]: alternate function selection for port x pin y (y = 8..15) these bits are written by software to configure alternate function i/os */
    };

    /**********************************************************************************************
     * @section JPEG Register Definitions
     **********************************************************************************************/

    /**** @subsection JPEG Register Pointer Definitions ****/

    static RW_ uint32_t* const JPEG_CR_PTR  = (RW_ uint32_t*)0x52003030U;   /** @brief JPEG control register */
    static RO_ uint32_t* const JPEG_SR_PTR  = (RO_ uint32_t*)0x52003034U;   /** @brief JPEG status register */
    static RW_ uint32_t* const JPEG_CFR_PTR = (RW_ uint32_t*)0x52003038U;   /** @brief JPEG clear flag register */
    static RW_ uint32_t* const JPEG_DIR_PTR = (RW_ uint32_t*)0x52003040U;   /** @brief JPEG data input register */
    static RO_ uint32_t* const JPEG_DOR_PTR = (RO_ uint32_t*)0x52003044U;   /** @brief JPEG data output register */

    static RW_ uint32_t* const JPEG_CONFRx_PTR[4] = {
      [1] = (RW_ uint32_t*)0x52003004U,   /** @brief JPEG codec configuration register 1 */
      [2] = (RW_ uint32_t*)0x52003008U,   /** @brief JPEG codec configuration register 2 */
      [3] = (RW_ uint32_t*)0x5200300CU,   /** @brief JPEG codec configuration register 3 */
      [0] = (RW_ uint32_t*)0x52003000U   /** @brief JPEG codec control register */
    };

    static RW_ uint32_t* const JPEG_CONFRNx_PTR[5] = {
      [2] = (RW_ uint32_t*)0x52003014U,   /** @brief JPEG codec configuration register 4-7 */
      [3] = (RW_ uint32_t*)0x52003018U,   /** @brief JPEG codec configuration register 4-7 */
      [4] = (RW_ uint32_t*)0x5200301CU,   /** @brief JPEG codec configuration register 4-7 */
      [1] = (RW_ uint32_t*)0x52003010U   /** @brief JPEG codec configuration register 4-7 */
    };

    /**** @subsection JPEG Register Reset Value Definitions ****/

    static const uint32_t JPEG_CR_RST  = 0x00000000U;   /** @brief JPEG control register */
    static const uint32_t JPEG_SR_RST  = 0x00000006U;   /** @brief JPEG status register */
    static const uint32_t JPEG_CFR_RST = 0x00000000U;   /** @brief JPEG clear flag register */
    static const uint32_t JPEG_DIR_RST = 0x00000000U;   /** @brief JPEG data input register */
    static const uint32_t JPEG_DOR_RST = 0x00000000U;   /** @brief JPEG data output register */

    static const uint32_t JPEG_CONFRx_RST[4] = {
      [1] = 0x00000000U,   /** @brief JPEG codec configuration register 1 */
      [2] = 0x00000000U,   /** @brief JPEG codec configuration register 2 */
      [3] = 0x00000000U,   /** @brief JPEG codec configuration register 3 */
      [0] = 0x00000000U   /** @brief JPEG codec control register */
    };

    static const uint32_t JPEG_CONFRNx_RST[5] = {
      [2] = 0x00000000U,   /** @brief JPEG codec configuration register 4-7 */
      [3] = 0x00000000U,   /** @brief JPEG codec configuration register 4-7 */
      [4] = 0x00000000U,   /** @brief JPEG codec configuration register 4-7 */
      [1] = 0x00000000U   /** @brief JPEG codec configuration register 4-7 */
    };

    /**** @subsection JPEG Register Value Type Definitions ****/

    typedef uint32_t JPEG_CONFRx_vt;    /** @brief JPEG_CONFRx register value type. */
    typedef uint32_t JPEG_CONFRNx_vt;   /** @brief JPEG_CONFRNx register value type. */
    typedef uint32_t JPEG_CR_vt;        /** @brief JPEG_CR register value type. */
    typedef uint32_t JPEG_SR_vt;        /** @brief JPEG_SR register value type. */
    typedef uint32_t JPEG_CFR_vt;       /** @brief JPEG_CFR register value type. */
    typedef uint32_t JPEG_DIR_vt;       /** @brief JPEG_DIR register value type. */
    typedef uint32_t JPEG_DOR_vt;       /** @brief JPEG_DOR register value type. */

    /**** @subsection JPEG Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* JPEG_CONFRx_pt;    /** @brief JPEG_CONFRx pointer register pointer type. */
    typedef RW_ uint32_t* JPEG_CONFRNx_pt;   /** @brief JPEG_CONFRNx pointer register pointer type. */
    typedef RW_ uint32_t* JPEG_CR_pt;        /** @brief JPEG_CR pointer register pointer type. */
    typedef RO_ uint32_t* JPEG_SR_pt;        /** @brief JPEG_SR pointer register pointer type. */
    typedef RW_ uint32_t* JPEG_CFR_pt;       /** @brief JPEG_CFR pointer register pointer type. */
    typedef RW_ uint32_t* JPEG_DIR_pt;       /** @brief JPEG_DIR pointer register pointer type. */
    typedef RO_ uint32_t* JPEG_DOR_pt;       /** @brief JPEG_DOR pointer register pointer type. */

    /**** @subsection JPEG Field Mask Definitions ****/

    static const uint32_t JPEG_CONFRx_START_MASK = 0x00000001U;   /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
    static const uint32_t JPEG_CR_OFF_MASK       = 0x00004000U;   /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
    static const uint32_t JPEG_SR_COF_MASK       = 0x00000080U;   /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
    static const uint32_t JPEG_CFR_CHPDF_MASK    = 0x00000040U;   /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */
    static const uint32_t JPEG_DIR_DATAIN_MASK   = 0xFFFFFFFFU;   /** @brief Data input FIFO input FIFO data register. */
    static const uint32_t JPEG_DOR_DATAOUT_MASK  = 0xFFFFFFFFU;   /** @brief Data output FIFO output FIFO data register. */

    static const uint32_t JPEG_CONFRNx_HSF_MASK[5] = {
      [2] = 0x0000F000U,   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
      [3] = 0x0000F000U,   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
      [4] = 0x0000F000U,   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
      [1] = 0x0000F000U   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
    };

    /**********************************************************************************************
     * @section MDMA Register Definitions
     **********************************************************************************************/

    /**** @subsection MDMA Register Pointer Definitions ****/

    static RO_ uint32_t* const MDMA_MDMA_GISR0_PTR = (RO_ uint32_t*)0x52000000U;   /** @brief MDMA global interrupt/status register */

    static RO_ uint32_t* const MDMA_MDMA_CxISR_PTR[16] = {
      [1]  = (RO_ uint32_t*)0x52000080U,   /** @brief MDMA channel x interrupt/status register */
      [2]  = (RO_ uint32_t*)0x520000C0U,   /** @brief MDMA channel x interrupt/status register */
      [3]  = (RO_ uint32_t*)0x52000100U,   /** @brief MDMA channel x interrupt/status register */
      [4]  = (RO_ uint32_t*)0x52000140U,   /** @brief MDMA channel x interrupt/status register */
      [5]  = (RO_ uint32_t*)0x52000180U,   /** @brief MDMA channel x interrupt/status register */
      [6]  = (RO_ uint32_t*)0x520001C0U,   /** @brief MDMA channel x interrupt/status register */
      [7]  = (RO_ uint32_t*)0x52000200U,   /** @brief MDMA channel x interrupt/status register */
      [8]  = (RO_ uint32_t*)0x52000240U,   /** @brief MDMA channel x interrupt/status register */
      [9]  = (RO_ uint32_t*)0x52000280U,   /** @brief MDMA channel x interrupt/status register */
      [10] = (RO_ uint32_t*)0x520002C0U,   /** @brief MDMA channel x interrupt/status register */
      [11] = (RO_ uint32_t*)0x52000300U,   /** @brief MDMA channel x interrupt/status register */
      [12] = (RO_ uint32_t*)0x52000340U,   /** @brief MDMA channel x interrupt/status register */
      [13] = (RO_ uint32_t*)0x52000380U,   /** @brief MDMA channel x interrupt/status register */
      [14] = (RO_ uint32_t*)0x520003C0U,   /** @brief MDMA channel x interrupt/status register */
      [15] = (RO_ uint32_t*)0x52000400U,   /** @brief MDMA channel x interrupt/status register */
      [0]  = (RO_ uint32_t*)0x52000040U   /** @brief MDMA channel x interrupt/status register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxIFCR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x52000084U,   /** @brief MDMA channel x interrupt flag clear register */
      [2]  = (RW_ uint32_t*)0x520000C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [3]  = (RW_ uint32_t*)0x52000104U,   /** @brief MDMA channel x interrupt flag clear register */
      [4]  = (RW_ uint32_t*)0x52000144U,   /** @brief MDMA channel x interrupt flag clear register */
      [5]  = (RW_ uint32_t*)0x52000184U,   /** @brief MDMA channel x interrupt flag clear register */
      [6]  = (RW_ uint32_t*)0x520001C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [7]  = (RW_ uint32_t*)0x52000204U,   /** @brief MDMA channel x interrupt flag clear register */
      [8]  = (RW_ uint32_t*)0x52000244U,   /** @brief MDMA channel x interrupt flag clear register */
      [9]  = (RW_ uint32_t*)0x52000284U,   /** @brief MDMA channel x interrupt flag clear register */
      [10] = (RW_ uint32_t*)0x520002C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [11] = (RW_ uint32_t*)0x52000304U,   /** @brief MDMA channel x interrupt flag clear register */
      [12] = (RW_ uint32_t*)0x52000344U,   /** @brief MDMA channel x interrupt flag clear register */
      [13] = (RW_ uint32_t*)0x52000384U,   /** @brief MDMA channel x interrupt flag clear register */
      [14] = (RW_ uint32_t*)0x520003C4U,   /** @brief MDMA channel x interrupt flag clear register */
      [15] = (RW_ uint32_t*)0x52000404U,   /** @brief MDMA channel x interrupt flag clear register */
      [0]  = (RW_ uint32_t*)0x52000044U   /** @brief MDMA channel x interrupt flag clear register */
    };

    static RO_ uint32_t* const MDMA_MDMA_CxESR_PTR[16] = {
      [1]  = (RO_ uint32_t*)0x52000088U,   /** @brief MDMA channel x error status register */
      [2]  = (RO_ uint32_t*)0x520000C8U,   /** @brief MDMA channel x error status register */
      [3]  = (RO_ uint32_t*)0x52000108U,   /** @brief MDMA channel x error status register */
      [4]  = (RO_ uint32_t*)0x52000148U,   /** @brief MDMA channel x error status register */
      [5]  = (RO_ uint32_t*)0x52000188U,   /** @brief MDMA channel x error status register */
      [6]  = (RO_ uint32_t*)0x520001C8U,   /** @brief MDMA channel x error status register */
      [7]  = (RO_ uint32_t*)0x52000208U,   /** @brief MDMA channel x error status register */
      [8]  = (RO_ uint32_t*)0x52000248U,   /** @brief MDMA channel x error status register */
      [9]  = (RO_ uint32_t*)0x52000288U,   /** @brief MDMA channel x error status register */
      [10] = (RO_ uint32_t*)0x520002C8U,   /** @brief MDMA channel x error status register */
      [11] = (RO_ uint32_t*)0x52000308U,   /** @brief MDMA channel x error status register */
      [12] = (RO_ uint32_t*)0x52000348U,   /** @brief MDMA channel x error status register */
      [13] = (RO_ uint32_t*)0x52000388U,   /** @brief MDMA channel x error status register */
      [14] = (RO_ uint32_t*)0x520003C8U,   /** @brief MDMA channel x error status register */
      [15] = (RO_ uint32_t*)0x52000408U,   /** @brief MDMA channel x error status register */
      [0]  = (RO_ uint32_t*)0x52000048U   /** @brief MDMA channel x error status register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxCR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x5200008CU,   /** @brief This register is used to control the concerned channel. */
      [2]  = (RW_ uint32_t*)0x520000CCU,   /** @brief This register is used to control the concerned channel. */
      [3]  = (RW_ uint32_t*)0x5200010CU,   /** @brief This register is used to control the concerned channel. */
      [4]  = (RW_ uint32_t*)0x5200014CU,   /** @brief This register is used to control the concerned channel. */
      [5]  = (RW_ uint32_t*)0x5200018CU,   /** @brief This register is used to control the concerned channel. */
      [6]  = (RW_ uint32_t*)0x520001CCU,   /** @brief This register is used to control the concerned channel. */
      [7]  = (RW_ uint32_t*)0x5200020CU,   /** @brief This register is used to control the concerned channel. */
      [8]  = (RW_ uint32_t*)0x5200024CU,   /** @brief This register is used to control the concerned channel. */
      [9]  = (RW_ uint32_t*)0x5200028CU,   /** @brief This register is used to control the concerned channel. */
      [10] = (RW_ uint32_t*)0x520002CCU,   /** @brief This register is used to control the concerned channel. */
      [11] = (RW_ uint32_t*)0x5200030CU,   /** @brief This register is used to control the concerned channel. */
      [12] = (RW_ uint32_t*)0x5200034CU,   /** @brief This register is used to control the concerned channel. */
      [13] = (RW_ uint32_t*)0x5200038CU,   /** @brief This register is used to control the concerned channel. */
      [14] = (RW_ uint32_t*)0x520003CCU,   /** @brief This register is used to control the concerned channel. */
      [15] = (RW_ uint32_t*)0x5200040CU,   /** @brief This register is used to control the concerned channel. */
      [0]  = (RW_ uint32_t*)0x5200004CU   /** @brief This register is used to control the concerned channel. */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxTCR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x52000090U,   /** @brief This register is used to configure the concerned channel. */
      [2]  = (RW_ uint32_t*)0x520000D0U,   /** @brief This register is used to configure the concerned channel. */
      [3]  = (RW_ uint32_t*)0x52000110U,   /** @brief This register is used to configure the concerned channel. */
      [4]  = (RW_ uint32_t*)0x52000150U,   /** @brief This register is used to configure the concerned channel. */
      [5]  = (RW_ uint32_t*)0x52000190U,   /** @brief This register is used to configure the concerned channel. */
      [6]  = (RW_ uint32_t*)0x520001D0U,   /** @brief This register is used to configure the concerned channel. */
      [7]  = (RW_ uint32_t*)0x52000210U,   /** @brief This register is used to configure the concerned channel. */
      [8]  = (RW_ uint32_t*)0x52000250U,   /** @brief This register is used to configure the concerned channel. */
      [9]  = (RW_ uint32_t*)0x52000290U,   /** @brief This register is used to configure the concerned channel. */
      [10] = (RW_ uint32_t*)0x520002D0U,   /** @brief This register is used to configure the concerned channel. */
      [11] = (RW_ uint32_t*)0x52000310U,   /** @brief This register is used to configure the concerned channel. */
      [12] = (RW_ uint32_t*)0x52000350U,   /** @brief This register is used to configure the concerned channel. */
      [13] = (RW_ uint32_t*)0x52000390U,   /** @brief This register is used to configure the concerned channel. */
      [14] = (RW_ uint32_t*)0x520003D0U,   /** @brief This register is used to configure the concerned channel. */
      [15] = (RW_ uint32_t*)0x52000410U,   /** @brief This register is used to configure the concerned channel. */
      [0]  = (RW_ uint32_t*)0x52000050U   /** @brief This register is used to configure the concerned channel. */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxBNDTR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x52000094U,   /** @brief MDMA channel x block number of data register */
      [2]  = (RW_ uint32_t*)0x520000D4U,   /** @brief MDMA channel x block number of data register */
      [3]  = (RW_ uint32_t*)0x52000114U,   /** @brief MDMA channel x block number of data register */
      [4]  = (RW_ uint32_t*)0x52000154U,   /** @brief MDMA channel x block number of data register */
      [5]  = (RW_ uint32_t*)0x52000194U,   /** @brief MDMA channel x block number of data register */
      [6]  = (RW_ uint32_t*)0x520001D4U,   /** @brief MDMA channel x block number of data register */
      [7]  = (RW_ uint32_t*)0x52000214U,   /** @brief MDMA channel x block number of data register */
      [8]  = (RW_ uint32_t*)0x52000254U,   /** @brief MDMA channel x block number of data register */
      [9]  = (RW_ uint32_t*)0x52000294U,   /** @brief MDMA channel x block number of data register */
      [10] = (RW_ uint32_t*)0x520002D4U,   /** @brief MDMA channel x block number of data register */
      [11] = (RW_ uint32_t*)0x52000314U,   /** @brief MDMA channel x block number of data register */
      [12] = (RW_ uint32_t*)0x52000354U,   /** @brief MDMA channel x block number of data register */
      [13] = (RW_ uint32_t*)0x52000394U,   /** @brief MDMA channel x block number of data register */
      [14] = (RW_ uint32_t*)0x520003D4U,   /** @brief MDMA channel x block number of data register */
      [15] = (RW_ uint32_t*)0x52000414U,   /** @brief MDMA channel x block number of data register */
      [0]  = (RW_ uint32_t*)0x52000054U   /** @brief MDMA channel x block number of data register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxSAR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x52000098U,   /** @brief MDMA channel x source address register */
      [2]  = (RW_ uint32_t*)0x520000D8U,   /** @brief MDMA channel x source address register */
      [3]  = (RW_ uint32_t*)0x52000118U,   /** @brief MDMA channel x source address register */
      [4]  = (RW_ uint32_t*)0x52000158U,   /** @brief MDMA channel x source address register */
      [5]  = (RW_ uint32_t*)0x52000198U,   /** @brief MDMA channel x source address register */
      [6]  = (RW_ uint32_t*)0x520001D8U,   /** @brief MDMA channel x source address register */
      [7]  = (RW_ uint32_t*)0x52000218U,   /** @brief MDMA channel x source address register */
      [8]  = (RW_ uint32_t*)0x52000258U,   /** @brief MDMA channel x source address register */
      [9]  = (RW_ uint32_t*)0x52000298U,   /** @brief MDMA channel x source address register */
      [10] = (RW_ uint32_t*)0x520002D8U,   /** @brief MDMA channel x source address register */
      [11] = (RW_ uint32_t*)0x52000318U,   /** @brief MDMA channel x source address register */
      [12] = (RW_ uint32_t*)0x52000358U,   /** @brief MDMA channel x source address register */
      [13] = (RW_ uint32_t*)0x52000398U,   /** @brief MDMA channel x source address register */
      [14] = (RW_ uint32_t*)0x520003D8U,   /** @brief MDMA channel x source address register */
      [15] = (RW_ uint32_t*)0x52000418U,   /** @brief MDMA channel x source address register */
      [0]  = (RW_ uint32_t*)0x52000058U   /** @brief MDMA channel x source address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxDAR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x5200009CU,   /** @brief MDMA channel x destination address register */
      [2]  = (RW_ uint32_t*)0x520000DCU,   /** @brief MDMA channel x destination address register */
      [3]  = (RW_ uint32_t*)0x5200011CU,   /** @brief MDMA channel x destination address register */
      [4]  = (RW_ uint32_t*)0x5200015CU,   /** @brief MDMA channel x destination address register */
      [5]  = (RW_ uint32_t*)0x5200019CU,   /** @brief MDMA channel x destination address register */
      [6]  = (RW_ uint32_t*)0x520001DCU,   /** @brief MDMA channel x destination address register */
      [7]  = (RW_ uint32_t*)0x5200021CU,   /** @brief MDMA channel x destination address register */
      [8]  = (RW_ uint32_t*)0x5200025CU,   /** @brief MDMA channel x destination address register */
      [9]  = (RW_ uint32_t*)0x5200029CU,   /** @brief MDMA channel x destination address register */
      [10] = (RW_ uint32_t*)0x520002DCU,   /** @brief MDMA channel x destination address register */
      [11] = (RW_ uint32_t*)0x5200031CU,   /** @brief MDMA channel x destination address register */
      [12] = (RW_ uint32_t*)0x5200035CU,   /** @brief MDMA channel x destination address register */
      [13] = (RW_ uint32_t*)0x5200039CU,   /** @brief MDMA channel x destination address register */
      [14] = (RW_ uint32_t*)0x520003DCU,   /** @brief MDMA channel x destination address register */
      [15] = (RW_ uint32_t*)0x5200041CU,   /** @brief MDMA channel x destination address register */
      [0]  = (RW_ uint32_t*)0x5200005CU   /** @brief MDMA channel x destination address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxBRUR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x520000A0U,   /** @brief MDMA channel x block repeat address update register */
      [2]  = (RW_ uint32_t*)0x520000E0U,   /** @brief MDMA channel x block repeat address update register */
      [3]  = (RW_ uint32_t*)0x52000120U,   /** @brief MDMA channel x block repeat address update register */
      [4]  = (RW_ uint32_t*)0x52000160U,   /** @brief MDMA channel x block repeat address update register */
      [5]  = (RW_ uint32_t*)0x520001A0U,   /** @brief MDMA channel x block repeat address update register */
      [6]  = (RW_ uint32_t*)0x520001E0U,   /** @brief MDMA channel x block repeat address update register */
      [7]  = (RW_ uint32_t*)0x52000220U,   /** @brief MDMA channel x block repeat address update register */
      [8]  = (RW_ uint32_t*)0x52000260U,   /** @brief MDMA channel x block repeat address update register */
      [9]  = (RW_ uint32_t*)0x520002A0U,   /** @brief MDMA channel x block repeat address update register */
      [10] = (RW_ uint32_t*)0x520002E0U,   /** @brief MDMA channel x block repeat address update register */
      [11] = (RW_ uint32_t*)0x52000320U,   /** @brief MDMA channel x block repeat address update register */
      [12] = (RW_ uint32_t*)0x52000360U,   /** @brief MDMA channel x block repeat address update register */
      [13] = (RW_ uint32_t*)0x520003A0U,   /** @brief MDMA channel x block repeat address update register */
      [14] = (RW_ uint32_t*)0x520003E0U,   /** @brief MDMA channel x block repeat address update register */
      [15] = (RW_ uint32_t*)0x52000420U,   /** @brief MDMA channel x block repeat address update register */
      [0]  = (RW_ uint32_t*)0x52000060U   /** @brief MDMA channel x block repeat address update register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxLAR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x520000A4U,   /** @brief MDMA channel x link address register */
      [2]  = (RW_ uint32_t*)0x520000E4U,   /** @brief MDMA channel x link address register */
      [3]  = (RW_ uint32_t*)0x52000124U,   /** @brief MDMA channel x link address register */
      [4]  = (RW_ uint32_t*)0x52000164U,   /** @brief MDMA channel x link address register */
      [5]  = (RW_ uint32_t*)0x520001A4U,   /** @brief MDMA channel x link address register */
      [6]  = (RW_ uint32_t*)0x520001E4U,   /** @brief MDMA channel x link address register */
      [7]  = (RW_ uint32_t*)0x52000224U,   /** @brief MDMA channel x link address register */
      [8]  = (RW_ uint32_t*)0x52000264U,   /** @brief MDMA channel x link address register */
      [9]  = (RW_ uint32_t*)0x520002A4U,   /** @brief MDMA channel x link address register */
      [10] = (RW_ uint32_t*)0x520002E4U,   /** @brief MDMA channel x link address register */
      [11] = (RW_ uint32_t*)0x52000324U,   /** @brief MDMA channel x link address register */
      [12] = (RW_ uint32_t*)0x52000364U,   /** @brief MDMA channel x link address register */
      [13] = (RW_ uint32_t*)0x520003A4U,   /** @brief MDMA channel x link address register */
      [14] = (RW_ uint32_t*)0x520003E4U,   /** @brief MDMA channel x link address register */
      [15] = (RW_ uint32_t*)0x52000424U,   /** @brief MDMA channel x link address register */
      [0]  = (RW_ uint32_t*)0x52000064U   /** @brief MDMA channel x link address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxTBR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x520000A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [2]  = (RW_ uint32_t*)0x520000E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [3]  = (RW_ uint32_t*)0x52000128U,   /** @brief MDMA channel x trigger and bus selection register */
      [4]  = (RW_ uint32_t*)0x52000168U,   /** @brief MDMA channel x trigger and bus selection register */
      [5]  = (RW_ uint32_t*)0x520001A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [6]  = (RW_ uint32_t*)0x520001E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [7]  = (RW_ uint32_t*)0x52000228U,   /** @brief MDMA channel x trigger and bus selection register */
      [8]  = (RW_ uint32_t*)0x52000268U,   /** @brief MDMA channel x trigger and bus selection register */
      [9]  = (RW_ uint32_t*)0x520002A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [10] = (RW_ uint32_t*)0x520002E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [11] = (RW_ uint32_t*)0x52000328U,   /** @brief MDMA channel x trigger and bus selection register */
      [12] = (RW_ uint32_t*)0x52000368U,   /** @brief MDMA channel x trigger and bus selection register */
      [13] = (RW_ uint32_t*)0x520003A8U,   /** @brief MDMA channel x trigger and bus selection register */
      [14] = (RW_ uint32_t*)0x520003E8U,   /** @brief MDMA channel x trigger and bus selection register */
      [15] = (RW_ uint32_t*)0x52000428U,   /** @brief MDMA channel x trigger and bus selection register */
      [0]  = (RW_ uint32_t*)0x52000068U   /** @brief MDMA channel x trigger and bus selection register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxMAR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x520000B0U,   /** @brief MDMA channel x mask address register */
      [2]  = (RW_ uint32_t*)0x520000F0U,   /** @brief MDMA channel x mask address register */
      [3]  = (RW_ uint32_t*)0x52000130U,   /** @brief MDMA channel x mask address register */
      [4]  = (RW_ uint32_t*)0x52000170U,   /** @brief MDMA channel x mask address register */
      [5]  = (RW_ uint32_t*)0x520001B0U,   /** @brief MDMA channel x mask address register */
      [6]  = (RW_ uint32_t*)0x520001F0U,   /** @brief MDMA channel x mask address register */
      [7]  = (RW_ uint32_t*)0x52000230U,   /** @brief MDMA channel x mask address register */
      [8]  = (RW_ uint32_t*)0x52000270U,   /** @brief MDMA channel x mask address register */
      [9]  = (RW_ uint32_t*)0x520002B0U,   /** @brief MDMA channel x mask address register */
      [10] = (RW_ uint32_t*)0x520002F0U,   /** @brief MDMA channel x mask address register */
      [11] = (RW_ uint32_t*)0x52000330U,   /** @brief MDMA channel x mask address register */
      [12] = (RW_ uint32_t*)0x52000370U,   /** @brief MDMA channel x mask address register */
      [13] = (RW_ uint32_t*)0x520003B0U,   /** @brief MDMA channel x mask address register */
      [14] = (RW_ uint32_t*)0x520003F0U,   /** @brief MDMA channel x mask address register */
      [15] = (RW_ uint32_t*)0x52000430U,   /** @brief MDMA channel x mask address register */
      [0]  = (RW_ uint32_t*)0x52000070U   /** @brief MDMA channel x mask address register */
    };

    static RW_ uint32_t* const MDMA_MDMA_CxMDR_PTR[16] = {
      [1]  = (RW_ uint32_t*)0x520000B4U,   /** @brief MDMA channel x mask data register */
      [2]  = (RW_ uint32_t*)0x520000F4U,   /** @brief MDMA channel x mask data register */
      [3]  = (RW_ uint32_t*)0x52000134U,   /** @brief MDMA channel x mask data register */
      [4]  = (RW_ uint32_t*)0x52000174U,   /** @brief MDMA channel x mask data register */
      [5]  = (RW_ uint32_t*)0x520001B4U,   /** @brief MDMA channel x mask data register */
      [6]  = (RW_ uint32_t*)0x520001F4U,   /** @brief MDMA channel x mask data register */
      [7]  = (RW_ uint32_t*)0x52000234U,   /** @brief MDMA channel x mask data register */
      [8]  = (RW_ uint32_t*)0x52000274U,   /** @brief MDMA channel x mask data register */
      [9]  = (RW_ uint32_t*)0x520002B4U,   /** @brief MDMA channel x mask data register */
      [10] = (RW_ uint32_t*)0x520002F4U,   /** @brief MDMA channel x mask data register */
      [11] = (RW_ uint32_t*)0x52000334U,   /** @brief MDMA channel x mask data register */
      [12] = (RW_ uint32_t*)0x52000374U,   /** @brief MDMA channel x mask data register */
      [13] = (RW_ uint32_t*)0x520003B4U,   /** @brief MDMA channel x mask data register */
      [14] = (RW_ uint32_t*)0x520003F4U,   /** @brief MDMA channel x mask data register */
      [15] = (RW_ uint32_t*)0x52000434U,   /** @brief MDMA channel x mask data register */
      [0]  = (RW_ uint32_t*)0x52000074U   /** @brief MDMA channel x mask data register */
    };

    /**** @subsection MDMA Register Reset Value Definitions ****/

    static const uint32_t MDMA_MDMA_GISR0_RST = 0x00000000U;   /** @brief MDMA global interrupt/status register */

    static const uint32_t MDMA_MDMA_CxISR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [10] = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [11] = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [12] = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [13] = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [14] = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [15] = 0x00000000U,   /** @brief MDMA channel x interrupt/status register */
      [0]  = 0x00000000U   /** @brief MDMA channel x interrupt/status register */
    };

    static const uint32_t MDMA_MDMA_CxIFCR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [10] = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [11] = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [12] = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [13] = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [14] = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [15] = 0x00000000U,   /** @brief MDMA channel x interrupt flag clear register */
      [0]  = 0x00000000U   /** @brief MDMA channel x interrupt flag clear register */
    };

    static const uint32_t MDMA_MDMA_CxESR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x error status register */
      [10] = 0x00000000U,   /** @brief MDMA channel x error status register */
      [11] = 0x00000000U,   /** @brief MDMA channel x error status register */
      [12] = 0x00000000U,   /** @brief MDMA channel x error status register */
      [13] = 0x00000000U,   /** @brief MDMA channel x error status register */
      [14] = 0x00000000U,   /** @brief MDMA channel x error status register */
      [15] = 0x00000000U,   /** @brief MDMA channel x error status register */
      [0]  = 0x00000000U   /** @brief MDMA channel x error status register */
    };

    static const uint32_t MDMA_MDMA_CxCR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [2]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [3]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [4]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [5]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [6]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [7]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [8]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [9]  = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [10] = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [11] = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [12] = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [13] = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [14] = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [15] = 0x00000000U,   /** @brief This register is used to control the concerned channel. */
      [0]  = 0x00000000U   /** @brief This register is used to control the concerned channel. */
    };

    static const uint32_t MDMA_MDMA_CxTCR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [2]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [3]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [4]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [5]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [6]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [7]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [8]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [9]  = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [10] = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [11] = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [12] = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [13] = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [14] = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [15] = 0x00000000U,   /** @brief This register is used to configure the concerned channel. */
      [0]  = 0x00000000U   /** @brief This register is used to configure the concerned channel. */
    };

    static const uint32_t MDMA_MDMA_CxBNDTR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [10] = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [11] = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [12] = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [13] = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [14] = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [15] = 0x00000000U,   /** @brief MDMA channel x block number of data register */
      [0]  = 0x00000000U   /** @brief MDMA channel x block number of data register */
    };

    static const uint32_t MDMA_MDMA_CxSAR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x source address register */
      [10] = 0x00000000U,   /** @brief MDMA channel x source address register */
      [11] = 0x00000000U,   /** @brief MDMA channel x source address register */
      [12] = 0x00000000U,   /** @brief MDMA channel x source address register */
      [13] = 0x00000000U,   /** @brief MDMA channel x source address register */
      [14] = 0x00000000U,   /** @brief MDMA channel x source address register */
      [15] = 0x00000000U,   /** @brief MDMA channel x source address register */
      [0]  = 0x00000000U   /** @brief MDMA channel x source address register */
    };

    static const uint32_t MDMA_MDMA_CxDAR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [10] = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [11] = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [12] = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [13] = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [14] = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [15] = 0x00000000U,   /** @brief MDMA channel x destination address register */
      [0]  = 0x00000000U   /** @brief MDMA channel x destination address register */
    };

    static const uint32_t MDMA_MDMA_CxBRUR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [10] = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [11] = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [12] = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [13] = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [14] = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [15] = 0x00000000U,   /** @brief MDMA channel x block repeat address update register */
      [0]  = 0x00000000U   /** @brief MDMA channel x block repeat address update register */
    };

    static const uint32_t MDMA_MDMA_CxLAR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x link address register */
      [10] = 0x00000000U,   /** @brief MDMA channel x link address register */
      [11] = 0x00000000U,   /** @brief MDMA channel x link address register */
      [12] = 0x00000000U,   /** @brief MDMA channel x link address register */
      [13] = 0x00000000U,   /** @brief MDMA channel x link address register */
      [14] = 0x00000000U,   /** @brief MDMA channel x link address register */
      [15] = 0x00000000U,   /** @brief MDMA channel x link address register */
      [0]  = 0x00000000U   /** @brief MDMA channel x link address register */
    };

    static const uint32_t MDMA_MDMA_CxTBR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [10] = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [11] = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [12] = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [13] = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [14] = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [15] = 0x00000000U,   /** @brief MDMA channel x trigger and bus selection register */
      [0]  = 0x00000000U   /** @brief MDMA channel x trigger and bus selection register */
    };

    static const uint32_t MDMA_MDMA_CxMAR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [10] = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [11] = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [12] = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [13] = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [14] = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [15] = 0x00000000U,   /** @brief MDMA channel x mask address register */
      [0]  = 0x00000000U   /** @brief MDMA channel x mask address register */
    };

    static const uint32_t MDMA_MDMA_CxMDR_RST[16] = {
      [1]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [2]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [3]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [4]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [5]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [6]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [7]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [8]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [9]  = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [10] = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [11] = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [12] = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [13] = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [14] = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [15] = 0x00000000U,   /** @brief MDMA channel x mask data register */
      [0]  = 0x00000000U   /** @brief MDMA channel x mask data register */
    };

    /**** @subsection MDMA Register Value Type Definitions ****/

    typedef uint32_t MDMA_MDMA_GISR0_vt;     /** @brief MDMA_MDMA_GISR0 register value type. */
    typedef uint32_t MDMA_MDMA_CxISR_vt;     /** @brief MDMA_MDMA_CxISR register value type. */
    typedef uint32_t MDMA_MDMA_CxIFCR_vt;    /** @brief MDMA_MDMA_CxIFCR register value type. */
    typedef uint32_t MDMA_MDMA_CxESR_vt;     /** @brief MDMA_MDMA_CxESR register value type. */
    typedef uint32_t MDMA_MDMA_CxCR_vt;      /** @brief MDMA_MDMA_CxCR register value type. */
    typedef uint32_t MDMA_MDMA_CxTCR_vt;     /** @brief MDMA_MDMA_CxTCR register value type. */
    typedef uint32_t MDMA_MDMA_CxBNDTR_vt;   /** @brief MDMA_MDMA_CxBNDTR register value type. */
    typedef uint32_t MDMA_MDMA_CxSAR_vt;     /** @brief MDMA_MDMA_CxSAR register value type. */
    typedef uint32_t MDMA_MDMA_CxDAR_vt;     /** @brief MDMA_MDMA_CxDAR register value type. */
    typedef uint32_t MDMA_MDMA_CxBRUR_vt;    /** @brief MDMA_MDMA_CxBRUR register value type. */
    typedef uint32_t MDMA_MDMA_CxLAR_vt;     /** @brief MDMA_MDMA_CxLAR register value type. */
    typedef uint32_t MDMA_MDMA_CxTBR_vt;     /** @brief MDMA_MDMA_CxTBR register value type. */
    typedef uint32_t MDMA_MDMA_CxMAR_vt;     /** @brief MDMA_MDMA_CxMAR register value type. */
    typedef uint32_t MDMA_MDMA_CxMDR_vt;     /** @brief MDMA_MDMA_CxMDR register value type. */

    /**** @subsection MDMA Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* MDMA_MDMA_GISR0_pt;     /** @brief MDMA_MDMA_GISR0 pointer register pointer type. */
    typedef RO_ uint32_t* MDMA_MDMA_CxISR_pt;     /** @brief MDMA_MDMA_CxISR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxIFCR_pt;    /** @brief MDMA_MDMA_CxIFCR pointer register pointer type. */
    typedef RO_ uint32_t* MDMA_MDMA_CxESR_pt;     /** @brief MDMA_MDMA_CxESR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxCR_pt;      /** @brief MDMA_MDMA_CxCR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxTCR_pt;     /** @brief MDMA_MDMA_CxTCR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxBNDTR_pt;   /** @brief MDMA_MDMA_CxBNDTR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxSAR_pt;     /** @brief MDMA_MDMA_CxSAR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxDAR_pt;     /** @brief MDMA_MDMA_CxDAR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxBRUR_pt;    /** @brief MDMA_MDMA_CxBRUR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxLAR_pt;     /** @brief MDMA_MDMA_CxLAR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxTBR_pt;     /** @brief MDMA_MDMA_CxTBR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxMAR_pt;     /** @brief MDMA_MDMA_CxMAR pointer register pointer type. */
    typedef RW_ uint32_t* MDMA_MDMA_CxMDR_pt;     /** @brief MDMA_MDMA_CxMDR pointer register pointer type. */

    /**** @subsection MDMA Field Mask Definitions ****/

    static const uint32_t MDMA_MDMA_GISR0_GIFx_MASK[16] = {
      [1]  = 0x00000002U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [2]  = 0x00000004U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [3]  = 0x00000008U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [4]  = 0x00000010U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [5]  = 0x00000020U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [6]  = 0x00000040U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [7]  = 0x00000080U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [8]  = 0x00000100U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [9]  = 0x00000200U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [10] = 0x00000400U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [11] = 0x00000800U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [12] = 0x00001000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [13] = 0x00002000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [14] = 0x00004000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [15] = 0x00008000U,   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
      [0]  = 0x00000001U   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex) */
    };

    static const uint32_t MDMA_MDMA_CxISR_CRQAx_MASK[16] = {
      [1]  = 0x00010000U,   /** @brief Channel x request active flag */
      [2]  = 0x00010000U,   /** @brief Channel x request active flag */
      [3]  = 0x00010000U,   /** @brief Channel x request active flag */
      [4]  = 0x00010000U,   /** @brief Channel x request active flag */
      [5]  = 0x00010000U,   /** @brief Channel x request active flag */
      [6]  = 0x00010000U,   /** @brief Channel x request active flag */
      [7]  = 0x00010000U,   /** @brief Channel x request active flag */
      [8]  = 0x00010000U,   /** @brief Channel x request active flag */
      [9]  = 0x00010000U,   /** @brief Channel x request active flag */
      [10] = 0x00010000U,   /** @brief Channel x request active flag */
      [11] = 0x00010000U,   /** @brief Channel x request active flag */
      [12] = 0x00010000U,   /** @brief Channel x request active flag */
      [13] = 0x00010000U,   /** @brief Channel x request active flag */
      [14] = 0x00010000U,   /** @brief Channel x request active flag */
      [15] = 0x00010000U,   /** @brief Channel x request active flag */
      [0]  = 0x00010000U   /** @brief Channel x request active flag */
    };

    static const uint32_t MDMA_MDMA_CxIFCR_CLTCIFx_MASK[16] = {
      [1]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [2]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [3]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [4]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [5]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [6]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [7]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [8]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [9]  = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [10] = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [11] = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [12] = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [13] = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [14] = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [15] = 0x00000010U,   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
      [0]  = 0x00000010U   /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register */
    };

    static const uint32_t MDMA_MDMA_CxESR_BSE_MASK[16] = {
      [1]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [2]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [3]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [4]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [5]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [6]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [7]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [8]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [9]  = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [10] = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [11] = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [12] = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [13] = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [14] = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [15] = 0x00000800U,   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
      [0]  = 0x00000800U   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
    };

    static const uint32_t MDMA_MDMA_CxCR_SWRQ_MASK[16] = {
      [1]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [2]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [3]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [4]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [5]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [6]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [7]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [8]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [9]  = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [10] = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [11] = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [12] = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [13] = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [14] = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [15] = 0x00010000U,   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
      [0]  = 0x00010000U   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
    };

    static const uint32_t MDMA_MDMA_CxTCR_BWM_MASK[16] = {
      [1]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [2]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [3]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [4]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [5]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [6]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [7]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [8]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [9]  = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [10] = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [11] = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [12] = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [13] = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [14] = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [15] = 0x80000000U,   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
      [0]  = 0x80000000U   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
    };

    static const uint32_t MDMA_MDMA_CxBNDTR_BRC_MASK[16] = {
      [1]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [2]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [3]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [4]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [5]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [6]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0 */
      [7]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [8]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [9]  = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [10] = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [11] = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [12] = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [13] = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [14] = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [15] = 0xFFF00000U,   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
      [0]  = 0xFFF00000U   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
    };

    static const uint32_t MDMA_MDMA_CxSAR_SAR_MASK[16] = {
      [1]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [2]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [3]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [4]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [5]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [6]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [7]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [8]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [9]  = 0xFFFFFFFFU,   /** @brief Source adr base */
      [10] = 0xFFFFFFFFU,   /** @brief Source adr base */
      [11] = 0xFFFFFFFFU,   /** @brief Source adr base */
      [12] = 0xFFFFFFFFU,   /** @brief Source adr base */
      [13] = 0xFFFFFFFFU,   /** @brief Source adr base */
      [14] = 0xFFFFFFFFU,   /** @brief Source adr base */
      [15] = 0xFFFFFFFFU,   /** @brief Source adr base */
      [0]  = 0xFFFFFFFFU   /** @brief Source adr base */
    };

    static const uint32_t MDMA_MDMA_CxDAR_DAR_MASK[16] = {
      [1]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [2]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [3]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [4]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [5]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [6]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [7]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [8]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [9]  = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [10] = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [11] = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [12] = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [13] = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [14] = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [15] = 0xFFFFFFFFU,   /** @brief Destination adr base */
      [0]  = 0xFFFFFFFFU   /** @brief Destination adr base */
    };

    static const uint32_t MDMA_MDMA_CxBRUR_DUV_MASK[16] = {
      [1]  = 0xFFFF0000U,   /** @brief Destination address update */
      [2]  = 0xFFFF0000U,   /** @brief Destination address update */
      [3]  = 0xFFFF0000U,   /** @brief Destination address update */
      [4]  = 0xFFFF0000U,   /** @brief Destination address update */
      [5]  = 0xFFFF0000U,   /** @brief Destination address update */
      [6]  = 0xFFFF0000U,   /** @brief Destination address update */
      [7]  = 0xFFFF0000U,   /** @brief Destination address update */
      [8]  = 0xFFFF0000U,   /** @brief Destination address update */
      [9]  = 0xFFFF0000U,   /** @brief Destination address update */
      [10] = 0xFFFF0000U,   /** @brief Destination address update */
      [11] = 0xFFFF0000U,   /** @brief Destination address update */
      [12] = 0xFFFF0000U,   /** @brief Destination address update */
      [13] = 0xFFFF0000U,   /** @brief Destination address update */
      [14] = 0xFFFF0000U,   /** @brief Destination address update */
      [15] = 0xFFFF0000U,   /** @brief Destination address update */
      [0]  = 0xFFFF0000U   /** @brief Destination address update */
    };

    static const uint32_t MDMA_MDMA_CxLAR_LAR_MASK[16] = {
      [1]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [2]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [3]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [4]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [5]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [6]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [7]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [8]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [9]  = 0xFFFFFFFFU,   /** @brief Link address register */
      [10] = 0xFFFFFFFFU,   /** @brief Link address register */
      [11] = 0xFFFFFFFFU,   /** @brief Link address register */
      [12] = 0xFFFFFFFFU,   /** @brief Link address register */
      [13] = 0xFFFFFFFFU,   /** @brief Link address register */
      [14] = 0xFFFFFFFFU,   /** @brief Link address register */
      [15] = 0xFFFFFFFFU,   /** @brief Link address register */
      [0]  = 0xFFFFFFFFU   /** @brief Link address register */
    };

    static const uint32_t MDMA_MDMA_CxTBR_DBUS_MASK[16] = {
      [1]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [2]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [3]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [4]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [5]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [6]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [7]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [8]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [9]  = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [10] = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [11] = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [12] = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [13] = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [14] = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [15] = 0x00020000U,   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
      [0]  = 0x00020000U   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */
    };

    static const uint32_t MDMA_MDMA_CxMAR_MAR_MASK[16] = {
      [1]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [2]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [3]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [4]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [5]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [6]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [7]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [8]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [9]  = 0xFFFFFFFFU,   /** @brief Mask address */
      [10] = 0xFFFFFFFFU,   /** @brief Mask address */
      [11] = 0xFFFFFFFFU,   /** @brief Mask address */
      [12] = 0xFFFFFFFFU,   /** @brief Mask address */
      [13] = 0xFFFFFFFFU,   /** @brief Mask address */
      [14] = 0xFFFFFFFFU,   /** @brief Mask address */
      [15] = 0xFFFFFFFFU,   /** @brief Mask address */
      [0]  = 0xFFFFFFFFU   /** @brief Mask address */
    };

    static const uint32_t MDMA_MDMA_CxMDR_MDR_MASK[16] = {
      [1]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [2]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [3]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [4]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [5]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [6]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [7]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [8]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [9]  = 0xFFFFFFFFU,   /** @brief Mask data */
      [10] = 0xFFFFFFFFU,   /** @brief Mask data */
      [11] = 0xFFFFFFFFU,   /** @brief Mask data */
      [12] = 0xFFFFFFFFU,   /** @brief Mask data */
      [13] = 0xFFFFFFFFU,   /** @brief Mask data */
      [14] = 0xFFFFFFFFU,   /** @brief Mask data */
      [15] = 0xFFFFFFFFU,   /** @brief Mask data */
      [0]  = 0xFFFFFFFFU   /** @brief Mask data */
    };

    /**********************************************************************************************
     * @section QUADSPI Register Definitions
     **********************************************************************************************/

    /**** @subsection QUADSPI Register Pointer Definitions ****/

    static RW_ uint32_t* const QUADSPI_CR_PTR    = (RW_ uint32_t*)0x52005000U;   /** @brief QUADSPI control register */
    static RW_ uint32_t* const QUADSPI_DCR_PTR   = (RW_ uint32_t*)0x52005004U;   /** @brief QUADSPI device configuration register */
    static RO_ uint32_t* const QUADSPI_SR_PTR    = (RO_ uint32_t*)0x52005008U;   /** @brief QUADSPI status register */
    static RW_ uint32_t* const QUADSPI_FCR_PTR   = (RW_ uint32_t*)0x5200500CU;   /** @brief QUADSPI flag clear register */
    static RW_ uint32_t* const QUADSPI_DLR_PTR   = (RW_ uint32_t*)0x52005010U;   /** @brief QUADSPI data length register */
    static RW_ uint32_t* const QUADSPI_CCR_PTR   = (RW_ uint32_t*)0x52005014U;   /** @brief QUADSPI communication configuration register */
    static RW_ uint32_t* const QUADSPI_AR_PTR    = (RW_ uint32_t*)0x52005018U;   /** @brief QUADSPI address register */
    static RW_ uint32_t* const QUADSPI_ABR_PTR   = (RW_ uint32_t*)0x5200501CU;   /** @brief QUADSPI alternate bytes registers */
    static RW_ uint32_t* const QUADSPI_DR_PTR    = (RW_ uint32_t*)0x52005020U;   /** @brief QUADSPI data register */
    static RW_ uint32_t* const QUADSPI_PSMKR_PTR = (RW_ uint32_t*)0x52005024U;   /** @brief QUADSPI polling status mask register */
    static RW_ uint32_t* const QUADSPI_PSMAR_PTR = (RW_ uint32_t*)0x52005028U;   /** @brief QUADSPI polling status match register */
    static RW_ uint32_t* const QUADSPI_PIR_PTR   = (RW_ uint32_t*)0x5200502CU;   /** @brief QUADSPI polling interval register */
    static RW_ uint32_t* const QUADSPI_LPTR_PTR  = (RW_ uint32_t*)0x52005030U;   /** @brief QUADSPI low-power timeout register */

    /**** @subsection QUADSPI Register Reset Value Definitions ****/

    static const uint32_t QUADSPI_CR_RST    = 0x00000000U;   /** @brief QUADSPI control register */
    static const uint32_t QUADSPI_DCR_RST   = 0x00000000U;   /** @brief QUADSPI device configuration register */
    static const uint32_t QUADSPI_SR_RST    = 0x00000000U;   /** @brief QUADSPI status register */
    static const uint32_t QUADSPI_FCR_RST   = 0x00000000U;   /** @brief QUADSPI flag clear register */
    static const uint32_t QUADSPI_DLR_RST   = 0x00000000U;   /** @brief QUADSPI data length register */
    static const uint32_t QUADSPI_CCR_RST   = 0x00000000U;   /** @brief QUADSPI communication configuration register */
    static const uint32_t QUADSPI_AR_RST    = 0x00000000U;   /** @brief QUADSPI address register */
    static const uint32_t QUADSPI_ABR_RST   = 0x00000000U;   /** @brief QUADSPI alternate bytes registers */
    static const uint32_t QUADSPI_DR_RST    = 0x00000000U;   /** @brief QUADSPI data register */
    static const uint32_t QUADSPI_PSMKR_RST = 0x00000000U;   /** @brief QUADSPI polling status mask register */
    static const uint32_t QUADSPI_PSMAR_RST = 0x00000000U;   /** @brief QUADSPI polling status match register */
    static const uint32_t QUADSPI_PIR_RST   = 0x00000000U;   /** @brief QUADSPI polling interval register */
    static const uint32_t QUADSPI_LPTR_RST  = 0x00000000U;   /** @brief QUADSPI low-power timeout register */

    /**** @subsection QUADSPI Register Value Type Definitions ****/

    typedef uint32_t QUADSPI_CR_vt;      /** @brief QUADSPI_CR register value type. */
    typedef uint32_t QUADSPI_DCR_vt;     /** @brief QUADSPI_DCR register value type. */
    typedef uint32_t QUADSPI_SR_vt;      /** @brief QUADSPI_SR register value type. */
    typedef uint32_t QUADSPI_FCR_vt;     /** @brief QUADSPI_FCR register value type. */
    typedef uint32_t QUADSPI_DLR_vt;     /** @brief QUADSPI_DLR register value type. */
    typedef uint32_t QUADSPI_CCR_vt;     /** @brief QUADSPI_CCR register value type. */
    typedef uint32_t QUADSPI_AR_vt;      /** @brief QUADSPI_AR register value type. */
    typedef uint32_t QUADSPI_ABR_vt;     /** @brief QUADSPI_ABR register value type. */
    typedef uint32_t QUADSPI_DR_vt;      /** @brief QUADSPI_DR register value type. */
    typedef uint32_t QUADSPI_PSMKR_vt;   /** @brief QUADSPI_PSMKR register value type. */
    typedef uint32_t QUADSPI_PSMAR_vt;   /** @brief QUADSPI_PSMAR register value type. */
    typedef uint32_t QUADSPI_PIR_vt;     /** @brief QUADSPI_PIR register value type. */
    typedef uint32_t QUADSPI_LPTR_vt;    /** @brief QUADSPI_LPTR register value type. */

    /**** @subsection QUADSPI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* QUADSPI_CR_pt;      /** @brief QUADSPI_CR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_DCR_pt;     /** @brief QUADSPI_DCR pointer register pointer type. */
    typedef RO_ uint32_t* QUADSPI_SR_pt;      /** @brief QUADSPI_SR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_FCR_pt;     /** @brief QUADSPI_FCR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_DLR_pt;     /** @brief QUADSPI_DLR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_CCR_pt;     /** @brief QUADSPI_CCR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_AR_pt;      /** @brief QUADSPI_AR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_ABR_pt;     /** @brief QUADSPI_ABR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_DR_pt;      /** @brief QUADSPI_DR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_PSMKR_pt;   /** @brief QUADSPI_PSMKR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_PSMAR_pt;   /** @brief QUADSPI_PSMAR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_PIR_pt;     /** @brief QUADSPI_PIR pointer register pointer type. */
    typedef RW_ uint32_t* QUADSPI_LPTR_pt;    /** @brief QUADSPI_LPTR pointer register pointer type. */

    /**** @subsection QUADSPI Field Mask Definitions ****/

    static const uint32_t QUADSPI_CR_PRESCALER_MASK  = 0xFF000000U;   /** @brief Clock prescaler */
    static const uint32_t QUADSPI_DCR_FSIZE_MASK     = 0x001F0000U;   /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
    static const uint32_t QUADSPI_SR_FLEVEL_MASK     = 0x00003F00U;   /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
    static const uint32_t QUADSPI_FCR_CTOF_MASK      = 0x00000010U;   /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register */
    static const uint32_t QUADSPI_DLR_DL_MASK        = 0xFFFFFFFFU;   /** @brief Data length number of data to be retrieved (value+1) in indirect and status-polling modes. A value no greater than 3 (indicating 4 bytes) should be used for status-polling mode. All 1s in indirect mode means undefined length, where QUADSPI will continue until the end of memory, as defined by FSIZE. 0x0000_0000: 1 byte is to be transferred 0x0000_0001: 2 bytes are to be transferred 0x0000_0002: 3 bytes are to be transferred 0x0000_0003: 4 bytes are to be transferred ... 0xFFFF_FFFD: 4,294,967,294 (4G-2) bytes are to be transferred 0xffff_fffe: 4,294,967,295 (4G-1) bytes are to be transferred 0xffff_ffff: undefined length -- all bytes until the end of flash memory (as defined by FSIZE) are to be transferred. Continue reading indefinitely if FSIZE = 0x1f. DL[0] is stuck at 1 in dual-flash mode (DFM = 1) even when 0 is written to this bit, thus assuring that each access transfers an even number of bytes. This field has no effect when in memory-mapped mode (FMODE = 10). This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_CCR_DDRM_MASK      = 0x80000000U;   /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_AR_ADDRESS_MASK    = 0xFFFFFFFFU;   /** @brief [31 0]: address address to be send to the external flash memory writes to this field are ignored when BUSY = 0 or when FMODE = 11 (memory-mapped mode). In dual flash mode, ADDRESS[0] is automatically stuck to 0 as the address should always be even */
    static const uint32_t QUADSPI_ABR_ALTERNATE_MASK = 0xFFFFFFFFU;   /** @brief Alternate bytes optional data to be send to the external SPI device right after the address. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_DR_DATA_MASK       = 0xFFFFFFFFU;   /** @brief Data data to be sent/received to/from the external SPI device. In indirect write mode, data written to this register is stored on the FIFO before it is sent to the flash memory during the data phase. If the FIFO is too full, a write operation is stalled until the FIFO has enough space to accept the amount of data being written. In indirect read mode, reading this register gives (via the FIFO) the data which was received from the flash memory. If the FIFO does not have as many bytes as requested by the read operation and if BUSY=1, the read operation is stalled until enough data is present or until the transfer is complete, whichever happens first. In automatic polling mode, this register contains the last data read from the flash memory (without masking). Word, halfword, and byte accesses to this register are supported. In indirect write mode, a byte write adds 1 byte to the FIFO, a halfword write 2, and a word write 4. Similarly, in indirect read mode, a byte read removes 1 byte from the FIFO, a halfword read 2, and a word read 4. Accesses in indirect mode must be aligned to the bottom of this register: a byte read must read DATA[7:0] and a halfword read must read DATA[15:0]. */
    static const uint32_t QUADSPI_PSMKR_MASK_MASK    = 0xFFFFFFFFU;   /** @brief Status mask mask to be applied to the status bytes received in polling mode. For bit n: this field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_PSMAR_MATCH_MASK   = 0xFFFFFFFFU;   /** @brief Status match value to be compared with the masked status register to get a match. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_PIR_INTERVAL_MASK  = 0x0000FFFFU;   /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
    static const uint32_t QUADSPI_LPTR_TIMEOUT_MASK  = 0x0000FFFFU;   /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

    /**********************************************************************************************
     * @section RNG Register Definitions
     **********************************************************************************************/

    /**** @subsection RNG Register Pointer Definitions ****/

    static RW_ uint32_t* const RNG_CR_PTR = (RW_ uint32_t*)0x48021800U;   /** @brief RNG control register */
    static RW_ uint32_t* const RNG_SR_PTR = (RW_ uint32_t*)0x48021804U;   /** @brief RNG status register */
    static RO_ uint32_t* const RNG_DR_PTR = (RO_ uint32_t*)0x48021808U;   /** @brief The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0. */

    /**** @subsection RNG Register Reset Value Definitions ****/

    static const uint32_t RNG_CR_RST = 0x00000000U;   /** @brief RNG control register */
    static const uint32_t RNG_SR_RST = 0x00000000U;   /** @brief RNG status register */
    static const uint32_t RNG_DR_RST = 0x00000000U;   /** @brief The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0. */

    /**** @subsection RNG Register Value Type Definitions ****/

    typedef uint32_t RNG_CR_vt;   /** @brief RNG_CR register value type. */
    typedef uint32_t RNG_SR_vt;   /** @brief RNG_SR register value type. */
    typedef uint32_t RNG_DR_vt;   /** @brief RNG_DR register value type. */

    /**** @subsection RNG Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* RNG_CR_pt;   /** @brief RNG_CR pointer register pointer type. */
    typedef RW_ uint32_t* RNG_SR_pt;   /** @brief RNG_SR pointer register pointer type. */
    typedef RO_ uint32_t* RNG_DR_pt;   /** @brief RNG_DR pointer register pointer type. */

    /**** @subsection RNG Field Mask Definitions ****/

    static const uint32_t RNG_CR_CED_MASK    = 0x00000020U;   /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
    static const uint32_t RNG_SR_SEIS_MASK   = 0x00000040U;   /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */
    static const uint32_t RNG_DR_RNDATA_MASK = 0xFFFFFFFFU;   /** @brief Random data 32-bit random data which are valid when DRDY=1. */

    /**********************************************************************************************
     * @section RTC Register Definitions
     **********************************************************************************************/

    /**** @subsection RTC Register Pointer Definitions ****/

    static RW_ uint32_t* const RTC_RTC_TR_PTR       = (RW_ uint32_t*)0x58004000U;   /** @brief The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_DR_PTR       = (RW_ uint32_t*)0x58004004U;   /** @brief The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_CR_PTR       = (RW_ uint32_t*)0x58004008U;   /** @brief RTC control register */
    static RW_ uint32_t* const RTC_RTC_ISR_PTR      = (RW_ uint32_t*)0x5800400CU;   /** @brief This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_PRER_PTR     = (RW_ uint32_t*)0x58004010U;   /** @brief This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to calendar initialization and configuration on page9.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_WUTR_PTR     = (RW_ uint32_t*)0x58004014U;   /** @brief This register can be written only when WUTWF is set to 1 in rtc_isr.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_ALRMAR_PTR   = (RW_ uint32_t*)0x5800401CU;   /** @brief This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_ALRMBR_PTR   = (RW_ uint32_t*)0x58004020U;   /** @brief This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_WPR_PTR      = (RW_ uint32_t*)0x58004024U;   /** @brief RTC write protection register */
    static RO_ uint32_t* const RTC_RTC_SSR_PTR      = (RO_ uint32_t*)0x58004028U;   /** @brief RTC sub second register */
    static RW_ uint32_t* const RTC_RTC_SHIFTR_PTR   = (RW_ uint32_t*)0x5800402CU;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RO_ uint32_t* const RTC_RTC_TSTR_PTR     = (RO_ uint32_t*)0x58004030U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static RO_ uint32_t* const RTC_RTC_TSDR_PTR     = (RO_ uint32_t*)0x58004034U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static RO_ uint32_t* const RTC_RTC_TSSSR_PTR    = (RO_ uint32_t*)0x58004038U;   /** @brief The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset. */
    static RW_ uint32_t* const RTC_RTC_CALR_PTR     = (RW_ uint32_t*)0x5800403CU;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static RW_ uint32_t* const RTC_RTC_TAMPCR_PTR   = (RW_ uint32_t*)0x58004040U;   /** @brief RTC tamper and alternate function configuration register */
    static RW_ uint32_t* const RTC_RTC_ALRMASSR_PTR = (RW_ uint32_t*)0x58004044U;   /** @brief This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9 */
    static RW_ uint32_t* const RTC_RTC_ALRMBSSR_PTR = (RW_ uint32_t*)0x58004048U;   /** @brief This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.this register is write protected.the write access procedure is described in section: RTC register write protection. */
    static RW_ uint32_t* const RTC_RTC_OR_PTR       = (RW_ uint32_t*)0x5800404CU;   /** @brief RTC option register */

    static RW_ uint32_t* const RTC_RTC_BKPxR_PTR[32] = {
      [1]  = (RW_ uint32_t*)0x58004054U,   /** @brief RTC backup registers */
      [2]  = (RW_ uint32_t*)0x58004058U,   /** @brief RTC backup registers */
      [3]  = (RW_ uint32_t*)0x5800405CU,   /** @brief RTC backup registers */
      [4]  = (RW_ uint32_t*)0x58004060U,   /** @brief RTC backup registers */
      [5]  = (RW_ uint32_t*)0x58004064U,   /** @brief RTC backup registers */
      [6]  = (RW_ uint32_t*)0x58004068U,   /** @brief RTC backup registers */
      [7]  = (RW_ uint32_t*)0x5800406CU,   /** @brief RTC backup registers */
      [8]  = (RW_ uint32_t*)0x58004070U,   /** @brief RTC backup registers */
      [9]  = (RW_ uint32_t*)0x58004074U,   /** @brief RTC backup registers */
      [10] = (RW_ uint32_t*)0x58004078U,   /** @brief RTC backup registers */
      [11] = (RW_ uint32_t*)0x5800407CU,   /** @brief RTC backup registers */
      [12] = (RW_ uint32_t*)0x58004080U,   /** @brief RTC backup registers */
      [13] = (RW_ uint32_t*)0x58004084U,   /** @brief RTC backup registers */
      [14] = (RW_ uint32_t*)0x58004088U,   /** @brief RTC backup registers */
      [15] = (RW_ uint32_t*)0x5800408CU,   /** @brief RTC backup registers */
      [16] = (RW_ uint32_t*)0x58004090U,   /** @brief RTC backup registers */
      [17] = (RW_ uint32_t*)0x58004094U,   /** @brief RTC backup registers */
      [18] = (RW_ uint32_t*)0x58004098U,   /** @brief RTC backup registers */
      [19] = (RW_ uint32_t*)0x5800409CU,   /** @brief RTC backup registers */
      [20] = (RW_ uint32_t*)0x580040A0U,   /** @brief RTC backup registers */
      [21] = (RW_ uint32_t*)0x580040A4U,   /** @brief RTC backup registers */
      [22] = (RW_ uint32_t*)0x580040A8U,   /** @brief RTC backup registers */
      [23] = (RW_ uint32_t*)0x580040ACU,   /** @brief RTC backup registers */
      [24] = (RW_ uint32_t*)0x580040B0U,   /** @brief RTC backup registers */
      [25] = (RW_ uint32_t*)0x580040B4U,   /** @brief RTC backup registers */
      [26] = (RW_ uint32_t*)0x580040B8U,   /** @brief RTC backup registers */
      [27] = (RW_ uint32_t*)0x580040BCU,   /** @brief RTC backup registers */
      [28] = (RW_ uint32_t*)0x580040C0U,   /** @brief RTC backup registers */
      [29] = (RW_ uint32_t*)0x580040C4U,   /** @brief RTC backup registers */
      [30] = (RW_ uint32_t*)0x580040C8U,   /** @brief RTC backup registers */
      [31] = (RW_ uint32_t*)0x580040CCU,   /** @brief RTC backup registers */
      [0]  = (RW_ uint32_t*)0x58004050U   /** @brief RTC backup registers */
    };

    /**** @subsection RTC Register Reset Value Definitions ****/

    static const uint32_t RTC_RTC_TR_RST       = 0x00000000U;   /** @brief The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_DR_RST       = 0x00002101U;   /** @brief The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_CR_RST       = 0x00000000U;   /** @brief RTC control register */
    static const uint32_t RTC_RTC_ISR_RST      = 0x00000007U;   /** @brief This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_PRER_RST     = 0x007F00FFU;   /** @brief This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to calendar initialization and configuration on page9.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_WUTR_RST     = 0x0000FFFFU;   /** @brief This register can be written only when WUTWF is set to 1 in rtc_isr.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_ALRMAR_RST   = 0x00000000U;   /** @brief This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_ALRMBR_RST   = 0x00000000U;   /** @brief This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_WPR_RST      = 0x00000000U;   /** @brief RTC write protection register */
    static const uint32_t RTC_RTC_SSR_RST      = 0x00000000U;   /** @brief RTC sub second register */
    static const uint32_t RTC_RTC_SHIFTR_RST   = 0x00000000U;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_TSTR_RST     = 0x00000000U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static const uint32_t RTC_RTC_TSDR_RST     = 0x00000000U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
    static const uint32_t RTC_RTC_TSSSR_RST    = 0x00000000U;   /** @brief The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset. */
    static const uint32_t RTC_RTC_CALR_RST     = 0x00000000U;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
    static const uint32_t RTC_RTC_TAMPCR_RST   = 0x00000000U;   /** @brief RTC tamper and alternate function configuration register */
    static const uint32_t RTC_RTC_ALRMASSR_RST = 0x00000000U;   /** @brief This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9 */
    static const uint32_t RTC_RTC_ALRMBSSR_RST = 0x00000000U;   /** @brief This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.this register is write protected.the write access procedure is described in section: RTC register write protection. */
    static const uint32_t RTC_RTC_OR_RST       = 0x00000000U;   /** @brief RTC option register */

    static const uint32_t RTC_RTC_BKPxR_RST[32] = {
      [1]  = 0x00000000U,   /** @brief RTC backup registers */
      [2]  = 0x00000000U,   /** @brief RTC backup registers */
      [3]  = 0x00000000U,   /** @brief RTC backup registers */
      [4]  = 0x00000000U,   /** @brief RTC backup registers */
      [5]  = 0x00000000U,   /** @brief RTC backup registers */
      [6]  = 0x00000000U,   /** @brief RTC backup registers */
      [7]  = 0x00000000U,   /** @brief RTC backup registers */
      [8]  = 0x00000000U,   /** @brief RTC backup registers */
      [9]  = 0x00000000U,   /** @brief RTC backup registers */
      [10] = 0x00000000U,   /** @brief RTC backup registers */
      [11] = 0x00000000U,   /** @brief RTC backup registers */
      [12] = 0x00000000U,   /** @brief RTC backup registers */
      [13] = 0x00000000U,   /** @brief RTC backup registers */
      [14] = 0x00000000U,   /** @brief RTC backup registers */
      [15] = 0x00000000U,   /** @brief RTC backup registers */
      [16] = 0x00000000U,   /** @brief RTC backup registers */
      [17] = 0x00000000U,   /** @brief RTC backup registers */
      [18] = 0x00000000U,   /** @brief RTC backup registers */
      [19] = 0x00000000U,   /** @brief RTC backup registers */
      [20] = 0x00000000U,   /** @brief RTC backup registers */
      [21] = 0x00000000U,   /** @brief RTC backup registers */
      [22] = 0x00000000U,   /** @brief RTC backup registers */
      [23] = 0x00000000U,   /** @brief RTC backup registers */
      [24] = 0x00000000U,   /** @brief RTC backup registers */
      [25] = 0x00000000U,   /** @brief RTC backup registers */
      [26] = 0x00000000U,   /** @brief RTC backup registers */
      [27] = 0x00000000U,   /** @brief RTC backup registers */
      [28] = 0x00000000U,   /** @brief RTC backup registers */
      [29] = 0x00000000U,   /** @brief RTC backup registers */
      [30] = 0x00000000U,   /** @brief RTC backup registers */
      [31] = 0x00000000U,   /** @brief RTC backup registers */
      [0]  = 0x00000000U   /** @brief RTC backup registers */
    };

    /**** @subsection RTC Register Value Type Definitions ****/

    typedef uint32_t RTC_RTC_TR_vt;         /** @brief RTC_RTC_TR register value type. */
    typedef uint32_t RTC_RTC_DR_vt;         /** @brief RTC_RTC_DR register value type. */
    typedef uint32_t RTC_RTC_CR_vt;         /** @brief RTC_RTC_CR register value type. */
    typedef uint32_t RTC_RTC_ISR_vt;        /** @brief RTC_RTC_ISR register value type. */
    typedef uint32_t RTC_RTC_PRER_vt;       /** @brief RTC_RTC_PRER register value type. */
    typedef uint32_t RTC_RTC_WUTR_vt;       /** @brief RTC_RTC_WUTR register value type. */
    typedef uint32_t RTC_RTC_ALRMAR_vt;     /** @brief RTC_RTC_ALRMAR register value type. */
    typedef uint32_t RTC_RTC_ALRMBR_vt;     /** @brief RTC_RTC_ALRMBR register value type. */
    typedef uint32_t RTC_RTC_WPR_vt;        /** @brief RTC_RTC_WPR register value type. */
    typedef uint32_t RTC_RTC_SSR_vt;        /** @brief RTC_RTC_SSR register value type. */
    typedef uint32_t RTC_RTC_SHIFTR_vt;     /** @brief RTC_RTC_SHIFTR register value type. */
    typedef uint32_t RTC_RTC_TSTR_vt;       /** @brief RTC_RTC_TSTR register value type. */
    typedef uint32_t RTC_RTC_TSDR_vt;       /** @brief RTC_RTC_TSDR register value type. */
    typedef uint32_t RTC_RTC_TSSSR_vt;      /** @brief RTC_RTC_TSSSR register value type. */
    typedef uint32_t RTC_RTC_CALR_vt;       /** @brief RTC_RTC_CALR register value type. */
    typedef uint32_t RTC_RTC_TAMPCR_vt;     /** @brief RTC_RTC_TAMPCR register value type. */
    typedef uint32_t RTC_RTC_ALRMASSR_vt;   /** @brief RTC_RTC_ALRMASSR register value type. */
    typedef uint32_t RTC_RTC_ALRMBSSR_vt;   /** @brief RTC_RTC_ALRMBSSR register value type. */
    typedef uint32_t RTC_RTC_BKPxR_vt;      /** @brief RTC_RTC_BKPxR register value type. */
    typedef uint32_t RTC_RTC_OR_vt;         /** @brief RTC_RTC_OR register value type. */

    /**** @subsection RTC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* RTC_RTC_TR_pt;         /** @brief RTC_RTC_TR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_DR_pt;         /** @brief RTC_RTC_DR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_CR_pt;         /** @brief RTC_RTC_CR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_ISR_pt;        /** @brief RTC_RTC_ISR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_PRER_pt;       /** @brief RTC_RTC_PRER pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_WUTR_pt;       /** @brief RTC_RTC_WUTR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_ALRMAR_pt;     /** @brief RTC_RTC_ALRMAR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_ALRMBR_pt;     /** @brief RTC_RTC_ALRMBR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_WPR_pt;        /** @brief RTC_RTC_WPR pointer register pointer type. */
    typedef RO_ uint32_t* RTC_RTC_SSR_pt;        /** @brief RTC_RTC_SSR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_SHIFTR_pt;     /** @brief RTC_RTC_SHIFTR pointer register pointer type. */
    typedef RO_ uint32_t* RTC_RTC_TSTR_pt;       /** @brief RTC_RTC_TSTR pointer register pointer type. */
    typedef RO_ uint32_t* RTC_RTC_TSDR_pt;       /** @brief RTC_RTC_TSDR pointer register pointer type. */
    typedef RO_ uint32_t* RTC_RTC_TSSSR_pt;      /** @brief RTC_RTC_TSSSR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_CALR_pt;       /** @brief RTC_RTC_CALR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_TAMPCR_pt;     /** @brief RTC_RTC_TAMPCR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_ALRMASSR_pt;   /** @brief RTC_RTC_ALRMASSR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_ALRMBSSR_pt;   /** @brief RTC_RTC_ALRMBSSR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_BKPxR_pt;      /** @brief RTC_RTC_BKPxR pointer register pointer type. */
    typedef RW_ uint32_t* RTC_RTC_OR_pt;         /** @brief RTC_RTC_OR pointer register pointer type. */

    /**** @subsection RTC Field Mask Definitions ****/

    static const uint32_t RTC_RTC_TR_PM_MASK           = 0x00400000U;   /** @brief AM/PM notation */
    static const uint32_t RTC_RTC_DR_YT_MASK           = 0x00F00000U;   /** @brief Year tens in BCD format */
    static const uint32_t RTC_RTC_CR_ITSE_MASK         = 0x01000000U;   /** @brief Timestamp on internal event enable */
    static const uint32_t RTC_RTC_ISR_ITSF_MASK        = 0x00020000U;   /** @brief Internal ttime-stamp flag */
    static const uint32_t RTC_RTC_PRER_PREDIV_A_MASK   = 0x007F0000U;   /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1) */
    static const uint32_t RTC_RTC_WUTR_WUT_MASK        = 0x0000FFFFU;   /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
    static const uint32_t RTC_RTC_ALRMAR_WDSEL_MASK    = 0x40000000U;   /** @brief Week day selection */
    static const uint32_t RTC_RTC_ALRMBR_WDSEL_MASK    = 0x40000000U;   /** @brief Week day selection */
    static const uint32_t RTC_RTC_WPR_KEY_MASK         = 0x000000FFU;   /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
    static const uint32_t RTC_RTC_SSR_SS_MASK          = 0x0000FFFFU;   /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
    static const uint32_t RTC_RTC_SHIFTR_ADD1S_MASK    = 0x80000000U;   /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
    static const uint32_t RTC_RTC_TSTR_PM_MASK         = 0x00400000U;   /** @brief AM/PM notation */
    static const uint32_t RTC_RTC_TSDR_WDU_MASK        = 0x0000E000U;   /** @brief Week day units */
    static const uint32_t RTC_RTC_TSSSR_SS_MASK        = 0x0000FFFFU;   /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
    static const uint32_t RTC_RTC_CALR_CALP_MASK       = 0x00008000U;   /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
    static const uint32_t RTC_RTC_ALRMASSR_MASKSS_MASK = 0x0F000000U;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const uint32_t RTC_RTC_ALRMBSSR_MASKSS_MASK = 0x0F000000U;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
    static const uint32_t RTC_RTC_OR_RTC_OUT_RMP_MASK  = 0x00000002U;   /** @brief RTC_OUT remap */

    static const uint32_t RTC_RTC_TAMPCR_TAMPxMF_MASK[4] = {
      [2] = 0x00200000U,   /** @brief Tamper 2 mask flag */
      [3] = 0x01000000U,   /** @brief Tamper 3 mask flag */
      [1] = 0x00040000U   /** @brief Tamper 1 mask flag */
    };

    static const uint32_t RTC_RTC_BKPxR_BKP_MASK[32] = {
      [1]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [2]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [3]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [4]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [5]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [6]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [7]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [8]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [9]  = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [10] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [11] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [12] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [13] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [14] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [15] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [16] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [17] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [18] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [19] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [20] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [21] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [22] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [23] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [24] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [25] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [26] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [27] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [28] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [29] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [30] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [31] = 0xFFFFFFFFU,   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
      [0]  = 0xFFFFFFFFU   /** @brief The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by system reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as tampxf=1. Or when the flash readout protection is disabled. */
    };

    /**********************************************************************************************
     * @section SAI Register Definitions
     **********************************************************************************************/

    /**** @subsection SAI Register Pointer Definitions ****/

    static RW_ uint32_t* const SAIx_SAI_GCR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015800U,   /** @brief Global configuration register */
      [2] = (RW_ uint32_t*)0x40015C00U,   /** @brief Global configuration register */
      [3] = (RW_ uint32_t*)0x40016000U,   /** @brief Global configuration register */
      [4] = (RW_ uint32_t*)0x58005400U   /** @brief Global configuration register */
    };

    static RW_ uint32_t* const SAIx_SAI_AFRCR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x4001580CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t*)0x40015C0CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t*)0x4001600CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t*)0x5800540CU   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_ASLOTR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015810U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t*)0x40015C10U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t*)0x40016010U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t*)0x58005410U   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_AIM_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015814U,   /** @brief Interrupt mask register 2 */
      [2] = (RW_ uint32_t*)0x40015C14U,   /** @brief Interrupt mask register 2 */
      [3] = (RW_ uint32_t*)0x40016014U,   /** @brief Interrupt mask register 2 */
      [4] = (RW_ uint32_t*)0x58005414U   /** @brief Interrupt mask register 2 */
    };

    static RO_ uint32_t* const SAIx_SAI_ASR_PTR[5] = {
      [1] = (RO_ uint32_t*)0x40015818U,   /** @brief Status register */
      [2] = (RO_ uint32_t*)0x40015C18U,   /** @brief Status register */
      [3] = (RO_ uint32_t*)0x40016018U,   /** @brief Status register */
      [4] = (RO_ uint32_t*)0x58005418U   /** @brief Status register */
    };

    static RW_ uint32_t* const SAIx_SAI_ACLRFR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x4001581CU,   /** @brief Clear flag register */
      [2] = (RW_ uint32_t*)0x40015C1CU,   /** @brief Clear flag register */
      [3] = (RW_ uint32_t*)0x4001601CU,   /** @brief Clear flag register */
      [4] = (RW_ uint32_t*)0x5800541CU   /** @brief Clear flag register */
    };

    static RW_ uint32_t* const SAIx_SAI_ADR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015820U,   /** @brief Data register */
      [2] = (RW_ uint32_t*)0x40015C20U,   /** @brief Data register */
      [3] = (RW_ uint32_t*)0x40016020U,   /** @brief Data register */
      [4] = (RW_ uint32_t*)0x58005420U   /** @brief Data register */
    };

    static RW_ uint32_t* const SAIx_SAI_BFRCR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x4001582CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t*)0x40015C2CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t*)0x4001602CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t*)0x5800542CU   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_BSLOTR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015830U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = (RW_ uint32_t*)0x40015C30U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = (RW_ uint32_t*)0x40016030U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = (RW_ uint32_t*)0x58005430U   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static RW_ uint32_t* const SAIx_SAI_BIM_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015834U,   /** @brief Interrupt mask register 2 */
      [2] = (RW_ uint32_t*)0x40015C34U,   /** @brief Interrupt mask register 2 */
      [3] = (RW_ uint32_t*)0x40016034U,   /** @brief Interrupt mask register 2 */
      [4] = (RW_ uint32_t*)0x58005434U   /** @brief Interrupt mask register 2 */
    };

    static RO_ uint32_t* const SAIx_SAI_BSR_PTR[5] = {
      [1] = (RO_ uint32_t*)0x40015838U,   /** @brief Status register */
      [2] = (RO_ uint32_t*)0x40015C38U,   /** @brief Status register */
      [3] = (RO_ uint32_t*)0x40016038U,   /** @brief Status register */
      [4] = (RO_ uint32_t*)0x58005438U   /** @brief Status register */
    };

    static RW_ uint32_t* const SAIx_SAI_BCLRFR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x4001583CU,   /** @brief Clear flag register */
      [2] = (RW_ uint32_t*)0x40015C3CU,   /** @brief Clear flag register */
      [3] = (RW_ uint32_t*)0x4001603CU,   /** @brief Clear flag register */
      [4] = (RW_ uint32_t*)0x5800543CU   /** @brief Clear flag register */
    };

    static RW_ uint32_t* const SAIx_SAI_BDR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015840U,   /** @brief Data register */
      [2] = (RW_ uint32_t*)0x40015C40U,   /** @brief Data register */
      [3] = (RW_ uint32_t*)0x40016040U,   /** @brief Data register */
      [4] = (RW_ uint32_t*)0x58005440U   /** @brief Data register */
    };

    static RW_ uint32_t* const SAIx_SAI_PDMCR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015844U,   /** @brief PDM control register */
      [2] = (RW_ uint32_t*)0x40015C44U,   /** @brief PDM control register */
      [3] = (RW_ uint32_t*)0x40016044U,   /** @brief PDM control register */
      [4] = (RW_ uint32_t*)0x58005444U   /** @brief PDM control register */
    };

    static RW_ uint32_t* const SAIx_SAI_PDMDLY_PTR[5] = {
      [1] = (RW_ uint32_t*)0x40015848U,   /** @brief PDM delay register */
      [2] = (RW_ uint32_t*)0x40015C48U,   /** @brief PDM delay register */
      [3] = (RW_ uint32_t*)0x40016048U,   /** @brief PDM delay register */
      [4] = (RW_ uint32_t*)0x58005448U   /** @brief PDM delay register */
    };

    /**** @subsection SAI Register Reset Value Definitions ****/

    static const uint32_t SAIx_SAI_GCR_RST[5] = {
      [1] = 0x00000000U,   /** @brief Global configuration register */
      [2] = 0x00000000U,   /** @brief Global configuration register */
      [3] = 0x00000000U,   /** @brief Global configuration register */
      [4] = 0x00000000U   /** @brief Global configuration register */
    };

    static const uint32_t SAIx_SAI_AFRCR_RST[5] = {
      [1] = 0x00000007U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = 0x00000007U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = 0x00000007U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = 0x00000007U   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static const uint32_t SAIx_SAI_ASLOTR_RST[5] = {
      [1] = 0x00000000U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = 0x00000000U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = 0x00000000U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = 0x00000000U   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static const uint32_t SAIx_SAI_AIM_RST[5] = {
      [1] = 0x00000000U,   /** @brief Interrupt mask register 2 */
      [2] = 0x00000000U,   /** @brief Interrupt mask register 2 */
      [3] = 0x00000000U,   /** @brief Interrupt mask register 2 */
      [4] = 0x00000000U   /** @brief Interrupt mask register 2 */
    };

    static const uint32_t SAIx_SAI_ASR_RST[5] = {
      [1] = 0x00000008U,   /** @brief Status register */
      [2] = 0x00000008U,   /** @brief Status register */
      [3] = 0x00000008U,   /** @brief Status register */
      [4] = 0x00000008U   /** @brief Status register */
    };

    static const uint32_t SAIx_SAI_ACLRFR_RST[5] = {
      [1] = 0x00000000U,   /** @brief Clear flag register */
      [2] = 0x00000000U,   /** @brief Clear flag register */
      [3] = 0x00000000U,   /** @brief Clear flag register */
      [4] = 0x00000000U   /** @brief Clear flag register */
    };

    static const uint32_t SAIx_SAI_ADR_RST[5] = {
      [1] = 0x00000000U,   /** @brief Data register */
      [2] = 0x00000000U,   /** @brief Data register */
      [3] = 0x00000000U,   /** @brief Data register */
      [4] = 0x00000000U   /** @brief Data register */
    };

    static const uint32_t SAIx_SAI_BFRCR_RST[5] = {
      [1] = 0x00000007U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = 0x00000007U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = 0x00000007U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = 0x00000007U   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static const uint32_t SAIx_SAI_BSLOTR_RST[5] = {
      [1] = 0x00000000U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [2] = 0x00000000U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [3] = 0x00000000U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
      [4] = 0x00000000U   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    };

    static const uint32_t SAIx_SAI_BIM_RST[5] = {
      [1] = 0x00000000U,   /** @brief Interrupt mask register 2 */
      [2] = 0x00000000U,   /** @brief Interrupt mask register 2 */
      [3] = 0x00000000U,   /** @brief Interrupt mask register 2 */
      [4] = 0x00000000U   /** @brief Interrupt mask register 2 */
    };

    static const uint32_t SAIx_SAI_BSR_RST[5] = {
      [1] = 0x00000008U,   /** @brief Status register */
      [2] = 0x00000008U,   /** @brief Status register */
      [3] = 0x00000008U,   /** @brief Status register */
      [4] = 0x00000008U   /** @brief Status register */
    };

    static const uint32_t SAIx_SAI_BCLRFR_RST[5] = {
      [1] = 0x00000000U,   /** @brief Clear flag register */
      [2] = 0x00000000U,   /** @brief Clear flag register */
      [3] = 0x00000000U,   /** @brief Clear flag register */
      [4] = 0x00000000U   /** @brief Clear flag register */
    };

    static const uint32_t SAIx_SAI_BDR_RST[5] = {
      [1] = 0x00000000U,   /** @brief Data register */
      [2] = 0x00000000U,   /** @brief Data register */
      [3] = 0x00000000U,   /** @brief Data register */
      [4] = 0x00000000U   /** @brief Data register */
    };

    static const uint32_t SAIx_SAI_PDMCR_RST[5] = {
      [1] = 0x00000000U,   /** @brief PDM control register */
      [2] = 0x00000000U,   /** @brief PDM control register */
      [3] = 0x00000000U,   /** @brief PDM control register */
      [4] = 0x00000000U   /** @brief PDM control register */
    };

    static const uint32_t SAIx_SAI_PDMDLY_RST[5] = {
      [1] = 0x00000000U,   /** @brief PDM delay register */
      [2] = 0x00000000U,   /** @brief PDM delay register */
      [3] = 0x00000000U,   /** @brief PDM delay register */
      [4] = 0x00000000U   /** @brief PDM delay register */
    };

    /**** @subsection SAI Register Value Type Definitions ****/

    typedef uint32_t SAIx_SAI_GCR_vt;      /** @brief SAIx_SAI_GCR register value type. */
    typedef uint32_t SAIx_SAI_ACRx_vt;     /** @brief SAIx_SAI_ACRx register value type. */
    typedef uint32_t SAIx_SAI_AFRCR_vt;    /** @brief SAIx_SAI_AFRCR register value type. */
    typedef uint32_t SAIx_SAI_ASLOTR_vt;   /** @brief SAIx_SAI_ASLOTR register value type. */
    typedef uint32_t SAIx_SAI_AIM_vt;      /** @brief SAIx_SAI_AIM register value type. */
    typedef uint32_t SAIx_SAI_ASR_vt;      /** @brief SAIx_SAI_ASR register value type. */
    typedef uint32_t SAIx_SAI_ACLRFR_vt;   /** @brief SAIx_SAI_ACLRFR register value type. */
    typedef uint32_t SAIx_SAI_ADR_vt;      /** @brief SAIx_SAI_ADR register value type. */
    typedef uint32_t SAIx_SAI_BCRx_vt;     /** @brief SAIx_SAI_BCRx register value type. */
    typedef uint32_t SAIx_SAI_BFRCR_vt;    /** @brief SAIx_SAI_BFRCR register value type. */
    typedef uint32_t SAIx_SAI_BSLOTR_vt;   /** @brief SAIx_SAI_BSLOTR register value type. */
    typedef uint32_t SAIx_SAI_BIM_vt;      /** @brief SAIx_SAI_BIM register value type. */
    typedef uint32_t SAIx_SAI_BSR_vt;      /** @brief SAIx_SAI_BSR register value type. */
    typedef uint32_t SAIx_SAI_BCLRFR_vt;   /** @brief SAIx_SAI_BCLRFR register value type. */
    typedef uint32_t SAIx_SAI_BDR_vt;      /** @brief SAIx_SAI_BDR register value type. */
    typedef uint32_t SAIx_SAI_PDMCR_vt;    /** @brief SAIx_SAI_PDMCR register value type. */
    typedef uint32_t SAIx_SAI_PDMDLY_vt;   /** @brief SAIx_SAI_PDMDLY register value type. */

    /**** @subsection SAI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* SAIx_SAI_GCR_pt;      /** @brief SAIx_SAI_GCR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_ACRx_pt;     /** @brief SAIx_SAI_ACRx pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_AFRCR_pt;    /** @brief SAIx_SAI_AFRCR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_ASLOTR_pt;   /** @brief SAIx_SAI_ASLOTR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_AIM_pt;      /** @brief SAIx_SAI_AIM pointer register pointer type. */
    typedef RO_ uint32_t* SAIx_SAI_ASR_pt;      /** @brief SAIx_SAI_ASR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_ACLRFR_pt;   /** @brief SAIx_SAI_ACLRFR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_ADR_pt;      /** @brief SAIx_SAI_ADR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_BCRx_pt;     /** @brief SAIx_SAI_BCRx pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_BFRCR_pt;    /** @brief SAIx_SAI_BFRCR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_BSLOTR_pt;   /** @brief SAIx_SAI_BSLOTR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_BIM_pt;      /** @brief SAIx_SAI_BIM pointer register pointer type. */
    typedef RO_ uint32_t* SAIx_SAI_BSR_pt;      /** @brief SAIx_SAI_BSR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_BCLRFR_pt;   /** @brief SAIx_SAI_BCLRFR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_BDR_pt;      /** @brief SAIx_SAI_BDR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_PDMCR_pt;    /** @brief SAIx_SAI_PDMCR pointer register pointer type. */
    typedef RW_ uint32_t* SAIx_SAI_PDMDLY_pt;   /** @brief SAIx_SAI_PDMDLY pointer register pointer type. */

    /**** @subsection SAI Field Mask Definitions ****/

    static const uint32_t SAIx_SAI_GCR_SYNCIN_MASK[5] = {
      [1] = 0x00000003U,   /** @brief Synchronization inputs */
      [2] = 0x00000003U,   /** @brief Synchronization inputs */
      [3] = 0x00000003U,   /** @brief Synchronization inputs */
      [4] = 0x00000003U   /** @brief Synchronization inputs */
    };

    static const uint32_t SAIx_SAI_ACRx_OSR_MASK[5] = {
      [1] = 0x04000000U,   /** @brief Oversampling ratio for master clock */
      [2] = 0x04000000U,   /** @brief Oversampling ratio for master clock */
      [3] = 0x04000000U,   /** @brief Oversampling ratio for master clock */
      [4] = 0x04000000U   /** @brief Oversampling ratio for master clock */
    };

    static const uint32_t SAIx_SAI_AFRCR_FSOFF_MASK[5] = {
      [1] = 0x00040000U,   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
      [2] = 0x00040000U,   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
      [3] = 0x00040000U,   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
      [4] = 0x00040000U   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    };

    static const uint32_t SAIx_SAI_ASLOTR_SLOTEN_MASK[5] = {
      [1] = 0xFFFF0000U,   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
      [2] = 0xFFFF0000U,   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
      [3] = 0xFFFF0000U,   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
      [4] = 0xFFFF0000U   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    };

    static const uint32_t SAIx_SAI_AIM_LFSDETIE_MASK[5] = {
      [1] = 0x00000040U,   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
      [2] = 0x00000040U,   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
      [3] = 0x00000040U,   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
      [4] = 0x00000040U   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    };

    static const uint32_t SAIx_SAI_ASR_FLVL_MASK[5] = {
      [1] = 0x00070000U,   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
      [2] = 0x00070000U,   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
      [3] = 0x00070000U,   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
      [4] = 0x00070000U   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    };

    static const uint32_t SAIx_SAI_ACLRFR_CLFSDET_MASK[5] = {
      [1] = 0x00000040U,   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
      [2] = 0x00000040U,   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
      [3] = 0x00000040U,   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
      [4] = 0x00000040U   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    };

    static const uint32_t SAIx_SAI_ADR_DATA_MASK[5] = {
      [1] = 0xFFFFFFFFU,   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
      [2] = 0xFFFFFFFFU,   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
      [3] = 0xFFFFFFFFU,   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
      [4] = 0xFFFFFFFFU   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
    };

    static const uint32_t SAIx_SAI_BCRx_OSR_MASK[5] = {
      [1] = 0x04000000U,   /** @brief Oversampling ratio for master clock */
      [2] = 0x04000000U,   /** @brief Oversampling ratio for master clock */
      [3] = 0x04000000U,   /** @brief Oversampling ratio for master clock */
      [4] = 0x04000000U   /** @brief Oversampling ratio for master clock */
    };

    static const uint32_t SAIx_SAI_BFRCR_FSOFF_MASK[5] = {
      [1] = 0x00040000U,   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
      [2] = 0x00040000U,   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
      [3] = 0x00040000U,   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
      [4] = 0x00040000U   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
    };

    static const uint32_t SAIx_SAI_BSLOTR_SLOTEN_MASK[5] = {
      [1] = 0xFFFF0000U,   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
      [2] = 0xFFFF0000U,   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
      [3] = 0xFFFF0000U,   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
      [4] = 0xFFFF0000U   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
    };

    static const uint32_t SAIx_SAI_BIM_LFSDETIE_MASK[5] = {
      [1] = 0x00000040U,   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
      [2] = 0x00000040U,   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
      [3] = 0x00000040U,   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
      [4] = 0x00000040U   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
    };

    static const uint32_t SAIx_SAI_BSR_FLVL_MASK[5] = {
      [1] = 0x00070000U,   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
      [2] = 0x00070000U,   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
      [3] = 0x00070000U,   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
      [4] = 0x00070000U   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
    };

    static const uint32_t SAIx_SAI_BCLRFR_CLFSDET_MASK[5] = {
      [1] = 0x00000040U,   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
      [2] = 0x00000040U,   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
      [3] = 0x00000040U,   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
      [4] = 0x00000040U   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
    };

    static const uint32_t SAIx_SAI_BDR_DATA_MASK[5] = {
      [1] = 0xFFFFFFFFU,   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
      [2] = 0xFFFFFFFFU,   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
      [3] = 0xFFFFFFFFU,   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
      [4] = 0xFFFFFFFFU   /** @brief Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty. */
    };

    static const uint32_t SAIx_SAI_PDMCR_CKENx_MASK[5][5] = {
      [1] = {
        [2] = 0x00000200U,   /** @brief Clock enable of bitstream clock number 2 */
        [3] = 0x00000400U,   /** @brief Clock enable of bitstream clock number 3 */
        [4] = 0x00000800U,   /** @brief Clock enable of bitstream clock number 4 */
        [1] = 0x00000100U   /** @brief Clock enable of bitstream clock number 1 */
      },
      [2] = {
        [2] = 0x00000200U,   /** @brief Clock enable of bitstream clock number 2 */
        [3] = 0x00000400U,   /** @brief Clock enable of bitstream clock number 3 */
        [4] = 0x00000800U,   /** @brief Clock enable of bitstream clock number 4 */
        [1] = 0x00000100U   /** @brief Clock enable of bitstream clock number 1 */
      },
      [3] = {
        [2] = 0x00000200U,   /** @brief Clock enable of bitstream clock number 2 */
        [3] = 0x00000400U,   /** @brief Clock enable of bitstream clock number 3 */
        [4] = 0x00000800U,   /** @brief Clock enable of bitstream clock number 4 */
        [1] = 0x00000100U   /** @brief Clock enable of bitstream clock number 1 */
      },
      [4] = {
        [2] = 0x00000200U,   /** @brief Clock enable of bitstream clock number 2 */
        [3] = 0x00000400U,   /** @brief Clock enable of bitstream clock number 3 */
        [4] = 0x00000800U,   /** @brief Clock enable of bitstream clock number 4 */
        [1] = 0x00000100U   /** @brief Clock enable of bitstream clock number 1 */
      }
    };

    static const uint32_t SAIx_SAI_PDMDLY_DLYMxR_MASK[5][5] = {
      [1] = {
        [2] = 0x00007000U,   /** @brief Delay line for second microphone of pair 2 */
        [3] = 0x00700000U,   /** @brief Delay line for second microphone of pair 3 */
        [4] = 0x70000000U,   /** @brief Delay line for second microphone of pair 4 */
        [1] = 0x00000070U   /** @brief Delay line adjust for second microphone of pair 1 */
      },
      [2] = {
        [2] = 0x00007000U,   /** @brief Delay line for second microphone of pair 2 */
        [3] = 0x00700000U,   /** @brief Delay line for second microphone of pair 3 */
        [4] = 0x70000000U,   /** @brief Delay line for second microphone of pair 4 */
        [1] = 0x00000070U   /** @brief Delay line adjust for second microphone of pair 1 */
      },
      [3] = {
        [2] = 0x00007000U,   /** @brief Delay line for second microphone of pair 2 */
        [3] = 0x00700000U,   /** @brief Delay line for second microphone of pair 3 */
        [4] = 0x70000000U,   /** @brief Delay line for second microphone of pair 4 */
        [1] = 0x00000070U   /** @brief Delay line adjust for second microphone of pair 1 */
      },
      [4] = {
        [2] = 0x00007000U,   /** @brief Delay line for second microphone of pair 2 */
        [3] = 0x00700000U,   /** @brief Delay line for second microphone of pair 3 */
        [4] = 0x70000000U,   /** @brief Delay line for second microphone of pair 4 */
        [1] = 0x00000070U   /** @brief Delay line adjust for second microphone of pair 1 */
      }
    };

    /**********************************************************************************************
     * @section SDMMC Register Definitions
     **********************************************************************************************/

    /**** @subsection SDMMC Register Pointer Definitions ****/

    static RW_ uint32_t* const SDMMCx_POWER_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022400U,   /** @brief SDMMC power control register */
      [1] = (RW_ uint32_t*)0x52007000U   /** @brief SDMMC power control register */
    };

    static RW_ uint32_t* const SDMMCx_CLKCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022404U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
      [1] = (RW_ uint32_t*)0x52007004U   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
    };

    static RW_ uint32_t* const SDMMCx_ARGR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022408U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
      [1] = (RW_ uint32_t*)0x52007008U   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
    };

    static RW_ uint32_t* const SDMMCx_CMDR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4802240CU,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
      [1] = (RW_ uint32_t*)0x5200700CU   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
    };

    static RW_ uint32_t* const SDMMCx_DTIMER_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022424U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
      [1] = (RW_ uint32_t*)0x52007024U   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
    };

    static RW_ uint32_t* const SDMMCx_DLENR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022428U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
      [1] = (RW_ uint32_t*)0x52007028U   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
    };

    static RW_ uint32_t* const SDMMCx_DCTRL_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4802242CU,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
      [1] = (RW_ uint32_t*)0x5200702CU   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
    };

    static RO_ uint32_t* const SDMMCx_DCNTR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x48022430U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
      [1] = (RO_ uint32_t*)0x52007030U   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
    };

    static RO_ uint32_t* const SDMMCx_STAR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x48022434U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
      [1] = (RO_ uint32_t*)0x52007034U   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
    };

    static RW_ uint32_t* const SDMMCx_ICR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022438U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
      [1] = (RW_ uint32_t*)0x52007038U   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
    };

    static RW_ uint32_t* const SDMMCx_MASKR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4802243CU,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
      [1] = (RW_ uint32_t*)0x5200703CU   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
    };

    static RW_ uint32_t* const SDMMCx_ACKTIMER_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022440U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
      [1] = (RW_ uint32_t*)0x52007040U   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
    };

    static RW_ uint32_t* const SDMMCx_IDMACTRLR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022450U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
      [1] = (RW_ uint32_t*)0x52007050U   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
    };

    static RW_ uint32_t* const SDMMCx_IDMABSIZER_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022454U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
      [1] = (RW_ uint32_t*)0x52007054U   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
    };

    static RW_ uint32_t* const SDMMCx_FIFOR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022480U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
      [1] = (RW_ uint32_t*)0x52007080U   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
    };

    static RO_ uint32_t* const SDMMCx_RESPCMDR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x48022410U,   /** @brief SDMMC command response register */
      [1] = (RO_ uint32_t*)0x52007010U   /** @brief SDMMC command response register */
    };

    /**** @subsection SDMMC Register Reset Value Definitions ****/

    static const uint32_t SDMMCx_POWER_RST[3] = {
      [2] = 0x00000000U,   /** @brief SDMMC power control register */
      [1] = 0x00000000U   /** @brief SDMMC power control register */
    };

    static const uint32_t SDMMCx_CLKCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
      [1] = 0x00000000U   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
    };

    static const uint32_t SDMMCx_ARGR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
      [1] = 0x00000000U   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
    };

    static const uint32_t SDMMCx_CMDR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
      [1] = 0x00000000U   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
    };

    static const uint32_t SDMMCx_DTIMER_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
      [1] = 0x00000000U   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
    };

    static const uint32_t SDMMCx_DLENR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
      [1] = 0x00000000U   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
    };

    static const uint32_t SDMMCx_DCTRL_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
      [1] = 0x00000000U   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
    };

    static const uint32_t SDMMCx_DCNTR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
      [1] = 0x00000000U   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
    };

    static const uint32_t SDMMCx_STAR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
      [1] = 0x00000000U   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
    };

    static const uint32_t SDMMCx_ICR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
      [1] = 0x00000000U   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
    };

    static const uint32_t SDMMCx_MASKR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
      [1] = 0x00000000U   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
    };

    static const uint32_t SDMMCx_ACKTIMER_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
      [1] = 0x00000000U   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
    };

    static const uint32_t SDMMCx_IDMACTRLR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
      [1] = 0x00000000U   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
    };

    static const uint32_t SDMMCx_IDMABSIZER_RST[3] = {
      [2] = 0x00000000U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
      [1] = 0x00000000U   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
    };

    static const uint32_t SDMMCx_FIFOR_RST[3] = {
      [2] = 0x00000000U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
      [1] = 0x00000000U   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
    };

    static const uint32_t SDMMCx_RESPCMDR_RST[3] = {
      [2] = 0xA3C5DD01U,   /** @brief SDMMC command response register */
      [1] = 0xA3C5DD01U   /** @brief SDMMC command response register */
    };

    /**** @subsection SDMMC Register Value Type Definitions ****/

    typedef uint32_t SDMMCx_POWER_vt;        /** @brief SDMMCx_POWER register value type. */
    typedef uint32_t SDMMCx_CLKCR_vt;        /** @brief SDMMCx_CLKCR register value type. */
    typedef uint32_t SDMMCx_ARGR_vt;         /** @brief SDMMCx_ARGR register value type. */
    typedef uint32_t SDMMCx_CMDR_vt;         /** @brief SDMMCx_CMDR register value type. */
    typedef uint32_t SDMMCx_RESPxR_vt;       /** @brief SDMMCx_RESPxR register value type. */
    typedef uint32_t SDMMCx_DTIMER_vt;       /** @brief SDMMCx_DTIMER register value type. */
    typedef uint32_t SDMMCx_DLENR_vt;        /** @brief SDMMCx_DLENR register value type. */
    typedef uint32_t SDMMCx_DCTRL_vt;        /** @brief SDMMCx_DCTRL register value type. */
    typedef uint32_t SDMMCx_DCNTR_vt;        /** @brief SDMMCx_DCNTR register value type. */
    typedef uint32_t SDMMCx_STAR_vt;         /** @brief SDMMCx_STAR register value type. */
    typedef uint32_t SDMMCx_ICR_vt;          /** @brief SDMMCx_ICR register value type. */
    typedef uint32_t SDMMCx_MASKR_vt;        /** @brief SDMMCx_MASKR register value type. */
    typedef uint32_t SDMMCx_ACKTIMER_vt;     /** @brief SDMMCx_ACKTIMER register value type. */
    typedef uint32_t SDMMCx_IDMACTRLR_vt;    /** @brief SDMMCx_IDMACTRLR register value type. */
    typedef uint32_t SDMMCx_IDMABSIZER_vt;   /** @brief SDMMCx_IDMABSIZER register value type. */
    typedef uint32_t SDMMCx_IDMABASExR_vt;   /** @brief SDMMCx_IDMABASExR register value type. */
    typedef uint32_t SDMMCx_FIFOR_vt;        /** @brief SDMMCx_FIFOR register value type. */
    typedef uint32_t SDMMCx_RESPCMDR_vt;     /** @brief SDMMCx_RESPCMDR register value type. */

    /**** @subsection SDMMC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* SDMMCx_POWER_pt;        /** @brief SDMMCx_POWER pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_CLKCR_pt;        /** @brief SDMMCx_CLKCR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_ARGR_pt;         /** @brief SDMMCx_ARGR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_CMDR_pt;         /** @brief SDMMCx_CMDR pointer register pointer type. */
    typedef RO_ uint32_t* SDMMCx_RESPxR_pt;       /** @brief SDMMCx_RESPxR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_DTIMER_pt;       /** @brief SDMMCx_DTIMER pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_DLENR_pt;        /** @brief SDMMCx_DLENR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_DCTRL_pt;        /** @brief SDMMCx_DCTRL pointer register pointer type. */
    typedef RO_ uint32_t* SDMMCx_DCNTR_pt;        /** @brief SDMMCx_DCNTR pointer register pointer type. */
    typedef RO_ uint32_t* SDMMCx_STAR_pt;         /** @brief SDMMCx_STAR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_ICR_pt;          /** @brief SDMMCx_ICR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_MASKR_pt;        /** @brief SDMMCx_MASKR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_ACKTIMER_pt;     /** @brief SDMMCx_ACKTIMER pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_IDMACTRLR_pt;    /** @brief SDMMCx_IDMACTRLR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_IDMABSIZER_pt;   /** @brief SDMMCx_IDMABSIZER pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_IDMABASExR_pt;   /** @brief SDMMCx_IDMABASExR pointer register pointer type. */
    typedef RW_ uint32_t* SDMMCx_FIFOR_pt;        /** @brief SDMMCx_FIFOR pointer register pointer type. */
    typedef RO_ uint32_t* SDMMCx_RESPCMDR_pt;     /** @brief SDMMCx_RESPCMDR pointer register pointer type. */

    /**** @subsection SDMMC Field Mask Definitions ****/

    static const uint32_t SDMMCx_POWER_DIRPOL_MASK[3] = {
      [2] = 0x00000010U,   /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
      [1] = 0x00000010U   /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
    };

    static const uint32_t SDMMCx_CLKCR_SELCLKRX_MASK[3] = {
      [2] = 0x00300000U,   /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
      [1] = 0x00300000U   /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
    };

    static const uint32_t SDMMCx_ARGR_CMDARG_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register. */
      [1] = 0xFFFFFFFFU   /** @brief Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register. */
    };

    static const uint32_t SDMMCx_CMDR_CMDSUSPEND_MASK[3] = {
      [2] = 0x00010000U,   /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
      [1] = 0x00010000U   /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
    };

    static const uint32_t SDMMCx_DTIMER_DATATIME_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Data and r1b busy timeout period this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and r1b busy timeout period expressed in card bus clock periods. */
      [1] = 0xFFFFFFFFU   /** @brief Data and r1b busy timeout period this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and r1b busy timeout period expressed in card bus clock periods. */
    };

    static const uint32_t SDMMCx_DLENR_DATALENGTH_MASK[3] = {
      [2] = 0x01FFFFFFU,   /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
      [1] = 0x01FFFFFFU   /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
    };

    static const uint32_t SDMMCx_DCTRL_FIFORST_MASK[3] = {
      [2] = 0x00002000U,   /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
      [1] = 0x00002000U   /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
    };

    static const uint32_t SDMMCx_DCNTR_DATACOUNT_MASK[3] = {
      [2] = 0x01FFFFFFU,   /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
      [1] = 0x01FFFFFFU   /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
    };

    static const uint32_t SDMMCx_STAR_IDMABTC_MASK[3] = {
      [2] = 0x10000000U,   /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
      [1] = 0x10000000U   /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
    };

    static const uint32_t SDMMCx_ICR_IDMABTCC_MASK[3] = {
      [2] = 0x10000000U,   /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
      [1] = 0x10000000U   /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
    };

    static const uint32_t SDMMCx_MASKR_IDMABTCIE_MASK[3] = {
      [2] = 0x10000000U,   /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
      [1] = 0x10000000U   /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
    };

    static const uint32_t SDMMCx_ACKTIMER_ACKTIME_MASK[3] = {
      [2] = 0x01FFFFFFU,   /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
      [1] = 0x01FFFFFFU   /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
    };

    static const uint32_t SDMMCx_IDMACTRLR_IDMABACT_MASK[3] = {
      [2] = 0x00000004U,   /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
      [1] = 0x00000004U   /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
    };

    static const uint32_t SDMMCx_IDMABSIZER_IDMABNDT_MASK[3] = {
      [2] = 0x00001FE0U,   /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
      [1] = 0x00001FE0U   /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
    };

    static const uint32_t SDMMCx_FIFOR_FIFODATA_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Receive and transmit FIFO data this register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words. */
      [1] = 0xFFFFFFFFU   /** @brief Receive and transmit FIFO data this register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words. */
    };

    static const uint32_t SDMMCx_RESPCMDR_RESPCMD_MASK[3] = {
      [2] = 0x0000003FU,   /** @brief Response command index */
      [1] = 0x0000003FU   /** @brief Response command index */
    };

    static const uint32_t SDMMCx_RESPxR_CARDSTATUSx_MASK[3][5] = {
      [2] = {
        [2] = 0xFFFFFFFFU,   /** @brief See table404. */
        [3] = 0xFFFFFFFFU,   /** @brief See table404. */
        [4] = 0xFFFFFFFFU,   /** @brief See table404. */
        [1] = 0xFFFFFFFFU   /** @brief See table 432 */
      },
      [1] = {
        [2] = 0xFFFFFFFFU,   /** @brief See table404. */
        [3] = 0xFFFFFFFFU,   /** @brief See table404. */
        [4] = 0xFFFFFFFFU,   /** @brief See table404. */
        [1] = 0xFFFFFFFFU   /** @brief See table 432 */
      }
    };

    static const uint32_t SDMMCx_IDMABASExR_IDMABASEx_MASK[3][2] = {
      [2] = {
        [1] = 0xFFFFFFFFU,   /** @brief Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0). */
        [0] = 0xFFFFFFFFU   /** @brief Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1). */
      },
      [1] = {
        [1] = 0xFFFFFFFFU,   /** @brief Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0). */
        [0] = 0xFFFFFFFFU   /** @brief Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1). */
      }
    };

    /**********************************************************************************************
     * @section VREFBUF Register Definitions
     **********************************************************************************************/

    /**** @subsection VREFBUF Register Pointer Definitions ****/

    static RW_ uint32_t* const VREFBUF_CSR_PTR = (RW_ uint32_t*)0x58003C00U;   /** @brief VREFBUF control and status register */
    static RW_ uint32_t* const VREFBUF_CCR_PTR = (RW_ uint32_t*)0x58003C04U;   /** @brief VREFBUF calibration control register */

    /**** @subsection VREFBUF Register Reset Value Definitions ****/

    static const uint32_t VREFBUF_CSR_RST = 0x00000002U;   /** @brief VREFBUF control and status register */
    static const uint32_t VREFBUF_CCR_RST = 0x00000000U;   /** @brief VREFBUF calibration control register */

    /**** @subsection VREFBUF Register Value Type Definitions ****/

    typedef uint32_t VREFBUF_CSR_vt;   /** @brief VREFBUF_CSR register value type. */
    typedef uint32_t VREFBUF_CCR_vt;   /** @brief VREFBUF_CCR register value type. */

    /**** @subsection VREFBUF Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* VREFBUF_CSR_pt;   /** @brief VREFBUF_CSR pointer register pointer type. */
    typedef RW_ uint32_t* VREFBUF_CCR_pt;   /** @brief VREFBUF_CCR pointer register pointer type. */

    /**** @subsection VREFBUF Field Mask Definitions ****/

    static const uint32_t VREFBUF_CSR_VRS_MASK  = 0x00000070U;   /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved */
    static const uint32_t VREFBUF_CCR_TRIM_MASK = 0x0000003FU;   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

    /**********************************************************************************************
     * @section IWDG Register Definitions
     **********************************************************************************************/

    /**** @subsection IWDG Register Pointer Definitions ****/

    static RW_ uint32_t* const IWDGx_KR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x58004C00U,   /** @brief Key register */
      [1] = (RW_ uint32_t*)0x58004800U   /** @brief Key register */
    };

    static RW_ uint32_t* const IWDGx_PR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x58004C04U,   /** @brief Prescaler register */
      [1] = (RW_ uint32_t*)0x58004804U   /** @brief Prescaler register */
    };

    static RW_ uint32_t* const IWDGx_RLR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x58004C08U,   /** @brief Reload register */
      [1] = (RW_ uint32_t*)0x58004808U   /** @brief Reload register */
    };

    static RO_ uint32_t* const IWDGx_SR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x58004C0CU,   /** @brief Status register */
      [1] = (RO_ uint32_t*)0x5800480CU   /** @brief Status register */
    };

    static RW_ uint32_t* const IWDGx_WINR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x58004C10U,   /** @brief Window register */
      [1] = (RW_ uint32_t*)0x58004810U   /** @brief Window register */
    };

    /**** @subsection IWDG Register Reset Value Definitions ****/

    static const uint32_t IWDGx_KR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Key register */
      [1] = 0x00000000U   /** @brief Key register */
    };

    static const uint32_t IWDGx_PR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Prescaler register */
      [1] = 0x00000000U   /** @brief Prescaler register */
    };

    static const uint32_t IWDGx_RLR_RST[3] = {
      [2] = 0x00000FFFU,   /** @brief Reload register */
      [1] = 0x00000FFFU   /** @brief Reload register */
    };

    static const uint32_t IWDGx_SR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Status register */
      [1] = 0x00000000U   /** @brief Status register */
    };

    static const uint32_t IWDGx_WINR_RST[3] = {
      [2] = 0x00000FFFU,   /** @brief Window register */
      [1] = 0x00000FFFU   /** @brief Window register */
    };

    /**** @subsection IWDG Register Value Type Definitions ****/

    typedef uint32_t IWDGx_KR_vt;     /** @brief IWDGx_KR register value type. */
    typedef uint32_t IWDGx_PR_vt;     /** @brief IWDGx_PR register value type. */
    typedef uint32_t IWDGx_RLR_vt;    /** @brief IWDGx_RLR register value type. */
    typedef uint32_t IWDGx_SR_vt;     /** @brief IWDGx_SR register value type. */
    typedef uint32_t IWDGx_WINR_vt;   /** @brief IWDGx_WINR register value type. */

    /**** @subsection IWDG Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* IWDGx_KR_pt;     /** @brief IWDGx_KR pointer register pointer type. */
    typedef RW_ uint32_t* IWDGx_PR_pt;     /** @brief IWDGx_PR pointer register pointer type. */
    typedef RW_ uint32_t* IWDGx_RLR_pt;    /** @brief IWDGx_RLR pointer register pointer type. */
    typedef RO_ uint32_t* IWDGx_SR_pt;     /** @brief IWDGx_SR pointer register pointer type. */
    typedef RW_ uint32_t* IWDGx_WINR_pt;   /** @brief IWDGx_WINR pointer register pointer type. */

    /**** @subsection IWDG Field Mask Definitions ****/

    static const uint32_t IWDGx_KR_KEY_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
      [1] = 0x0000FFFFU   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
    };

    static const uint32_t IWDGx_PR_PR_MASK[3] = {
      [2] = 0x00000007U,   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
      [1] = 0x00000007U   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
    };

    static const uint32_t IWDGx_RLR_RL_MASK[3] = {
      [2] = 0x00000FFFU,   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
      [1] = 0x00000FFFU   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
    };

    static const uint32_t IWDGx_SR_WVU_MASK[3] = {
      [2] = 0x00000004U,   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
      [1] = 0x00000004U   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
    };

    static const uint32_t IWDGx_WINR_WIN_MASK[3] = {
      [2] = 0x00000FFFU,   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */
      [1] = 0x00000FFFU   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */
    };

    /**********************************************************************************************
     * @section WWDG Register Definitions
     **********************************************************************************************/

    /**** @subsection WWDG Register Pointer Definitions ****/

    static RW_ uint32_t* const WWDGx_CR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40002C00U,   /** @brief Control register */
      [1] = (RW_ uint32_t*)0x50003000U   /** @brief Control register */
    };

    static RW_ uint32_t* const WWDGx_CFR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40002C04U,   /** @brief Configuration register */
      [1] = (RW_ uint32_t*)0x50003004U   /** @brief Configuration register */
    };

    static RW_ uint32_t* const WWDGx_SR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40002C08U,   /** @brief Status register */
      [1] = (RW_ uint32_t*)0x50003008U   /** @brief Status register */
    };

    /**** @subsection WWDG Register Reset Value Definitions ****/

    static const uint32_t WWDGx_CR_RST[3] = {
      [2] = 0x0000007FU,   /** @brief Control register */
      [1] = 0x0000007FU   /** @brief Control register */
    };

    static const uint32_t WWDGx_CFR_RST[3] = {
      [2] = 0x0000007FU,   /** @brief Configuration register */
      [1] = 0x0000007FU   /** @brief Configuration register */
    };

    static const uint32_t WWDGx_SR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Status register */
      [1] = 0x00000000U   /** @brief Status register */
    };

    /**** @subsection WWDG Register Value Type Definitions ****/

    typedef uint32_t WWDGx_CR_vt;    /** @brief WWDGx_CR register value type. */
    typedef uint32_t WWDGx_CFR_vt;   /** @brief WWDGx_CFR register value type. */
    typedef uint32_t WWDGx_SR_vt;    /** @brief WWDGx_SR register value type. */

    /**** @subsection WWDG Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* WWDGx_CR_pt;    /** @brief WWDGx_CR pointer register pointer type. */
    typedef RW_ uint32_t* WWDGx_CFR_pt;   /** @brief WWDGx_CFR pointer register pointer type. */
    typedef RW_ uint32_t* WWDGx_SR_pt;    /** @brief WWDGx_SR pointer register pointer type. */

    /**** @subsection WWDG Field Mask Definitions ****/

    static const uint32_t WWDGx_CR_WDGA_MASK[3] = {
      [2] = 0x00000080U,   /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
      [1] = 0x00000080U   /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
    };

    static const uint32_t WWDGx_CFR_EWI_MASK[3] = {
      [2] = 0x00000200U,   /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
      [1] = 0x00000200U   /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
    };

    static const uint32_t WWDGx_SR_EWIF_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */
      [1] = 0x00000001U   /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */
    };

    /**********************************************************************************************
     * @section PWR Register Definitions
     **********************************************************************************************/

    /**** @subsection PWR Register Pointer Definitions ****/

    static RO_ uint32_t* const PWR_CSR1_PTR    = (RO_ uint32_t*)0x58024804U;   /** @brief PWR control status register 1 */
    static RW_ uint32_t* const PWR_CPUCR_PTR   = (RW_ uint32_t*)0x58024810U;   /** @brief This register allows controlling CPU1 power. */
    static RW_ uint32_t* const PWR_D3CR_PTR    = (RW_ uint32_t*)0x58024818U;   /** @brief This register allows controlling D3 domain power.following reset VOSRDY will be read 1 by software */
    static RW_ uint32_t* const PWR_WKUPCR_PTR  = (RW_ uint32_t*)0x58024820U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared). */
    static RW_ uint32_t* const PWR_WKUPFR_PTR  = (RW_ uint32_t*)0x58024824U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */
    static RW_ uint32_t* const PWR_WKUPEPR_PTR = (RW_ uint32_t*)0x58024828U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */

    static RW_ uint32_t* const PWR_CRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58024808U,   /** @brief This register is not reset by wakeup from standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.after reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection. */
      [3] = (RW_ uint32_t*)0x5802480CU,   /** @brief Reset only by POR only, not reset by wakeup from standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value. */
      [1] = (RW_ uint32_t*)0x58024800U   /** @brief PWR control register 1 */
    };

    /**** @subsection PWR Register Reset Value Definitions ****/

    static const uint32_t PWR_CSR1_RST    = 0x00004000U;   /** @brief PWR control status register 1 */
    static const uint32_t PWR_CPUCR_RST   = 0x00000000U;   /** @brief This register allows controlling CPU1 power. */
    static const uint32_t PWR_D3CR_RST    = 0x00004000U;   /** @brief This register allows controlling D3 domain power.following reset VOSRDY will be read 1 by software */
    static const uint32_t PWR_WKUPCR_RST  = 0x00000000U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared). */
    static const uint32_t PWR_WKUPFR_RST  = 0x00000000U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */
    static const uint32_t PWR_WKUPEPR_RST = 0x00000000U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */

    static const uint32_t PWR_CRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief This register is not reset by wakeup from standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.after reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection. */
      [3] = 0x00000006U,   /** @brief Reset only by POR only, not reset by wakeup from standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value. */
      [1] = 0xF000C000U   /** @brief PWR control register 1 */
    };

    /**** @subsection PWR Register Value Type Definitions ****/

    typedef uint32_t PWR_CRx_vt;       /** @brief PWR_CRx register value type. */
    typedef uint32_t PWR_CSR1_vt;      /** @brief PWR_CSR1 register value type. */
    typedef uint32_t PWR_CPUCR_vt;     /** @brief PWR_CPUCR register value type. */
    typedef uint32_t PWR_D3CR_vt;      /** @brief PWR_D3CR register value type. */
    typedef uint32_t PWR_WKUPCR_vt;    /** @brief PWR_WKUPCR register value type. */
    typedef uint32_t PWR_WKUPFR_vt;    /** @brief PWR_WKUPFR register value type. */
    typedef uint32_t PWR_WKUPEPR_vt;   /** @brief PWR_WKUPEPR register value type. */

    /**** @subsection PWR Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* PWR_CRx_pt;       /** @brief PWR_CRx pointer register pointer type. */
    typedef RO_ uint32_t* PWR_CSR1_pt;      /** @brief PWR_CSR1 pointer register pointer type. */
    typedef RW_ uint32_t* PWR_CPUCR_pt;     /** @brief PWR_CPUCR pointer register pointer type. */
    typedef RW_ uint32_t* PWR_D3CR_pt;      /** @brief PWR_D3CR pointer register pointer type. */
    typedef RW_ uint32_t* PWR_WKUPCR_pt;    /** @brief PWR_WKUPCR pointer register pointer type. */
    typedef RW_ uint32_t* PWR_WKUPFR_pt;    /** @brief PWR_WKUPFR pointer register pointer type. */
    typedef RW_ uint32_t* PWR_WKUPEPR_pt;   /** @brief PWR_WKUPEPR pointer register pointer type. */

    /**** @subsection PWR Field Mask Definitions ****/

    static const uint32_t PWR_CRx_ALS_MASK      = 0x00060000U;   /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
    static const uint32_t PWR_CSR1_AVDO_MASK    = 0x00010000U;   /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
    static const uint32_t PWR_CPUCR_RUN_D3_MASK = 0x00000800U;   /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes */
    static const uint32_t PWR_D3CR_VOS_MASK     = 0x0000C000U;   /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
    static const uint32_t PWR_WKUPCR_WKUPC_MASK = 0x0000003FU;   /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

    static const uint32_t PWR_WKUPFR_WKUPFx_MASK[7] = {
      [2] = 0x00000002U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [3] = 0x00000004U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [4] = 0x00000008U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [5] = 0x00000010U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [6] = 0x00000020U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
      [1] = 0x00000001U   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    };

    static const uint32_t PWR_WKUPEPR_WKUPPUPDx_MASK[7] = {
      [2] = 0x000C0000U,   /** @brief Wakeup pin pull configuration */
      [3] = 0x00300000U,   /** @brief Wakeup pin pull configuration */
      [4] = 0x00C00000U,   /** @brief Wakeup pin pull configuration */
      [5] = 0x03000000U,   /** @brief Wakeup pin pull configuration */
      [6] = 0x0C000000U,   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
      [1] = 0x00030000U   /** @brief Wakeup pin pull configuration */
    };

    /**********************************************************************************************
     * @section SPI Register Definitions
     **********************************************************************************************/

    /**** @subsection SPI Register Pointer Definitions ****/

    static RW_ uint32_t* const SPIx_IER_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40003810U,   /** @brief Interrupt enable register */
      [3] = (RW_ uint32_t*)0x40003C10U,   /** @brief Interrupt enable register */
      [4] = (RW_ uint32_t*)0x40013410U,   /** @brief Interrupt enable register */
      [5] = (RW_ uint32_t*)0x40015010U,   /** @brief Interrupt enable register */
      [6] = (RW_ uint32_t*)0x58001410U,   /** @brief Interrupt enable register */
      [1] = (RW_ uint32_t*)0x40013010U   /** @brief Interrupt enable register */
    };

    static RO_ uint32_t* const SPIx_SR_PTR[7] = {
      [2] = (RO_ uint32_t*)0x40003814U,   /** @brief Status register */
      [3] = (RO_ uint32_t*)0x40003C14U,   /** @brief Status register */
      [4] = (RO_ uint32_t*)0x40013414U,   /** @brief Status register */
      [5] = (RO_ uint32_t*)0x40015014U,   /** @brief Status register */
      [6] = (RO_ uint32_t*)0x58001414U,   /** @brief Status register */
      [1] = (RO_ uint32_t*)0x40013014U   /** @brief Status register */
    };

    static RW_ uint32_t* const SPIx_IFCR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40003818U,   /** @brief Interrupt/Status flags clear register */
      [3] = (RW_ uint32_t*)0x40003C18U,   /** @brief Interrupt/Status flags clear register */
      [4] = (RW_ uint32_t*)0x40013418U,   /** @brief Interrupt/Status flags clear register */
      [5] = (RW_ uint32_t*)0x40015018U,   /** @brief Interrupt/Status flags clear register */
      [6] = (RW_ uint32_t*)0x58001418U,   /** @brief Interrupt/Status flags clear register */
      [1] = (RW_ uint32_t*)0x40013018U   /** @brief Interrupt/Status flags clear register */
    };

    static RW_ uint32_t* const SPIx_TXDR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40003820U,   /** @brief Transmit data register */
      [3] = (RW_ uint32_t*)0x40003C20U,   /** @brief Transmit data register */
      [4] = (RW_ uint32_t*)0x40013420U,   /** @brief Transmit data register */
      [5] = (RW_ uint32_t*)0x40015020U,   /** @brief Transmit data register */
      [6] = (RW_ uint32_t*)0x58001420U,   /** @brief Transmit data register */
      [1] = (RW_ uint32_t*)0x40013020U   /** @brief Transmit data register */
    };

    static RO_ uint32_t* const SPIx_RXDR_PTR[7] = {
      [2] = (RO_ uint32_t*)0x40003830U,   /** @brief Receive data register */
      [3] = (RO_ uint32_t*)0x40003C30U,   /** @brief Receive data register */
      [4] = (RO_ uint32_t*)0x40013430U,   /** @brief Receive data register */
      [5] = (RO_ uint32_t*)0x40015030U,   /** @brief Receive data register */
      [6] = (RO_ uint32_t*)0x58001430U,   /** @brief Receive data register */
      [1] = (RO_ uint32_t*)0x40013030U   /** @brief Receive data register */
    };

    static RW_ uint32_t* const SPIx_CRCPOLY_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40003840U,   /** @brief Polynomial register */
      [3] = (RW_ uint32_t*)0x40003C40U,   /** @brief Polynomial register */
      [4] = (RW_ uint32_t*)0x40013440U,   /** @brief Polynomial register */
      [5] = (RW_ uint32_t*)0x40015040U,   /** @brief Polynomial register */
      [6] = (RW_ uint32_t*)0x58001440U,   /** @brief Polynomial register */
      [1] = (RW_ uint32_t*)0x40013040U   /** @brief Polynomial register */
    };

    static RW_ uint32_t* const SPIx_TXCRC_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40003844U,   /** @brief Transmitter CRC register */
      [3] = (RW_ uint32_t*)0x40003C44U,   /** @brief Transmitter CRC register */
      [4] = (RW_ uint32_t*)0x40013444U,   /** @brief Transmitter CRC register */
      [5] = (RW_ uint32_t*)0x40015044U,   /** @brief Transmitter CRC register */
      [6] = (RW_ uint32_t*)0x58001444U,   /** @brief Transmitter CRC register */
      [1] = (RW_ uint32_t*)0x40013044U   /** @brief Transmitter CRC register */
    };

    static RW_ uint32_t* const SPIx_RXCRC_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40003848U,   /** @brief Receiver CRC register */
      [3] = (RW_ uint32_t*)0x40003C48U,   /** @brief Receiver CRC register */
      [4] = (RW_ uint32_t*)0x40013448U,   /** @brief Receiver CRC register */
      [5] = (RW_ uint32_t*)0x40015048U,   /** @brief Receiver CRC register */
      [6] = (RW_ uint32_t*)0x58001448U,   /** @brief Receiver CRC register */
      [1] = (RW_ uint32_t*)0x40013048U   /** @brief Receiver CRC register */
    };

    static RW_ uint32_t* const SPIx_UDRDR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x4000384CU,   /** @brief Underrun data register */
      [3] = (RW_ uint32_t*)0x40003C4CU,   /** @brief Underrun data register */
      [4] = (RW_ uint32_t*)0x4001344CU,   /** @brief Underrun data register */
      [5] = (RW_ uint32_t*)0x4001504CU,   /** @brief Underrun data register */
      [6] = (RW_ uint32_t*)0x5800144CU,   /** @brief Underrun data register */
      [1] = (RW_ uint32_t*)0x4001304CU   /** @brief Underrun data register */
    };

    static RW_ uint32_t* const SPIx_CGFR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40003850U,   /** @brief Configuration register */
      [3] = (RW_ uint32_t*)0x40003C50U,   /** @brief Configuration register */
      [4] = (RW_ uint32_t*)0x40013450U,   /** @brief Configuration register */
      [5] = (RW_ uint32_t*)0x40015050U,   /** @brief Configuration register */
      [6] = (RW_ uint32_t*)0x58001450U,   /** @brief Configuration register */
      [1] = (RW_ uint32_t*)0x40013050U   /** @brief Configuration register */
    };

    /**** @subsection SPI Register Reset Value Definitions ****/

    static const uint32_t SPIx_IER_RST[7] = {
      [2] = 0x00000000U,   /** @brief Interrupt enable register */
      [3] = 0x00000000U,   /** @brief Interrupt enable register */
      [4] = 0x00000000U,   /** @brief Interrupt enable register */
      [5] = 0x00000000U,   /** @brief Interrupt enable register */
      [6] = 0x00000000U,   /** @brief Interrupt enable register */
      [1] = 0x00000000U   /** @brief Interrupt enable register */
    };

    static const uint32_t SPIx_SR_RST[7] = {
      [2] = 0x00001002U,   /** @brief Status register */
      [3] = 0x00001002U,   /** @brief Status register */
      [4] = 0x00001002U,   /** @brief Status register */
      [5] = 0x00001002U,   /** @brief Status register */
      [6] = 0x00001002U,   /** @brief Status register */
      [1] = 0x00001002U   /** @brief Status register */
    };

    static const uint32_t SPIx_IFCR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Interrupt/Status flags clear register */
      [3] = 0x00000000U,   /** @brief Interrupt/Status flags clear register */
      [4] = 0x00000000U,   /** @brief Interrupt/Status flags clear register */
      [5] = 0x00000000U,   /** @brief Interrupt/Status flags clear register */
      [6] = 0x00000000U,   /** @brief Interrupt/Status flags clear register */
      [1] = 0x00000000U   /** @brief Interrupt/Status flags clear register */
    };

    static const uint32_t SPIx_TXDR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Transmit data register */
      [3] = 0x00000000U,   /** @brief Transmit data register */
      [4] = 0x00000000U,   /** @brief Transmit data register */
      [5] = 0x00000000U,   /** @brief Transmit data register */
      [6] = 0x00000000U,   /** @brief Transmit data register */
      [1] = 0x00000000U   /** @brief Transmit data register */
    };

    static const uint32_t SPIx_RXDR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Receive data register */
      [3] = 0x00000000U,   /** @brief Receive data register */
      [4] = 0x00000000U,   /** @brief Receive data register */
      [5] = 0x00000000U,   /** @brief Receive data register */
      [6] = 0x00000000U,   /** @brief Receive data register */
      [1] = 0x00000000U   /** @brief Receive data register */
    };

    static const uint32_t SPIx_CRCPOLY_RST[7] = {
      [2] = 0x00000107U,   /** @brief Polynomial register */
      [3] = 0x00000107U,   /** @brief Polynomial register */
      [4] = 0x00000107U,   /** @brief Polynomial register */
      [5] = 0x00000107U,   /** @brief Polynomial register */
      [6] = 0x00000107U,   /** @brief Polynomial register */
      [1] = 0x00000107U   /** @brief Polynomial register */
    };

    static const uint32_t SPIx_TXCRC_RST[7] = {
      [2] = 0x00000000U,   /** @brief Transmitter CRC register */
      [3] = 0x00000000U,   /** @brief Transmitter CRC register */
      [4] = 0x00000000U,   /** @brief Transmitter CRC register */
      [5] = 0x00000000U,   /** @brief Transmitter CRC register */
      [6] = 0x00000000U,   /** @brief Transmitter CRC register */
      [1] = 0x00000000U   /** @brief Transmitter CRC register */
    };

    static const uint32_t SPIx_RXCRC_RST[7] = {
      [2] = 0x00000000U,   /** @brief Receiver CRC register */
      [3] = 0x00000000U,   /** @brief Receiver CRC register */
      [4] = 0x00000000U,   /** @brief Receiver CRC register */
      [5] = 0x00000000U,   /** @brief Receiver CRC register */
      [6] = 0x00000000U,   /** @brief Receiver CRC register */
      [1] = 0x00000000U   /** @brief Receiver CRC register */
    };

    static const uint32_t SPIx_UDRDR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Underrun data register */
      [3] = 0x00000000U,   /** @brief Underrun data register */
      [4] = 0x00000000U,   /** @brief Underrun data register */
      [5] = 0x00000000U,   /** @brief Underrun data register */
      [6] = 0x00000000U,   /** @brief Underrun data register */
      [1] = 0x00000000U   /** @brief Underrun data register */
    };

    static const uint32_t SPIx_CGFR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Configuration register */
      [3] = 0x00000000U,   /** @brief Configuration register */
      [4] = 0x00000000U,   /** @brief Configuration register */
      [5] = 0x00000000U,   /** @brief Configuration register */
      [6] = 0x00000000U,   /** @brief Configuration register */
      [1] = 0x00000000U   /** @brief Configuration register */
    };

    /**** @subsection SPI Register Value Type Definitions ****/

    typedef uint32_t SPIx_CRx_vt;       /** @brief SPIx_CRx register value type. */
    typedef uint32_t SPIx_CFGx_vt;      /** @brief SPIx_CFGx register value type. */
    typedef uint32_t SPIx_IER_vt;       /** @brief SPIx_IER register value type. */
    typedef uint32_t SPIx_SR_vt;        /** @brief SPIx_SR register value type. */
    typedef uint32_t SPIx_IFCR_vt;      /** @brief SPIx_IFCR register value type. */
    typedef uint32_t SPIx_TXDR_vt;      /** @brief SPIx_TXDR register value type. */
    typedef uint32_t SPIx_RXDR_vt;      /** @brief SPIx_RXDR register value type. */
    typedef uint32_t SPIx_CRCPOLY_vt;   /** @brief SPIx_CRCPOLY register value type. */
    typedef uint32_t SPIx_TXCRC_vt;     /** @brief SPIx_TXCRC register value type. */
    typedef uint32_t SPIx_RXCRC_vt;     /** @brief SPIx_RXCRC register value type. */
    typedef uint32_t SPIx_UDRDR_vt;     /** @brief SPIx_UDRDR register value type. */
    typedef uint32_t SPIx_CGFR_vt;      /** @brief SPIx_CGFR register value type. */

    /**** @subsection SPI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* SPIx_CRx_pt;       /** @brief SPIx_CRx pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_CFGx_pt;      /** @brief SPIx_CFGx pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_IER_pt;       /** @brief SPIx_IER pointer register pointer type. */
    typedef RO_ uint32_t* SPIx_SR_pt;        /** @brief SPIx_SR pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_IFCR_pt;      /** @brief SPIx_IFCR pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_TXDR_pt;      /** @brief SPIx_TXDR pointer register pointer type. */
    typedef RO_ uint32_t* SPIx_RXDR_pt;      /** @brief SPIx_RXDR pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_CRCPOLY_pt;   /** @brief SPIx_CRCPOLY pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_TXCRC_pt;     /** @brief SPIx_TXCRC pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_RXCRC_pt;     /** @brief SPIx_RXCRC pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_UDRDR_pt;     /** @brief SPIx_UDRDR pointer register pointer type. */
    typedef RW_ uint32_t* SPIx_CGFR_pt;      /** @brief SPIx_CGFR pointer register pointer type. */

    /**** @subsection SPI Field Mask Definitions ****/

    static const uint32_t SPIx_CRx_SPE_MASK[7] = {
      [2] = 0x00000001U,   /** @brief Serial peripheral enable */
      [3] = 0x00000001U,   /** @brief Serial peripheral enable */
      [4] = 0x00000001U,   /** @brief Serial peripheral enable */
      [5] = 0x00000001U,   /** @brief Serial peripheral enable */
      [6] = 0x00000001U,   /** @brief Serial peripheral enable */
      [1] = 0x00000001U   /** @brief Serial peripheral enable */
    };

    static const uint32_t SPIx_CFGx_DSIZE_MASK[7] = {
      [2] = 0x0000001FU,   /** @brief Number of bits in at single SPI data frame */
      [3] = 0x0000001FU,   /** @brief Number of bits in at single SPI data frame */
      [4] = 0x0000001FU,   /** @brief Number of bits in at single SPI data frame */
      [5] = 0x0000001FU,   /** @brief Number of bits in at single SPI data frame */
      [6] = 0x0000001FU,   /** @brief Number of bits in at single SPI data frame */
      [1] = 0x0000001FU   /** @brief Number of bits in at single SPI data frame */
    };

    static const uint32_t SPIx_IER_RXPIE_MASK[7] = {
      [2] = 0x00000001U,   /** @brief RXP interrupt enable */
      [3] = 0x00000001U,   /** @brief RXP interrupt enable */
      [4] = 0x00000001U,   /** @brief RXP interrupt enable */
      [5] = 0x00000001U,   /** @brief RXP interrupt enable */
      [6] = 0x00000001U,   /** @brief RXP interrupt enable */
      [1] = 0x00000001U   /** @brief RXP interrupt enable */
    };

    static const uint32_t SPIx_SR_RXP_MASK[7] = {
      [2] = 0x00000001U,   /** @brief Rx-Packet available */
      [3] = 0x00000001U,   /** @brief Rx-Packet available */
      [4] = 0x00000001U,   /** @brief Rx-Packet available */
      [5] = 0x00000001U,   /** @brief Rx-Packet available */
      [6] = 0x00000001U,   /** @brief Rx-Packet available */
      [1] = 0x00000001U   /** @brief Rx-Packet available */
    };

    static const uint32_t SPIx_IFCR_EOTC_MASK[7] = {
      [2] = 0x00000008U,   /** @brief End of transfer flag clear */
      [3] = 0x00000008U,   /** @brief End of transfer flag clear */
      [4] = 0x00000008U,   /** @brief End of transfer flag clear */
      [5] = 0x00000008U,   /** @brief End of transfer flag clear */
      [6] = 0x00000008U,   /** @brief End of transfer flag clear */
      [1] = 0x00000008U   /** @brief End of transfer flag clear */
    };

    static const uint32_t SPIx_TXDR_TXDR_MASK[7] = {
      [2] = 0xFFFFFFFFU,   /** @brief Transmit data register */
      [3] = 0xFFFFFFFFU,   /** @brief Transmit data register */
      [4] = 0xFFFFFFFFU,   /** @brief Transmit data register */
      [5] = 0xFFFFFFFFU,   /** @brief Transmit data register */
      [6] = 0xFFFFFFFFU,   /** @brief Transmit data register */
      [1] = 0xFFFFFFFFU   /** @brief Transmit data register */
    };

    static const uint32_t SPIx_RXDR_RXDR_MASK[7] = {
      [2] = 0xFFFFFFFFU,   /** @brief Receive data register */
      [3] = 0xFFFFFFFFU,   /** @brief Receive data register */
      [4] = 0xFFFFFFFFU,   /** @brief Receive data register */
      [5] = 0xFFFFFFFFU,   /** @brief Receive data register */
      [6] = 0xFFFFFFFFU,   /** @brief Receive data register */
      [1] = 0xFFFFFFFFU   /** @brief Receive data register */
    };

    static const uint32_t SPIx_CRCPOLY_CRCPOLY_MASK[7] = {
      [2] = 0xFFFFFFFFU,   /** @brief CRC polynomial register */
      [3] = 0xFFFFFFFFU,   /** @brief CRC polynomial register */
      [4] = 0xFFFFFFFFU,   /** @brief CRC polynomial register */
      [5] = 0xFFFFFFFFU,   /** @brief CRC polynomial register */
      [6] = 0xFFFFFFFFU,   /** @brief CRC polynomial register */
      [1] = 0xFFFFFFFFU   /** @brief CRC polynomial register */
    };

    static const uint32_t SPIx_TXCRC_TXCRC_MASK[7] = {
      [2] = 0xFFFFFFFFU,   /** @brief CRC register for transmitter */
      [3] = 0xFFFFFFFFU,   /** @brief CRC register for transmitter */
      [4] = 0xFFFFFFFFU,   /** @brief CRC register for transmitter */
      [5] = 0xFFFFFFFFU,   /** @brief CRC register for transmitter */
      [6] = 0xFFFFFFFFU,   /** @brief CRC register for transmitter */
      [1] = 0xFFFFFFFFU   /** @brief CRC register for transmitter */
    };

    static const uint32_t SPIx_RXCRC_RXCRC_MASK[7] = {
      [2] = 0xFFFFFFFFU,   /** @brief CRC register for receiver */
      [3] = 0xFFFFFFFFU,   /** @brief CRC register for receiver */
      [4] = 0xFFFFFFFFU,   /** @brief CRC register for receiver */
      [5] = 0xFFFFFFFFU,   /** @brief CRC register for receiver */
      [6] = 0xFFFFFFFFU,   /** @brief CRC register for receiver */
      [1] = 0xFFFFFFFFU   /** @brief CRC register for receiver */
    };

    static const uint32_t SPIx_UDRDR_UDRDR_MASK[7] = {
      [2] = 0xFFFFFFFFU,   /** @brief Data at slave underrun condition */
      [3] = 0xFFFFFFFFU,   /** @brief Data at slave underrun condition */
      [4] = 0xFFFFFFFFU,   /** @brief Data at slave underrun condition */
      [5] = 0xFFFFFFFFU,   /** @brief Data at slave underrun condition */
      [6] = 0xFFFFFFFFU,   /** @brief Data at slave underrun condition */
      [1] = 0xFFFFFFFFU   /** @brief Data at slave underrun condition */
    };

    static const uint32_t SPIx_CGFR_I2SMOD_MASK[7] = {
      [2] = 0x00000001U,   /** @brief I2S mode selection */
      [3] = 0x00000001U,   /** @brief I2S mode selection */
      [4] = 0x00000001U,   /** @brief I2S mode selection */
      [5] = 0x00000001U,   /** @brief I2S mode selection */
      [6] = 0x00000001U,   /** @brief I2S mode selection */
      [1] = 0x00000001U   /** @brief I2S mode selection */
    };

    /**********************************************************************************************
     * @section LTDC Register Definitions
     **********************************************************************************************/

    /**** @subsection LTDC Register Pointer Definitions ****/

    static RW_ uint32_t* const LTDC_SSCR_PTR  = (RW_ uint32_t*)0x50001008U;   /** @brief Synchronization size configuration register */
    static RW_ uint32_t* const LTDC_BPCR_PTR  = (RW_ uint32_t*)0x5000100CU;   /** @brief Back porch configuration register */
    static RW_ uint32_t* const LTDC_AWCR_PTR  = (RW_ uint32_t*)0x50001010U;   /** @brief Active width configuration register */
    static RW_ uint32_t* const LTDC_TWCR_PTR  = (RW_ uint32_t*)0x50001014U;   /** @brief Total width configuration register */
    static RW_ uint32_t* const LTDC_GCR_PTR   = (RW_ uint32_t*)0x50001018U;   /** @brief Global control register */
    static RW_ uint32_t* const LTDC_SRCR_PTR  = (RW_ uint32_t*)0x50001024U;   /** @brief Shadow reload configuration register */
    static RW_ uint32_t* const LTDC_BCCR_PTR  = (RW_ uint32_t*)0x5000102CU;   /** @brief Background color configuration register */
    static RW_ uint32_t* const LTDC_IER_PTR   = (RW_ uint32_t*)0x50001034U;   /** @brief Interrupt enable register */
    static RO_ uint32_t* const LTDC_ISR_PTR   = (RO_ uint32_t*)0x50001038U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const LTDC_ICR_PTR   = (RW_ uint32_t*)0x5000103CU;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const LTDC_LIPCR_PTR = (RW_ uint32_t*)0x50001040U;   /** @brief Line interrupt position configuration register */
    static RO_ uint32_t* const LTDC_CPSR_PTR  = (RO_ uint32_t*)0x50001044U;   /** @brief Current position status register */
    static RO_ uint32_t* const LTDC_CDSR_PTR  = (RO_ uint32_t*)0x50001048U;   /** @brief Current display status register */

    static RW_ uint32_t* const LTDC_LxCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001104U,   /** @brief Layerx control register */
      [1] = (RW_ uint32_t*)0x50001084U   /** @brief Layerx control register */
    };

    static RW_ uint32_t* const LTDC_LxWHPCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001108U,   /** @brief Layerx window horizontal position configuration register */
      [1] = (RW_ uint32_t*)0x50001088U   /** @brief Layerx window horizontal position configuration register */
    };

    static RW_ uint32_t* const LTDC_LxWVPCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5000110CU,   /** @brief Layerx window vertical position configuration register */
      [1] = (RW_ uint32_t*)0x5000108CU   /** @brief Layerx window vertical position configuration register */
    };

    static RW_ uint32_t* const LTDC_LxCKCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001110U,   /** @brief Layerx color keying configuration register */
      [1] = (RW_ uint32_t*)0x50001090U   /** @brief Layerx color keying configuration register */
    };

    static RW_ uint32_t* const LTDC_LxPFCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001114U,   /** @brief Layerx pixel format configuration register */
      [1] = (RW_ uint32_t*)0x50001094U   /** @brief Layerx pixel format configuration register */
    };

    static RW_ uint32_t* const LTDC_LxCACR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001118U,   /** @brief Layerx constant alpha configuration register */
      [1] = (RW_ uint32_t*)0x50001098U   /** @brief Layerx constant alpha configuration register */
    };

    static RW_ uint32_t* const LTDC_LxDCCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5000111CU,   /** @brief Layerx default color configuration register */
      [1] = (RW_ uint32_t*)0x5000109CU   /** @brief Layerx default color configuration register */
    };

    static RW_ uint32_t* const LTDC_LxBFCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001120U,   /** @brief Layerx blending factors configuration register */
      [1] = (RW_ uint32_t*)0x500010A0U   /** @brief Layerx blending factors configuration register */
    };

    static RW_ uint32_t* const LTDC_LxCFBAR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5000112CU,   /** @brief Layerx color frame buffer address register */
      [1] = (RW_ uint32_t*)0x500010ACU   /** @brief Layerx color frame buffer address register */
    };

    static RW_ uint32_t* const LTDC_LxCFBLR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001130U,   /** @brief Layerx color frame buffer length register */
      [1] = (RW_ uint32_t*)0x500010B0U   /** @brief Layerx color frame buffer length register */
    };

    static RW_ uint32_t* const LTDC_LxCFBLNR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001134U,   /** @brief Layerx colorframe buffer line number register */
      [1] = (RW_ uint32_t*)0x500010B4U   /** @brief Layerx colorframe buffer line number register */
    };

    static RW_ uint32_t* const LTDC_LxCLUTWR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x50001144U,   /** @brief Layerx CLUT write register */
      [1] = (RW_ uint32_t*)0x500010C4U   /** @brief Layerx CLUT write register */
    };

    /**** @subsection LTDC Register Reset Value Definitions ****/

    static const uint32_t LTDC_SSCR_RST  = 0x00000000U;   /** @brief Synchronization size configuration register */
    static const uint32_t LTDC_BPCR_RST  = 0x00000000U;   /** @brief Back porch configuration register */
    static const uint32_t LTDC_AWCR_RST  = 0x00000000U;   /** @brief Active width configuration register */
    static const uint32_t LTDC_TWCR_RST  = 0x00000000U;   /** @brief Total width configuration register */
    static const uint32_t LTDC_GCR_RST   = 0x00002220U;   /** @brief Global control register */
    static const uint32_t LTDC_SRCR_RST  = 0x00000000U;   /** @brief Shadow reload configuration register */
    static const uint32_t LTDC_BCCR_RST  = 0x00000000U;   /** @brief Background color configuration register */
    static const uint32_t LTDC_IER_RST   = 0x00000000U;   /** @brief Interrupt enable register */
    static const uint32_t LTDC_ISR_RST   = 0x00000000U;   /** @brief Interrupt status register */
    static const uint32_t LTDC_ICR_RST   = 0x00000000U;   /** @brief Interrupt clear register */
    static const uint32_t LTDC_LIPCR_RST = 0x00000000U;   /** @brief Line interrupt position configuration register */
    static const uint32_t LTDC_CPSR_RST  = 0x00000000U;   /** @brief Current position status register */
    static const uint32_t LTDC_CDSR_RST  = 0x0000000FU;   /** @brief Current display status register */

    static const uint32_t LTDC_LxCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx control register */
      [1] = 0x00000000U   /** @brief Layerx control register */
    };

    static const uint32_t LTDC_LxWHPCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx window horizontal position configuration register */
      [1] = 0x00000000U   /** @brief Layerx window horizontal position configuration register */
    };

    static const uint32_t LTDC_LxWVPCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx window vertical position configuration register */
      [1] = 0x00000000U   /** @brief Layerx window vertical position configuration register */
    };

    static const uint32_t LTDC_LxCKCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx color keying configuration register */
      [1] = 0x00000000U   /** @brief Layerx color keying configuration register */
    };

    static const uint32_t LTDC_LxPFCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx pixel format configuration register */
      [1] = 0x00000000U   /** @brief Layerx pixel format configuration register */
    };

    static const uint32_t LTDC_LxCACR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx constant alpha configuration register */
      [1] = 0x00000000U   /** @brief Layerx constant alpha configuration register */
    };

    static const uint32_t LTDC_LxDCCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx default color configuration register */
      [1] = 0x00000000U   /** @brief Layerx default color configuration register */
    };

    static const uint32_t LTDC_LxBFCR_RST[3] = {
      [2] = 0x00000607U,   /** @brief Layerx blending factors configuration register */
      [1] = 0x00000607U   /** @brief Layerx blending factors configuration register */
    };

    static const uint32_t LTDC_LxCFBAR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx color frame buffer address register */
      [1] = 0x00000000U   /** @brief Layerx color frame buffer address register */
    };

    static const uint32_t LTDC_LxCFBLR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx color frame buffer length register */
      [1] = 0x00000000U   /** @brief Layerx color frame buffer length register */
    };

    static const uint32_t LTDC_LxCFBLNR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx colorframe buffer line number register */
      [1] = 0x00000000U   /** @brief Layerx colorframe buffer line number register */
    };

    static const uint32_t LTDC_LxCLUTWR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Layerx CLUT write register */
      [1] = 0x00000000U   /** @brief Layerx CLUT write register */
    };

    /**** @subsection LTDC Register Value Type Definitions ****/

    typedef uint32_t LTDC_SSCR_vt;       /** @brief LTDC_SSCR register value type. */
    typedef uint32_t LTDC_BPCR_vt;       /** @brief LTDC_BPCR register value type. */
    typedef uint32_t LTDC_AWCR_vt;       /** @brief LTDC_AWCR register value type. */
    typedef uint32_t LTDC_TWCR_vt;       /** @brief LTDC_TWCR register value type. */
    typedef uint32_t LTDC_GCR_vt;        /** @brief LTDC_GCR register value type. */
    typedef uint32_t LTDC_SRCR_vt;       /** @brief LTDC_SRCR register value type. */
    typedef uint32_t LTDC_BCCR_vt;       /** @brief LTDC_BCCR register value type. */
    typedef uint32_t LTDC_IER_vt;        /** @brief LTDC_IER register value type. */
    typedef uint32_t LTDC_ISR_vt;        /** @brief LTDC_ISR register value type. */
    typedef uint32_t LTDC_ICR_vt;        /** @brief LTDC_ICR register value type. */
    typedef uint32_t LTDC_LIPCR_vt;      /** @brief LTDC_LIPCR register value type. */
    typedef uint32_t LTDC_CPSR_vt;       /** @brief LTDC_CPSR register value type. */
    typedef uint32_t LTDC_CDSR_vt;       /** @brief LTDC_CDSR register value type. */
    typedef uint32_t LTDC_LxCR_vt;       /** @brief LTDC_LxCR register value type. */
    typedef uint32_t LTDC_LxWHPCR_vt;    /** @brief LTDC_LxWHPCR register value type. */
    typedef uint32_t LTDC_LxWVPCR_vt;    /** @brief LTDC_LxWVPCR register value type. */
    typedef uint32_t LTDC_LxCKCR_vt;     /** @brief LTDC_LxCKCR register value type. */
    typedef uint32_t LTDC_LxPFCR_vt;     /** @brief LTDC_LxPFCR register value type. */
    typedef uint32_t LTDC_LxCACR_vt;     /** @brief LTDC_LxCACR register value type. */
    typedef uint32_t LTDC_LxDCCR_vt;     /** @brief LTDC_LxDCCR register value type. */
    typedef uint32_t LTDC_LxBFCR_vt;     /** @brief LTDC_LxBFCR register value type. */
    typedef uint32_t LTDC_LxCFBAR_vt;    /** @brief LTDC_LxCFBAR register value type. */
    typedef uint32_t LTDC_LxCFBLR_vt;    /** @brief LTDC_LxCFBLR register value type. */
    typedef uint32_t LTDC_LxCFBLNR_vt;   /** @brief LTDC_LxCFBLNR register value type. */
    typedef uint32_t LTDC_LxCLUTWR_vt;   /** @brief LTDC_LxCLUTWR register value type. */

    /**** @subsection LTDC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* LTDC_SSCR_pt;       /** @brief LTDC_SSCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_BPCR_pt;       /** @brief LTDC_BPCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_AWCR_pt;       /** @brief LTDC_AWCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_TWCR_pt;       /** @brief LTDC_TWCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_GCR_pt;        /** @brief LTDC_GCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_SRCR_pt;       /** @brief LTDC_SRCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_BCCR_pt;       /** @brief LTDC_BCCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_IER_pt;        /** @brief LTDC_IER pointer register pointer type. */
    typedef RO_ uint32_t* LTDC_ISR_pt;        /** @brief LTDC_ISR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_ICR_pt;        /** @brief LTDC_ICR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LIPCR_pt;      /** @brief LTDC_LIPCR pointer register pointer type. */
    typedef RO_ uint32_t* LTDC_CPSR_pt;       /** @brief LTDC_CPSR pointer register pointer type. */
    typedef RO_ uint32_t* LTDC_CDSR_pt;       /** @brief LTDC_CDSR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxCR_pt;       /** @brief LTDC_LxCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxWHPCR_pt;    /** @brief LTDC_LxWHPCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxWVPCR_pt;    /** @brief LTDC_LxWVPCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxCKCR_pt;     /** @brief LTDC_LxCKCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxPFCR_pt;     /** @brief LTDC_LxPFCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxCACR_pt;     /** @brief LTDC_LxCACR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxDCCR_pt;     /** @brief LTDC_LxDCCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxBFCR_pt;     /** @brief LTDC_LxBFCR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxCFBAR_pt;    /** @brief LTDC_LxCFBAR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxCFBLR_pt;    /** @brief LTDC_LxCFBLR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxCFBLNR_pt;   /** @brief LTDC_LxCFBLNR pointer register pointer type. */
    typedef RW_ uint32_t* LTDC_LxCLUTWR_pt;   /** @brief LTDC_LxCLUTWR pointer register pointer type. */

    /**** @subsection LTDC Field Mask Definitions ****/

    static const uint32_t LTDC_SSCR_VSH_MASK    = 0x000007FFU;   /** @brief Vertical synchronization height (in units of horizontal scan line) */
    static const uint32_t LTDC_BPCR_AVBP_MASK   = 0x000007FFU;   /** @brief Accumulated vertical back porch (in units of horizontal scan line) */
    static const uint32_t LTDC_AWCR_AAH_MASK    = 0x000007FFU;   /** @brief Accumulated active height (in units of horizontal scan line) */
    static const uint32_t LTDC_TWCR_TOTALH_MASK = 0x000007FFU;   /** @brief Total height (in units of horizontal scan line) */
    static const uint32_t LTDC_GCR_LTDCEN_MASK  = 0x00000001U;   /** @brief LCD-TFT controller enable bit */
    static const uint32_t LTDC_SRCR_IMR_MASK    = 0x00000001U;   /** @brief Immediate reload */
    static const uint32_t LTDC_BCCR_BCRED_MASK  = 0x00FF0000U;   /** @brief Background color red value */
    static const uint32_t LTDC_IER_LIE_MASK     = 0x00000001U;   /** @brief Line interrupt enable */
    static const uint32_t LTDC_ISR_LIF_MASK     = 0x00000001U;   /** @brief Line interrupt flag */
    static const uint32_t LTDC_ICR_CLIF_MASK    = 0x00000001U;   /** @brief Clears the line interrupt flag */
    static const uint32_t LTDC_LIPCR_LIPOS_MASK = 0x000007FFU;   /** @brief Line interrupt position */
    static const uint32_t LTDC_CPSR_CYPOS_MASK  = 0x0000FFFFU;   /** @brief Current Y position */
    static const uint32_t LTDC_CDSR_VDES_MASK   = 0x00000001U;   /** @brief Vertical data enable display status */

    static const uint32_t LTDC_LxCR_LEN_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Layer enable */
      [1] = 0x00000001U   /** @brief Layer enable */
    };

    static const uint32_t LTDC_LxWHPCR_WHSTPOS_MASK[3] = {
      [2] = 0x00000FFFU,   /** @brief Window horizontal start position */
      [1] = 0x00000FFFU   /** @brief Window horizontal start position */
    };

    static const uint32_t LTDC_LxWVPCR_WVSTPOS_MASK[3] = {
      [2] = 0x000007FFU,   /** @brief Window vertical start position */
      [1] = 0x000007FFU   /** @brief Window vertical start position */
    };

    static const uint32_t LTDC_LxCKCR_CKBLUE_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Color key blue value */
      [1] = 0x000000FFU   /** @brief Color key blue value */
    };

    static const uint32_t LTDC_LxPFCR_PF_MASK[3] = {
      [2] = 0x00000007U,   /** @brief Pixel format */
      [1] = 0x00000007U   /** @brief Pixel format */
    };

    static const uint32_t LTDC_LxCACR_CONSTA_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Constant alpha */
      [1] = 0x000000FFU   /** @brief Constant alpha */
    };

    static const uint32_t LTDC_LxDCCR_DCBLUE_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Default color blue */
      [1] = 0x000000FFU   /** @brief Default color blue */
    };

    static const uint32_t LTDC_LxCFBAR_CFBADD_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Color frame buffer start address */
      [1] = 0xFFFFFFFFU   /** @brief Color frame buffer start address */
    };

    static const uint32_t LTDC_LxCFBLR_CFBLL_MASK[3] = {
      [2] = 0x00001FFFU,   /** @brief Color frame buffer line length */
      [1] = 0x00001FFFU   /** @brief Color frame buffer line length */
    };

    static const uint32_t LTDC_LxCFBLNR_CFBLNBR_MASK[3] = {
      [2] = 0x000007FFU,   /** @brief Frame buffer line number */
      [1] = 0x000007FFU   /** @brief Frame buffer line number */
    };

    static const uint32_t LTDC_LxCLUTWR_BLUE_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Blue value */
      [1] = 0x000000FFU   /** @brief Blue value */
    };

    static const uint32_t LTDC_LxBFCR_BFx_MASK[3][3] = {
      [2] = {
        [2] = 0x00000007U,   /** @brief Blending factor 2 */
        [1] = 0x00000700U   /** @brief Blending factor 1 */
      },
      [1] = {
        [2] = 0x00000007U,   /** @brief Blending factor 2 */
        [1] = 0x00000700U   /** @brief Blending factor 1 */
      }
    };

    /**********************************************************************************************
     * @section SPDIFRX Register Definitions
     **********************************************************************************************/

    /**** @subsection SPDIFRX Register Pointer Definitions ****/

    static RW_ uint32_t* const SPDIFRX_CR_PTR   = (RW_ uint32_t*)0x40004000U;   /** @brief Control register */
    static RW_ uint32_t* const SPDIFRX_IMR_PTR  = (RW_ uint32_t*)0x40004004U;   /** @brief Interrupt mask register */
    static RO_ uint32_t* const SPDIFRX_SR_PTR   = (RO_ uint32_t*)0x40004008U;   /** @brief Status register */
    static RW_ uint32_t* const SPDIFRX_IFCR_PTR = (RW_ uint32_t*)0x4000400CU;   /** @brief Interrupt flag clear register */
    static RO_ uint32_t* const SPDIFRX_CSR_PTR  = (RO_ uint32_t*)0x40004014U;   /** @brief Channel status register */
    static RO_ uint32_t* const SPDIFRX_DIR_PTR  = (RO_ uint32_t*)0x40004018U;   /** @brief Debug information register */
    static RO_ uint32_t* const SPDIFRX_VERR_PTR = (RO_ uint32_t*)0x400043F4U;   /** @brief SPDIFRX version register */
    static RO_ uint32_t* const SPDIFRX_IDR_PTR  = (RO_ uint32_t*)0x400043F8U;   /** @brief SPDIFRX identification register */
    static RO_ uint32_t* const SPDIFRX_SIDR_PTR = (RO_ uint32_t*)0x400043FCU;   /** @brief SPDIFRX size identification register */

    static RO_ uint32_t* const SPDIFRX_DR_x_PTR[11] = {
      [1]  = (RO_ uint32_t*)0x40004010U,   /** @brief Data input register */
      [10] = (RO_ uint32_t*)0x40004010U,   /** @brief Data input register */
      [0]  = (RO_ uint32_t*)0x40004010U   /** @brief Data input register */
    };

    /**** @subsection SPDIFRX Register Reset Value Definitions ****/

    static const uint32_t SPDIFRX_CR_RST   = 0x00000000U;   /** @brief Control register */
    static const uint32_t SPDIFRX_IMR_RST  = 0x00000000U;   /** @brief Interrupt mask register */
    static const uint32_t SPDIFRX_SR_RST   = 0x00000000U;   /** @brief Status register */
    static const uint32_t SPDIFRX_IFCR_RST = 0x00000000U;   /** @brief Interrupt flag clear register */
    static const uint32_t SPDIFRX_CSR_RST  = 0x00000000U;   /** @brief Channel status register */
    static const uint32_t SPDIFRX_DIR_RST  = 0x00000000U;   /** @brief Debug information register */
    static const uint32_t SPDIFRX_VERR_RST = 0x00000012U;   /** @brief SPDIFRX version register */
    static const uint32_t SPDIFRX_IDR_RST  = 0x00130041U;   /** @brief SPDIFRX identification register */
    static const uint32_t SPDIFRX_SIDR_RST = 0xA3C5DD01U;   /** @brief SPDIFRX size identification register */

    static const uint32_t SPDIFRX_DR_x_RST[11] = {
      [1]  = 0x00000000U,   /** @brief Data input register */
      [10] = 0x00000000U,   /** @brief Data input register */
      [0]  = 0x00000000U   /** @brief Data input register */
    };

    /**** @subsection SPDIFRX Register Value Type Definitions ****/

    typedef uint32_t SPDIFRX_CR_vt;     /** @brief SPDIFRX_CR register value type. */
    typedef uint32_t SPDIFRX_IMR_vt;    /** @brief SPDIFRX_IMR register value type. */
    typedef uint32_t SPDIFRX_SR_vt;     /** @brief SPDIFRX_SR register value type. */
    typedef uint32_t SPDIFRX_IFCR_vt;   /** @brief SPDIFRX_IFCR register value type. */
    typedef uint32_t SPDIFRX_DR_x_vt;   /** @brief SPDIFRX_DR_x register value type. */
    typedef uint32_t SPDIFRX_CSR_vt;    /** @brief SPDIFRX_CSR register value type. */
    typedef uint32_t SPDIFRX_DIR_vt;    /** @brief SPDIFRX_DIR register value type. */
    typedef uint32_t SPDIFRX_VERR_vt;   /** @brief SPDIFRX_VERR register value type. */
    typedef uint32_t SPDIFRX_IDR_vt;    /** @brief SPDIFRX_IDR register value type. */
    typedef uint32_t SPDIFRX_SIDR_vt;   /** @brief SPDIFRX_SIDR register value type. */

    /**** @subsection SPDIFRX Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* SPDIFRX_CR_pt;     /** @brief SPDIFRX_CR pointer register pointer type. */
    typedef RW_ uint32_t* SPDIFRX_IMR_pt;    /** @brief SPDIFRX_IMR pointer register pointer type. */
    typedef RO_ uint32_t* SPDIFRX_SR_pt;     /** @brief SPDIFRX_SR pointer register pointer type. */
    typedef RW_ uint32_t* SPDIFRX_IFCR_pt;   /** @brief SPDIFRX_IFCR pointer register pointer type. */
    typedef RO_ uint32_t* SPDIFRX_DR_x_pt;   /** @brief SPDIFRX_DR_x pointer register pointer type. */
    typedef RO_ uint32_t* SPDIFRX_CSR_pt;    /** @brief SPDIFRX_CSR pointer register pointer type. */
    typedef RO_ uint32_t* SPDIFRX_DIR_pt;    /** @brief SPDIFRX_DIR pointer register pointer type. */
    typedef RO_ uint32_t* SPDIFRX_VERR_pt;   /** @brief SPDIFRX_VERR pointer register pointer type. */
    typedef RO_ uint32_t* SPDIFRX_IDR_pt;    /** @brief SPDIFRX_IDR pointer register pointer type. */
    typedef RO_ uint32_t* SPDIFRX_SIDR_pt;   /** @brief SPDIFRX_SIDR pointer register pointer type. */

    /**** @subsection SPDIFRX Field Mask Definitions ****/

    static const uint32_t SPDIFRX_CR_CKSBKPEN_MASK  = 0x00200000U;   /** @brief Backup symbol clock enable */
    static const uint32_t SPDIFRX_IMR_IFEIE_MASK    = 0x00000040U;   /** @brief Serial interface error interrupt enable */
    static const uint32_t SPDIFRX_SR_WIDTH5_MASK    = 0x7FFF0000U;   /** @brief Duration of 5 symbols counted with SPDIF_CLK */
    static const uint32_t SPDIFRX_IFCR_SYNCDCF_MASK = 0x00000020U;   /** @brief Clears the synchronization done flag */
    static const uint32_t SPDIFRX_CSR_SOB_MASK      = 0x01000000U;   /** @brief Start of block */
    static const uint32_t SPDIFRX_DIR_TLO_MASK      = 0x1FFF0000U;   /** @brief Threshold LOW */
    static const uint32_t SPDIFRX_VERR_MAJREV_MASK  = 0x000000F0U;   /** @brief Major revision */
    static const uint32_t SPDIFRX_IDR_ID_MASK       = 0xFFFFFFFFU;   /** @brief SPDIFRX identifier */
    static const uint32_t SPDIFRX_SIDR_SID_MASK     = 0xFFFFFFFFU;   /** @brief Size identification */

    static const uint32_t SPDIFRX_DR_x_PT_MASK[2] = {
      [1] = 0x00000030U,   /** @brief Preamble type */
      [0] = 0x30000000U   /** @brief Preamble type */
    };

    /**********************************************************************************************
     * @section ADC Register Definitions
     **********************************************************************************************/

    /**** @subsection ADC Register Pointer Definitions ****/

    static RW_ uint32_t* const ADCx_ISR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40022000U,   /** @brief ADC interrupt and status register */
      [2] = (RW_ uint32_t*)0x40022100U,   /** @brief ADC interrupt and status register */
      [3] = (RW_ uint32_t*)0x58026000U   /** @brief ADC interrupt and status register */
    };

    static RW_ uint32_t* const ADCx_IER_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40022004U,   /** @brief ADC interrupt enable register */
      [2] = (RW_ uint32_t*)0x40022104U,   /** @brief ADC interrupt enable register */
      [3] = (RW_ uint32_t*)0x58026004U   /** @brief ADC interrupt enable register */
    };

    static RW_ uint32_t* const ADCx_CR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40022008U,   /** @brief ADC control register */
      [2] = (RW_ uint32_t*)0x40022108U,   /** @brief ADC control register */
      [3] = (RW_ uint32_t*)0x58026008U   /** @brief ADC control register */
    };

    static RW_ uint32_t* const ADCx_CFGR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x4002200CU,   /** @brief ADC configuration register 1 */
      [2] = (RW_ uint32_t*)0x4002210CU,   /** @brief ADC configuration register 1 */
      [3] = (RW_ uint32_t*)0x5802600CU   /** @brief ADC configuration register 1 */
    };

    static RW_ uint32_t* const ADCx_CFGR2_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40022010U,   /** @brief ADC configuration register 2 */
      [2] = (RW_ uint32_t*)0x40022110U,   /** @brief ADC configuration register 2 */
      [3] = (RW_ uint32_t*)0x58026010U   /** @brief ADC configuration register 2 */
    };

    static RW_ uint32_t* const ADCx_LHTR1_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40022024U,   /** @brief ADC analog watchdog 2 threshold register */
      [2] = (RW_ uint32_t*)0x40022124U,   /** @brief ADC analog watchdog 2 threshold register */
      [3] = (RW_ uint32_t*)0x58026024U   /** @brief ADC analog watchdog 2 threshold register */
    };

    static RO_ uint32_t* const ADCx_DR_PTR[4] = {
      [1] = (RO_ uint32_t*)0x40022040U,   /** @brief ADC group regular conversion data register */
      [2] = (RO_ uint32_t*)0x40022140U,   /** @brief ADC group regular conversion data register */
      [3] = (RO_ uint32_t*)0x58026040U   /** @brief ADC group regular conversion data register */
    };

    static RW_ uint32_t* const ADCx_JSQR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x4002204CU,   /** @brief ADC group injected sequencer register */
      [2] = (RW_ uint32_t*)0x4002214CU,   /** @brief ADC group injected sequencer register */
      [3] = (RW_ uint32_t*)0x5802604CU   /** @brief ADC group injected sequencer register */
    };

    static RW_ uint32_t* const ADCx_DIFSEL_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400220C0U,   /** @brief ADC channel differential or single-ended mode selection register */
      [2] = (RW_ uint32_t*)0x400221C0U,   /** @brief ADC channel differential or single-ended mode selection register */
      [3] = (RW_ uint32_t*)0x580260C0U   /** @brief ADC channel differential or single-ended mode selection register */
    };

    static RW_ uint32_t* const ADCx_CALFACT_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400220C4U,   /** @brief ADC calibration factors register */
      [2] = (RW_ uint32_t*)0x400221C4U,   /** @brief ADC calibration factors register */
      [3] = (RW_ uint32_t*)0x580260C4U   /** @brief ADC calibration factors register */
    };

    static RW_ uint32_t* const ADCx_PCSEL_PTR[4] = {
      [1] = (RW_ uint32_t*)0x4002201CU,   /** @brief ADC pre channel selection register */
      [2] = (RW_ uint32_t*)0x4002211CU,   /** @brief ADC pre channel selection register */
      [3] = (RW_ uint32_t*)0x5802601CU   /** @brief ADC pre channel selection register */
    };

    static RW_ uint32_t* const ADCx_CALFACT2_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400220C8U,   /** @brief ADC calibration factor register 2 */
      [2] = (RW_ uint32_t*)0x400221C8U,   /** @brief ADC calibration factor register 2 */
      [3] = (RW_ uint32_t*)0x580260C8U   /** @brief ADC calibration factor register 2 */
    };

    /**** @subsection ADC Register Reset Value Definitions ****/

    static const uint32_t ADCx_ISR_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC interrupt and status register */
      [2] = 0x00000000U,   /** @brief ADC interrupt and status register */
      [3] = 0x00000000U   /** @brief ADC interrupt and status register */
    };

    static const uint32_t ADCx_IER_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC interrupt enable register */
      [2] = 0x00000000U,   /** @brief ADC interrupt enable register */
      [3] = 0x00000000U   /** @brief ADC interrupt enable register */
    };

    static const uint32_t ADCx_CR_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC control register */
      [2] = 0x00000000U,   /** @brief ADC control register */
      [3] = 0x00000000U   /** @brief ADC control register */
    };

    static const uint32_t ADCx_CFGR_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC configuration register 1 */
      [2] = 0x00000000U,   /** @brief ADC configuration register 1 */
      [3] = 0x00000000U   /** @brief ADC configuration register 1 */
    };

    static const uint32_t ADCx_CFGR2_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC configuration register 2 */
      [2] = 0x00000000U,   /** @brief ADC configuration register 2 */
      [3] = 0x00000000U   /** @brief ADC configuration register 2 */
    };

    static const uint32_t ADCx_LHTR1_RST[4] = {
      [1] = 0x0FFF0000U,   /** @brief ADC analog watchdog 2 threshold register */
      [2] = 0x0FFF0000U,   /** @brief ADC analog watchdog 2 threshold register */
      [3] = 0x0FFF0000U   /** @brief ADC analog watchdog 2 threshold register */
    };

    static const uint32_t ADCx_DR_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC group regular conversion data register */
      [2] = 0x00000000U,   /** @brief ADC group regular conversion data register */
      [3] = 0x00000000U   /** @brief ADC group regular conversion data register */
    };

    static const uint32_t ADCx_JSQR_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC group injected sequencer register */
      [2] = 0x00000000U,   /** @brief ADC group injected sequencer register */
      [3] = 0x00000000U   /** @brief ADC group injected sequencer register */
    };

    static const uint32_t ADCx_DIFSEL_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC channel differential or single-ended mode selection register */
      [2] = 0x00000000U,   /** @brief ADC channel differential or single-ended mode selection register */
      [3] = 0x00000000U   /** @brief ADC channel differential or single-ended mode selection register */
    };

    static const uint32_t ADCx_CALFACT_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC calibration factors register */
      [2] = 0x00000000U,   /** @brief ADC calibration factors register */
      [3] = 0x00000000U   /** @brief ADC calibration factors register */
    };

    static const uint32_t ADCx_PCSEL_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC pre channel selection register */
      [2] = 0x00000000U,   /** @brief ADC pre channel selection register */
      [3] = 0x00000000U   /** @brief ADC pre channel selection register */
    };

    static const uint32_t ADCx_CALFACT2_RST[4] = {
      [1] = 0x00000000U,   /** @brief ADC calibration factor register 2 */
      [2] = 0x00000000U,   /** @brief ADC calibration factor register 2 */
      [3] = 0x00000000U   /** @brief ADC calibration factor register 2 */
    };

    /**** @subsection ADC Register Value Type Definitions ****/

    typedef uint32_t ADCx_ISR_vt;        /** @brief ADCx_ISR register value type. */
    typedef uint32_t ADCx_IER_vt;        /** @brief ADCx_IER register value type. */
    typedef uint32_t ADCx_CR_vt;         /** @brief ADCx_CR register value type. */
    typedef uint32_t ADCx_CFGR_vt;       /** @brief ADCx_CFGR register value type. */
    typedef uint32_t ADCx_CFGR2_vt;      /** @brief ADCx_CFGR2 register value type. */
    typedef uint32_t ADCx_SMPRx_vt;      /** @brief ADCx_SMPRx register value type. */
    typedef uint32_t ADCx_LTRx_vt;       /** @brief ADCx_LTRx register value type. */
    typedef uint32_t ADCx_LHTR1_vt;      /** @brief ADCx_LHTR1 register value type. */
    typedef uint32_t ADCx_SQRx_vt;       /** @brief ADCx_SQRx register value type. */
    typedef uint32_t ADCx_DR_vt;         /** @brief ADCx_DR register value type. */
    typedef uint32_t ADCx_JSQR_vt;       /** @brief ADCx_JSQR register value type. */
    typedef uint32_t ADCx_OFRx_vt;       /** @brief ADCx_OFRx register value type. */
    typedef uint32_t ADCx_JDRx_vt;       /** @brief ADCx_JDRx register value type. */
    typedef uint32_t ADCx_AWDxCR_vt;     /** @brief ADCx_AWDxCR register value type. */
    typedef uint32_t ADCx_DIFSEL_vt;     /** @brief ADCx_DIFSEL register value type. */
    typedef uint32_t ADCx_CALFACT_vt;    /** @brief ADCx_CALFACT register value type. */
    typedef uint32_t ADCx_PCSEL_vt;      /** @brief ADCx_PCSEL register value type. */
    typedef uint32_t ADCx_HTRx_vt;       /** @brief ADCx_HTRx register value type. */
    typedef uint32_t ADCx_CALFACT2_vt;   /** @brief ADCx_CALFACT2 register value type. */

    /**** @subsection ADC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* ADCx_ISR_pt;        /** @brief ADCx_ISR pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_IER_pt;        /** @brief ADCx_IER pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_CR_pt;         /** @brief ADCx_CR pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_CFGR_pt;       /** @brief ADCx_CFGR pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_CFGR2_pt;      /** @brief ADCx_CFGR2 pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_SMPRx_pt;      /** @brief ADCx_SMPRx pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_LTRx_pt;       /** @brief ADCx_LTRx pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_LHTR1_pt;      /** @brief ADCx_LHTR1 pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_SQRx_pt;       /** @brief ADCx_SQRx pointer register pointer type. */
    typedef RO_ uint32_t* ADCx_DR_pt;         /** @brief ADCx_DR pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_JSQR_pt;       /** @brief ADCx_JSQR pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_OFRx_pt;       /** @brief ADCx_OFRx pointer register pointer type. */
    typedef RO_ uint32_t* ADCx_JDRx_pt;       /** @brief ADCx_JDRx pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_AWDxCR_pt;     /** @brief ADCx_AWDxCR pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_DIFSEL_pt;     /** @brief ADCx_DIFSEL pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_CALFACT_pt;    /** @brief ADCx_CALFACT pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_PCSEL_pt;      /** @brief ADCx_PCSEL pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_HTRx_pt;       /** @brief ADCx_HTRx pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_CALFACT2_pt;   /** @brief ADCx_CALFACT2 pointer register pointer type. */

    /**** @subsection ADC Field Mask Definitions ****/

    static const uint32_t ADCx_ISR_ADRDY_MASK[4] = {
      [1] = 0x00000001U,   /** @brief ADC ready flag */
      [2] = 0x00000001U,   /** @brief ADC ready flag */
      [3] = 0x00000001U   /** @brief ADC ready flag */
    };

    static const uint32_t ADCx_IER_ADRDYIE_MASK[4] = {
      [1] = 0x00000001U,   /** @brief ADC ready interrupt */
      [2] = 0x00000001U,   /** @brief ADC ready interrupt */
      [3] = 0x00000001U   /** @brief ADC ready interrupt */
    };

    static const uint32_t ADCx_CR_ADEN_MASK[4] = {
      [1] = 0x00000001U,   /** @brief ADC enable */
      [2] = 0x00000001U,   /** @brief ADC enable */
      [3] = 0x00000001U   /** @brief ADC enable */
    };

    static const uint32_t ADCx_CFGR_DMNGT_MASK[4] = {
      [1] = 0x00000003U,   /** @brief ADC DMA transfer enable */
      [2] = 0x00000003U,   /** @brief ADC DMA transfer enable */
      [3] = 0x00000003U   /** @brief ADC DMA transfer enable */
    };

    static const uint32_t ADCx_CFGR2_LSHIFT_MASK[4] = {
      [1] = 0xF0000000U,   /** @brief Left shift factor */
      [2] = 0xF0000000U,   /** @brief Left shift factor */
      [3] = 0xF0000000U   /** @brief Left shift factor */
    };

    static const uint32_t ADCx_LHTR1_LHTR1_MASK[4] = {
      [1] = 0x03FFFFFFU,   /** @brief ADC analog watchdog 2 threshold low */
      [2] = 0x03FFFFFFU,   /** @brief ADC analog watchdog 2 threshold low */
      [3] = 0x03FFFFFFU   /** @brief ADC analog watchdog 2 threshold low */
    };

    static const uint32_t ADCx_SQRx_L3_MASK[4] = {
      [1] = 0x0000000FU,   /** @brief L3 */
      [2] = 0x0000000FU,   /** @brief L3 */
      [3] = 0x0000000FU   /** @brief L3 */
    };

    static const uint32_t ADCx_DR_RDATA_MASK[4] = {
      [1] = 0x0000FFFFU,   /** @brief ADC group regular conversion data */
      [2] = 0x0000FFFFU,   /** @brief ADC group regular conversion data */
      [3] = 0x0000FFFFU   /** @brief ADC group regular conversion data */
    };

    static const uint32_t ADCx_JSQR_JL_MASK[4] = {
      [1] = 0x00000003U,   /** @brief ADC group injected sequencer scan length */
      [2] = 0x00000003U,   /** @brief ADC group injected sequencer scan length */
      [3] = 0x00000003U   /** @brief ADC group injected sequencer scan length */
    };

    static const uint32_t ADCx_DIFSEL_DIFSEL_MASK[4] = {
      [1] = 0x000FFFFFU,   /** @brief ADC channel differential or single-ended mode for channel */
      [2] = 0x000FFFFFU,   /** @brief ADC channel differential or single-ended mode for channel */
      [3] = 0x000FFFFFU   /** @brief ADC channel differential or single-ended mode for channel */
    };

    static const uint32_t ADCx_CALFACT_CALFACT_S_MASK[4] = {
      [1] = 0x000007FFU,   /** @brief ADC calibration factor in single-ended mode */
      [2] = 0x000007FFU,   /** @brief ADC calibration factor in single-ended mode */
      [3] = 0x000007FFU   /** @brief ADC calibration factor in single-ended mode */
    };

    static const uint32_t ADCx_PCSEL_PCSEL_MASK[4] = {
      [1] = 0x000FFFFFU,   /** @brief Channel x (vinp[i]) pre selection */
      [2] = 0x000FFFFFU,   /** @brief Channel x (vinp[i]) pre selection */
      [3] = 0x000FFFFFU   /** @brief Channel x (vinp[i]) pre selection */
    };

    static const uint32_t ADCx_CALFACT2_LINCALFACT_MASK[4] = {
      [1] = 0x3FFFFFFFU,   /** @brief Linearity calibration factor */
      [2] = 0x3FFFFFFFU,   /** @brief Linearity calibration factor */
      [3] = 0x3FFFFFFFU   /** @brief Linearity calibration factor */
    };

    static const uint32_t ADCx_LTRx_LTRx_MASK[4][4] = {
      [1] = {
        [2] = 0x03FFFFFFU,   /** @brief Analog watchdog 2 lower threshold */
        [3] = 0x03FFFFFFU,   /** @brief Analog watchdog 3 lower threshold */
        [1] = 0x03FFFFFFU   /** @brief ADC analog watchdog 1 threshold low */
      },
      [2] = {
        [2] = 0x03FFFFFFU,   /** @brief Analog watchdog 2 lower threshold */
        [3] = 0x03FFFFFFU,   /** @brief Analog watchdog 3 lower threshold */
        [1] = 0x03FFFFFFU   /** @brief ADC analog watchdog 1 threshold low */
      },
      [3] = {
        [2] = 0x03FFFFFFU,   /** @brief Analog watchdog 2 lower threshold */
        [3] = 0x03FFFFFFU,   /** @brief Analog watchdog 3 lower threshold */
        [1] = 0x03FFFFFFU   /** @brief ADC analog watchdog 1 threshold low */
      }
    };

    static const uint32_t ADCx_OFRx_OFFSET1_MASK[4][5] = {
      [1] = {
        [2] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [3] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [4] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [1] = 0x03FFFFFFU   /** @brief ADC offset number 1 offset level */
      },
      [2] = {
        [2] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [3] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [4] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [1] = 0x03FFFFFFU   /** @brief ADC offset number 1 offset level */
      },
      [3] = {
        [2] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [3] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [4] = 0x03FFFFFFU,   /** @brief ADC offset number 1 offset level */
        [1] = 0x03FFFFFFU   /** @brief ADC offset number 1 offset level */
      }
    };

    static const uint32_t ADCx_JDRx_JDATAx_MASK[4][5] = {
      [1] = {
        [2] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 2 conversion data */
        [3] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 3 conversion data */
        [4] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 4 conversion data */
        [1] = 0xFFFFFFFFU   /** @brief ADC group injected sequencer rank 1 conversion data */
      },
      [2] = {
        [2] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 2 conversion data */
        [3] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 3 conversion data */
        [4] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 4 conversion data */
        [1] = 0xFFFFFFFFU   /** @brief ADC group injected sequencer rank 1 conversion data */
      },
      [3] = {
        [2] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 2 conversion data */
        [3] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 3 conversion data */
        [4] = 0xFFFFFFFFU,   /** @brief ADC group injected sequencer rank 4 conversion data */
        [1] = 0xFFFFFFFFU   /** @brief ADC group injected sequencer rank 1 conversion data */
      }
    };

    static const uint32_t ADCx_AWDxCR_AWDxCH_MASK[4][4] = {
      [1] = {
        [3] = 0x001FFFFEU,   /** @brief ADC analog watchdog 3 monitored channel selection */
        [2] = 0x000FFFFFU   /** @brief ADC analog watchdog 2 monitored channel selection */
      },
      [2] = {
        [3] = 0x001FFFFEU,   /** @brief ADC analog watchdog 3 monitored channel selection */
        [2] = 0x000FFFFFU   /** @brief ADC analog watchdog 2 monitored channel selection */
      },
      [3] = {
        [3] = 0x001FFFFEU,   /** @brief ADC analog watchdog 3 monitored channel selection */
        [2] = 0x000FFFFFU   /** @brief ADC analog watchdog 2 monitored channel selection */
      }
    };

    static const uint32_t ADCx_HTRx_HTRx_MASK[4][4] = {
      [1] = {
        [3] = 0x03FFFFFFU,   /** @brief Analog watchdog 3 higher threshold */
        [2] = 0x03FFFFFFU   /** @brief Analog watchdog 2 higher threshold */
      },
      [2] = {
        [3] = 0x03FFFFFFU,   /** @brief Analog watchdog 3 higher threshold */
        [2] = 0x03FFFFFFU   /** @brief Analog watchdog 2 higher threshold */
      },
      [3] = {
        [3] = 0x03FFFFFFU,   /** @brief Analog watchdog 3 higher threshold */
        [2] = 0x03FFFFFFU   /** @brief Analog watchdog 2 higher threshold */
      }
    };

    static uint32_t ADCx_SMPRx_SMPx[4][3][20] = {
      [1] = {
        [2] = {
          [19] = 0x38000000U,   /** @brief ADC channel 18 sampling time selection */
          [18] = 0x07000000U,   /** @brief ADC channel 18 sampling time selection */
          [17] = 0x00E00000U,   /** @brief ADC channel 17 sampling time selection */
          [16] = 0x001C0000U,   /** @brief ADC channel 16 sampling time selection */
          [15] = 0x00038000U,   /** @brief ADC channel 15 sampling time selection */
          [14] = 0x00007000U,   /** @brief ADC channel 14 sampling time selection */
          [13] = 0x00000E00U,   /** @brief ADC channel 13 sampling time selection */
          [12] = 0x000001C0U,   /** @brief ADC channel 12 sampling time selection */
          [11] = 0x00000038U,   /** @brief ADC channel 11 sampling time selection */
          [10] = 0x00000007U   /** @brief ADC channel 10 sampling time selection */
        },
        [1] = {
          [8] = 0x07000000U,   /** @brief ADC channel 8 sampling time selection */
          [7] = 0x00E00000U,   /** @brief ADC channel 7 sampling time selection */
          [6] = 0x001C0000U,   /** @brief ADC channel 6 sampling time selection */
          [5] = 0x00038000U,   /** @brief ADC channel 5 sampling time selection */
          [4] = 0x00007000U,   /** @brief ADC channel 4 sampling time selection */
          [3] = 0x00000E00U,   /** @brief ADC channel 3 sampling time selection */
          [2] = 0x000001C0U,   /** @brief ADC channel 2 sampling time selection */
          [1] = 0x00000038U,   /** @brief ADC channel 1 sampling time selection */
          [9] = 0x38000000U   /** @brief ADC channel 9 sampling time selection */
        }
      },
      [2] = {
        [2] = {
          [19] = 0x38000000U,   /** @brief ADC channel 18 sampling time selection */
          [18] = 0x07000000U,   /** @brief ADC channel 18 sampling time selection */
          [17] = 0x00E00000U,   /** @brief ADC channel 17 sampling time selection */
          [16] = 0x001C0000U,   /** @brief ADC channel 16 sampling time selection */
          [15] = 0x00038000U,   /** @brief ADC channel 15 sampling time selection */
          [14] = 0x00007000U,   /** @brief ADC channel 14 sampling time selection */
          [13] = 0x00000E00U,   /** @brief ADC channel 13 sampling time selection */
          [12] = 0x000001C0U,   /** @brief ADC channel 12 sampling time selection */
          [11] = 0x00000038U,   /** @brief ADC channel 11 sampling time selection */
          [10] = 0x00000007U   /** @brief ADC channel 10 sampling time selection */
        },
        [1] = {
          [8] = 0x07000000U,   /** @brief ADC channel 8 sampling time selection */
          [7] = 0x00E00000U,   /** @brief ADC channel 7 sampling time selection */
          [6] = 0x001C0000U,   /** @brief ADC channel 6 sampling time selection */
          [5] = 0x00038000U,   /** @brief ADC channel 5 sampling time selection */
          [4] = 0x00007000U,   /** @brief ADC channel 4 sampling time selection */
          [3] = 0x00000E00U,   /** @brief ADC channel 3 sampling time selection */
          [2] = 0x000001C0U,   /** @brief ADC channel 2 sampling time selection */
          [1] = 0x00000038U,   /** @brief ADC channel 1 sampling time selection */
          [9] = 0x38000000U   /** @brief ADC channel 9 sampling time selection */
        }
      },
      [3] = {
        [2] = {
          [19] = 0x38000000U,   /** @brief ADC channel 18 sampling time selection */
          [18] = 0x07000000U,   /** @brief ADC channel 18 sampling time selection */
          [17] = 0x00E00000U,   /** @brief ADC channel 17 sampling time selection */
          [16] = 0x001C0000U,   /** @brief ADC channel 16 sampling time selection */
          [15] = 0x00038000U,   /** @brief ADC channel 15 sampling time selection */
          [14] = 0x00007000U,   /** @brief ADC channel 14 sampling time selection */
          [13] = 0x00000E00U,   /** @brief ADC channel 13 sampling time selection */
          [12] = 0x000001C0U,   /** @brief ADC channel 12 sampling time selection */
          [11] = 0x00000038U,   /** @brief ADC channel 11 sampling time selection */
          [10] = 0x00000007U   /** @brief ADC channel 10 sampling time selection */
        },
        [1] = {
          [8] = 0x07000000U,   /** @brief ADC channel 8 sampling time selection */
          [7] = 0x00E00000U,   /** @brief ADC channel 7 sampling time selection */
          [6] = 0x001C0000U,   /** @brief ADC channel 6 sampling time selection */
          [5] = 0x00038000U,   /** @brief ADC channel 5 sampling time selection */
          [4] = 0x00007000U,   /** @brief ADC channel 4 sampling time selection */
          [3] = 0x00000E00U,   /** @brief ADC channel 3 sampling time selection */
          [2] = 0x000001C0U,   /** @brief ADC channel 2 sampling time selection */
          [1] = 0x00000038U,   /** @brief ADC channel 1 sampling time selection */
          [9] = 0x38000000U   /** @brief ADC channel 9 sampling time selection */
        }
      }
    };

    /**********************************************************************************************
     * @section ADC_COMMON Register Definitions
     **********************************************************************************************/

    /**** @subsection ADC_COMMON Register Pointer Definitions ****/

    static RO_ uint32_t* const ADCx_COMMON_CSR_PTR[13] = {
      [12] = (RO_ uint32_t*)0x40022300U,   /** @brief ADC common status register */
      [3]  = (RO_ uint32_t*)0x58026300U   /** @brief ADC common status register */
    };

    static RW_ uint32_t* const ADCx_COMMON_CCR_PTR[13] = {
      [12] = (RW_ uint32_t*)0x40022308U,   /** @brief ADC common control register */
      [3]  = (RW_ uint32_t*)0x58026308U   /** @brief ADC common control register */
    };

    static RO_ uint32_t* const ADCx_COMMON_CDR_PTR[13] = {
      [12] = (RO_ uint32_t*)0x4002230CU,   /** @brief ADC common regular data register for dual and triple modes */
      [3]  = (RO_ uint32_t*)0x5802630CU   /** @brief ADC common regular data register for dual and triple modes */
    };

    static RO_ uint32_t* const ADCx_COMMON_CDR2_PTR[13] = {
      [12] = (RO_ uint32_t*)0x40022310U,   /** @brief ADC x common regular data register for 32-bit dual mode */
      [3]  = (RO_ uint32_t*)0x58026310U   /** @brief ADC x common regular data register for 32-bit dual mode */
    };

    /**** @subsection ADC_COMMON Register Reset Value Definitions ****/

    static const uint32_t ADCx_COMMON_CSR_RST[13] = {
      [12] = 0x00000000U,   /** @brief ADC common status register */
      [3]  = 0x00000000U   /** @brief ADC common status register */
    };

    static const uint32_t ADCx_COMMON_CCR_RST[13] = {
      [12] = 0x00000000U,   /** @brief ADC common control register */
      [3]  = 0x00000000U   /** @brief ADC common control register */
    };

    static const uint32_t ADCx_COMMON_CDR_RST[13] = {
      [12] = 0x00000000U,   /** @brief ADC common regular data register for dual and triple modes */
      [3]  = 0x00000000U   /** @brief ADC common regular data register for dual and triple modes */
    };

    static const uint32_t ADCx_COMMON_CDR2_RST[13] = {
      [12] = 0x00000000U,   /** @brief ADC x common regular data register for 32-bit dual mode */
      [3]  = 0x00000000U   /** @brief ADC x common regular data register for 32-bit dual mode */
    };

    /**** @subsection ADC_COMMON Register Value Type Definitions ****/

    typedef uint32_t ADCx_COMMON_CSR_vt;    /** @brief ADCx_COMMON_CSR register value type. */
    typedef uint32_t ADCx_COMMON_CCR_vt;    /** @brief ADCx_COMMON_CCR register value type. */
    typedef uint32_t ADCx_COMMON_CDR_vt;    /** @brief ADCx_COMMON_CDR register value type. */
    typedef uint32_t ADCx_COMMON_CDR2_vt;   /** @brief ADCx_COMMON_CDR2 register value type. */

    /**** @subsection ADC_COMMON Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* ADCx_COMMON_CSR_pt;    /** @brief ADCx_COMMON_CSR pointer register pointer type. */
    typedef RW_ uint32_t* ADCx_COMMON_CCR_pt;    /** @brief ADCx_COMMON_CCR pointer register pointer type. */
    typedef RO_ uint32_t* ADCx_COMMON_CDR_pt;    /** @brief ADCx_COMMON_CDR pointer register pointer type. */
    typedef RO_ uint32_t* ADCx_COMMON_CDR2_pt;   /** @brief ADCx_COMMON_CDR2 pointer register pointer type. */

    /**** @subsection ADC_COMMON Field Mask Definitions ****/

    static const uint32_t ADCx_COMMON_CSR_JQOVF_SLV_MASK[13] = {
      [12] = 0x04000000U,   /** @brief Injected context queue overflow flag of the slave ADC */
      [3]  = 0x04000000U   /** @brief Injected context queue overflow flag of the slave ADC */
    };

    static const uint32_t ADCx_COMMON_CCR_VBATEN_MASK[13] = {
      [12] = 0x01000000U,   /** @brief VBAT enable */
      [3]  = 0x01000000U   /** @brief VBAT enable */
    };

    static const uint32_t ADCx_COMMON_CDR_RDATA_MST_MASK[13] = {
      [12] = 0x0000FFFFU,   /** @brief Regular data of the master ADC */
      [3]  = 0x0000FFFFU   /** @brief Regular data of the master ADC */
    };

    static const uint32_t ADCx_COMMON_CDR2_RDATA_ALT_MASK[13] = {
      [12] = 0xFFFFFFFFU,   /** @brief Regular data of the master/slave alternated adcs */
      [3]  = 0xFFFFFFFFU   /** @brief Regular data of the master/slave alternated adcs */
    };

    /**********************************************************************************************
     * @section CRC Register Definitions
     **********************************************************************************************/

    /**** @subsection CRC Register Pointer Definitions ****/

    static RW_ uint32_t* const CRC_DR_PTR   = (RW_ uint32_t*)0x58024C00U;   /** @brief Data register */
    static RW_ uint32_t* const CRC_IDR_PTR  = (RW_ uint32_t*)0x58024C04U;   /** @brief Independent data register */
    static RW_ uint32_t* const CRC_CR_PTR   = (RW_ uint32_t*)0x58024C08U;   /** @brief Control register */
    static RW_ uint32_t* const CRC_INIT_PTR = (RW_ uint32_t*)0x58024C0CU;   /** @brief Initial CRC value */
    static RW_ uint32_t* const CRC_POL_PTR  = (RW_ uint32_t*)0x58024C10U;   /** @brief CRC polynomial */

    /**** @subsection CRC Register Reset Value Definitions ****/

    static const uint32_t CRC_DR_RST   = 0xFFFFFFFFU;   /** @brief Data register */
    static const uint32_t CRC_IDR_RST  = 0x00000000U;   /** @brief Independent data register */
    static const uint32_t CRC_CR_RST   = 0x00000000U;   /** @brief Control register */
    static const uint32_t CRC_INIT_RST = 0x00000000U;   /** @brief Initial CRC value */
    static const uint32_t CRC_POL_RST  = 0x00000000U;   /** @brief CRC polynomial */

    /**** @subsection CRC Register Value Type Definitions ****/

    typedef uint32_t CRC_DR_vt;     /** @brief CRC_DR register value type. */
    typedef uint32_t CRC_IDR_vt;    /** @brief CRC_IDR register value type. */
    typedef uint32_t CRC_CR_vt;     /** @brief CRC_CR register value type. */
    typedef uint32_t CRC_INIT_vt;   /** @brief CRC_INIT register value type. */
    typedef uint32_t CRC_POL_vt;    /** @brief CRC_POL register value type. */

    /**** @subsection CRC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* CRC_DR_pt;     /** @brief CRC_DR pointer register pointer type. */
    typedef RW_ uint32_t* CRC_IDR_pt;    /** @brief CRC_IDR pointer register pointer type. */
    typedef RW_ uint32_t* CRC_CR_pt;     /** @brief CRC_CR pointer register pointer type. */
    typedef RW_ uint32_t* CRC_INIT_pt;   /** @brief CRC_INIT pointer register pointer type. */
    typedef RW_ uint32_t* CRC_POL_pt;    /** @brief CRC_POL pointer register pointer type. */

    /**** @subsection CRC Field Mask Definitions ****/

    static const uint32_t CRC_DR_DR_MASK         = 0xFFFFFFFFU;   /** @brief Data register */
    static const uint32_t CRC_IDR_IDR_MASK       = 0xFFFFFFFFU;   /** @brief Independent data register */
    static const uint32_t CRC_CR_REV_OUT_MASK    = 0x00000080U;   /** @brief Reverse output data */
    static const uint32_t CRC_INIT_CRC_INIT_MASK = 0xFFFFFFFFU;   /** @brief Programmable initial CRC value */
    static const uint32_t CRC_POL_POL_MASK       = 0xFFFFFFFFU;   /** @brief Programmable polynomial */

    /**********************************************************************************************
     * @section RCC Register Definitions
     **********************************************************************************************/

    /**** @subsection RCC Register Pointer Definitions ****/

    static RW_ uint32_t* const RCC_CR_PTR            = (RW_ uint32_t*)0x58024400U;   /** @brief Clock control register */
    static RW_ uint32_t* const RCC_ICSCR_PTR         = (RW_ uint32_t*)0x58024404U;   /** @brief RCC internal clock source calibration register */
    static RO_ uint32_t* const RCC_CRRCR_PTR         = (RO_ uint32_t*)0x58024408U;   /** @brief RCC clock recovery RC register */
    static RW_ uint32_t* const RCC_CFGR_PTR          = (RW_ uint32_t*)0x58024410U;   /** @brief RCC clock configuration register */
    static RW_ uint32_t* const RCC_PLLCKSELR_PTR     = (RW_ uint32_t*)0x58024428U;   /** @brief RCC plls clock source selection register */
    static RW_ uint32_t* const RCC_PLLCFGR_PTR       = (RW_ uint32_t*)0x5802442CU;   /** @brief RCC plls configuration register */
    static RW_ uint32_t* const RCC_CIER_PTR          = (RW_ uint32_t*)0x58024460U;   /** @brief RCC clock source interrupt enable register */
    static RW_ uint32_t* const RCC_CIFR_PTR          = (RW_ uint32_t*)0x58024464U;   /** @brief RCC clock source interrupt flag register */
    static RW_ uint32_t* const RCC_CICR_PTR          = (RW_ uint32_t*)0x58024468U;   /** @brief RCC clock source interrupt clear register */
    static RW_ uint32_t* const RCC_BDCR_PTR          = (RW_ uint32_t*)0x58024470U;   /** @brief RCC backup domain control register */
    static RW_ uint32_t* const RCC_CSR_PTR           = (RW_ uint32_t*)0x58024474U;   /** @brief RCC clock control and status register */
    static RW_ uint32_t* const RCC_APB1LRSTR_PTR     = (RW_ uint32_t*)0x58024490U;   /** @brief RCC APB1 peripheral reset register */
    static RW_ uint32_t* const RCC_APB1HRSTR_PTR     = (RW_ uint32_t*)0x58024494U;   /** @brief RCC APB1 peripheral reset register */
    static RW_ uint32_t* const RCC_GCR_PTR           = (RW_ uint32_t*)0x580244A0U;   /** @brief RCC global control register */
    static RW_ uint32_t* const RCC_D3AMR_PTR         = (RW_ uint32_t*)0x580244A8U;   /** @brief RCC D3 autonomous mode register */
    static RW_ uint32_t* const RCC_RSR_PTR           = (RW_ uint32_t*)0x580244D0U;   /** @brief RCC reset status register */
    static RW_ uint32_t* const RCC_C1_RSR_PTR        = (RW_ uint32_t*)0x58024530U;   /** @brief RCC reset status register */
    static RW_ uint32_t* const RCC_APB1LENR_PTR      = (RW_ uint32_t*)0x580244E8U;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_C1_APB1LENR_PTR   = (RW_ uint32_t*)0x58024548U;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_APB1HENR_PTR      = (RW_ uint32_t*)0x580244ECU;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_C1_APB1HENR_PTR   = (RW_ uint32_t*)0x5802454CU;   /** @brief RCC APB1 clock register */
    static RW_ uint32_t* const RCC_APB1LLPENR_PTR    = (RW_ uint32_t*)0x58024510U;   /** @brief RCC APB1 low sleep clock register */
    static RW_ uint32_t* const RCC_C1_APB1LLPENR_PTR = (RW_ uint32_t*)0x58024570U;   /** @brief RCC APB1 low sleep clock register */
    static RW_ uint32_t* const RCC_C1_APB1HLPENR_PTR = (RW_ uint32_t*)0x58024574U;   /** @brief RCC APB1 high sleep clock register */
    static RW_ uint32_t* const RCC_APB1HLPENR_PTR    = (RW_ uint32_t*)0x58024514U;   /** @brief RCC APB1 high sleep clock register */

    static RW_ uint32_t* const RCC_DxCFGR_PTR[4] = {
      [2] = (RW_ uint32_t*)0x5802441CU,   /** @brief RCC domain 2 clock configuration register */
      [3] = (RW_ uint32_t*)0x58024420U,   /** @brief RCC domain 3 clock configuration register */
      [1] = (RW_ uint32_t*)0x58024418U   /** @brief RCC domain 1 clock configuration register */
    };

    static RW_ uint32_t* const RCC_PLLxDIVR_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58024438U,   /** @brief RCC PLL2 dividers configuration register */
      [3] = (RW_ uint32_t*)0x58024440U,   /** @brief RCC PLL3 dividers configuration register */
      [1] = (RW_ uint32_t*)0x58024430U   /** @brief RCC PLL1 dividers configuration register */
    };

    static RW_ uint32_t* const RCC_PLLxFRACR_PTR[4] = {
      [2] = (RW_ uint32_t*)0x5802443CU,   /** @brief RCC PLL2 fractional divider register */
      [3] = (RW_ uint32_t*)0x58024444U,   /** @brief RCC PLL3 fractional divider register */
      [1] = (RW_ uint32_t*)0x58024434U   /** @brief RCC PLL1 fractional divider register */
    };

    static RW_ uint32_t* const RCC_DxCCIPR_PTR[4] = {
      [3] = (RW_ uint32_t*)0x58024458U,   /** @brief RCC domain 3 kernel clock configuration register */
      [1] = (RW_ uint32_t*)0x5802444CU   /** @brief RCC domain 1 kernel clock configuration register */
    };

    static RW_ uint32_t* const RCC_D2CCIPxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x58024454U,   /** @brief RCC domain 2 kernel clock configuration register */
      [1] = (RW_ uint32_t*)0x58024450U   /** @brief RCC domain 2 kernel clock configuration register */
    };

    static RW_ uint32_t* const RCC_AHBxRSTR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x58024480U,   /** @brief RCC AHB1 peripheral reset register */
      [2] = (RW_ uint32_t*)0x58024484U,   /** @brief RCC AHB2 peripheral reset register */
      [4] = (RW_ uint32_t*)0x58024488U,   /** @brief RCC AHB4 peripheral reset register */
      [3] = (RW_ uint32_t*)0x5802447CU   /** @brief RCC AHB3 reset register */
    };

    static RW_ uint32_t* const RCC_APBxRSTR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x58024498U,   /** @brief RCC APB2 peripheral reset register */
      [4] = (RW_ uint32_t*)0x5802449CU,   /** @brief RCC APB4 peripheral reset register */
      [3] = (RW_ uint32_t*)0x5802448CU   /** @brief RCC APB3 peripheral reset register */
    };

    static RW_ uint32_t* const RCC_C1_AHBxENR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x58024538U,   /** @brief RCC AHB1 clock register */
      [2] = (RW_ uint32_t*)0x5802453CU,   /** @brief RCC AHB2 clock register */
      [4] = (RW_ uint32_t*)0x58024540U,   /** @brief RCC AHB4 clock register */
      [3] = (RW_ uint32_t*)0x58024534U   /** @brief RCC AHB3 clock register */
    };

    static RW_ uint32_t* const RCC_AHBxENR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x580244D8U,   /** @brief RCC AHB1 clock register */
      [2] = (RW_ uint32_t*)0x580244DCU,   /** @brief RCC AHB2 clock register */
      [4] = (RW_ uint32_t*)0x580244E0U,   /** @brief RCC AHB4 clock register */
      [3] = (RW_ uint32_t*)0x580244D4U   /** @brief RCC AHB3 clock register */
    };

    static RW_ uint32_t* const RCC_C1_APBxENR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x58024550U,   /** @brief RCC APB2 clock register */
      [4] = (RW_ uint32_t*)0x58024554U,   /** @brief RCC APB4 clock register */
      [3] = (RW_ uint32_t*)0x58024544U   /** @brief RCC APB3 clock register */
    };

    static RW_ uint32_t* const RCC_APBxENR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x580244F0U,   /** @brief RCC APB2 clock register */
      [4] = (RW_ uint32_t*)0x580244F4U,   /** @brief RCC APB4 clock register */
      [3] = (RW_ uint32_t*)0x580244E4U   /** @brief RCC APB3 clock register */
    };

    static RW_ uint32_t* const RCC_C1_AHBxLPENR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x58024560U,   /** @brief RCC AHB1 sleep clock register */
      [2] = (RW_ uint32_t*)0x58024564U,   /** @brief RCC AHB2 sleep clock register */
      [4] = (RW_ uint32_t*)0x58024568U,   /** @brief RCC AHB4 sleep clock register */
      [3] = (RW_ uint32_t*)0x5802455CU   /** @brief RCC AHB3 sleep clock register */
    };

    static RW_ uint32_t* const RCC_AHBxLPENR_PTR[5] = {
      [1] = (RW_ uint32_t*)0x58024500U,   /** @brief RCC AHB1 sleep clock register */
      [2] = (RW_ uint32_t*)0x58024504U,   /** @brief RCC AHB2 sleep clock register */
      [4] = (RW_ uint32_t*)0x58024508U,   /** @brief RCC AHB4 sleep clock register */
      [3] = (RW_ uint32_t*)0x580244FCU   /** @brief RCC AHB3 sleep clock register */
    };

    static RW_ uint32_t* const RCC_C1_APBxLPENR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x58024578U,   /** @brief RCC APB2 sleep clock register */
      [4] = (RW_ uint32_t*)0x5802457CU,   /** @brief RCC APB4 sleep clock register */
      [3] = (RW_ uint32_t*)0x5802456CU   /** @brief RCC APB3 sleep clock register */
    };

    static RW_ uint32_t* const RCC_APBxLPENR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x58024518U,   /** @brief RCC APB2 sleep clock register */
      [4] = (RW_ uint32_t*)0x5802451CU,   /** @brief RCC APB4 sleep clock register */
      [3] = (RW_ uint32_t*)0x5802450CU   /** @brief RCC APB3 sleep clock register */
    };

    /**** @subsection RCC Register Reset Value Definitions ****/

    static const uint32_t RCC_CR_RST            = 0x00000083U;   /** @brief Clock control register */
    static const uint32_t RCC_ICSCR_RST         = 0x40000000U;   /** @brief RCC internal clock source calibration register */
    static const uint32_t RCC_CRRCR_RST         = 0x00000000U;   /** @brief RCC clock recovery RC register */
    static const uint32_t RCC_CFGR_RST          = 0x00000000U;   /** @brief RCC clock configuration register */
    static const uint32_t RCC_PLLCKSELR_RST     = 0x02020200U;   /** @brief RCC plls clock source selection register */
    static const uint32_t RCC_PLLCFGR_RST       = 0x01FF0000U;   /** @brief RCC plls configuration register */
    static const uint32_t RCC_CIER_RST          = 0x00000000U;   /** @brief RCC clock source interrupt enable register */
    static const uint32_t RCC_CIFR_RST          = 0x00000000U;   /** @brief RCC clock source interrupt flag register */
    static const uint32_t RCC_CICR_RST          = 0x00000000U;   /** @brief RCC clock source interrupt clear register */
    static const uint32_t RCC_BDCR_RST          = 0x00000000U;   /** @brief RCC backup domain control register */
    static const uint32_t RCC_CSR_RST           = 0x00000000U;   /** @brief RCC clock control and status register */
    static const uint32_t RCC_APB1LRSTR_RST     = 0x00000000U;   /** @brief RCC APB1 peripheral reset register */
    static const uint32_t RCC_APB1HRSTR_RST     = 0x00000000U;   /** @brief RCC APB1 peripheral reset register */
    static const uint32_t RCC_GCR_RST           = 0x00000000U;   /** @brief RCC global control register */
    static const uint32_t RCC_D3AMR_RST         = 0x00000000U;   /** @brief RCC D3 autonomous mode register */
    static const uint32_t RCC_RSR_RST           = 0x00000000U;   /** @brief RCC reset status register */
    static const uint32_t RCC_C1_RSR_RST        = 0x00000000U;   /** @brief RCC reset status register */
    static const uint32_t RCC_APB1LENR_RST      = 0x00000000U;   /** @brief RCC APB1 clock register */
    static const uint32_t RCC_C1_APB1LENR_RST   = 0x00000000U;   /** @brief RCC APB1 clock register */
    static const uint32_t RCC_APB1HENR_RST      = 0x00000000U;   /** @brief RCC APB1 clock register */
    static const uint32_t RCC_C1_APB1HENR_RST   = 0x00000000U;   /** @brief RCC APB1 clock register */
    static const uint32_t RCC_APB1LLPENR_RST    = 0x00000000U;   /** @brief RCC APB1 low sleep clock register */
    static const uint32_t RCC_C1_APB1LLPENR_RST = 0x00000000U;   /** @brief RCC APB1 low sleep clock register */
    static const uint32_t RCC_C1_APB1HLPENR_RST = 0x00000000U;   /** @brief RCC APB1 high sleep clock register */
    static const uint32_t RCC_APB1HLPENR_RST    = 0x00000000U;   /** @brief RCC APB1 high sleep clock register */

    static const uint32_t RCC_DxCFGR_RST[4] = {
      [2] = 0x00000000U,   /** @brief RCC domain 2 clock configuration register */
      [3] = 0x00000000U,   /** @brief RCC domain 3 clock configuration register */
      [1] = 0x00000000U   /** @brief RCC domain 1 clock configuration register */
    };

    static const uint32_t RCC_PLLxDIVR_RST[4] = {
      [2] = 0x01010280U,   /** @brief RCC PLL2 dividers configuration register */
      [3] = 0x01010280U,   /** @brief RCC PLL3 dividers configuration register */
      [1] = 0x01010280U   /** @brief RCC PLL1 dividers configuration register */
    };

    static const uint32_t RCC_PLLxFRACR_RST[4] = {
      [2] = 0x00000000U,   /** @brief RCC PLL2 fractional divider register */
      [3] = 0x00000000U,   /** @brief RCC PLL3 fractional divider register */
      [1] = 0x00000000U   /** @brief RCC PLL1 fractional divider register */
    };

    static const uint32_t RCC_DxCCIPR_RST[4] = {
      [3] = 0x00000000U,   /** @brief RCC domain 3 kernel clock configuration register */
      [1] = 0x00000000U   /** @brief RCC domain 1 kernel clock configuration register */
    };

    static const uint32_t RCC_D2CCIPxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief RCC domain 2 kernel clock configuration register */
      [1] = 0x00000000U   /** @brief RCC domain 2 kernel clock configuration register */
    };

    static const uint32_t RCC_AHBxRSTR_RST[5] = {
      [1] = 0x00000000U,   /** @brief RCC AHB1 peripheral reset register */
      [2] = 0x00000000U,   /** @brief RCC AHB2 peripheral reset register */
      [4] = 0x00000000U,   /** @brief RCC AHB4 peripheral reset register */
      [3] = 0x00000000U   /** @brief RCC AHB3 reset register */
    };

    static const uint32_t RCC_APBxRSTR_RST[5] = {
      [2] = 0x00000000U,   /** @brief RCC APB2 peripheral reset register */
      [4] = 0x00000000U,   /** @brief RCC APB4 peripheral reset register */
      [3] = 0x00000000U   /** @brief RCC APB3 peripheral reset register */
    };

    static const uint32_t RCC_C1_AHBxENR_RST[5] = {
      [1] = 0x00000000U,   /** @brief RCC AHB1 clock register */
      [2] = 0x00000000U,   /** @brief RCC AHB2 clock register */
      [4] = 0x00000000U,   /** @brief RCC AHB4 clock register */
      [3] = 0x00000000U   /** @brief RCC AHB3 clock register */
    };

    static const uint32_t RCC_AHBxENR_RST[5] = {
      [1] = 0x00000000U,   /** @brief RCC AHB1 clock register */
      [2] = 0x00000000U,   /** @brief RCC AHB2 clock register */
      [4] = 0x00000000U,   /** @brief RCC AHB4 clock register */
      [3] = 0x00000000U   /** @brief RCC AHB3 clock register */
    };

    static const uint32_t RCC_C1_APBxENR_RST[5] = {
      [2] = 0x00000000U,   /** @brief RCC APB2 clock register */
      [4] = 0x00000000U,   /** @brief RCC APB4 clock register */
      [3] = 0x00000000U   /** @brief RCC APB3 clock register */
    };

    static const uint32_t RCC_APBxENR_RST[5] = {
      [2] = 0x00000000U,   /** @brief RCC APB2 clock register */
      [4] = 0x00000000U,   /** @brief RCC APB4 clock register */
      [3] = 0x00000000U   /** @brief RCC APB3 clock register */
    };

    static const uint32_t RCC_C1_AHBxLPENR_RST[5] = {
      [1] = 0x00000000U,   /** @brief RCC AHB1 sleep clock register */
      [2] = 0x00000000U,   /** @brief RCC AHB2 sleep clock register */
      [4] = 0x00000000U,   /** @brief RCC AHB4 sleep clock register */
      [3] = 0x00000000U   /** @brief RCC AHB3 sleep clock register */
    };

    static const uint32_t RCC_AHBxLPENR_RST[5] = {
      [1] = 0x00000000U,   /** @brief RCC AHB1 sleep clock register */
      [2] = 0x00000000U,   /** @brief RCC AHB2 sleep clock register */
      [4] = 0x00000000U,   /** @brief RCC AHB4 sleep clock register */
      [3] = 0x00000000U   /** @brief RCC AHB3 sleep clock register */
    };

    static const uint32_t RCC_C1_APBxLPENR_RST[5] = {
      [2] = 0x00000000U,   /** @brief RCC APB2 sleep clock register */
      [4] = 0x00000000U,   /** @brief RCC APB4 sleep clock register */
      [3] = 0x00000000U   /** @brief RCC APB3 sleep clock register */
    };

    static const uint32_t RCC_APBxLPENR_RST[5] = {
      [2] = 0x00000000U,   /** @brief RCC APB2 sleep clock register */
      [4] = 0x00000000U,   /** @brief RCC APB4 sleep clock register */
      [3] = 0x00000000U   /** @brief RCC APB3 sleep clock register */
    };

    /**** @subsection RCC Register Value Type Definitions ****/

    typedef uint32_t RCC_CR_vt;              /** @brief RCC_CR register value type. */
    typedef uint32_t RCC_ICSCR_vt;           /** @brief RCC_ICSCR register value type. */
    typedef uint32_t RCC_CRRCR_vt;           /** @brief RCC_CRRCR register value type. */
    typedef uint32_t RCC_CFGR_vt;            /** @brief RCC_CFGR register value type. */
    typedef uint32_t RCC_DxCFGR_vt;          /** @brief RCC_DxCFGR register value type. */
    typedef uint32_t RCC_PLLCKSELR_vt;       /** @brief RCC_PLLCKSELR register value type. */
    typedef uint32_t RCC_PLLCFGR_vt;         /** @brief RCC_PLLCFGR register value type. */
    typedef uint32_t RCC_PLLxDIVR_vt;        /** @brief RCC_PLLxDIVR register value type. */
    typedef uint32_t RCC_PLLxFRACR_vt;       /** @brief RCC_PLLxFRACR register value type. */
    typedef uint32_t RCC_DxCCIPR_vt;         /** @brief RCC_DxCCIPR register value type. */
    typedef uint32_t RCC_D2CCIPxR_vt;        /** @brief RCC_D2CCIPxR register value type. */
    typedef uint32_t RCC_CIER_vt;            /** @brief RCC_CIER register value type. */
    typedef uint32_t RCC_CIFR_vt;            /** @brief RCC_CIFR register value type. */
    typedef uint32_t RCC_CICR_vt;            /** @brief RCC_CICR register value type. */
    typedef uint32_t RCC_BDCR_vt;            /** @brief RCC_BDCR register value type. */
    typedef uint32_t RCC_CSR_vt;             /** @brief RCC_CSR register value type. */
    typedef uint32_t RCC_AHBxRSTR_vt;        /** @brief RCC_AHBxRSTR register value type. */
    typedef uint32_t RCC_APBxRSTR_vt;        /** @brief RCC_APBxRSTR register value type. */
    typedef uint32_t RCC_APB1LRSTR_vt;       /** @brief RCC_APB1LRSTR register value type. */
    typedef uint32_t RCC_APB1HRSTR_vt;       /** @brief RCC_APB1HRSTR register value type. */
    typedef uint32_t RCC_GCR_vt;             /** @brief RCC_GCR register value type. */
    typedef uint32_t RCC_D3AMR_vt;           /** @brief RCC_D3AMR register value type. */
    typedef uint32_t RCC_RSR_vt;             /** @brief RCC_RSR register value type. */
    typedef uint32_t RCC_C1_RSR_vt;          /** @brief RCC_C1_RSR register value type. */
    typedef uint32_t RCC_C1_AHBxENR_vt;      /** @brief RCC_C1_AHBxENR register value type. */
    typedef uint32_t RCC_AHBxENR_vt;         /** @brief RCC_AHBxENR register value type. */
    typedef uint32_t RCC_C1_APBxENR_vt;      /** @brief RCC_C1_APBxENR register value type. */
    typedef uint32_t RCC_APBxENR_vt;         /** @brief RCC_APBxENR register value type. */
    typedef uint32_t RCC_APB1LENR_vt;        /** @brief RCC_APB1LENR register value type. */
    typedef uint32_t RCC_C1_APB1LENR_vt;     /** @brief RCC_C1_APB1LENR register value type. */
    typedef uint32_t RCC_APB1HENR_vt;        /** @brief RCC_APB1HENR register value type. */
    typedef uint32_t RCC_C1_APB1HENR_vt;     /** @brief RCC_C1_APB1HENR register value type. */
    typedef uint32_t RCC_C1_AHBxLPENR_vt;    /** @brief RCC_C1_AHBxLPENR register value type. */
    typedef uint32_t RCC_AHBxLPENR_vt;       /** @brief RCC_AHBxLPENR register value type. */
    typedef uint32_t RCC_C1_APBxLPENR_vt;    /** @brief RCC_C1_APBxLPENR register value type. */
    typedef uint32_t RCC_APBxLPENR_vt;       /** @brief RCC_APBxLPENR register value type. */
    typedef uint32_t RCC_APB1LLPENR_vt;      /** @brief RCC_APB1LLPENR register value type. */
    typedef uint32_t RCC_C1_APB1LLPENR_vt;   /** @brief RCC_C1_APB1LLPENR register value type. */
    typedef uint32_t RCC_C1_APB1HLPENR_vt;   /** @brief RCC_C1_APB1HLPENR register value type. */
    typedef uint32_t RCC_APB1HLPENR_vt;      /** @brief RCC_APB1HLPENR register value type. */

    /**** @subsection RCC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* RCC_CR_pt;              /** @brief RCC_CR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_ICSCR_pt;           /** @brief RCC_ICSCR pointer register pointer type. */
    typedef RO_ uint32_t* RCC_CRRCR_pt;           /** @brief RCC_CRRCR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_CFGR_pt;            /** @brief RCC_CFGR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_DxCFGR_pt;          /** @brief RCC_DxCFGR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_PLLCKSELR_pt;       /** @brief RCC_PLLCKSELR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_PLLCFGR_pt;         /** @brief RCC_PLLCFGR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_PLLxDIVR_pt;        /** @brief RCC_PLLxDIVR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_PLLxFRACR_pt;       /** @brief RCC_PLLxFRACR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_DxCCIPR_pt;         /** @brief RCC_DxCCIPR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_D2CCIPxR_pt;        /** @brief RCC_D2CCIPxR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_CIER_pt;            /** @brief RCC_CIER pointer register pointer type. */
    typedef RW_ uint32_t* RCC_CIFR_pt;            /** @brief RCC_CIFR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_CICR_pt;            /** @brief RCC_CICR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_BDCR_pt;            /** @brief RCC_BDCR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_CSR_pt;             /** @brief RCC_CSR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_AHBxRSTR_pt;        /** @brief RCC_AHBxRSTR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APBxRSTR_pt;        /** @brief RCC_APBxRSTR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APB1LRSTR_pt;       /** @brief RCC_APB1LRSTR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APB1HRSTR_pt;       /** @brief RCC_APB1HRSTR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_GCR_pt;             /** @brief RCC_GCR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_D3AMR_pt;           /** @brief RCC_D3AMR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_RSR_pt;             /** @brief RCC_RSR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_RSR_pt;          /** @brief RCC_C1_RSR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_AHBxENR_pt;      /** @brief RCC_C1_AHBxENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_AHBxENR_pt;         /** @brief RCC_AHBxENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_APBxENR_pt;      /** @brief RCC_C1_APBxENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APBxENR_pt;         /** @brief RCC_APBxENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APB1LENR_pt;        /** @brief RCC_APB1LENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_APB1LENR_pt;     /** @brief RCC_C1_APB1LENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APB1HENR_pt;        /** @brief RCC_APB1HENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_APB1HENR_pt;     /** @brief RCC_C1_APB1HENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_AHBxLPENR_pt;    /** @brief RCC_C1_AHBxLPENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_AHBxLPENR_pt;       /** @brief RCC_AHBxLPENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_APBxLPENR_pt;    /** @brief RCC_C1_APBxLPENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APBxLPENR_pt;       /** @brief RCC_APBxLPENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APB1LLPENR_pt;      /** @brief RCC_APB1LLPENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_APB1LLPENR_pt;   /** @brief RCC_C1_APB1LLPENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_C1_APB1HLPENR_pt;   /** @brief RCC_C1_APB1HLPENR pointer register pointer type. */
    typedef RW_ uint32_t* RCC_APB1HLPENR_pt;      /** @brief RCC_APB1HLPENR pointer register pointer type. */

    /**** @subsection RCC Field Mask Definitions ****/

    static const uint32_t RCC_ICSCR_CSITRIM_MASK            = 0x7C000000U;   /** @brief CSI clock trimming */
    static const uint32_t RCC_CRRCR_RC48CAL_MASK            = 0x000003FFU;   /** @brief Internal RC 48 mhz clock calibration */
    static const uint32_t RCC_DxCFGR_D1CPRE_MASK            = 0x00000F00U;   /** @brief D1 domain core prescaler */
    static const uint32_t RCC_DxCCIPR_CKPERSRC_MASK         = 0x30000000U;   /** @brief Per_ck clock source selection */
    static const uint32_t RCC_D2CCIPxR_SWPSRC_MASK          = 0x80000000U;   /** @brief SWPMI kernel clock source selection */
    static const uint32_t RCC_CIER_LSECSSIE_MASK            = 0x00000200U;   /** @brief LSE clock security system interrupt enable */
    static const uint32_t RCC_CIFR_HSECSSF_MASK             = 0x00000400U;   /** @brief HSE clock security system interrupt flag */
    static const uint32_t RCC_CICR_HSECSSC_MASK             = 0x00000400U;   /** @brief HSE clock security system interrupt clear */
    static const uint32_t RCC_BDCR_VSWRST_MASK              = 0x00010000U;   /** @brief VSwitch domain software reset */
    static const uint32_t RCC_CSR_LSIRDY_MASK               = 0x00000002U;   /** @brief LSI oscillator ready */
    static const uint32_t RCC_AHBxRSTR_CPURST_MASK          = 0x80000000U;   /** @brief CPU reset */
    static const uint32_t RCC_APBxRSTR_LTDCRST_MASK         = 0x00000008U;   /** @brief LTDC block reset */
    static const uint32_t RCC_APB1LRSTR_DAC12RST_MASK       = 0x20000000U;   /** @brief DAC1 and 2 blocks reset */
    static const uint32_t RCC_APB1HRSTR_FDCANRST_MASK       = 0x00000100U;   /** @brief FDCAN block reset */
    static const uint32_t RCC_GCR_WW1RSC_MASK               = 0x00000001U;   /** @brief WWDG1 reset scope control */
    static const uint32_t RCC_D3AMR_SRAM4AMEN_MASK          = 0x20000000U;   /** @brief SRAM4 autonomous mode enable */
    static const uint32_t RCC_RSR_LPWRRSTF_MASK             = 0x40000000U;   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const uint32_t RCC_C1_RSR_LPWRRSTF_MASK          = 0x40000000U;   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag */
    static const uint32_t RCC_C1_APBxENR_WWDG1EN_MASK       = 0x00000040U;   /** @brief WWDG1 clock enable */
    static const uint32_t RCC_APBxENR_WWDG1EN_MASK          = 0x00000040U;   /** @brief WWDG1 clock enable */
    static const uint32_t RCC_APB1LENR_DAC12EN_MASK         = 0x20000000U;   /** @brief DAC1&2 peripheral clock enable */
    static const uint32_t RCC_C1_APB1LENR_DAC12EN_MASK      = 0x20000000U;   /** @brief DAC1&2 peripheral clock enable */
    static const uint32_t RCC_APB1HENR_FDCANEN_MASK         = 0x00000100U;   /** @brief FDCAN peripheral clocks enable */
    static const uint32_t RCC_C1_APB1HENR_FDCANEN_MASK      = 0x00000100U;   /** @brief FDCAN peripheral clocks enable */
    static const uint32_t RCC_C1_AHBxLPENR_AXISRAMLPEN_MASK = 0x80000000U;   /** @brief AXISRAM block clock enable during csleep mode */
    static const uint32_t RCC_AHBxLPENR_AXISRAMLPEN_MASK    = 0x80000000U;   /** @brief AXISRAM block clock enable during csleep mode */
    static const uint32_t RCC_C1_APBxLPENR_WWDG1LPEN_MASK   = 0x00000040U;   /** @brief WWDG1 clock enable during csleep mode */
    static const uint32_t RCC_APBxLPENR_WWDG1LPEN_MASK      = 0x00000040U;   /** @brief WWDG1 clock enable during csleep mode */
    static const uint32_t RCC_APB1LLPENR_DAC12LPEN_MASK     = 0x20000000U;   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1LLPENR_DAC12LPEN_MASK  = 0x20000000U;   /** @brief DAC1/2 peripheral clock enable during csleep mode */
    static const uint32_t RCC_C1_APB1HLPENR_FDCANLPEN_MASK  = 0x00000100U;   /** @brief FDCAN peripheral clocks enable during csleep mode */
    static const uint32_t RCC_APB1HLPENR_FDCANLPEN_MASK     = 0x00000100U;   /** @brief FDCAN peripheral clocks enable during csleep mode */

    static const uint32_t RCC_CR_PLLxRDY_MASK[4] = {
      [2] = 0x08000000U,   /** @brief PLL2 clock ready flag */
      [3] = 0x20000000U,   /** @brief PLL3 clock ready flag */
      [1] = 0x02000000U   /** @brief PLL1 clock ready flag */
    };

    static const uint32_t RCC_CFGR_MCOxSEL_MASK[3] = {
      [2] = 0xE0000000U,   /** @brief Micro-controller clock output 2 */
      [1] = 0x01C00000U   /** @brief Micro-controller clock output 1 */
    };

    static const uint32_t RCC_PLLCKSELR_DIVMx_MASK[4] = {
      [2] = 0x0003F000U,   /** @brief Prescaler for PLL2 */
      [3] = 0x03F00000U,   /** @brief Prescaler for PLL3 */
      [1] = 0x000003F0U   /** @brief Prescaler for PLL1 */
    };

    static const uint32_t RCC_PLLCFGR_DIVRxEN_MASK[4] = {
      [2] = 0x00200000U,   /** @brief PLL2 DIVR divider output enable */
      [3] = 0x01000000U,   /** @brief PLL3 DIVR divider output enable */
      [1] = 0x00040000U   /** @brief PLL1 DIVR divider output enable */
    };

    static const uint32_t RCC_PLLxDIVR_DIVRx_MASK[4] = {
      [2] = 0x7F000000U,   /** @brief PLL1 DIVR division factor */
      [3] = 0x7F000000U,   /** @brief PLL DIVR division factor */
      [1] = 0x7F000000U   /** @brief PLL1 DIVR division factor */
    };

    static const uint32_t RCC_PLLxFRACR_FRACNx_MASK[4] = {
      [2] = 0x0000FFF8U,   /** @brief Fractional part of the multiplication factor for PLL VCO */
      [3] = 0x0000FFF8U,   /** @brief Fractional part of the multiplication factor for PLL3 VCO */
      [1] = 0x0000FFF8U   /** @brief Fractional part of the multiplication factor for PLL1 VCO */
    };

    static const uint32_t RCC_C1_AHBxENR_SDMMCxEN_MASK[4] = {
      [2] = 0x00000200U,   /** @brief SDMMC2 and SDMMC2 delay clock enable */
      [3] = 0x00010000U   /** @brief SDMMC1 and SDMMC1 delay clock enable */
    };

    static const uint32_t RCC_AHBxENR_SDMMCxEN_MASK[4] = {
      [2] = 0x00000200U,   /** @brief SDMMC2 and SDMMC2 delay clock enable */
      [3] = 0x00010000U   /** @brief SDMMC1 and SDMMC1 delay clock enable */
    };

    /**********************************************************************************************
     * @section LPTIM Register Definitions
     **********************************************************************************************/

    /**** @subsection LPTIM Register Pointer Definitions ****/

    static RO_ uint32_t* const LPTIMx_ISR_PTR[6] = {
      [2] = (RO_ uint32_t*)0x58002400U,   /** @brief Interrupt and status register */
      [3] = (RO_ uint32_t*)0x58002800U,   /** @brief Interrupt and status register */
      [4] = (RO_ uint32_t*)0x58002C00U,   /** @brief Interrupt and status register */
      [5] = (RO_ uint32_t*)0x58003000U,   /** @brief Interrupt and status register */
      [1] = (RO_ uint32_t*)0x40002400U   /** @brief Interrupt and status register */
    };

    static RW_ uint32_t* const LPTIMx_ICR_PTR[6] = {
      [2] = (RW_ uint32_t*)0x58002404U,   /** @brief Interrupt clear register */
      [3] = (RW_ uint32_t*)0x58002804U,   /** @brief Interrupt clear register */
      [4] = (RW_ uint32_t*)0x58002C04U,   /** @brief Interrupt clear register */
      [5] = (RW_ uint32_t*)0x58003004U,   /** @brief Interrupt clear register */
      [1] = (RW_ uint32_t*)0x40002404U   /** @brief Interrupt clear register */
    };

    static RW_ uint32_t* const LPTIMx_IER_PTR[6] = {
      [2] = (RW_ uint32_t*)0x58002408U,   /** @brief Interrupt enable register */
      [3] = (RW_ uint32_t*)0x58002808U,   /** @brief Interrupt enable register */
      [4] = (RW_ uint32_t*)0x58002C08U,   /** @brief Interrupt enable register */
      [5] = (RW_ uint32_t*)0x58003008U,   /** @brief Interrupt enable register */
      [1] = (RW_ uint32_t*)0x40002408U   /** @brief Interrupt enable register */
    };

    static RW_ uint32_t* const LPTIMx_CFGR_PTR[6] = {
      [2] = (RW_ uint32_t*)0x5800240CU,   /** @brief Configuration register */
      [3] = (RW_ uint32_t*)0x5800280CU,   /** @brief Configuration register */
      [4] = (RW_ uint32_t*)0x58002C0CU,   /** @brief Configuration register */
      [5] = (RW_ uint32_t*)0x5800300CU,   /** @brief Configuration register */
      [1] = (RW_ uint32_t*)0x4000240CU   /** @brief Configuration register */
    };

    static RW_ uint32_t* const LPTIMx_CR_PTR[6] = {
      [2] = (RW_ uint32_t*)0x58002410U,   /** @brief Control register */
      [3] = (RW_ uint32_t*)0x58002810U,   /** @brief Control register */
      [4] = (RW_ uint32_t*)0x58002C10U,   /** @brief Control register */
      [5] = (RW_ uint32_t*)0x58003010U,   /** @brief Control register */
      [1] = (RW_ uint32_t*)0x40002410U   /** @brief Control register */
    };

    static RW_ uint32_t* const LPTIMx_CMP_PTR[6] = {
      [2] = (RW_ uint32_t*)0x58002414U,   /** @brief Compare register */
      [3] = (RW_ uint32_t*)0x58002814U,   /** @brief Compare register */
      [4] = (RW_ uint32_t*)0x58002C14U,   /** @brief Compare register */
      [5] = (RW_ uint32_t*)0x58003014U,   /** @brief Compare register */
      [1] = (RW_ uint32_t*)0x40002414U   /** @brief Compare register */
    };

    static RW_ uint32_t* const LPTIMx_ARR_PTR[6] = {
      [2] = (RW_ uint32_t*)0x58002418U,   /** @brief Autoreload register */
      [3] = (RW_ uint32_t*)0x58002818U,   /** @brief Autoreload register */
      [4] = (RW_ uint32_t*)0x58002C18U,   /** @brief Autoreload register */
      [5] = (RW_ uint32_t*)0x58003018U,   /** @brief Autoreload register */
      [1] = (RW_ uint32_t*)0x40002418U   /** @brief Autoreload register */
    };

    static RO_ uint32_t* const LPTIMx_CNT_PTR[6] = {
      [2] = (RO_ uint32_t*)0x5800241CU,   /** @brief Counter register */
      [3] = (RO_ uint32_t*)0x5800281CU,   /** @brief Counter register */
      [4] = (RO_ uint32_t*)0x58002C1CU,   /** @brief Counter register */
      [5] = (RO_ uint32_t*)0x5800301CU,   /** @brief Counter register */
      [1] = (RO_ uint32_t*)0x4000241CU   /** @brief Counter register */
    };

    static RW_ uint32_t* const LPTIMx_CFGR2_PTR[6] = {
      [2] = (RW_ uint32_t*)0x58002424U,   /** @brief LPTIM configuration register 2 */
      [3] = (RW_ uint32_t*)0x58002824U,   /** @brief LPTIM configuration register 2 */
      [4] = (RW_ uint32_t*)0x58002C24U,   /** @brief LPTIM configuration register 2 */
      [5] = (RW_ uint32_t*)0x58003024U,   /** @brief LPTIM configuration register 2 */
      [1] = (RW_ uint32_t*)0x40002424U   /** @brief LPTIM configuration register 2 */
    };

    /**** @subsection LPTIM Register Reset Value Definitions ****/

    static const uint32_t LPTIMx_ISR_RST[6] = {
      [2] = 0x00000000U,   /** @brief Interrupt and status register */
      [3] = 0x00000000U,   /** @brief Interrupt and status register */
      [4] = 0x00000000U,   /** @brief Interrupt and status register */
      [5] = 0x00000000U,   /** @brief Interrupt and status register */
      [1] = 0x00000000U   /** @brief Interrupt and status register */
    };

    static const uint32_t LPTIMx_ICR_RST[6] = {
      [2] = 0x00000000U,   /** @brief Interrupt clear register */
      [3] = 0x00000000U,   /** @brief Interrupt clear register */
      [4] = 0x00000000U,   /** @brief Interrupt clear register */
      [5] = 0x00000000U,   /** @brief Interrupt clear register */
      [1] = 0x00000000U   /** @brief Interrupt clear register */
    };

    static const uint32_t LPTIMx_IER_RST[6] = {
      [2] = 0x00000000U,   /** @brief Interrupt enable register */
      [3] = 0x00000000U,   /** @brief Interrupt enable register */
      [4] = 0x00000000U,   /** @brief Interrupt enable register */
      [5] = 0x00000000U,   /** @brief Interrupt enable register */
      [1] = 0x00000000U   /** @brief Interrupt enable register */
    };

    static const uint32_t LPTIMx_CFGR_RST[6] = {
      [2] = 0x00000000U,   /** @brief Configuration register */
      [3] = 0x00000000U,   /** @brief Configuration register */
      [4] = 0x00000000U,   /** @brief Configuration register */
      [5] = 0x00000000U,   /** @brief Configuration register */
      [1] = 0x00000000U   /** @brief Configuration register */
    };

    static const uint32_t LPTIMx_CR_RST[6] = {
      [2] = 0x00000000U,   /** @brief Control register */
      [3] = 0x00000000U,   /** @brief Control register */
      [4] = 0x00000000U,   /** @brief Control register */
      [5] = 0x00000000U,   /** @brief Control register */
      [1] = 0x00000000U   /** @brief Control register */
    };

    static const uint32_t LPTIMx_CMP_RST[6] = {
      [2] = 0x00000000U,   /** @brief Compare register */
      [3] = 0x00000000U,   /** @brief Compare register */
      [4] = 0x00000000U,   /** @brief Compare register */
      [5] = 0x00000000U,   /** @brief Compare register */
      [1] = 0x00000000U   /** @brief Compare register */
    };

    static const uint32_t LPTIMx_ARR_RST[6] = {
      [2] = 0x00000001U,   /** @brief Autoreload register */
      [3] = 0x00000001U,   /** @brief Autoreload register */
      [4] = 0x00000001U,   /** @brief Autoreload register */
      [5] = 0x00000001U,   /** @brief Autoreload register */
      [1] = 0x00000001U   /** @brief Autoreload register */
    };

    static const uint32_t LPTIMx_CNT_RST[6] = {
      [2] = 0x00000000U,   /** @brief Counter register */
      [3] = 0x00000000U,   /** @brief Counter register */
      [4] = 0x00000000U,   /** @brief Counter register */
      [5] = 0x00000000U,   /** @brief Counter register */
      [1] = 0x00000000U   /** @brief Counter register */
    };

    static const uint32_t LPTIMx_CFGR2_RST[6] = {
      [2] = 0x00000000U,   /** @brief LPTIM configuration register 2 */
      [3] = 0x00000000U,   /** @brief LPTIM configuration register 2 */
      [4] = 0x00000000U,   /** @brief LPTIM configuration register 2 */
      [5] = 0x00000000U,   /** @brief LPTIM configuration register 2 */
      [1] = 0x00000000U   /** @brief LPTIM configuration register 2 */
    };

    /**** @subsection LPTIM Register Value Type Definitions ****/

    typedef uint32_t LPTIMx_ISR_vt;     /** @brief LPTIMx_ISR register value type. */
    typedef uint32_t LPTIMx_ICR_vt;     /** @brief LPTIMx_ICR register value type. */
    typedef uint32_t LPTIMx_IER_vt;     /** @brief LPTIMx_IER register value type. */
    typedef uint32_t LPTIMx_CFGR_vt;    /** @brief LPTIMx_CFGR register value type. */
    typedef uint32_t LPTIMx_CR_vt;      /** @brief LPTIMx_CR register value type. */
    typedef uint32_t LPTIMx_CMP_vt;     /** @brief LPTIMx_CMP register value type. */
    typedef uint32_t LPTIMx_ARR_vt;     /** @brief LPTIMx_ARR register value type. */
    typedef uint32_t LPTIMx_CNT_vt;     /** @brief LPTIMx_CNT register value type. */
    typedef uint32_t LPTIMx_CFGR2_vt;   /** @brief LPTIMx_CFGR2 register value type. */

    /**** @subsection LPTIM Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* LPTIMx_ISR_pt;     /** @brief LPTIMx_ISR pointer register pointer type. */
    typedef RW_ uint32_t* LPTIMx_ICR_pt;     /** @brief LPTIMx_ICR pointer register pointer type. */
    typedef RW_ uint32_t* LPTIMx_IER_pt;     /** @brief LPTIMx_IER pointer register pointer type. */
    typedef RW_ uint32_t* LPTIMx_CFGR_pt;    /** @brief LPTIMx_CFGR pointer register pointer type. */
    typedef RW_ uint32_t* LPTIMx_CR_pt;      /** @brief LPTIMx_CR pointer register pointer type. */
    typedef RW_ uint32_t* LPTIMx_CMP_pt;     /** @brief LPTIMx_CMP pointer register pointer type. */
    typedef RW_ uint32_t* LPTIMx_ARR_pt;     /** @brief LPTIMx_ARR pointer register pointer type. */
    typedef RO_ uint32_t* LPTIMx_CNT_pt;     /** @brief LPTIMx_CNT pointer register pointer type. */
    typedef RW_ uint32_t* LPTIMx_CFGR2_pt;   /** @brief LPTIMx_CFGR2 pointer register pointer type. */

    /**** @subsection LPTIM Field Mask Definitions ****/

    static const uint32_t LPTIMx_ISR_CMPM_MASK[6] = {
      [2] = 0x00000001U,   /** @brief Compare match */
      [3] = 0x00000001U,   /** @brief Compare match */
      [4] = 0x00000001U,   /** @brief Compare match */
      [5] = 0x00000001U,   /** @brief Compare match */
      [1] = 0x00000001U   /** @brief Compare match */
    };

    static const uint32_t LPTIMx_ICR_CMPMCF_MASK[6] = {
      [2] = 0x00000001U,   /** @brief Compare match clear flag */
      [3] = 0x00000001U,   /** @brief Compare match clear flag */
      [4] = 0x00000001U,   /** @brief Compare match clear flag */
      [5] = 0x00000001U,   /** @brief Compare match clear flag */
      [1] = 0x00000001U   /** @brief Compare match clear flag */
    };

    static const uint32_t LPTIMx_IER_CMPMIE_MASK[6] = {
      [2] = 0x00000001U,   /** @brief Compare match interrupt enable */
      [3] = 0x00000001U,   /** @brief Compare match interrupt enable */
      [4] = 0x00000001U,   /** @brief Compare match interrupt enable */
      [5] = 0x00000001U,   /** @brief Compare match interrupt enable */
      [1] = 0x00000001U   /** @brief Compare match interrupt enable */
    };

    static const uint32_t LPTIMx_CFGR_CKSEL_MASK[6] = {
      [2] = 0x00000001U,   /** @brief Clock selector */
      [3] = 0x00000001U,   /** @brief Clock selector */
      [4] = 0x00000001U,   /** @brief Clock selector */
      [5] = 0x00000001U,   /** @brief Clock selector */
      [1] = 0x00000001U   /** @brief Clock selector */
    };

    static const uint32_t LPTIMx_CR_RSTARE_MASK[6] = {
      [2] = 0x00000010U,   /** @brief Reset after read enable */
      [3] = 0x00000010U,   /** @brief Reset after read enable */
      [4] = 0x00000010U,   /** @brief Reset after read enable */
      [5] = 0x00000010U,   /** @brief Reset after read enable */
      [1] = 0x00000010U   /** @brief Reset after read enable */
    };

    static const uint32_t LPTIMx_CMP_CMP_MASK[6] = {
      [2] = 0x0000FFFFU,   /** @brief Compare value */
      [3] = 0x0000FFFFU,   /** @brief Compare value */
      [4] = 0x0000FFFFU,   /** @brief Compare value */
      [5] = 0x0000FFFFU,   /** @brief Compare value */
      [1] = 0x0000FFFFU   /** @brief Compare value */
    };

    static const uint32_t LPTIMx_ARR_ARR_MASK[6] = {
      [2] = 0x0000FFFFU,   /** @brief Auto reload value */
      [3] = 0x0000FFFFU,   /** @brief Auto reload value */
      [4] = 0x0000FFFFU,   /** @brief Auto reload value */
      [5] = 0x0000FFFFU,   /** @brief Auto reload value */
      [1] = 0x0000FFFFU   /** @brief Auto reload value */
    };

    static const uint32_t LPTIMx_CNT_CNT_MASK[6] = {
      [2] = 0x0000FFFFU,   /** @brief Counter value */
      [3] = 0x0000FFFFU,   /** @brief Counter value */
      [4] = 0x0000FFFFU,   /** @brief Counter value */
      [5] = 0x0000FFFFU,   /** @brief Counter value */
      [1] = 0x0000FFFFU   /** @brief Counter value */
    };

    static const uint32_t LPTIMx_CFGR2_INxSEL_MASK[6] = {
      [3] = 0x00000003U,   /** @brief LPTIM input 1 selection */
      [4] = 0x00000003U,   /** @brief LPTIM input 1 selection */
      [5] = 0x00000003U   /** @brief LPTIM input 1 selection */
    };

    static const uint32_t LPTIMx_CFGR2_INxSEL_MASK[6][3] = {
      [2] = {
        [2] = 0x00000030U,   /** @brief LPTIM input 2 selection */
        [1] = 0x00000003U   /** @brief LPTIM input 1 selection */
      },
      [1] = {
        [2] = 0x00000030U,   /** @brief LPTIM input 2 selection */
        [1] = 0x00000003U   /** @brief LPTIM input 1 selection */
      }
    };

    /**********************************************************************************************
     * @section LPUART1 Register Definitions
     **********************************************************************************************/

    /**** @subsection LPUART1 Register Pointer Definitions ****/

    static RW_ uint32_t* const LPUART1_BRR_PTR   = (RW_ uint32_t*)0x58000C0CU;   /** @brief Baud rate register */
    static RW_ uint32_t* const LPUART1_GTPR_PTR  = (RW_ uint32_t*)0x58000C10U;   /** @brief Guard time and prescaler register */
    static RW_ uint32_t* const LPUART1_RTOR_PTR  = (RW_ uint32_t*)0x58000C14U;   /** @brief Receiver timeout register */
    static RW_ uint32_t* const LPUART1_RQR_PTR   = (RW_ uint32_t*)0x58000C18U;   /** @brief Request register */
    static RO_ uint32_t* const LPUART1_ISR_PTR   = (RO_ uint32_t*)0x58000C1CU;   /** @brief Interrupt & status register */
    static RW_ uint32_t* const LPUART1_ICR_PTR   = (RW_ uint32_t*)0x58000C20U;   /** @brief Interrupt flag clear register */
    static RO_ uint32_t* const LPUART1_RDR_PTR   = (RO_ uint32_t*)0x58000C24U;   /** @brief Receive data register */
    static RW_ uint32_t* const LPUART1_TDR_PTR   = (RW_ uint32_t*)0x58000C28U;   /** @brief Transmit data register */
    static RW_ uint32_t* const LPUART1_PRESC_PTR = (RW_ uint32_t*)0x58000C2CU;   /** @brief Prescaler register */

    static RW_ uint32_t* const LPUART1_CRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58000C04U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t*)0x58000C08U,   /** @brief Control register 3 */
      [1] = (RW_ uint32_t*)0x58000C00U   /** @brief Control register 1 */
    };

    /**** @subsection LPUART1 Register Reset Value Definitions ****/

    static const uint32_t LPUART1_BRR_RST   = 0x00000000U;   /** @brief Baud rate register */
    static const uint32_t LPUART1_GTPR_RST  = 0x00000000U;   /** @brief Guard time and prescaler register */
    static const uint32_t LPUART1_RTOR_RST  = 0x00000000U;   /** @brief Receiver timeout register */
    static const uint32_t LPUART1_RQR_RST   = 0x00000000U;   /** @brief Request register */
    static const uint32_t LPUART1_ISR_RST   = 0x000000C0U;   /** @brief Interrupt & status register */
    static const uint32_t LPUART1_ICR_RST   = 0x00000000U;   /** @brief Interrupt flag clear register */
    static const uint32_t LPUART1_RDR_RST   = 0x00000000U;   /** @brief Receive data register */
    static const uint32_t LPUART1_TDR_RST   = 0x00000000U;   /** @brief Transmit data register */
    static const uint32_t LPUART1_PRESC_RST = 0x00000000U;   /** @brief Prescaler register */

    static const uint32_t LPUART1_CRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief Control register 2 */
      [3] = 0x00000000U,   /** @brief Control register 3 */
      [1] = 0x00000000U   /** @brief Control register 1 */
    };

    /**** @subsection LPUART1 Register Value Type Definitions ****/

    typedef uint32_t LPUART1_CRx_vt;     /** @brief LPUART1_CRx register value type. */
    typedef uint32_t LPUART1_BRR_vt;     /** @brief LPUART1_BRR register value type. */
    typedef uint32_t LPUART1_GTPR_vt;    /** @brief LPUART1_GTPR register value type. */
    typedef uint32_t LPUART1_RTOR_vt;    /** @brief LPUART1_RTOR register value type. */
    typedef uint32_t LPUART1_RQR_vt;     /** @brief LPUART1_RQR register value type. */
    typedef uint32_t LPUART1_ISR_vt;     /** @brief LPUART1_ISR register value type. */
    typedef uint32_t LPUART1_ICR_vt;     /** @brief LPUART1_ICR register value type. */
    typedef uint32_t LPUART1_RDR_vt;     /** @brief LPUART1_RDR register value type. */
    typedef uint32_t LPUART1_TDR_vt;     /** @brief LPUART1_TDR register value type. */
    typedef uint32_t LPUART1_PRESC_vt;   /** @brief LPUART1_PRESC register value type. */

    /**** @subsection LPUART1 Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* LPUART1_CRx_pt;     /** @brief LPUART1_CRx pointer register pointer type. */
    typedef RW_ uint32_t* LPUART1_BRR_pt;     /** @brief LPUART1_BRR pointer register pointer type. */
    typedef RW_ uint32_t* LPUART1_GTPR_pt;    /** @brief LPUART1_GTPR pointer register pointer type. */
    typedef RW_ uint32_t* LPUART1_RTOR_pt;    /** @brief LPUART1_RTOR pointer register pointer type. */
    typedef RW_ uint32_t* LPUART1_RQR_pt;     /** @brief LPUART1_RQR pointer register pointer type. */
    typedef RO_ uint32_t* LPUART1_ISR_pt;     /** @brief LPUART1_ISR pointer register pointer type. */
    typedef RW_ uint32_t* LPUART1_ICR_pt;     /** @brief LPUART1_ICR pointer register pointer type. */
    typedef RO_ uint32_t* LPUART1_RDR_pt;     /** @brief LPUART1_RDR pointer register pointer type. */
    typedef RW_ uint32_t* LPUART1_TDR_pt;     /** @brief LPUART1_TDR pointer register pointer type. */
    typedef RW_ uint32_t* LPUART1_PRESC_pt;   /** @brief LPUART1_PRESC pointer register pointer type. */

    /**** @subsection LPUART1 Field Mask Definitions ****/

    static const uint32_t LPUART1_CRx_UE_MASK          = 0x00000001U;   /** @brief USART enable */
    static const uint32_t LPUART1_BRR_BRR_MASK         = 0x000FFFFFU;   /** @brief BRR */
    static const uint32_t LPUART1_GTPR_PSC_MASK        = 0x000000FFU;   /** @brief Prescaler value */
    static const uint32_t LPUART1_RTOR_RTO_MASK        = 0x00FFFFFFU;   /** @brief Receiver timeout value */
    static const uint32_t LPUART1_RQR_ABRRQ_MASK       = 0x00000001U;   /** @brief Auto baud rate request */
    static const uint32_t LPUART1_ISR_PE_MASK          = 0x00000001U;   /** @brief PE */
    static const uint32_t LPUART1_ICR_PECF_MASK        = 0x00000001U;   /** @brief Parity error clear flag */
    static const uint32_t LPUART1_RDR_RDR_MASK         = 0x000001FFU;   /** @brief Receive data value */
    static const uint32_t LPUART1_TDR_TDR_MASK         = 0x000001FFU;   /** @brief Transmit data value */
    static const uint32_t LPUART1_PRESC_PRESCALER_MASK = 0x0000000FU;   /** @brief Clock prescaler */

    /**********************************************************************************************
     * @section SYSCFG Register Definitions
     **********************************************************************************************/

    /**** @subsection SYSCFG Register Pointer Definitions ****/

    static RW_ uint32_t* const SYSCFG_PMCR_PTR  = (RW_ uint32_t*)0x58000404U;   /** @brief Peripheral mode configuration register */
    static RW_ uint32_t* const SYSCFG_CCCSR_PTR = (RW_ uint32_t*)0x58000420U;   /** @brief Compensation cell control/status register */
    static RO_ uint32_t* const SYSCFG_CCVR_PTR  = (RO_ uint32_t*)0x58000424U;   /** @brief SYSCFG compensation cell value register */
    static RW_ uint32_t* const SYSCFG_CCCR_PTR  = (RW_ uint32_t*)0x58000428U;   /** @brief SYSCFG compensation cell code register */
    static RO_ uint32_t* const SYSCFG_PKGR_PTR  = (RO_ uint32_t*)0x58000524U;   /** @brief SYSCFG package register */

    static RW_ uint32_t* const SYSCFG_EXTICRx_PTR[5] = {
      [2] = (RW_ uint32_t*)0x5800040CU,   /** @brief External interrupt configuration register 2 */
      [3] = (RW_ uint32_t*)0x58000410U,   /** @brief External interrupt configuration register 3 */
      [4] = (RW_ uint32_t*)0x58000414U,   /** @brief External interrupt configuration register 4 */
      [1] = (RW_ uint32_t*)0x58000408U   /** @brief External interrupt configuration register 1 */
    };

    static RW_ uint32_t* const SYSCFG_URx_PTR[18] = {
      [2]  = (RW_ uint32_t*)0x58000708U,   /** @brief SYSCFG user register 2 */
      [3]  = (RW_ uint32_t*)0x5800070CU,   /** @brief SYSCFG user register 3 */
      [4]  = (RW_ uint32_t*)0x58000710U,   /** @brief SYSCFG user register 4 */
      [5]  = (RW_ uint32_t*)0x58000714U,   /** @brief SYSCFG user register 5 */
      [6]  = (RW_ uint32_t*)0x58000718U,   /** @brief SYSCFG user register 6 */
      [7]  = (RW_ uint32_t*)0x5800071CU,   /** @brief SYSCFG user register 7 */
      [8]  = (RW_ uint32_t*)0x58000720U,   /** @brief SYSCFG user register 8 */
      [9]  = (RW_ uint32_t*)0x58000724U,   /** @brief SYSCFG user register 9 */
      [10] = (RW_ uint32_t*)0x58000728U,   /** @brief SYSCFG user register 10 */
      [11] = (RW_ uint32_t*)0x5800072CU,   /** @brief SYSCFG user register 11 */
      [12] = (RW_ uint32_t*)0x58000730U,   /** @brief SYSCFG user register 12 */
      [13] = (RW_ uint32_t*)0x58000734U,   /** @brief SYSCFG user register 13 */
      [14] = (RW_ uint32_t*)0x58000738U,   /** @brief SYSCFG user register 14 */
      [15] = (RW_ uint32_t*)0x5800073CU,   /** @brief SYSCFG user register 15 */
      [16] = (RW_ uint32_t*)0x58000740U,   /** @brief SYSCFG user register 16 */
      [17] = (RW_ uint32_t*)0x58000744U,   /** @brief SYSCFG user register 17 */
      [0]  = (RW_ uint32_t*)0x58000700U   /** @brief SYSCFG user register 0 */
    };

    /**** @subsection SYSCFG Register Reset Value Definitions ****/

    static const uint32_t SYSCFG_PMCR_RST  = 0x00000000U;   /** @brief Peripheral mode configuration register */
    static const uint32_t SYSCFG_CCCSR_RST = 0x00000000U;   /** @brief Compensation cell control/status register */
    static const uint32_t SYSCFG_CCVR_RST  = 0x00000000U;   /** @brief SYSCFG compensation cell value register */
    static const uint32_t SYSCFG_CCCR_RST  = 0x00000000U;   /** @brief SYSCFG compensation cell code register */
    static const uint32_t SYSCFG_PKGR_RST  = 0x00000000U;   /** @brief SYSCFG package register */

    static const uint32_t SYSCFG_EXTICRx_RST[5] = {
      [2] = 0x00000000U,   /** @brief External interrupt configuration register 2 */
      [3] = 0x00000000U,   /** @brief External interrupt configuration register 3 */
      [4] = 0x00000000U,   /** @brief External interrupt configuration register 4 */
      [1] = 0x00000000U   /** @brief External interrupt configuration register 1 */
    };

    static const uint32_t SYSCFG_URx_RST[18] = {
      [2]  = 0x00000000U,   /** @brief SYSCFG user register 2 */
      [3]  = 0x00000000U,   /** @brief SYSCFG user register 3 */
      [4]  = 0x00000000U,   /** @brief SYSCFG user register 4 */
      [5]  = 0x00000000U,   /** @brief SYSCFG user register 5 */
      [6]  = 0x00000000U,   /** @brief SYSCFG user register 6 */
      [7]  = 0x00000000U,   /** @brief SYSCFG user register 7 */
      [8]  = 0x00000000U,   /** @brief SYSCFG user register 8 */
      [9]  = 0x00000000U,   /** @brief SYSCFG user register 9 */
      [10] = 0x00000000U,   /** @brief SYSCFG user register 10 */
      [11] = 0x00000000U,   /** @brief SYSCFG user register 11 */
      [12] = 0x00000000U,   /** @brief SYSCFG user register 12 */
      [13] = 0x00000000U,   /** @brief SYSCFG user register 13 */
      [14] = 0x00000000U,   /** @brief SYSCFG user register 14 */
      [15] = 0x00000000U,   /** @brief SYSCFG user register 15 */
      [16] = 0x00000000U,   /** @brief SYSCFG user register 16 */
      [17] = 0x00000000U,   /** @brief SYSCFG user register 17 */
      [0]  = 0x00000000U   /** @brief SYSCFG user register 0 */
    };

    /**** @subsection SYSCFG Register Value Type Definitions ****/

    typedef uint32_t SYSCFG_PMCR_vt;      /** @brief SYSCFG_PMCR register value type. */
    typedef uint32_t SYSCFG_EXTICRx_vt;   /** @brief SYSCFG_EXTICRx register value type. */
    typedef uint32_t SYSCFG_CCCSR_vt;     /** @brief SYSCFG_CCCSR register value type. */
    typedef uint32_t SYSCFG_CCVR_vt;      /** @brief SYSCFG_CCVR register value type. */
    typedef uint32_t SYSCFG_CCCR_vt;      /** @brief SYSCFG_CCCR register value type. */
    typedef uint32_t SYSCFG_PKGR_vt;      /** @brief SYSCFG_PKGR register value type. */
    typedef uint32_t SYSCFG_URx_vt;       /** @brief SYSCFG_URx register value type. */

    /**** @subsection SYSCFG Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* SYSCFG_PMCR_pt;      /** @brief SYSCFG_PMCR pointer register pointer type. */
    typedef RW_ uint32_t* SYSCFG_EXTICRx_pt;   /** @brief SYSCFG_EXTICRx pointer register pointer type. */
    typedef RW_ uint32_t* SYSCFG_CCCSR_pt;     /** @brief SYSCFG_CCCSR pointer register pointer type. */
    typedef RO_ uint32_t* SYSCFG_CCVR_pt;      /** @brief SYSCFG_CCVR pointer register pointer type. */
    typedef RW_ uint32_t* SYSCFG_CCCR_pt;      /** @brief SYSCFG_CCCR pointer register pointer type. */
    typedef RO_ uint32_t* SYSCFG_PKGR_pt;      /** @brief SYSCFG_PKGR pointer register pointer type. */
    typedef RW_ uint32_t* SYSCFG_URx_pt;       /** @brief SYSCFG_URx pointer register pointer type. */

    /**** @subsection SYSCFG Field Mask Definitions ****/

    static const uint32_t SYSCFG_CCCSR_HSLV_MASK = 0x00010000U;   /** @brief High-speed at low-voltage */
    static const uint32_t SYSCFG_CCVR_PCV_MASK   = 0x000000F0U;   /** @brief PMOS compensation value */
    static const uint32_t SYSCFG_CCCR_PCC_MASK   = 0x000000F0U;   /** @brief PMOS compensation code */
    static const uint32_t SYSCFG_PKGR_PKG_MASK   = 0x0000000FU;   /** @brief Package */
    static const uint32_t SYSCFG_URx_RDP_MASK    = 0x00FF0000U;   /** @brief Readout protection */

    static const uint32_t SYSCFG_PMCR_PCxSO_MASK[4] = {
      [3] = 0x08000000U,   /** @brief PC3 switch open */
      [2] = 0x04000000U   /** @brief PC2 switch open */
    };

    static const uint32_t SYSCFG_EXTICRx_EXTIx_MASK[5][16] = {
      [2] = {
        [7] = 0x0000F000U,   /** @brief EXTI x configuration (x = 4 to 7) */
        [6] = 0x00000F00U,   /** @brief EXTI x configuration (x = 4 to 7) */
        [5] = 0x000000F0U,   /** @brief EXTI x configuration (x = 4 to 7) */
        [4] = 0x0000000FU   /** @brief EXTI x configuration (x = 4 to 7) */
      },
      [3] = {
        [11] = 0x0000F000U,   /** @brief EXTI x configuration (x = 8 to 11) */
        [10] = 0x00000F00U,   /** @brief EXTI10 */
        [9]  = 0x000000F0U,   /** @brief EXTI x configuration (x = 8 to 11) */
        [8]  = 0x0000000FU   /** @brief EXTI x configuration (x = 8 to 11) */
      },
      [4] = {
        [15] = 0x0000F000U,   /** @brief EXTI x configuration (x = 12 to 15) */
        [14] = 0x00000F00U,   /** @brief EXTI x configuration (x = 12 to 15) */
        [13] = 0x000000F0U,   /** @brief EXTI x configuration (x = 12 to 15) */
        [12] = 0x0000000FU   /** @brief EXTI x configuration (x = 12 to 15) */
      },
      [1] = {
        [2] = 0x00000F00U,   /** @brief EXTI x configuration (x = 0 to 3) */
        [1] = 0x000000F0U,   /** @brief EXTI x configuration (x = 0 to 3) */
        [0] = 0x0000000FU,   /** @brief EXTI x configuration (x = 0 to 3) */
        [3] = 0x0000F000U   /** @brief EXTI x configuration (x = 0 to 3) */
      }
    };

    /**********************************************************************************************
     * @section EXTI Register Definitions
     **********************************************************************************************/

    /**** @subsection EXTI Register Pointer Definitions ****/

    static RW_ uint32_t* const EXTI_RTSRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58000020U,   /** @brief EXTI rising trigger selection register */
      [3] = (RW_ uint32_t*)0x58000040U,   /** @brief EXTI rising trigger selection register */
      [1] = (RW_ uint32_t*)0x58000000U   /** @brief EXTI rising trigger selection register */
    };

    static RW_ uint32_t* const EXTI_FTSRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58000024U,   /** @brief EXTI falling trigger selection register */
      [3] = (RW_ uint32_t*)0x58000044U,   /** @brief EXTI falling trigger selection register */
      [1] = (RW_ uint32_t*)0x58000004U   /** @brief EXTI falling trigger selection register */
    };

    static RW_ uint32_t* const EXTI_SWIERx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58000028U,   /** @brief EXTI software interrupt event register */
      [3] = (RW_ uint32_t*)0x58000048U,   /** @brief EXTI software interrupt event register */
      [1] = (RW_ uint32_t*)0x58000008U   /** @brief EXTI software interrupt event register */
    };

    static RW_ uint32_t* const EXTI_D3PMRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x5800002CU,   /** @brief EXTI D3 pending mask register */
      [3] = (RW_ uint32_t*)0x5800004CU,   /** @brief EXTI D3 pending mask register */
      [1] = (RW_ uint32_t*)0x5800000CU   /** @brief EXTI D3 pending mask register */
    };

    static RW_ uint32_t* const EXTI_D3PCRxL_PTR[3] = {
      [2] = (RW_ uint32_t*)0x58000030U,   /** @brief EXTI D3 pending clear selection register low */
      [1] = (RW_ uint32_t*)0x58000010U   /** @brief EXTI D3 pending clear selection register low */
    };

    static RW_ uint32_t* const EXTI_D3PCRxH_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58000034U,   /** @brief EXTI D3 pending clear selection register high */
      [3] = (RW_ uint32_t*)0x58000054U,   /** @brief EXTI D3 pending clear selection register high */
      [1] = (RW_ uint32_t*)0x58000014U   /** @brief EXTI D3 pending clear selection register high */
    };

    static RW_ uint32_t* const EXTI_CPUIMRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58000090U,   /** @brief EXTI interrupt mask register */
      [3] = (RW_ uint32_t*)0x580000A0U,   /** @brief EXTI interrupt mask register */
      [1] = (RW_ uint32_t*)0x58000080U   /** @brief EXTI interrupt mask register */
    };

    static RW_ uint32_t* const EXTI_CPUEMRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x58000094U,   /** @brief EXTI event mask register */
      [3] = (RW_ uint32_t*)0x580000A4U,   /** @brief EXTI event mask register */
      [1] = (RW_ uint32_t*)0x58000084U   /** @brief EXTI event mask register */
    };

    static RO_ uint32_t* const EXTI_CPUPRx_PTR[4] = {
      [2] = (RO_ uint32_t*)0x58000098U,   /** @brief EXTI pending register */
      [3] = (RO_ uint32_t*)0x580000A8U,   /** @brief EXTI pending register */
      [1] = (RO_ uint32_t*)0x58000088U   /** @brief EXTI pending register */
    };

    /**** @subsection EXTI Register Reset Value Definitions ****/

    static const uint32_t EXTI_RTSRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI rising trigger selection register */
      [3] = 0x00000000U,   /** @brief EXTI rising trigger selection register */
      [1] = 0x00000000U   /** @brief EXTI rising trigger selection register */
    };

    static const uint32_t EXTI_FTSRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI falling trigger selection register */
      [3] = 0x00000000U,   /** @brief EXTI falling trigger selection register */
      [1] = 0x00000000U   /** @brief EXTI falling trigger selection register */
    };

    static const uint32_t EXTI_SWIERx_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI software interrupt event register */
      [3] = 0x00000000U,   /** @brief EXTI software interrupt event register */
      [1] = 0x00000000U   /** @brief EXTI software interrupt event register */
    };

    static const uint32_t EXTI_D3PMRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI D3 pending mask register */
      [3] = 0x00000000U,   /** @brief EXTI D3 pending mask register */
      [1] = 0x00000000U   /** @brief EXTI D3 pending mask register */
    };

    static const uint32_t EXTI_D3PCRxL_RST[3] = {
      [2] = 0x00000000U,   /** @brief EXTI D3 pending clear selection register low */
      [1] = 0x00000000U   /** @brief EXTI D3 pending clear selection register low */
    };

    static const uint32_t EXTI_D3PCRxH_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI D3 pending clear selection register high */
      [3] = 0x00000000U,   /** @brief EXTI D3 pending clear selection register high */
      [1] = 0x00000000U   /** @brief EXTI D3 pending clear selection register high */
    };

    static const uint32_t EXTI_CPUIMRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI interrupt mask register */
      [3] = 0x00000000U,   /** @brief EXTI interrupt mask register */
      [1] = 0xFFC00000U   /** @brief EXTI interrupt mask register */
    };

    static const uint32_t EXTI_CPUEMRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI event mask register */
      [3] = 0x00000000U,   /** @brief EXTI event mask register */
      [1] = 0x00000000U   /** @brief EXTI event mask register */
    };

    static const uint32_t EXTI_CPUPRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief EXTI pending register */
      [3] = 0x00000000U,   /** @brief EXTI pending register */
      [1] = 0x00000000U   /** @brief EXTI pending register */
    };

    /**** @subsection EXTI Register Value Type Definitions ****/

    typedef uint32_t EXTI_RTSRx_vt;     /** @brief EXTI_RTSRx register value type. */
    typedef uint32_t EXTI_FTSRx_vt;     /** @brief EXTI_FTSRx register value type. */
    typedef uint32_t EXTI_SWIERx_vt;    /** @brief EXTI_SWIERx register value type. */
    typedef uint32_t EXTI_D3PMRx_vt;    /** @brief EXTI_D3PMRx register value type. */
    typedef uint32_t EXTI_D3PCRxL_vt;   /** @brief EXTI_D3PCRxL register value type. */
    typedef uint32_t EXTI_D3PCRxH_vt;   /** @brief EXTI_D3PCRxH register value type. */
    typedef uint32_t EXTI_CPUIMRx_vt;   /** @brief EXTI_CPUIMRx register value type. */
    typedef uint32_t EXTI_CPUEMRx_vt;   /** @brief EXTI_CPUEMRx register value type. */
    typedef uint32_t EXTI_CPUPRx_vt;    /** @brief EXTI_CPUPRx register value type. */

    /**** @subsection EXTI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* EXTI_RTSRx_pt;     /** @brief EXTI_RTSRx pointer register pointer type. */
    typedef RW_ uint32_t* EXTI_FTSRx_pt;     /** @brief EXTI_FTSRx pointer register pointer type. */
    typedef RW_ uint32_t* EXTI_SWIERx_pt;    /** @brief EXTI_SWIERx pointer register pointer type. */
    typedef RW_ uint32_t* EXTI_D3PMRx_pt;    /** @brief EXTI_D3PMRx pointer register pointer type. */
    typedef RW_ uint32_t* EXTI_D3PCRxL_pt;   /** @brief EXTI_D3PCRxL pointer register pointer type. */
    typedef RW_ uint32_t* EXTI_D3PCRxH_pt;   /** @brief EXTI_D3PCRxH pointer register pointer type. */
    typedef RW_ uint32_t* EXTI_CPUIMRx_pt;   /** @brief EXTI_CPUIMRx pointer register pointer type. */
    typedef RW_ uint32_t* EXTI_CPUEMRx_pt;   /** @brief EXTI_CPUEMRx pointer register pointer type. */
    typedef RO_ uint32_t* EXTI_CPUPRx_pt;    /** @brief EXTI_CPUPRx pointer register pointer type. */

    /**** @subsection EXTI Field Mask Definitions ****/

    static const uint32_t EXTI_D3PMRx_MRx_MASK[4] = {
      [3] = 0x01000000U   /** @brief D3 pending mask on event input x+64 */
    };

    static const uint32_t EXTI_D3PCRxH_PCSx_MASK[4] = {
      [3] = 0x000C0000U   /** @brief D3 pending request clear input signal selection on event input x= truncate N+160/2 */
    };

    static const uint32_t EXTI_RTSRx_TRx_MASK[4][87] = {
      [2] = {
        [49] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input x+32 */
        [51] = 0x00080000U   /** @brief Rising trigger event configuration bit of configurable event input x+32 */
      },
      [3] = {
        [82] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
        [84] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
        [85] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
        [86] = 0x00400000U   /** @brief Rising trigger event configuration bit of configurable event input x+64 */
      },
      [1] = {
        [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [0]  = 0x00000001U   /** @brief Rising trigger event configuration bit of configurable event input */
      }
    };

    static const uint32_t EXTI_FTSRx_TRx_MASK[4][87] = {
      [2] = {
        [49] = 0x00020000U,   /** @brief Falling trigger event configuration bit of configurable event input x+32 */
        [51] = 0x00080000U   /** @brief Falling trigger event configuration bit of configurable event input x+32 */
      },
      [3] = {
        [82] = 0x00040000U,   /** @brief Falling trigger event configuration bit of configurable event input x+64 */
        [84] = 0x00100000U,   /** @brief Falling trigger event configuration bit of configurable event input x+64 */
        [85] = 0x00200000U,   /** @brief Falling trigger event configuration bit of configurable event input x+64 */
        [86] = 0x00400000U   /** @brief Falling trigger event configuration bit of configurable event input x+64 */
      },
      [1] = {
        [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [0]  = 0x00000001U   /** @brief Rising trigger event configuration bit of configurable event input */
      }
    };

    static const uint32_t EXTI_SWIERx_SWIERx_MASK[4][87] = {
      [2] = {
        [49] = 0x00020000U,   /** @brief Software interrupt on line x+32 */
        [51] = 0x00080000U   /** @brief Software interrupt on line x+32 */
      },
      [3] = {
        [82] = 0x00040000U,   /** @brief Software interrupt on line x+64 */
        [84] = 0x00100000U,   /** @brief Software interrupt on line x+64 */
        [85] = 0x00200000U,   /** @brief Software interrupt on line x+64 */
        [86] = 0x00400000U   /** @brief Software interrupt on line x+64 */
      },
      [1] = {
        [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [0]  = 0x00000001U   /** @brief Rising trigger event configuration bit of configurable event input */
      }
    };

    static const uint32_t EXTI_D3PMRx_MRx_MASK[4][54] = {
      [2] = {
        [34] = 0x00000004U,   /** @brief D3 pending mask on event input x+32 */
        [35] = 0x00000008U,   /** @brief D3 pending mask on event input x+32 */
        [41] = 0x00000200U,   /** @brief D3 pending mask on event input x+32 */
        [48] = 0x00010000U,   /** @brief D3 pending mask on event input x+32 */
        [49] = 0x00020000U,   /** @brief D3 pending mask on event input x+32 */
        [50] = 0x00040000U,   /** @brief D3 pending mask on event input x+32 */
        [51] = 0x00080000U,   /** @brief D3 pending mask on event input x+32 */
        [52] = 0x00100000U,   /** @brief D3 pending mask on event input x+32 */
        [53] = 0x00200000U   /** @brief D3 pending mask on event input x+32 */
      },
      [1] = {
        [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [25] = 0x02000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [0]  = 0x00000001U   /** @brief Rising trigger event configuration bit of configurable event input */
      }
    };

    static const uint32_t EXTI_D3PCRxL_PCSx_MASK[3][42] = {
      [2] = {
        [35] = 0x000000C0U,   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+64)/2) */
        [34] = 0x00000030U,   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+64)/2) */
        [41] = 0x000C0000U   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+64)/2) */
      },
      [1] = {
        [1]  = 0x0000000CU,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [2]  = 0x00000030U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [3]  = 0x000000C0U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [4]  = 0x00000300U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [5]  = 0x00000C00U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [6]  = 0x00003000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [7]  = 0x0000C000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [8]  = 0x00030000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [9]  = 0x000C0000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [10] = 0x00300000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [11] = 0x00C00000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [12] = 0x03000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [13] = 0x0C000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [14] = 0x30000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [15] = 0xC0000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
        [0]  = 0x00000003U   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
      }
    };

    static const uint32_t EXTI_D3PCRxH_PCSx_MASK[4][54] = {
      [2] = {
        [48] = 0x00000003U,   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
        [49] = 0x0000000CU,   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
        [50] = 0x00000030U,   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
        [51] = 0x000000C0U,   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
        [52] = 0x00000300U,   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
        [53] = 0x00000C00U   /** @brief Pending request clear input signal selection on event input x= truncate ((n+96)/2) */
      },
      [1] = {
        [20] = 0x00000300U,   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+32)/2) */
        [21] = 0x00000C00U,   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+32)/2) */
        [25] = 0x000C0000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+32)/2) */
        [19] = 0x000000C0U   /** @brief D3 pending request clear input signal selection on event input x = truncate ((n+32)/2) */
      }
    };

    static const uint32_t EXTI_CPUIMRx_MRx_MASK[4][89] = {
      [2] = {
        [1]  = 0x00000002U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [2]  = 0x00000004U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [3]  = 0x00000008U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [4]  = 0x00000010U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [5]  = 0x00000020U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [6]  = 0x00000040U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [7]  = 0x00000080U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [8]  = 0x00000100U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [9]  = 0x00000200U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [10] = 0x00000400U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [11] = 0x00000800U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [12] = 0x00001000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [14] = 0x00004000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [15] = 0x00008000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [16] = 0x00010000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [17] = 0x00020000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [18] = 0x00040000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [19] = 0x00080000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [20] = 0x00100000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [21] = 0x00200000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [22] = 0x00400000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [23] = 0x00800000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [24] = 0x01000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [25] = 0x02000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [26] = 0x04000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [27] = 0x08000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [28] = 0x10000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [29] = 0x20000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [30] = 0x40000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [31] = 0x80000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [0]  = 0x00000001U   /** @brief CPU interrupt mask on direct event input x+32 */
      },
      [3] = {
        [64] = 0x00000001U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [65] = 0x00000002U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [66] = 0x00000004U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [67] = 0x00000008U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [68] = 0x00000010U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [69] = 0x00000020U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [70] = 0x00000040U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [71] = 0x00000080U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [72] = 0x00000100U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [73] = 0x00000200U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [74] = 0x00000400U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [75] = 0x00000800U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [76] = 0x00001000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [77] = 0x00002000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [78] = 0x00004000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [79] = 0x00008000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [80] = 0x00010000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [82] = 0x00040000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [84] = 0x00100000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [85] = 0x00200000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [86] = 0x00400000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [87] = 0x00800000U,   /** @brief CPU interrupt mask on direct event input x+64 */
        [88] = 0x01000000U   /** @brief CPU interrupt mask on direct event input x+64 */
      },
      [1] = {
        [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [22] = 0x00400000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [23] = 0x00800000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [24] = 0x01000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [25] = 0x02000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [26] = 0x04000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [27] = 0x08000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [28] = 0x10000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [29] = 0x20000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [30] = 0x40000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [31] = 0x80000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
        [0]  = 0x00000001U   /** @brief Rising trigger event configuration bit of configurable event input */
      }
    };

    static const uint32_t EXTI_CPUEMRx_MRx_MASK[4][89] = {
      [2] = {
        [32] = 0x00000001U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [33] = 0x00000002U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [34] = 0x00000004U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [35] = 0x00000008U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [36] = 0x00000010U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [37] = 0x00000020U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [38] = 0x00000040U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [39] = 0x00000080U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [40] = 0x00000100U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [41] = 0x00000200U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [42] = 0x00000400U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [43] = 0x00000800U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [44] = 0x00001000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [46] = 0x00004000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [47] = 0x00008000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [48] = 0x00010000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [49] = 0x00020000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [50] = 0x00040000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [51] = 0x00080000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [52] = 0x00100000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [53] = 0x00200000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [54] = 0x00400000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [55] = 0x00800000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [56] = 0x01000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [57] = 0x02000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [58] = 0x04000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [59] = 0x08000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [60] = 0x10000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [61] = 0x20000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [62] = 0x40000000U,   /** @brief CPU interrupt mask on direct event input x+32 */
        [63] = 0x80000000U   /** @brief CPU interrupt mask on direct event input x+32 */
      },
      [3] = {
        [64] = 0x00000001U,   /** @brief CPU event mask on event input x+64 */
        [65] = 0x00000002U,   /** @brief CPU event mask on event input x+64 */
        [66] = 0x00000004U,   /** @brief CPU event mask on event input x+64 */
        [67] = 0x00000008U,   /** @brief CPU event mask on event input x+64 */
        [68] = 0x00000010U,   /** @brief CPU event mask on event input x+64 */
        [69] = 0x00000020U,   /** @brief CPU event mask on event input x+64 */
        [70] = 0x00000040U,   /** @brief CPU event mask on event input x+64 */
        [71] = 0x00000080U,   /** @brief CPU event mask on event input x+64 */
        [72] = 0x00000100U,   /** @brief CPU event mask on event input x+64 */
        [73] = 0x00000200U,   /** @brief CPU event mask on event input x+64 */
        [74] = 0x00000400U,   /** @brief CPU event mask on event input x+64 */
        [75] = 0x00000800U,   /** @brief CPU event mask on event input x+64 */
        [76] = 0x00001000U,   /** @brief CPU event mask on event input x+64 */
        [77] = 0x00002000U,   /** @brief CPU event mask on event input x+64 */
        [78] = 0x00004000U,   /** @brief CPU event mask on event input x+64 */
        [79] = 0x00008000U,   /** @brief CPU event mask on event input x+64 */
        [80] = 0x00010000U,   /** @brief CPU event mask on event input x+64 */
        [82] = 0x00040000U,   /** @brief CPU event mask on event input x+64 */
        [84] = 0x00100000U,   /** @brief CPU event mask on event input x+64 */
        [85] = 0x00200000U,   /** @brief CPU event mask on event input x+64 */
        [86] = 0x00400000U,   /** @brief CPU event mask on event input x+64 */
        [87] = 0x00800000U,   /** @brief CPU event mask on event input x+64 */
        [88] = 0x01000000U   /** @brief CPU event mask on event input x+64 */
      },
      [1] = {
        [1]  = 0x00000002U,   /** @brief CPU event mask on event input x */
        [2]  = 0x00000004U,   /** @brief CPU event mask on event input x */
        [3]  = 0x00000008U,   /** @brief CPU event mask on event input x */
        [4]  = 0x00000010U,   /** @brief CPU event mask on event input x */
        [5]  = 0x00000020U,   /** @brief CPU event mask on event input x */
        [6]  = 0x00000040U,   /** @brief CPU event mask on event input x */
        [7]  = 0x00000080U,   /** @brief CPU event mask on event input x */
        [8]  = 0x00000100U,   /** @brief CPU event mask on event input x */
        [9]  = 0x00000200U,   /** @brief CPU event mask on event input x */
        [10] = 0x00000400U,   /** @brief CPU event mask on event input x */
        [11] = 0x00000800U,   /** @brief CPU event mask on event input x */
        [12] = 0x00001000U,   /** @brief CPU event mask on event input x */
        [13] = 0x00002000U,   /** @brief CPU event mask on event input x */
        [14] = 0x00004000U,   /** @brief CPU event mask on event input x */
        [15] = 0x00008000U,   /** @brief CPU event mask on event input x */
        [16] = 0x00010000U,   /** @brief CPU event mask on event input x */
        [17] = 0x00020000U,   /** @brief CPU event mask on event input x */
        [18] = 0x00040000U,   /** @brief CPU event mask on event input x */
        [19] = 0x00080000U,   /** @brief CPU event mask on event input x */
        [20] = 0x00100000U,   /** @brief CPU event mask on event input x */
        [21] = 0x00200000U,   /** @brief CPU event mask on event input x */
        [22] = 0x00400000U,   /** @brief CPU event mask on event input x */
        [23] = 0x00800000U,   /** @brief CPU event mask on event input x */
        [24] = 0x01000000U,   /** @brief CPU event mask on event input x */
        [25] = 0x02000000U,   /** @brief CPU event mask on event input x */
        [26] = 0x04000000U,   /** @brief CPU event mask on event input x */
        [27] = 0x08000000U,   /** @brief CPU event mask on event input x */
        [28] = 0x10000000U,   /** @brief CPU event mask on event input x */
        [29] = 0x20000000U,   /** @brief CPU event mask on event input x */
        [30] = 0x40000000U,   /** @brief CPU event mask on event input x */
        [31] = 0x80000000U,   /** @brief CPU event mask on event input x */
        [0]  = 0x00000001U   /** @brief CPU event mask on event input x */
      }
    };

    static const uint32_t EXTI_CPUPRx_PRx_MASK[4][87] = {
      [2] = {
        [49] = 0x00020000U,   /** @brief Configurable event inputs x+32 pending bit */
        [51] = 0x00080000U   /** @brief Configurable event inputs x+32 pending bit */
      },
      [3] = {
        [82] = 0x00040000U,   /** @brief Configurable event inputs x+64 pending bit */
        [84] = 0x00100000U,   /** @brief Configurable event inputs x+64 pending bit */
        [85] = 0x00200000U,   /** @brief Configurable event inputs x+64 pending bit */
        [86] = 0x00400000U   /** @brief Configurable event inputs x+64 pending bit */
      },
      [1] = {
        [1]  = 0x00000002U,   /** @brief CPU event mask on event input x */
        [2]  = 0x00000004U,   /** @brief CPU event mask on event input x */
        [3]  = 0x00000008U,   /** @brief CPU event mask on event input x */
        [4]  = 0x00000010U,   /** @brief CPU event mask on event input x */
        [5]  = 0x00000020U,   /** @brief CPU event mask on event input x */
        [6]  = 0x00000040U,   /** @brief CPU event mask on event input x */
        [7]  = 0x00000080U,   /** @brief CPU event mask on event input x */
        [8]  = 0x00000100U,   /** @brief CPU event mask on event input x */
        [9]  = 0x00000200U,   /** @brief CPU event mask on event input x */
        [10] = 0x00000400U,   /** @brief CPU event mask on event input x */
        [11] = 0x00000800U,   /** @brief CPU event mask on event input x */
        [12] = 0x00001000U,   /** @brief CPU event mask on event input x */
        [13] = 0x00002000U,   /** @brief CPU event mask on event input x */
        [14] = 0x00004000U,   /** @brief CPU event mask on event input x */
        [15] = 0x00008000U,   /** @brief CPU event mask on event input x */
        [16] = 0x00010000U,   /** @brief CPU event mask on event input x */
        [17] = 0x00020000U,   /** @brief CPU event mask on event input x */
        [18] = 0x00040000U,   /** @brief CPU event mask on event input x */
        [19] = 0x00080000U,   /** @brief CPU event mask on event input x */
        [20] = 0x00100000U,   /** @brief CPU event mask on event input x */
        [21] = 0x00200000U,   /** @brief CPU event mask on event input x */
        [0]  = 0x00000001U   /** @brief CPU event mask on event input x */
      }
    };

    /**********************************************************************************************
     * @section DELAY_BLOCK_SDMMC Register Definitions
     **********************************************************************************************/

    /**** @subsection DELAY_BLOCK_SDMMC Register Pointer Definitions ****/

    static RW_ uint32_t* const DELAY_BLOCK_SDMMCx_CR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022800U,   /** @brief DLYB control register */
      [1] = (RW_ uint32_t*)0x52008000U   /** @brief DLYB control register */
    };

    static RW_ uint32_t* const DELAY_BLOCK_SDMMCx_CFGR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x48022804U,   /** @brief DLYB configuration register */
      [1] = (RW_ uint32_t*)0x52008004U   /** @brief DLYB configuration register */
    };

    /**** @subsection DELAY_BLOCK_SDMMC Register Reset Value Definitions ****/

    static const uint32_t DELAY_BLOCK_SDMMCx_CR_RST[3] = {
      [2] = 0x00000000U,   /** @brief DLYB control register */
      [1] = 0x00000000U   /** @brief DLYB control register */
    };

    static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_RST[3] = {
      [2] = 0x00000000U,   /** @brief DLYB configuration register */
      [1] = 0x00000000U   /** @brief DLYB configuration register */
    };

    /**** @subsection DELAY_BLOCK_SDMMC Register Value Type Definitions ****/

    typedef uint32_t DELAY_BLOCK_SDMMCx_CR_vt;     /** @brief DELAY_BLOCK_SDMMCx_CR register value type. */
    typedef uint32_t DELAY_BLOCK_SDMMCx_CFGR_vt;   /** @brief DELAY_BLOCK_SDMMCx_CFGR register value type. */

    /**** @subsection DELAY_BLOCK_SDMMC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* DELAY_BLOCK_SDMMCx_CR_pt;     /** @brief DELAY_BLOCK_SDMMCx_CR pointer register pointer type. */
    typedef RW_ uint32_t* DELAY_BLOCK_SDMMCx_CFGR_pt;   /** @brief DELAY_BLOCK_SDMMCx_CFGR pointer register pointer type. */

    /**** @subsection DELAY_BLOCK_SDMMC Field Mask Definitions ****/

    static const uint32_t DELAY_BLOCK_SDMMCx_CR_SEN_MASK[3] = {
      [2] = 0x00000002U,   /** @brief Sampler length enable bit */
      [1] = 0x00000002U   /** @brief Sampler length enable bit */
    };

    static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_LNGF_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Length valid flag */
      [1] = 0x80000000U   /** @brief Length valid flag */
    };

    /**********************************************************************************************
     * @section DELAY_BLOCK_QUADSPI Register Definitions
     **********************************************************************************************/

    /**** @subsection DELAY_BLOCK_QUADSPI Register Pointer Definitions ****/

    static RW_ uint32_t* const DELAY_BLOCK_QUADSPI_CR_PTR   = (RW_ uint32_t*)0x52006000U;   /** @brief DLYB control register */
    static RW_ uint32_t* const DELAY_BLOCK_QUADSPI_CFGR_PTR = (RW_ uint32_t*)0x52006004U;   /** @brief DLYB configuration register */

    /**** @subsection DELAY_BLOCK_QUADSPI Register Reset Value Definitions ****/

    static const uint32_t DELAY_BLOCK_QUADSPI_CR_RST   = 0x00000000U;   /** @brief DLYB control register */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_RST = 0x00000000U;   /** @brief DLYB configuration register */

    /**** @subsection DELAY_BLOCK_QUADSPI Register Value Type Definitions ****/

    typedef uint32_t DELAY_BLOCK_QUADSPI_CR_vt;     /** @brief DELAY_BLOCK_QUADSPI_CR register value type. */
    typedef uint32_t DELAY_BLOCK_QUADSPI_CFGR_vt;   /** @brief DELAY_BLOCK_QUADSPI_CFGR register value type. */

    /**** @subsection DELAY_BLOCK_QUADSPI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* DELAY_BLOCK_QUADSPI_CR_pt;     /** @brief DELAY_BLOCK_QUADSPI_CR pointer register pointer type. */
    typedef RW_ uint32_t* DELAY_BLOCK_QUADSPI_CFGR_pt;   /** @brief DELAY_BLOCK_QUADSPI_CFGR pointer register pointer type. */

    /**** @subsection DELAY_BLOCK_QUADSPI Field Mask Definitions ****/

    static const uint32_t DELAY_BLOCK_QUADSPI_CR_SEN_MASK    = 0x00000002U;   /** @brief Sampler length enable bit */
    static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF_MASK = 0x80000000U;   /** @brief Length valid flag */

    /**********************************************************************************************
     * @section FLASH Register Definitions
     **********************************************************************************************/

    /**** @subsection FLASH Register Pointer Definitions ****/

    static RW_ uint32_t* const FLASH_ACR_PTR        = (RW_ uint32_t*)0x52002000U;   /** @brief Access control register */
    static RW_ uint32_t* const FLASH_ACR__PTR       = (RW_ uint32_t*)0x52002100U;   /** @brief Access control register */
    static RW_ uint32_t* const FLASH_OPTKEYR_PTR    = (RW_ uint32_t*)0x52002008U;   /** @brief FLASH option key register */
    static RW_ uint32_t* const FLASH_OPTKEYR__PTR   = (RW_ uint32_t*)0x52002108U;   /** @brief FLASH option key register */
    static RW_ uint32_t* const FLASH_OPTCR_PTR      = (RW_ uint32_t*)0x52002018U;   /** @brief FLASH option control register */
    static RW_ uint32_t* const FLASH_OPTCR__PTR     = (RW_ uint32_t*)0x52002118U;   /** @brief FLASH option control register */
    static RW_ uint32_t* const FLASH_OPTSR_CUR__PTR = (RW_ uint32_t*)0x5200211CU;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTSR_CUR_PTR  = (RW_ uint32_t*)0x5200201CU;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTSR_PRG_PTR  = (RW_ uint32_t*)0x52002020U;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTSR_PRG__PTR = (RW_ uint32_t*)0x52002120U;   /** @brief FLASH option status register */
    static RW_ uint32_t* const FLASH_OPTCCR__PTR    = (RW_ uint32_t*)0x52002124U;   /** @brief FLASH option clear control register */
    static RW_ uint32_t* const FLASH_OPTCCR_PTR     = (RW_ uint32_t*)0x52002024U;   /** @brief FLASH option clear control register */
    static RO_ uint32_t* const FLASH_BOOT_CURR_PTR  = (RO_ uint32_t*)0x52002040U;   /** @brief FLASH register with boot address */
    static RO_ uint32_t* const FLASH_BOOT_PRGR_PTR  = (RO_ uint32_t*)0x52002044U;   /** @brief FLASH register with boot address */
    static RW_ uint32_t* const FLASH_CRCDATAR_PTR   = (RW_ uint32_t*)0x5200205CU;   /** @brief FLASH CRC data register */

    static RO_ uint32_t* const FLASH_KEYRx_PTR[3] = {
      [2] = (RO_ uint32_t*)0x52002104U,   /** @brief FLASH key register for bank 2 */
      [1] = (RO_ uint32_t*)0x52002004U   /** @brief FLASH key register for bank 1 */
    };

    static RW_ uint32_t* const FLASH_CRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5200210CU,   /** @brief FLASH control register for bank 2 */
      [1] = (RW_ uint32_t*)0x5200200CU   /** @brief FLASH control register for bank 1 */
    };

    static RW_ uint32_t* const FLASH_SRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52002110U,   /** @brief FLASH status register for bank 2 */
      [1] = (RW_ uint32_t*)0x52002010U   /** @brief FLASH status register for bank 1 */
    };

    static RW_ uint32_t* const FLASH_CCRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52002114U,   /** @brief FLASH clear control register for bank 2 */
      [1] = (RW_ uint32_t*)0x52002014U   /** @brief FLASH clear control register for bank 1 */
    };

    static RO_ uint32_t* const FLASH_PRAR_CURx_PTR[3] = {
      [2] = (RO_ uint32_t*)0x52002128U,   /** @brief FLASH protection address for bank 1 */
      [1] = (RO_ uint32_t*)0x52002028U   /** @brief FLASH protection address for bank 1 */
    };

    static RW_ uint32_t* const FLASH_PRAR_PRGx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5200202CU,   /** @brief FLASH protection address for bank 2 */
      [1] = (RW_ uint32_t*)0x5200202CU   /** @brief FLASH protection address for bank 1 */
    };

    static RW_ uint32_t* const FLASH_SCAR_CURx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52002130U,   /** @brief FLASH secure address for bank 2 */
      [1] = (RW_ uint32_t*)0x52002030U   /** @brief FLASH secure address for bank 1 */
    };

    static RW_ uint32_t* const FLASH_SCAR_PRGx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52002134U,   /** @brief FLASH secure address for bank 2 */
      [1] = (RW_ uint32_t*)0x52002034U   /** @brief FLASH secure address for bank 1 */
    };

    static RO_ uint32_t* const FLASH_WPSN_CURxR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x52002138U,   /** @brief FLASH write sector protection for bank 2 */
      [1] = (RO_ uint32_t*)0x52002038U   /** @brief FLASH write sector protection for bank 1 */
    };

    static RW_ uint32_t* const FLASH_WPSN_PRGxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5200213CU,   /** @brief FLASH write sector protection for bank 2 */
      [1] = (RW_ uint32_t*)0x5200203CU   /** @brief FLASH write sector protection for bank 1 */
    };

    static RW_ uint32_t* const FLASH_CRCCRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52002150U,   /** @brief FLASH CRC control register for bank 1 */
      [1] = (RW_ uint32_t*)0x52002050U   /** @brief FLASH CRC control register for bank 1 */
    };

    static RW_ uint32_t* const FLASH_CRCSADDxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52002154U,   /** @brief FLASH CRC start address register for bank 2 */
      [1] = (RW_ uint32_t*)0x52002054U   /** @brief FLASH CRC start address register for bank 1 */
    };

    static RW_ uint32_t* const FLASH_CRCEADDxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x52002158U,   /** @brief FLASH CRC end address register for bank 2 */
      [1] = (RW_ uint32_t*)0x52002058U   /** @brief FLASH CRC end address register for bank 1 */
    };

    static RO_ uint32_t* const FLASH_ECC_FAxR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x52002160U,   /** @brief FLASH ECC fail address for bank 2 */
      [1] = (RO_ uint32_t*)0x52002060U   /** @brief FLASH ECC fail address for bank 1 */
    };

    /**** @subsection FLASH Register Reset Value Definitions ****/

    static const uint32_t FLASH_ACR_RST        = 0x00000600U;   /** @brief Access control register */
    static const uint32_t FLASH_ACR__RST       = 0x00000000U;   /** @brief Access control register */
    static const uint32_t FLASH_OPTKEYR_RST    = 0x00000000U;   /** @brief FLASH option key register */
    static const uint32_t FLASH_OPTKEYR__RST   = 0x00000000U;   /** @brief FLASH option key register */
    static const uint32_t FLASH_OPTCR_RST      = 0x00000000U;   /** @brief FLASH option control register */
    static const uint32_t FLASH_OPTCR__RST     = 0x00000000U;   /** @brief FLASH option control register */
    static const uint32_t FLASH_OPTSR_CUR__RST = 0x00000000U;   /** @brief FLASH option status register */
    static const uint32_t FLASH_OPTSR_CUR_RST  = 0x00000000U;   /** @brief FLASH option status register */
    static const uint32_t FLASH_OPTSR_PRG_RST  = 0x00000000U;   /** @brief FLASH option status register */
    static const uint32_t FLASH_OPTSR_PRG__RST = 0x00000000U;   /** @brief FLASH option status register */
    static const uint32_t FLASH_OPTCCR__RST    = 0x00000000U;   /** @brief FLASH option clear control register */
    static const uint32_t FLASH_OPTCCR_RST     = 0x00000000U;   /** @brief FLASH option clear control register */
    static const uint32_t FLASH_BOOT_CURR_RST  = 0x00000000U;   /** @brief FLASH register with boot address */
    static const uint32_t FLASH_BOOT_PRGR_RST  = 0x00000000U;   /** @brief FLASH register with boot address */
    static const uint32_t FLASH_CRCDATAR_RST   = 0x00000000U;   /** @brief FLASH CRC data register */

    static const uint32_t FLASH_KEYRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH key register for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH key register for bank 1 */
    };

    static const uint32_t FLASH_CRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH control register for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH control register for bank 1 */
    };

    static const uint32_t FLASH_SRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH status register for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH status register for bank 1 */
    };

    static const uint32_t FLASH_CCRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH clear control register for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH clear control register for bank 1 */
    };

    static const uint32_t FLASH_PRAR_CURx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH protection address for bank 1 */
      [1] = 0x00000000U   /** @brief FLASH protection address for bank 1 */
    };

    static const uint32_t FLASH_PRAR_PRGx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH protection address for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH protection address for bank 1 */
    };

    static const uint32_t FLASH_SCAR_CURx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH secure address for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH secure address for bank 1 */
    };

    static const uint32_t FLASH_SCAR_PRGx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH secure address for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH secure address for bank 1 */
    };

    static const uint32_t FLASH_WPSN_CURxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH write sector protection for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH write sector protection for bank 1 */
    };

    static const uint32_t FLASH_WPSN_PRGxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH write sector protection for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH write sector protection for bank 1 */
    };

    static const uint32_t FLASH_CRCCRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH CRC control register for bank 1 */
      [1] = 0x00000000U   /** @brief FLASH CRC control register for bank 1 */
    };

    static const uint32_t FLASH_CRCSADDxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH CRC start address register for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH CRC start address register for bank 1 */
    };

    static const uint32_t FLASH_CRCEADDxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH CRC end address register for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH CRC end address register for bank 1 */
    };

    static const uint32_t FLASH_ECC_FAxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FLASH ECC fail address for bank 2 */
      [1] = 0x00000000U   /** @brief FLASH ECC fail address for bank 1 */
    };

    /**** @subsection FLASH Register Value Type Definitions ****/

    typedef uint32_t FLASH_ACR_vt;          /** @brief FLASH_ACR register value type. */
    typedef uint32_t FLASH_ACR__vt;         /** @brief FLASH_ACR_ register value type. */
    typedef uint32_t FLASH_KEYRx_vt;        /** @brief FLASH_KEYRx register value type. */
    typedef uint32_t FLASH_OPTKEYR_vt;      /** @brief FLASH_OPTKEYR register value type. */
    typedef uint32_t FLASH_OPTKEYR__vt;     /** @brief FLASH_OPTKEYR_ register value type. */
    typedef uint32_t FLASH_CRx_vt;          /** @brief FLASH_CRx register value type. */
    typedef uint32_t FLASH_SRx_vt;          /** @brief FLASH_SRx register value type. */
    typedef uint32_t FLASH_CCRx_vt;         /** @brief FLASH_CCRx register value type. */
    typedef uint32_t FLASH_OPTCR_vt;        /** @brief FLASH_OPTCR register value type. */
    typedef uint32_t FLASH_OPTCR__vt;       /** @brief FLASH_OPTCR_ register value type. */
    typedef uint32_t FLASH_OPTSR_CUR__vt;   /** @brief FLASH_OPTSR_CUR_ register value type. */
    typedef uint32_t FLASH_OPTSR_CUR_vt;    /** @brief FLASH_OPTSR_CUR register value type. */
    typedef uint32_t FLASH_OPTSR_PRG_vt;    /** @brief FLASH_OPTSR_PRG register value type. */
    typedef uint32_t FLASH_OPTSR_PRG__vt;   /** @brief FLASH_OPTSR_PRG_ register value type. */
    typedef uint32_t FLASH_OPTCCR__vt;      /** @brief FLASH_OPTCCR_ register value type. */
    typedef uint32_t FLASH_OPTCCR_vt;       /** @brief FLASH_OPTCCR register value type. */
    typedef uint32_t FLASH_PRAR_CURx_vt;    /** @brief FLASH_PRAR_CURx register value type. */
    typedef uint32_t FLASH_PRAR_PRGx_vt;    /** @brief FLASH_PRAR_PRGx register value type. */
    typedef uint32_t FLASH_SCAR_CURx_vt;    /** @brief FLASH_SCAR_CURx register value type. */
    typedef uint32_t FLASH_SCAR_PRGx_vt;    /** @brief FLASH_SCAR_PRGx register value type. */
    typedef uint32_t FLASH_WPSN_CURxR_vt;   /** @brief FLASH_WPSN_CURxR register value type. */
    typedef uint32_t FLASH_WPSN_PRGxR_vt;   /** @brief FLASH_WPSN_PRGxR register value type. */
    typedef uint32_t FLASH_BOOT_CURR_vt;    /** @brief FLASH_BOOT_CURR register value type. */
    typedef uint32_t FLASH_BOOT_PRGR_vt;    /** @brief FLASH_BOOT_PRGR register value type. */
    typedef uint32_t FLASH_CRCCRx_vt;       /** @brief FLASH_CRCCRx register value type. */
    typedef uint32_t FLASH_CRCSADDxR_vt;    /** @brief FLASH_CRCSADDxR register value type. */
    typedef uint32_t FLASH_CRCEADDxR_vt;    /** @brief FLASH_CRCEADDxR register value type. */
    typedef uint32_t FLASH_CRCDATAR_vt;     /** @brief FLASH_CRCDATAR register value type. */
    typedef uint32_t FLASH_ECC_FAxR_vt;     /** @brief FLASH_ECC_FAxR register value type. */

    /**** @subsection FLASH Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* FLASH_ACR_pt;          /** @brief FLASH_ACR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_ACR__pt;         /** @brief FLASH_ACR_ pointer register pointer type. */
    typedef RO_ uint32_t* FLASH_KEYRx_pt;        /** @brief FLASH_KEYRx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTKEYR_pt;      /** @brief FLASH_OPTKEYR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTKEYR__pt;     /** @brief FLASH_OPTKEYR_ pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_CRx_pt;          /** @brief FLASH_CRx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_SRx_pt;          /** @brief FLASH_SRx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_CCRx_pt;         /** @brief FLASH_CCRx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTCR_pt;        /** @brief FLASH_OPTCR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTCR__pt;       /** @brief FLASH_OPTCR_ pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTSR_CUR__pt;   /** @brief FLASH_OPTSR_CUR_ pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTSR_CUR_pt;    /** @brief FLASH_OPTSR_CUR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTSR_PRG_pt;    /** @brief FLASH_OPTSR_PRG pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTSR_PRG__pt;   /** @brief FLASH_OPTSR_PRG_ pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTCCR__pt;      /** @brief FLASH_OPTCCR_ pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_OPTCCR_pt;       /** @brief FLASH_OPTCCR pointer register pointer type. */
    typedef RO_ uint32_t* FLASH_PRAR_CURx_pt;    /** @brief FLASH_PRAR_CURx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_PRAR_PRGx_pt;    /** @brief FLASH_PRAR_PRGx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_SCAR_CURx_pt;    /** @brief FLASH_SCAR_CURx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_SCAR_PRGx_pt;    /** @brief FLASH_SCAR_PRGx pointer register pointer type. */
    typedef RO_ uint32_t* FLASH_WPSN_CURxR_pt;   /** @brief FLASH_WPSN_CURxR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_WPSN_PRGxR_pt;   /** @brief FLASH_WPSN_PRGxR pointer register pointer type. */
    typedef RO_ uint32_t* FLASH_BOOT_CURR_pt;    /** @brief FLASH_BOOT_CURR pointer register pointer type. */
    typedef RO_ uint32_t* FLASH_BOOT_PRGR_pt;    /** @brief FLASH_BOOT_PRGR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_CRCCRx_pt;       /** @brief FLASH_CRCCRx pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_CRCSADDxR_pt;    /** @brief FLASH_CRCSADDxR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_CRCEADDxR_pt;    /** @brief FLASH_CRCEADDxR pointer register pointer type. */
    typedef RW_ uint32_t* FLASH_CRCDATAR_pt;     /** @brief FLASH_CRCDATAR pointer register pointer type. */
    typedef RO_ uint32_t* FLASH_ECC_FAxR_pt;     /** @brief FLASH_ECC_FAxR pointer register pointer type. */

    /**** @subsection FLASH Field Mask Definitions ****/

    static const uint32_t FLASH_ACR_WRHIGHFREQ_MASK           = 0x00000030U;   /** @brief Flash signal delay */
    static const uint32_t FLASH_ACR__WRHIGHFREQ_MASK          = 0x00000030U;   /** @brief Flash signal delay */
    static const uint32_t FLASH_OPTKEYR_OPTKEYR_MASK          = 0xFFFFFFFFU;   /** @brief Unlock key option bytes */
    static const uint32_t FLASH_OPTKEYR__OPTKEYR_MASK         = 0xFFFFFFFFU;   /** @brief Unlock key option bytes */
    static const uint32_t FLASH_OPTCR_SWAP_BANK_MASK          = 0x80000000U;   /** @brief Bank swapping configuration bit */
    static const uint32_t FLASH_OPTCR__SWAP_BANK_MASK         = 0x80000000U;   /** @brief Bank swapping configuration bit */
    static const uint32_t FLASH_OPTSR_CUR__SWAP_BANK_OPT_MASK = 0x80000000U;   /** @brief Bank swapping option status bit */
    static const uint32_t FLASH_OPTSR_CUR_SWAP_BANK_OPT_MASK  = 0x80000000U;   /** @brief Bank swapping option status bit */
    static const uint32_t FLASH_OPTSR_PRG_SWAP_BANK_OPT_MASK  = 0x80000000U;   /** @brief Bank swapping option configuration bit */
    static const uint32_t FLASH_OPTSR_PRG__SWAP_BANK_OPT_MASK = 0x80000000U;   /** @brief Bank swapping option configuration bit */
    static const uint32_t FLASH_OPTCCR__CLR_OPTCHANGEERR_MASK = 0x40000000U;   /** @brief OPTCHANGEERR reset bit */
    static const uint32_t FLASH_OPTCCR_CLR_OPTCHANGEERR_MASK  = 0x40000000U;   /** @brief OPTCHANGEERR reset bit */
    static const uint32_t FLASH_CRCDATAR_CRC_DATA_MASK        = 0xFFFFFFFFU;   /** @brief CRC result */

    static const uint32_t FLASH_KEYRx_KEYRx_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Bank 2 access configuration unlock key */
      [1] = 0xFFFFFFFFU   /** @brief Bank 1 access configuration unlock key */
    };

    static const uint32_t FLASH_CRx_CRCENDIEx_MASK[3] = {
      [2] = 0x08000000U,   /** @brief Bank 2 end of CRC calculation interrupt enable bit */
      [1] = 0x08000000U   /** @brief Bank 1 end of CRC calculation interrupt enable bit */
    };

    static const uint32_t FLASH_SRx_CRCENDx_MASK[3] = {
      [2] = 0x08000000U,   /** @brief Bank 2 crc-complete flag */
      [1] = 0x08000000U   /** @brief Bank 1 crc-complete flag */
    };

    static const uint32_t FLASH_CCRx_CLR_CRCENDx_MASK[3] = {
      [2] = 0x08000000U,   /** @brief Bank 2 CRCEND1 flag clear bit */
      [1] = 0x08000000U   /** @brief Bank 1 CRCEND1 flag clear bit */
    };

    static const uint32_t FLASH_PRAR_CURx_DMEPx_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Bank 2 PCROP protected erase enable option status bit */
      [1] = 0x80000000U   /** @brief Bank 1 PCROP protected erase enable option status bit */
    };

    static const uint32_t FLASH_PRAR_PRGx_DMEPx_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Bank 2 PCROP protected erase enable option configuration bit */
      [1] = 0x80000000U   /** @brief Bank 1 PCROP protected erase enable option configuration bit */
    };

    static const uint32_t FLASH_SCAR_CURx_DMESx_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Bank 2 secure protected erase enable option status bit */
      [1] = 0x80000000U   /** @brief Bank 1 secure protected erase enable option status bit */
    };

    static const uint32_t FLASH_SCAR_PRGx_DMESx_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Bank 2 secure protected erase enable option configuration bit */
      [1] = 0x80000000U   /** @brief Bank 1 secure protected erase enable option configuration bit */
    };

    static const uint32_t FLASH_WPSN_CURxR_WRPSNx_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Bank 2 sector write protection option status byte */
      [1] = 0x000000FFU   /** @brief Bank 1 sector write protection option status byte */
    };

    static const uint32_t FLASH_WPSN_PRGxR_WRPSNx_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Bank 2 sector write protection configuration byte */
      [1] = 0x000000FFU   /** @brief Bank 1 sector write protection configuration byte */
    };

    static const uint32_t FLASH_BOOT_CURR_BOOT_ADDx_MASK[2] = {
      [1] = 0xFFFF0000U,   /** @brief Boot address 1 */
      [0] = 0x0000FFFFU   /** @brief Boot address 0 */
    };

    static const uint32_t FLASH_BOOT_PRGR_BOOT_ADDx_MASK[2] = {
      [1] = 0xFFFF0000U,   /** @brief Boot address 1 */
      [0] = 0x0000FFFFU   /** @brief Boot address 0 */
    };

    static const uint32_t FLASH_CRCCRx_CRC_BURST_MASK[3] = {
      [2] = 0x00300000U,   /** @brief Bank 2 CRC burst size */
      [1] = 0x00300000U   /** @brief Bank 1 CRC burst size */
    };

    static const uint32_t FLASH_CRCSADDxR_CRC_START_ADDR_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief CRC start address on bank 2 */
      [1] = 0xFFFFFFFFU   /** @brief CRC start address on bank 1 */
    };

    static const uint32_t FLASH_CRCEADDxR_CRC_END_ADDR_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief CRC end address on bank 2 */
      [1] = 0xFFFFFFFFU   /** @brief CRC end address on bank 1 */
    };

    static const uint32_t FLASH_ECC_FAxR_FAIL_ECC_ADDRx_MASK[3] = {
      [2] = 0x00007FFFU,   /** @brief Bank 2 ECC error address */
      [1] = 0x00007FFFU   /** @brief Bank 1 ECC error address */
    };

    /**********************************************************************************************
     * @section AXI Register Definitions
     **********************************************************************************************/

    /**** @subsection AXI Register Pointer Definitions ****/

    static RO_ uint32_t* const AXI_AXI_PERIPH_ID_x_PTR[5] = {
      [0] = (RO_ uint32_t*)0x51001FE0U,   /** @brief AXI interconnect - peripheral ID0 register */
      [1] = (RO_ uint32_t*)0x51001FE4U,   /** @brief AXI interconnect - peripheral ID1 register */
      [2] = (RO_ uint32_t*)0x51001FE8U,   /** @brief AXI interconnect - peripheral ID2 register */
      [3] = (RO_ uint32_t*)0x51001FECU,   /** @brief AXI interconnect - peripheral ID3 register */
      [4] = (RO_ uint32_t*)0x51001FD0U   /** @brief AXI interconnect - peripheral ID4 register */
    };

    static RO_ uint32_t* const AXI_AXI_COMP_ID_x_PTR[4] = {
      [1] = (RO_ uint32_t*)0x51001FF4U,   /** @brief AXI interconnect - component ID1 register */
      [2] = (RO_ uint32_t*)0x51001FF8U,   /** @brief AXI interconnect - component ID2 register */
      [3] = (RO_ uint32_t*)0x51001FFCU,   /** @brief AXI interconnect - component ID3 register */
      [0] = (RO_ uint32_t*)0x51001FF0U   /** @brief AXI interconnect - component ID0 register */
    };

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_ISS_BM_PTR[8] = {
      [2] = (RW_ uint32_t*)0x51003008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [3] = (RW_ uint32_t*)0x51004008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [4] = (RW_ uint32_t*)0x51005008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [5] = (RW_ uint32_t*)0x51006008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [6] = (RW_ uint32_t*)0x51007008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [7] = (RW_ uint32_t*)0x5100800CU,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [1] = (RW_ uint32_t*)0x51002008U   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    };

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD2_PTR[8] = {
      [2] = (RW_ uint32_t*)0x51003024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      [7] = (RW_ uint32_t*)0x51008024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      [1] = (RW_ uint32_t*)0x51002024U   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
    };

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_LB_PTR[3] = {
      [2] = (RW_ uint32_t*)0x5100302CU,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [1] = (RW_ uint32_t*)0x5100202CU   /** @brief AXI interconnect - TARG x long burst functionality modification */
    };

    static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_PTR[8] = {
      [2] = (RW_ uint32_t*)0x51003108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [7] = (RW_ uint32_t*)0x51008108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [1] = (RW_ uint32_t*)0x51002108U   /** @brief AXI interconnect - TARG x long burst functionality modification */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD2_PTR[4] = {
      [3] = (RW_ uint32_t*)0x51044024U,   /** @brief AXI interconnect - INI x functionality modification 2 register */
      [1] = (RW_ uint32_t*)0x51042024U   /** @brief AXI interconnect - INI x functionality modification 2 register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD_AHB_PTR[4] = {
      [3] = (RW_ uint32_t*)0x51044028U,   /** @brief AXI interconnect - INI x AHB functionality modification register */
      [1] = (RW_ uint32_t*)0x51042028U   /** @brief AXI interconnect - INI x AHB functionality modification register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_READ_QOS_PTR[7] = {
      [2] = (RW_ uint32_t*)0x51043100U,   /** @brief AXI interconnect - INI x read qos register */
      [3] = (RW_ uint32_t*)0x51044100U,   /** @brief AXI interconnect - INI x read qos register */
      [4] = (RW_ uint32_t*)0x51045100U,   /** @brief AXI interconnect - INI x read qos register */
      [5] = (RW_ uint32_t*)0x51046100U,   /** @brief AXI interconnect - INI x read qos register */
      [6] = (RW_ uint32_t*)0x51047100U,   /** @brief AXI interconnect - INI x read qos register */
      [1] = (RW_ uint32_t*)0x51042100U   /** @brief AXI interconnect - INI x read qos register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_WRITE_QOS_PTR[7] = {
      [2] = (RW_ uint32_t*)0x51043104U,   /** @brief AXI interconnect - INI x write qos register */
      [3] = (RW_ uint32_t*)0x51044104U,   /** @brief AXI interconnect - INI x write qos register */
      [4] = (RW_ uint32_t*)0x51045104U,   /** @brief AXI interconnect - INI x write qos register */
      [5] = (RW_ uint32_t*)0x51046104U,   /** @brief AXI interconnect - INI x write qos register */
      [6] = (RW_ uint32_t*)0x51047104U,   /** @brief AXI interconnect - INI x write qos register */
      [1] = (RW_ uint32_t*)0x51042104U   /** @brief AXI interconnect - INI x write qos register */
    };

    static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD_PTR[7] = {
      [2] = (RW_ uint32_t*)0x51043108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [3] = (RW_ uint32_t*)0x51044108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [4] = (RW_ uint32_t*)0x51045108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [5] = (RW_ uint32_t*)0x51046108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [6] = (RW_ uint32_t*)0x51047108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [1] = (RW_ uint32_t*)0x51042108U   /** @brief AXI interconnect - INI x issuing functionality modification register */
    };

    /**** @subsection AXI Register Reset Value Definitions ****/

    static const uint32_t AXI_AXI_PERIPH_ID_x_RST[5] = {
      [0] = 0x00000004U,   /** @brief AXI interconnect - peripheral ID0 register */
      [1] = 0x00000004U,   /** @brief AXI interconnect - peripheral ID1 register */
      [2] = 0x00000004U,   /** @brief AXI interconnect - peripheral ID2 register */
      [3] = 0x00000004U,   /** @brief AXI interconnect - peripheral ID3 register */
      [4] = 0x00000004U   /** @brief AXI interconnect - peripheral ID4 register */
    };

    static const uint32_t AXI_AXI_COMP_ID_x_RST[4] = {
      [1] = 0x00000004U,   /** @brief AXI interconnect - component ID1 register */
      [2] = 0x00000004U,   /** @brief AXI interconnect - component ID2 register */
      [3] = 0x00000004U,   /** @brief AXI interconnect - component ID3 register */
      [0] = 0x00000004U   /** @brief AXI interconnect - component ID0 register */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_RST[8] = {
      [2] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [3] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [4] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [5] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [6] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [7] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
      [1] = 0x00000004U   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD2_RST[8] = {
      [2] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      [7] = 0x00000004U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
      [1] = 0x00000004U   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_LB_RST[3] = {
      [2] = 0x00000004U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [1] = 0x00000004U   /** @brief AXI interconnect - TARG x long burst functionality modification */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_RST[8] = {
      [2] = 0x00000004U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [7] = 0x00000004U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
      [1] = 0x00000004U   /** @brief AXI interconnect - TARG x long burst functionality modification */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD2_RST[4] = {
      [3] = 0x00000004U,   /** @brief AXI interconnect - INI x functionality modification 2 register */
      [1] = 0x00000004U   /** @brief AXI interconnect - INI x functionality modification 2 register */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD_AHB_RST[4] = {
      [3] = 0x00000004U,   /** @brief AXI interconnect - INI x AHB functionality modification register */
      [1] = 0x00000004U   /** @brief AXI interconnect - INI x AHB functionality modification register */
    };

    static const uint32_t AXI_AXI_INIx_READ_QOS_RST[7] = {
      [2] = 0x00000004U,   /** @brief AXI interconnect - INI x read qos register */
      [3] = 0x00000004U,   /** @brief AXI interconnect - INI x read qos register */
      [4] = 0x00000004U,   /** @brief AXI interconnect - INI x read qos register */
      [5] = 0x00000004U,   /** @brief AXI interconnect - INI x read qos register */
      [6] = 0x00000004U,   /** @brief AXI interconnect - INI x read qos register */
      [1] = 0x00000004U   /** @brief AXI interconnect - INI x read qos register */
    };

    static const uint32_t AXI_AXI_INIx_WRITE_QOS_RST[7] = {
      [2] = 0x00000004U,   /** @brief AXI interconnect - INI x write qos register */
      [3] = 0x00000004U,   /** @brief AXI interconnect - INI x write qos register */
      [4] = 0x00000004U,   /** @brief AXI interconnect - INI x write qos register */
      [5] = 0x00000004U,   /** @brief AXI interconnect - INI x write qos register */
      [6] = 0x00000004U,   /** @brief AXI interconnect - INI x write qos register */
      [1] = 0x00000004U   /** @brief AXI interconnect - INI x write qos register */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD_RST[7] = {
      [2] = 0x00000004U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [3] = 0x00000004U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [4] = 0x00000004U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [5] = 0x00000004U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [6] = 0x00000004U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
      [1] = 0x00000004U   /** @brief AXI interconnect - INI x issuing functionality modification register */
    };

    /**** @subsection AXI Register Value Type Definitions ****/

    typedef uint32_t AXI_AXI_PERIPH_ID_x_vt;           /** @brief AXI_AXI_PERIPH_ID_x register value type. */
    typedef uint32_t AXI_AXI_COMP_ID_x_vt;             /** @brief AXI_AXI_COMP_ID_x register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_vt;   /** @brief AXI_AXI_TARGx_FN_MOD_ISS_BM register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD2_vt;         /** @brief AXI_AXI_TARGx_FN_MOD2 register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD_LB_vt;       /** @brief AXI_AXI_TARGx_FN_MOD_LB register value type. */
    typedef uint32_t AXI_AXI_TARGx_FN_MOD_vt;          /** @brief AXI_AXI_TARGx_FN_MOD register value type. */
    typedef uint32_t AXI_AXI_INIx_FN_MOD2_vt;          /** @brief AXI_AXI_INIx_FN_MOD2 register value type. */
    typedef uint32_t AXI_AXI_INIx_FN_MOD_AHB_vt;       /** @brief AXI_AXI_INIx_FN_MOD_AHB register value type. */
    typedef uint32_t AXI_AXI_INIx_READ_QOS_vt;         /** @brief AXI_AXI_INIx_READ_QOS register value type. */
    typedef uint32_t AXI_AXI_INIx_WRITE_QOS_vt;        /** @brief AXI_AXI_INIx_WRITE_QOS register value type. */
    typedef uint32_t AXI_AXI_INIx_FN_MOD_vt;           /** @brief AXI_AXI_INIx_FN_MOD register value type. */

    /**** @subsection AXI Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* AXI_AXI_PERIPH_ID_x_pt;           /** @brief AXI_AXI_PERIPH_ID_x pointer register pointer type. */
    typedef RO_ uint32_t* AXI_AXI_COMP_ID_x_pt;             /** @brief AXI_AXI_COMP_ID_x pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_TARGx_FN_MOD_ISS_BM_pt;   /** @brief AXI_AXI_TARGx_FN_MOD_ISS_BM pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_TARGx_FN_MOD2_pt;         /** @brief AXI_AXI_TARGx_FN_MOD2 pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_TARGx_FN_MOD_LB_pt;       /** @brief AXI_AXI_TARGx_FN_MOD_LB pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_TARGx_FN_MOD_pt;          /** @brief AXI_AXI_TARGx_FN_MOD pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_INIx_FN_MOD2_pt;          /** @brief AXI_AXI_INIx_FN_MOD2 pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_INIx_FN_MOD_AHB_pt;       /** @brief AXI_AXI_INIx_FN_MOD_AHB pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_INIx_READ_QOS_pt;         /** @brief AXI_AXI_INIx_READ_QOS pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_INIx_WRITE_QOS_pt;        /** @brief AXI_AXI_INIx_WRITE_QOS pointer register pointer type. */
    typedef RW_ uint32_t* AXI_AXI_INIx_FN_MOD_pt;           /** @brief AXI_AXI_INIx_FN_MOD pointer register pointer type. */

    /**** @subsection AXI Field Mask Definitions ****/

    static const uint32_t AXI_AXI_PERIPH_ID_x_KCOUNT4_MASK = 0x000000F0U;   /** @brief Register file size */

    static const uint32_t AXI_AXI_COMP_ID_x_PREAMBLE_MASK[4] = {
      [1] = 0x0000000FU,   /** @brief Preamble bits 8 to 11 */
      [2] = 0x000000FFU,   /** @brief Preamble bits 12 to 19 */
      [3] = 0x000000FFU,   /** @brief Preamble bits 20 to 27 */
      [0] = 0x000000FFU   /** @brief Preamble bits 0 to 7 */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MASK[8] = {
      [2] = 0x00000002U,   /** @brief Switch matrix write issuing override for target */
      [3] = 0x00000002U,   /** @brief Switch matrix write issuing override for target */
      [4] = 0x00000002U,   /** @brief Switch matrix write issuing override for target */
      [5] = 0x00000002U,   /** @brief Switch matrix write issuing override for target */
      [6] = 0x00000002U,   /** @brief Switch matrix write issuing override for target */
      [7] = 0x00000002U,   /** @brief Switch matrix write issuing override for target */
      [1] = 0x00000002U   /** @brief Switch matrix write issuing override for target */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD2_BYPASS_MERGE_MASK[8] = {
      [2] = 0x00000001U,   /** @brief Disable packing of beats to match the output data width */
      [7] = 0x00000001U,   /** @brief Disable packing of beats to match the output data width */
      [1] = 0x00000001U   /** @brief Disable packing of beats to match the output data width */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_LB_FN_MOD_LB_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Controls burst breaking of long bursts */
      [1] = 0x00000001U   /** @brief Controls burst breaking of long bursts */
    };

    static const uint32_t AXI_AXI_TARGx_FN_MOD_WRITE_ISS_OVERRIDE_MASK[8] = {
      [2] = 0x00000002U,   /** @brief Override AMIB write issuing capability */
      [7] = 0x00000002U,   /** @brief Override AMIB write issuing capability */
      [1] = 0x00000002U   /** @brief Override AMIB write issuing capability */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD2_BYPASS_MERGE_MASK[4] = {
      [3] = 0x00000001U,   /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
      [1] = 0x00000001U   /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD_AHB_WR_INC_OVERRIDE_MASK[4] = {
      [3] = 0x00000002U,   /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
      [1] = 0x00000002U   /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
    };

    static const uint32_t AXI_AXI_INIx_READ_QOS_AR_QOS_MASK[7] = {
      [2] = 0x0000000FU,   /** @brief Read channel qos setting */
      [3] = 0x0000000FU,   /** @brief Read channel qos setting */
      [4] = 0x0000000FU,   /** @brief Read channel qos setting */
      [5] = 0x0000000FU,   /** @brief Read channel qos setting */
      [6] = 0x0000000FU,   /** @brief Read channel qos setting */
      [1] = 0x0000000FU   /** @brief Read channel qos setting */
    };

    static const uint32_t AXI_AXI_INIx_WRITE_QOS_AW_QOS_MASK[7] = {
      [2] = 0x0000000FU,   /** @brief Write channel qos setting */
      [3] = 0x0000000FU,   /** @brief Write channel qos setting */
      [4] = 0x0000000FU,   /** @brief Write channel qos setting */
      [5] = 0x0000000FU,   /** @brief Write channel qos setting */
      [6] = 0x0000000FU,   /** @brief Write channel qos setting */
      [1] = 0x0000000FU   /** @brief Write channel qos setting */
    };

    static const uint32_t AXI_AXI_INIx_FN_MOD_WRITE_ISS_OVERRIDE_MASK[7] = {
      [2] = 0x00000002U,   /** @brief Override ASIB write issuing capability */
      [3] = 0x00000002U,   /** @brief Override ASIB write issuing capability */
      [4] = 0x00000002U,   /** @brief Override ASIB write issuing capability */
      [5] = 0x00000002U,   /** @brief Override ASIB write issuing capability */
      [6] = 0x00000002U,   /** @brief Override ASIB write issuing capability */
      [1] = 0x00000002U   /** @brief Override ASIB write issuing capability */
    };

    /**********************************************************************************************
     * @section HASH Register Definitions
     **********************************************************************************************/

    /**** @subsection HASH Register Pointer Definitions ****/

    static RW_ uint32_t* const HASH_CR_PTR  = (RW_ uint32_t*)0x48021400U;   /** @brief Control register */
    static RW_ uint32_t* const HASH_DIN_PTR = (RW_ uint32_t*)0x48021404U;   /** @brief Data input register */
    static RW_ uint32_t* const HASH_STR_PTR = (RW_ uint32_t*)0x48021408U;   /** @brief Start register */
    static RW_ uint32_t* const HASH_IMR_PTR = (RW_ uint32_t*)0x48021420U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const HASH_SR_PTR  = (RW_ uint32_t*)0x48021424U;   /** @brief Status register */

    static RO_ uint32_t* const HASH_HRx_PTR[5] = {
      [1] = (RO_ uint32_t*)0x48021410U,   /** @brief Digest registers */
      [2] = (RO_ uint32_t*)0x48021414U,   /** @brief Digest registers */
      [3] = (RO_ uint32_t*)0x48021418U,   /** @brief Digest registers */
      [4] = (RO_ uint32_t*)0x4802141CU,   /** @brief Digest registers */
      [0] = (RO_ uint32_t*)0x4802140CU   /** @brief Digest registers */
    };

    static RW_ uint32_t* const HASH_CSRx_PTR[54] = {
      [1]  = (RW_ uint32_t*)0x480214FCU,   /** @brief Context swap registers */
      [2]  = (RW_ uint32_t*)0x48021500U,   /** @brief Context swap registers */
      [3]  = (RW_ uint32_t*)0x48021504U,   /** @brief Context swap registers */
      [4]  = (RW_ uint32_t*)0x48021508U,   /** @brief Context swap registers */
      [5]  = (RW_ uint32_t*)0x4802150CU,   /** @brief Context swap registers */
      [6]  = (RW_ uint32_t*)0x48021510U,   /** @brief Context swap registers */
      [7]  = (RW_ uint32_t*)0x48021514U,   /** @brief Context swap registers */
      [8]  = (RW_ uint32_t*)0x48021518U,   /** @brief Context swap registers */
      [9]  = (RW_ uint32_t*)0x4802151CU,   /** @brief Context swap registers */
      [10] = (RW_ uint32_t*)0x48021520U,   /** @brief Context swap registers */
      [11] = (RW_ uint32_t*)0x48021524U,   /** @brief Context swap registers */
      [12] = (RW_ uint32_t*)0x48021528U,   /** @brief Context swap registers */
      [13] = (RW_ uint32_t*)0x4802152CU,   /** @brief Context swap registers */
      [14] = (RW_ uint32_t*)0x48021530U,   /** @brief Context swap registers */
      [15] = (RW_ uint32_t*)0x48021534U,   /** @brief Context swap registers */
      [16] = (RW_ uint32_t*)0x48021538U,   /** @brief Context swap registers */
      [17] = (RW_ uint32_t*)0x4802153CU,   /** @brief Context swap registers */
      [18] = (RW_ uint32_t*)0x48021540U,   /** @brief Context swap registers */
      [19] = (RW_ uint32_t*)0x48021544U,   /** @brief Context swap registers */
      [20] = (RW_ uint32_t*)0x48021548U,   /** @brief Context swap registers */
      [21] = (RW_ uint32_t*)0x4802154CU,   /** @brief Context swap registers */
      [22] = (RW_ uint32_t*)0x48021550U,   /** @brief Context swap registers */
      [23] = (RW_ uint32_t*)0x48021554U,   /** @brief Context swap registers */
      [24] = (RW_ uint32_t*)0x48021558U,   /** @brief Context swap registers */
      [25] = (RW_ uint32_t*)0x4802155CU,   /** @brief Context swap registers */
      [26] = (RW_ uint32_t*)0x48021560U,   /** @brief Context swap registers */
      [27] = (RW_ uint32_t*)0x48021564U,   /** @brief Context swap registers */
      [28] = (RW_ uint32_t*)0x48021568U,   /** @brief Context swap registers */
      [29] = (RW_ uint32_t*)0x4802156CU,   /** @brief Context swap registers */
      [30] = (RW_ uint32_t*)0x48021570U,   /** @brief Context swap registers */
      [31] = (RW_ uint32_t*)0x48021574U,   /** @brief Context swap registers */
      [32] = (RW_ uint32_t*)0x48021578U,   /** @brief Context swap registers */
      [33] = (RW_ uint32_t*)0x4802157CU,   /** @brief Context swap registers */
      [34] = (RW_ uint32_t*)0x48021580U,   /** @brief Context swap registers */
      [35] = (RW_ uint32_t*)0x48021584U,   /** @brief Context swap registers */
      [36] = (RW_ uint32_t*)0x48021588U,   /** @brief Context swap registers */
      [37] = (RW_ uint32_t*)0x4802158CU,   /** @brief Context swap registers */
      [38] = (RW_ uint32_t*)0x48021590U,   /** @brief Context swap registers */
      [39] = (RW_ uint32_t*)0x48021594U,   /** @brief Context swap registers */
      [40] = (RW_ uint32_t*)0x48021598U,   /** @brief Context swap registers */
      [41] = (RW_ uint32_t*)0x4802159CU,   /** @brief Context swap registers */
      [42] = (RW_ uint32_t*)0x480215A0U,   /** @brief Context swap registers */
      [43] = (RW_ uint32_t*)0x480215A4U,   /** @brief Context swap registers */
      [44] = (RW_ uint32_t*)0x480215A8U,   /** @brief Context swap registers */
      [45] = (RW_ uint32_t*)0x480215ACU,   /** @brief Context swap registers */
      [46] = (RW_ uint32_t*)0x480215B0U,   /** @brief Context swap registers */
      [47] = (RW_ uint32_t*)0x480215B4U,   /** @brief Context swap registers */
      [48] = (RW_ uint32_t*)0x480215B8U,   /** @brief Context swap registers */
      [49] = (RW_ uint32_t*)0x480215BCU,   /** @brief Context swap registers */
      [50] = (RW_ uint32_t*)0x480215C0U,   /** @brief Context swap registers */
      [51] = (RW_ uint32_t*)0x480215C4U,   /** @brief Context swap registers */
      [52] = (RW_ uint32_t*)0x480215C8U,   /** @brief Context swap registers */
      [53] = (RW_ uint32_t*)0x480215CCU,   /** @brief Context swap registers */
      [0]  = (RW_ uint32_t*)0x480214F8U   /** @brief Context swap registers */
    };

    static RO_ uint32_t* const HASH_HASH_HRx_PTR[8] = {
      [1] = (RO_ uint32_t*)0x48021714U,   /** @brief Read-only */
      [2] = (RO_ uint32_t*)0x48021718U,   /** @brief Read-only */
      [3] = (RO_ uint32_t*)0x4802171CU,   /** @brief Read-only */
      [4] = (RO_ uint32_t*)0x48021720U,   /** @brief Read-only */
      [5] = (RO_ uint32_t*)0x48021724U,   /** @brief Read-only */
      [6] = (RO_ uint32_t*)0x48021728U,   /** @brief Read-only */
      [7] = (RO_ uint32_t*)0x4802172CU,   /** @brief Read-only */
      [0] = (RO_ uint32_t*)0x48021710U   /** @brief HASH digest register */
    };

    /**** @subsection HASH Register Reset Value Definitions ****/

    static const uint32_t HASH_CR_RST  = 0x00000000U;   /** @brief Control register */
    static const uint32_t HASH_DIN_RST = 0x00000000U;   /** @brief Data input register */
    static const uint32_t HASH_STR_RST = 0x00000000U;   /** @brief Start register */
    static const uint32_t HASH_IMR_RST = 0x00000000U;   /** @brief Interrupt enable register */
    static const uint32_t HASH_SR_RST  = 0x00000001U;   /** @brief Status register */

    static const uint32_t HASH_HRx_RST[5] = {
      [1] = 0x00000000U,   /** @brief Digest registers */
      [2] = 0x00000000U,   /** @brief Digest registers */
      [3] = 0x00000000U,   /** @brief Digest registers */
      [4] = 0x00000000U,   /** @brief Digest registers */
      [0] = 0x00000000U   /** @brief Digest registers */
    };

    static const uint32_t HASH_CSRx_RST[54] = {
      [1]  = 0x00000000U,   /** @brief Context swap registers */
      [2]  = 0x00000000U,   /** @brief Context swap registers */
      [3]  = 0x00000000U,   /** @brief Context swap registers */
      [4]  = 0x00000000U,   /** @brief Context swap registers */
      [5]  = 0x00000000U,   /** @brief Context swap registers */
      [6]  = 0x00000000U,   /** @brief Context swap registers */
      [7]  = 0x00000000U,   /** @brief Context swap registers */
      [8]  = 0x00000000U,   /** @brief Context swap registers */
      [9]  = 0x00000000U,   /** @brief Context swap registers */
      [10] = 0x00000000U,   /** @brief Context swap registers */
      [11] = 0x00000000U,   /** @brief Context swap registers */
      [12] = 0x00000000U,   /** @brief Context swap registers */
      [13] = 0x00000000U,   /** @brief Context swap registers */
      [14] = 0x00000000U,   /** @brief Context swap registers */
      [15] = 0x00000000U,   /** @brief Context swap registers */
      [16] = 0x00000000U,   /** @brief Context swap registers */
      [17] = 0x00000000U,   /** @brief Context swap registers */
      [18] = 0x00000000U,   /** @brief Context swap registers */
      [19] = 0x00000000U,   /** @brief Context swap registers */
      [20] = 0x00000000U,   /** @brief Context swap registers */
      [21] = 0x00000000U,   /** @brief Context swap registers */
      [22] = 0x00000000U,   /** @brief Context swap registers */
      [23] = 0x00000000U,   /** @brief Context swap registers */
      [24] = 0x00000000U,   /** @brief Context swap registers */
      [25] = 0x00000000U,   /** @brief Context swap registers */
      [26] = 0x00000000U,   /** @brief Context swap registers */
      [27] = 0x00000000U,   /** @brief Context swap registers */
      [28] = 0x00000000U,   /** @brief Context swap registers */
      [29] = 0x00000000U,   /** @brief Context swap registers */
      [30] = 0x00000000U,   /** @brief Context swap registers */
      [31] = 0x00000000U,   /** @brief Context swap registers */
      [32] = 0x00000000U,   /** @brief Context swap registers */
      [33] = 0x00000000U,   /** @brief Context swap registers */
      [34] = 0x00000000U,   /** @brief Context swap registers */
      [35] = 0x00000000U,   /** @brief Context swap registers */
      [36] = 0x00000000U,   /** @brief Context swap registers */
      [37] = 0x00000000U,   /** @brief Context swap registers */
      [38] = 0x00000000U,   /** @brief Context swap registers */
      [39] = 0x00000000U,   /** @brief Context swap registers */
      [40] = 0x00000000U,   /** @brief Context swap registers */
      [41] = 0x00000000U,   /** @brief Context swap registers */
      [42] = 0x00000000U,   /** @brief Context swap registers */
      [43] = 0x00000000U,   /** @brief Context swap registers */
      [44] = 0x00000000U,   /** @brief Context swap registers */
      [45] = 0x00000000U,   /** @brief Context swap registers */
      [46] = 0x00000000U,   /** @brief Context swap registers */
      [47] = 0x00000000U,   /** @brief Context swap registers */
      [48] = 0x00000000U,   /** @brief Context swap registers */
      [49] = 0x00000000U,   /** @brief Context swap registers */
      [50] = 0x00000000U,   /** @brief Context swap registers */
      [51] = 0x00000000U,   /** @brief Context swap registers */
      [52] = 0x00000000U,   /** @brief Context swap registers */
      [53] = 0x00000000U,   /** @brief Context swap registers */
      [0]  = 0x00000000U   /** @brief Context swap registers */
    };

    static const uint32_t HASH_HASH_HRx_RST[8] = {
      [1] = 0x00000000U,   /** @brief Read-only */
      [2] = 0x00000000U,   /** @brief Read-only */
      [3] = 0x00000000U,   /** @brief Read-only */
      [4] = 0x00000000U,   /** @brief Read-only */
      [5] = 0x00000000U,   /** @brief Read-only */
      [6] = 0x00000000U,   /** @brief Read-only */
      [7] = 0x00000000U,   /** @brief Read-only */
      [0] = 0x00000000U   /** @brief HASH digest register */
    };

    /**** @subsection HASH Register Value Type Definitions ****/

    typedef uint32_t HASH_CR_vt;         /** @brief HASH_CR register value type. */
    typedef uint32_t HASH_DIN_vt;        /** @brief HASH_DIN register value type. */
    typedef uint32_t HASH_STR_vt;        /** @brief HASH_STR register value type. */
    typedef uint32_t HASH_HRx_vt;        /** @brief HASH_HRx register value type. */
    typedef uint32_t HASH_IMR_vt;        /** @brief HASH_IMR register value type. */
    typedef uint32_t HASH_SR_vt;         /** @brief HASH_SR register value type. */
    typedef uint32_t HASH_CSRx_vt;       /** @brief HASH_CSRx register value type. */
    typedef uint32_t HASH_HASH_HRx_vt;   /** @brief HASH_HASH_HRx register value type. */

    /**** @subsection HASH Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HASH_CR_pt;         /** @brief HASH_CR pointer register pointer type. */
    typedef RW_ uint32_t* HASH_DIN_pt;        /** @brief HASH_DIN pointer register pointer type. */
    typedef RW_ uint32_t* HASH_STR_pt;        /** @brief HASH_STR pointer register pointer type. */
    typedef RO_ uint32_t* HASH_HRx_pt;        /** @brief HASH_HRx pointer register pointer type. */
    typedef RW_ uint32_t* HASH_IMR_pt;        /** @brief HASH_IMR pointer register pointer type. */
    typedef RW_ uint32_t* HASH_SR_pt;         /** @brief HASH_SR pointer register pointer type. */
    typedef RW_ uint32_t* HASH_CSRx_pt;       /** @brief HASH_CSRx pointer register pointer type. */
    typedef RO_ uint32_t* HASH_HASH_HRx_pt;   /** @brief HASH_HASH_HRx pointer register pointer type. */

    /**** @subsection HASH Field Mask Definitions ****/

    static const uint32_t HASH_CR_LKEY_MASK    = 0x00010000U;   /** @brief Long key selection */
    static const uint32_t HASH_DIN_DATAIN_MASK = 0xFFFFFFFFU;   /** @brief Data input */
    static const uint32_t HASH_STR_NBLW_MASK   = 0x0000001FU;   /** @brief Number of valid bits in the last word of the message */
    static const uint32_t HASH_IMR_DINIE_MASK  = 0x00000001U;   /** @brief Data input interrupt enable */
    static const uint32_t HASH_SR_DINIS_MASK   = 0x00000001U;   /** @brief Data input interrupt status */

    static const uint32_t HASH_HRx_Hx_MASK[5] = {
      [1] = 0xFFFFFFFFU,   /** @brief H1 */
      [2] = 0xFFFFFFFFU,   /** @brief H2 */
      [3] = 0xFFFFFFFFU,   /** @brief H3 */
      [4] = 0xFFFFFFFFU,   /** @brief H4 */
      [0] = 0xFFFFFFFFU   /** @brief H0 */
    };

    static const uint32_t HASH_CSRx_CSRx_MASK[54] = {
      [1]  = 0xFFFFFFFFU,   /** @brief CSR1 */
      [2]  = 0xFFFFFFFFU,   /** @brief CSR2 */
      [3]  = 0xFFFFFFFFU,   /** @brief CSR3 */
      [4]  = 0xFFFFFFFFU,   /** @brief CSR4 */
      [5]  = 0xFFFFFFFFU,   /** @brief CSR5 */
      [6]  = 0xFFFFFFFFU,   /** @brief CSR6 */
      [7]  = 0xFFFFFFFFU,   /** @brief CSR7 */
      [8]  = 0xFFFFFFFFU,   /** @brief CSR8 */
      [9]  = 0xFFFFFFFFU,   /** @brief CSR9 */
      [10] = 0xFFFFFFFFU,   /** @brief CSR10 */
      [11] = 0xFFFFFFFFU,   /** @brief CSR11 */
      [12] = 0xFFFFFFFFU,   /** @brief CSR12 */
      [13] = 0xFFFFFFFFU,   /** @brief CSR13 */
      [14] = 0xFFFFFFFFU,   /** @brief CSR14 */
      [15] = 0xFFFFFFFFU,   /** @brief CSR15 */
      [16] = 0xFFFFFFFFU,   /** @brief CSR16 */
      [17] = 0xFFFFFFFFU,   /** @brief CSR17 */
      [18] = 0xFFFFFFFFU,   /** @brief CSR18 */
      [19] = 0xFFFFFFFFU,   /** @brief CSR19 */
      [20] = 0xFFFFFFFFU,   /** @brief CSR20 */
      [21] = 0xFFFFFFFFU,   /** @brief CSR21 */
      [22] = 0xFFFFFFFFU,   /** @brief CSR22 */
      [23] = 0xFFFFFFFFU,   /** @brief CSR23 */
      [24] = 0xFFFFFFFFU,   /** @brief CSR24 */
      [25] = 0xFFFFFFFFU,   /** @brief CSR25 */
      [26] = 0xFFFFFFFFU,   /** @brief CSR26 */
      [27] = 0xFFFFFFFFU,   /** @brief CSR27 */
      [28] = 0xFFFFFFFFU,   /** @brief CSR28 */
      [29] = 0xFFFFFFFFU,   /** @brief CSR29 */
      [30] = 0xFFFFFFFFU,   /** @brief CSR30 */
      [31] = 0xFFFFFFFFU,   /** @brief CSR31 */
      [32] = 0xFFFFFFFFU,   /** @brief CSR32 */
      [33] = 0xFFFFFFFFU,   /** @brief CSR33 */
      [34] = 0xFFFFFFFFU,   /** @brief CSR34 */
      [35] = 0xFFFFFFFFU,   /** @brief CSR35 */
      [36] = 0xFFFFFFFFU,   /** @brief CSR36 */
      [37] = 0xFFFFFFFFU,   /** @brief CSR37 */
      [38] = 0xFFFFFFFFU,   /** @brief CSR38 */
      [39] = 0xFFFFFFFFU,   /** @brief CSR39 */
      [40] = 0xFFFFFFFFU,   /** @brief CSR40 */
      [41] = 0xFFFFFFFFU,   /** @brief CSR41 */
      [42] = 0xFFFFFFFFU,   /** @brief CSR42 */
      [43] = 0xFFFFFFFFU,   /** @brief CSR43 */
      [44] = 0xFFFFFFFFU,   /** @brief CSR44 */
      [45] = 0xFFFFFFFFU,   /** @brief CSR45 */
      [46] = 0xFFFFFFFFU,   /** @brief CSR46 */
      [47] = 0xFFFFFFFFU,   /** @brief CSR47 */
      [48] = 0xFFFFFFFFU,   /** @brief CSR48 */
      [49] = 0xFFFFFFFFU,   /** @brief CSR49 */
      [50] = 0xFFFFFFFFU,   /** @brief CSR50 */
      [51] = 0xFFFFFFFFU,   /** @brief CSR51 */
      [52] = 0xFFFFFFFFU,   /** @brief CSR52 */
      [53] = 0xFFFFFFFFU,   /** @brief CSR53 */
      [0]  = 0xFFFFFFFFU   /** @brief CSR0 */
    };

    static const uint32_t HASH_HASH_HRx_Hx_MASK[8] = {
      [1] = 0xFFFFFFFFU,   /** @brief H1 */
      [2] = 0xFFFFFFFFU,   /** @brief H2 */
      [3] = 0xFFFFFFFFU,   /** @brief H3 */
      [4] = 0xFFFFFFFFU,   /** @brief H4 */
      [5] = 0xFFFFFFFFU,   /** @brief H5 */
      [6] = 0xFFFFFFFFU,   /** @brief H6 */
      [7] = 0xFFFFFFFFU,   /** @brief H7 */
      [0] = 0xFFFFFFFFU   /** @brief H0 */
    };

    /**********************************************************************************************
     * @section CRYP Register Definitions
     **********************************************************************************************/

    /**** @subsection CRYP Register Pointer Definitions ****/

    static RW_ uint32_t* const CRYP_CR_PTR    = (RW_ uint32_t*)0x48021000U;   /** @brief Control register */
    static RO_ uint32_t* const CRYP_SR_PTR    = (RO_ uint32_t*)0x48021004U;   /** @brief Status register */
    static RW_ uint32_t* const CRYP_DIN_PTR   = (RW_ uint32_t*)0x48021008U;   /** @brief Data input register */
    static RO_ uint32_t* const CRYP_DOUT_PTR  = (RO_ uint32_t*)0x4802100CU;   /** @brief Data output register */
    static RW_ uint32_t* const CRYP_DMACR_PTR = (RW_ uint32_t*)0x48021010U;   /** @brief DMA control register */
    static RW_ uint32_t* const CRYP_IMSCR_PTR = (RW_ uint32_t*)0x48021014U;   /** @brief Interrupt mask set/clear register */
    static RO_ uint32_t* const CRYP_RISR_PTR  = (RO_ uint32_t*)0x48021018U;   /** @brief Raw interrupt status register */
    static RO_ uint32_t* const CRYP_MISR_PTR  = (RO_ uint32_t*)0x4802101CU;   /** @brief Masked interrupt status register */

    static RW_ uint32_t* const CRYP_KxLR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x48021028U,   /** @brief Key registers */
      [2] = (RW_ uint32_t*)0x48021030U,   /** @brief Key registers */
      [3] = (RW_ uint32_t*)0x48021038U,   /** @brief Key registers */
      [0] = (RW_ uint32_t*)0x48021020U   /** @brief Key registers */
    };

    static RW_ uint32_t* const CRYP_KxRR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x4802102CU,   /** @brief Key registers */
      [2] = (RW_ uint32_t*)0x48021034U,   /** @brief Key registers */
      [3] = (RW_ uint32_t*)0x4802103CU,   /** @brief Key registers */
      [0] = (RW_ uint32_t*)0x48021024U   /** @brief Key registers */
    };

    static RW_ uint32_t* const CRYP_IVxLR_PTR[2] = {
      [1] = (RW_ uint32_t*)0x48021048U,   /** @brief Initialization vector registers */
      [0] = (RW_ uint32_t*)0x48021040U   /** @brief Initialization vector registers */
    };

    static RW_ uint32_t* const CRYP_IVxRR_PTR[2] = {
      [1] = (RW_ uint32_t*)0x4802104CU,   /** @brief Initialization vector registers */
      [0] = (RW_ uint32_t*)0x48021044U   /** @brief Initialization vector registers */
    };

    static RW_ uint32_t* const CRYP_CSGCMCCMxR_PTR[8] = {
      [1] = (RW_ uint32_t*)0x48021054U,   /** @brief Context swap register */
      [2] = (RW_ uint32_t*)0x48021058U,   /** @brief Context swap register */
      [3] = (RW_ uint32_t*)0x4802105CU,   /** @brief Context swap register */
      [4] = (RW_ uint32_t*)0x48021060U,   /** @brief Context swap register */
      [5] = (RW_ uint32_t*)0x48021064U,   /** @brief Context swap register */
      [6] = (RW_ uint32_t*)0x48021068U,   /** @brief Context swap register */
      [7] = (RW_ uint32_t*)0x4802106CU,   /** @brief Context swap register */
      [0] = (RW_ uint32_t*)0x48021050U   /** @brief Context swap register */
    };

    static RW_ uint32_t* const CRYP_CSGCMxR_PTR[8] = {
      [1] = (RW_ uint32_t*)0x48021074U,   /** @brief Context swap register */
      [2] = (RW_ uint32_t*)0x48021078U,   /** @brief Context swap register */
      [3] = (RW_ uint32_t*)0x4802107CU,   /** @brief Context swap register */
      [4] = (RW_ uint32_t*)0x48021080U,   /** @brief Context swap register */
      [5] = (RW_ uint32_t*)0x48021084U,   /** @brief Context swap register */
      [6] = (RW_ uint32_t*)0x48021088U,   /** @brief Context swap register */
      [7] = (RW_ uint32_t*)0x4802108CU,   /** @brief Context swap register */
      [0] = (RW_ uint32_t*)0x48021070U   /** @brief Context swap register */
    };

    /**** @subsection CRYP Register Reset Value Definitions ****/

    static const uint32_t CRYP_CR_RST    = 0x00000000U;   /** @brief Control register */
    static const uint32_t CRYP_SR_RST    = 0x00000003U;   /** @brief Status register */
    static const uint32_t CRYP_DIN_RST   = 0x00000000U;   /** @brief Data input register */
    static const uint32_t CRYP_DOUT_RST  = 0x00000000U;   /** @brief Data output register */
    static const uint32_t CRYP_DMACR_RST = 0x00000000U;   /** @brief DMA control register */
    static const uint32_t CRYP_IMSCR_RST = 0x00000000U;   /** @brief Interrupt mask set/clear register */
    static const uint32_t CRYP_RISR_RST  = 0x00000001U;   /** @brief Raw interrupt status register */
    static const uint32_t CRYP_MISR_RST  = 0x00000000U;   /** @brief Masked interrupt status register */

    static const uint32_t CRYP_KxLR_RST[4] = {
      [1] = 0x00000000U,   /** @brief Key registers */
      [2] = 0x00000000U,   /** @brief Key registers */
      [3] = 0x00000000U,   /** @brief Key registers */
      [0] = 0x00000000U   /** @brief Key registers */
    };

    static const uint32_t CRYP_KxRR_RST[4] = {
      [1] = 0x00000000U,   /** @brief Key registers */
      [2] = 0x00000000U,   /** @brief Key registers */
      [3] = 0x00000000U,   /** @brief Key registers */
      [0] = 0x00000000U   /** @brief Key registers */
    };

    static const uint32_t CRYP_IVxLR_RST[2] = {
      [1] = 0x00000000U,   /** @brief Initialization vector registers */
      [0] = 0x00000000U   /** @brief Initialization vector registers */
    };

    static const uint32_t CRYP_IVxRR_RST[2] = {
      [1] = 0x00000000U,   /** @brief Initialization vector registers */
      [0] = 0x00000000U   /** @brief Initialization vector registers */
    };

    static const uint32_t CRYP_CSGCMCCMxR_RST[8] = {
      [1] = 0x00000000U,   /** @brief Context swap register */
      [2] = 0x00000000U,   /** @brief Context swap register */
      [3] = 0x00000000U,   /** @brief Context swap register */
      [4] = 0x00000000U,   /** @brief Context swap register */
      [5] = 0x00000000U,   /** @brief Context swap register */
      [6] = 0x00000000U,   /** @brief Context swap register */
      [7] = 0x00000000U,   /** @brief Context swap register */
      [0] = 0x00000000U   /** @brief Context swap register */
    };

    static const uint32_t CRYP_CSGCMxR_RST[8] = {
      [1] = 0x00000000U,   /** @brief Context swap register */
      [2] = 0x00000000U,   /** @brief Context swap register */
      [3] = 0x00000000U,   /** @brief Context swap register */
      [4] = 0x00000000U,   /** @brief Context swap register */
      [5] = 0x00000000U,   /** @brief Context swap register */
      [6] = 0x00000000U,   /** @brief Context swap register */
      [7] = 0x00000000U,   /** @brief Context swap register */
      [0] = 0x00000000U   /** @brief Context swap register */
    };

    /**** @subsection CRYP Register Value Type Definitions ****/

    typedef uint32_t CRYP_CR_vt;           /** @brief CRYP_CR register value type. */
    typedef uint32_t CRYP_SR_vt;           /** @brief CRYP_SR register value type. */
    typedef uint32_t CRYP_DIN_vt;          /** @brief CRYP_DIN register value type. */
    typedef uint32_t CRYP_DOUT_vt;         /** @brief CRYP_DOUT register value type. */
    typedef uint32_t CRYP_DMACR_vt;        /** @brief CRYP_DMACR register value type. */
    typedef uint32_t CRYP_IMSCR_vt;        /** @brief CRYP_IMSCR register value type. */
    typedef uint32_t CRYP_RISR_vt;         /** @brief CRYP_RISR register value type. */
    typedef uint32_t CRYP_MISR_vt;         /** @brief CRYP_MISR register value type. */
    typedef uint32_t CRYP_KxLR_vt;         /** @brief CRYP_KxLR register value type. */
    typedef uint32_t CRYP_KxRR_vt;         /** @brief CRYP_KxRR register value type. */
    typedef uint32_t CRYP_IVxLR_vt;        /** @brief CRYP_IVxLR register value type. */
    typedef uint32_t CRYP_IVxRR_vt;        /** @brief CRYP_IVxRR register value type. */
    typedef uint32_t CRYP_CSGCMCCMxR_vt;   /** @brief CRYP_CSGCMCCMxR register value type. */
    typedef uint32_t CRYP_CSGCMxR_vt;      /** @brief CRYP_CSGCMxR register value type. */

    /**** @subsection CRYP Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* CRYP_CR_pt;           /** @brief CRYP_CR pointer register pointer type. */
    typedef RO_ uint32_t* CRYP_SR_pt;           /** @brief CRYP_SR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_DIN_pt;          /** @brief CRYP_DIN pointer register pointer type. */
    typedef RO_ uint32_t* CRYP_DOUT_pt;         /** @brief CRYP_DOUT pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_DMACR_pt;        /** @brief CRYP_DMACR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_IMSCR_pt;        /** @brief CRYP_IMSCR pointer register pointer type. */
    typedef RO_ uint32_t* CRYP_RISR_pt;         /** @brief CRYP_RISR pointer register pointer type. */
    typedef RO_ uint32_t* CRYP_MISR_pt;         /** @brief CRYP_MISR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_KxLR_pt;         /** @brief CRYP_KxLR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_KxRR_pt;         /** @brief CRYP_KxRR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_IVxLR_pt;        /** @brief CRYP_IVxLR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_IVxRR_pt;        /** @brief CRYP_IVxRR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_CSGCMCCMxR_pt;   /** @brief CRYP_CSGCMCCMxR pointer register pointer type. */
    typedef RW_ uint32_t* CRYP_CSGCMxR_pt;      /** @brief CRYP_CSGCMxR pointer register pointer type. */

    /**** @subsection CRYP Field Mask Definitions ****/

    static const uint32_t CRYP_CR_GCM_CCMPH_MASK = 0x00030000U;   /** @brief GCM_CCMPH */
    static const uint32_t CRYP_SR_IFEM_MASK      = 0x00000001U;   /** @brief Input FIFO empty */
    static const uint32_t CRYP_DIN_DATAIN_MASK   = 0xFFFFFFFFU;   /** @brief Data input */
    static const uint32_t CRYP_DOUT_DATAOUT_MASK = 0xFFFFFFFFU;   /** @brief Data output */
    static const uint32_t CRYP_DMACR_DIEN_MASK   = 0x00000001U;   /** @brief DMA input enable */
    static const uint32_t CRYP_IMSCR_INIM_MASK   = 0x00000001U;   /** @brief Input FIFO service interrupt mask */
    static const uint32_t CRYP_RISR_INRIS_MASK   = 0x00000001U;   /** @brief Input FIFO service raw interrupt status */
    static const uint32_t CRYP_MISR_INMIS_MASK   = 0x00000001U;   /** @brief Input FIFO service masked interrupt status */

    static const uint32_t CRYP_CSGCMCCMxR_CSGCMCCMxR_MASK[8] = {
      [1] = 0xFFFFFFFFU,   /** @brief CSGCMCCM1R */
      [2] = 0xFFFFFFFFU,   /** @brief CSGCMCCM2R */
      [3] = 0xFFFFFFFFU,   /** @brief CSGCMCCM3R */
      [4] = 0xFFFFFFFFU,   /** @brief CSGCMCCM4R */
      [5] = 0xFFFFFFFFU,   /** @brief CSGCMCCM5R */
      [6] = 0xFFFFFFFFU,   /** @brief CSGCMCCM6R */
      [7] = 0xFFFFFFFFU,   /** @brief CSGCMCCM7R */
      [0] = 0xFFFFFFFFU   /** @brief CSGCMCCM0R */
    };

    static const uint32_t CRYP_CSGCMxR_CSGCMxR_MASK[8] = {
      [1] = 0xFFFFFFFFU,   /** @brief CSGCM1R */
      [2] = 0xFFFFFFFFU,   /** @brief CSGCM2R */
      [3] = 0xFFFFFFFFU,   /** @brief CSGCM3R */
      [4] = 0xFFFFFFFFU,   /** @brief CSGCM4R */
      [5] = 0xFFFFFFFFU,   /** @brief CSGCM5R */
      [6] = 0xFFFFFFFFU,   /** @brief CSGCM6R */
      [7] = 0xFFFFFFFFU,   /** @brief CSGCM7R */
      [0] = 0xFFFFFFFFU   /** @brief CSGCM0R */
    };

    static const uint32_t CRYP_KxLR_Bx_MASK[4][192] = {
      [1] = {
        [160] = 0x00000001U,   /** @brief B160 */
        [161] = 0x00000002U,   /** @brief B161 */
        [162] = 0x00000004U,   /** @brief B162 */
        [163] = 0x00000008U,   /** @brief B163 */
        [164] = 0x00000010U,   /** @brief B164 */
        [165] = 0x00000020U,   /** @brief B165 */
        [166] = 0x00000040U,   /** @brief B166 */
        [167] = 0x00000080U,   /** @brief B167 */
        [168] = 0x00000100U,   /** @brief B168 */
        [169] = 0x00000200U,   /** @brief B169 */
        [170] = 0x00000400U,   /** @brief B170 */
        [171] = 0x00000800U,   /** @brief B171 */
        [172] = 0x00001000U,   /** @brief B172 */
        [173] = 0x00002000U,   /** @brief B173 */
        [174] = 0x00004000U,   /** @brief B174 */
        [175] = 0x00008000U,   /** @brief B175 */
        [176] = 0x00010000U,   /** @brief B176 */
        [177] = 0x00020000U,   /** @brief B177 */
        [178] = 0x00040000U,   /** @brief B178 */
        [179] = 0x00080000U,   /** @brief B179 */
        [180] = 0x00100000U,   /** @brief B180 */
        [181] = 0x00200000U,   /** @brief B181 */
        [182] = 0x00400000U,   /** @brief B182 */
        [183] = 0x00800000U,   /** @brief B183 */
        [184] = 0x01000000U,   /** @brief B184 */
        [185] = 0x02000000U,   /** @brief B185 */
        [186] = 0x04000000U,   /** @brief B186 */
        [187] = 0x08000000U,   /** @brief B187 */
        [188] = 0x10000000U,   /** @brief B188 */
        [189] = 0x20000000U,   /** @brief B189 */
        [190] = 0x40000000U,   /** @brief B190 */
        [191] = 0x80000000U   /** @brief B191 */
      },
      [2] = {
        [96]  = 0x00000001U,   /** @brief B96 */
        [97]  = 0x00000002U,   /** @brief B97 */
        [98]  = 0x00000004U,   /** @brief B98 */
        [99]  = 0x00000008U,   /** @brief B99 */
        [100] = 0x00000010U,   /** @brief B100 */
        [101] = 0x00000020U,   /** @brief B101 */
        [102] = 0x00000040U,   /** @brief B102 */
        [103] = 0x00000080U,   /** @brief B103 */
        [104] = 0x00000100U,   /** @brief B104 */
        [105] = 0x00000200U,   /** @brief B105 */
        [106] = 0x00000400U,   /** @brief B106 */
        [107] = 0x00000800U,   /** @brief B107 */
        [108] = 0x00001000U,   /** @brief B108 */
        [109] = 0x00002000U,   /** @brief B109 */
        [110] = 0x00004000U,   /** @brief B110 */
        [111] = 0x00008000U,   /** @brief B111 */
        [112] = 0x00010000U,   /** @brief B112 */
        [113] = 0x00020000U,   /** @brief B113 */
        [114] = 0x00040000U,   /** @brief B114 */
        [115] = 0x00080000U,   /** @brief B115 */
        [116] = 0x00100000U,   /** @brief B116 */
        [117] = 0x00200000U,   /** @brief B117 */
        [118] = 0x00400000U,   /** @brief B118 */
        [119] = 0x00800000U,   /** @brief B119 */
        [120] = 0x01000000U,   /** @brief B120 */
        [121] = 0x02000000U,   /** @brief B121 */
        [122] = 0x04000000U,   /** @brief B122 */
        [123] = 0x08000000U,   /** @brief B123 */
        [124] = 0x10000000U,   /** @brief B124 */
        [125] = 0x20000000U,   /** @brief B125 */
        [126] = 0x40000000U,   /** @brief B126 */
        [127] = 0x80000000U   /** @brief B127 */
      },
      [3] = {
        [32] = 0x00000001U,   /** @brief B32 */
        [33] = 0x00000002U,   /** @brief B33 */
        [34] = 0x00000004U,   /** @brief B34 */
        [35] = 0x00000008U,   /** @brief B35 */
        [36] = 0x00000010U,   /** @brief B36 */
        [37] = 0x00000020U,   /** @brief B37 */
        [38] = 0x00000040U,   /** @brief B38 */
        [39] = 0x00000080U,   /** @brief B39 */
        [40] = 0x00000100U,   /** @brief B40 */
        [41] = 0x00000200U,   /** @brief B41 */
        [42] = 0x00000400U,   /** @brief B42 */
        [43] = 0x00000800U,   /** @brief B43 */
        [44] = 0x00001000U,   /** @brief B44 */
        [45] = 0x00002000U,   /** @brief B45 */
        [46] = 0x00004000U,   /** @brief B46 */
        [47] = 0x00008000U,   /** @brief B47 */
        [48] = 0x00010000U,   /** @brief B48 */
        [49] = 0x00020000U,   /** @brief B49 */
        [50] = 0x00040000U,   /** @brief B50 */
        [51] = 0x00080000U,   /** @brief B51 */
        [52] = 0x00100000U,   /** @brief B52 */
        [53] = 0x00200000U,   /** @brief B53 */
        [54] = 0x00400000U,   /** @brief B54 */
        [55] = 0x00800000U,   /** @brief B55 */
        [56] = 0x01000000U,   /** @brief B56 */
        [57] = 0x02000000U,   /** @brief B57 */
        [58] = 0x04000000U,   /** @brief B58 */
        [59] = 0x08000000U,   /** @brief B59 */
        [60] = 0x10000000U,   /** @brief B60 */
        [61] = 0x20000000U,   /** @brief B61 */
        [62] = 0x40000000U,   /** @brief B62 */
        [63] = 0x80000000U   /** @brief B63 */
      },
      [0] = {
        [5]  = 0x00000002U,   /** @brief B225 */
        [6]  = 0x00000004U,   /** @brief B226 */
        [7]  = 0x00000008U,   /** @brief B227 */
        [8]  = 0x00000010U,   /** @brief B228 */
        [9]  = 0x00000020U,   /** @brief B229 */
        [30] = 0x00000040U,   /** @brief B230 */
        [31] = 0x00000080U,   /** @brief B231 */
        [32] = 0x00000100U,   /** @brief B232 */
        [33] = 0x00000200U,   /** @brief B233 */
        [34] = 0x00000400U,   /** @brief B234 */
        [35] = 0x00000800U,   /** @brief B235 */
        [36] = 0x00001000U,   /** @brief B236 */
        [37] = 0x00002000U,   /** @brief B237 */
        [38] = 0x00004000U,   /** @brief B238 */
        [39] = 0x00008000U,   /** @brief B239 */
        [40] = 0x00010000U,   /** @brief B240 */
        [41] = 0x00020000U,   /** @brief B241 */
        [42] = 0x00040000U,   /** @brief B242 */
        [43] = 0x00080000U,   /** @brief B243 */
        [44] = 0x00100000U,   /** @brief B244 */
        [45] = 0x00200000U,   /** @brief B245 */
        [46] = 0x00400000U,   /** @brief B246 */
        [47] = 0x00800000U,   /** @brief B247 */
        [48] = 0x01000000U,   /** @brief B248 */
        [49] = 0x02000000U,   /** @brief B249 */
        [50] = 0x04000000U,   /** @brief B250 */
        [51] = 0x08000000U,   /** @brief B251 */
        [52] = 0x10000000U,   /** @brief B252 */
        [53] = 0x20000000U,   /** @brief B253 */
        [54] = 0x40000000U,   /** @brief B254 */
        [55] = 0x80000000U,   /** @brief B255 */
        [24] = 0x00000001U   /** @brief B224 */
      }
    };

    static const uint32_t CRYP_KxRR_Bx_MASK[4][224] = {
      [1] = {
        [28] = 0x00000001U,   /** @brief B128 */
        [29] = 0x00000002U,   /** @brief B129 */
        [30] = 0x00000004U,   /** @brief B130 */
        [31] = 0x00000008U,   /** @brief B131 */
        [32] = 0x00000010U,   /** @brief B132 */
        [33] = 0x00000020U,   /** @brief B133 */
        [34] = 0x00000040U,   /** @brief B134 */
        [35] = 0x00000080U,   /** @brief B135 */
        [36] = 0x00000100U,   /** @brief B136 */
        [37] = 0x00000200U,   /** @brief B137 */
        [38] = 0x00000400U,   /** @brief B138 */
        [39] = 0x00000800U,   /** @brief B139 */
        [40] = 0x00001000U,   /** @brief B140 */
        [41] = 0x00002000U,   /** @brief B141 */
        [42] = 0x00004000U,   /** @brief B142 */
        [43] = 0x00008000U,   /** @brief B143 */
        [44] = 0x00010000U,   /** @brief B144 */
        [45] = 0x00020000U,   /** @brief B145 */
        [46] = 0x00040000U,   /** @brief B146 */
        [47] = 0x00080000U,   /** @brief B147 */
        [48] = 0x00100000U,   /** @brief B148 */
        [49] = 0x00200000U,   /** @brief B149 */
        [50] = 0x00400000U,   /** @brief B150 */
        [51] = 0x00800000U,   /** @brief B151 */
        [52] = 0x01000000U,   /** @brief B152 */
        [53] = 0x02000000U,   /** @brief B153 */
        [54] = 0x04000000U,   /** @brief B154 */
        [55] = 0x08000000U,   /** @brief B155 */
        [56] = 0x10000000U,   /** @brief B156 */
        [57] = 0x20000000U,   /** @brief B157 */
        [58] = 0x40000000U,   /** @brief B158 */
        [59] = 0x80000000U   /** @brief B159 */
      },
      [2] = {
        [64] = 0x00000001U,   /** @brief B64 */
        [65] = 0x00000002U,   /** @brief B65 */
        [66] = 0x00000004U,   /** @brief B66 */
        [67] = 0x00000008U,   /** @brief B67 */
        [68] = 0x00000010U,   /** @brief B68 */
        [69] = 0x00000020U,   /** @brief B69 */
        [70] = 0x00000040U,   /** @brief B70 */
        [71] = 0x00000080U,   /** @brief B71 */
        [72] = 0x00000100U,   /** @brief B72 */
        [73] = 0x00000200U,   /** @brief B73 */
        [74] = 0x00000400U,   /** @brief B74 */
        [75] = 0x00000800U,   /** @brief B75 */
        [76] = 0x00001000U,   /** @brief B76 */
        [77] = 0x00002000U,   /** @brief B77 */
        [78] = 0x00004000U,   /** @brief B78 */
        [79] = 0x00008000U,   /** @brief B79 */
        [80] = 0x00010000U,   /** @brief B80 */
        [81] = 0x00020000U,   /** @brief B81 */
        [82] = 0x00040000U,   /** @brief B82 */
        [83] = 0x00080000U,   /** @brief B83 */
        [84] = 0x00100000U,   /** @brief B84 */
        [85] = 0x00200000U,   /** @brief B85 */
        [86] = 0x00400000U,   /** @brief B86 */
        [87] = 0x00800000U,   /** @brief B87 */
        [88] = 0x01000000U,   /** @brief B88 */
        [89] = 0x02000000U,   /** @brief B89 */
        [90] = 0x04000000U,   /** @brief B90 */
        [91] = 0x08000000U,   /** @brief B91 */
        [92] = 0x10000000U,   /** @brief B92 */
        [93] = 0x20000000U,   /** @brief B93 */
        [94] = 0x40000000U,   /** @brief B94 */
        [95] = 0x80000000U   /** @brief B95 */
      },
      [3] = {
        [0]  = 0x00000400U,   /** @brief B10 */
        [2]  = 0x00001000U,   /** @brief B12 */
        [3]  = 0x00002000U,   /** @brief B13 */
        [4]  = 0x00004000U,   /** @brief B14 */
        [5]  = 0x00008000U,   /** @brief B15 */
        [6]  = 0x00010000U,   /** @brief B16 */
        [7]  = 0x00020000U,   /** @brief B17 */
        [8]  = 0x00040000U,   /** @brief B18 */
        [9]  = 0x00000200U,   /** @brief B9 */
        [1]  = 0x00000800U,   /** @brief B11 */
        [20] = 0x00100000U,   /** @brief B20 */
        [21] = 0x00200000U,   /** @brief B21 */
        [22] = 0x00400000U,   /** @brief B22 */
        [23] = 0x00800000U,   /** @brief B23 */
        [24] = 0x01000000U,   /** @brief B24 */
        [25] = 0x02000000U,   /** @brief B25 */
        [26] = 0x04000000U,   /** @brief B26 */
        [27] = 0x08000000U,   /** @brief B27 */
        [28] = 0x10000000U,   /** @brief B28 */
        [29] = 0x20000000U,   /** @brief B29 */
        [30] = 0x40000000U,   /** @brief B30 */
        [31] = 0x80000000U   /** @brief B31 */
      },
      [0] = {
        [3]   = 0x00000002U,   /** @brief B193 */
        [4]   = 0x00000004U,   /** @brief B194 */
        [5]   = 0x00000008U,   /** @brief B195 */
        [6]   = 0x00000010U,   /** @brief B196 */
        [7]   = 0x00000020U,   /** @brief B197 */
        [8]   = 0x00000040U,   /** @brief B198 */
        [9]   = 0x00000080U,   /** @brief B199 */
        [200] = 0x00000100U,   /** @brief B200 */
        [201] = 0x00000200U,   /** @brief B201 */
        [202] = 0x00000400U,   /** @brief B202 */
        [203] = 0x00000800U,   /** @brief B203 */
        [204] = 0x00001000U,   /** @brief B204 */
        [205] = 0x00002000U,   /** @brief B205 */
        [206] = 0x00004000U,   /** @brief B206 */
        [207] = 0x00008000U,   /** @brief B207 */
        [208] = 0x00010000U,   /** @brief B208 */
        [209] = 0x00020000U,   /** @brief B209 */
        [210] = 0x00040000U,   /** @brief B210 */
        [211] = 0x00080000U,   /** @brief B211 */
        [212] = 0x00100000U,   /** @brief B212 */
        [213] = 0x00200000U,   /** @brief B213 */
        [214] = 0x00400000U,   /** @brief B214 */
        [215] = 0x00800000U,   /** @brief B215 */
        [216] = 0x01000000U,   /** @brief B216 */
        [217] = 0x02000000U,   /** @brief B217 */
        [218] = 0x04000000U,   /** @brief B218 */
        [219] = 0x08000000U,   /** @brief B219 */
        [220] = 0x10000000U,   /** @brief B220 */
        [221] = 0x20000000U,   /** @brief B221 */
        [222] = 0x40000000U,   /** @brief B222 */
        [223] = 0x80000000U,   /** @brief B223 */
        [192] = 0x00000001U   /** @brief B192 */
      }
    };

    static const uint32_t CRYP_IVxLR_IVx_MASK[2][96] = {
      [1] = {
        [95] = 0x00000001U,   /** @brief IV95 */
        [94] = 0x00000002U,   /** @brief IV94 */
        [93] = 0x00000004U,   /** @brief IV93 */
        [92] = 0x00000008U,   /** @brief IV92 */
        [91] = 0x00000010U,   /** @brief IV91 */
        [90] = 0x00000020U,   /** @brief IV90 */
        [89] = 0x00000040U,   /** @brief IV89 */
        [88] = 0x00000080U,   /** @brief IV88 */
        [87] = 0x00000100U,   /** @brief IV87 */
        [86] = 0x00000200U,   /** @brief IV86 */
        [85] = 0x00000400U,   /** @brief IV85 */
        [84] = 0x00000800U,   /** @brief IV84 */
        [83] = 0x00001000U,   /** @brief IV83 */
        [82] = 0x00002000U,   /** @brief IV82 */
        [81] = 0x00004000U,   /** @brief IV81 */
        [80] = 0x00008000U,   /** @brief IV80 */
        [79] = 0x00010000U,   /** @brief IV79 */
        [78] = 0x00020000U,   /** @brief IV78 */
        [77] = 0x00040000U,   /** @brief IV77 */
        [76] = 0x00080000U,   /** @brief IV76 */
        [75] = 0x00100000U,   /** @brief IV75 */
        [74] = 0x00200000U,   /** @brief IV74 */
        [73] = 0x00400000U,   /** @brief IV73 */
        [72] = 0x00800000U,   /** @brief IV72 */
        [71] = 0x01000000U,   /** @brief IV71 */
        [70] = 0x02000000U,   /** @brief IV70 */
        [69] = 0x04000000U,   /** @brief IV69 */
        [68] = 0x08000000U,   /** @brief IV68 */
        [67] = 0x10000000U,   /** @brief IV67 */
        [66] = 0x20000000U,   /** @brief IV66 */
        [65] = 0x40000000U,   /** @brief IV65 */
        [64] = 0x80000000U   /** @brief IV64 */
      },
      [0] = {
        [29] = 0x00000004U,   /** @brief IV29 */
        [28] = 0x00000008U,   /** @brief IV28 */
        [27] = 0x00000010U,   /** @brief IV27 */
        [26] = 0x00000020U,   /** @brief IV26 */
        [25] = 0x00000040U,   /** @brief IV25 */
        [24] = 0x00000080U,   /** @brief IV24 */
        [23] = 0x00000100U,   /** @brief IV23 */
        [22] = 0x00000200U,   /** @brief IV22 */
        [21] = 0x00000400U,   /** @brief IV21 */
        [20] = 0x00000800U,   /** @brief IV20 */
        [19] = 0x00001000U,   /** @brief IV19 */
        [18] = 0x00002000U,   /** @brief IV18 */
        [17] = 0x00004000U,   /** @brief IV17 */
        [16] = 0x00008000U,   /** @brief IV16 */
        [15] = 0x00010000U,   /** @brief IV15 */
        [14] = 0x00020000U,   /** @brief IV14 */
        [13] = 0x00040000U,   /** @brief IV13 */
        [12] = 0x00080000U,   /** @brief IV12 */
        [11] = 0x00100000U,   /** @brief IV11 */
        [10] = 0x00200000U,   /** @brief IV10 */
        [9]  = 0x00400000U,   /** @brief IV9 */
        [8]  = 0x00800000U,   /** @brief IV8 */
        [7]  = 0x01000000U,   /** @brief IV7 */
        [6]  = 0x02000000U,   /** @brief IV6 */
        [5]  = 0x04000000U,   /** @brief IV5 */
        [4]  = 0x08000000U,   /** @brief IV4 */
        [2]  = 0x20000000U,   /** @brief IV2 */
        [1]  = 0x40000000U,   /** @brief IV1 */
        [0]  = 0x80000000U,   /** @brief IV0 */
        [3]  = 0x10000000U   /** @brief IV3 */
      }
    };

    static const uint32_t CRYP_IVxRR_IVx_MASK[2][128] = {
      [1] = {
        [127] = 0x00000001U,   /** @brief IV127 */
        [126] = 0x00000002U,   /** @brief IV126 */
        [125] = 0x00000004U,   /** @brief IV125 */
        [124] = 0x00000008U,   /** @brief IV124 */
        [123] = 0x00000010U,   /** @brief IV123 */
        [122] = 0x00000020U,   /** @brief IV122 */
        [121] = 0x00000040U,   /** @brief IV121 */
        [120] = 0x00000080U,   /** @brief IV120 */
        [119] = 0x00000100U,   /** @brief IV119 */
        [118] = 0x00000200U,   /** @brief IV118 */
        [117] = 0x00000400U,   /** @brief IV117 */
        [116] = 0x00000800U,   /** @brief IV116 */
        [115] = 0x00001000U,   /** @brief IV115 */
        [114] = 0x00002000U,   /** @brief IV114 */
        [113] = 0x00004000U,   /** @brief IV113 */
        [112] = 0x00008000U,   /** @brief IV112 */
        [111] = 0x00010000U,   /** @brief IV111 */
        [110] = 0x00020000U,   /** @brief IV110 */
        [109] = 0x00040000U,   /** @brief IV109 */
        [108] = 0x00080000U,   /** @brief IV108 */
        [107] = 0x00100000U,   /** @brief IV107 */
        [106] = 0x00200000U,   /** @brief IV106 */
        [105] = 0x00400000U,   /** @brief IV105 */
        [104] = 0x00800000U,   /** @brief IV104 */
        [103] = 0x01000000U,   /** @brief IV103 */
        [102] = 0x02000000U,   /** @brief IV102 */
        [101] = 0x04000000U,   /** @brief IV101 */
        [100] = 0x08000000U,   /** @brief IV100 */
        [99]  = 0x10000000U,   /** @brief IV99 */
        [98]  = 0x20000000U,   /** @brief IV98 */
        [97]  = 0x40000000U,   /** @brief IV97 */
        [96]  = 0x80000000U   /** @brief IV96 */
      },
      [0] = {
        [2]  = 0x00000002U,   /** @brief IV62 */
        [1]  = 0x00000004U,   /** @brief IV61 */
        [0]  = 0x00000008U,   /** @brief IV60 */
        [59] = 0x00000010U,   /** @brief IV59 */
        [58] = 0x00000020U,   /** @brief IV58 */
        [57] = 0x00000040U,   /** @brief IV57 */
        [56] = 0x00000080U,   /** @brief IV56 */
        [55] = 0x00000100U,   /** @brief IV55 */
        [54] = 0x00000200U,   /** @brief IV54 */
        [53] = 0x00000400U,   /** @brief IV53 */
        [52] = 0x00000800U,   /** @brief IV52 */
        [51] = 0x00001000U,   /** @brief IV51 */
        [50] = 0x00002000U,   /** @brief IV50 */
        [49] = 0x00004000U,   /** @brief IV49 */
        [48] = 0x00008000U,   /** @brief IV48 */
        [47] = 0x00010000U,   /** @brief IV47 */
        [46] = 0x00020000U,   /** @brief IV46 */
        [45] = 0x00040000U,   /** @brief IV45 */
        [44] = 0x00080000U,   /** @brief IV44 */
        [43] = 0x00100000U,   /** @brief IV43 */
        [42] = 0x00200000U,   /** @brief IV42 */
        [41] = 0x00400000U,   /** @brief IV41 */
        [40] = 0x00800000U,   /** @brief IV40 */
        [39] = 0x01000000U,   /** @brief IV39 */
        [38] = 0x02000000U,   /** @brief IV38 */
        [37] = 0x04000000U,   /** @brief IV37 */
        [36] = 0x08000000U,   /** @brief IV36 */
        [35] = 0x10000000U,   /** @brief IV35 */
        [34] = 0x20000000U,   /** @brief IV34 */
        [33] = 0x40000000U,   /** @brief IV33 */
        [32] = 0x80000000U,   /** @brief IV32 */
        [63] = 0x00000001U   /** @brief IV63 */
      }
    };

    /**********************************************************************************************
     * @section DCMI Register Definitions
     **********************************************************************************************/

    /**** @subsection DCMI Register Pointer Definitions ****/

    static RW_ uint32_t* const DCMI_CR_PTR     = (RW_ uint32_t*)0x48020000U;   /** @brief Control register 1 */
    static RO_ uint32_t* const DCMI_SR_PTR     = (RO_ uint32_t*)0x48020004U;   /** @brief Status register */
    static RO_ uint32_t* const DCMI_RIS_PTR    = (RO_ uint32_t*)0x48020008U;   /** @brief Raw interrupt status register */
    static RW_ uint32_t* const DCMI_IER_PTR    = (RW_ uint32_t*)0x4802000CU;   /** @brief Interrupt enable register */
    static RO_ uint32_t* const DCMI_MIS_PTR    = (RO_ uint32_t*)0x48020010U;   /** @brief Masked interrupt status register */
    static RW_ uint32_t* const DCMI_ICR_PTR    = (RW_ uint32_t*)0x48020014U;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const DCMI_ESCR_PTR   = (RW_ uint32_t*)0x48020018U;   /** @brief Embedded synchronization code register */
    static RW_ uint32_t* const DCMI_ESUR_PTR   = (RW_ uint32_t*)0x4802001CU;   /** @brief Embedded synchronization unmask register */
    static RW_ uint32_t* const DCMI_CWSTRT_PTR = (RW_ uint32_t*)0x48020020U;   /** @brief Crop window start */
    static RW_ uint32_t* const DCMI_CWSIZE_PTR = (RW_ uint32_t*)0x48020024U;   /** @brief Crop window size */
    static RO_ uint32_t* const DCMI_DR_PTR     = (RO_ uint32_t*)0x48020028U;   /** @brief Data register */

    /**** @subsection DCMI Register Reset Value Definitions ****/

    static const uint32_t DCMI_CR_RST     = 0x00000000U;   /** @brief Control register 1 */
    static const uint32_t DCMI_SR_RST     = 0x00000000U;   /** @brief Status register */
    static const uint32_t DCMI_RIS_RST    = 0x00000000U;   /** @brief Raw interrupt status register */
    static const uint32_t DCMI_IER_RST    = 0x00000000U;   /** @brief Interrupt enable register */
    static const uint32_t DCMI_MIS_RST    = 0x00000000U;   /** @brief Masked interrupt status register */
    static const uint32_t DCMI_ICR_RST    = 0x00000000U;   /** @brief Interrupt clear register */
    static const uint32_t DCMI_ESCR_RST   = 0x00000000U;   /** @brief Embedded synchronization code register */
    static const uint32_t DCMI_ESUR_RST   = 0x00000000U;   /** @brief Embedded synchronization unmask register */
    static const uint32_t DCMI_CWSTRT_RST = 0x00000000U;   /** @brief Crop window start */
    static const uint32_t DCMI_CWSIZE_RST = 0x00000000U;   /** @brief Crop window size */
    static const uint32_t DCMI_DR_RST     = 0x00000000U;   /** @brief Data register */

    /**** @subsection DCMI Register Value Type Definitions ****/

    typedef uint32_t DCMI_CR_vt;       /** @brief DCMI_CR register value type. */
    typedef uint32_t DCMI_SR_vt;       /** @brief DCMI_SR register value type. */
    typedef uint32_t DCMI_RIS_vt;      /** @brief DCMI_RIS register value type. */
    typedef uint32_t DCMI_IER_vt;      /** @brief DCMI_IER register value type. */
    typedef uint32_t DCMI_MIS_vt;      /** @brief DCMI_MIS register value type. */
    typedef uint32_t DCMI_ICR_vt;      /** @brief DCMI_ICR register value type. */
    typedef uint32_t DCMI_ESCR_vt;     /** @brief DCMI_ESCR register value type. */
    typedef uint32_t DCMI_ESUR_vt;     /** @brief DCMI_ESUR register value type. */
    typedef uint32_t DCMI_CWSTRT_vt;   /** @brief DCMI_CWSTRT register value type. */
    typedef uint32_t DCMI_CWSIZE_vt;   /** @brief DCMI_CWSIZE register value type. */
    typedef uint32_t DCMI_DR_vt;       /** @brief DCMI_DR register value type. */

    /**** @subsection DCMI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* DCMI_CR_pt;       /** @brief DCMI_CR pointer register pointer type. */
    typedef RO_ uint32_t* DCMI_SR_pt;       /** @brief DCMI_SR pointer register pointer type. */
    typedef RO_ uint32_t* DCMI_RIS_pt;      /** @brief DCMI_RIS pointer register pointer type. */
    typedef RW_ uint32_t* DCMI_IER_pt;      /** @brief DCMI_IER pointer register pointer type. */
    typedef RO_ uint32_t* DCMI_MIS_pt;      /** @brief DCMI_MIS pointer register pointer type. */
    typedef RW_ uint32_t* DCMI_ICR_pt;      /** @brief DCMI_ICR pointer register pointer type. */
    typedef RW_ uint32_t* DCMI_ESCR_pt;     /** @brief DCMI_ESCR pointer register pointer type. */
    typedef RW_ uint32_t* DCMI_ESUR_pt;     /** @brief DCMI_ESUR pointer register pointer type. */
    typedef RW_ uint32_t* DCMI_CWSTRT_pt;   /** @brief DCMI_CWSTRT pointer register pointer type. */
    typedef RW_ uint32_t* DCMI_CWSIZE_pt;   /** @brief DCMI_CWSIZE pointer register pointer type. */
    typedef RO_ uint32_t* DCMI_DR_pt;       /** @brief DCMI_DR pointer register pointer type. */

    /**** @subsection DCMI Field Mask Definitions ****/

    static const uint32_t DCMI_CR_CAPTURE_MASK     = 0x00000001U;   /** @brief Capture enable */
    static const uint32_t DCMI_SR_HSYNC_MASK       = 0x00000001U;   /** @brief HSYNC */
    static const uint32_t DCMI_RIS_FRAME_RIS_MASK  = 0x00000001U;   /** @brief Capture complete raw interrupt status */
    static const uint32_t DCMI_IER_FRAME_IE_MASK   = 0x00000001U;   /** @brief Capture complete interrupt enable */
    static const uint32_t DCMI_MIS_FRAME_MIS_MASK  = 0x00000001U;   /** @brief Capture complete masked interrupt status */
    static const uint32_t DCMI_ICR_FRAME_ISC_MASK  = 0x00000001U;   /** @brief Capture complete interrupt status clear */
    static const uint32_t DCMI_ESCR_FSC_MASK       = 0x000000FFU;   /** @brief Frame start delimiter code */
    static const uint32_t DCMI_ESUR_FSU_MASK       = 0x000000FFU;   /** @brief Frame start delimiter unmask */
    static const uint32_t DCMI_CWSTRT_HOFFCNT_MASK = 0x00003FFFU;   /** @brief Horizontal offset count */
    static const uint32_t DCMI_CWSIZE_CAPCNT_MASK  = 0x00003FFFU;   /** @brief Capture count */

    static const uint32_t DCMI_DR_BYTEx_MASK[4] = {
      [2] = 0x00FF0000U,   /** @brief Data byte 2 */
      [1] = 0x0000FF00U,   /** @brief Data byte 1 */
      [0] = 0x000000FFU,   /** @brief Data byte 0 */
      [3] = 0xFF000000U   /** @brief Data byte 3 */
    };

    /**********************************************************************************************
     * @section OTG_HS_GLOBAL Register Definitions
     **********************************************************************************************/

    /**** @subsection OTG_HS_GLOBAL Register Pointer Definitions ****/

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080000U,   /** @brief OTG_HS control and status register */
      [1] = (RW_ uint32_t*)0x40040000U   /** @brief OTG_HS control and status register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GOTGINT_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080004U,   /** @brief OTG_HS interrupt register */
      [1] = (RW_ uint32_t*)0x40040004U   /** @brief OTG_HS interrupt register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080008U,   /** @brief OTG_HS AHB configuration register */
      [1] = (RW_ uint32_t*)0x40040008U   /** @brief OTG_HS AHB configuration register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4008000CU,   /** @brief OTG_HS USB configuration register */
      [1] = (RW_ uint32_t*)0x4004000CU   /** @brief OTG_HS USB configuration register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080010U,   /** @brief OTG_HS reset register */
      [1] = (RW_ uint32_t*)0x40040010U   /** @brief OTG_HS reset register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080014U,   /** @brief OTG_HS core interrupt register */
      [1] = (RW_ uint32_t*)0x40040014U   /** @brief OTG_HS core interrupt register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080018U,   /** @brief OTG_HS interrupt mask register */
      [1] = (RW_ uint32_t*)0x40040018U   /** @brief OTG_HS interrupt mask register */
    };

    static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4008001CU,   /** @brief OTG_HS receive status debug read register (host mode) */
      [1] = (RO_ uint32_t*)0x4004001CU   /** @brief OTG_HS receive status debug read register (host mode) */
    };

    static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40080020U,   /** @brief OTG_HS status read and pop register (host mode) */
      [1] = (RO_ uint32_t*)0x40040020U   /** @brief OTG_HS status read and pop register (host mode) */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080024U,   /** @brief OTG_HS receive FIFO size register */
      [1] = (RW_ uint32_t*)0x40040024U   /** @brief OTG_HS receive FIFO size register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
      [1] = (RW_ uint32_t*)0x40040028U   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080028U,   /** @brief Endpoint 0 transmit FIFO size (peripheral mode) */
      [1] = (RW_ uint32_t*)0x40040028U   /** @brief Endpoint 0 transmit FIFO size (peripheral mode) */
    };

    static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4008002CU,   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
      [1] = (RO_ uint32_t*)0x4004002CU   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GCCFG_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080038U,   /** @brief OTG_HS general core configuration register */
      [1] = (RW_ uint32_t*)0x40040038U   /** @brief OTG_HS general core configuration register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_CID_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4008003CU,   /** @brief OTG_HS core ID register */
      [1] = (RW_ uint32_t*)0x4004003CU   /** @brief OTG_HS core ID register */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080100U,   /** @brief OTG_HS host periodic transmit FIFO size register */
      [1] = (RW_ uint32_t*)0x40040100U   /** @brief OTG_HS host periodic transmit FIFO size register */
    };

    static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4008001CU,   /** @brief OTG_HS receive status debug read register (peripheral mode mode) */
      [1] = (RO_ uint32_t*)0x4004001CU   /** @brief OTG_HS receive status debug read register (peripheral mode mode) */
    };

    static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40080020U,   /** @brief OTG_HS status read and pop register (peripheral mode) */
      [1] = (RO_ uint32_t*)0x40040020U   /** @brief OTG_HS status read and pop register (peripheral mode) */
    };

    static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080054U,   /** @brief OTG core LPM configuration register */
      [1] = (RW_ uint32_t*)0x40040054U   /** @brief OTG core LPM configuration register */
    };

    /**** @subsection OTG_HS_GLOBAL Register Reset Value Definitions ****/

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_RST[3] = {
      [2] = 0x00000800U,   /** @brief OTG_HS control and status register */
      [1] = 0x00000800U   /** @brief OTG_HS control and status register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS interrupt register */
      [1] = 0x00000000U   /** @brief OTG_HS interrupt register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS AHB configuration register */
      [1] = 0x00000000U   /** @brief OTG_HS AHB configuration register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_RST[3] = {
      [2] = 0x00000A00U,   /** @brief OTG_HS USB configuration register */
      [1] = 0x00000A00U   /** @brief OTG_HS USB configuration register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_RST[3] = {
      [2] = 0x20000000U,   /** @brief OTG_HS reset register */
      [1] = 0x20000000U   /** @brief OTG_HS reset register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_RST[3] = {
      [2] = 0x04000020U,   /** @brief OTG_HS core interrupt register */
      [1] = 0x04000020U   /** @brief OTG_HS core interrupt register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS interrupt mask register */
      [1] = 0x00000000U   /** @brief OTG_HS interrupt mask register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS receive status debug read register (host mode) */
      [1] = 0x00000000U   /** @brief OTG_HS receive status debug read register (host mode) */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS status read and pop register (host mode) */
      [1] = 0x00000000U   /** @brief OTG_HS status read and pop register (host mode) */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_RST[3] = {
      [2] = 0x00000200U,   /** @brief OTG_HS receive FIFO size register */
      [1] = 0x00000200U   /** @brief OTG_HS receive FIFO size register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_RST[3] = {
      [2] = 0x00000200U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
      [1] = 0x00000200U   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_RST[3] = {
      [2] = 0x00000200U,   /** @brief Endpoint 0 transmit FIFO size (peripheral mode) */
      [1] = 0x00000200U   /** @brief Endpoint 0 transmit FIFO size (peripheral mode) */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_RST[3] = {
      [2] = 0x00080200U,   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
      [1] = 0x00080200U   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS general core configuration register */
      [1] = 0x00000000U   /** @brief OTG_HS general core configuration register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_CID_RST[3] = {
      [2] = 0x00001200U,   /** @brief OTG_HS core ID register */
      [1] = 0x00001200U   /** @brief OTG_HS core ID register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_RST[3] = {
      [2] = 0x02000600U,   /** @brief OTG_HS host periodic transmit FIFO size register */
      [1] = 0x02000600U   /** @brief OTG_HS host periodic transmit FIFO size register */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS receive status debug read register (peripheral mode mode) */
      [1] = 0x00000000U   /** @brief OTG_HS receive status debug read register (peripheral mode mode) */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS status read and pop register (peripheral mode) */
      [1] = 0x00000000U   /** @brief OTG_HS status read and pop register (peripheral mode) */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG core LPM configuration register */
      [1] = 0x00000000U   /** @brief OTG core LPM configuration register */
    };

    /**** @subsection OTG_HS_GLOBAL Register Value Type Definitions ****/

    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GOTGCTL register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GOTGINT register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GAHBCFG register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GUSBCFG register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GRSTCTL register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GINTSTS register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GINTMSK register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_vt;      /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_vt;      /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_vt;    /** @brief OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_vt;   /** @brief OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_vt;          /** @brief OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_vt;             /** @brief OTGx_HS_GLOBAL_OTG_HS_GCCFG register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_CID_vt;               /** @brief OTGx_HS_GLOBAL_OTG_HS_CID register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_vt;          /** @brief OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_vt;          /** @brief OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_vt;    /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_vt;    /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE register value type. */
    typedef uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_vt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GLPMCFG register value type. */

    /**** @subsection OTG_HS_GLOBAL Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GOTGCTL pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GOTGINT_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GOTGINT pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GAHBCFG pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GUSBCFG pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GRSTCTL pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GINTSTS_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GINTSTS pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GINTMSK_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GINTMSK pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_pt;      /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_pt;      /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_pt;    /** @brief OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_pt;   /** @brief OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_pt;          /** @brief OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GCCFG_pt;             /** @brief OTGx_HS_GLOBAL_OTG_HS_GCCFG pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_CID_pt;               /** @brief OTGx_HS_GLOBAL_OTG_HS_CID pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_pt;          /** @brief OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_pt;          /** @brief OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_pt;    /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_pt;    /** @brief OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_pt;           /** @brief OTGx_HS_GLOBAL_OTG_HS_GLPMCFG pointer register pointer type. */

    /**** @subsection OTG_HS_GLOBAL Field Mask Definitions ****/

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN_MASK[3] = {
      [2] = 0x00001000U,   /** @brief Embedded host enable */
      [1] = 0x00001000U   /** @brief Embedded host enable */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG_MASK[3] = {
      [2] = 0x00100000U,   /** @brief ID input pin changed */
      [1] = 0x00100000U   /** @brief ID input pin changed */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL_MASK[3] = {
      [2] = 0x00000100U,   /** @brief Periodic txfifo empty level */
      [1] = 0x00000100U   /** @brief Periodic txfifo empty level */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD_MASK[3] = {
      [2] = 0x40000000U,   /** @brief Forced peripheral mode */
      [1] = 0x40000000U   /** @brief Forced peripheral mode */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ_MASK[3] = {
      [2] = 0x40000000U,   /** @brief DMA request signal enabled for USB OTG HS */
      [1] = 0x40000000U   /** @brief DMA request signal enabled for USB OTG HS */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Resume/remote wakeup detected interrupt */
      [1] = 0x80000000U   /** @brief Resume/remote wakeup detected interrupt */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM_MASK[3] = {
      [2] = 0x08000000U,   /** @brief LPM interrupt mask */
      [1] = 0x08000000U   /** @brief LPM interrupt mask */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS_MASK[3] = {
      [2] = 0x001E0000U,   /** @brief Packet status */
      [1] = 0x001E0000U   /** @brief Packet status */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS_MASK[3] = {
      [2] = 0x001E0000U,   /** @brief Packet status */
      [1] = 0x001E0000U   /** @brief Packet status */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief RxFIFO depth */
      [1] = 0x0000FFFFU   /** @brief RxFIFO depth */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Nonperiodic txfifo depth */
      [1] = 0xFFFF0000U   /** @brief Nonperiodic txfifo depth */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Endpoint 0 txfifo depth */
      [1] = 0xFFFF0000U   /** @brief Endpoint 0 txfifo depth */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_MASK[3] = {
      [2] = 0x7F000000U,   /** @brief Top of the nonperiodic transmit request queue */
      [1] = 0x7F000000U   /** @brief Top of the nonperiodic transmit request queue */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PS2DET_MASK[3] = {
      [2] = 0x00000008U,   /** @brief DM pull-up detection status */
      [1] = 0x00000008U   /** @brief DM pull-up detection status */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_CID_PRODUCT_ID_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Product ID field */
      [1] = 0xFFFFFFFFU   /** @brief Product ID field */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Host periodic txfifo depth */
      [1] = 0xFFFF0000U   /** @brief Host periodic txfifo depth */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM_MASK[3] = {
      [2] = 0x01E00000U,   /** @brief Frame number */
      [1] = 0x01E00000U   /** @brief Frame number */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM_MASK[3] = {
      [2] = 0x01E00000U,   /** @brief Frame number */
      [1] = 0x01E00000U   /** @brief Frame number */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL_MASK[3] = {
      [2] = 0x10000000U,   /** @brief Enable best effort service latency */
      [1] = 0x10000000U   /** @brief Enable best effort service latency */
    };

    static const uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD_MASK[3][8] = {
      [2] = {
        [2] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [3] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [4] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [5] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [6] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [7] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [1] = 0xFFFF0000U   /** @brief IN endpoint txfifo depth */
      },
      [1] = {
        [2] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [3] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [4] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [5] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [6] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [7] = 0xFFFF0000U,   /** @brief IN endpoint txfifo depth */
        [1] = 0xFFFF0000U   /** @brief IN endpoint txfifo depth */
      }
    };

    /**********************************************************************************************
     * @section OTG_HS_HOST Register Definitions
     **********************************************************************************************/

    /**** @subsection OTG_HS_HOST Register Pointer Definitions ****/

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCFG_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080400U,   /** @brief OTG_HS host configuration register */
      [1] = (RW_ uint32_t*)0x40040400U   /** @brief OTG_HS host configuration register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HFIR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080404U,   /** @brief OTG_HS host frame interval register */
      [1] = (RW_ uint32_t*)0x40040404U   /** @brief OTG_HS host frame interval register */
    };

    static RO_ uint32_t* const OTGx_HS_HOST_OTG_HS_HFNUM_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40080408U,   /** @brief OTG_HS host frame number/frame time remaining register */
      [1] = (RO_ uint32_t*)0x40040408U   /** @brief OTG_HS host frame number/frame time remaining register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HPTXSTS_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080410U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
      [1] = (RW_ uint32_t*)0x40040410U   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
    };

    static RO_ uint32_t* const OTGx_HS_HOST_OTG_HS_HAINT_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40080414U,   /** @brief OTG_HS host all channels interrupt register */
      [1] = (RO_ uint32_t*)0x40040414U   /** @brief OTG_HS host all channels interrupt register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HAINTMSK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080418U,   /** @brief OTG_HS host all channels interrupt mask register */
      [1] = (RW_ uint32_t*)0x40040418U   /** @brief OTG_HS host all channels interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HPRT_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080440U,   /** @brief OTG_HS host port control and status register */
      [1] = (RW_ uint32_t*)0x40040440U   /** @brief OTG_HS host port control and status register */
    };

    /**** @subsection OTG_HS_HOST Register Reset Value Definitions ****/

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCFG_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS host configuration register */
      [1] = 0x00000000U   /** @brief OTG_HS host configuration register */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HFIR_RST[3] = {
      [2] = 0x0000EA60U,   /** @brief OTG_HS host frame interval register */
      [1] = 0x0000EA60U   /** @brief OTG_HS host frame interval register */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_RST[3] = {
      [2] = 0x00003FFFU,   /** @brief OTG_HS host frame number/frame time remaining register */
      [1] = 0x00003FFFU   /** @brief OTG_HS host frame number/frame time remaining register */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_RST[3] = {
      [2] = 0x00080100U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
      [1] = 0x00080100U   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINT_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS host all channels interrupt register */
      [1] = 0x00000000U   /** @brief OTG_HS host all channels interrupt register */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS host all channels interrupt mask register */
      [1] = 0x00000000U   /** @brief OTG_HS host all channels interrupt mask register */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS host port control and status register */
      [1] = 0x00000000U   /** @brief OTG_HS host port control and status register */
    };

    /**** @subsection OTG_HS_HOST Register Value Type Definitions ****/

    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCFG_vt;        /** @brief OTGx_HS_HOST_OTG_HS_HCFG register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HFIR_vt;        /** @brief OTGx_HS_HOST_OTG_HS_HFIR register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_vt;       /** @brief OTGx_HS_HOST_OTG_HS_HFNUM register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_vt;     /** @brief OTGx_HS_HOST_OTG_HS_HPTXSTS register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HAINT_vt;       /** @brief OTGx_HS_HOST_OTG_HS_HAINT register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_vt;    /** @brief OTGx_HS_HOST_OTG_HS_HAINTMSK register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HPRT_vt;        /** @brief OTGx_HS_HOST_OTG_HS_HPRT register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_vt;     /** @brief OTGx_HS_HOST_OTG_HS_HCCHARx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_vt;     /** @brief OTGx_HS_HOST_OTG_HS_HCSPLTx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_vt;      /** @brief OTGx_HS_HOST_OTG_HS_HCINTx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_vt;   /** @brief OTGx_HS_HOST_OTG_HS_HCINTMSKx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_vt;     /** @brief OTGx_HS_HOST_OTG_HS_HCTSIZx register value type. */
    typedef uint32_t OTGx_HS_HOST_OTG_HS_HCDMAx_vt;      /** @brief OTGx_HS_HOST_OTG_HS_HCDMAx register value type. */

    /**** @subsection OTG_HS_HOST Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HCFG_pt;        /** @brief OTGx_HS_HOST_OTG_HS_HCFG pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HFIR_pt;        /** @brief OTGx_HS_HOST_OTG_HS_HFIR pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_HOST_OTG_HS_HFNUM_pt;       /** @brief OTGx_HS_HOST_OTG_HS_HFNUM pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HPTXSTS_pt;     /** @brief OTGx_HS_HOST_OTG_HS_HPTXSTS pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_HOST_OTG_HS_HAINT_pt;       /** @brief OTGx_HS_HOST_OTG_HS_HAINT pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HAINTMSK_pt;    /** @brief OTGx_HS_HOST_OTG_HS_HAINTMSK pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HPRT_pt;        /** @brief OTGx_HS_HOST_OTG_HS_HPRT pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HCCHARx_pt;     /** @brief OTGx_HS_HOST_OTG_HS_HCCHARx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HCSPLTx_pt;     /** @brief OTGx_HS_HOST_OTG_HS_HCSPLTx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HCINTx_pt;      /** @brief OTGx_HS_HOST_OTG_HS_HCINTx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HCINTMSKx_pt;   /** @brief OTGx_HS_HOST_OTG_HS_HCINTMSKx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HCTSIZx_pt;     /** @brief OTGx_HS_HOST_OTG_HS_HCTSIZx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_HOST_OTG_HS_HCDMAx_pt;      /** @brief OTGx_HS_HOST_OTG_HS_HCDMAx pointer register pointer type. */

    /**** @subsection OTG_HS_HOST Field Mask Definitions ****/

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSS_MASK[3] = {
      [2] = 0x00000004U,   /** @brief FS- and ls-only support */
      [1] = 0x00000004U   /** @brief FS- and ls-only support */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HFIR_FRIVL_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Frame interval */
      [1] = 0x0000FFFFU   /** @brief Frame interval */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_FTREM_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Frame time remaining */
      [1] = 0xFFFF0000U   /** @brief Frame time remaining */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP_MASK[3] = {
      [2] = 0xFF000000U,   /** @brief Top of the periodic transmit request queue */
      [1] = 0xFF000000U   /** @brief Top of the periodic transmit request queue */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINT_HAINT_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Channel interrupts */
      [1] = 0x0000FFFFU   /** @brief Channel interrupts */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_HAINTM_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Channel interrupt mask */
      [1] = 0x0000FFFFU   /** @brief Channel interrupt mask */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PSPD_MASK[3] = {
      [2] = 0x00060000U,   /** @brief Port speed */
      [1] = 0x00060000U   /** @brief Port speed */
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHENA_MASK[3][16] = {
      [2] = {
        [1]  = 0x80000000U,   /** @brief Channel enable */
        [2]  = 0x80000000U,   /** @brief Channel enable */
        [3]  = 0x80000000U,   /** @brief Channel enable */
        [4]  = 0x80000000U,   /** @brief Channel enable */
        [5]  = 0x80000000U,   /** @brief Channel enable */
        [6]  = 0x80000000U,   /** @brief Channel enable */
        [7]  = 0x80000000U,   /** @brief Channel enable */
        [8]  = 0x80000000U,   /** @brief Channel enable */
        [9]  = 0x80000000U,   /** @brief Channel enable */
        [10] = 0x80000000U,   /** @brief Channel enable */
        [11] = 0x80000000U,   /** @brief Channel enable */
        [12] = 0x80000000U,   /** @brief Channel enable */
        [13] = 0x80000000U,   /** @brief Channel enable */
        [14] = 0x80000000U,   /** @brief Channel enable */
        [15] = 0x80000000U,   /** @brief Channel enable */
        [0]  = 0x80000000U   /** @brief Channel enable */
      },
      [1] = {
        [1]  = 0x80000000U,   /** @brief Channel enable */
        [2]  = 0x80000000U,   /** @brief Channel enable */
        [3]  = 0x80000000U,   /** @brief Channel enable */
        [4]  = 0x80000000U,   /** @brief Channel enable */
        [5]  = 0x80000000U,   /** @brief Channel enable */
        [6]  = 0x80000000U,   /** @brief Channel enable */
        [7]  = 0x80000000U,   /** @brief Channel enable */
        [8]  = 0x80000000U,   /** @brief Channel enable */
        [9]  = 0x80000000U,   /** @brief Channel enable */
        [10] = 0x80000000U,   /** @brief Channel enable */
        [11] = 0x80000000U,   /** @brief Channel enable */
        [12] = 0x80000000U,   /** @brief Channel enable */
        [13] = 0x80000000U,   /** @brief Channel enable */
        [14] = 0x80000000U,   /** @brief Channel enable */
        [15] = 0x80000000U,   /** @brief Channel enable */
        [0]  = 0x80000000U   /** @brief Channel enable */
      }
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_SPLITEN_MASK[3][16] = {
      [2] = {
        [1]  = 0x80000000U,   /** @brief Split enable */
        [2]  = 0x80000000U,   /** @brief Split enable */
        [3]  = 0x80000000U,   /** @brief Split enable */
        [4]  = 0x80000000U,   /** @brief Split enable */
        [5]  = 0x80000000U,   /** @brief Split enable */
        [6]  = 0x80000000U,   /** @brief Split enable */
        [7]  = 0x80000000U,   /** @brief Split enable */
        [8]  = 0x80000000U,   /** @brief Split enable */
        [9]  = 0x80000000U,   /** @brief Split enable */
        [10] = 0x80000000U,   /** @brief Split enable */
        [11] = 0x80000000U,   /** @brief Split enable */
        [12] = 0x80000000U,   /** @brief Split enable */
        [13] = 0x80000000U,   /** @brief Split enable */
        [14] = 0x80000000U,   /** @brief Split enable */
        [15] = 0x80000000U,   /** @brief Split enable */
        [0]  = 0x80000000U   /** @brief Split enable */
      },
      [1] = {
        [1]  = 0x80000000U,   /** @brief Split enable */
        [2]  = 0x80000000U,   /** @brief Split enable */
        [3]  = 0x80000000U,   /** @brief Split enable */
        [4]  = 0x80000000U,   /** @brief Split enable */
        [5]  = 0x80000000U,   /** @brief Split enable */
        [6]  = 0x80000000U,   /** @brief Split enable */
        [7]  = 0x80000000U,   /** @brief Split enable */
        [8]  = 0x80000000U,   /** @brief Split enable */
        [9]  = 0x80000000U,   /** @brief Split enable */
        [10] = 0x80000000U,   /** @brief Split enable */
        [11] = 0x80000000U,   /** @brief Split enable */
        [12] = 0x80000000U,   /** @brief Split enable */
        [13] = 0x80000000U,   /** @brief Split enable */
        [14] = 0x80000000U,   /** @brief Split enable */
        [15] = 0x80000000U,   /** @brief Split enable */
        [0]  = 0x80000000U   /** @brief Split enable */
      }
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_DTERR_MASK[3][16] = {
      [2] = {
        [1]  = 0x00000400U,   /** @brief Data toggle error */
        [2]  = 0x00000400U,   /** @brief Data toggle error */
        [3]  = 0x00000400U,   /** @brief Data toggle error */
        [4]  = 0x00000400U,   /** @brief Data toggle error */
        [5]  = 0x00000400U,   /** @brief Data toggle error */
        [6]  = 0x00000400U,   /** @brief Data toggle error */
        [7]  = 0x00000400U,   /** @brief Data toggle error */
        [8]  = 0x00000400U,   /** @brief Data toggle error */
        [9]  = 0x00000400U,   /** @brief Data toggle error */
        [10] = 0x00000400U,   /** @brief Data toggle error */
        [11] = 0x00000400U,   /** @brief Data toggle error */
        [12] = 0x00000400U,   /** @brief Data toggle error */
        [13] = 0x00000400U,   /** @brief Data toggle error */
        [14] = 0x00000400U,   /** @brief Data toggle error */
        [15] = 0x00000400U,   /** @brief Data toggle error */
        [0]  = 0x00000400U   /** @brief Data toggle error */
      },
      [1] = {
        [1]  = 0x00000400U,   /** @brief Data toggle error */
        [2]  = 0x00000400U,   /** @brief Data toggle error */
        [3]  = 0x00000400U,   /** @brief Data toggle error */
        [4]  = 0x00000400U,   /** @brief Data toggle error */
        [5]  = 0x00000400U,   /** @brief Data toggle error */
        [6]  = 0x00000400U,   /** @brief Data toggle error */
        [7]  = 0x00000400U,   /** @brief Data toggle error */
        [8]  = 0x00000400U,   /** @brief Data toggle error */
        [9]  = 0x00000400U,   /** @brief Data toggle error */
        [10] = 0x00000400U,   /** @brief Data toggle error */
        [11] = 0x00000400U,   /** @brief Data toggle error */
        [12] = 0x00000400U,   /** @brief Data toggle error */
        [13] = 0x00000400U,   /** @brief Data toggle error */
        [14] = 0x00000400U,   /** @brief Data toggle error */
        [15] = 0x00000400U,   /** @brief Data toggle error */
        [0]  = 0x00000400U   /** @brief Data toggle error */
      }
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_DTERRM_MASK[3][16] = {
      [2] = {
        [1]  = 0x00000400U,   /** @brief Data toggle error mask */
        [2]  = 0x00000400U,   /** @brief Data toggle error mask */
        [3]  = 0x00000400U,   /** @brief Data toggle error mask */
        [4]  = 0x00000400U,   /** @brief Data toggle error mask */
        [5]  = 0x00000400U,   /** @brief Data toggle error mask */
        [6]  = 0x00000400U,   /** @brief Data toggle error mask */
        [7]  = 0x00000400U,   /** @brief Data toggle error mask */
        [8]  = 0x00000400U,   /** @brief Data toggle error mask */
        [9]  = 0x00000400U,   /** @brief Data toggle error mask */
        [10] = 0x00000400U,   /** @brief Data toggle error mask */
        [11] = 0x00000400U,   /** @brief Data toggle error mask */
        [12] = 0x00000400U,   /** @brief Data toggle error mask */
        [13] = 0x00000400U,   /** @brief Data toggle error mask */
        [14] = 0x00000400U,   /** @brief Data toggle error mask */
        [15] = 0x00000400U,   /** @brief Data toggle error mask */
        [0]  = 0x00000400U   /** @brief Data toggle error mask */
      },
      [1] = {
        [1]  = 0x00000400U,   /** @brief Data toggle error mask */
        [2]  = 0x00000400U,   /** @brief Data toggle error mask */
        [3]  = 0x00000400U,   /** @brief Data toggle error mask */
        [4]  = 0x00000400U,   /** @brief Data toggle error mask */
        [5]  = 0x00000400U,   /** @brief Data toggle error mask */
        [6]  = 0x00000400U,   /** @brief Data toggle error mask */
        [7]  = 0x00000400U,   /** @brief Data toggle error mask */
        [8]  = 0x00000400U,   /** @brief Data toggle error mask */
        [9]  = 0x00000400U,   /** @brief Data toggle error mask */
        [10] = 0x00000400U,   /** @brief Data toggle error mask */
        [11] = 0x00000400U,   /** @brief Data toggle error mask */
        [12] = 0x00000400U,   /** @brief Data toggle error mask */
        [13] = 0x00000400U,   /** @brief Data toggle error mask */
        [14] = 0x00000400U,   /** @brief Data toggle error mask */
        [15] = 0x00000400U,   /** @brief Data toggle error mask */
        [0]  = 0x00000400U   /** @brief Data toggle error mask */
      }
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_DPID_MASK[3][16] = {
      [2] = {
        [1]  = 0x60000000U,   /** @brief Data PID */
        [2]  = 0x60000000U,   /** @brief Data PID */
        [3]  = 0x60000000U,   /** @brief Data PID */
        [4]  = 0x60000000U,   /** @brief Data PID */
        [5]  = 0x60000000U,   /** @brief Data PID */
        [6]  = 0x60000000U,   /** @brief Data PID */
        [7]  = 0x60000000U,   /** @brief Data PID */
        [8]  = 0x60000000U,   /** @brief Data PID */
        [9]  = 0x60000000U,   /** @brief Data PID */
        [10] = 0x60000000U,   /** @brief Data PID */
        [11] = 0x60000000U,   /** @brief Data PID */
        [12] = 0x60000000U,   /** @brief Data PID */
        [13] = 0x60000000U,   /** @brief Data PID */
        [14] = 0x60000000U,   /** @brief Data PID */
        [15] = 0x60000000U,   /** @brief Data PID */
        [0]  = 0x60000000U   /** @brief Data PID */
      },
      [1] = {
        [1]  = 0x60000000U,   /** @brief Data PID */
        [2]  = 0x60000000U,   /** @brief Data PID */
        [3]  = 0x60000000U,   /** @brief Data PID */
        [4]  = 0x60000000U,   /** @brief Data PID */
        [5]  = 0x60000000U,   /** @brief Data PID */
        [6]  = 0x60000000U,   /** @brief Data PID */
        [7]  = 0x60000000U,   /** @brief Data PID */
        [8]  = 0x60000000U,   /** @brief Data PID */
        [9]  = 0x60000000U,   /** @brief Data PID */
        [10] = 0x60000000U,   /** @brief Data PID */
        [11] = 0x60000000U,   /** @brief Data PID */
        [12] = 0x60000000U,   /** @brief Data PID */
        [13] = 0x60000000U,   /** @brief Data PID */
        [14] = 0x60000000U,   /** @brief Data PID */
        [15] = 0x60000000U,   /** @brief Data PID */
        [0]  = 0x60000000U   /** @brief Data PID */
      }
    };

    static const uint32_t OTGx_HS_HOST_OTG_HS_HCDMAx_DMAADDR_MASK[3][16] = {
      [2] = {
        [1]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [2]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [3]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [4]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [5]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [6]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [7]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [8]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [9]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [10] = 0xFFFFFFFFU,   /** @brief DMA address */
        [11] = 0xFFFFFFFFU,   /** @brief DMA address */
        [12] = 0xFFFFFFFFU,   /** @brief DMA address */
        [13] = 0xFFFFFFFFU,   /** @brief DMA address */
        [14] = 0xFFFFFFFFU,   /** @brief DMA address */
        [15] = 0xFFFFFFFFU,   /** @brief DMA address */
        [0]  = 0xFFFFFFFFU   /** @brief DMA address */
      },
      [1] = {
        [1]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [2]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [3]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [4]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [5]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [6]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [7]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [8]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [9]  = 0xFFFFFFFFU,   /** @brief DMA address */
        [10] = 0xFFFFFFFFU,   /** @brief DMA address */
        [11] = 0xFFFFFFFFU,   /** @brief DMA address */
        [12] = 0xFFFFFFFFU,   /** @brief DMA address */
        [13] = 0xFFFFFFFFU,   /** @brief DMA address */
        [14] = 0xFFFFFFFFU,   /** @brief DMA address */
        [15] = 0xFFFFFFFFU,   /** @brief DMA address */
        [0]  = 0xFFFFFFFFU   /** @brief DMA address */
      }
    };

    /**********************************************************************************************
     * @section OTG_HS_DEVICE Register Definitions
     **********************************************************************************************/

    /**** @subsection OTG_HS_DEVICE Register Pointer Definitions ****/

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DCFG_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080800U,   /** @brief OTG_HS device configuration register */
      [1] = (RW_ uint32_t*)0x40040800U   /** @brief OTG_HS device configuration register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DCTL_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080804U,   /** @brief OTG_HS device control register */
      [1] = (RW_ uint32_t*)0x40040804U   /** @brief OTG_HS device control register */
    };

    static RO_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DSTS_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40080808U,   /** @brief OTG_HS device status register */
      [1] = (RO_ uint32_t*)0x40040808U   /** @brief OTG_HS device status register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPMSK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080810U,   /** @brief OTG_HS device IN endpoint common interrupt mask register */
      [1] = (RW_ uint32_t*)0x40040810U   /** @brief OTG_HS device IN endpoint common interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DOEPMSK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080814U,   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
      [1] = (RW_ uint32_t*)0x40040814U   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
    };

    static RO_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DAINT_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40080818U,   /** @brief OTG_HS device all endpoints interrupt register */
      [1] = (RO_ uint32_t*)0x40040818U   /** @brief OTG_HS device all endpoints interrupt register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DAINTMSK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4008081CU,   /** @brief OTG_HS all endpoints interrupt mask register */
      [1] = (RW_ uint32_t*)0x4004081CU   /** @brief OTG_HS all endpoints interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080828U,   /** @brief OTG_HS device VBUS discharge time register */
      [1] = (RW_ uint32_t*)0x40040828U   /** @brief OTG_HS device VBUS discharge time register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4008082CU,   /** @brief OTG_HS device VBUS pulsing time register */
      [1] = (RW_ uint32_t*)0x4004082CU   /** @brief OTG_HS device VBUS pulsing time register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DTHRCTL_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080830U,   /** @brief OTG_HS device threshold control register */
      [1] = (RW_ uint32_t*)0x40040830U   /** @brief OTG_HS device threshold control register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080834U,   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
      [1] = (RW_ uint32_t*)0x40040834U   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DEACHINT_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080838U,   /** @brief OTG_HS device each endpoint interrupt register */
      [1] = (RW_ uint32_t*)0x40040838U   /** @brief OTG_HS device each endpoint interrupt register */
    };

    static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4008083CU,   /** @brief OTG_HS device each endpoint interrupt register mask */
      [1] = (RW_ uint32_t*)0x4004083CU   /** @brief OTG_HS device each endpoint interrupt register mask */
    };

    /**** @subsection OTG_HS_DEVICE Register Reset Value Definitions ****/

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_RST[3] = {
      [2] = 0x02200000U,   /** @brief OTG_HS device configuration register */
      [1] = 0x02200000U   /** @brief OTG_HS device configuration register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device control register */
      [1] = 0x00000000U   /** @brief OTG_HS device control register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DSTS_RST[3] = {
      [2] = 0x00000010U,   /** @brief OTG_HS device status register */
      [1] = 0x00000010U   /** @brief OTG_HS device status register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device IN endpoint common interrupt mask register */
      [1] = 0x00000000U   /** @brief OTG_HS device IN endpoint common interrupt mask register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
      [1] = 0x00000000U   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINT_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device all endpoints interrupt register */
      [1] = 0x00000000U   /** @brief OTG_HS device all endpoints interrupt register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS all endpoints interrupt mask register */
      [1] = 0x00000000U   /** @brief OTG_HS all endpoints interrupt mask register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_RST[3] = {
      [2] = 0x000017D7U,   /** @brief OTG_HS device VBUS discharge time register */
      [1] = 0x000017D7U   /** @brief OTG_HS device VBUS discharge time register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_RST[3] = {
      [2] = 0x000005B8U,   /** @brief OTG_HS device VBUS pulsing time register */
      [1] = 0x000005B8U   /** @brief OTG_HS device VBUS pulsing time register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device threshold control register */
      [1] = 0x00000000U   /** @brief OTG_HS device threshold control register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
      [1] = 0x00000000U   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device each endpoint interrupt register */
      [1] = 0x00000000U   /** @brief OTG_HS device each endpoint interrupt register */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_RST[3] = {
      [2] = 0x00000000U,   /** @brief OTG_HS device each endpoint interrupt register mask */
      [1] = 0x00000000U   /** @brief OTG_HS device each endpoint interrupt register mask */
    };

    /**** @subsection OTG_HS_DEVICE Register Value Type Definitions ****/

    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_vt;          /** @brief OTGx_HS_DEVICE_OTG_HS_DCFG register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_vt;          /** @brief OTGx_HS_DEVICE_OTG_HS_DCTL register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DSTS_vt;          /** @brief OTGx_HS_DEVICE_OTG_HS_DSTS register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_vt;       /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPMSK register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_vt;       /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPMSK register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DAINT_vt;         /** @brief OTGx_HS_DEVICE_OTG_HS_DAINT register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DAINTMSK register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DVBUSDIS register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_vt;    /** @brief OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_vt;       /** @brief OTGx_HS_DEVICE_OTG_HS_DTHRCTL register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_vt;    /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DEACHINT register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_vt;   /** @brief OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPCTLx register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPINTx register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_vt;     /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPDMAx_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPDMAx register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DTXFSTSx_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DTXFSTSx register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPCTLx register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_vt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPINTx register value type. */
    typedef uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_vt;     /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx register value type. */

    /**** @subsection OTG_HS_DEVICE Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DCFG_pt;          /** @brief OTGx_HS_DEVICE_OTG_HS_DCFG pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DCTL_pt;          /** @brief OTGx_HS_DEVICE_OTG_HS_DCTL pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DSTS_pt;          /** @brief OTGx_HS_DEVICE_OTG_HS_DSTS pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DIEPMSK_pt;       /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPMSK pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DOEPMSK_pt;       /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPMSK pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DAINT_pt;         /** @brief OTGx_HS_DEVICE_OTG_HS_DAINT pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DAINTMSK_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DAINTMSK pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DVBUSDIS pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_pt;    /** @brief OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DTHRCTL_pt;       /** @brief OTGx_HS_DEVICE_OTG_HS_DTHRCTL pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_pt;    /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DEACHINT_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DEACHINT pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_pt;   /** @brief OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPCTLx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DIEPINTx_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPINTx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_pt;     /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DIEPDMAx_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DIEPDMAx pointer register pointer type. */
    typedef RO_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DTXFSTSx_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DTXFSTSx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPCTLx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DOEPINTx_pt;      /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPINTx pointer register pointer type. */
    typedef RW_ uint32_t* OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_pt;     /** @brief OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx pointer register pointer type. */

    /**** @subsection OTG_HS_DEVICE Field Mask Definitions ****/

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_MASK[3] = {
      [2] = 0x03000000U,   /** @brief Periodic scheduling interval */
      [1] = 0x03000000U   /** @brief Periodic scheduling interval */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_POPRGDNE_MASK[3] = {
      [2] = 0x00000800U,   /** @brief Power-on programming done */
      [1] = 0x00000800U   /** @brief Power-on programming done */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DSTS_FNSOF_MASK[3] = {
      [2] = 0x003FFF00U,   /** @brief Frame number of the received SOF */
      [1] = 0x003FFF00U   /** @brief Frame number of the received SOF */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_BIM_MASK[3] = {
      [2] = 0x00000200U,   /** @brief BNA interrupt mask */
      [1] = 0x00000200U   /** @brief BNA interrupt mask */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_BOIM_MASK[3] = {
      [2] = 0x00000200U,   /** @brief BNA interrupt mask */
      [1] = 0x00000200U   /** @brief BNA interrupt mask */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINT_OEPINT_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief OUT endpoint interrupt bits */
      [1] = 0xFFFF0000U   /** @brief OUT endpoint interrupt bits */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief OUT EP interrupt mask bits */
      [1] = 0xFFFF0000U   /** @brief OUT EP interrupt mask bits */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Device VBUS discharge time */
      [1] = 0x0000FFFFU   /** @brief Device VBUS discharge time */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_MASK[3] = {
      [2] = 0x00000FFFU,   /** @brief Device VBUS pulsing time */
      [1] = 0x00000FFFU   /** @brief Device VBUS pulsing time */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN_MASK[3] = {
      [2] = 0x08000000U,   /** @brief Arbiter parking enable */
      [1] = 0x08000000U   /** @brief Arbiter parking enable */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief IN EP tx FIFO empty interrupt mask bits */
      [1] = 0x0000FFFFU   /** @brief IN EP tx FIFO empty interrupt mask bits */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT_MASK[3] = {
      [2] = 0x00020000U,   /** @brief OUT endpoint 1 interrupt bit */
      [1] = 0x00020000U   /** @brief OUT endpoint 1 interrupt bit */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM_MASK[3] = {
      [2] = 0x00020000U,   /** @brief OUT endpoint 1 interrupt mask bit */
      [1] = 0x00020000U   /** @brief OUT endpoint 1 interrupt mask bit */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_STUPCNT_MASK[3] = {
      [2] = 0x60000000U,   /** @brief SETUP packet count */
      [1] = 0x60000000U   /** @brief SETUP packet count */
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA_MASK[3][8] = {
      [2] = {
        [1] = 0x80000000U,   /** @brief Endpoint enable */
        [2] = 0x80000000U,   /** @brief Endpoint enable */
        [3] = 0x80000000U,   /** @brief Endpoint enable */
        [4] = 0x80000000U,   /** @brief Endpoint enable */
        [5] = 0x80000000U,   /** @brief Endpoint enable */
        [6] = 0x80000000U,   /** @brief Endpoint enable */
        [7] = 0x80000000U,   /** @brief Endpoint enable */
        [0] = 0x80000000U   /** @brief Endpoint enable */
      },
      [1] = {
        [1] = 0x80000000U,   /** @brief Endpoint enable */
        [2] = 0x80000000U,   /** @brief Endpoint enable */
        [3] = 0x80000000U,   /** @brief Endpoint enable */
        [4] = 0x80000000U,   /** @brief Endpoint enable */
        [5] = 0x80000000U,   /** @brief Endpoint enable */
        [6] = 0x80000000U,   /** @brief Endpoint enable */
        [7] = 0x80000000U,   /** @brief Endpoint enable */
        [0] = 0x80000000U   /** @brief Endpoint enable */
      }
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_NAK_MASK[3][8] = {
      [2] = {
        [1] = 0x00002000U,   /** @brief NAK interrupt */
        [2] = 0x00002000U,   /** @brief NAK interrupt */
        [3] = 0x00002000U,   /** @brief NAK interrupt */
        [4] = 0x00002000U,   /** @brief NAK interrupt */
        [5] = 0x00002000U,   /** @brief NAK interrupt */
        [6] = 0x00002000U,   /** @brief NAK interrupt */
        [7] = 0x00002000U,   /** @brief NAK interrupt */
        [0] = 0x00002000U   /** @brief NAK interrupt */
      },
      [1] = {
        [1] = 0x00002000U,   /** @brief NAK interrupt */
        [2] = 0x00002000U,   /** @brief NAK interrupt */
        [3] = 0x00002000U,   /** @brief NAK interrupt */
        [4] = 0x00002000U,   /** @brief NAK interrupt */
        [5] = 0x00002000U,   /** @brief NAK interrupt */
        [6] = 0x00002000U,   /** @brief NAK interrupt */
        [7] = 0x00002000U,   /** @brief NAK interrupt */
        [0] = 0x00002000U   /** @brief NAK interrupt */
      }
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_PKTCNT_MASK[3][8] = {
      [2] = {
        [1] = 0x1FF80000U,   /** @brief Packet count */
        [2] = 0x1FF80000U,   /** @brief Packet count */
        [3] = 0x1FF80000U,   /** @brief Packet count */
        [4] = 0x1FF80000U,   /** @brief Packet count */
        [5] = 0x1FF80000U,   /** @brief Packet count */
        [6] = 0x1FF80000U,   /** @brief Packet count */
        [7] = 0x1FF80000U,   /** @brief Packet count */
        [0] = 0x00180000U   /** @brief Packet count */
      },
      [1] = {
        [1] = 0x1FF80000U,   /** @brief Packet count */
        [2] = 0x1FF80000U,   /** @brief Packet count */
        [3] = 0x1FF80000U,   /** @brief Packet count */
        [4] = 0x1FF80000U,   /** @brief Packet count */
        [5] = 0x1FF80000U,   /** @brief Packet count */
        [6] = 0x1FF80000U,   /** @brief Packet count */
        [7] = 0x1FF80000U,   /** @brief Packet count */
        [0] = 0x00180000U   /** @brief Packet count */
      }
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPDMAx_DMAADDR_MASK[3][6] = {
      [2] = {
        [2] = 0xFFFFFFFFU,   /** @brief DMA address */
        [3] = 0xFFFFFFFFU,   /** @brief DMA address */
        [4] = 0xFFFFFFFFU,   /** @brief DMA address */
        [5] = 0xFFFFFFFFU,   /** @brief DMA address */
        [1] = 0xFFFFFFFFU   /** @brief DMA address */
      },
      [1] = {
        [2] = 0xFFFFFFFFU,   /** @brief DMA address */
        [3] = 0xFFFFFFFFU,   /** @brief DMA address */
        [4] = 0xFFFFFFFFU,   /** @brief DMA address */
        [5] = 0xFFFFFFFFU,   /** @brief DMA address */
        [1] = 0xFFFFFFFFU   /** @brief DMA address */
      }
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTXFSTSx_INEPTFSAV_MASK[3][8] = {
      [2] = {
        [1] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [2] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [3] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [4] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [5] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [6] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [7] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [0] = 0x0000FFFFU   /** @brief IN endpoint txfifo space avail */
      },
      [1] = {
        [1] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [2] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [3] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [4] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [5] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [6] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [7] = 0x0000FFFFU,   /** @brief IN endpoint txfifo space avail */
        [0] = 0x0000FFFFU   /** @brief IN endpoint txfifo space avail */
      }
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPENA_MASK[3][8] = {
      [2] = {
        [1] = 0x80000000U,   /** @brief Endpoint enable */
        [2] = 0x80000000U,   /** @brief Endpoint enable */
        [3] = 0x80000000U,   /** @brief Endpoint enable */
        [4] = 0x80000000U,   /** @brief Endpoint enable */
        [5] = 0x80000000U,   /** @brief Endpoint enable */
        [6] = 0x80000000U,   /** @brief Endpoint enable */
        [7] = 0x80000000U,   /** @brief Endpoint enable */
        [0] = 0x80000000U   /** @brief Endpoint enable */
      },
      [1] = {
        [1] = 0x80000000U,   /** @brief Endpoint enable */
        [2] = 0x80000000U,   /** @brief Endpoint enable */
        [3] = 0x80000000U,   /** @brief Endpoint enable */
        [4] = 0x80000000U,   /** @brief Endpoint enable */
        [5] = 0x80000000U,   /** @brief Endpoint enable */
        [6] = 0x80000000U,   /** @brief Endpoint enable */
        [7] = 0x80000000U,   /** @brief Endpoint enable */
        [0] = 0x80000000U   /** @brief Endpoint enable */
      }
    };

    static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_NYET_MASK[3][8] = {
      [2] = {
        [1] = 0x00004000U,   /** @brief NYET interrupt */
        [2] = 0x00004000U,   /** @brief NYET interrupt */
        [3] = 0x00004000U,   /** @brief NYET interrupt */
        [4] = 0x00004000U,   /** @brief NYET interrupt */
        [5] = 0x00004000U,   /** @brief NYET interrupt */
        [6] = 0x00004000U,   /** @brief NYET interrupt */
        [7] = 0x00004000U,   /** @brief NYET interrupt */
        [0] = 0x00004000U   /** @brief NYET interrupt */
      },
      [1] = {
        [1] = 0x00004000U,   /** @brief NYET interrupt */
        [2] = 0x00004000U,   /** @brief NYET interrupt */
        [3] = 0x00004000U,   /** @brief NYET interrupt */
        [4] = 0x00004000U,   /** @brief NYET interrupt */
        [5] = 0x00004000U,   /** @brief NYET interrupt */
        [6] = 0x00004000U,   /** @brief NYET interrupt */
        [7] = 0x00004000U,   /** @brief NYET interrupt */
        [0] = 0x00004000U   /** @brief NYET interrupt */
      }
    };

    /**********************************************************************************************
     * @section OTG_HS_PWRCLK Register Definitions
     **********************************************************************************************/

    /**** @subsection OTG_HS_PWRCLK Register Pointer Definitions ****/

    static RW_ uint32_t* const OTGx_HS_PWRCLK_OTG_HS_PCGCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40080E00U,   /** @brief Power and clock gating control register */
      [1] = (RW_ uint32_t*)0x40040E00U   /** @brief Power and clock gating control register */
    };

    /**** @subsection OTG_HS_PWRCLK Register Reset Value Definitions ****/

    static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Power and clock gating control register */
      [1] = 0x00000000U   /** @brief Power and clock gating control register */
    };

    /**** @subsection OTG_HS_PWRCLK Register Value Type Definitions ****/

    typedef uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_vt;   /** @brief OTGx_HS_PWRCLK_OTG_HS_PCGCR register value type. */

    /**** @subsection OTG_HS_PWRCLK Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* OTGx_HS_PWRCLK_OTG_HS_PCGCR_pt;   /** @brief OTGx_HS_PWRCLK_OTG_HS_PCGCR pointer register pointer type. */

    /**** @subsection OTG_HS_PWRCLK Field Mask Definitions ****/

    static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP_MASK[3] = {
      [2] = 0x00000010U,   /** @brief PHY suspended */
      [1] = 0x00000010U   /** @brief PHY suspended */
    };

    /**********************************************************************************************
     * @section ETHERNET_MAC Register Definitions
     **********************************************************************************************/

    /**** @subsection ETHERNET_MAC Register Pointer Definitions ****/

    static RW_ uint32_t* const ETHERNET_MAC_DMAMR_PTR                              = (RW_ uint32_t*)0x40029000U;   /** @brief DMA mode register */
    static RW_ uint32_t* const ETHERNET_MAC_DMASBMR_PTR                            = (RW_ uint32_t*)0x40029004U;   /** @brief System bus mode register */
    static RO_ uint32_t* const ETHERNET_MAC_DMAISR_PTR                             = (RO_ uint32_t*)0x40029008U;   /** @brief Interrupt status register */
    static RO_ uint32_t* const ETHERNET_MAC_DMADSR_PTR                             = (RO_ uint32_t*)0x4002900CU;   /** @brief Debug status register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACCR_PTR                             = (RW_ uint32_t*)0x40029100U;   /** @brief Channel control register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXCR_PTR                           = (RW_ uint32_t*)0x40029104U;   /** @brief Channel transmit control register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXCR_PTR                           = (RW_ uint32_t*)0x40029108U;   /** @brief Channel receive control register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXDLAR_PTR                         = (RW_ uint32_t*)0x40029114U;   /** @brief Channel tx descriptor list address register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXDLAR_PTR                         = (RW_ uint32_t*)0x4002911CU;   /** @brief Channel rx descriptor list address register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXDTPR_PTR                         = (RW_ uint32_t*)0x40029120U;   /** @brief Channel tx descriptor tail pointer register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXDTPR_PTR                         = (RW_ uint32_t*)0x40029128U;   /** @brief Channel rx descriptor tail pointer register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACTXRLR_PTR                          = (RW_ uint32_t*)0x4002912CU;   /** @brief Channel tx descriptor ring length register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXRLR_PTR                          = (RW_ uint32_t*)0x40029130U;   /** @brief Channel rx descriptor ring length register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACIER_PTR                            = (RW_ uint32_t*)0x40029134U;   /** @brief Channel interrupt enable register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACRXIWTR_PTR                         = (RW_ uint32_t*)0x40029138U;   /** @brief Channel rx interrupt watchdog timer register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCATXDR_PTR                         = (RO_ uint32_t*)0x40029144U;   /** @brief Channel current application transmit descriptor register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCARXDR_PTR                         = (RO_ uint32_t*)0x4002914CU;   /** @brief Channel current application receive descriptor register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCATXBR_PTR                         = (RO_ uint32_t*)0x40029154U;   /** @brief Channel current application transmit buffer register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACCARXBR_PTR                         = (RO_ uint32_t*)0x4002915CU;   /** @brief Channel current application receive buffer register */
    static RW_ uint32_t* const ETHERNET_MAC_DMACSR_PTR                             = (RW_ uint32_t*)0x40029160U;   /** @brief Channel status register */
    static RO_ uint32_t* const ETHERNET_MAC_DMACMFCR_PTR                           = (RO_ uint32_t*)0x4002916CU;   /** @brief Channel missed frame count register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLOMR_PTR                             = (RW_ uint32_t*)0x40028C00U;   /** @brief Operating mode register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLISR_PTR                             = (RO_ uint32_t*)0x40028C20U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLTXQOMR_PTR                          = (RW_ uint32_t*)0x40028D00U;   /** @brief Tx queue operating mode register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLTXQUR_PTR                           = (RO_ uint32_t*)0x40028D04U;   /** @brief Tx queue underflow register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLTXQDR_PTR                           = (RO_ uint32_t*)0x40028D08U;   /** @brief Tx queue debug register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLQICSR_PTR                           = (RW_ uint32_t*)0x40028D2CU;   /** @brief Queue interrupt control status register */
    static RW_ uint32_t* const ETHERNET_MAC_MTLRXQOMR_PTR                          = (RW_ uint32_t*)0x40028D30U;   /** @brief Rx queue operating mode register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLRXQMPOCR_PTR                        = (RO_ uint32_t*)0x40028D34U;   /** @brief Rx queue missed packet and overflow counter register */
    static RO_ uint32_t* const ETHERNET_MAC_MTLRXQDR_PTR                           = (RO_ uint32_t*)0x40028D38U;   /** @brief Rx queue debug register */
    static RW_ uint32_t* const ETHERNET_MAC_MACCR_PTR                              = (RW_ uint32_t*)0x40028000U;   /** @brief Operating mode configuration register */
    static RW_ uint32_t* const ETHERNET_MAC_MACECR_PTR                             = (RW_ uint32_t*)0x40028004U;   /** @brief Extended operating mode configuration register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPFR_PTR                             = (RW_ uint32_t*)0x40028008U;   /** @brief Packet filtering control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACWTR_PTR                             = (RW_ uint32_t*)0x4002800CU;   /** @brief Watchdog timeout register */
    static RW_ uint32_t* const ETHERNET_MAC_MACVTR_PTR                             = (RW_ uint32_t*)0x40028050U;   /** @brief VLAN tag register */
    static RW_ uint32_t* const ETHERNET_MAC_MACVHTR_PTR                            = (RW_ uint32_t*)0x40028058U;   /** @brief VLAN hash table register */
    static RW_ uint32_t* const ETHERNET_MAC_MACVIR_PTR                             = (RW_ uint32_t*)0x40028060U;   /** @brief VLAN inclusion register */
    static RW_ uint32_t* const ETHERNET_MAC_MACIVIR_PTR                            = (RW_ uint32_t*)0x40028064U;   /** @brief Inner VLAN inclusion register */
    static RW_ uint32_t* const ETHERNET_MAC_MACQTXFCR_PTR                          = (RW_ uint32_t*)0x40028070U;   /** @brief Tx queue flow control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACRXFCR_PTR                           = (RW_ uint32_t*)0x40028090U;   /** @brief Rx flow control register */
    static RO_ uint32_t* const ETHERNET_MAC_MACISR_PTR                             = (RO_ uint32_t*)0x400280B0U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACIER_PTR                             = (RW_ uint32_t*)0x400280B4U;   /** @brief Interrupt enable register */
    static RO_ uint32_t* const ETHERNET_MAC_MACRXTXSR_PTR                          = (RO_ uint32_t*)0x400280B8U;   /** @brief Rx tx status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPCSR_PTR                            = (RW_ uint32_t*)0x400280C0U;   /** @brief PMT control status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACRWKPFR_PTR                          = (RW_ uint32_t*)0x400280C4U;   /** @brief Remove wakeup packet filter register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLCSR_PTR                            = (RW_ uint32_t*)0x400280D0U;   /** @brief LPI control status register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLTCR_PTR                            = (RW_ uint32_t*)0x400280D4U;   /** @brief LPI timers control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLETR_PTR                            = (RW_ uint32_t*)0x400280D8U;   /** @brief LPI entry timer register */
    static RW_ uint32_t* const ETHERNET_MAC_MAC1USTCR_PTR                          = (RW_ uint32_t*)0x400280DCU;   /** @brief 1-microsecond-tick counter register */
    static RO_ uint32_t* const ETHERNET_MAC_MACVR_PTR                              = (RO_ uint32_t*)0x40028110U;   /** @brief Version register */
    static RW_ uint32_t* const ETHERNET_MAC_MACMDIOAR_PTR                          = (RW_ uint32_t*)0x40028200U;   /** @brief MDIO address register */
    static RW_ uint32_t* const ETHERNET_MAC_MACMDIODR_PTR                          = (RW_ uint32_t*)0x40028204U;   /** @brief MDIO data register */
    static RW_ uint32_t* const ETHERNET_MAC_MACARPAR_PTR                           = (RW_ uint32_t*)0x40028AE0U;   /** @brief ARP address register */
    static RW_ uint32_t* const ETHERNET_MAC_MMC_CONTROL_PTR                        = (RW_ uint32_t*)0x40028700U;   /** @brief MMC control register */
    static RO_ uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_PTR                   = (RO_ uint32_t*)0x40028704U;   /** @brief MMC rx interrupt register */
    static RO_ uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_PTR                   = (RO_ uint32_t*)0x40028708U;   /** @brief MMC tx interrupt register */
    static RW_ uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_PTR              = (RW_ uint32_t*)0x4002870CU;   /** @brief MMC rx interrupt mask register */
    static RW_ uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_PTR              = (RW_ uint32_t*)0x40028710U;   /** @brief MMC tx interrupt mask register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_PTR   = (RO_ uint32_t*)0x4002874CU;   /** @brief Tx single collision good packets register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_PTR = (RO_ uint32_t*)0x40028750U;   /** @brief Tx multiple collision good packets register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_PACKET_COUNT_GOOD_PTR               = (RO_ uint32_t*)0x40028768U;   /** @brief Tx packet count good register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_CRC_ERROR_PACKETS_PTR               = (RO_ uint32_t*)0x40028794U;   /** @brief Rx CRC error packets register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_PTR         = (RO_ uint32_t*)0x40028798U;   /** @brief Rx alignment error packets register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_PTR            = (RO_ uint32_t*)0x400287C4U;   /** @brief Rx unicast packets good register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_LPI_USEC_CNTR_PTR                   = (RO_ uint32_t*)0x400287ECU;   /** @brief Tx LPI microsecond timer register */
    static RO_ uint32_t* const ETHERNET_MAC_TX_LPI_TRAN_CNTR_PTR                   = (RO_ uint32_t*)0x400287F0U;   /** @brief Tx LPI transition counter register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_LPI_USEC_CNTR_PTR                   = (RO_ uint32_t*)0x400287F4U;   /** @brief Rx LPI microsecond counter register */
    static RO_ uint32_t* const ETHERNET_MAC_RX_LPI_TRAN_CNTR_PTR                   = (RO_ uint32_t*)0x400287F8U;   /** @brief Rx LPI transition counter register */
    static RO_ uint32_t* const ETHERNET_MAC_MACDR_PTR                              = (RO_ uint32_t*)0x40028114U;   /** @brief Debug register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSCR_PTR                            = (RW_ uint32_t*)0x40028B00U;   /** @brief Timestamp control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSSIR_PTR                            = (RW_ uint32_t*)0x40028B04U;   /** @brief Sub-second increment register */
    static RO_ uint32_t* const ETHERNET_MAC_MACSTSR_PTR                            = (RO_ uint32_t*)0x40028B08U;   /** @brief System time seconds register */
    static RO_ uint32_t* const ETHERNET_MAC_MACSTNR_PTR                            = (RO_ uint32_t*)0x40028B0CU;   /** @brief System time nanoseconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSTSUR_PTR                           = (RW_ uint32_t*)0x40028B10U;   /** @brief System time seconds update register */
    static RW_ uint32_t* const ETHERNET_MAC_MACSTNUR_PTR                           = (RW_ uint32_t*)0x40028B14U;   /** @brief System time nanoseconds update register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSAR_PTR                            = (RW_ uint32_t*)0x40028B18U;   /** @brief Timestamp addend register */
    static RO_ uint32_t* const ETHERNET_MAC_MACTSSR_PTR                            = (RO_ uint32_t*)0x40028B20U;   /** @brief Timestamp status register */
    static RO_ uint32_t* const ETHERNET_MAC_MACTXTSSNR_PTR                         = (RO_ uint32_t*)0x40028B30U;   /** @brief Tx timestamp status nanoseconds register */
    static RO_ uint32_t* const ETHERNET_MAC_MACTXTSSSR_PTR                         = (RO_ uint32_t*)0x40028B34U;   /** @brief Tx timestamp status seconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACACR_PTR                             = (RW_ uint32_t*)0x40028B40U;   /** @brief Auxiliary control register */
    static RO_ uint32_t* const ETHERNET_MAC_MACATSNR_PTR                           = (RO_ uint32_t*)0x40028B48U;   /** @brief Auxiliary timestamp nanoseconds register */
    static RO_ uint32_t* const ETHERNET_MAC_MACATSSR_PTR                           = (RO_ uint32_t*)0x40028B4CU;   /** @brief Auxiliary timestamp seconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSIACR_PTR                          = (RW_ uint32_t*)0x40028B50U;   /** @brief Timestamp ingress asymmetric correction register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSEACR_PTR                          = (RW_ uint32_t*)0x40028B54U;   /** @brief Timestamp egress asymmetric correction register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSICNR_PTR                          = (RW_ uint32_t*)0x40028B58U;   /** @brief Timestamp ingress correction nanosecond register */
    static RW_ uint32_t* const ETHERNET_MAC_MACTSECNR_PTR                          = (RW_ uint32_t*)0x40028B5CU;   /** @brief Timestamp egress correction nanosecond register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSCR_PTR                           = (RW_ uint32_t*)0x40028B70U;   /** @brief PPS control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSTTSR_PTR                         = (RW_ uint32_t*)0x40028B80U;   /** @brief PPS target time seconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSTTNR_PTR                         = (RW_ uint32_t*)0x40028B84U;   /** @brief PPS target time nanoseconds register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSIR_PTR                           = (RW_ uint32_t*)0x40028B88U;   /** @brief PPS interval register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPPSWR_PTR                           = (RW_ uint32_t*)0x40028B8CU;   /** @brief PPS width register */
    static RW_ uint32_t* const ETHERNET_MAC_MACPOCR_PTR                            = (RW_ uint32_t*)0x40028BC0U;   /** @brief PTP offload control register */
    static RW_ uint32_t* const ETHERNET_MAC_MACLMIR_PTR                            = (RW_ uint32_t*)0x40028BD0U;   /** @brief Log message interval register */

    static RW_ uint32_t* const ETHERNET_MAC_MACHTxR_PTR[2] = {
      [1] = (RW_ uint32_t*)0x40028014U,   /** @brief Hash table 1 register */
      [0] = (RW_ uint32_t*)0x40028010U   /** @brief Hash table 0 register */
    };

    static RO_ uint32_t* const ETHERNET_MAC_MACHWFxR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40028124U,   /** @brief HW feature 2 register */
      [1] = (RO_ uint32_t*)0x40028120U   /** @brief HW feature 1 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACAxHR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40028308U,   /** @brief Address 1 high register */
      [2] = (RW_ uint32_t*)0x40028310U,   /** @brief Address 2 high register */
      [3] = (RW_ uint32_t*)0x40028318U,   /** @brief Address 3 high register */
      [0] = (RW_ uint32_t*)0x40028300U   /** @brief Address 0 high register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACAxLR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x4002830CU,   /** @brief Address 1 low register */
      [2] = (RW_ uint32_t*)0x40028314U,   /** @brief Address 2 low register */
      [3] = (RW_ uint32_t*)0x4002831CU,   /** @brief Address 3 low register */
      [0] = (RW_ uint32_t*)0x40028304U   /** @brief Address 0 low register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL3L4CxR_PTR[2] = {
      [1] = (RW_ uint32_t*)0x40028930U,   /** @brief L3 and L4 control 1 register */
      [0] = (RW_ uint32_t*)0x40028900U   /** @brief L3 and L4 control 0 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL4AxR_PTR[2] = {
      [1] = (RW_ uint32_t*)0x40028934U,   /** @brief Layer 4 address filter 1 register */
      [0] = (RW_ uint32_t*)0x40028904U   /** @brief Layer4 address filter 0 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL3AxR_PTR[32] = {
      [10] = (RW_ uint32_t*)0x40028914U,   /** @brief Layer3 address 1 filter 0 register */
      [1]  = (RW_ uint32_t*)0x40028940U,   /** @brief Layer3 address 0 filter 1 register */
      [11] = (RW_ uint32_t*)0x40028944U,   /** @brief Layer3 address 1 filter 1 register */
      [21] = (RW_ uint32_t*)0x40028948U,   /** @brief Layer3 address 2 filter 1 register */
      [31] = (RW_ uint32_t*)0x4002894CU,   /** @brief Layer3 address 3 filter 1 register */
      [0]  = (RW_ uint32_t*)0x40028910U   /** @brief MACL3A00R */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACL3Ax_PTR[31] = {
      [30] = (RW_ uint32_t*)0x4002891CU,   /** @brief Layer3 address 3 filter 0 register */
      [20] = (RW_ uint32_t*)0x40028918U   /** @brief Layer3 address 2 filter 0 register */
    };

    static RW_ uint32_t* const ETHERNET_MAC_MACSPIxR_PTR[3] = {
      [1] = (RW_ uint32_t*)0x40028BC8U,   /** @brief PTP source port identity 1 register */
      [2] = (RW_ uint32_t*)0x40028BCCU,   /** @brief PTP source port identity 2 register */
      [0] = (RW_ uint32_t*)0x40028BC4U   /** @brief PTP source port identity 0 register */
    };

    /**** @subsection ETHERNET_MAC Register Reset Value Definitions ****/

    static const uint32_t ETHERNET_MAC_DMAMR_RST                              = 0x00000000U;   /** @brief DMA mode register */
    static const uint32_t ETHERNET_MAC_DMASBMR_RST                            = 0x01010000U;   /** @brief System bus mode register */
    static const uint32_t ETHERNET_MAC_DMAISR_RST                             = 0x00000000U;   /** @brief Interrupt status register */
    static const uint32_t ETHERNET_MAC_DMADSR_RST                             = 0x00000000U;   /** @brief Debug status register */
    static const uint32_t ETHERNET_MAC_DMACCR_RST                             = 0x00000000U;   /** @brief Channel control register */
    static const uint32_t ETHERNET_MAC_DMACTXCR_RST                           = 0x00000000U;   /** @brief Channel transmit control register */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RST                           = 0x00000000U;   /** @brief Channel receive control register */
    static const uint32_t ETHERNET_MAC_DMACTXDLAR_RST                         = 0x00000000U;   /** @brief Channel tx descriptor list address register */
    static const uint32_t ETHERNET_MAC_DMACRXDLAR_RST                         = 0x00000000U;   /** @brief Channel rx descriptor list address register */
    static const uint32_t ETHERNET_MAC_DMACTXDTPR_RST                         = 0x00000000U;   /** @brief Channel tx descriptor tail pointer register */
    static const uint32_t ETHERNET_MAC_DMACRXDTPR_RST                         = 0x00000000U;   /** @brief Channel rx descriptor tail pointer register */
    static const uint32_t ETHERNET_MAC_DMACTXRLR_RST                          = 0x00000000U;   /** @brief Channel tx descriptor ring length register */
    static const uint32_t ETHERNET_MAC_DMACRXRLR_RST                          = 0x00000000U;   /** @brief Channel rx descriptor ring length register */
    static const uint32_t ETHERNET_MAC_DMACIER_RST                            = 0x00000000U;   /** @brief Channel interrupt enable register */
    static const uint32_t ETHERNET_MAC_DMACRXIWTR_RST                         = 0x00000000U;   /** @brief Channel rx interrupt watchdog timer register */
    static const uint32_t ETHERNET_MAC_DMACCATXDR_RST                         = 0x00000000U;   /** @brief Channel current application transmit descriptor register */
    static const uint32_t ETHERNET_MAC_DMACCARXDR_RST                         = 0x00000000U;   /** @brief Channel current application receive descriptor register */
    static const uint32_t ETHERNET_MAC_DMACCATXBR_RST                         = 0x00000000U;   /** @brief Channel current application transmit buffer register */
    static const uint32_t ETHERNET_MAC_DMACCARXBR_RST                         = 0x00000000U;   /** @brief Channel current application receive buffer register */
    static const uint32_t ETHERNET_MAC_DMACSR_RST                             = 0x00000000U;   /** @brief Channel status register */
    static const uint32_t ETHERNET_MAC_DMACMFCR_RST                           = 0x00000000U;   /** @brief Channel missed frame count register */
    static const uint32_t ETHERNET_MAC_MTLOMR_RST                             = 0x00000000U;   /** @brief Operating mode register */
    static const uint32_t ETHERNET_MAC_MTLISR_RST                             = 0x00000000U;   /** @brief Interrupt status register */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_RST                          = 0x00070008U;   /** @brief Tx queue operating mode register */
    static const uint32_t ETHERNET_MAC_MTLTXQUR_RST                           = 0x00000000U;   /** @brief Tx queue underflow register */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_RST                           = 0x00000000U;   /** @brief Tx queue debug register */
    static const uint32_t ETHERNET_MAC_MTLQICSR_RST                           = 0x00000000U;   /** @brief Queue interrupt control status register */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RST                          = 0x00700000U;   /** @brief Rx queue operating mode register */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_RST                        = 0x00000000U;   /** @brief Rx queue missed packet and overflow counter register */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_RST                           = 0x00000000U;   /** @brief Rx queue debug register */
    static const uint32_t ETHERNET_MAC_MACCR_RST                              = 0x00000000U;   /** @brief Operating mode configuration register */
    static const uint32_t ETHERNET_MAC_MACECR_RST                             = 0x00000000U;   /** @brief Extended operating mode configuration register */
    static const uint32_t ETHERNET_MAC_MACPFR_RST                             = 0x00000000U;   /** @brief Packet filtering control register */
    static const uint32_t ETHERNET_MAC_MACWTR_RST                             = 0x00000000U;   /** @brief Watchdog timeout register */
    static const uint32_t ETHERNET_MAC_MACVTR_RST                             = 0x00000000U;   /** @brief VLAN tag register */
    static const uint32_t ETHERNET_MAC_MACVHTR_RST                            = 0x00000000U;   /** @brief VLAN hash table register */
    static const uint32_t ETHERNET_MAC_MACVIR_RST                             = 0x00000000U;   /** @brief VLAN inclusion register */
    static const uint32_t ETHERNET_MAC_MACIVIR_RST                            = 0x00000000U;   /** @brief Inner VLAN inclusion register */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_RST                          = 0x00000000U;   /** @brief Tx queue flow control register */
    static const uint32_t ETHERNET_MAC_MACRXFCR_RST                           = 0x00000000U;   /** @brief Rx flow control register */
    static const uint32_t ETHERNET_MAC_MACISR_RST                             = 0x00000000U;   /** @brief Interrupt status register */
    static const uint32_t ETHERNET_MAC_MACIER_RST                             = 0x00000000U;   /** @brief Interrupt enable register */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_RST                          = 0x00000000U;   /** @brief Rx tx status register */
    static const uint32_t ETHERNET_MAC_MACPCSR_RST                            = 0x00000000U;   /** @brief PMT control status register */
    static const uint32_t ETHERNET_MAC_MACRWKPFR_RST                          = 0x00000000U;   /** @brief Remove wakeup packet filter register */
    static const uint32_t ETHERNET_MAC_MACLCSR_RST                            = 0x00000000U;   /** @brief LPI control status register */
    static const uint32_t ETHERNET_MAC_MACLTCR_RST                            = 0x03E80000U;   /** @brief LPI timers control register */
    static const uint32_t ETHERNET_MAC_MACLETR_RST                            = 0x00000000U;   /** @brief LPI entry timer register */
    static const uint32_t ETHERNET_MAC_MAC1USTCR_RST                          = 0x00000000U;   /** @brief 1-microsecond-tick counter register */
    static const uint32_t ETHERNET_MAC_MACVR_RST                              = 0x00003041U;   /** @brief Version register */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_RST                          = 0x00000000U;   /** @brief MDIO address register */
    static const uint32_t ETHERNET_MAC_MACMDIODR_RST                          = 0x00000000U;   /** @brief MDIO data register */
    static const uint32_t ETHERNET_MAC_MACARPAR_RST                           = 0x00000000U;   /** @brief ARP address register */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_RST                        = 0x00000000U;   /** @brief MMC control register */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RST                   = 0x00000000U;   /** @brief MMC rx interrupt register */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_RST                   = 0x00000000U;   /** @brief MMC tx interrupt register */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RST              = 0x00000000U;   /** @brief MMC rx interrupt mask register */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_RST              = 0x00000000U;   /** @brief MMC tx interrupt mask register */
    static const uint32_t ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_RST   = 0x00000000U;   /** @brief Tx single collision good packets register */
    static const uint32_t ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_RST = 0x00000000U;   /** @brief Tx multiple collision good packets register */
    static const uint32_t ETHERNET_MAC_TX_PACKET_COUNT_GOOD_RST               = 0x00000000U;   /** @brief Tx packet count good register */
    static const uint32_t ETHERNET_MAC_RX_CRC_ERROR_PACKETS_RST               = 0x00000000U;   /** @brief Rx CRC error packets register */
    static const uint32_t ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_RST         = 0x00000000U;   /** @brief Rx alignment error packets register */
    static const uint32_t ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_RST            = 0x00000000U;   /** @brief Rx unicast packets good register */
    static const uint32_t ETHERNET_MAC_TX_LPI_USEC_CNTR_RST                   = 0x00000000U;   /** @brief Tx LPI microsecond timer register */
    static const uint32_t ETHERNET_MAC_TX_LPI_TRAN_CNTR_RST                   = 0x00000000U;   /** @brief Tx LPI transition counter register */
    static const uint32_t ETHERNET_MAC_RX_LPI_USEC_CNTR_RST                   = 0x00000000U;   /** @brief Rx LPI microsecond counter register */
    static const uint32_t ETHERNET_MAC_RX_LPI_TRAN_CNTR_RST                   = 0x00000000U;   /** @brief Rx LPI transition counter register */
    static const uint32_t ETHERNET_MAC_MACDR_RST                              = 0x00000000U;   /** @brief Debug register */
    static const uint32_t ETHERNET_MAC_MACTSCR_RST                            = 0x00000200U;   /** @brief Timestamp control register */
    static const uint32_t ETHERNET_MAC_MACSSIR_RST                            = 0x00000000U;   /** @brief Sub-second increment register */
    static const uint32_t ETHERNET_MAC_MACSTSR_RST                            = 0x00000000U;   /** @brief System time seconds register */
    static const uint32_t ETHERNET_MAC_MACSTNR_RST                            = 0x00000000U;   /** @brief System time nanoseconds register */
    static const uint32_t ETHERNET_MAC_MACSTSUR_RST                           = 0x00000000U;   /** @brief System time seconds update register */
    static const uint32_t ETHERNET_MAC_MACSTNUR_RST                           = 0x00000000U;   /** @brief System time nanoseconds update register */
    static const uint32_t ETHERNET_MAC_MACTSAR_RST                            = 0x00000000U;   /** @brief Timestamp addend register */
    static const uint32_t ETHERNET_MAC_MACTSSR_RST                            = 0x00000000U;   /** @brief Timestamp status register */
    static const uint32_t ETHERNET_MAC_MACTXTSSNR_RST                         = 0x00000000U;   /** @brief Tx timestamp status nanoseconds register */
    static const uint32_t ETHERNET_MAC_MACTXTSSSR_RST                         = 0x00000000U;   /** @brief Tx timestamp status seconds register */
    static const uint32_t ETHERNET_MAC_MACACR_RST                             = 0x00000000U;   /** @brief Auxiliary control register */
    static const uint32_t ETHERNET_MAC_MACATSNR_RST                           = 0x00000000U;   /** @brief Auxiliary timestamp nanoseconds register */
    static const uint32_t ETHERNET_MAC_MACATSSR_RST                           = 0x00000000U;   /** @brief Auxiliary timestamp seconds register */
    static const uint32_t ETHERNET_MAC_MACTSIACR_RST                          = 0x00000000U;   /** @brief Timestamp ingress asymmetric correction register */
    static const uint32_t ETHERNET_MAC_MACTSEACR_RST                          = 0x00000000U;   /** @brief Timestamp egress asymmetric correction register */
    static const uint32_t ETHERNET_MAC_MACTSICNR_RST                          = 0x00000000U;   /** @brief Timestamp ingress correction nanosecond register */
    static const uint32_t ETHERNET_MAC_MACTSECNR_RST                          = 0x00000000U;   /** @brief Timestamp egress correction nanosecond register */
    static const uint32_t ETHERNET_MAC_MACPPSCR_RST                           = 0x00000000U;   /** @brief PPS control register */
    static const uint32_t ETHERNET_MAC_MACPPSTTSR_RST                         = 0x00000000U;   /** @brief PPS target time seconds register */
    static const uint32_t ETHERNET_MAC_MACPPSTTNR_RST                         = 0x00000000U;   /** @brief PPS target time nanoseconds register */
    static const uint32_t ETHERNET_MAC_MACPPSIR_RST                           = 0x00000000U;   /** @brief PPS interval register */
    static const uint32_t ETHERNET_MAC_MACPPSWR_RST                           = 0x00000000U;   /** @brief PPS width register */
    static const uint32_t ETHERNET_MAC_MACPOCR_RST                            = 0x00000000U;   /** @brief PTP offload control register */
    static const uint32_t ETHERNET_MAC_MACLMIR_RST                            = 0x00000000U;   /** @brief Log message interval register */

    static const uint32_t ETHERNET_MAC_MACHTxR_RST[2] = {
      [1] = 0x00000000U,   /** @brief Hash table 1 register */
      [0] = 0x00000000U   /** @brief Hash table 0 register */
    };

    static const uint32_t ETHERNET_MAC_MACHWFxR_RST[3] = {
      [2] = 0x41000000U,   /** @brief HW feature 2 register */
      [1] = 0x11841904U   /** @brief HW feature 1 register */
    };

    static const uint32_t ETHERNET_MAC_MACAxHR_RST[4] = {
      [1] = 0x0000FFFFU,   /** @brief Address 1 high register */
      [2] = 0x0000FFFFU,   /** @brief Address 2 high register */
      [3] = 0x0000FFFFU,   /** @brief Address 3 high register */
      [0] = 0x8000FFFFU   /** @brief Address 0 high register */
    };

    static const uint32_t ETHERNET_MAC_MACAxLR_RST[4] = {
      [1] = 0xFFFFFFFFU,   /** @brief Address 1 low register */
      [2] = 0xFFFFFFFFU,   /** @brief Address 2 low register */
      [3] = 0xFFFFFFFFU,   /** @brief Address 3 low register */
      [0] = 0xFFFFFFFFU   /** @brief Address 0 low register */
    };

    static const uint32_t ETHERNET_MAC_MACL3L4CxR_RST[2] = {
      [1] = 0x00000000U,   /** @brief L3 and L4 control 1 register */
      [0] = 0x00000000U   /** @brief L3 and L4 control 0 register */
    };

    static const uint32_t ETHERNET_MAC_MACL4AxR_RST[2] = {
      [1] = 0x00000000U,   /** @brief Layer 4 address filter 1 register */
      [0] = 0x00000000U   /** @brief Layer4 address filter 0 register */
    };

    static const uint32_t ETHERNET_MAC_MACL3AxR_RST[32] = {
      [10] = 0x00000000U,   /** @brief Layer3 address 1 filter 0 register */
      [1]  = 0x00000000U,   /** @brief Layer3 address 0 filter 1 register */
      [11] = 0x00000000U,   /** @brief Layer3 address 1 filter 1 register */
      [21] = 0x00000000U,   /** @brief Layer3 address 2 filter 1 register */
      [31] = 0x00000000U,   /** @brief Layer3 address 3 filter 1 register */
      [0]  = 0x00000000U   /** @brief MACL3A00R */
    };

    static const uint32_t ETHERNET_MAC_MACL3Ax_RST[31] = {
      [30] = 0x00000000U,   /** @brief Layer3 address 3 filter 0 register */
      [20] = 0x00000000U   /** @brief Layer3 address 2 filter 0 register */
    };

    static const uint32_t ETHERNET_MAC_MACSPIxR_RST[3] = {
      [1] = 0x00000000U,   /** @brief PTP source port identity 1 register */
      [2] = 0x00000000U,   /** @brief PTP source port identity 2 register */
      [0] = 0x00000000U   /** @brief PTP source port identity 0 register */
    };

    /**** @subsection ETHERNET_MAC Register Value Type Definitions ****/

    typedef uint32_t ETHERNET_MAC_DMAMR_vt;                                /** @brief ETHERNET_MAC_DMAMR register value type. */
    typedef uint32_t ETHERNET_MAC_DMASBMR_vt;                              /** @brief ETHERNET_MAC_DMASBMR register value type. */
    typedef uint32_t ETHERNET_MAC_DMAISR_vt;                               /** @brief ETHERNET_MAC_DMAISR register value type. */
    typedef uint32_t ETHERNET_MAC_DMADSR_vt;                               /** @brief ETHERNET_MAC_DMADSR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCR_vt;                               /** @brief ETHERNET_MAC_DMACCR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXCR_vt;                             /** @brief ETHERNET_MAC_DMACTXCR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXCR_vt;                             /** @brief ETHERNET_MAC_DMACRXCR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXDLAR_vt;                           /** @brief ETHERNET_MAC_DMACTXDLAR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXDLAR_vt;                           /** @brief ETHERNET_MAC_DMACRXDLAR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXDTPR_vt;                           /** @brief ETHERNET_MAC_DMACTXDTPR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXDTPR_vt;                           /** @brief ETHERNET_MAC_DMACRXDTPR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACTXRLR_vt;                            /** @brief ETHERNET_MAC_DMACTXRLR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXRLR_vt;                            /** @brief ETHERNET_MAC_DMACRXRLR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACIER_vt;                              /** @brief ETHERNET_MAC_DMACIER register value type. */
    typedef uint32_t ETHERNET_MAC_DMACRXIWTR_vt;                           /** @brief ETHERNET_MAC_DMACRXIWTR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCATXDR_vt;                           /** @brief ETHERNET_MAC_DMACCATXDR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCARXDR_vt;                           /** @brief ETHERNET_MAC_DMACCARXDR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCATXBR_vt;                           /** @brief ETHERNET_MAC_DMACCATXBR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACCARXBR_vt;                           /** @brief ETHERNET_MAC_DMACCARXBR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACSR_vt;                               /** @brief ETHERNET_MAC_DMACSR register value type. */
    typedef uint32_t ETHERNET_MAC_DMACMFCR_vt;                             /** @brief ETHERNET_MAC_DMACMFCR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLOMR_vt;                               /** @brief ETHERNET_MAC_MTLOMR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLISR_vt;                               /** @brief ETHERNET_MAC_MTLISR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLTXQOMR_vt;                            /** @brief ETHERNET_MAC_MTLTXQOMR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLTXQUR_vt;                             /** @brief ETHERNET_MAC_MTLTXQUR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLTXQDR_vt;                             /** @brief ETHERNET_MAC_MTLTXQDR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLQICSR_vt;                             /** @brief ETHERNET_MAC_MTLQICSR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLRXQOMR_vt;                            /** @brief ETHERNET_MAC_MTLRXQOMR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLRXQMPOCR_vt;                          /** @brief ETHERNET_MAC_MTLRXQMPOCR register value type. */
    typedef uint32_t ETHERNET_MAC_MTLRXQDR_vt;                             /** @brief ETHERNET_MAC_MTLRXQDR register value type. */
    typedef uint32_t ETHERNET_MAC_MACCR_vt;                                /** @brief ETHERNET_MAC_MACCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACECR_vt;                               /** @brief ETHERNET_MAC_MACECR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPFR_vt;                               /** @brief ETHERNET_MAC_MACPFR register value type. */
    typedef uint32_t ETHERNET_MAC_MACWTR_vt;                               /** @brief ETHERNET_MAC_MACWTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACHTxR_vt;                              /** @brief ETHERNET_MAC_MACHTxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACVTR_vt;                               /** @brief ETHERNET_MAC_MACVTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACVHTR_vt;                              /** @brief ETHERNET_MAC_MACVHTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACVIR_vt;                               /** @brief ETHERNET_MAC_MACVIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACIVIR_vt;                              /** @brief ETHERNET_MAC_MACIVIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACQTXFCR_vt;                            /** @brief ETHERNET_MAC_MACQTXFCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACRXFCR_vt;                             /** @brief ETHERNET_MAC_MACRXFCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACISR_vt;                               /** @brief ETHERNET_MAC_MACISR register value type. */
    typedef uint32_t ETHERNET_MAC_MACIER_vt;                               /** @brief ETHERNET_MAC_MACIER register value type. */
    typedef uint32_t ETHERNET_MAC_MACRXTXSR_vt;                            /** @brief ETHERNET_MAC_MACRXTXSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPCSR_vt;                              /** @brief ETHERNET_MAC_MACPCSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACRWKPFR_vt;                            /** @brief ETHERNET_MAC_MACRWKPFR register value type. */
    typedef uint32_t ETHERNET_MAC_MACLCSR_vt;                              /** @brief ETHERNET_MAC_MACLCSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACLTCR_vt;                              /** @brief ETHERNET_MAC_MACLTCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACLETR_vt;                              /** @brief ETHERNET_MAC_MACLETR register value type. */
    typedef uint32_t ETHERNET_MAC_MAC1USTCR_vt;                            /** @brief ETHERNET_MAC_MAC1USTCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACVR_vt;                                /** @brief ETHERNET_MAC_MACVR register value type. */
    typedef uint32_t ETHERNET_MAC_MACHWFxR_vt;                             /** @brief ETHERNET_MAC_MACHWFxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACMDIOAR_vt;                            /** @brief ETHERNET_MAC_MACMDIOAR register value type. */
    typedef uint32_t ETHERNET_MAC_MACMDIODR_vt;                            /** @brief ETHERNET_MAC_MACMDIODR register value type. */
    typedef uint32_t ETHERNET_MAC_MACARPAR_vt;                             /** @brief ETHERNET_MAC_MACARPAR register value type. */
    typedef uint32_t ETHERNET_MAC_MACAxHR_vt;                              /** @brief ETHERNET_MAC_MACAxHR register value type. */
    typedef uint32_t ETHERNET_MAC_MACAxLR_vt;                              /** @brief ETHERNET_MAC_MACAxLR register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_CONTROL_vt;                          /** @brief ETHERNET_MAC_MMC_CONTROL register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_vt;                     /** @brief ETHERNET_MAC_MMC_RX_INTERRUPT register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_vt;                     /** @brief ETHERNET_MAC_MMC_TX_INTERRUPT register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_vt;                /** @brief ETHERNET_MAC_MMC_RX_INTERRUPT_MASK register value type. */
    typedef uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_vt;                /** @brief ETHERNET_MAC_MMC_TX_INTERRUPT_MASK register value type. */
    typedef uint32_t ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_vt;     /** @brief ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_vt;   /** @brief ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_TX_PACKET_COUNT_GOOD_vt;                 /** @brief ETHERNET_MAC_TX_PACKET_COUNT_GOOD register value type. */
    typedef uint32_t ETHERNET_MAC_RX_CRC_ERROR_PACKETS_vt;                 /** @brief ETHERNET_MAC_RX_CRC_ERROR_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_vt;           /** @brief ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS register value type. */
    typedef uint32_t ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_vt;              /** @brief ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD register value type. */
    typedef uint32_t ETHERNET_MAC_TX_LPI_USEC_CNTR_vt;                     /** @brief ETHERNET_MAC_TX_LPI_USEC_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_TX_LPI_TRAN_CNTR_vt;                     /** @brief ETHERNET_MAC_TX_LPI_TRAN_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_RX_LPI_USEC_CNTR_vt;                     /** @brief ETHERNET_MAC_RX_LPI_USEC_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_RX_LPI_TRAN_CNTR_vt;                     /** @brief ETHERNET_MAC_RX_LPI_TRAN_CNTR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL3L4CxR_vt;                           /** @brief ETHERNET_MAC_MACL3L4CxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL4AxR_vt;                             /** @brief ETHERNET_MAC_MACL4AxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACDR_vt;                                /** @brief ETHERNET_MAC_MACDR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL3AxR_vt;                             /** @brief ETHERNET_MAC_MACL3AxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACL3Ax_vt;                              /** @brief ETHERNET_MAC_MACL3Ax register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSCR_vt;                              /** @brief ETHERNET_MAC_MACTSCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSSIR_vt;                              /** @brief ETHERNET_MAC_MACSSIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTSR_vt;                              /** @brief ETHERNET_MAC_MACSTSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTNR_vt;                              /** @brief ETHERNET_MAC_MACSTNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTSUR_vt;                             /** @brief ETHERNET_MAC_MACSTSUR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSTNUR_vt;                             /** @brief ETHERNET_MAC_MACSTNUR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSAR_vt;                              /** @brief ETHERNET_MAC_MACTSAR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSSR_vt;                              /** @brief ETHERNET_MAC_MACTSSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTXTSSNR_vt;                           /** @brief ETHERNET_MAC_MACTXTSSNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTXTSSSR_vt;                           /** @brief ETHERNET_MAC_MACTXTSSSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACACR_vt;                               /** @brief ETHERNET_MAC_MACACR register value type. */
    typedef uint32_t ETHERNET_MAC_MACATSNR_vt;                             /** @brief ETHERNET_MAC_MACATSNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACATSSR_vt;                             /** @brief ETHERNET_MAC_MACATSSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSIACR_vt;                            /** @brief ETHERNET_MAC_MACTSIACR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSEACR_vt;                            /** @brief ETHERNET_MAC_MACTSEACR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSICNR_vt;                            /** @brief ETHERNET_MAC_MACTSICNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACTSECNR_vt;                            /** @brief ETHERNET_MAC_MACTSECNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSCR_vt;                             /** @brief ETHERNET_MAC_MACPPSCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSTTSR_vt;                           /** @brief ETHERNET_MAC_MACPPSTTSR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSTTNR_vt;                           /** @brief ETHERNET_MAC_MACPPSTTNR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSIR_vt;                             /** @brief ETHERNET_MAC_MACPPSIR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPPSWR_vt;                             /** @brief ETHERNET_MAC_MACPPSWR register value type. */
    typedef uint32_t ETHERNET_MAC_MACPOCR_vt;                              /** @brief ETHERNET_MAC_MACPOCR register value type. */
    typedef uint32_t ETHERNET_MAC_MACSPIxR_vt;                             /** @brief ETHERNET_MAC_MACSPIxR register value type. */
    typedef uint32_t ETHERNET_MAC_MACLMIR_vt;                              /** @brief ETHERNET_MAC_MACLMIR register value type. */

    /**** @subsection ETHERNET_MAC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* ETHERNET_MAC_DMAMR_pt;                                /** @brief ETHERNET_MAC_DMAMR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMASBMR_pt;                              /** @brief ETHERNET_MAC_DMASBMR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_DMAISR_pt;                               /** @brief ETHERNET_MAC_DMAISR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_DMADSR_pt;                               /** @brief ETHERNET_MAC_DMADSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACCR_pt;                               /** @brief ETHERNET_MAC_DMACCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACTXCR_pt;                             /** @brief ETHERNET_MAC_DMACTXCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACRXCR_pt;                             /** @brief ETHERNET_MAC_DMACRXCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACTXDLAR_pt;                           /** @brief ETHERNET_MAC_DMACTXDLAR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACRXDLAR_pt;                           /** @brief ETHERNET_MAC_DMACRXDLAR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACTXDTPR_pt;                           /** @brief ETHERNET_MAC_DMACTXDTPR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACRXDTPR_pt;                           /** @brief ETHERNET_MAC_DMACRXDTPR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACTXRLR_pt;                            /** @brief ETHERNET_MAC_DMACTXRLR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACRXRLR_pt;                            /** @brief ETHERNET_MAC_DMACRXRLR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACIER_pt;                              /** @brief ETHERNET_MAC_DMACIER pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACRXIWTR_pt;                           /** @brief ETHERNET_MAC_DMACRXIWTR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_DMACCATXDR_pt;                           /** @brief ETHERNET_MAC_DMACCATXDR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_DMACCARXDR_pt;                           /** @brief ETHERNET_MAC_DMACCARXDR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_DMACCATXBR_pt;                           /** @brief ETHERNET_MAC_DMACCATXBR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_DMACCARXBR_pt;                           /** @brief ETHERNET_MAC_DMACCARXBR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_DMACSR_pt;                               /** @brief ETHERNET_MAC_DMACSR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_DMACMFCR_pt;                             /** @brief ETHERNET_MAC_DMACMFCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MTLOMR_pt;                               /** @brief ETHERNET_MAC_MTLOMR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MTLISR_pt;                               /** @brief ETHERNET_MAC_MTLISR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MTLTXQOMR_pt;                            /** @brief ETHERNET_MAC_MTLTXQOMR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MTLTXQUR_pt;                             /** @brief ETHERNET_MAC_MTLTXQUR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MTLTXQDR_pt;                             /** @brief ETHERNET_MAC_MTLTXQDR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MTLQICSR_pt;                             /** @brief ETHERNET_MAC_MTLQICSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MTLRXQOMR_pt;                            /** @brief ETHERNET_MAC_MTLRXQOMR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MTLRXQMPOCR_pt;                          /** @brief ETHERNET_MAC_MTLRXQMPOCR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MTLRXQDR_pt;                             /** @brief ETHERNET_MAC_MTLRXQDR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACCR_pt;                                /** @brief ETHERNET_MAC_MACCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACECR_pt;                               /** @brief ETHERNET_MAC_MACECR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPFR_pt;                               /** @brief ETHERNET_MAC_MACPFR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACWTR_pt;                               /** @brief ETHERNET_MAC_MACWTR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACHTxR_pt;                              /** @brief ETHERNET_MAC_MACHTxR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACVTR_pt;                               /** @brief ETHERNET_MAC_MACVTR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACVHTR_pt;                              /** @brief ETHERNET_MAC_MACVHTR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACVIR_pt;                               /** @brief ETHERNET_MAC_MACVIR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACIVIR_pt;                              /** @brief ETHERNET_MAC_MACIVIR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACQTXFCR_pt;                            /** @brief ETHERNET_MAC_MACQTXFCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACRXFCR_pt;                             /** @brief ETHERNET_MAC_MACRXFCR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACISR_pt;                               /** @brief ETHERNET_MAC_MACISR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACIER_pt;                               /** @brief ETHERNET_MAC_MACIER pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACRXTXSR_pt;                            /** @brief ETHERNET_MAC_MACRXTXSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPCSR_pt;                              /** @brief ETHERNET_MAC_MACPCSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACRWKPFR_pt;                            /** @brief ETHERNET_MAC_MACRWKPFR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACLCSR_pt;                              /** @brief ETHERNET_MAC_MACLCSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACLTCR_pt;                              /** @brief ETHERNET_MAC_MACLTCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACLETR_pt;                              /** @brief ETHERNET_MAC_MACLETR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MAC1USTCR_pt;                            /** @brief ETHERNET_MAC_MAC1USTCR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACVR_pt;                                /** @brief ETHERNET_MAC_MACVR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACHWFxR_pt;                             /** @brief ETHERNET_MAC_MACHWFxR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACMDIOAR_pt;                            /** @brief ETHERNET_MAC_MACMDIOAR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACMDIODR_pt;                            /** @brief ETHERNET_MAC_MACMDIODR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACARPAR_pt;                             /** @brief ETHERNET_MAC_MACARPAR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACAxHR_pt;                              /** @brief ETHERNET_MAC_MACAxHR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACAxLR_pt;                              /** @brief ETHERNET_MAC_MACAxLR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MMC_CONTROL_pt;                          /** @brief ETHERNET_MAC_MMC_CONTROL pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MMC_RX_INTERRUPT_pt;                     /** @brief ETHERNET_MAC_MMC_RX_INTERRUPT pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MMC_TX_INTERRUPT_pt;                     /** @brief ETHERNET_MAC_MMC_TX_INTERRUPT pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_pt;                /** @brief ETHERNET_MAC_MMC_RX_INTERRUPT_MASK pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_pt;                /** @brief ETHERNET_MAC_MMC_TX_INTERRUPT_MASK pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_pt;     /** @brief ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_pt;   /** @brief ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_TX_PACKET_COUNT_GOOD_pt;                 /** @brief ETHERNET_MAC_TX_PACKET_COUNT_GOOD pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_RX_CRC_ERROR_PACKETS_pt;                 /** @brief ETHERNET_MAC_RX_CRC_ERROR_PACKETS pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_pt;           /** @brief ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_pt;              /** @brief ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_TX_LPI_USEC_CNTR_pt;                     /** @brief ETHERNET_MAC_TX_LPI_USEC_CNTR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_TX_LPI_TRAN_CNTR_pt;                     /** @brief ETHERNET_MAC_TX_LPI_TRAN_CNTR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_RX_LPI_USEC_CNTR_pt;                     /** @brief ETHERNET_MAC_RX_LPI_USEC_CNTR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_RX_LPI_TRAN_CNTR_pt;                     /** @brief ETHERNET_MAC_RX_LPI_TRAN_CNTR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACL3L4CxR_pt;                           /** @brief ETHERNET_MAC_MACL3L4CxR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACL4AxR_pt;                             /** @brief ETHERNET_MAC_MACL4AxR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACDR_pt;                                /** @brief ETHERNET_MAC_MACDR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACL3AxR_pt;                             /** @brief ETHERNET_MAC_MACL3AxR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACL3Ax_pt;                              /** @brief ETHERNET_MAC_MACL3Ax pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACTSCR_pt;                              /** @brief ETHERNET_MAC_MACTSCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACSSIR_pt;                              /** @brief ETHERNET_MAC_MACSSIR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACSTSR_pt;                              /** @brief ETHERNET_MAC_MACSTSR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACSTNR_pt;                              /** @brief ETHERNET_MAC_MACSTNR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACSTSUR_pt;                             /** @brief ETHERNET_MAC_MACSTSUR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACSTNUR_pt;                             /** @brief ETHERNET_MAC_MACSTNUR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACTSAR_pt;                              /** @brief ETHERNET_MAC_MACTSAR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACTSSR_pt;                              /** @brief ETHERNET_MAC_MACTSSR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACTXTSSNR_pt;                           /** @brief ETHERNET_MAC_MACTXTSSNR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACTXTSSSR_pt;                           /** @brief ETHERNET_MAC_MACTXTSSSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACACR_pt;                               /** @brief ETHERNET_MAC_MACACR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACATSNR_pt;                             /** @brief ETHERNET_MAC_MACATSNR pointer register pointer type. */
    typedef RO_ uint32_t* ETHERNET_MAC_MACATSSR_pt;                             /** @brief ETHERNET_MAC_MACATSSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACTSIACR_pt;                            /** @brief ETHERNET_MAC_MACTSIACR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACTSEACR_pt;                            /** @brief ETHERNET_MAC_MACTSEACR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACTSICNR_pt;                            /** @brief ETHERNET_MAC_MACTSICNR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACTSECNR_pt;                            /** @brief ETHERNET_MAC_MACTSECNR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPPSCR_pt;                             /** @brief ETHERNET_MAC_MACPPSCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPPSTTSR_pt;                           /** @brief ETHERNET_MAC_MACPPSTTSR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPPSTTNR_pt;                           /** @brief ETHERNET_MAC_MACPPSTTNR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPPSIR_pt;                             /** @brief ETHERNET_MAC_MACPPSIR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPPSWR_pt;                             /** @brief ETHERNET_MAC_MACPPSWR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACPOCR_pt;                              /** @brief ETHERNET_MAC_MACPOCR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACSPIxR_pt;                             /** @brief ETHERNET_MAC_MACSPIxR pointer register pointer type. */
    typedef RW_ uint32_t* ETHERNET_MAC_MACLMIR_pt;                              /** @brief ETHERNET_MAC_MACLMIR pointer register pointer type. */

    /**** @subsection ETHERNET_MAC Field Mask Definitions ****/

    static const uint32_t ETHERNET_MAC_DMAMR_INTM_MASK                                    = 0x00010000U;   /** @brief Interrupt mode */
    static const uint32_t ETHERNET_MAC_DMASBMR_RB_MASK                                    = 0x00008000U;   /** @brief Rebuild incrx burst */
    static const uint32_t ETHERNET_MAC_DMAISR_MACIS_MASK                                  = 0x00020000U;   /** @brief MAC interrupt status */
    static const uint32_t ETHERNET_MAC_DMADSR_TPS0_MASK                                   = 0x0000F000U;   /** @brief DMA channel transmit process state */
    static const uint32_t ETHERNET_MAC_DMACCR_DSL_MASK                                    = 0x001C0000U;   /** @brief Descriptor skip length */
    static const uint32_t ETHERNET_MAC_DMACTXCR_TXPBL_MASK                                = 0x003F0000U;   /** @brief Transmit programmable burst length */
    static const uint32_t ETHERNET_MAC_DMACRXCR_RPF_MASK                                  = 0x80000000U;   /** @brief DMA rx channel packet flush */
    static const uint32_t ETHERNET_MAC_DMACTXDLAR_TDESLA_MASK                             = 0xFFFFFFFCU;   /** @brief Start of transmit list */
    static const uint32_t ETHERNET_MAC_DMACRXDLAR_RDESLA_MASK                             = 0xFFFFFFFCU;   /** @brief Start of receive list */
    static const uint32_t ETHERNET_MAC_DMACTXDTPR_TDT_MASK                                = 0xFFFFFFFCU;   /** @brief Transmit descriptor tail pointer */
    static const uint32_t ETHERNET_MAC_DMACRXDTPR_RDT_MASK                                = 0xFFFFFFFCU;   /** @brief Receive descriptor tail pointer */
    static const uint32_t ETHERNET_MAC_DMACTXRLR_TDRL_MASK                                = 0x000003FFU;   /** @brief Transmit descriptor ring length */
    static const uint32_t ETHERNET_MAC_DMACRXRLR_RDRL_MASK                                = 0x000003FFU;   /** @brief Receive descriptor ring length */
    static const uint32_t ETHERNET_MAC_DMACIER_NIE_MASK                                   = 0x00008000U;   /** @brief Normal interrupt summary enable */
    static const uint32_t ETHERNET_MAC_DMACRXIWTR_RWT_MASK                                = 0x000000FFU;   /** @brief Receive interrupt watchdog timer count */
    static const uint32_t ETHERNET_MAC_DMACCATXDR_CURTDESAPTR_MASK                        = 0xFFFFFFFFU;   /** @brief Application transmit descriptor address pointer */
    static const uint32_t ETHERNET_MAC_DMACCARXDR_CURRDESAPTR_MASK                        = 0xFFFFFFFFU;   /** @brief Application receive descriptor address pointer */
    static const uint32_t ETHERNET_MAC_DMACCATXBR_CURTBUFAPTR_MASK                        = 0xFFFFFFFFU;   /** @brief Application transmit buffer address pointer */
    static const uint32_t ETHERNET_MAC_DMACCARXBR_CURRBUFAPTR_MASK                        = 0xFFFFFFFFU;   /** @brief Application receive buffer address pointer */
    static const uint32_t ETHERNET_MAC_DMACSR_REB_MASK                                    = 0x00380000U;   /** @brief Rx DMA error bits */
    static const uint32_t ETHERNET_MAC_DMACMFCR_MFCO_MASK                                 = 0x00008000U;   /** @brief Overflow status of the MFC counter */
    static const uint32_t ETHERNET_MAC_MTLOMR_CNTCLR_MASK                                 = 0x00000200U;   /** @brief CNTCLR */
    static const uint32_t ETHERNET_MAC_MTLISR_Q0IS_MASK                                   = 0x00000001U;   /** @brief Queue interrupt status */
    static const uint32_t ETHERNET_MAC_MTLTXQOMR_TQS_MASK                                 = 0x01FF0000U;   /** @brief Transmit queue size */
    static const uint32_t ETHERNET_MAC_MTLTXQUR_UFCNTOVF_MASK                             = 0x00000800U;   /** @brief UFCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLTXQDR_STXSTSF_MASK                              = 0x00700000U;   /** @brief STXSTSF */
    static const uint32_t ETHERNET_MAC_MTLQICSR_RXOIE_MASK                                = 0x01000000U;   /** @brief RXOIE */
    static const uint32_t ETHERNET_MAC_MTLRXQOMR_RQS_MASK                                 = 0x00700000U;   /** @brief RQS */
    static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF_MASK                         = 0x08000000U;   /** @brief MISCNTOVF */
    static const uint32_t ETHERNET_MAC_MTLRXQDR_PRXQ_MASK                                 = 0x3FFF0000U;   /** @brief PRXQ */
    static const uint32_t ETHERNET_MAC_MACCR_ARPEN_MASK                                   = 0x80000000U;   /** @brief ARPEN */
    static const uint32_t ETHERNET_MAC_MACECR_EIPG_MASK                                   = 0x3E000000U;   /** @brief EIPG */
    static const uint32_t ETHERNET_MAC_MACPFR_RA_MASK                                     = 0x80000000U;   /** @brief RA */
    static const uint32_t ETHERNET_MAC_MACWTR_PWE_MASK                                    = 0x00000100U;   /** @brief PWE */
    static const uint32_t ETHERNET_MAC_MACHTxR_HT31T0_MASK                                = 0xFFFFFFFFU;   /** @brief HT31T0 */
    static const uint32_t ETHERNET_MAC_MACVTR_EIVLRXS_MASK                                = 0x80000000U;   /** @brief EIVLRXS */
    static const uint32_t ETHERNET_MAC_MACVHTR_VLHT_MASK                                  = 0x0000FFFFU;   /** @brief VLHT */
    static const uint32_t ETHERNET_MAC_MACVIR_VLTI_MASK                                   = 0x00100000U;   /** @brief VLTI */
    static const uint32_t ETHERNET_MAC_MACIVIR_VLTI_MASK                                  = 0x00100000U;   /** @brief VLTI */
    static const uint32_t ETHERNET_MAC_MACQTXFCR_PT_MASK                                  = 0xFFFF0000U;   /** @brief PT */
    static const uint32_t ETHERNET_MAC_MACRXFCR_UP_MASK                                   = 0x00000002U;   /** @brief UP */
    static const uint32_t ETHERNET_MAC_MACISR_RXSTSIS_MASK                                = 0x00004000U;   /** @brief RXSTSIS */
    static const uint32_t ETHERNET_MAC_MACIER_RXSTSIE_MASK                                = 0x00004000U;   /** @brief RXSTSIE */
    static const uint32_t ETHERNET_MAC_MACRXTXSR_RWT_MASK                                 = 0x00000100U;   /** @brief RWT */
    static const uint32_t ETHERNET_MAC_MACPCSR_RWKFILTRST_MASK                            = 0x80000000U;   /** @brief RWKFILTRST */
    static const uint32_t ETHERNET_MAC_MACRWKPFR_WKUPFRMFTR_MASK                          = 0xFFFFFFFFU;   /** @brief WKUPFRMFTR */
    static const uint32_t ETHERNET_MAC_MACLCSR_LPITCSE_MASK                               = 0x00200000U;   /** @brief LPITCSE */
    static const uint32_t ETHERNET_MAC_MACLTCR_LST_MASK                                   = 0x03FF0000U;   /** @brief LST */
    static const uint32_t ETHERNET_MAC_MACLETR_LPIET_MASK                                 = 0x0001FFFFU;   /** @brief LPIET */
    static const uint32_t ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR_MASK                        = 0x00000FFFU;   /** @brief TIC_1US_CNTR */
    static const uint32_t ETHERNET_MAC_MACVR_USERVER_MASK                                 = 0x0000FF00U;   /** @brief USERVER */
    static const uint32_t ETHERNET_MAC_MACHWFxR_L3L4FNUM_MASK                             = 0x78000000U;   /** @brief L3L4FNUM */
    static const uint32_t ETHERNET_MAC_MACMDIOAR_PSE_MASK                                 = 0x08000000U;   /** @brief PSE */
    static const uint32_t ETHERNET_MAC_MACMDIODR_RA_MASK                                  = 0xFFFF0000U;   /** @brief RA */
    static const uint32_t ETHERNET_MAC_MACARPAR_ARPPA_MASK                                = 0xFFFFFFFFU;   /** @brief ARPPA */
    static const uint32_t ETHERNET_MAC_MMC_CONTROL_UCDBC_MASK                             = 0x00000100U;   /** @brief UCDBC */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS_MASK                   = 0x08000000U;   /** @brief RXLPITRCIS */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS_MASK                   = 0x08000000U;   /** @brief TXLPITRCIS */
    static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_MASK              = 0x08000000U;   /** @brief RXLPITRCIM */
    static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_MASK              = 0x08000000U;   /** @brief TXLPITRCIM */
    static const uint32_t ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG_MASK   = 0xFFFFFFFFU;   /** @brief TXSNGLCOLG */
    static const uint32_t ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG_MASK = 0xFFFFFFFFU;   /** @brief TXMULTCOLG */
    static const uint32_t ETHERNET_MAC_TX_PACKET_COUNT_GOOD_TXPKTG_MASK                   = 0xFFFFFFFFU;   /** @brief TXPKTG */
    static const uint32_t ETHERNET_MAC_RX_CRC_ERROR_PACKETS_RXCRCERR_MASK                 = 0xFFFFFFFFU;   /** @brief RXCRCERR */
    static const uint32_t ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_RXALGNERR_MASK          = 0xFFFFFFFFU;   /** @brief RXALGNERR */
    static const uint32_t ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_RXUCASTG_MASK              = 0xFFFFFFFFU;   /** @brief RXUCASTG */
    static const uint32_t ETHERNET_MAC_TX_LPI_USEC_CNTR_TXLPIUSC_MASK                     = 0xFFFFFFFFU;   /** @brief TXLPIUSC */
    static const uint32_t ETHERNET_MAC_TX_LPI_TRAN_CNTR_TXLPITRC_MASK                     = 0xFFFFFFFFU;   /** @brief TXLPITRC */
    static const uint32_t ETHERNET_MAC_RX_LPI_USEC_CNTR_RXLPIUSC_MASK                     = 0xFFFFFFFFU;   /** @brief RXLPIUSC */
    static const uint32_t ETHERNET_MAC_RX_LPI_TRAN_CNTR_RXLPITRC_MASK                     = 0xFFFFFFFFU;   /** @brief RXLPITRC */
    static const uint32_t ETHERNET_MAC_MACDR_TFCSTS_MASK                                  = 0x00060000U;   /** @brief TFCSTS */
    static const uint32_t ETHERNET_MAC_MACTSCR_TXTSSTSM_MASK                              = 0x01000000U;   /** @brief TXTSSTSM */
    static const uint32_t ETHERNET_MAC_MACSSIR_SSINC_MASK                                 = 0x00FF0000U;   /** @brief SSINC */
    static const uint32_t ETHERNET_MAC_MACSTSR_TSS_MASK                                   = 0xFFFFFFFFU;   /** @brief TSS */
    static const uint32_t ETHERNET_MAC_MACSTNR_TSSS_MASK                                  = 0x7FFFFFFFU;   /** @brief TSSS */
    static const uint32_t ETHERNET_MAC_MACSTSUR_TSS_MASK                                  = 0xFFFFFFFFU;   /** @brief TSS */
    static const uint32_t ETHERNET_MAC_MACSTNUR_ADDSUB_MASK                               = 0x80000000U;   /** @brief ADDSUB */
    static const uint32_t ETHERNET_MAC_MACTSAR_TSAR_MASK                                  = 0xFFFFFFFFU;   /** @brief TSAR */
    static const uint32_t ETHERNET_MAC_MACTSSR_ATSNS_MASK                                 = 0x3E000000U;   /** @brief ATSNS */
    static const uint32_t ETHERNET_MAC_MACTXTSSNR_TXTSSMIS_MASK                           = 0x80000000U;   /** @brief TXTSSMIS */
    static const uint32_t ETHERNET_MAC_MACTXTSSSR_TXTSSHI_MASK                            = 0xFFFFFFFFU;   /** @brief TXTSSHI */
    static const uint32_t ETHERNET_MAC_MACATSNR_AUXTSLO_MASK                              = 0x7FFFFFFFU;   /** @brief AUXTSLO */
    static const uint32_t ETHERNET_MAC_MACATSSR_AUXTSHI_MASK                              = 0xFFFFFFFFU;   /** @brief AUXTSHI */
    static const uint32_t ETHERNET_MAC_MACTSIACR_OSTIAC_MASK                              = 0xFFFFFFFFU;   /** @brief OSTIAC */
    static const uint32_t ETHERNET_MAC_MACTSEACR_OSTEAC_MASK                              = 0xFFFFFFFFU;   /** @brief OSTEAC */
    static const uint32_t ETHERNET_MAC_MACTSICNR_TSIC_MASK                                = 0xFFFFFFFFU;   /** @brief TSIC */
    static const uint32_t ETHERNET_MAC_MACTSECNR_TSEC_MASK                                = 0xFFFFFFFFU;   /** @brief TSEC */
    static const uint32_t ETHERNET_MAC_MACPPSCR_TRGTMODSEL0_MASK                          = 0x00000060U;   /** @brief TRGTMODSEL0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTSR_TSTRH0_MASK                             = 0x7FFFFFFFU;   /** @brief TSTRH0 */
    static const uint32_t ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0_MASK                          = 0x80000000U;   /** @brief TRGTBUSY0 */
    static const uint32_t ETHERNET_MAC_MACPPSIR_PPSINT0_MASK                              = 0xFFFFFFFFU;   /** @brief PPSINT0 */
    static const uint32_t ETHERNET_MAC_MACPPSWR_PPSWIDTH0_MASK                            = 0xFFFFFFFFU;   /** @brief PPSWIDTH0 */
    static const uint32_t ETHERNET_MAC_MACPOCR_DN_MASK                                    = 0x0000FF00U;   /** @brief DN */
    static const uint32_t ETHERNET_MAC_MACLMIR_LMPDRI_MASK                                = 0xFF000000U;   /** @brief LMPDRI */

    static const uint32_t ETHERNET_MAC_MACAxHR_AE_MASK[4] = {
      [1] = 0x80000000U,   /** @brief AE */
      [2] = 0x80000000U,   /** @brief AE */
      [3] = 0x80000000U,   /** @brief AE */
      [0] = 0x80000000U   /** @brief AE */
    };

    static const uint32_t ETHERNET_MAC_MACAxLR_ADDRLO_MASK[4] = {
      [1] = 0xFFFFFFFFU,   /** @brief ADDRLO */
      [2] = 0xFFFFFFFFU,   /** @brief ADDRLO */
      [3] = 0xFFFFFFFFU,   /** @brief ADDRLO */
      [0] = 0xFFFFFFFFU   /** @brief ADDRLO */
    };

    static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4DPIMx_MASK[2] = {
      [1] = 0x00200000U,   /** @brief L4DPIM1 */
      [0] = 0x00200000U   /** @brief L4DPIM0 */
    };

    static const uint32_t ETHERNET_MAC_MACL4AxR_L4DPx_MASK[2] = {
      [1] = 0xFFFF0000U,   /** @brief L4DP1 */
      [0] = 0xFFFF0000U   /** @brief L4DP0 */
    };

    static const uint32_t ETHERNET_MAC_MACL3AxR_L3Ax_MASK[32] = {
      [10] = 0xFFFFFFFFU,   /** @brief L3A10 */
      [1]  = 0xFFFFFFFFU,   /** @brief L3A01 */
      [11] = 0xFFFFFFFFU,   /** @brief L3A11 */
      [21] = 0xFFFFFFFFU,   /** @brief L3A21 */
      [31] = 0xFFFFFFFFU,   /** @brief L3A31 */
      [0]  = 0xFFFFFFFFU   /** @brief L3A00 */
    };

    static const uint32_t ETHERNET_MAC_MACL3Ax_L3Ax_MASK[31] = {
      [30] = 0xFFFFFFFFU,   /** @brief L3A30 */
      [20] = 0xFFFFFFFFU   /** @brief L3A20 */
    };

    static const uint32_t ETHERNET_MAC_MACACR_ATSENx_MASK[4] = {
      [1] = 0x00000020U,   /** @brief ATSEN1 */
      [2] = 0x00000040U,   /** @brief ATSEN2 */
      [3] = 0x00000080U,   /** @brief ATSEN3 */
      [0] = 0x00000010U   /** @brief ATSEN0 */
    };

    static const uint32_t ETHERNET_MAC_MACSPIxR_SPIx_MASK[3] = {
      [1] = 0xFFFFFFFFU,   /** @brief SPI1 */
      [2] = 0x0000FFFFU,   /** @brief SPI2 */
      [0] = 0xFFFFFFFFU   /** @brief SPI0 */
    };

    /**********************************************************************************************
     * @section DMA Register Definitions
     **********************************************************************************************/

    /**** @subsection DMA Register Pointer Definitions ****/

    static RO_ uint32_t* const DMAx_LISR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40020400U,   /** @brief Low interrupt status register */
      [1] = (RO_ uint32_t*)0x40020000U   /** @brief Low interrupt status register */
    };

    static RO_ uint32_t* const DMAx_HISR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40020404U,   /** @brief High interrupt status register */
      [1] = (RO_ uint32_t*)0x40020004U   /** @brief High interrupt status register */
    };

    static RW_ uint32_t* const DMAx_LIFCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40020408U,   /** @brief Low interrupt flag clear register */
      [1] = (RW_ uint32_t*)0x40020008U   /** @brief Low interrupt flag clear register */
    };

    static RW_ uint32_t* const DMAx_HIFCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4002040CU,   /** @brief High interrupt flag clear register */
      [1] = (RW_ uint32_t*)0x4002000CU   /** @brief High interrupt flag clear register */
    };

    /**** @subsection DMA Register Reset Value Definitions ****/

    static const uint32_t DMAx_LISR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Low interrupt status register */
      [1] = 0x00000000U   /** @brief Low interrupt status register */
    };

    static const uint32_t DMAx_HISR_RST[3] = {
      [2] = 0x00000000U,   /** @brief High interrupt status register */
      [1] = 0x00000000U   /** @brief High interrupt status register */
    };

    static const uint32_t DMAx_LIFCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Low interrupt flag clear register */
      [1] = 0x00000000U   /** @brief Low interrupt flag clear register */
    };

    static const uint32_t DMAx_HIFCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief High interrupt flag clear register */
      [1] = 0x00000000U   /** @brief High interrupt flag clear register */
    };

    /**** @subsection DMA Register Value Type Definitions ****/

    typedef uint32_t DMAx_LISR_vt;     /** @brief DMAx_LISR register value type. */
    typedef uint32_t DMAx_HISR_vt;     /** @brief DMAx_HISR register value type. */
    typedef uint32_t DMAx_LIFCR_vt;    /** @brief DMAx_LIFCR register value type. */
    typedef uint32_t DMAx_HIFCR_vt;    /** @brief DMAx_HIFCR register value type. */
    typedef uint32_t DMAx_SxCR_vt;     /** @brief DMAx_SxCR register value type. */
    typedef uint32_t DMAx_SxNDTR_vt;   /** @brief DMAx_SxNDTR register value type. */
    typedef uint32_t DMAx_SxPAR_vt;    /** @brief DMAx_SxPAR register value type. */
    typedef uint32_t DMAx_SxM0AR_vt;   /** @brief DMAx_SxM0AR register value type. */
    typedef uint32_t DMAx_SxFCR_vt;    /** @brief DMAx_SxFCR register value type. */
    typedef uint32_t DMAx_SxM1AR_vt;   /** @brief DMAx_SxM1AR register value type. */

    /**** @subsection DMA Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* DMAx_LISR_pt;     /** @brief DMAx_LISR pointer register pointer type. */
    typedef RO_ uint32_t* DMAx_HISR_pt;     /** @brief DMAx_HISR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_LIFCR_pt;    /** @brief DMAx_LIFCR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_HIFCR_pt;    /** @brief DMAx_HIFCR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_SxCR_pt;     /** @brief DMAx_SxCR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_SxNDTR_pt;   /** @brief DMAx_SxNDTR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_SxPAR_pt;    /** @brief DMAx_SxPAR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_SxM0AR_pt;   /** @brief DMAx_SxM0AR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_SxFCR_pt;    /** @brief DMAx_SxFCR pointer register pointer type. */
    typedef RW_ uint32_t* DMAx_SxM1AR_pt;   /** @brief DMAx_SxM1AR pointer register pointer type. */

    /**** @subsection DMA Field Mask Definitions ****/

    static const uint32_t DMAx_LISR_FEIFx_MASK[3][4] = {
      [2] = {
        [2] = 0x00010000U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
        [1] = 0x00000040U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
        [0] = 0x00000001U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
        [3] = 0x00400000U   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      },
      [1] = {
        [2] = 0x00010000U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
        [1] = 0x00000040U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
        [0] = 0x00000001U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
        [3] = 0x00400000U   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
      }
    };

    static const uint32_t DMAx_HISR_FEIFx_MASK[3][8] = {
      [2] = {
        [6] = 0x00010000U,   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
        [5] = 0x00000040U,   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
        [4] = 0x00000001U,   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
        [7] = 0x00400000U   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
      },
      [1] = {
        [6] = 0x00010000U,   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
        [5] = 0x00000040U,   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
        [4] = 0x00000001U,   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
        [7] = 0x00400000U   /** @brief Stream x FIFO error interrupt flag (x=7..4) */
      }
    };

    static const uint32_t DMAx_LIFCR_CFEIFx_MASK[3][4] = {
      [2] = {
        [2] = 0x00010000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
        [1] = 0x00000040U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
        [0] = 0x00000001U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
        [3] = 0x00400000U   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      },
      [1] = {
        [2] = 0x00010000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
        [1] = 0x00000040U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
        [0] = 0x00000001U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
        [3] = 0x00400000U   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
      }
    };

    static const uint32_t DMAx_HIFCR_CFEIFx_MASK[3][8] = {
      [2] = {
        [6] = 0x00010000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
        [5] = 0x00000040U,   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
        [4] = 0x00000001U,   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
        [7] = 0x00400000U   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
      },
      [1] = {
        [6] = 0x00010000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
        [5] = 0x00000040U,   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
        [4] = 0x00000001U,   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
        [7] = 0x00400000U   /** @brief Stream x clear FIFO error interrupt flag (x = 7..4) */
      }
    };

    static const uint32_t DMAx_SxCR_EN_MASK[3][8] = {
      [2] = {
        [1] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [2] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [3] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [4] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [5] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [6] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [7] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [0] = 0x00000001U   /** @brief Stream enable / flag stream ready when read low */
      },
      [1] = {
        [1] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [2] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [3] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [4] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [5] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [6] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [7] = 0x00000001U,   /** @brief Stream enable / flag stream ready when read low */
        [0] = 0x00000001U   /** @brief Stream enable / flag stream ready when read low */
      }
    };

    static const uint32_t DMAx_SxNDTR_NDT_MASK[3][8] = {
      [2] = {
        [1] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [2] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [3] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [4] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [5] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [6] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [7] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [0] = 0x0000FFFFU   /** @brief Number of data items to transfer */
      },
      [1] = {
        [1] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [2] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [3] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [4] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [5] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [6] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [7] = 0x0000FFFFU,   /** @brief Number of data items to transfer */
        [0] = 0x0000FFFFU   /** @brief Number of data items to transfer */
      }
    };

    static const uint32_t DMAx_SxPAR_PA_MASK[3][8] = {
      [2] = {
        [1] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [2] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [3] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [4] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [5] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [6] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [7] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [0] = 0xFFFFFFFFU   /** @brief Peripheral address */
      },
      [1] = {
        [1] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [2] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [3] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [4] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [5] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [6] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [7] = 0xFFFFFFFFU,   /** @brief Peripheral address */
        [0] = 0xFFFFFFFFU   /** @brief Peripheral address */
      }
    };

    static const uint32_t DMAx_SxM0AR_MxA_MASK[3][8] = {
      [2] = {
        [1] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [2] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [3] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [4] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [5] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [6] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [7] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [0] = 0xFFFFFFFFU   /** @brief Memory 0 address */
      },
      [1] = {
        [1] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [2] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [3] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [4] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [5] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [6] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [7] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [0] = 0xFFFFFFFFU   /** @brief Memory 0 address */
      }
    };

    static const uint32_t DMAx_SxFCR_FTH_MASK[3][8] = {
      [2] = {
        [1] = 0x00000003U,   /** @brief FIFO threshold selection */
        [2] = 0x00000003U,   /** @brief FIFO threshold selection */
        [3] = 0x00000003U,   /** @brief FIFO threshold selection */
        [4] = 0x00000003U,   /** @brief FIFO threshold selection */
        [5] = 0x00000003U,   /** @brief FIFO threshold selection */
        [6] = 0x00000003U,   /** @brief FIFO threshold selection */
        [7] = 0x00000003U,   /** @brief FIFO threshold selection */
        [0] = 0x00000003U   /** @brief FIFO threshold selection */
      },
      [1] = {
        [1] = 0x00000003U,   /** @brief FIFO threshold selection */
        [2] = 0x00000003U,   /** @brief FIFO threshold selection */
        [3] = 0x00000003U,   /** @brief FIFO threshold selection */
        [4] = 0x00000003U,   /** @brief FIFO threshold selection */
        [5] = 0x00000003U,   /** @brief FIFO threshold selection */
        [6] = 0x00000003U,   /** @brief FIFO threshold selection */
        [7] = 0x00000003U,   /** @brief FIFO threshold selection */
        [0] = 0x00000003U   /** @brief FIFO threshold selection */
      }
    };

    static const uint32_t DMAx_SxM1AR_MxA_MASK[3][8] = {
      [2] = {
        [0] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [2] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [3] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [4] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [5] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [6] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [7] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [1] = 0xFFFFFFFFU   /** @brief Memory 1 address (used in case of double buffer mode) */
      },
      [1] = {
        [0] = 0xFFFFFFFFU,   /** @brief Memory 0 address */
        [2] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [3] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [4] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [5] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [6] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [7] = 0xFFFFFFFFU,   /** @brief Memory 1 address (used in case of double buffer mode) */
        [1] = 0xFFFFFFFFU   /** @brief Memory 1 address (used in case of double buffer mode) */
      }
    };

    /**********************************************************************************************
     * @section HRTIM_MASTER Register Definitions
     **********************************************************************************************/

    /**** @subsection HRTIM_MASTER Register Pointer Definitions ****/

    static RW_ uint32_t* const HRTIM_MASTER_MCR_PTR    = (RW_ uint32_t*)0x40017400U;   /** @brief Master timer control register */
    static RO_ uint32_t* const HRTIM_MASTER_MISR_PTR   = (RO_ uint32_t*)0x40017404U;   /** @brief Master timer interrupt status register */
    static RW_ uint32_t* const HRTIM_MASTER_MICR_PTR   = (RW_ uint32_t*)0x40017408U;   /** @brief Master timer interrupt clear register */
    static RW_ uint32_t* const HRTIM_MASTER_MDIER4_PTR = (RW_ uint32_t*)0x4001740CU;   /** @brief MDIER4 */
    static RW_ uint32_t* const HRTIM_MASTER_MCNTR_PTR  = (RW_ uint32_t*)0x40017410U;   /** @brief Master timer counter register */
    static RW_ uint32_t* const HRTIM_MASTER_MPER_PTR   = (RW_ uint32_t*)0x40017414U;   /** @brief Master timer period register */
    static RW_ uint32_t* const HRTIM_MASTER_MREP_PTR   = (RW_ uint32_t*)0x40017418U;   /** @brief Master timer repetition register */

    static RW_ uint32_t* const HRTIM_MASTER_MCMPxR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x40017424U,   /** @brief Master timer compare 2 register */
      [3] = (RW_ uint32_t*)0x40017428U,   /** @brief Master timer compare 3 register */
      [4] = (RW_ uint32_t*)0x4001742CU,   /** @brief Master timer compare 4 register */
      [1] = (RW_ uint32_t*)0x4001741CU   /** @brief Master timer compare 1 register */
    };

    /**** @subsection HRTIM_MASTER Register Reset Value Definitions ****/

    static const uint32_t HRTIM_MASTER_MCR_RST    = 0x00000000U;   /** @brief Master timer control register */
    static const uint32_t HRTIM_MASTER_MISR_RST   = 0x00000000U;   /** @brief Master timer interrupt status register */
    static const uint32_t HRTIM_MASTER_MICR_RST   = 0x00000000U;   /** @brief Master timer interrupt clear register */
    static const uint32_t HRTIM_MASTER_MDIER4_RST = 0x00000000U;   /** @brief MDIER4 */
    static const uint32_t HRTIM_MASTER_MCNTR_RST  = 0x00000000U;   /** @brief Master timer counter register */
    static const uint32_t HRTIM_MASTER_MPER_RST   = 0x0000FFFFU;   /** @brief Master timer period register */
    static const uint32_t HRTIM_MASTER_MREP_RST   = 0x00000000U;   /** @brief Master timer repetition register */

    static const uint32_t HRTIM_MASTER_MCMPxR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Master timer compare 2 register */
      [3] = 0x00000000U,   /** @brief Master timer compare 3 register */
      [4] = 0x00000000U,   /** @brief Master timer compare 4 register */
      [1] = 0x00000000U   /** @brief Master timer compare 1 register */
    };

    /**** @subsection HRTIM_MASTER Register Value Type Definitions ****/

    typedef uint32_t HRTIM_MASTER_MCR_vt;      /** @brief HRTIM_MASTER_MCR register value type. */
    typedef uint32_t HRTIM_MASTER_MISR_vt;     /** @brief HRTIM_MASTER_MISR register value type. */
    typedef uint32_t HRTIM_MASTER_MICR_vt;     /** @brief HRTIM_MASTER_MICR register value type. */
    typedef uint32_t HRTIM_MASTER_MDIER4_vt;   /** @brief HRTIM_MASTER_MDIER4 register value type. */
    typedef uint32_t HRTIM_MASTER_MCNTR_vt;    /** @brief HRTIM_MASTER_MCNTR register value type. */
    typedef uint32_t HRTIM_MASTER_MPER_vt;     /** @brief HRTIM_MASTER_MPER register value type. */
    typedef uint32_t HRTIM_MASTER_MREP_vt;     /** @brief HRTIM_MASTER_MREP register value type. */
    typedef uint32_t HRTIM_MASTER_MCMPxR_vt;   /** @brief HRTIM_MASTER_MCMPxR register value type. */

    /**** @subsection HRTIM_MASTER Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HRTIM_MASTER_MCR_pt;      /** @brief HRTIM_MASTER_MCR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_MASTER_MISR_pt;     /** @brief HRTIM_MASTER_MISR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_MASTER_MICR_pt;     /** @brief HRTIM_MASTER_MICR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_MASTER_MDIER4_pt;   /** @brief HRTIM_MASTER_MDIER4 pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_MASTER_MCNTR_pt;    /** @brief HRTIM_MASTER_MCNTR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_MASTER_MPER_pt;     /** @brief HRTIM_MASTER_MPER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_MASTER_MREP_pt;     /** @brief HRTIM_MASTER_MREP pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_MASTER_MCMPxR_pt;   /** @brief HRTIM_MASTER_MCMPxR pointer register pointer type. */

    /**** @subsection HRTIM_MASTER Field Mask Definitions ****/

    static const uint32_t HRTIM_MASTER_MCR_CK_PSC_MASK = 0x00000007U;   /** @brief HRTIM master clock prescaler */
    static const uint32_t HRTIM_MASTER_MCNTR_MCNT_MASK = 0x0000FFFFU;   /** @brief Counter value */
    static const uint32_t HRTIM_MASTER_MPER_MPER_MASK  = 0x0000FFFFU;   /** @brief Master timer period value */
    static const uint32_t HRTIM_MASTER_MREP_MREP_MASK  = 0x000000FFU;   /** @brief Master timer repetition counter value */

    static const uint32_t HRTIM_MASTER_MISR_MCMPx_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Master compare 3 interrupt flag */
      [2] = 0x00000002U,   /** @brief Master compare 2 interrupt flag */
      [1] = 0x00000001U,   /** @brief Master compare 1 interrupt flag */
      [4] = 0x00000008U   /** @brief Master compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_MASTER_MICR_MCMPxC_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Master compare 3 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Master compare 2 interrupt flag clear */
      [1] = 0x00000001U,   /** @brief Master compare 1 interrupt flag clear */
      [4] = 0x00000008U   /** @brief Master compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_MASTER_MDIER4_MCMPxIE_MASK[5] = {
      [3] = 0x00000004U,   /** @brief MCMP3IE */
      [2] = 0x00000002U,   /** @brief MCMP2IE */
      [1] = 0x00000001U,   /** @brief MCMP1IE */
      [4] = 0x00000008U   /** @brief MCMP4IE */
    };

    static const uint32_t HRTIM_MASTER_MCMPxR_MCMPx_MASK[5] = {
      [2] = 0x0000FFFFU,   /** @brief Master timer compare 2 value */
      [3] = 0x0000FFFFU,   /** @brief Master timer compare 3 value */
      [4] = 0x0000FFFFU,   /** @brief Master timer compare 4 value */
      [1] = 0x0000FFFFU   /** @brief Master timer compare 1 value */
    };

    /**********************************************************************************************
     * @section HRTIM_TIMA Register Definitions
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMA Register Pointer Definitions ****/

    static RW_ uint32_t* const HRTIM_TIMA_TIMACR_PTR    = (RW_ uint32_t*)0x40017480U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMA_TIMAISR_PTR   = (RO_ uint32_t*)0x40017484U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMA_TIMAICR_PTR   = (RW_ uint32_t*)0x40017488U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMA_TIMADIER5_PTR = (RW_ uint32_t*)0x4001748CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMA_CNTAR_PTR     = (RW_ uint32_t*)0x40017490U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMA_PERAR_PTR     = (RW_ uint32_t*)0x40017494U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMA_REPAR_PTR     = (RW_ uint32_t*)0x40017498U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMA_CMP1CAR_PTR   = (RW_ uint32_t*)0x400174A0U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMA_DTAR_PTR      = (RW_ uint32_t*)0x400174B8U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMA_RSTAR_PTR     = (RW_ uint32_t*)0x400174D4U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMA_CHPAR_PTR     = (RW_ uint32_t*)0x400174D8U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMA_OUTAR_PTR     = (RW_ uint32_t*)0x400174E4U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMA_FLTAR_PTR     = (RW_ uint32_t*)0x400174E8U;   /** @brief Timerx fault register */

    static RW_ uint32_t* const HRTIM_TIMA_CMPxAR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x400174A4U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t*)0x400174A8U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t*)0x400174ACU,   /** @brief Timerx compare 4 register */
      [1] = (RW_ uint32_t*)0x4001749CU   /** @brief Timerx compare 1 register */
    };

    static RO_ uint32_t* const HRTIM_TIMA_CPTxAR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x400174B4U,   /** @brief Timerx capture 2 register */
      [1] = (RO_ uint32_t*)0x400174B0U   /** @brief Timerx capture 1 register */
    };

    static RW_ uint32_t* const HRTIM_TIMA_SETAxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400174C4U,   /** @brief Timerx output2 set register */
      [1] = (RW_ uint32_t*)0x400174BCU   /** @brief Timerx output1 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMA_RSTAxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400174C8U,   /** @brief Timerx output2 reset register */
      [1] = (RW_ uint32_t*)0x400174C0U   /** @brief Timerx output1 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMA_EEFARx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400174D0U,   /** @brief Timerx external event filtering register 2 */
      [1] = (RW_ uint32_t*)0x400174CCU   /** @brief Timerx external event filtering register 1 */
    };

    static RW_ uint32_t* const HRTIM_TIMA_CPTxACR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400174E0U,   /** @brief CPT2xCR */
      [1] = (RW_ uint32_t*)0x400174DCU   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMA Register Reset Value Definitions ****/

    static const uint32_t HRTIM_TIMA_TIMACR_RST    = 0x00000000U;   /** @brief Timerx control register */
    static const uint32_t HRTIM_TIMA_TIMAISR_RST   = 0x00000000U;   /** @brief Timerx interrupt status register */
    static const uint32_t HRTIM_TIMA_TIMAICR_RST   = 0x00000000U;   /** @brief Timerx interrupt clear register */
    static const uint32_t HRTIM_TIMA_TIMADIER5_RST = 0x00000000U;   /** @brief TIMxDIER5 */
    static const uint32_t HRTIM_TIMA_CNTAR_RST     = 0x00000000U;   /** @brief Timerx counter register */
    static const uint32_t HRTIM_TIMA_PERAR_RST     = 0x0000FFFFU;   /** @brief Timerx period register */
    static const uint32_t HRTIM_TIMA_REPAR_RST     = 0x00000000U;   /** @brief Timerx repetition register */
    static const uint32_t HRTIM_TIMA_CMP1CAR_RST   = 0x00000000U;   /** @brief Timerx compare 1 compound register */
    static const uint32_t HRTIM_TIMA_DTAR_RST      = 0x00000000U;   /** @brief Timerx deadtime register */
    static const uint32_t HRTIM_TIMA_RSTAR_RST     = 0x00000000U;   /** @brief TimerA reset register */
    static const uint32_t HRTIM_TIMA_CHPAR_RST     = 0x00000000U;   /** @brief Timerx chopper register */
    static const uint32_t HRTIM_TIMA_OUTAR_RST     = 0x00000000U;   /** @brief Timerx output register */
    static const uint32_t HRTIM_TIMA_FLTAR_RST     = 0x00000000U;   /** @brief Timerx fault register */

    static const uint32_t HRTIM_TIMA_CMPxAR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Timerx compare 2 register */
      [3] = 0x00000000U,   /** @brief Timerx compare 3 register */
      [4] = 0x00000000U,   /** @brief Timerx compare 4 register */
      [1] = 0x00000000U   /** @brief Timerx compare 1 register */
    };

    static const uint32_t HRTIM_TIMA_CPTxAR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx capture 2 register */
      [1] = 0x00000000U   /** @brief Timerx capture 1 register */
    };

    static const uint32_t HRTIM_TIMA_SETAxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 set register */
      [1] = 0x00000000U   /** @brief Timerx output1 set register */
    };

    static const uint32_t HRTIM_TIMA_RSTAxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 reset register */
      [1] = 0x00000000U   /** @brief Timerx output1 reset register */
    };

    static const uint32_t HRTIM_TIMA_EEFARx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx external event filtering register 2 */
      [1] = 0x00000000U   /** @brief Timerx external event filtering register 1 */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_RST[3] = {
      [2] = 0x00000000U,   /** @brief CPT2xCR */
      [1] = 0x00000000U   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMA Register Value Type Definitions ****/

    typedef uint32_t HRTIM_TIMA_TIMACR_vt;      /** @brief HRTIM_TIMA_TIMACR register value type. */
    typedef uint32_t HRTIM_TIMA_TIMAISR_vt;     /** @brief HRTIM_TIMA_TIMAISR register value type. */
    typedef uint32_t HRTIM_TIMA_TIMAICR_vt;     /** @brief HRTIM_TIMA_TIMAICR register value type. */
    typedef uint32_t HRTIM_TIMA_TIMADIER5_vt;   /** @brief HRTIM_TIMA_TIMADIER5 register value type. */
    typedef uint32_t HRTIM_TIMA_CNTAR_vt;       /** @brief HRTIM_TIMA_CNTAR register value type. */
    typedef uint32_t HRTIM_TIMA_PERAR_vt;       /** @brief HRTIM_TIMA_PERAR register value type. */
    typedef uint32_t HRTIM_TIMA_REPAR_vt;       /** @brief HRTIM_TIMA_REPAR register value type. */
    typedef uint32_t HRTIM_TIMA_CMPxAR_vt;      /** @brief HRTIM_TIMA_CMPxAR register value type. */
    typedef uint32_t HRTIM_TIMA_CMP1CAR_vt;     /** @brief HRTIM_TIMA_CMP1CAR register value type. */
    typedef uint32_t HRTIM_TIMA_CPTxAR_vt;      /** @brief HRTIM_TIMA_CPTxAR register value type. */
    typedef uint32_t HRTIM_TIMA_DTAR_vt;        /** @brief HRTIM_TIMA_DTAR register value type. */
    typedef uint32_t HRTIM_TIMA_SETAxR_vt;      /** @brief HRTIM_TIMA_SETAxR register value type. */
    typedef uint32_t HRTIM_TIMA_RSTAxR_vt;      /** @brief HRTIM_TIMA_RSTAxR register value type. */
    typedef uint32_t HRTIM_TIMA_EEFARx_vt;      /** @brief HRTIM_TIMA_EEFARx register value type. */
    typedef uint32_t HRTIM_TIMA_RSTAR_vt;       /** @brief HRTIM_TIMA_RSTAR register value type. */
    typedef uint32_t HRTIM_TIMA_CHPAR_vt;       /** @brief HRTIM_TIMA_CHPAR register value type. */
    typedef uint32_t HRTIM_TIMA_CPTxACR_vt;     /** @brief HRTIM_TIMA_CPTxACR register value type. */
    typedef uint32_t HRTIM_TIMA_OUTAR_vt;       /** @brief HRTIM_TIMA_OUTAR register value type. */
    typedef uint32_t HRTIM_TIMA_FLTAR_vt;       /** @brief HRTIM_TIMA_FLTAR register value type. */

    /**** @subsection HRTIM_TIMA Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HRTIM_TIMA_TIMACR_pt;      /** @brief HRTIM_TIMA_TIMACR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMA_TIMAISR_pt;     /** @brief HRTIM_TIMA_TIMAISR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_TIMAICR_pt;     /** @brief HRTIM_TIMA_TIMAICR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_TIMADIER5_pt;   /** @brief HRTIM_TIMA_TIMADIER5 pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_CNTAR_pt;       /** @brief HRTIM_TIMA_CNTAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_PERAR_pt;       /** @brief HRTIM_TIMA_PERAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_REPAR_pt;       /** @brief HRTIM_TIMA_REPAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_CMPxAR_pt;      /** @brief HRTIM_TIMA_CMPxAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_CMP1CAR_pt;     /** @brief HRTIM_TIMA_CMP1CAR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMA_CPTxAR_pt;      /** @brief HRTIM_TIMA_CPTxAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_DTAR_pt;        /** @brief HRTIM_TIMA_DTAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_SETAxR_pt;      /** @brief HRTIM_TIMA_SETAxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_RSTAxR_pt;      /** @brief HRTIM_TIMA_RSTAxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_EEFARx_pt;      /** @brief HRTIM_TIMA_EEFARx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_RSTAR_pt;       /** @brief HRTIM_TIMA_RSTAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_CHPAR_pt;       /** @brief HRTIM_TIMA_CHPAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_CPTxACR_pt;     /** @brief HRTIM_TIMA_CPTxACR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_OUTAR_pt;       /** @brief HRTIM_TIMA_OUTAR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMA_FLTAR_pt;       /** @brief HRTIM_TIMA_FLTAR pointer register pointer type. */

    /**** @subsection HRTIM_TIMA Field Mask Definitions ****/

    static const uint32_t HRTIM_TIMA_TIMACR_CK_PSCX_MASK = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMA_CNTAR_CNTX_MASK     = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMA_PERAR_PERX_MASK     = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMA_REPAR_REPX_MASK     = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMA_CMP1CAR_CMP1X_MASK  = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMA_DTAR_DTRX_MASK      = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMA_RSTAR_UPDT_MASK     = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMA_CHPAR_CHPFRQ_MASK   = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMA_OUTAR_DTEN_MASK     = 0x00000100U;   /** @brief Deadtime enable */

    static const uint32_t HRTIM_TIMA_TIMAISR_CMPx_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMA_TIMAICR_CMPxC_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMA_TIMADIER5_CMPxIE_MASK[5] = {
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [4] = 0x00000008U   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMA_CMPxAR_CMPxX_MASK[5] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx compare 2 value */
      [3] = 0x0000FFFFU,   /** @brief Timerx compare 3 value */
      [4] = 0x0000FFFFU,   /** @brief Timerx compare 4 value */
      [1] = 0x0000FFFFU   /** @brief Timerx compare 1 value */
    };

    static const uint32_t HRTIM_TIMA_CPTxAR_CPTxX_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx capture 2 value */
      [1] = 0x0000FFFFU   /** @brief Timerx capture 1 value */
    };

    static const uint32_t HRTIM_TIMA_SETAxR_SST_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SST */
      [1] = 0x00000001U   /** @brief Software set trigger */
    };

    static const uint32_t HRTIM_TIMA_RSTAxR_SRT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SRT */
      [1] = 0x00000001U   /** @brief SRT */
    };

    static const uint32_t HRTIM_TIMA_CPTxACR_SWCPT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Software capture */
      [1] = 0x00000001U   /** @brief Software capture */
    };

    static const uint32_t HRTIM_TIMA_FLTAR_FLTxEN_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [5] = 0x00000010U   /** @brief Fault 5 enable */
    };

    static const uint32_t HRTIM_TIMA_EEFARx_EExLTCH_MASK[3][11] = {
      [2] = {
        [10] = 0x01000000U,   /** @brief External event 10 latch */
        [9]  = 0x00040000U,   /** @brief External event 9 latch */
        [8]  = 0x00001000U,   /** @brief External event 8 latch */
        [7]  = 0x00000040U,   /** @brief External event 7 latch */
        [6]  = 0x00000001U   /** @brief External event 6 latch */
      },
      [1] = {
        [4] = 0x00040000U,   /** @brief External event 4 latch */
        [3] = 0x00001000U,   /** @brief External event 3 latch */
        [2] = 0x00000040U,   /** @brief External event 2 latch */
        [1] = 0x00000001U,   /** @brief External event 1 latch */
        [5] = 0x01000000U   /** @brief External event 5 latch */
      }
    };

    /**********************************************************************************************
     * @section HRTIM_TIMB Register Definitions
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMB Register Pointer Definitions ****/

    static RW_ uint32_t* const HRTIM_TIMB_TIMBCR_PTR    = (RW_ uint32_t*)0x40017500U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMB_TIMBISR_PTR   = (RO_ uint32_t*)0x40017504U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMB_TIMBICR_PTR   = (RW_ uint32_t*)0x40017508U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMB_TIMBDIER5_PTR = (RW_ uint32_t*)0x4001750CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMB_CNTR_PTR      = (RW_ uint32_t*)0x40017510U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMB_PERBR_PTR     = (RW_ uint32_t*)0x40017514U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMB_REPBR_PTR     = (RW_ uint32_t*)0x40017518U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMB_CMP1CBR_PTR   = (RW_ uint32_t*)0x40017520U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMB_DTBR_PTR      = (RW_ uint32_t*)0x40017538U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMB_RSTBR_PTR     = (RW_ uint32_t*)0x40017554U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMB_CHPBR_PTR     = (RW_ uint32_t*)0x40017558U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMB_OUTBR_PTR     = (RW_ uint32_t*)0x40017564U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMB_FLTBR_PTR     = (RW_ uint32_t*)0x40017568U;   /** @brief Timerx fault register */

    static RW_ uint32_t* const HRTIM_TIMB_CMPxBR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x40017524U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t*)0x40017528U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t*)0x4001752CU,   /** @brief Timerx compare 4 register */
      [1] = (RW_ uint32_t*)0x4001751CU   /** @brief Timerx compare 1 register */
    };

    static RO_ uint32_t* const HRTIM_TIMB_CPTxBR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40017534U,   /** @brief Timerx capture 2 register */
      [1] = (RO_ uint32_t*)0x40017530U   /** @brief Timerx capture 1 register */
    };

    static RW_ uint32_t* const HRTIM_TIMB_SETBxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017544U,   /** @brief Timerx output2 set register */
      [1] = (RW_ uint32_t*)0x4001753CU   /** @brief Timerx output1 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMB_RSTBxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017548U,   /** @brief Timerx output2 reset register */
      [1] = (RW_ uint32_t*)0x40017540U   /** @brief Timerx output1 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMB_EEFBRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017550U,   /** @brief Timerx external event filtering register 2 */
      [1] = (RW_ uint32_t*)0x4001754CU   /** @brief Timerx external event filtering register 1 */
    };

    static RW_ uint32_t* const HRTIM_TIMB_CPTxBCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017560U,   /** @brief CPT2xCR */
      [1] = (RW_ uint32_t*)0x4001755CU   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMB Register Reset Value Definitions ****/

    static const uint32_t HRTIM_TIMB_TIMBCR_RST    = 0x00000000U;   /** @brief Timerx control register */
    static const uint32_t HRTIM_TIMB_TIMBISR_RST   = 0x00000000U;   /** @brief Timerx interrupt status register */
    static const uint32_t HRTIM_TIMB_TIMBICR_RST   = 0x00000000U;   /** @brief Timerx interrupt clear register */
    static const uint32_t HRTIM_TIMB_TIMBDIER5_RST = 0x00000000U;   /** @brief TIMxDIER5 */
    static const uint32_t HRTIM_TIMB_CNTR_RST      = 0x00000000U;   /** @brief Timerx counter register */
    static const uint32_t HRTIM_TIMB_PERBR_RST     = 0x0000FFFFU;   /** @brief Timerx period register */
    static const uint32_t HRTIM_TIMB_REPBR_RST     = 0x00000000U;   /** @brief Timerx repetition register */
    static const uint32_t HRTIM_TIMB_CMP1CBR_RST   = 0x00000000U;   /** @brief Timerx compare 1 compound register */
    static const uint32_t HRTIM_TIMB_DTBR_RST      = 0x00000000U;   /** @brief Timerx deadtime register */
    static const uint32_t HRTIM_TIMB_RSTBR_RST     = 0x00000000U;   /** @brief TimerA reset register */
    static const uint32_t HRTIM_TIMB_CHPBR_RST     = 0x00000000U;   /** @brief Timerx chopper register */
    static const uint32_t HRTIM_TIMB_OUTBR_RST     = 0x00000000U;   /** @brief Timerx output register */
    static const uint32_t HRTIM_TIMB_FLTBR_RST     = 0x00000000U;   /** @brief Timerx fault register */

    static const uint32_t HRTIM_TIMB_CMPxBR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Timerx compare 2 register */
      [3] = 0x00000000U,   /** @brief Timerx compare 3 register */
      [4] = 0x00000000U,   /** @brief Timerx compare 4 register */
      [1] = 0x00000000U   /** @brief Timerx compare 1 register */
    };

    static const uint32_t HRTIM_TIMB_CPTxBR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx capture 2 register */
      [1] = 0x00000000U   /** @brief Timerx capture 1 register */
    };

    static const uint32_t HRTIM_TIMB_SETBxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 set register */
      [1] = 0x00000000U   /** @brief Timerx output1 set register */
    };

    static const uint32_t HRTIM_TIMB_RSTBxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 reset register */
      [1] = 0x00000000U   /** @brief Timerx output1 reset register */
    };

    static const uint32_t HRTIM_TIMB_EEFBRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx external event filtering register 2 */
      [1] = 0x00000000U   /** @brief Timerx external event filtering register 1 */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief CPT2xCR */
      [1] = 0x00000000U   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMB Register Value Type Definitions ****/

    typedef uint32_t HRTIM_TIMB_TIMBCR_vt;      /** @brief HRTIM_TIMB_TIMBCR register value type. */
    typedef uint32_t HRTIM_TIMB_TIMBISR_vt;     /** @brief HRTIM_TIMB_TIMBISR register value type. */
    typedef uint32_t HRTIM_TIMB_TIMBICR_vt;     /** @brief HRTIM_TIMB_TIMBICR register value type. */
    typedef uint32_t HRTIM_TIMB_TIMBDIER5_vt;   /** @brief HRTIM_TIMB_TIMBDIER5 register value type. */
    typedef uint32_t HRTIM_TIMB_CNTR_vt;        /** @brief HRTIM_TIMB_CNTR register value type. */
    typedef uint32_t HRTIM_TIMB_PERBR_vt;       /** @brief HRTIM_TIMB_PERBR register value type. */
    typedef uint32_t HRTIM_TIMB_REPBR_vt;       /** @brief HRTIM_TIMB_REPBR register value type. */
    typedef uint32_t HRTIM_TIMB_CMPxBR_vt;      /** @brief HRTIM_TIMB_CMPxBR register value type. */
    typedef uint32_t HRTIM_TIMB_CMP1CBR_vt;     /** @brief HRTIM_TIMB_CMP1CBR register value type. */
    typedef uint32_t HRTIM_TIMB_CPTxBR_vt;      /** @brief HRTIM_TIMB_CPTxBR register value type. */
    typedef uint32_t HRTIM_TIMB_DTBR_vt;        /** @brief HRTIM_TIMB_DTBR register value type. */
    typedef uint32_t HRTIM_TIMB_SETBxR_vt;      /** @brief HRTIM_TIMB_SETBxR register value type. */
    typedef uint32_t HRTIM_TIMB_RSTBxR_vt;      /** @brief HRTIM_TIMB_RSTBxR register value type. */
    typedef uint32_t HRTIM_TIMB_EEFBRx_vt;      /** @brief HRTIM_TIMB_EEFBRx register value type. */
    typedef uint32_t HRTIM_TIMB_RSTBR_vt;       /** @brief HRTIM_TIMB_RSTBR register value type. */
    typedef uint32_t HRTIM_TIMB_CHPBR_vt;       /** @brief HRTIM_TIMB_CHPBR register value type. */
    typedef uint32_t HRTIM_TIMB_CPTxBCR_vt;     /** @brief HRTIM_TIMB_CPTxBCR register value type. */
    typedef uint32_t HRTIM_TIMB_OUTBR_vt;       /** @brief HRTIM_TIMB_OUTBR register value type. */
    typedef uint32_t HRTIM_TIMB_FLTBR_vt;       /** @brief HRTIM_TIMB_FLTBR register value type. */

    /**** @subsection HRTIM_TIMB Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HRTIM_TIMB_TIMBCR_pt;      /** @brief HRTIM_TIMB_TIMBCR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMB_TIMBISR_pt;     /** @brief HRTIM_TIMB_TIMBISR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_TIMBICR_pt;     /** @brief HRTIM_TIMB_TIMBICR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_TIMBDIER5_pt;   /** @brief HRTIM_TIMB_TIMBDIER5 pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_CNTR_pt;        /** @brief HRTIM_TIMB_CNTR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_PERBR_pt;       /** @brief HRTIM_TIMB_PERBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_REPBR_pt;       /** @brief HRTIM_TIMB_REPBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_CMPxBR_pt;      /** @brief HRTIM_TIMB_CMPxBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_CMP1CBR_pt;     /** @brief HRTIM_TIMB_CMP1CBR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMB_CPTxBR_pt;      /** @brief HRTIM_TIMB_CPTxBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_DTBR_pt;        /** @brief HRTIM_TIMB_DTBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_SETBxR_pt;      /** @brief HRTIM_TIMB_SETBxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_RSTBxR_pt;      /** @brief HRTIM_TIMB_RSTBxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_EEFBRx_pt;      /** @brief HRTIM_TIMB_EEFBRx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_RSTBR_pt;       /** @brief HRTIM_TIMB_RSTBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_CHPBR_pt;       /** @brief HRTIM_TIMB_CHPBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_CPTxBCR_pt;     /** @brief HRTIM_TIMB_CPTxBCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_OUTBR_pt;       /** @brief HRTIM_TIMB_OUTBR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMB_FLTBR_pt;       /** @brief HRTIM_TIMB_FLTBR pointer register pointer type. */

    /**** @subsection HRTIM_TIMB Field Mask Definitions ****/

    static const uint32_t HRTIM_TIMB_TIMBCR_CK_PSCX_MASK = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMB_CNTR_CNTX_MASK      = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMB_PERBR_PERX_MASK     = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMB_REPBR_REPX_MASK     = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMB_CMP1CBR_CMP1X_MASK  = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMB_DTBR_DTRX_MASK      = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMB_RSTBR_UPDT_MASK     = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMB_CHPBR_CHPFRQ_MASK   = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMB_OUTBR_DTEN_MASK     = 0x00000100U;   /** @brief Deadtime enable */

    static const uint32_t HRTIM_TIMB_TIMBISR_CMPx_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMB_TIMBICR_CMPxC_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMB_TIMBDIER5_CMPxIE_MASK[5] = {
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [4] = 0x00000008U   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMB_CMPxBR_CMPxX_MASK[5] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx compare 2 value */
      [3] = 0x0000FFFFU,   /** @brief Timerx compare 3 value */
      [4] = 0x0000FFFFU,   /** @brief Timerx compare 4 value */
      [1] = 0x0000FFFFU   /** @brief Timerx compare 1 value */
    };

    static const uint32_t HRTIM_TIMB_CPTxBR_CPTxX_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx capture 2 value */
      [1] = 0x0000FFFFU   /** @brief Timerx capture 1 value */
    };

    static const uint32_t HRTIM_TIMB_SETBxR_SST_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SST */
      [1] = 0x00000001U   /** @brief Software set trigger */
    };

    static const uint32_t HRTIM_TIMB_RSTBxR_SRT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SRT */
      [1] = 0x00000001U   /** @brief SRT */
    };

    static const uint32_t HRTIM_TIMB_CPTxBCR_SWCPT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Software capture */
      [1] = 0x00000001U   /** @brief Software capture */
    };

    static const uint32_t HRTIM_TIMB_FLTBR_FLTxEN_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [5] = 0x00000010U   /** @brief Fault 5 enable */
    };

    static const uint32_t HRTIM_TIMB_EEFBRx_EExLTCH_MASK[3][11] = {
      [2] = {
        [10] = 0x01000000U,   /** @brief External event 10 latch */
        [9]  = 0x00040000U,   /** @brief External event 9 latch */
        [8]  = 0x00001000U,   /** @brief External event 8 latch */
        [7]  = 0x00000040U,   /** @brief External event 7 latch */
        [6]  = 0x00000001U   /** @brief External event 6 latch */
      },
      [1] = {
        [4] = 0x00040000U,   /** @brief External event 4 latch */
        [3] = 0x00001000U,   /** @brief External event 3 latch */
        [2] = 0x00000040U,   /** @brief External event 2 latch */
        [1] = 0x00000001U,   /** @brief External event 1 latch */
        [5] = 0x01000000U   /** @brief External event 5 latch */
      }
    };

    /**********************************************************************************************
     * @section HRTIM_TIMC Register Definitions
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMC Register Pointer Definitions ****/

    static RW_ uint32_t* const HRTIM_TIMC_TIMCCR_PTR    = (RW_ uint32_t*)0x40017580U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMC_TIMCISR_PTR   = (RO_ uint32_t*)0x40017584U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMC_TIMCICR_PTR   = (RW_ uint32_t*)0x40017588U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMC_TIMCDIER5_PTR = (RW_ uint32_t*)0x4001758CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMC_CNTCR_PTR     = (RW_ uint32_t*)0x40017590U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMC_PERCR_PTR     = (RW_ uint32_t*)0x40017594U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMC_REPCR_PTR     = (RW_ uint32_t*)0x40017598U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMC_CMP1CCR_PTR   = (RW_ uint32_t*)0x400175A0U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMC_DTCR_PTR      = (RW_ uint32_t*)0x400175B8U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMC_RSTCR_PTR     = (RW_ uint32_t*)0x400175D4U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMC_CHPCR_PTR     = (RW_ uint32_t*)0x400175D8U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMC_OUTCR_PTR     = (RW_ uint32_t*)0x400175E4U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMC_FLTCR_PTR     = (RW_ uint32_t*)0x400175E8U;   /** @brief Timerx fault register */

    static RW_ uint32_t* const HRTIM_TIMC_CMPxCR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x400175A4U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t*)0x400175A8U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t*)0x400175ACU,   /** @brief Timerx compare 4 register */
      [1] = (RW_ uint32_t*)0x4001759CU   /** @brief Timerx compare 1 register */
    };

    static RO_ uint32_t* const HRTIM_TIMC_CPTxCR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x400175B4U,   /** @brief Timerx capture 2 register */
      [1] = (RO_ uint32_t*)0x400175B0U   /** @brief Timerx capture 1 register */
    };

    static RW_ uint32_t* const HRTIM_TIMC_SETCxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400175C4U,   /** @brief Timerx output2 set register */
      [1] = (RW_ uint32_t*)0x400175BCU   /** @brief Timerx output1 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMC_RSTCxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400175C8U,   /** @brief Timerx output2 reset register */
      [1] = (RW_ uint32_t*)0x400175C0U   /** @brief Timerx output1 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMC_EEFCRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400175D0U,   /** @brief Timerx external event filtering register 2 */
      [1] = (RW_ uint32_t*)0x400175CCU   /** @brief Timerx external event filtering register 1 */
    };

    static RW_ uint32_t* const HRTIM_TIMC_CPTxCCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400175E0U,   /** @brief CPT2xCR */
      [1] = (RW_ uint32_t*)0x400175DCU   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMC Register Reset Value Definitions ****/

    static const uint32_t HRTIM_TIMC_TIMCCR_RST    = 0x00000000U;   /** @brief Timerx control register */
    static const uint32_t HRTIM_TIMC_TIMCISR_RST   = 0x00000000U;   /** @brief Timerx interrupt status register */
    static const uint32_t HRTIM_TIMC_TIMCICR_RST   = 0x00000000U;   /** @brief Timerx interrupt clear register */
    static const uint32_t HRTIM_TIMC_TIMCDIER5_RST = 0x00000000U;   /** @brief TIMxDIER5 */
    static const uint32_t HRTIM_TIMC_CNTCR_RST     = 0x00000000U;   /** @brief Timerx counter register */
    static const uint32_t HRTIM_TIMC_PERCR_RST     = 0x0000FFFFU;   /** @brief Timerx period register */
    static const uint32_t HRTIM_TIMC_REPCR_RST     = 0x00000000U;   /** @brief Timerx repetition register */
    static const uint32_t HRTIM_TIMC_CMP1CCR_RST   = 0x00000000U;   /** @brief Timerx compare 1 compound register */
    static const uint32_t HRTIM_TIMC_DTCR_RST      = 0x00000000U;   /** @brief Timerx deadtime register */
    static const uint32_t HRTIM_TIMC_RSTCR_RST     = 0x00000000U;   /** @brief TimerA reset register */
    static const uint32_t HRTIM_TIMC_CHPCR_RST     = 0x00000000U;   /** @brief Timerx chopper register */
    static const uint32_t HRTIM_TIMC_OUTCR_RST     = 0x00000000U;   /** @brief Timerx output register */
    static const uint32_t HRTIM_TIMC_FLTCR_RST     = 0x00000000U;   /** @brief Timerx fault register */

    static const uint32_t HRTIM_TIMC_CMPxCR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Timerx compare 2 register */
      [3] = 0x00000000U,   /** @brief Timerx compare 3 register */
      [4] = 0x00000000U,   /** @brief Timerx compare 4 register */
      [1] = 0x00000000U   /** @brief Timerx compare 1 register */
    };

    static const uint32_t HRTIM_TIMC_CPTxCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx capture 2 register */
      [1] = 0x00000000U   /** @brief Timerx capture 1 register */
    };

    static const uint32_t HRTIM_TIMC_SETCxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 set register */
      [1] = 0x00000000U   /** @brief Timerx output1 set register */
    };

    static const uint32_t HRTIM_TIMC_RSTCxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 reset register */
      [1] = 0x00000000U   /** @brief Timerx output1 reset register */
    };

    static const uint32_t HRTIM_TIMC_EEFCRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx external event filtering register 2 */
      [1] = 0x00000000U   /** @brief Timerx external event filtering register 1 */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief CPT2xCR */
      [1] = 0x00000000U   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMC Register Value Type Definitions ****/

    typedef uint32_t HRTIM_TIMC_TIMCCR_vt;      /** @brief HRTIM_TIMC_TIMCCR register value type. */
    typedef uint32_t HRTIM_TIMC_TIMCISR_vt;     /** @brief HRTIM_TIMC_TIMCISR register value type. */
    typedef uint32_t HRTIM_TIMC_TIMCICR_vt;     /** @brief HRTIM_TIMC_TIMCICR register value type. */
    typedef uint32_t HRTIM_TIMC_TIMCDIER5_vt;   /** @brief HRTIM_TIMC_TIMCDIER5 register value type. */
    typedef uint32_t HRTIM_TIMC_CNTCR_vt;       /** @brief HRTIM_TIMC_CNTCR register value type. */
    typedef uint32_t HRTIM_TIMC_PERCR_vt;       /** @brief HRTIM_TIMC_PERCR register value type. */
    typedef uint32_t HRTIM_TIMC_REPCR_vt;       /** @brief HRTIM_TIMC_REPCR register value type. */
    typedef uint32_t HRTIM_TIMC_CMPxCR_vt;      /** @brief HRTIM_TIMC_CMPxCR register value type. */
    typedef uint32_t HRTIM_TIMC_CMP1CCR_vt;     /** @brief HRTIM_TIMC_CMP1CCR register value type. */
    typedef uint32_t HRTIM_TIMC_CPTxCR_vt;      /** @brief HRTIM_TIMC_CPTxCR register value type. */
    typedef uint32_t HRTIM_TIMC_DTCR_vt;        /** @brief HRTIM_TIMC_DTCR register value type. */
    typedef uint32_t HRTIM_TIMC_SETCxR_vt;      /** @brief HRTIM_TIMC_SETCxR register value type. */
    typedef uint32_t HRTIM_TIMC_RSTCxR_vt;      /** @brief HRTIM_TIMC_RSTCxR register value type. */
    typedef uint32_t HRTIM_TIMC_EEFCRx_vt;      /** @brief HRTIM_TIMC_EEFCRx register value type. */
    typedef uint32_t HRTIM_TIMC_RSTCR_vt;       /** @brief HRTIM_TIMC_RSTCR register value type. */
    typedef uint32_t HRTIM_TIMC_CHPCR_vt;       /** @brief HRTIM_TIMC_CHPCR register value type. */
    typedef uint32_t HRTIM_TIMC_CPTxCCR_vt;     /** @brief HRTIM_TIMC_CPTxCCR register value type. */
    typedef uint32_t HRTIM_TIMC_OUTCR_vt;       /** @brief HRTIM_TIMC_OUTCR register value type. */
    typedef uint32_t HRTIM_TIMC_FLTCR_vt;       /** @brief HRTIM_TIMC_FLTCR register value type. */

    /**** @subsection HRTIM_TIMC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HRTIM_TIMC_TIMCCR_pt;      /** @brief HRTIM_TIMC_TIMCCR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMC_TIMCISR_pt;     /** @brief HRTIM_TIMC_TIMCISR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_TIMCICR_pt;     /** @brief HRTIM_TIMC_TIMCICR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_TIMCDIER5_pt;   /** @brief HRTIM_TIMC_TIMCDIER5 pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_CNTCR_pt;       /** @brief HRTIM_TIMC_CNTCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_PERCR_pt;       /** @brief HRTIM_TIMC_PERCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_REPCR_pt;       /** @brief HRTIM_TIMC_REPCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_CMPxCR_pt;      /** @brief HRTIM_TIMC_CMPxCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_CMP1CCR_pt;     /** @brief HRTIM_TIMC_CMP1CCR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMC_CPTxCR_pt;      /** @brief HRTIM_TIMC_CPTxCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_DTCR_pt;        /** @brief HRTIM_TIMC_DTCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_SETCxR_pt;      /** @brief HRTIM_TIMC_SETCxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_RSTCxR_pt;      /** @brief HRTIM_TIMC_RSTCxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_EEFCRx_pt;      /** @brief HRTIM_TIMC_EEFCRx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_RSTCR_pt;       /** @brief HRTIM_TIMC_RSTCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_CHPCR_pt;       /** @brief HRTIM_TIMC_CHPCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_CPTxCCR_pt;     /** @brief HRTIM_TIMC_CPTxCCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_OUTCR_pt;       /** @brief HRTIM_TIMC_OUTCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMC_FLTCR_pt;       /** @brief HRTIM_TIMC_FLTCR pointer register pointer type. */

    /**** @subsection HRTIM_TIMC Field Mask Definitions ****/

    static const uint32_t HRTIM_TIMC_TIMCCR_CK_PSCX_MASK = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMC_CNTCR_CNTX_MASK     = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMC_PERCR_PERX_MASK     = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMC_REPCR_REPX_MASK     = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMC_CMP1CCR_CMP1X_MASK  = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMC_DTCR_DTRX_MASK      = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMC_RSTCR_UPDT_MASK     = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMC_CHPCR_CHPFRQ_MASK   = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMC_OUTCR_DTEN_MASK     = 0x00000100U;   /** @brief Deadtime enable */

    static const uint32_t HRTIM_TIMC_TIMCISR_CMPx_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMC_TIMCICR_CMPxC_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMC_TIMCDIER5_CMPxIE_MASK[5] = {
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [4] = 0x00000008U   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMC_CMPxCR_CMPxX_MASK[5] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx compare 2 value */
      [3] = 0x0000FFFFU,   /** @brief Timerx compare 3 value */
      [4] = 0x0000FFFFU,   /** @brief Timerx compare 4 value */
      [1] = 0x0000FFFFU   /** @brief Timerx compare 1 value */
    };

    static const uint32_t HRTIM_TIMC_CPTxCR_CPTxX_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx capture 2 value */
      [1] = 0x0000FFFFU   /** @brief Timerx capture 1 value */
    };

    static const uint32_t HRTIM_TIMC_SETCxR_SST_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SST */
      [1] = 0x00000001U   /** @brief Software set trigger */
    };

    static const uint32_t HRTIM_TIMC_RSTCxR_SRT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SRT */
      [1] = 0x00000001U   /** @brief SRT */
    };

    static const uint32_t HRTIM_TIMC_CPTxCCR_SWCPT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Software capture */
      [1] = 0x00000001U   /** @brief Software capture */
    };

    static const uint32_t HRTIM_TIMC_FLTCR_FLTxEN_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [5] = 0x00000010U   /** @brief Fault 5 enable */
    };

    static const uint32_t HRTIM_TIMC_EEFCRx_EExLTCH_MASK[3][11] = {
      [2] = {
        [10] = 0x01000000U,   /** @brief External event 10 latch */
        [9]  = 0x00040000U,   /** @brief External event 9 latch */
        [8]  = 0x00001000U,   /** @brief External event 8 latch */
        [7]  = 0x00000040U,   /** @brief External event 7 latch */
        [6]  = 0x00000001U   /** @brief External event 6 latch */
      },
      [1] = {
        [4] = 0x00040000U,   /** @brief External event 4 latch */
        [3] = 0x00001000U,   /** @brief External event 3 latch */
        [2] = 0x00000040U,   /** @brief External event 2 latch */
        [1] = 0x00000001U,   /** @brief External event 1 latch */
        [5] = 0x01000000U   /** @brief External event 5 latch */
      }
    };

    /**********************************************************************************************
     * @section HRTIM_TIMD Register Definitions
     **********************************************************************************************/

    /**** @subsection HRTIM_TIMD Register Pointer Definitions ****/

    static RW_ uint32_t* const HRTIM_TIMD_TIMDCR_PTR    = (RW_ uint32_t*)0x40017600U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIMD_TIMDISR_PTR   = (RO_ uint32_t*)0x40017604U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIMD_TIMDICR_PTR   = (RW_ uint32_t*)0x40017608U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIMD_TIMDDIER5_PTR = (RW_ uint32_t*)0x4001760CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIMD_CNTDR_PTR     = (RW_ uint32_t*)0x40017610U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIMD_PERDR_PTR     = (RW_ uint32_t*)0x40017614U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIMD_REPDR_PTR     = (RW_ uint32_t*)0x40017618U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIMD_CMP1CDR_PTR   = (RW_ uint32_t*)0x40017620U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIMD_DTDR_PTR      = (RW_ uint32_t*)0x40017638U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIMD_RSTDR_PTR     = (RW_ uint32_t*)0x40017654U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIMD_CHPDR_PTR     = (RW_ uint32_t*)0x40017658U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIMD_OUTDR_PTR     = (RW_ uint32_t*)0x40017664U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIMD_FLTDR_PTR     = (RW_ uint32_t*)0x40017668U;   /** @brief Timerx fault register */

    static RW_ uint32_t* const HRTIM_TIMD_CMPxDR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x40017624U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t*)0x40017628U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t*)0x4001762CU,   /** @brief Timerx compare 4 register */
      [1] = (RW_ uint32_t*)0x4001761CU   /** @brief Timerx compare 1 register */
    };

    static RO_ uint32_t* const HRTIM_TIMD_CPTxDR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x40017634U,   /** @brief Timerx capture 2 register */
      [1] = (RO_ uint32_t*)0x40017630U   /** @brief Timerx capture 1 register */
    };

    static RW_ uint32_t* const HRTIM_TIMD_SETDxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017644U,   /** @brief Timerx output2 set register */
      [1] = (RW_ uint32_t*)0x4001763CU   /** @brief Timerx output1 set register */
    };

    static RW_ uint32_t* const HRTIM_TIMD_RSTDxR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017648U,   /** @brief Timerx output2 reset register */
      [1] = (RW_ uint32_t*)0x40017640U   /** @brief Timerx output1 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIMD_EEFDRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017650U,   /** @brief Timerx external event filtering register 2 */
      [1] = (RW_ uint32_t*)0x4001764CU   /** @brief Timerx external event filtering register 1 */
    };

    static RW_ uint32_t* const HRTIM_TIMD_CPTxDCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017660U,   /** @brief CPT2xCR */
      [1] = (RW_ uint32_t*)0x4001765CU   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMD Register Reset Value Definitions ****/

    static const uint32_t HRTIM_TIMD_TIMDCR_RST    = 0x00000000U;   /** @brief Timerx control register */
    static const uint32_t HRTIM_TIMD_TIMDISR_RST   = 0x00000000U;   /** @brief Timerx interrupt status register */
    static const uint32_t HRTIM_TIMD_TIMDICR_RST   = 0x00000000U;   /** @brief Timerx interrupt clear register */
    static const uint32_t HRTIM_TIMD_TIMDDIER5_RST = 0x00000000U;   /** @brief TIMxDIER5 */
    static const uint32_t HRTIM_TIMD_CNTDR_RST     = 0x00000000U;   /** @brief Timerx counter register */
    static const uint32_t HRTIM_TIMD_PERDR_RST     = 0x0000FFFFU;   /** @brief Timerx period register */
    static const uint32_t HRTIM_TIMD_REPDR_RST     = 0x00000000U;   /** @brief Timerx repetition register */
    static const uint32_t HRTIM_TIMD_CMP1CDR_RST   = 0x00000000U;   /** @brief Timerx compare 1 compound register */
    static const uint32_t HRTIM_TIMD_DTDR_RST      = 0x00000000U;   /** @brief Timerx deadtime register */
    static const uint32_t HRTIM_TIMD_RSTDR_RST     = 0x00000000U;   /** @brief TimerA reset register */
    static const uint32_t HRTIM_TIMD_CHPDR_RST     = 0x00000000U;   /** @brief Timerx chopper register */
    static const uint32_t HRTIM_TIMD_OUTDR_RST     = 0x00000000U;   /** @brief Timerx output register */
    static const uint32_t HRTIM_TIMD_FLTDR_RST     = 0x00000000U;   /** @brief Timerx fault register */

    static const uint32_t HRTIM_TIMD_CMPxDR_RST[5] = {
      [2] = 0x00000000U,   /** @brief Timerx compare 2 register */
      [3] = 0x00000000U,   /** @brief Timerx compare 3 register */
      [4] = 0x00000000U,   /** @brief Timerx compare 4 register */
      [1] = 0x00000000U   /** @brief Timerx compare 1 register */
    };

    static const uint32_t HRTIM_TIMD_CPTxDR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx capture 2 register */
      [1] = 0x00000000U   /** @brief Timerx capture 1 register */
    };

    static const uint32_t HRTIM_TIMD_SETDxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 set register */
      [1] = 0x00000000U   /** @brief Timerx output1 set register */
    };

    static const uint32_t HRTIM_TIMD_RSTDxR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 reset register */
      [1] = 0x00000000U   /** @brief Timerx output1 reset register */
    };

    static const uint32_t HRTIM_TIMD_EEFDRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx external event filtering register 2 */
      [1] = 0x00000000U   /** @brief Timerx external event filtering register 1 */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief CPT2xCR */
      [1] = 0x00000000U   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIMD Register Value Type Definitions ****/

    typedef uint32_t HRTIM_TIMD_TIMDCR_vt;      /** @brief HRTIM_TIMD_TIMDCR register value type. */
    typedef uint32_t HRTIM_TIMD_TIMDISR_vt;     /** @brief HRTIM_TIMD_TIMDISR register value type. */
    typedef uint32_t HRTIM_TIMD_TIMDICR_vt;     /** @brief HRTIM_TIMD_TIMDICR register value type. */
    typedef uint32_t HRTIM_TIMD_TIMDDIER5_vt;   /** @brief HRTIM_TIMD_TIMDDIER5 register value type. */
    typedef uint32_t HRTIM_TIMD_CNTDR_vt;       /** @brief HRTIM_TIMD_CNTDR register value type. */
    typedef uint32_t HRTIM_TIMD_PERDR_vt;       /** @brief HRTIM_TIMD_PERDR register value type. */
    typedef uint32_t HRTIM_TIMD_REPDR_vt;       /** @brief HRTIM_TIMD_REPDR register value type. */
    typedef uint32_t HRTIM_TIMD_CMPxDR_vt;      /** @brief HRTIM_TIMD_CMPxDR register value type. */
    typedef uint32_t HRTIM_TIMD_CMP1CDR_vt;     /** @brief HRTIM_TIMD_CMP1CDR register value type. */
    typedef uint32_t HRTIM_TIMD_CPTxDR_vt;      /** @brief HRTIM_TIMD_CPTxDR register value type. */
    typedef uint32_t HRTIM_TIMD_DTDR_vt;        /** @brief HRTIM_TIMD_DTDR register value type. */
    typedef uint32_t HRTIM_TIMD_SETDxR_vt;      /** @brief HRTIM_TIMD_SETDxR register value type. */
    typedef uint32_t HRTIM_TIMD_RSTDxR_vt;      /** @brief HRTIM_TIMD_RSTDxR register value type. */
    typedef uint32_t HRTIM_TIMD_EEFDRx_vt;      /** @brief HRTIM_TIMD_EEFDRx register value type. */
    typedef uint32_t HRTIM_TIMD_RSTDR_vt;       /** @brief HRTIM_TIMD_RSTDR register value type. */
    typedef uint32_t HRTIM_TIMD_CHPDR_vt;       /** @brief HRTIM_TIMD_CHPDR register value type. */
    typedef uint32_t HRTIM_TIMD_CPTxDCR_vt;     /** @brief HRTIM_TIMD_CPTxDCR register value type. */
    typedef uint32_t HRTIM_TIMD_OUTDR_vt;       /** @brief HRTIM_TIMD_OUTDR register value type. */
    typedef uint32_t HRTIM_TIMD_FLTDR_vt;       /** @brief HRTIM_TIMD_FLTDR register value type. */

    /**** @subsection HRTIM_TIMD Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HRTIM_TIMD_TIMDCR_pt;      /** @brief HRTIM_TIMD_TIMDCR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMD_TIMDISR_pt;     /** @brief HRTIM_TIMD_TIMDISR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_TIMDICR_pt;     /** @brief HRTIM_TIMD_TIMDICR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_TIMDDIER5_pt;   /** @brief HRTIM_TIMD_TIMDDIER5 pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_CNTDR_pt;       /** @brief HRTIM_TIMD_CNTDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_PERDR_pt;       /** @brief HRTIM_TIMD_PERDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_REPDR_pt;       /** @brief HRTIM_TIMD_REPDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_CMPxDR_pt;      /** @brief HRTIM_TIMD_CMPxDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_CMP1CDR_pt;     /** @brief HRTIM_TIMD_CMP1CDR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIMD_CPTxDR_pt;      /** @brief HRTIM_TIMD_CPTxDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_DTDR_pt;        /** @brief HRTIM_TIMD_DTDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_SETDxR_pt;      /** @brief HRTIM_TIMD_SETDxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_RSTDxR_pt;      /** @brief HRTIM_TIMD_RSTDxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_EEFDRx_pt;      /** @brief HRTIM_TIMD_EEFDRx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_RSTDR_pt;       /** @brief HRTIM_TIMD_RSTDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_CHPDR_pt;       /** @brief HRTIM_TIMD_CHPDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_CPTxDCR_pt;     /** @brief HRTIM_TIMD_CPTxDCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_OUTDR_pt;       /** @brief HRTIM_TIMD_OUTDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIMD_FLTDR_pt;       /** @brief HRTIM_TIMD_FLTDR pointer register pointer type. */

    /**** @subsection HRTIM_TIMD Field Mask Definitions ****/

    static const uint32_t HRTIM_TIMD_TIMDCR_CK_PSCX_MASK = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIMD_CNTDR_CNTX_MASK     = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIMD_PERDR_PERX_MASK     = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIMD_REPDR_REPX_MASK     = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIMD_CMP1CDR_CMP1X_MASK  = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIMD_DTDR_DTRX_MASK      = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIMD_RSTDR_UPDT_MASK     = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIMD_CHPDR_CHPFRQ_MASK   = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIMD_OUTDR_DTEN_MASK     = 0x00000100U;   /** @brief Deadtime enable */

    static const uint32_t HRTIM_TIMD_TIMDISR_CMPx_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIMD_TIMDICR_CMPxC_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIMD_TIMDDIER5_CMPxIE_MASK[5] = {
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [4] = 0x00000008U   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIMD_CMPxDR_CMPxX_MASK[5] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx compare 2 value */
      [3] = 0x0000FFFFU,   /** @brief Timerx compare 3 value */
      [4] = 0x0000FFFFU,   /** @brief Timerx compare 4 value */
      [1] = 0x0000FFFFU   /** @brief Timerx compare 1 value */
    };

    static const uint32_t HRTIM_TIMD_CPTxDR_CPTxX_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx capture 2 value */
      [1] = 0x0000FFFFU   /** @brief Timerx capture 1 value */
    };

    static const uint32_t HRTIM_TIMD_SETDxR_SST_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SST */
      [1] = 0x00000001U   /** @brief Software set trigger */
    };

    static const uint32_t HRTIM_TIMD_RSTDxR_SRT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SRT */
      [1] = 0x00000001U   /** @brief SRT */
    };

    static const uint32_t HRTIM_TIMD_CPTxDCR_SWCPT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Software capture */
      [1] = 0x00000001U   /** @brief Software capture */
    };

    static const uint32_t HRTIM_TIMD_FLTDR_FLTxEN_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [5] = 0x00000010U   /** @brief Fault 5 enable */
    };

    static const uint32_t HRTIM_TIMD_EEFDRx_EExLTCH_MASK[3][11] = {
      [2] = {
        [10] = 0x01000000U,   /** @brief External event 10 latch */
        [9]  = 0x00040000U,   /** @brief External event 9 latch */
        [8]  = 0x00001000U,   /** @brief External event 8 latch */
        [7]  = 0x00000040U,   /** @brief External event 7 latch */
        [6]  = 0x00000001U   /** @brief External event 6 latch */
      },
      [1] = {
        [4] = 0x00040000U,   /** @brief External event 4 latch */
        [3] = 0x00001000U,   /** @brief External event 3 latch */
        [2] = 0x00000040U,   /** @brief External event 2 latch */
        [1] = 0x00000001U,   /** @brief External event 1 latch */
        [5] = 0x01000000U   /** @brief External event 5 latch */
      }
    };

    /**********************************************************************************************
     * @section HRTIM_TIME Register Definitions
     **********************************************************************************************/

    /**** @subsection HRTIM_TIME Register Pointer Definitions ****/

    static RW_ uint32_t* const HRTIM_TIME_TIMECR_PTR    = (RW_ uint32_t*)0x40017680U;   /** @brief Timerx control register */
    static RO_ uint32_t* const HRTIM_TIME_TIMEISR_PTR   = (RO_ uint32_t*)0x40017684U;   /** @brief Timerx interrupt status register */
    static RW_ uint32_t* const HRTIM_TIME_TIMEICR_PTR   = (RW_ uint32_t*)0x40017688U;   /** @brief Timerx interrupt clear register */
    static RW_ uint32_t* const HRTIM_TIME_TIMEDIER5_PTR = (RW_ uint32_t*)0x4001768CU;   /** @brief TIMxDIER5 */
    static RW_ uint32_t* const HRTIM_TIME_CNTER_PTR     = (RW_ uint32_t*)0x40017690U;   /** @brief Timerx counter register */
    static RW_ uint32_t* const HRTIM_TIME_PERER_PTR     = (RW_ uint32_t*)0x40017694U;   /** @brief Timerx period register */
    static RW_ uint32_t* const HRTIM_TIME_REPER_PTR     = (RW_ uint32_t*)0x40017698U;   /** @brief Timerx repetition register */
    static RW_ uint32_t* const HRTIM_TIME_CMP1CER_PTR   = (RW_ uint32_t*)0x400176A0U;   /** @brief Timerx compare 1 compound register */
    static RW_ uint32_t* const HRTIM_TIME_DTER_PTR      = (RW_ uint32_t*)0x400176B8U;   /** @brief Timerx deadtime register */
    static RW_ uint32_t* const HRTIM_TIME_RSTER_PTR     = (RW_ uint32_t*)0x400176D4U;   /** @brief TimerA reset register */
    static RW_ uint32_t* const HRTIM_TIME_CHPER_PTR     = (RW_ uint32_t*)0x400176D8U;   /** @brief Timerx chopper register */
    static RW_ uint32_t* const HRTIM_TIME_OUTER_PTR     = (RW_ uint32_t*)0x400176E4U;   /** @brief Timerx output register */
    static RW_ uint32_t* const HRTIM_TIME_FLTER_PTR     = (RW_ uint32_t*)0x400176E8U;   /** @brief Timerx fault register */

    static RW_ uint32_t* const HRTIM_TIME_CMPxER_PTR[5] = {
      [2] = (RW_ uint32_t*)0x400176A4U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t*)0x400176A8U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t*)0x400176ACU,   /** @brief Timerx compare 4 register */
      [1] = (RW_ uint32_t*)0x4001769CU   /** @brief Timerx compare 1 register */
    };

    static RO_ uint32_t* const HRTIM_TIME_CPTxER_PTR[3] = {
      [2] = (RO_ uint32_t*)0x400176B4U,   /** @brief Timerx capture 2 register */
      [1] = (RO_ uint32_t*)0x400176B0U   /** @brief Timerx capture 1 register */
    };

    static RW_ uint32_t* const HRTIM_TIME_SETExR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400176C4U,   /** @brief Timerx output2 set register */
      [1] = (RW_ uint32_t*)0x400176BCU   /** @brief Timerx output1 set register */
    };

    static RW_ uint32_t* const HRTIM_TIME_RSTExR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400176C8U,   /** @brief Timerx output2 reset register */
      [1] = (RW_ uint32_t*)0x400176C0U   /** @brief Timerx output1 reset register */
    };

    static RW_ uint32_t* const HRTIM_TIME_EEFERx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400176D0U,   /** @brief Timerx external event filtering register 2 */
      [1] = (RW_ uint32_t*)0x400176CCU   /** @brief Timerx external event filtering register 1 */
    };

    static RW_ uint32_t* const HRTIM_TIME_CPTxECR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400176E0U,   /** @brief CPT2xCR */
      [1] = (RW_ uint32_t*)0x400176DCU   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIME Register Reset Value Definitions ****/

    static const uint32_t HRTIM_TIME_TIMECR_RST    = 0x00000000U;   /** @brief Timerx control register */
    static const uint32_t HRTIM_TIME_TIMEISR_RST   = 0x00000000U;   /** @brief Timerx interrupt status register */
    static const uint32_t HRTIM_TIME_TIMEICR_RST   = 0x00000000U;   /** @brief Timerx interrupt clear register */
    static const uint32_t HRTIM_TIME_TIMEDIER5_RST = 0x00000000U;   /** @brief TIMxDIER5 */
    static const uint32_t HRTIM_TIME_CNTER_RST     = 0x00000000U;   /** @brief Timerx counter register */
    static const uint32_t HRTIM_TIME_PERER_RST     = 0x0000FFFFU;   /** @brief Timerx period register */
    static const uint32_t HRTIM_TIME_REPER_RST     = 0x00000000U;   /** @brief Timerx repetition register */
    static const uint32_t HRTIM_TIME_CMP1CER_RST   = 0x00000000U;   /** @brief Timerx compare 1 compound register */
    static const uint32_t HRTIM_TIME_DTER_RST      = 0x00000000U;   /** @brief Timerx deadtime register */
    static const uint32_t HRTIM_TIME_RSTER_RST     = 0x00000000U;   /** @brief TimerA reset register */
    static const uint32_t HRTIM_TIME_CHPER_RST     = 0x00000000U;   /** @brief Timerx chopper register */
    static const uint32_t HRTIM_TIME_OUTER_RST     = 0x00000000U;   /** @brief Timerx output register */
    static const uint32_t HRTIM_TIME_FLTER_RST     = 0x00000000U;   /** @brief Timerx fault register */

    static const uint32_t HRTIM_TIME_CMPxER_RST[5] = {
      [2] = 0x00000000U,   /** @brief Timerx compare 2 register */
      [3] = 0x00000000U,   /** @brief Timerx compare 3 register */
      [4] = 0x00000000U,   /** @brief Timerx compare 4 register */
      [1] = 0x00000000U   /** @brief Timerx compare 1 register */
    };

    static const uint32_t HRTIM_TIME_CPTxER_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx capture 2 register */
      [1] = 0x00000000U   /** @brief Timerx capture 1 register */
    };

    static const uint32_t HRTIM_TIME_SETExR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 set register */
      [1] = 0x00000000U   /** @brief Timerx output1 set register */
    };

    static const uint32_t HRTIM_TIME_RSTExR_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx output2 reset register */
      [1] = 0x00000000U   /** @brief Timerx output1 reset register */
    };

    static const uint32_t HRTIM_TIME_EEFERx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Timerx external event filtering register 2 */
      [1] = 0x00000000U   /** @brief Timerx external event filtering register 1 */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_RST[3] = {
      [2] = 0x00000000U,   /** @brief CPT2xCR */
      [1] = 0x00000000U   /** @brief Timerx capture 2 control register */
    };

    /**** @subsection HRTIM_TIME Register Value Type Definitions ****/

    typedef uint32_t HRTIM_TIME_TIMECR_vt;      /** @brief HRTIM_TIME_TIMECR register value type. */
    typedef uint32_t HRTIM_TIME_TIMEISR_vt;     /** @brief HRTIM_TIME_TIMEISR register value type. */
    typedef uint32_t HRTIM_TIME_TIMEICR_vt;     /** @brief HRTIM_TIME_TIMEICR register value type. */
    typedef uint32_t HRTIM_TIME_TIMEDIER5_vt;   /** @brief HRTIM_TIME_TIMEDIER5 register value type. */
    typedef uint32_t HRTIM_TIME_CNTER_vt;       /** @brief HRTIM_TIME_CNTER register value type. */
    typedef uint32_t HRTIM_TIME_PERER_vt;       /** @brief HRTIM_TIME_PERER register value type. */
    typedef uint32_t HRTIM_TIME_REPER_vt;       /** @brief HRTIM_TIME_REPER register value type. */
    typedef uint32_t HRTIM_TIME_CMPxER_vt;      /** @brief HRTIM_TIME_CMPxER register value type. */
    typedef uint32_t HRTIM_TIME_CMP1CER_vt;     /** @brief HRTIM_TIME_CMP1CER register value type. */
    typedef uint32_t HRTIM_TIME_CPTxER_vt;      /** @brief HRTIM_TIME_CPTxER register value type. */
    typedef uint32_t HRTIM_TIME_DTER_vt;        /** @brief HRTIM_TIME_DTER register value type. */
    typedef uint32_t HRTIM_TIME_SETExR_vt;      /** @brief HRTIM_TIME_SETExR register value type. */
    typedef uint32_t HRTIM_TIME_RSTExR_vt;      /** @brief HRTIM_TIME_RSTExR register value type. */
    typedef uint32_t HRTIM_TIME_EEFERx_vt;      /** @brief HRTIM_TIME_EEFERx register value type. */
    typedef uint32_t HRTIM_TIME_RSTER_vt;       /** @brief HRTIM_TIME_RSTER register value type. */
    typedef uint32_t HRTIM_TIME_CHPER_vt;       /** @brief HRTIM_TIME_CHPER register value type. */
    typedef uint32_t HRTIM_TIME_CPTxECR_vt;     /** @brief HRTIM_TIME_CPTxECR register value type. */
    typedef uint32_t HRTIM_TIME_OUTER_vt;       /** @brief HRTIM_TIME_OUTER register value type. */
    typedef uint32_t HRTIM_TIME_FLTER_vt;       /** @brief HRTIM_TIME_FLTER register value type. */

    /**** @subsection HRTIM_TIME Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HRTIM_TIME_TIMECR_pt;      /** @brief HRTIM_TIME_TIMECR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIME_TIMEISR_pt;     /** @brief HRTIM_TIME_TIMEISR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_TIMEICR_pt;     /** @brief HRTIM_TIME_TIMEICR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_TIMEDIER5_pt;   /** @brief HRTIM_TIME_TIMEDIER5 pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_CNTER_pt;       /** @brief HRTIM_TIME_CNTER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_PERER_pt;       /** @brief HRTIM_TIME_PERER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_REPER_pt;       /** @brief HRTIM_TIME_REPER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_CMPxER_pt;      /** @brief HRTIM_TIME_CMPxER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_CMP1CER_pt;     /** @brief HRTIM_TIME_CMP1CER pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_TIME_CPTxER_pt;      /** @brief HRTIM_TIME_CPTxER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_DTER_pt;        /** @brief HRTIM_TIME_DTER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_SETExR_pt;      /** @brief HRTIM_TIME_SETExR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_RSTExR_pt;      /** @brief HRTIM_TIME_RSTExR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_EEFERx_pt;      /** @brief HRTIM_TIME_EEFERx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_RSTER_pt;       /** @brief HRTIM_TIME_RSTER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_CHPER_pt;       /** @brief HRTIM_TIME_CHPER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_CPTxECR_pt;     /** @brief HRTIM_TIME_CPTxECR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_OUTER_pt;       /** @brief HRTIM_TIME_OUTER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_TIME_FLTER_pt;       /** @brief HRTIM_TIME_FLTER pointer register pointer type. */

    /**** @subsection HRTIM_TIME Field Mask Definitions ****/

    static const uint32_t HRTIM_TIME_TIMECR_CK_PSCX_MASK = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
    static const uint32_t HRTIM_TIME_CNTER_CNTX_MASK     = 0x0000FFFFU;   /** @brief Timerx counter value */
    static const uint32_t HRTIM_TIME_PERER_PERX_MASK     = 0x0000FFFFU;   /** @brief Timerx period value */
    static const uint32_t HRTIM_TIME_REPER_REPX_MASK     = 0x000000FFU;   /** @brief Timerx repetition counter value */
    static const uint32_t HRTIM_TIME_CMP1CER_CMP1X_MASK  = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
    static const uint32_t HRTIM_TIME_DTER_DTRX_MASK      = 0x000001FFU;   /** @brief Deadtime rising value */
    static const uint32_t HRTIM_TIME_RSTER_UPDT_MASK     = 0x00000002U;   /** @brief Timer A update reset */
    static const uint32_t HRTIM_TIME_CHPER_CHPFRQ_MASK   = 0x0000000FU;   /** @brief Timerx carrier frequency value */
    static const uint32_t HRTIM_TIME_OUTER_DTEN_MASK     = 0x00000100U;   /** @brief Deadtime enable */

    static const uint32_t HRTIM_TIME_TIMEISR_CMPx_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag */
    };

    static const uint32_t HRTIM_TIME_TIMEICR_CMPxC_MASK[5] = {
      [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
      [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
      [4] = 0x00000008U   /** @brief Compare 4 interrupt flag clear */
    };

    static const uint32_t HRTIM_TIME_TIMEDIER5_CMPxIE_MASK[5] = {
      [3] = 0x00000004U,   /** @brief CMP3IE */
      [2] = 0x00000002U,   /** @brief CMP2IE */
      [1] = 0x00000001U,   /** @brief CMP1IE */
      [4] = 0x00000008U   /** @brief CMP4IE */
    };

    static const uint32_t HRTIM_TIME_CMPxER_CMPxX_MASK[5] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx compare 2 value */
      [3] = 0x0000FFFFU,   /** @brief Timerx compare 3 value */
      [4] = 0x0000FFFFU,   /** @brief Timerx compare 4 value */
      [1] = 0x0000FFFFU   /** @brief Timerx compare 1 value */
    };

    static const uint32_t HRTIM_TIME_CPTxER_CPTxX_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Timerx capture 2 value */
      [1] = 0x0000FFFFU   /** @brief Timerx capture 1 value */
    };

    static const uint32_t HRTIM_TIME_SETExR_SST_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SST */
      [1] = 0x00000001U   /** @brief Software set trigger */
    };

    static const uint32_t HRTIM_TIME_RSTExR_SRT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief SRT */
      [1] = 0x00000001U   /** @brief SRT */
    };

    static const uint32_t HRTIM_TIME_CPTxECR_SWCPT_MASK[3] = {
      [2] = 0x00000001U,   /** @brief Software capture */
      [1] = 0x00000001U   /** @brief Software capture */
    };

    static const uint32_t HRTIM_TIME_FLTER_FLTxEN_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 enable */
      [3] = 0x00000004U,   /** @brief Fault 3 enable */
      [2] = 0x00000002U,   /** @brief Fault 2 enable */
      [1] = 0x00000001U,   /** @brief Fault 1 enable */
      [5] = 0x00000010U   /** @brief Fault 5 enable */
    };

    static const uint32_t HRTIM_TIME_EEFERx_EExLTCH_MASK[3][11] = {
      [2] = {
        [10] = 0x01000000U,   /** @brief External event 10 latch */
        [9]  = 0x00040000U,   /** @brief External event 9 latch */
        [8]  = 0x00001000U,   /** @brief External event 8 latch */
        [7]  = 0x00000040U,   /** @brief External event 7 latch */
        [6]  = 0x00000001U   /** @brief External event 6 latch */
      },
      [1] = {
        [4] = 0x00040000U,   /** @brief External event 4 latch */
        [3] = 0x00001000U,   /** @brief External event 3 latch */
        [2] = 0x00000040U,   /** @brief External event 2 latch */
        [1] = 0x00000001U,   /** @brief External event 1 latch */
        [5] = 0x01000000U   /** @brief External event 5 latch */
      }
    };

    /**********************************************************************************************
     * @section HRTIM_COMMON Register Definitions
     **********************************************************************************************/

    /**** @subsection HRTIM_COMMON Register Pointer Definitions ****/

    static RW_ uint32_t* const HRTIM_COMMON_ISR_PTR     = (RW_ uint32_t*)0x40017788U;   /** @brief Interrupt status register */
    static RW_ uint32_t* const HRTIM_COMMON_ICR_PTR     = (RW_ uint32_t*)0x4001778CU;   /** @brief Interrupt clear register */
    static RW_ uint32_t* const HRTIM_COMMON_IER_PTR     = (RW_ uint32_t*)0x40017790U;   /** @brief Interrupt enable register */
    static RW_ uint32_t* const HRTIM_COMMON_OENR_PTR    = (RW_ uint32_t*)0x40017794U;   /** @brief Output enable register */
    static RW_ uint32_t* const HRTIM_COMMON_DISR_PTR    = (RW_ uint32_t*)0x40017798U;   /** @brief DISR */
    static RO_ uint32_t* const HRTIM_COMMON_ODSR_PTR    = (RO_ uint32_t*)0x4001779CU;   /** @brief Output disable status register */
    static RW_ uint32_t* const HRTIM_COMMON_BMCR_PTR    = (RW_ uint32_t*)0x400177A0U;   /** @brief Burst mode control register */
    static RW_ uint32_t* const HRTIM_COMMON_BMTRG_PTR   = (RW_ uint32_t*)0x400177A4U;   /** @brief BMTRG */
    static RW_ uint32_t* const HRTIM_COMMON_BMCMPR6_PTR = (RW_ uint32_t*)0x400177A8U;   /** @brief BMCMPR6 */
    static RW_ uint32_t* const HRTIM_COMMON_BMPER_PTR   = (RW_ uint32_t*)0x400177ACU;   /** @brief Burst mode period register */
    static RW_ uint32_t* const HRTIM_COMMON_DLLCR_PTR   = (RW_ uint32_t*)0x400177CCU;   /** @brief DLL control register */
    static RW_ uint32_t* const HRTIM_COMMON_BDMUPDR_PTR = (RW_ uint32_t*)0x400177D8U;   /** @brief BDMUPDR */
    static RW_ uint32_t* const HRTIM_COMMON_BDTXUPR_PTR = (RW_ uint32_t*)0x400177DCU;   /** @brief Burst DMA timerx update register */
    static RW_ uint32_t* const HRTIM_COMMON_BDMADR_PTR  = (RW_ uint32_t*)0x400177E0U;   /** @brief Burst DMA data register */

    static RW_ uint32_t* const HRTIM_COMMON_CRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40017784U,   /** @brief Control register 2 */
      [1] = (RW_ uint32_t*)0x40017780U   /** @brief Control register 1 */
    };

    static RW_ uint32_t* const HRTIM_COMMON_EECRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0x400177B4U,   /** @brief Timer external event control register 2 */
      [3] = (RW_ uint32_t*)0x400177B8U,   /** @brief Timer external event control register 3 */
      [1] = (RW_ uint32_t*)0x400177B0U   /** @brief Timer external event control register 1 */
    };

    static RW_ uint32_t* const HRTIM_COMMON_ADCxR_PTR[5] = {
      [2] = (RW_ uint32_t*)0x400177C0U,   /** @brief ADC trigger 2 register */
      [3] = (RW_ uint32_t*)0x400177C4U,   /** @brief ADC trigger 3 register */
      [4] = (RW_ uint32_t*)0x400177C8U,   /** @brief ADC trigger 4 register */
      [1] = (RW_ uint32_t*)0x400177BCU   /** @brief ADC trigger 1 register */
    };

    static RW_ uint32_t* const HRTIM_COMMON_FLTINRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x400177D4U,   /** @brief HRTIM fault input register 2 */
      [1] = (RW_ uint32_t*)0x400177D0U   /** @brief HRTIM fault input register 1 */
    };

    /**** @subsection HRTIM_COMMON Register Reset Value Definitions ****/

    static const uint32_t HRTIM_COMMON_ISR_RST     = 0x00000000U;   /** @brief Interrupt status register */
    static const uint32_t HRTIM_COMMON_ICR_RST     = 0x00000000U;   /** @brief Interrupt clear register */
    static const uint32_t HRTIM_COMMON_IER_RST     = 0x00000000U;   /** @brief Interrupt enable register */
    static const uint32_t HRTIM_COMMON_OENR_RST    = 0x00000000U;   /** @brief Output enable register */
    static const uint32_t HRTIM_COMMON_DISR_RST    = 0x00000000U;   /** @brief DISR */
    static const uint32_t HRTIM_COMMON_ODSR_RST    = 0x00000000U;   /** @brief Output disable status register */
    static const uint32_t HRTIM_COMMON_BMCR_RST    = 0x00000000U;   /** @brief Burst mode control register */
    static const uint32_t HRTIM_COMMON_BMTRG_RST   = 0x00000000U;   /** @brief BMTRG */
    static const uint32_t HRTIM_COMMON_BMCMPR6_RST = 0x00000000U;   /** @brief BMCMPR6 */
    static const uint32_t HRTIM_COMMON_BMPER_RST   = 0x00000000U;   /** @brief Burst mode period register */
    static const uint32_t HRTIM_COMMON_DLLCR_RST   = 0x00000000U;   /** @brief DLL control register */
    static const uint32_t HRTIM_COMMON_BDMUPDR_RST = 0x00000000U;   /** @brief BDMUPDR */
    static const uint32_t HRTIM_COMMON_BDTXUPR_RST = 0x00000000U;   /** @brief Burst DMA timerx update register */
    static const uint32_t HRTIM_COMMON_BDMADR_RST  = 0x00000000U;   /** @brief Burst DMA data register */

    static const uint32_t HRTIM_COMMON_CRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Control register 2 */
      [1] = 0x00000000U   /** @brief Control register 1 */
    };

    static const uint32_t HRTIM_COMMON_EECRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief Timer external event control register 2 */
      [3] = 0x00000000U,   /** @brief Timer external event control register 3 */
      [1] = 0x00000000U   /** @brief Timer external event control register 1 */
    };

    static const uint32_t HRTIM_COMMON_ADCxR_RST[5] = {
      [2] = 0x00000000U,   /** @brief ADC trigger 2 register */
      [3] = 0x00000000U,   /** @brief ADC trigger 3 register */
      [4] = 0x00000000U,   /** @brief ADC trigger 4 register */
      [1] = 0x00000000U   /** @brief ADC trigger 1 register */
    };

    static const uint32_t HRTIM_COMMON_FLTINRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief HRTIM fault input register 2 */
      [1] = 0x00000000U   /** @brief HRTIM fault input register 1 */
    };

    /**** @subsection HRTIM_COMMON Register Value Type Definitions ****/

    typedef uint32_t HRTIM_COMMON_CRx_vt;       /** @brief HRTIM_COMMON_CRx register value type. */
    typedef uint32_t HRTIM_COMMON_ISR_vt;       /** @brief HRTIM_COMMON_ISR register value type. */
    typedef uint32_t HRTIM_COMMON_ICR_vt;       /** @brief HRTIM_COMMON_ICR register value type. */
    typedef uint32_t HRTIM_COMMON_IER_vt;       /** @brief HRTIM_COMMON_IER register value type. */
    typedef uint32_t HRTIM_COMMON_OENR_vt;      /** @brief HRTIM_COMMON_OENR register value type. */
    typedef uint32_t HRTIM_COMMON_DISR_vt;      /** @brief HRTIM_COMMON_DISR register value type. */
    typedef uint32_t HRTIM_COMMON_ODSR_vt;      /** @brief HRTIM_COMMON_ODSR register value type. */
    typedef uint32_t HRTIM_COMMON_BMCR_vt;      /** @brief HRTIM_COMMON_BMCR register value type. */
    typedef uint32_t HRTIM_COMMON_BMTRG_vt;     /** @brief HRTIM_COMMON_BMTRG register value type. */
    typedef uint32_t HRTIM_COMMON_BMCMPR6_vt;   /** @brief HRTIM_COMMON_BMCMPR6 register value type. */
    typedef uint32_t HRTIM_COMMON_BMPER_vt;     /** @brief HRTIM_COMMON_BMPER register value type. */
    typedef uint32_t HRTIM_COMMON_EECRx_vt;     /** @brief HRTIM_COMMON_EECRx register value type. */
    typedef uint32_t HRTIM_COMMON_ADCxR_vt;     /** @brief HRTIM_COMMON_ADCxR register value type. */
    typedef uint32_t HRTIM_COMMON_DLLCR_vt;     /** @brief HRTIM_COMMON_DLLCR register value type. */
    typedef uint32_t HRTIM_COMMON_FLTINRx_vt;   /** @brief HRTIM_COMMON_FLTINRx register value type. */
    typedef uint32_t HRTIM_COMMON_BDMUPDR_vt;   /** @brief HRTIM_COMMON_BDMUPDR register value type. */
    typedef uint32_t HRTIM_COMMON_BDTXUPR_vt;   /** @brief HRTIM_COMMON_BDTXUPR register value type. */
    typedef uint32_t HRTIM_COMMON_BDMADR_vt;    /** @brief HRTIM_COMMON_BDMADR register value type. */

    /**** @subsection HRTIM_COMMON Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* HRTIM_COMMON_CRx_pt;       /** @brief HRTIM_COMMON_CRx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_ISR_pt;       /** @brief HRTIM_COMMON_ISR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_ICR_pt;       /** @brief HRTIM_COMMON_ICR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_IER_pt;       /** @brief HRTIM_COMMON_IER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_OENR_pt;      /** @brief HRTIM_COMMON_OENR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_DISR_pt;      /** @brief HRTIM_COMMON_DISR pointer register pointer type. */
    typedef RO_ uint32_t* HRTIM_COMMON_ODSR_pt;      /** @brief HRTIM_COMMON_ODSR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_BMCR_pt;      /** @brief HRTIM_COMMON_BMCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_BMTRG_pt;     /** @brief HRTIM_COMMON_BMTRG pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_BMCMPR6_pt;   /** @brief HRTIM_COMMON_BMCMPR6 pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_BMPER_pt;     /** @brief HRTIM_COMMON_BMPER pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_EECRx_pt;     /** @brief HRTIM_COMMON_EECRx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_ADCxR_pt;     /** @brief HRTIM_COMMON_ADCxR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_DLLCR_pt;     /** @brief HRTIM_COMMON_DLLCR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_FLTINRx_pt;   /** @brief HRTIM_COMMON_FLTINRx pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_BDMUPDR_pt;   /** @brief HRTIM_COMMON_BDMUPDR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_BDTXUPR_pt;   /** @brief HRTIM_COMMON_BDTXUPR pointer register pointer type. */
    typedef RW_ uint32_t* HRTIM_COMMON_BDMADR_pt;    /** @brief HRTIM_COMMON_BDMADR pointer register pointer type. */

    /**** @subsection HRTIM_COMMON Field Mask Definitions ****/

    static const uint32_t HRTIM_COMMON_CRx_MUDIS_MASK      = 0x00000001U;   /** @brief Master update disable */
    static const uint32_t HRTIM_COMMON_BMCR_BME_MASK       = 0x00000001U;   /** @brief Burst mode enable */
    static const uint32_t HRTIM_COMMON_BMTRG_SW_MASK       = 0x00000001U;   /** @brief SW */
    static const uint32_t HRTIM_COMMON_BMCMPR6_BMCMP_MASK  = 0x0000FFFFU;   /** @brief BMCMP */
    static const uint32_t HRTIM_COMMON_BMPER_BMPER_MASK    = 0x0000FFFFU;   /** @brief Burst mode period */
    static const uint32_t HRTIM_COMMON_DLLCR_CAL_MASK      = 0x00000001U;   /** @brief DLL calibration start */
    static const uint32_t HRTIM_COMMON_BDMUPDR_MCR_MASK    = 0x00000001U;   /** @brief MCR */
    static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCR_MASK = 0x00000001U;   /** @brief HRTIM_TIMxCR register update enable */
    static const uint32_t HRTIM_COMMON_BDMADR_BDMADR_MASK  = 0xFFFFFFFFU;   /** @brief Burst DMA data register */

    static const uint32_t HRTIM_COMMON_ISR_FLTx_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 interrupt flag */
      [3] = 0x00000004U,   /** @brief Fault 3 interrupt flag */
      [2] = 0x00000002U,   /** @brief Fault 2 interrupt flag */
      [1] = 0x00000001U,   /** @brief Fault 1 interrupt flag */
      [5] = 0x00000010U   /** @brief Fault 5 interrupt flag */
    };

    static const uint32_t HRTIM_COMMON_ICR_FLTxC_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 interrupt flag clear */
      [3] = 0x00000004U,   /** @brief Fault 3 interrupt flag clear */
      [2] = 0x00000002U,   /** @brief Fault 2 interrupt flag clear */
      [1] = 0x00000001U,   /** @brief Fault 1 interrupt flag clear */
      [5] = 0x00000010U   /** @brief Fault 5 interrupt flag clear */
    };

    static const uint32_t HRTIM_COMMON_IER_FLTxIE_MASK[6] = {
      [4] = 0x00000008U,   /** @brief Fault 4 interrupt enable */
      [3] = 0x00000004U,   /** @brief Fault 3 interrupt enable */
      [2] = 0x00000002U,   /** @brief Fault 2 interrupt enable */
      [1] = 0x00000001U,   /** @brief Fault 1 interrupt enable */
      [5] = 0x00000010U   /** @brief Fault 5 interrupt enable */
    };

    static const uint32_t HRTIM_COMMON_OENR_TAxOEN_MASK[3] = {
      [1] = 0x00000001U,   /** @brief Timer A output 1 enable */
      [2] = 0x00000002U   /** @brief Timer A output 2 enable */
    };

    static const uint32_t HRTIM_COMMON_DISR_TAxODIS_MASK[3] = {
      [1] = 0x00000001U,   /** @brief TA1ODIS */
      [2] = 0x00000002U   /** @brief TA2ODIS */
    };

    static const uint32_t HRTIM_COMMON_ODSR_TAxODS_MASK[3] = {
      [1] = 0x00000001U,   /** @brief Timer A output 1 disable status */
      [2] = 0x00000002U   /** @brief Timer A output 2 disable status */
    };

    static const uint32_t HRTIM_COMMON_ADCxR_ADxMC4_MASK[5] = {
      [2] = 0x00000008U,   /** @brief ADC trigger 2 on master compare 4 */
      [4] = 0x00000008U   /** @brief AD2MC4 */
    };

    static const uint32_t HRTIM_COMMON_FLTINRx_FLTxE_MASK[3] = {
      [2] = 0x00000001U   /** @brief FLT5E */
    };

    static const uint32_t HRTIM_COMMON_EECRx_EExSRC_MASK[4][11] = {
      [2] = {
        [10] = 0x03000000U,   /** @brief External event 10 source */
        [9]  = 0x000C0000U,   /** @brief External event 9 source */
        [8]  = 0x00003000U,   /** @brief External event 8 source */
        [7]  = 0x000000C0U,   /** @brief External event 7 source */
        [6]  = 0x00000003U   /** @brief External event 6 source */
      },
      [3] = {
        [10] = 0x03000000U,   /** @brief EE10SRC */
        [9]  = 0x000C0000U,   /** @brief EE9SRC */
        [8]  = 0x00003000U,   /** @brief EE8SRC */
        [7]  = 0x000000C0U,   /** @brief EE7SRC */
        [6]  = 0x00000003U   /** @brief EE6SRC */
      },
      [1] = {
        [4] = 0x000C0000U,   /** @brief External event 4 source */
        [3] = 0x00003000U,   /** @brief External event 3 source */
        [2] = 0x000000C0U,   /** @brief External event 2 source */
        [1] = 0x00000003U,   /** @brief External event 1 source */
        [5] = 0x03000000U   /** @brief External event 5 source */
      }
    };

    static const uint32_t HRTIM_COMMON_ADCxR_ADxMC4_MASK[5][5] = {
      [3] = {
        [3] = 0x00000004U,   /** @brief AD1MC3 */
        [2] = 0x00000002U,   /** @brief AD1MC2 */
        [1] = 0x00000001U,   /** @brief AD1MC1 */
        [4] = 0x00000008U   /** @brief AD1MC4 */
      },
      [1] = {
        [3] = 0x00000004U,   /** @brief ADC trigger 1 on master compare 3 */
        [2] = 0x00000002U,   /** @brief ADC trigger 1 on master compare 2 */
        [1] = 0x00000001U,   /** @brief ADC trigger 1 on master compare 1 */
        [4] = 0x00000008U   /** @brief ADC trigger 1 on master compare 4 */
      }
    };

    static const uint32_t HRTIM_COMMON_FLTINRx_FLTxE_MASK[3][5] = {
      [1] = {
        [3] = 0x00010000U,   /** @brief FLT3E */
        [2] = 0x00000100U,   /** @brief FLT2E */
        [1] = 0x00000001U,   /** @brief FLT1E */
        [4] = 0x01000000U   /** @brief FLT4E */
      }
    };

    /**********************************************************************************************
     * @section DFSDM Register Definitions
     **********************************************************************************************/

    /**** @subsection DFSDM Register Pointer Definitions ****/

    static RW_ uint32_t* const DFSDM_DFSDM_CHCFG0Rx_PTR[8] = {
      [1] = (RW_ uint32_t*)0x40017000U,   /** @brief DFSDM channel configuration 0 register 1 */
      [2] = (RW_ uint32_t*)0x40017020U,   /** @brief DFSDM channel configuration 0 register 2 */
      [3] = (RW_ uint32_t*)0x4001700CU,   /** @brief DFSDM channel configuration 3 register 1 */
      [4] = (RW_ uint32_t*)0x40017010U,   /** @brief DFSDM channel configuration 4 register 1 */
      [5] = (RW_ uint32_t*)0x40017014U,   /** @brief DFSDM channel configuration 5 register 1 */
      [6] = (RW_ uint32_t*)0x40017018U,   /** @brief DFSDM channel configuration 6 register 1 */
      [7] = (RW_ uint32_t*)0x4001701CU   /** @brief DFSDM channel configuration 7 register 1 */
    };

    static RW_ uint32_t* const DFSDM_DFSDM_CHCFGxR2_PTR[8] = {
      [1] = (RW_ uint32_t*)0x40017024U,   /** @brief DFSDM channel configuration 1 register 2 */
      [0] = (RW_ uint32_t*)0x40017020U,   /** @brief DFSDM channel configuration 0 register 2 */
      [2] = (RW_ uint32_t*)0x40017028U,   /** @brief DFSDM channel configuration 2 register 2 */
      [3] = (RW_ uint32_t*)0x4001702CU,   /** @brief DFSDM channel configuration 3 register 2 */
      [4] = (RW_ uint32_t*)0x40017030U,   /** @brief DFSDM channel configuration 4 register 2 */
      [5] = (RW_ uint32_t*)0x40017034U,   /** @brief DFSDM channel configuration 5 register 2 */
      [6] = (RW_ uint32_t*)0x40017038U,   /** @brief DFSDM channel configuration 6 register 2 */
      [7] = (RW_ uint32_t*)0x4001703CU   /** @brief DFSDM channel configuration 7 register 2 */
    };

    static RW_ uint32_t* const DFSDM_DFSDM_AWSCDxR_PTR[8] = {
      [1] = (RW_ uint32_t*)0x40017044U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [2] = (RW_ uint32_t*)0x40017048U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [3] = (RW_ uint32_t*)0x4001704CU,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [4] = (RW_ uint32_t*)0x40017050U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [5] = (RW_ uint32_t*)0x40017054U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [6] = (RW_ uint32_t*)0x40017058U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [7] = (RW_ uint32_t*)0x4001705CU,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [0] = (RW_ uint32_t*)0x40017040U   /** @brief DFSDM analog watchdog and short-circuit detector register */
    };

    static RO_ uint32_t* const DFSDM_DFSDM_CHWDATxR_PTR[8] = {
      [1] = (RO_ uint32_t*)0x40017064U,   /** @brief DFSDM channel watchdog filter data register */
      [2] = (RO_ uint32_t*)0x40017068U,   /** @brief DFSDM channel watchdog filter data register */
      [3] = (RO_ uint32_t*)0x4001706CU,   /** @brief DFSDM channel watchdog filter data register */
      [4] = (RO_ uint32_t*)0x40017070U,   /** @brief DFSDM channel watchdog filter data register */
      [5] = (RO_ uint32_t*)0x40017074U,   /** @brief DFSDM channel watchdog filter data register */
      [6] = (RO_ uint32_t*)0x40017078U,   /** @brief DFSDM channel watchdog filter data register */
      [7] = (RO_ uint32_t*)0x4001707CU,   /** @brief DFSDM channel watchdog filter data register */
      [0] = (RO_ uint32_t*)0x40017060U   /** @brief DFSDM channel watchdog filter data register */
    };

    static RW_ uint32_t* const DFSDM_DFSDM_CHDATINxR_PTR[8] = {
      [1] = (RW_ uint32_t*)0x40017084U,   /** @brief DFSDM channel data input register */
      [2] = (RW_ uint32_t*)0x40017088U,   /** @brief DFSDM channel data input register */
      [3] = (RW_ uint32_t*)0x4001708CU,   /** @brief DFSDM channel data input register */
      [4] = (RW_ uint32_t*)0x40017090U,   /** @brief DFSDM channel data input register */
      [5] = (RW_ uint32_t*)0x40017094U,   /** @brief DFSDM channel data input register */
      [6] = (RW_ uint32_t*)0x40017098U,   /** @brief DFSDM channel data input register */
      [7] = (RW_ uint32_t*)0x4001709CU,   /** @brief DFSDM channel data input register */
      [0] = (RW_ uint32_t*)0x40017080U   /** @brief DFSDM channel data input register */
    };

    static RW_ uint32_t* const DFSDM_DFSDM0_CRx_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400170A0U,   /** @brief DFSDM control register 1 */
      [2] = (RW_ uint32_t*)0x400170B0U,   /** @brief DFSDM control register 2 */
      [3] = (RW_ uint32_t*)0x400170ACU   /** @brief DFSDM control register 1 */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_CR2_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400170B4U,   /** @brief DFSDM control register 2 */
      [0] = (RW_ uint32_t*)0x400170B0U,   /** @brief DFSDM control register 2 */
      [2] = (RW_ uint32_t*)0x400170B8U,   /** @brief DFSDM control register 2 */
      [3] = (RW_ uint32_t*)0x400170BCU   /** @brief DFSDM control register 2 */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_ISR_PTR[4] = {
      [1] = (RO_ uint32_t*)0x400170C4U,   /** @brief DFSDM interrupt and status register */
      [2] = (RO_ uint32_t*)0x400170C8U,   /** @brief DFSDM interrupt and status register */
      [3] = (RO_ uint32_t*)0x400170CCU,   /** @brief DFSDM interrupt and status register */
      [0] = (RO_ uint32_t*)0x400170C0U   /** @brief DFSDM interrupt and status register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_ICR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400170D4U,   /** @brief DFSDM interrupt flag clear register */
      [2] = (RW_ uint32_t*)0x400170D8U,   /** @brief DFSDM interrupt flag clear register */
      [3] = (RW_ uint32_t*)0x400170DCU,   /** @brief DFSDM interrupt flag clear register */
      [0] = (RW_ uint32_t*)0x400170D0U   /** @brief DFSDM interrupt flag clear register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_JCHGR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400170E4U,   /** @brief DFSDM injected channel group selection register */
      [2] = (RW_ uint32_t*)0x400170E8U,   /** @brief DFSDM injected channel group selection register */
      [3] = (RW_ uint32_t*)0x400170ECU,   /** @brief DFSDM injected channel group selection register */
      [0] = (RW_ uint32_t*)0x400170E0U   /** @brief DFSDM injected channel group selection register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_FCR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x400170F4U,   /** @brief DFSDM filter control register */
      [2] = (RW_ uint32_t*)0x400170F8U,   /** @brief DFSDM filter control register */
      [3] = (RW_ uint32_t*)0x400170FCU,   /** @brief DFSDM filter control register */
      [0] = (RW_ uint32_t*)0x400170F0U   /** @brief DFSDM filter control register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_JDATAR_PTR[4] = {
      [1] = (RO_ uint32_t*)0x40017104U,   /** @brief DFSDM data register for injected group */
      [2] = (RO_ uint32_t*)0x40017108U,   /** @brief DFSDM data register for injected group */
      [3] = (RO_ uint32_t*)0x4001710CU,   /** @brief DFSDM data register for injected group */
      [0] = (RO_ uint32_t*)0x40017100U   /** @brief DFSDM data register for injected group */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_RDATAR_PTR[4] = {
      [1] = (RO_ uint32_t*)0x40017114U,   /** @brief DFSDM data register for the regular channel */
      [2] = (RO_ uint32_t*)0x40017118U,   /** @brief DFSDM data register for the regular channel */
      [3] = (RO_ uint32_t*)0x4001711CU,   /** @brief DFSDM data register for the regular channel */
      [0] = (RO_ uint32_t*)0x40017110U   /** @brief DFSDM data register for the regular channel */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_AWHTR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40017124U,   /** @brief DFSDM analog watchdog high threshold register */
      [2] = (RW_ uint32_t*)0x40017128U,   /** @brief DFSDM analog watchdog high threshold register */
      [3] = (RW_ uint32_t*)0x4001712CU,   /** @brief DFSDM analog watchdog high threshold register */
      [0] = (RW_ uint32_t*)0x40017120U   /** @brief DFSDM analog watchdog high threshold register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_AWLTR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40017134U,   /** @brief DFSDM analog watchdog low threshold register */
      [2] = (RW_ uint32_t*)0x40017138U,   /** @brief DFSDM analog watchdog low threshold register */
      [3] = (RW_ uint32_t*)0x4001713CU,   /** @brief DFSDM analog watchdog low threshold register */
      [0] = (RW_ uint32_t*)0x40017130U   /** @brief DFSDM analog watchdog low threshold register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_AWSR_PTR[4] = {
      [1] = (RO_ uint32_t*)0x40017144U,   /** @brief DFSDM analog watchdog status register */
      [2] = (RO_ uint32_t*)0x40017148U,   /** @brief DFSDM analog watchdog status register */
      [3] = (RO_ uint32_t*)0x4001714CU,   /** @brief DFSDM analog watchdog status register */
      [0] = (RO_ uint32_t*)0x40017140U   /** @brief DFSDM analog watchdog status register */
    };

    static RW_ uint32_t* const DFSDM_DFSDMx_AWCFR_PTR[4] = {
      [1] = (RW_ uint32_t*)0x40017154U,   /** @brief DFSDM analog watchdog clear flag register */
      [2] = (RW_ uint32_t*)0x40017158U,   /** @brief DFSDM analog watchdog clear flag register */
      [3] = (RW_ uint32_t*)0x4001715CU,   /** @brief DFSDM analog watchdog clear flag register */
      [0] = (RW_ uint32_t*)0x40017150U   /** @brief DFSDM analog watchdog clear flag register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_EXMAX_PTR[4] = {
      [1] = (RO_ uint32_t*)0x40017164U,   /** @brief DFSDM extremes detector maximum register */
      [2] = (RO_ uint32_t*)0x40017168U,   /** @brief DFSDM extremes detector maximum register */
      [3] = (RO_ uint32_t*)0x4001716CU,   /** @brief DFSDM extremes detector maximum register */
      [0] = (RO_ uint32_t*)0x40017160U   /** @brief DFSDM extremes detector maximum register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_EXMIN_PTR[4] = {
      [1] = (RO_ uint32_t*)0x40017174U,   /** @brief DFSDM extremes detector minimum register */
      [2] = (RO_ uint32_t*)0x40017178U,   /** @brief DFSDM extremes detector minimum register */
      [3] = (RO_ uint32_t*)0x4001717CU,   /** @brief DFSDM extremes detector minimum register */
      [0] = (RO_ uint32_t*)0x40017170U   /** @brief DFSDM extremes detector minimum register */
    };

    static RO_ uint32_t* const DFSDM_DFSDMx_CNVTIMR_PTR[4] = {
      [1] = (RO_ uint32_t*)0x40017184U,   /** @brief DFSDM conversion timer register */
      [2] = (RO_ uint32_t*)0x40017188U,   /** @brief DFSDM conversion timer register */
      [3] = (RO_ uint32_t*)0x4001718CU,   /** @brief DFSDM conversion timer register */
      [0] = (RO_ uint32_t*)0x40017180U   /** @brief DFSDM conversion timer register */
    };

    /**** @subsection DFSDM Register Reset Value Definitions ****/

    static const uint32_t DFSDM_DFSDM_CHCFG0Rx_RST[8] = {
      [1] = 0x00000000U,   /** @brief DFSDM channel configuration 0 register 1 */
      [2] = 0x00000000U,   /** @brief DFSDM channel configuration 0 register 2 */
      [3] = 0x00000000U,   /** @brief DFSDM channel configuration 3 register 1 */
      [4] = 0x00000000U,   /** @brief DFSDM channel configuration 4 register 1 */
      [5] = 0x00000000U,   /** @brief DFSDM channel configuration 5 register 1 */
      [6] = 0x00000000U,   /** @brief DFSDM channel configuration 6 register 1 */
      [7] = 0x00000000U   /** @brief DFSDM channel configuration 7 register 1 */
    };

    static const uint32_t DFSDM_DFSDM_CHCFGxR2_RST[8] = {
      [1] = 0x00000000U,   /** @brief DFSDM channel configuration 1 register 2 */
      [0] = 0x00000000U,   /** @brief DFSDM channel configuration 0 register 2 */
      [2] = 0x00000000U,   /** @brief DFSDM channel configuration 2 register 2 */
      [3] = 0x00000000U,   /** @brief DFSDM channel configuration 3 register 2 */
      [4] = 0x00000000U,   /** @brief DFSDM channel configuration 4 register 2 */
      [5] = 0x00000000U,   /** @brief DFSDM channel configuration 5 register 2 */
      [6] = 0x00000000U,   /** @brief DFSDM channel configuration 6 register 2 */
      [7] = 0x00000000U   /** @brief DFSDM channel configuration 7 register 2 */
    };

    static const uint32_t DFSDM_DFSDM_AWSCDxR_RST[8] = {
      [1] = 0x00000000U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [2] = 0x00000000U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [3] = 0x00000000U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [4] = 0x00000000U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [5] = 0x00000000U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [6] = 0x00000000U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [7] = 0x00000000U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
      [0] = 0x00000000U   /** @brief DFSDM analog watchdog and short-circuit detector register */
    };

    static const uint32_t DFSDM_DFSDM_CHWDATxR_RST[8] = {
      [1] = 0x00000000U,   /** @brief DFSDM channel watchdog filter data register */
      [2] = 0x00000000U,   /** @brief DFSDM channel watchdog filter data register */
      [3] = 0x00000000U,   /** @brief DFSDM channel watchdog filter data register */
      [4] = 0x00000000U,   /** @brief DFSDM channel watchdog filter data register */
      [5] = 0x00000000U,   /** @brief DFSDM channel watchdog filter data register */
      [6] = 0x00000000U,   /** @brief DFSDM channel watchdog filter data register */
      [7] = 0x00000000U,   /** @brief DFSDM channel watchdog filter data register */
      [0] = 0x00000000U   /** @brief DFSDM channel watchdog filter data register */
    };

    static const uint32_t DFSDM_DFSDM_CHDATINxR_RST[8] = {
      [1] = 0x00000000U,   /** @brief DFSDM channel data input register */
      [2] = 0x00000000U,   /** @brief DFSDM channel data input register */
      [3] = 0x00000000U,   /** @brief DFSDM channel data input register */
      [4] = 0x00000000U,   /** @brief DFSDM channel data input register */
      [5] = 0x00000000U,   /** @brief DFSDM channel data input register */
      [6] = 0x00000000U,   /** @brief DFSDM channel data input register */
      [7] = 0x00000000U,   /** @brief DFSDM channel data input register */
      [0] = 0x00000000U   /** @brief DFSDM channel data input register */
    };

    static const uint32_t DFSDM_DFSDM0_CRx_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM control register 1 */
      [2] = 0x00000000U,   /** @brief DFSDM control register 2 */
      [3] = 0x00000000U   /** @brief DFSDM control register 1 */
    };

    static const uint32_t DFSDM_DFSDMx_CR2_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM control register 2 */
      [0] = 0x00000000U,   /** @brief DFSDM control register 2 */
      [2] = 0x00000000U,   /** @brief DFSDM control register 2 */
      [3] = 0x00000000U   /** @brief DFSDM control register 2 */
    };

    static const uint32_t DFSDM_DFSDMx_ISR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM interrupt and status register */
      [2] = 0x00000000U,   /** @brief DFSDM interrupt and status register */
      [3] = 0x00000000U,   /** @brief DFSDM interrupt and status register */
      [0] = 0x00000000U   /** @brief DFSDM interrupt and status register */
    };

    static const uint32_t DFSDM_DFSDMx_ICR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM interrupt flag clear register */
      [2] = 0x00000000U,   /** @brief DFSDM interrupt flag clear register */
      [3] = 0x00000000U,   /** @brief DFSDM interrupt flag clear register */
      [0] = 0x00000000U   /** @brief DFSDM interrupt flag clear register */
    };

    static const uint32_t DFSDM_DFSDMx_JCHGR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM injected channel group selection register */
      [2] = 0x00000000U,   /** @brief DFSDM injected channel group selection register */
      [3] = 0x00000000U,   /** @brief DFSDM injected channel group selection register */
      [0] = 0x00000000U   /** @brief DFSDM injected channel group selection register */
    };

    static const uint32_t DFSDM_DFSDMx_FCR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM filter control register */
      [2] = 0x00000000U,   /** @brief DFSDM filter control register */
      [3] = 0x00000000U,   /** @brief DFSDM filter control register */
      [0] = 0x00000000U   /** @brief DFSDM filter control register */
    };

    static const uint32_t DFSDM_DFSDMx_JDATAR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM data register for injected group */
      [2] = 0x00000000U,   /** @brief DFSDM data register for injected group */
      [3] = 0x00000000U,   /** @brief DFSDM data register for injected group */
      [0] = 0x00000000U   /** @brief DFSDM data register for injected group */
    };

    static const uint32_t DFSDM_DFSDMx_RDATAR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM data register for the regular channel */
      [2] = 0x00000000U,   /** @brief DFSDM data register for the regular channel */
      [3] = 0x00000000U,   /** @brief DFSDM data register for the regular channel */
      [0] = 0x00000000U   /** @brief DFSDM data register for the regular channel */
    };

    static const uint32_t DFSDM_DFSDMx_AWHTR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM analog watchdog high threshold register */
      [2] = 0x00000000U,   /** @brief DFSDM analog watchdog high threshold register */
      [3] = 0x00000000U,   /** @brief DFSDM analog watchdog high threshold register */
      [0] = 0x00000000U   /** @brief DFSDM analog watchdog high threshold register */
    };

    static const uint32_t DFSDM_DFSDMx_AWLTR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM analog watchdog low threshold register */
      [2] = 0x00000000U,   /** @brief DFSDM analog watchdog low threshold register */
      [3] = 0x00000000U,   /** @brief DFSDM analog watchdog low threshold register */
      [0] = 0x00000000U   /** @brief DFSDM analog watchdog low threshold register */
    };

    static const uint32_t DFSDM_DFSDMx_AWSR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM analog watchdog status register */
      [2] = 0x00000000U,   /** @brief DFSDM analog watchdog status register */
      [3] = 0x00000000U,   /** @brief DFSDM analog watchdog status register */
      [0] = 0x00000000U   /** @brief DFSDM analog watchdog status register */
    };

    static const uint32_t DFSDM_DFSDMx_AWCFR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM analog watchdog clear flag register */
      [2] = 0x00000000U,   /** @brief DFSDM analog watchdog clear flag register */
      [3] = 0x00000000U,   /** @brief DFSDM analog watchdog clear flag register */
      [0] = 0x00000000U   /** @brief DFSDM analog watchdog clear flag register */
    };

    static const uint32_t DFSDM_DFSDMx_EXMAX_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM extremes detector maximum register */
      [2] = 0x00000000U,   /** @brief DFSDM extremes detector maximum register */
      [3] = 0x00000000U,   /** @brief DFSDM extremes detector maximum register */
      [0] = 0x00000000U   /** @brief DFSDM extremes detector maximum register */
    };

    static const uint32_t DFSDM_DFSDMx_EXMIN_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM extremes detector minimum register */
      [2] = 0x00000000U,   /** @brief DFSDM extremes detector minimum register */
      [3] = 0x00000000U,   /** @brief DFSDM extremes detector minimum register */
      [0] = 0x00000000U   /** @brief DFSDM extremes detector minimum register */
    };

    static const uint32_t DFSDM_DFSDMx_CNVTIMR_RST[4] = {
      [1] = 0x00000000U,   /** @brief DFSDM conversion timer register */
      [2] = 0x00000000U,   /** @brief DFSDM conversion timer register */
      [3] = 0x00000000U,   /** @brief DFSDM conversion timer register */
      [0] = 0x00000000U   /** @brief DFSDM conversion timer register */
    };

    /**** @subsection DFSDM Register Value Type Definitions ****/

    typedef uint32_t DFSDM_DFSDM_CHCFG0Rx_vt;    /** @brief DFSDM_DFSDM_CHCFG0Rx register value type. */
    typedef uint32_t DFSDM_DFSDM_CHCFGxR2_vt;    /** @brief DFSDM_DFSDM_CHCFGxR2 register value type. */
    typedef uint32_t DFSDM_DFSDM_AWSCDxR_vt;     /** @brief DFSDM_DFSDM_AWSCDxR register value type. */
    typedef uint32_t DFSDM_DFSDM_CHWDATxR_vt;    /** @brief DFSDM_DFSDM_CHWDATxR register value type. */
    typedef uint32_t DFSDM_DFSDM_CHDATINxR_vt;   /** @brief DFSDM_DFSDM_CHDATINxR register value type. */
    typedef uint32_t DFSDM_DFSDM0_CRx_vt;        /** @brief DFSDM_DFSDM0_CRx register value type. */
    typedef uint32_t DFSDM_DFSDMx_CR2_vt;        /** @brief DFSDM_DFSDMx_CR2 register value type. */
    typedef uint32_t DFSDM_DFSDMx_ISR_vt;        /** @brief DFSDM_DFSDMx_ISR register value type. */
    typedef uint32_t DFSDM_DFSDMx_ICR_vt;        /** @brief DFSDM_DFSDMx_ICR register value type. */
    typedef uint32_t DFSDM_DFSDMx_JCHGR_vt;      /** @brief DFSDM_DFSDMx_JCHGR register value type. */
    typedef uint32_t DFSDM_DFSDMx_FCR_vt;        /** @brief DFSDM_DFSDMx_FCR register value type. */
    typedef uint32_t DFSDM_DFSDMx_JDATAR_vt;     /** @brief DFSDM_DFSDMx_JDATAR register value type. */
    typedef uint32_t DFSDM_DFSDMx_RDATAR_vt;     /** @brief DFSDM_DFSDMx_RDATAR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWHTR_vt;      /** @brief DFSDM_DFSDMx_AWHTR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWLTR_vt;      /** @brief DFSDM_DFSDMx_AWLTR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWSR_vt;       /** @brief DFSDM_DFSDMx_AWSR register value type. */
    typedef uint32_t DFSDM_DFSDMx_AWCFR_vt;      /** @brief DFSDM_DFSDMx_AWCFR register value type. */
    typedef uint32_t DFSDM_DFSDMx_EXMAX_vt;      /** @brief DFSDM_DFSDMx_EXMAX register value type. */
    typedef uint32_t DFSDM_DFSDMx_EXMIN_vt;      /** @brief DFSDM_DFSDMx_EXMIN register value type. */
    typedef uint32_t DFSDM_DFSDMx_CNVTIMR_vt;    /** @brief DFSDM_DFSDMx_CNVTIMR register value type. */

    /**** @subsection DFSDM Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* DFSDM_DFSDM_CHCFG0Rx_pt;    /** @brief DFSDM_DFSDM_CHCFG0Rx pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDM_CHCFGxR2_pt;    /** @brief DFSDM_DFSDM_CHCFGxR2 pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDM_AWSCDxR_pt;     /** @brief DFSDM_DFSDM_AWSCDxR pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDM_CHWDATxR_pt;    /** @brief DFSDM_DFSDM_CHWDATxR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDM_CHDATINxR_pt;   /** @brief DFSDM_DFSDM_CHDATINxR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDM0_CRx_pt;        /** @brief DFSDM_DFSDM0_CRx pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDMx_CR2_pt;        /** @brief DFSDM_DFSDMx_CR2 pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDMx_ISR_pt;        /** @brief DFSDM_DFSDMx_ISR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDMx_ICR_pt;        /** @brief DFSDM_DFSDMx_ICR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDMx_JCHGR_pt;      /** @brief DFSDM_DFSDMx_JCHGR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDMx_FCR_pt;        /** @brief DFSDM_DFSDMx_FCR pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDMx_JDATAR_pt;     /** @brief DFSDM_DFSDMx_JDATAR pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDMx_RDATAR_pt;     /** @brief DFSDM_DFSDMx_RDATAR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDMx_AWHTR_pt;      /** @brief DFSDM_DFSDMx_AWHTR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDMx_AWLTR_pt;      /** @brief DFSDM_DFSDMx_AWLTR pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDMx_AWSR_pt;       /** @brief DFSDM_DFSDMx_AWSR pointer register pointer type. */
    typedef RW_ uint32_t* DFSDM_DFSDMx_AWCFR_pt;      /** @brief DFSDM_DFSDMx_AWCFR pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDMx_EXMAX_pt;      /** @brief DFSDM_DFSDMx_EXMAX pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDMx_EXMIN_pt;      /** @brief DFSDM_DFSDMx_EXMIN pointer register pointer type. */
    typedef RO_ uint32_t* DFSDM_DFSDMx_CNVTIMR_pt;    /** @brief DFSDM_DFSDMx_CNVTIMR pointer register pointer type. */

    /**** @subsection DFSDM Field Mask Definitions ****/

    static const uint32_t DFSDM_DFSDM_CHCFG0Rx_DFSDMEN_MASK[8] = {
      [1] = 0x80000000U,   /** @brief Global enable for DFSDM interface */
      [2] = 0x80000000U,   /** @brief Global enable for DFSDM interface */
      [3] = 0x80000000U,   /** @brief Global enable for DFSDM interface */
      [4] = 0x80000000U,   /** @brief Global enable for DFSDM interface */
      [5] = 0x80000000U,   /** @brief Global enable for DFSDM interface */
      [6] = 0x80000000U,   /** @brief Global enable for DFSDM interface */
      [7] = 0x80000000U   /** @brief Global enable for DFSDM interface */
    };

    static const uint32_t DFSDM_DFSDM_CHCFGxR2_OFFSET_MASK[8] = {
      [0] = 0xFFFFFF00U,   /** @brief 24-bit calibration offset for channel 0 */
      [2] = 0xFFFFFF00U,   /** @brief 24-bit calibration offset for channel 2 */
      [3] = 0xFFFFFF00U,   /** @brief 24-bit calibration offset for channel 3 */
      [4] = 0xFFFFFF00U,   /** @brief 24-bit calibration offset for channel 4 */
      [5] = 0xFFFFFF00U,   /** @brief 24-bit calibration offset for channel 5 */
      [6] = 0xFFFFFF00U,   /** @brief 24-bit calibration offset for channel 6 */
      [7] = 0xFFFFFF00U,   /** @brief 24-bit calibration offset for channel 7 */
      [1] = 0xFFFFFF00U   /** @brief 24-bit calibration offset for channel 1 */
    };

    static const uint32_t DFSDM_DFSDM_AWSCDxR_AWFORD_MASK[8] = {
      [1] = 0x00C00000U,   /** @brief Analog watchdog sinc filter order on channel 1 */
      [2] = 0x00C00000U,   /** @brief Analog watchdog sinc filter order on channel 2 */
      [3] = 0x00C00000U,   /** @brief Analog watchdog sinc filter order on channel 3 */
      [4] = 0x00C00000U,   /** @brief Analog watchdog sinc filter order on channel 4 */
      [5] = 0x00C00000U,   /** @brief Analog watchdog sinc filter order on channel 5 */
      [6] = 0x00C00000U,   /** @brief Analog watchdog sinc filter order on channel 6 */
      [7] = 0x00C00000U,   /** @brief Analog watchdog sinc filter order on channel 7 */
      [0] = 0x00C00000U   /** @brief Analog watchdog sinc filter order on channel 0 */
    };

    static const uint32_t DFSDM_DFSDM_CHWDATxR_WDATA_MASK[8] = {
      [1] = 0x0000FFFFU,   /** @brief Input channel y watchdog data */
      [2] = 0x0000FFFFU,   /** @brief Input channel y watchdog data */
      [3] = 0x0000FFFFU,   /** @brief Input channel y watchdog data */
      [4] = 0x0000FFFFU,   /** @brief Input channel y watchdog data */
      [5] = 0x0000FFFFU,   /** @brief Input channel y watchdog data */
      [6] = 0x0000FFFFU,   /** @brief Input channel y watchdog data */
      [7] = 0x0000FFFFU,   /** @brief Input channel y watchdog data */
      [0] = 0x0000FFFFU   /** @brief Input channel y watchdog data */
    };

    static const uint32_t DFSDM_DFSDM0_CRx_AWFSEL_MASK[4] = {
      [1] = 0x40000000U,   /** @brief Analog watchdog fast mode select */
      [2] = 0x40000000U,   /** @brief Analog watchdog fast mode select */
      [3] = 0x40000000U   /** @brief Analog watchdog fast mode select */
    };

    static const uint32_t DFSDM_DFSDMx_CR2_AWDCH_MASK[4] = {
      [0] = 0x00FF0000U,   /** @brief Analog watchdog channel selection */
      [2] = 0x00FF0000U,   /** @brief Analog watchdog channel selection */
      [3] = 0x00FF0000U,   /** @brief Analog watchdog channel selection */
      [1] = 0x00FF0000U   /** @brief Analog watchdog channel selection */
    };

    static const uint32_t DFSDM_DFSDMx_ISR_SCDF_MASK[4] = {
      [1] = 0xFF000000U,   /** @brief Short-circuit detector flag */
      [2] = 0xFF000000U,   /** @brief Short-circuit detector flag */
      [3] = 0xFF000000U,   /** @brief Short-circuit detector flag */
      [0] = 0xFF000000U   /** @brief Short-circuit detector flag */
    };

    static const uint32_t DFSDM_DFSDMx_ICR_CLRSCDF_MASK[4] = {
      [1] = 0xFF000000U,   /** @brief Clear the short-circuit detector flag */
      [2] = 0xFF000000U,   /** @brief Clear the short-circuit detector flag */
      [3] = 0xFF000000U,   /** @brief Clear the short-circuit detector flag */
      [0] = 0xFF000000U   /** @brief Clear the short-circuit detector flag */
    };

    static const uint32_t DFSDM_DFSDMx_JCHGR_JCHG_MASK[4] = {
      [1] = 0x000000FFU,   /** @brief Injected channel group selection */
      [2] = 0x000000FFU,   /** @brief Injected channel group selection */
      [3] = 0x000000FFU,   /** @brief Injected channel group selection */
      [0] = 0x000000FFU   /** @brief Injected channel group selection */
    };

    static const uint32_t DFSDM_DFSDMx_FCR_FORD_MASK[4] = {
      [1] = 0xE0000000U,   /** @brief Sinc filter order */
      [2] = 0xE0000000U,   /** @brief Sinc filter order */
      [3] = 0xE0000000U,   /** @brief Sinc filter order */
      [0] = 0xE0000000U   /** @brief Sinc filter order */
    };

    static const uint32_t DFSDM_DFSDMx_JDATAR_JDATA_MASK[4] = {
      [1] = 0xFFFFFF00U,   /** @brief Injected group conversion data */
      [2] = 0xFFFFFF00U,   /** @brief Injected group conversion data */
      [3] = 0xFFFFFF00U,   /** @brief Injected group conversion data */
      [0] = 0xFFFFFF00U   /** @brief Injected group conversion data */
    };

    static const uint32_t DFSDM_DFSDMx_RDATAR_RDATA_MASK[4] = {
      [1] = 0xFFFFFF00U,   /** @brief Regular channel conversion data */
      [2] = 0xFFFFFF00U,   /** @brief Regular channel conversion data */
      [3] = 0xFFFFFF00U,   /** @brief Regular channel conversion data */
      [0] = 0xFFFFFF00U   /** @brief Regular channel conversion data */
    };

    static const uint32_t DFSDM_DFSDMx_AWHTR_AWHT_MASK[4] = {
      [1] = 0xFFFFFF00U,   /** @brief Analog watchdog high threshold */
      [2] = 0xFFFFFF00U,   /** @brief Analog watchdog high threshold */
      [3] = 0xFFFFFF00U,   /** @brief Analog watchdog high threshold */
      [0] = 0xFFFFFF00U   /** @brief Analog watchdog high threshold */
    };

    static const uint32_t DFSDM_DFSDMx_AWLTR_AWLT_MASK[4] = {
      [1] = 0xFFFFFF00U,   /** @brief Analog watchdog low threshold */
      [2] = 0xFFFFFF00U,   /** @brief Analog watchdog low threshold */
      [3] = 0xFFFFFF00U,   /** @brief Analog watchdog low threshold */
      [0] = 0xFFFFFF00U   /** @brief Analog watchdog low threshold */
    };

    static const uint32_t DFSDM_DFSDMx_AWSR_AWHTF_MASK[4] = {
      [1] = 0x0000FF00U,   /** @brief Analog watchdog high threshold flag */
      [2] = 0x0000FF00U,   /** @brief Analog watchdog high threshold flag */
      [3] = 0x0000FF00U,   /** @brief Analog watchdog high threshold flag */
      [0] = 0x0000FF00U   /** @brief Analog watchdog high threshold flag */
    };

    static const uint32_t DFSDM_DFSDMx_AWCFR_CLRAWHTF_MASK[4] = {
      [1] = 0x0000FF00U,   /** @brief Clear the analog watchdog high threshold flag */
      [2] = 0x0000FF00U,   /** @brief Clear the analog watchdog high threshold flag */
      [3] = 0x0000FF00U,   /** @brief Clear the analog watchdog high threshold flag */
      [0] = 0x0000FF00U   /** @brief Clear the analog watchdog high threshold flag */
    };

    static const uint32_t DFSDM_DFSDMx_EXMAX_EXMAX_MASK[4] = {
      [1] = 0xFFFFFF00U,   /** @brief Extremes detector maximum value */
      [2] = 0xFFFFFF00U,   /** @brief Extremes detector maximum value */
      [3] = 0xFFFFFF00U,   /** @brief Extremes detector maximum value */
      [0] = 0xFFFFFF00U   /** @brief Extremes detector maximum value */
    };

    static const uint32_t DFSDM_DFSDMx_EXMIN_EXMIN_MASK[4] = {
      [1] = 0xFFFFFF00U,   /** @brief Extremes detector minimum value */
      [2] = 0xFFFFFF00U,   /** @brief Extremes detector minimum value */
      [3] = 0xFFFFFF00U,   /** @brief Extremes detector minimum value */
      [0] = 0xFFFFFF00U   /** @brief Extremes detector minimum value */
    };

    static const uint32_t DFSDM_DFSDMx_CNVTIMR_CNVCNT_MASK[4] = {
      [1] = 0xFFFFFFF0U,   /** @brief 28-bit timer counting conversion time */
      [2] = 0xFFFFFFF0U,   /** @brief 28-bit timer counting conversion time */
      [3] = 0xFFFFFFF0U,   /** @brief 28-bit timer counting conversion time */
      [0] = 0xFFFFFFF0U   /** @brief 28-bit timer counting conversion time */
    };

    static const uint32_t DFSDM_DFSDM_CHDATINxR_INDATx_MASK[8][2] = {
      [1] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 2 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 1 */
      },
      [2] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 3 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 2 */
      },
      [3] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 4 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 3 */
      },
      [4] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 5 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 4 */
      },
      [5] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 6 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 5 */
      },
      [6] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 7 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 6 */
      },
      [7] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 8 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 7 */
      },
      [0] = {
        [1] = 0xFFFF0000U,   /** @brief Input data for channel 1 */
        [0] = 0x0000FFFFU   /** @brief Input data for channel 0 */
      }
    };

    /**********************************************************************************************
     * @section G2_TIM1 Register Definitions
     **********************************************************************************************/

    /**** @subsection G2_TIM1 Register Pointer Definitions ****/

    static RW_ uint32_t* const G2_TIM1x_DIER_PTR[8] = {
      [7] = (RW_ uint32_t*)0x4001480CU,   /** @brief DMA/Interrupt enable register */
      [6] = (RW_ uint32_t*)0x4001440CU   /** @brief DMA/Interrupt enable register */
    };

    static RW_ uint32_t* const G2_TIM1x_SR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014810U,   /** @brief Status register */
      [6] = (RW_ uint32_t*)0x40014410U   /** @brief Status register */
    };

    static RW_ uint32_t* const G2_TIM1x_EGR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014814U,   /** @brief Event generation register */
      [6] = (RW_ uint32_t*)0x40014414U   /** @brief Event generation register */
    };

    static RW_ uint32_t* const G2_TIM1x_CCMR1_OUTPUT_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014818U,   /** @brief Capture/compare mode register (output mode) */
      [6] = (RW_ uint32_t*)0x40014418U   /** @brief Capture/compare mode register (output mode) */
    };

    static RW_ uint32_t* const G2_TIM1x_CCMR1_INPUT_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014818U,   /** @brief Capture/compare mode register 1 (input mode) */
      [6] = (RW_ uint32_t*)0x40014418U   /** @brief Capture/compare mode register 1 (input mode) */
    };

    static RW_ uint32_t* const G2_TIM1x_CCER_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014820U,   /** @brief Capture/compare enable register */
      [6] = (RW_ uint32_t*)0x40014420U   /** @brief Capture/compare enable register */
    };

    static RW_ uint32_t* const G2_TIM1x_CNT_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014824U,   /** @brief Counter */
      [6] = (RW_ uint32_t*)0x40014424U   /** @brief Counter */
    };

    static RW_ uint32_t* const G2_TIM1x_PSC_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014828U,   /** @brief Prescaler */
      [6] = (RW_ uint32_t*)0x40014428U   /** @brief Prescaler */
    };

    static RW_ uint32_t* const G2_TIM1x_ARR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x4001482CU,   /** @brief Auto-reload register */
      [6] = (RW_ uint32_t*)0x4001442CU   /** @brief Auto-reload register */
    };

    static RW_ uint32_t* const G2_TIM1x_RCR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014830U,   /** @brief Repetition counter register */
      [6] = (RW_ uint32_t*)0x40014430U   /** @brief Repetition counter register */
    };

    static RW_ uint32_t* const G2_TIM1x_CCR1_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014834U,   /** @brief Capture/compare register 1 */
      [6] = (RW_ uint32_t*)0x40014434U   /** @brief Capture/compare register 1 */
    };

    static RW_ uint32_t* const G2_TIM1x_BDTR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014844U,   /** @brief Break and dead-time register */
      [6] = (RW_ uint32_t*)0x40014444U   /** @brief Break and dead-time register */
    };

    static RW_ uint32_t* const G2_TIM1x_DCR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014848U,   /** @brief DMA control register */
      [6] = (RW_ uint32_t*)0x40014448U   /** @brief DMA control register */
    };

    static RW_ uint32_t* const G2_TIM1x_DMAR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x4001484CU,   /** @brief DMA address for full transfer */
      [6] = (RW_ uint32_t*)0x4001444CU   /** @brief DMA address for full transfer */
    };

    static RW_ uint32_t* const G2_TIM1x_TIM1x_AF1_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014860U,   /** @brief TIM17 alternate function register 1 */
      [6] = (RW_ uint32_t*)0x40014460U   /** @brief TIM16 alternate function register 1 */
    };

    static RW_ uint32_t* const G2_TIM1x_TIM1x_TISEL_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40014868U,   /** @brief TIM17 input selection register */
      [6] = (RW_ uint32_t*)0x40014468U   /** @brief TIM16 input selection register */
    };

    /**** @subsection G2_TIM1 Register Reset Value Definitions ****/

    static const uint32_t G2_TIM1x_DIER_RST[8] = {
      [7] = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [6] = 0x00000000U   /** @brief DMA/Interrupt enable register */
    };

    static const uint32_t G2_TIM1x_SR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Status register */
      [6] = 0x00000000U   /** @brief Status register */
    };

    static const uint32_t G2_TIM1x_EGR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Event generation register */
      [6] = 0x00000000U   /** @brief Event generation register */
    };

    static const uint32_t G2_TIM1x_CCMR1_OUTPUT_RST[8] = {
      [7] = 0x00000000U,   /** @brief Capture/compare mode register (output mode) */
      [6] = 0x00000000U   /** @brief Capture/compare mode register (output mode) */
    };

    static const uint32_t G2_TIM1x_CCMR1_INPUT_RST[8] = {
      [7] = 0x00000000U,   /** @brief Capture/compare mode register 1 (input mode) */
      [6] = 0x00000000U   /** @brief Capture/compare mode register 1 (input mode) */
    };

    static const uint32_t G2_TIM1x_CCER_RST[8] = {
      [7] = 0x00000000U,   /** @brief Capture/compare enable register */
      [6] = 0x00000000U   /** @brief Capture/compare enable register */
    };

    static const uint32_t G2_TIM1x_CNT_RST[8] = {
      [7] = 0x00000000U,   /** @brief Counter */
      [6] = 0x00000000U   /** @brief Counter */
    };

    static const uint32_t G2_TIM1x_PSC_RST[8] = {
      [7] = 0x00000000U,   /** @brief Prescaler */
      [6] = 0x00000000U   /** @brief Prescaler */
    };

    static const uint32_t G2_TIM1x_ARR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Auto-reload register */
      [6] = 0x00000000U   /** @brief Auto-reload register */
    };

    static const uint32_t G2_TIM1x_RCR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Repetition counter register */
      [6] = 0x00000000U   /** @brief Repetition counter register */
    };

    static const uint32_t G2_TIM1x_CCR1_RST[8] = {
      [7] = 0x00000000U,   /** @brief Capture/compare register 1 */
      [6] = 0x00000000U   /** @brief Capture/compare register 1 */
    };

    static const uint32_t G2_TIM1x_BDTR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Break and dead-time register */
      [6] = 0x00000000U   /** @brief Break and dead-time register */
    };

    static const uint32_t G2_TIM1x_DCR_RST[8] = {
      [7] = 0x00000000U,   /** @brief DMA control register */
      [6] = 0x00000000U   /** @brief DMA control register */
    };

    static const uint32_t G2_TIM1x_DMAR_RST[8] = {
      [7] = 0x00000000U,   /** @brief DMA address for full transfer */
      [6] = 0x00000000U   /** @brief DMA address for full transfer */
    };

    static const uint32_t G2_TIM1x_TIM1x_AF1_RST[8] = {
      [7] = 0x00000000U,   /** @brief TIM17 alternate function register 1 */
      [6] = 0x00000000U   /** @brief TIM16 alternate function register 1 */
    };

    static const uint32_t G2_TIM1x_TIM1x_TISEL_RST[8] = {
      [7] = 0x00000000U,   /** @brief TIM17 input selection register */
      [6] = 0x00000000U   /** @brief TIM16 input selection register */
    };

    /**** @subsection G2_TIM1 Register Value Type Definitions ****/

    typedef uint32_t G2_TIM1x_CRx_vt;            /** @brief G2_TIM1x_CRx register value type. */
    typedef uint32_t G2_TIM1x_DIER_vt;           /** @brief G2_TIM1x_DIER register value type. */
    typedef uint32_t G2_TIM1x_SR_vt;             /** @brief G2_TIM1x_SR register value type. */
    typedef uint32_t G2_TIM1x_EGR_vt;            /** @brief G2_TIM1x_EGR register value type. */
    typedef uint32_t G2_TIM1x_CCMR1_OUTPUT_vt;   /** @brief G2_TIM1x_CCMR1_OUTPUT register value type. */
    typedef uint32_t G2_TIM1x_CCMR1_INPUT_vt;    /** @brief G2_TIM1x_CCMR1_INPUT register value type. */
    typedef uint32_t G2_TIM1x_CCER_vt;           /** @brief G2_TIM1x_CCER register value type. */
    typedef uint32_t G2_TIM1x_CNT_vt;            /** @brief G2_TIM1x_CNT register value type. */
    typedef uint32_t G2_TIM1x_PSC_vt;            /** @brief G2_TIM1x_PSC register value type. */
    typedef uint32_t G2_TIM1x_ARR_vt;            /** @brief G2_TIM1x_ARR register value type. */
    typedef uint32_t G2_TIM1x_RCR_vt;            /** @brief G2_TIM1x_RCR register value type. */
    typedef uint32_t G2_TIM1x_CCR1_vt;           /** @brief G2_TIM1x_CCR1 register value type. */
    typedef uint32_t G2_TIM1x_BDTR_vt;           /** @brief G2_TIM1x_BDTR register value type. */
    typedef uint32_t G2_TIM1x_DCR_vt;            /** @brief G2_TIM1x_DCR register value type. */
    typedef uint32_t G2_TIM1x_DMAR_vt;           /** @brief G2_TIM1x_DMAR register value type. */
    typedef uint32_t G2_TIM1x_TIM1x_AF1_vt;      /** @brief G2_TIM1x_TIM1x_AF1 register value type. */
    typedef uint32_t G2_TIM1x_TIM1x_TISEL_vt;    /** @brief G2_TIM1x_TIM1x_TISEL register value type. */

    /**** @subsection G2_TIM1 Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* G2_TIM1x_CRx_pt;            /** @brief G2_TIM1x_CRx pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_DIER_pt;           /** @brief G2_TIM1x_DIER pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_SR_pt;             /** @brief G2_TIM1x_SR pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_EGR_pt;            /** @brief G2_TIM1x_EGR pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_CCMR1_OUTPUT_pt;   /** @brief G2_TIM1x_CCMR1_OUTPUT pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_CCMR1_INPUT_pt;    /** @brief G2_TIM1x_CCMR1_INPUT pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_CCER_pt;           /** @brief G2_TIM1x_CCER pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_CNT_pt;            /** @brief G2_TIM1x_CNT pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_PSC_pt;            /** @brief G2_TIM1x_PSC pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_ARR_pt;            /** @brief G2_TIM1x_ARR pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_RCR_pt;            /** @brief G2_TIM1x_RCR pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_CCR1_pt;           /** @brief G2_TIM1x_CCR1 pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_BDTR_pt;           /** @brief G2_TIM1x_BDTR pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_DCR_pt;            /** @brief G2_TIM1x_DCR pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_DMAR_pt;           /** @brief G2_TIM1x_DMAR pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_TIM1x_AF1_pt;      /** @brief G2_TIM1x_TIM1x_AF1 pointer register pointer type. */
    typedef RW_ uint32_t* G2_TIM1x_TIM1x_TISEL_pt;    /** @brief G2_TIM1x_TIM1x_TISEL pointer register pointer type. */

    /**** @subsection G2_TIM1 Field Mask Definitions ****/

    static const uint32_t G2_TIM1x_CRx_UIFREMAP_MASK[8] = {
      [7] = 0x00000800U,   /** @brief UIF status bit remapping */
      [6] = 0x00000800U   /** @brief UIF status bit remapping */
    };

    static const uint32_t G2_TIM1x_DIER_COMDE_MASK[8] = {
      [7] = 0x00002000U,   /** @brief COM DMA request enable */
      [6] = 0x00002000U   /** @brief COM DMA request enable */
    };

    static const uint32_t G2_TIM1x_SR_UIF_MASK[8] = {
      [7] = 0x00000001U,   /** @brief Update interrupt flag */
      [6] = 0x00000001U   /** @brief Update interrupt flag */
    };

    static const uint32_t G2_TIM1x_EGR_UG_MASK[8] = {
      [7] = 0x00000001U,   /** @brief Update generation */
      [6] = 0x00000001U   /** @brief Update generation */
    };

    static const uint32_t G2_TIM1x_CCMR1_OUTPUT_OC1M_3_MASK[8] = {
      [7] = 0x00010000U,   /** @brief Output compare 1 mode */
      [6] = 0x00010000U   /** @brief Output compare 1 mode */
    };

    static const uint32_t G2_TIM1x_CCMR1_INPUT_CC1S_MASK[8] = {
      [7] = 0x00000003U,   /** @brief Capture/Compare 1 selection */
      [6] = 0x00000003U   /** @brief Capture/Compare 1 selection */
    };

    static const uint32_t G2_TIM1x_CCER_CC1E_MASK[8] = {
      [7] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
      [6] = 0x00000001U   /** @brief Capture/Compare 1 output enable */
    };

    static const uint32_t G2_TIM1x_CNT_UIFCPY_MASK[8] = {
      [7] = 0x80000000U,   /** @brief UIF copy */
      [6] = 0x80000000U   /** @brief UIF copy */
    };

    static const uint32_t G2_TIM1x_PSC_PSC_MASK[8] = {
      [7] = 0x0000FFFFU,   /** @brief Prescaler value */
      [6] = 0x0000FFFFU   /** @brief Prescaler value */
    };

    static const uint32_t G2_TIM1x_ARR_ARR_MASK[8] = {
      [7] = 0x0000FFFFU,   /** @brief Auto-reload value */
      [6] = 0x0000FFFFU   /** @brief Auto-reload value */
    };

    static const uint32_t G2_TIM1x_RCR_REP_MASK[8] = {
      [7] = 0x000000FFU,   /** @brief Repetition counter value */
      [6] = 0x000000FFU   /** @brief Repetition counter value */
    };

    static const uint32_t G2_TIM1x_CCR1_CCR1_MASK[8] = {
      [7] = 0x0000FFFFU,   /** @brief Capture/Compare 1 value */
      [6] = 0x0000FFFFU   /** @brief Capture/Compare 1 value */
    };

    static const uint32_t G2_TIM1x_BDTR_BKF_MASK[8] = {
      [7] = 0x000F0000U,   /** @brief Break filter */
      [6] = 0x000F0000U   /** @brief Break filter */
    };

    static const uint32_t G2_TIM1x_DCR_DBA_MASK[8] = {
      [7] = 0x0000001FU,   /** @brief DMA base address */
      [6] = 0x0000001FU   /** @brief DMA base address */
    };

    static const uint32_t G2_TIM1x_DMAR_DMAB_MASK[8] = {
      [7] = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [6] = 0x0000FFFFU   /** @brief DMA register for burst accesses */
    };

    static const uint32_t G2_TIM1x_TIM1x_TISEL_TI1SEL_MASK[8] = {
      [7] = 0x0000000FU,   /** @brief Selects TI1[0] to TI1[15] input */
      [6] = 0x0000000FU   /** @brief Selects TI1[0] to TI1[15] input */
    };

    static const uint32_t G2_TIM1x_TIM1x_AF1_BKCMPxP_MASK[8][3] = {
      [7] = {
        [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
        [1] = 0x00000400U   /** @brief BRK COMP1 input polarity */
      },
      [6] = {
        [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
        [1] = 0x00000400U   /** @brief BRK COMP1 input polarity */
      }
    };

    /**********************************************************************************************
     * @section TIM15 Register Definitions
     **********************************************************************************************/

    /**** @subsection TIM15 Register Pointer Definitions ****/

    static RW_ uint32_t* const TIM15_SMCR_PTR         = (RW_ uint32_t*)0x40014008U;   /** @brief Slave mode control register */
    static RW_ uint32_t* const TIM15_DIER_PTR         = (RW_ uint32_t*)0x4001400CU;   /** @brief DMA/Interrupt enable register */
    static RW_ uint32_t* const TIM15_SR_PTR           = (RW_ uint32_t*)0x40014010U;   /** @brief Status register */
    static RW_ uint32_t* const TIM15_EGR_PTR          = (RW_ uint32_t*)0x40014014U;   /** @brief Event generation register */
    static RW_ uint32_t* const TIM15_CCMR1_OUTPUT_PTR = (RW_ uint32_t*)0x40014018U;   /** @brief Capture/compare mode register (output mode) */
    static RW_ uint32_t* const TIM15_CCMR1_INPUT_PTR  = (RW_ uint32_t*)0x40014018U;   /** @brief Capture/compare mode register 1 (input mode) */
    static RW_ uint32_t* const TIM15_CCER_PTR         = (RW_ uint32_t*)0x40014020U;   /** @brief Capture/compare enable register */
    static RW_ uint32_t* const TIM15_CNT_PTR          = (RW_ uint32_t*)0x40014024U;   /** @brief Counter */
    static RW_ uint32_t* const TIM15_PSC_PTR          = (RW_ uint32_t*)0x40014028U;   /** @brief Prescaler */
    static RW_ uint32_t* const TIM15_ARR_PTR          = (RW_ uint32_t*)0x4001402CU;   /** @brief Auto-reload register */
    static RW_ uint32_t* const TIM15_RCR_PTR          = (RW_ uint32_t*)0x40014030U;   /** @brief Repetition counter register */
    static RW_ uint32_t* const TIM15_BDTR_PTR         = (RW_ uint32_t*)0x40014044U;   /** @brief Break and dead-time register */
    static RW_ uint32_t* const TIM15_DCR_PTR          = (RW_ uint32_t*)0x40014048U;   /** @brief DMA control register */
    static RW_ uint32_t* const TIM15_DMAR_PTR         = (RW_ uint32_t*)0x4001404CU;   /** @brief DMA address for full transfer */
    static RW_ uint32_t* const TIM15_AF1_PTR          = (RW_ uint32_t*)0x40014060U;   /** @brief TIM15 alternate fdfsdm1_breakon register 1 */
    static RW_ uint32_t* const TIM15_TISEL_PTR        = (RW_ uint32_t*)0x40014068U;   /** @brief TIM15 input selection register */

    static RW_ uint32_t* const TIM15_CRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40014004U,   /** @brief Control register 2 */
      [1] = (RW_ uint32_t*)0x40014000U   /** @brief Control register 1 */
    };

    static RW_ uint32_t* const TIM15_CCRx_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40014038U,   /** @brief Capture/compare register 2 */
      [1] = (RW_ uint32_t*)0x40014034U   /** @brief Capture/compare register 1 */
    };

    /**** @subsection TIM15 Register Reset Value Definitions ****/

    static const uint32_t TIM15_SMCR_RST         = 0x00000000U;   /** @brief Slave mode control register */
    static const uint32_t TIM15_DIER_RST         = 0x00000000U;   /** @brief DMA/Interrupt enable register */
    static const uint32_t TIM15_SR_RST           = 0x00000000U;   /** @brief Status register */
    static const uint32_t TIM15_EGR_RST          = 0x00000000U;   /** @brief Event generation register */
    static const uint32_t TIM15_CCMR1_OUTPUT_RST = 0x00000000U;   /** @brief Capture/compare mode register (output mode) */
    static const uint32_t TIM15_CCMR1_INPUT_RST  = 0x00000000U;   /** @brief Capture/compare mode register 1 (input mode) */
    static const uint32_t TIM15_CCER_RST         = 0x00000000U;   /** @brief Capture/compare enable register */
    static const uint32_t TIM15_CNT_RST          = 0x00000000U;   /** @brief Counter */
    static const uint32_t TIM15_PSC_RST          = 0x00000000U;   /** @brief Prescaler */
    static const uint32_t TIM15_ARR_RST          = 0x00000000U;   /** @brief Auto-reload register */
    static const uint32_t TIM15_RCR_RST          = 0x00000000U;   /** @brief Repetition counter register */
    static const uint32_t TIM15_BDTR_RST         = 0x00000000U;   /** @brief Break and dead-time register */
    static const uint32_t TIM15_DCR_RST          = 0x00000000U;   /** @brief DMA control register */
    static const uint32_t TIM15_DMAR_RST         = 0x00000000U;   /** @brief DMA address for full transfer */
    static const uint32_t TIM15_AF1_RST          = 0x00000000U;   /** @brief TIM15 alternate fdfsdm1_breakon register 1 */
    static const uint32_t TIM15_TISEL_RST        = 0x00000000U;   /** @brief TIM15 input selection register */

    static const uint32_t TIM15_CRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Control register 2 */
      [1] = 0x00000000U   /** @brief Control register 1 */
    };

    static const uint32_t TIM15_CCRx_RST[3] = {
      [2] = 0x00000000U,   /** @brief Capture/compare register 2 */
      [1] = 0x00000000U   /** @brief Capture/compare register 1 */
    };

    /**** @subsection TIM15 Register Value Type Definitions ****/

    typedef uint32_t TIM15_CRx_vt;            /** @brief TIM15_CRx register value type. */
    typedef uint32_t TIM15_SMCR_vt;           /** @brief TIM15_SMCR register value type. */
    typedef uint32_t TIM15_DIER_vt;           /** @brief TIM15_DIER register value type. */
    typedef uint32_t TIM15_SR_vt;             /** @brief TIM15_SR register value type. */
    typedef uint32_t TIM15_EGR_vt;            /** @brief TIM15_EGR register value type. */
    typedef uint32_t TIM15_CCMR1_OUTPUT_vt;   /** @brief TIM15_CCMR1_OUTPUT register value type. */
    typedef uint32_t TIM15_CCMR1_INPUT_vt;    /** @brief TIM15_CCMR1_INPUT register value type. */
    typedef uint32_t TIM15_CCER_vt;           /** @brief TIM15_CCER register value type. */
    typedef uint32_t TIM15_CNT_vt;            /** @brief TIM15_CNT register value type. */
    typedef uint32_t TIM15_PSC_vt;            /** @brief TIM15_PSC register value type. */
    typedef uint32_t TIM15_ARR_vt;            /** @brief TIM15_ARR register value type. */
    typedef uint32_t TIM15_RCR_vt;            /** @brief TIM15_RCR register value type. */
    typedef uint32_t TIM15_CCRx_vt;           /** @brief TIM15_CCRx register value type. */
    typedef uint32_t TIM15_BDTR_vt;           /** @brief TIM15_BDTR register value type. */
    typedef uint32_t TIM15_DCR_vt;            /** @brief TIM15_DCR register value type. */
    typedef uint32_t TIM15_DMAR_vt;           /** @brief TIM15_DMAR register value type. */
    typedef uint32_t TIM15_AF1_vt;            /** @brief TIM15_AF1 register value type. */
    typedef uint32_t TIM15_TISEL_vt;          /** @brief TIM15_TISEL register value type. */

    /**** @subsection TIM15 Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* TIM15_CRx_pt;            /** @brief TIM15_CRx pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_SMCR_pt;           /** @brief TIM15_SMCR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_DIER_pt;           /** @brief TIM15_DIER pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_SR_pt;             /** @brief TIM15_SR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_EGR_pt;            /** @brief TIM15_EGR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_CCMR1_OUTPUT_pt;   /** @brief TIM15_CCMR1_OUTPUT pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_CCMR1_INPUT_pt;    /** @brief TIM15_CCMR1_INPUT pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_CCER_pt;           /** @brief TIM15_CCER pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_CNT_pt;            /** @brief TIM15_CNT pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_PSC_pt;            /** @brief TIM15_PSC pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_ARR_pt;            /** @brief TIM15_ARR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_RCR_pt;            /** @brief TIM15_RCR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_CCRx_pt;           /** @brief TIM15_CCRx pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_BDTR_pt;           /** @brief TIM15_BDTR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_DCR_pt;            /** @brief TIM15_DCR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_DMAR_pt;           /** @brief TIM15_DMAR pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_AF1_pt;            /** @brief TIM15_AF1 pointer register pointer type. */
    typedef RW_ uint32_t* TIM15_TISEL_pt;          /** @brief TIM15_TISEL pointer register pointer type. */

    /**** @subsection TIM15 Field Mask Definitions ****/

    static const uint32_t TIM15_CRx_UIFREMAP_MASK = 0x00000800U;   /** @brief UIF status bit remapping */
    static const uint32_t TIM15_SMCR_TS_4_3_MASK  = 0x00300000U;   /** @brief Trigger selection - bit 4:3 */
    static const uint32_t TIM15_DIER_TDE_MASK     = 0x00004000U;   /** @brief Trigger DMA request enable */
    static const uint32_t TIM15_SR_UIF_MASK       = 0x00000001U;   /** @brief Update interrupt flag */
    static const uint32_t TIM15_EGR_UG_MASK       = 0x00000001U;   /** @brief Update generation */
    static const uint32_t TIM15_CCER_CC1NE_MASK   = 0x00000004U;   /** @brief Capture/Compare 1 complementary output enable */
    static const uint32_t TIM15_CNT_UIFCPY_MASK   = 0x80000000U;   /** @brief UIF copy */
    static const uint32_t TIM15_PSC_PSC_MASK      = 0x0000FFFFU;   /** @brief Prescaler value */
    static const uint32_t TIM15_ARR_ARR_MASK      = 0x0000FFFFU;   /** @brief Auto-reload value */
    static const uint32_t TIM15_RCR_REP_MASK      = 0x000000FFU;   /** @brief Repetition counter value */
    static const uint32_t TIM15_BDTR_BKF_MASK     = 0x000F0000U;   /** @brief Break filter */
    static const uint32_t TIM15_DCR_DBA_MASK      = 0x0000001FU;   /** @brief DMA base address */
    static const uint32_t TIM15_DMAR_DMAB_MASK    = 0x0000FFFFU;   /** @brief DMA register for burst accesses */

    static const uint32_t TIM15_CCMR1_OUTPUT_OCxM_3_MASK[3] = {
      [2] = 0x01000000U,   /** @brief Output compare 2 mode bit 3 */
      [1] = 0x00010000U   /** @brief Output compare 1 mode bit 3 */
    };

    static const uint32_t TIM15_CCMR1_INPUT_CCxS_MASK[3] = {
      [1] = 0x00000003U,   /** @brief Capture/Compare 1 selection */
      [2] = 0x00000300U   /** @brief Capture/Compare 2 selection */
    };

    static const uint32_t TIM15_CCRx_CCRx_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Capture/Compare 2 value */
      [1] = 0x0000FFFFU   /** @brief Capture/Compare 1 value */
    };

    static const uint32_t TIM15_AF1_BKCMPxP_MASK[3] = {
      [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
      [1] = 0x00000400U   /** @brief BRK COMP1 input polarity */
    };

    static const uint32_t TIM15_TISEL_TIxSEL_MASK[3] = {
      [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
      [1] = 0x0000000FU   /** @brief Selects TI1[0] to TI1[15] input */
    };

    /**********************************************************************************************
     * @section USART Register Definitions
     **********************************************************************************************/

    /**** @subsection USART Register Pointer Definitions ****/

    static RW_ uint32_t* const USARTx_BRR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x4000440CU,   /** @brief Baud rate register */
      [3] = (RW_ uint32_t*)0x4000480CU,   /** @brief Baud rate register */
      [6] = (RW_ uint32_t*)0x4001140CU,   /** @brief Baud rate register */
      [1] = (RW_ uint32_t*)0x4001100CU   /** @brief Baud rate register */
    };

    static RW_ uint32_t* const USARTx_GTPR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40004410U,   /** @brief Guard time and prescaler register */
      [3] = (RW_ uint32_t*)0x40004810U,   /** @brief Guard time and prescaler register */
      [6] = (RW_ uint32_t*)0x40011410U,   /** @brief Guard time and prescaler register */
      [1] = (RW_ uint32_t*)0x40011010U   /** @brief Guard time and prescaler register */
    };

    static RW_ uint32_t* const USARTx_RTOR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40004414U,   /** @brief Receiver timeout register */
      [3] = (RW_ uint32_t*)0x40004814U,   /** @brief Receiver timeout register */
      [6] = (RW_ uint32_t*)0x40011414U,   /** @brief Receiver timeout register */
      [1] = (RW_ uint32_t*)0x40011014U   /** @brief Receiver timeout register */
    };

    static RW_ uint32_t* const USARTx_RQR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40004418U,   /** @brief Request register */
      [3] = (RW_ uint32_t*)0x40004818U,   /** @brief Request register */
      [6] = (RW_ uint32_t*)0x40011418U,   /** @brief Request register */
      [1] = (RW_ uint32_t*)0x40011018U   /** @brief Request register */
    };

    static RO_ uint32_t* const USARTx_ISR_PTR[7] = {
      [2] = (RO_ uint32_t*)0x4000441CU,   /** @brief Interrupt & status register */
      [3] = (RO_ uint32_t*)0x4000481CU,   /** @brief Interrupt & status register */
      [6] = (RO_ uint32_t*)0x4001141CU,   /** @brief Interrupt & status register */
      [1] = (RO_ uint32_t*)0x4001101CU   /** @brief Interrupt & status register */
    };

    static RW_ uint32_t* const USARTx_ICR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40004420U,   /** @brief Interrupt flag clear register */
      [3] = (RW_ uint32_t*)0x40004820U,   /** @brief Interrupt flag clear register */
      [6] = (RW_ uint32_t*)0x40011420U,   /** @brief Interrupt flag clear register */
      [1] = (RW_ uint32_t*)0x40011020U   /** @brief Interrupt flag clear register */
    };

    static RO_ uint32_t* const USARTx_RDR_PTR[7] = {
      [2] = (RO_ uint32_t*)0x40004424U,   /** @brief Receive data register */
      [3] = (RO_ uint32_t*)0x40004824U,   /** @brief Receive data register */
      [6] = (RO_ uint32_t*)0x40011424U,   /** @brief Receive data register */
      [1] = (RO_ uint32_t*)0x40011024U   /** @brief Receive data register */
    };

    static RW_ uint32_t* const USARTx_TDR_PTR[7] = {
      [2] = (RW_ uint32_t*)0x40004428U,   /** @brief Transmit data register */
      [3] = (RW_ uint32_t*)0x40004828U,   /** @brief Transmit data register */
      [6] = (RW_ uint32_t*)0x40011428U,   /** @brief Transmit data register */
      [1] = (RW_ uint32_t*)0x40011028U   /** @brief Transmit data register */
    };

    static RW_ uint32_t* const USARTx_PRESC_PTR[7] = {
      [2] = (RW_ uint32_t*)0x4000442CU,   /** @brief USART prescaler register */
      [3] = (RW_ uint32_t*)0x4000482CU,   /** @brief USART prescaler register */
      [6] = (RW_ uint32_t*)0x4001142CU,   /** @brief USART prescaler register */
      [1] = (RW_ uint32_t*)0x4001102CU   /** @brief USART prescaler register */
    };

    /**** @subsection USART Register Reset Value Definitions ****/

    static const uint32_t USARTx_BRR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Baud rate register */
      [3] = 0x00000000U,   /** @brief Baud rate register */
      [6] = 0x00000000U,   /** @brief Baud rate register */
      [1] = 0x00000000U   /** @brief Baud rate register */
    };

    static const uint32_t USARTx_GTPR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Guard time and prescaler register */
      [3] = 0x00000000U,   /** @brief Guard time and prescaler register */
      [6] = 0x00000000U,   /** @brief Guard time and prescaler register */
      [1] = 0x00000000U   /** @brief Guard time and prescaler register */
    };

    static const uint32_t USARTx_RTOR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Receiver timeout register */
      [3] = 0x00000000U,   /** @brief Receiver timeout register */
      [6] = 0x00000000U,   /** @brief Receiver timeout register */
      [1] = 0x00000000U   /** @brief Receiver timeout register */
    };

    static const uint32_t USARTx_RQR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Request register */
      [3] = 0x00000000U,   /** @brief Request register */
      [6] = 0x00000000U,   /** @brief Request register */
      [1] = 0x00000000U   /** @brief Request register */
    };

    static const uint32_t USARTx_ISR_RST[7] = {
      [2] = 0x000000C0U,   /** @brief Interrupt & status register */
      [3] = 0x000000C0U,   /** @brief Interrupt & status register */
      [6] = 0x000000C0U,   /** @brief Interrupt & status register */
      [1] = 0x000000C0U   /** @brief Interrupt & status register */
    };

    static const uint32_t USARTx_ICR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Interrupt flag clear register */
      [3] = 0x00000000U,   /** @brief Interrupt flag clear register */
      [6] = 0x00000000U,   /** @brief Interrupt flag clear register */
      [1] = 0x00000000U   /** @brief Interrupt flag clear register */
    };

    static const uint32_t USARTx_RDR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Receive data register */
      [3] = 0x00000000U,   /** @brief Receive data register */
      [6] = 0x00000000U,   /** @brief Receive data register */
      [1] = 0x00000000U   /** @brief Receive data register */
    };

    static const uint32_t USARTx_TDR_RST[7] = {
      [2] = 0x00000000U,   /** @brief Transmit data register */
      [3] = 0x00000000U,   /** @brief Transmit data register */
      [6] = 0x00000000U,   /** @brief Transmit data register */
      [1] = 0x00000000U   /** @brief Transmit data register */
    };

    static const uint32_t USARTx_PRESC_RST[7] = {
      [2] = 0x00000000U,   /** @brief USART prescaler register */
      [3] = 0x00000000U,   /** @brief USART prescaler register */
      [6] = 0x00000000U,   /** @brief USART prescaler register */
      [1] = 0x00000000U   /** @brief USART prescaler register */
    };

    /**** @subsection USART Register Value Type Definitions ****/

    typedef uint32_t USARTx_CRx_vt;     /** @brief USARTx_CRx register value type. */
    typedef uint32_t USARTx_BRR_vt;     /** @brief USARTx_BRR register value type. */
    typedef uint32_t USARTx_GTPR_vt;    /** @brief USARTx_GTPR register value type. */
    typedef uint32_t USARTx_RTOR_vt;    /** @brief USARTx_RTOR register value type. */
    typedef uint32_t USARTx_RQR_vt;     /** @brief USARTx_RQR register value type. */
    typedef uint32_t USARTx_ISR_vt;     /** @brief USARTx_ISR register value type. */
    typedef uint32_t USARTx_ICR_vt;     /** @brief USARTx_ICR register value type. */
    typedef uint32_t USARTx_RDR_vt;     /** @brief USARTx_RDR register value type. */
    typedef uint32_t USARTx_TDR_vt;     /** @brief USARTx_TDR register value type. */
    typedef uint32_t USARTx_PRESC_vt;   /** @brief USARTx_PRESC register value type. */

    /**** @subsection USART Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* USARTx_CRx_pt;     /** @brief USARTx_CRx pointer register pointer type. */
    typedef RW_ uint32_t* USARTx_BRR_pt;     /** @brief USARTx_BRR pointer register pointer type. */
    typedef RW_ uint32_t* USARTx_GTPR_pt;    /** @brief USARTx_GTPR pointer register pointer type. */
    typedef RW_ uint32_t* USARTx_RTOR_pt;    /** @brief USARTx_RTOR pointer register pointer type. */
    typedef RW_ uint32_t* USARTx_RQR_pt;     /** @brief USARTx_RQR pointer register pointer type. */
    typedef RO_ uint32_t* USARTx_ISR_pt;     /** @brief USARTx_ISR pointer register pointer type. */
    typedef RW_ uint32_t* USARTx_ICR_pt;     /** @brief USARTx_ICR pointer register pointer type. */
    typedef RO_ uint32_t* USARTx_RDR_pt;     /** @brief USARTx_RDR pointer register pointer type. */
    typedef RW_ uint32_t* USARTx_TDR_pt;     /** @brief USARTx_TDR pointer register pointer type. */
    typedef RW_ uint32_t* USARTx_PRESC_pt;   /** @brief USARTx_PRESC pointer register pointer type. */

    /**** @subsection USART Field Mask Definitions ****/

    static const uint32_t USARTx_CRx_UE_MASK[7] = {
      [2] = 0x00000001U,   /** @brief USART enable */
      [3] = 0x00000001U,   /** @brief USART enable */
      [6] = 0x00000001U,   /** @brief USART enable */
      [1] = 0x00000001U   /** @brief USART enable */
    };

    static const uint32_t USARTx_BRR_BRR_0_3_MASK[7] = {
      [2] = 0x0000000FU,   /** @brief DIV_Fraction */
      [3] = 0x0000000FU,   /** @brief DIV_Fraction */
      [6] = 0x0000000FU,   /** @brief DIV_Fraction */
      [1] = 0x0000000FU   /** @brief DIV_Fraction */
    };

    static const uint32_t USARTx_GTPR_PSC_MASK[7] = {
      [2] = 0x000000FFU,   /** @brief Prescaler value */
      [3] = 0x000000FFU,   /** @brief Prescaler value */
      [6] = 0x000000FFU,   /** @brief Prescaler value */
      [1] = 0x000000FFU   /** @brief Prescaler value */
    };

    static const uint32_t USARTx_RTOR_RTO_MASK[7] = {
      [2] = 0x00FFFFFFU,   /** @brief Receiver timeout value */
      [3] = 0x00FFFFFFU,   /** @brief Receiver timeout value */
      [6] = 0x00FFFFFFU,   /** @brief Receiver timeout value */
      [1] = 0x00FFFFFFU   /** @brief Receiver timeout value */
    };

    static const uint32_t USARTx_RQR_ABRRQ_MASK[7] = {
      [2] = 0x00000001U,   /** @brief Auto baud rate request */
      [3] = 0x00000001U,   /** @brief Auto baud rate request */
      [6] = 0x00000001U,   /** @brief Auto baud rate request */
      [1] = 0x00000001U   /** @brief Auto baud rate request */
    };

    static const uint32_t USARTx_ISR_PE_MASK[7] = {
      [2] = 0x00000001U,   /** @brief PE */
      [3] = 0x00000001U,   /** @brief PE */
      [6] = 0x00000001U,   /** @brief PE */
      [1] = 0x00000001U   /** @brief PE */
    };

    static const uint32_t USARTx_ICR_PECF_MASK[7] = {
      [2] = 0x00000001U,   /** @brief Parity error clear flag */
      [3] = 0x00000001U,   /** @brief Parity error clear flag */
      [6] = 0x00000001U,   /** @brief Parity error clear flag */
      [1] = 0x00000001U   /** @brief Parity error clear flag */
    };

    static const uint32_t USARTx_RDR_RDR_MASK[7] = {
      [2] = 0x000001FFU,   /** @brief Receive data value */
      [3] = 0x000001FFU,   /** @brief Receive data value */
      [6] = 0x000001FFU,   /** @brief Receive data value */
      [1] = 0x000001FFU   /** @brief Receive data value */
    };

    static const uint32_t USARTx_TDR_TDR_MASK[7] = {
      [2] = 0x000001FFU,   /** @brief Transmit data value */
      [3] = 0x000001FFU,   /** @brief Transmit data value */
      [6] = 0x000001FFU,   /** @brief Transmit data value */
      [1] = 0x000001FFU   /** @brief Transmit data value */
    };

    static const uint32_t USARTx_PRESC_PRESCALER_MASK[7] = {
      [2] = 0x0000000FU,   /** @brief Clock prescaler */
      [3] = 0x0000000FU,   /** @brief Clock prescaler */
      [6] = 0x0000000FU,   /** @brief Clock prescaler */
      [1] = 0x0000000FU   /** @brief Clock prescaler */
    };

    /**********************************************************************************************
     * @section UART Register Definitions
     **********************************************************************************************/

    /**** @subsection UART Register Pointer Definitions ****/

    static RW_ uint32_t* const UARTx_BRR_PTR[9] = {
      [5] = (RW_ uint32_t*)0x4000500CU,   /** @brief Baud rate register */
      [7] = (RW_ uint32_t*)0x4000780CU,   /** @brief Baud rate register */
      [8] = (RW_ uint32_t*)0x40007C0CU,   /** @brief Baud rate register */
      [4] = (RW_ uint32_t*)0x40004C0CU   /** @brief Baud rate register */
    };

    static RW_ uint32_t* const UARTx_GTPR_PTR[9] = {
      [5] = (RW_ uint32_t*)0x40005010U,   /** @brief Guard time and prescaler register */
      [7] = (RW_ uint32_t*)0x40007810U,   /** @brief Guard time and prescaler register */
      [8] = (RW_ uint32_t*)0x40007C10U,   /** @brief Guard time and prescaler register */
      [4] = (RW_ uint32_t*)0x40004C10U   /** @brief Guard time and prescaler register */
    };

    static RW_ uint32_t* const UARTx_RTOR_PTR[9] = {
      [5] = (RW_ uint32_t*)0x40005014U,   /** @brief Receiver timeout register */
      [7] = (RW_ uint32_t*)0x40007814U,   /** @brief Receiver timeout register */
      [8] = (RW_ uint32_t*)0x40007C14U,   /** @brief Receiver timeout register */
      [4] = (RW_ uint32_t*)0x40004C14U   /** @brief Receiver timeout register */
    };

    static RW_ uint32_t* const UARTx_RQR_PTR[9] = {
      [5] = (RW_ uint32_t*)0x40005018U,   /** @brief Request register */
      [7] = (RW_ uint32_t*)0x40007818U,   /** @brief Request register */
      [8] = (RW_ uint32_t*)0x40007C18U,   /** @brief Request register */
      [4] = (RW_ uint32_t*)0x40004C18U   /** @brief Request register */
    };

    static RO_ uint32_t* const UARTx_ISR_PTR[9] = {
      [5] = (RO_ uint32_t*)0x4000501CU,   /** @brief Interrupt & status register */
      [7] = (RO_ uint32_t*)0x4000781CU,   /** @brief Interrupt & status register */
      [8] = (RO_ uint32_t*)0x40007C1CU,   /** @brief Interrupt & status register */
      [4] = (RO_ uint32_t*)0x40004C1CU   /** @brief Interrupt & status register */
    };

    static RW_ uint32_t* const UARTx_ICR_PTR[9] = {
      [5] = (RW_ uint32_t*)0x40005020U,   /** @brief Interrupt flag clear register */
      [7] = (RW_ uint32_t*)0x40007820U,   /** @brief Interrupt flag clear register */
      [8] = (RW_ uint32_t*)0x40007C20U,   /** @brief Interrupt flag clear register */
      [4] = (RW_ uint32_t*)0x40004C20U   /** @brief Interrupt flag clear register */
    };

    static RO_ uint32_t* const UARTx_RDR_PTR[9] = {
      [5] = (RO_ uint32_t*)0x40005024U,   /** @brief Receive data register */
      [7] = (RO_ uint32_t*)0x40007824U,   /** @brief Receive data register */
      [8] = (RO_ uint32_t*)0x40007C24U,   /** @brief Receive data register */
      [4] = (RO_ uint32_t*)0x40004C24U   /** @brief Receive data register */
    };

    static RW_ uint32_t* const UARTx_TDR_PTR[9] = {
      [5] = (RW_ uint32_t*)0x40005028U,   /** @brief Transmit data register */
      [7] = (RW_ uint32_t*)0x40007828U,   /** @brief Transmit data register */
      [8] = (RW_ uint32_t*)0x40007C28U,   /** @brief Transmit data register */
      [4] = (RW_ uint32_t*)0x40004C28U   /** @brief Transmit data register */
    };

    static RW_ uint32_t* const UARTx_PRESC_PTR[9] = {
      [5] = (RW_ uint32_t*)0x4000502CU,   /** @brief USART prescaler register */
      [7] = (RW_ uint32_t*)0x4000782CU,   /** @brief USART prescaler register */
      [8] = (RW_ uint32_t*)0x40007C2CU,   /** @brief USART prescaler register */
      [4] = (RW_ uint32_t*)0x40004C2CU   /** @brief USART prescaler register */
    };

    /**** @subsection UART Register Reset Value Definitions ****/

    static const uint32_t UARTx_BRR_RST[9] = {
      [5] = 0x00000000U,   /** @brief Baud rate register */
      [7] = 0x00000000U,   /** @brief Baud rate register */
      [8] = 0x00000000U,   /** @brief Baud rate register */
      [4] = 0x00000000U   /** @brief Baud rate register */
    };

    static const uint32_t UARTx_GTPR_RST[9] = {
      [5] = 0x00000000U,   /** @brief Guard time and prescaler register */
      [7] = 0x00000000U,   /** @brief Guard time and prescaler register */
      [8] = 0x00000000U,   /** @brief Guard time and prescaler register */
      [4] = 0x00000000U   /** @brief Guard time and prescaler register */
    };

    static const uint32_t UARTx_RTOR_RST[9] = {
      [5] = 0x00000000U,   /** @brief Receiver timeout register */
      [7] = 0x00000000U,   /** @brief Receiver timeout register */
      [8] = 0x00000000U,   /** @brief Receiver timeout register */
      [4] = 0x00000000U   /** @brief Receiver timeout register */
    };

    static const uint32_t UARTx_RQR_RST[9] = {
      [5] = 0x00000000U,   /** @brief Request register */
      [7] = 0x00000000U,   /** @brief Request register */
      [8] = 0x00000000U,   /** @brief Request register */
      [4] = 0x00000000U   /** @brief Request register */
    };

    static const uint32_t UARTx_ISR_RST[9] = {
      [5] = 0x000000C0U,   /** @brief Interrupt & status register */
      [7] = 0x000000C0U,   /** @brief Interrupt & status register */
      [8] = 0x000000C0U,   /** @brief Interrupt & status register */
      [4] = 0x000000C0U   /** @brief Interrupt & status register */
    };

    static const uint32_t UARTx_ICR_RST[9] = {
      [5] = 0x00000000U,   /** @brief Interrupt flag clear register */
      [7] = 0x00000000U,   /** @brief Interrupt flag clear register */
      [8] = 0x00000000U,   /** @brief Interrupt flag clear register */
      [4] = 0x00000000U   /** @brief Interrupt flag clear register */
    };

    static const uint32_t UARTx_RDR_RST[9] = {
      [5] = 0x00000000U,   /** @brief Receive data register */
      [7] = 0x00000000U,   /** @brief Receive data register */
      [8] = 0x00000000U,   /** @brief Receive data register */
      [4] = 0x00000000U   /** @brief Receive data register */
    };

    static const uint32_t UARTx_TDR_RST[9] = {
      [5] = 0x00000000U,   /** @brief Transmit data register */
      [7] = 0x00000000U,   /** @brief Transmit data register */
      [8] = 0x00000000U,   /** @brief Transmit data register */
      [4] = 0x00000000U   /** @brief Transmit data register */
    };

    static const uint32_t UARTx_PRESC_RST[9] = {
      [5] = 0x00000000U,   /** @brief USART prescaler register */
      [7] = 0x00000000U,   /** @brief USART prescaler register */
      [8] = 0x00000000U,   /** @brief USART prescaler register */
      [4] = 0x00000000U   /** @brief USART prescaler register */
    };

    /**** @subsection UART Register Value Type Definitions ****/

    typedef uint32_t UARTx_CRx_vt;     /** @brief UARTx_CRx register value type. */
    typedef uint32_t UARTx_BRR_vt;     /** @brief UARTx_BRR register value type. */
    typedef uint32_t UARTx_GTPR_vt;    /** @brief UARTx_GTPR register value type. */
    typedef uint32_t UARTx_RTOR_vt;    /** @brief UARTx_RTOR register value type. */
    typedef uint32_t UARTx_RQR_vt;     /** @brief UARTx_RQR register value type. */
    typedef uint32_t UARTx_ISR_vt;     /** @brief UARTx_ISR register value type. */
    typedef uint32_t UARTx_ICR_vt;     /** @brief UARTx_ICR register value type. */
    typedef uint32_t UARTx_RDR_vt;     /** @brief UARTx_RDR register value type. */
    typedef uint32_t UARTx_TDR_vt;     /** @brief UARTx_TDR register value type. */
    typedef uint32_t UARTx_PRESC_vt;   /** @brief UARTx_PRESC register value type. */

    /**** @subsection UART Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* UARTx_CRx_pt;     /** @brief UARTx_CRx pointer register pointer type. */
    typedef RW_ uint32_t* UARTx_BRR_pt;     /** @brief UARTx_BRR pointer register pointer type. */
    typedef RW_ uint32_t* UARTx_GTPR_pt;    /** @brief UARTx_GTPR pointer register pointer type. */
    typedef RW_ uint32_t* UARTx_RTOR_pt;    /** @brief UARTx_RTOR pointer register pointer type. */
    typedef RW_ uint32_t* UARTx_RQR_pt;     /** @brief UARTx_RQR pointer register pointer type. */
    typedef RO_ uint32_t* UARTx_ISR_pt;     /** @brief UARTx_ISR pointer register pointer type. */
    typedef RW_ uint32_t* UARTx_ICR_pt;     /** @brief UARTx_ICR pointer register pointer type. */
    typedef RO_ uint32_t* UARTx_RDR_pt;     /** @brief UARTx_RDR pointer register pointer type. */
    typedef RW_ uint32_t* UARTx_TDR_pt;     /** @brief UARTx_TDR pointer register pointer type. */
    typedef RW_ uint32_t* UARTx_PRESC_pt;   /** @brief UARTx_PRESC pointer register pointer type. */

    /**** @subsection UART Field Mask Definitions ****/

    static const uint32_t UARTx_CRx_UE_MASK[9] = {
      [5] = 0x00000001U,   /** @brief USART enable */
      [7] = 0x00000001U,   /** @brief USART enable */
      [8] = 0x00000001U,   /** @brief USART enable */
      [4] = 0x00000001U   /** @brief USART enable */
    };

    static const uint32_t UARTx_BRR_BRR_0_3_MASK[9] = {
      [5] = 0x0000000FU,   /** @brief DIV_Fraction */
      [7] = 0x0000000FU,   /** @brief DIV_Fraction */
      [8] = 0x0000000FU,   /** @brief DIV_Fraction */
      [4] = 0x0000000FU   /** @brief DIV_Fraction */
    };

    static const uint32_t UARTx_GTPR_PSC_MASK[9] = {
      [5] = 0x000000FFU,   /** @brief Prescaler value */
      [7] = 0x000000FFU,   /** @brief Prescaler value */
      [8] = 0x000000FFU,   /** @brief Prescaler value */
      [4] = 0x000000FFU   /** @brief Prescaler value */
    };

    static const uint32_t UARTx_RTOR_RTO_MASK[9] = {
      [5] = 0x00FFFFFFU,   /** @brief Receiver timeout value */
      [7] = 0x00FFFFFFU,   /** @brief Receiver timeout value */
      [8] = 0x00FFFFFFU,   /** @brief Receiver timeout value */
      [4] = 0x00FFFFFFU   /** @brief Receiver timeout value */
    };

    static const uint32_t UARTx_RQR_ABRRQ_MASK[9] = {
      [5] = 0x00000001U,   /** @brief Auto baud rate request */
      [7] = 0x00000001U,   /** @brief Auto baud rate request */
      [8] = 0x00000001U,   /** @brief Auto baud rate request */
      [4] = 0x00000001U   /** @brief Auto baud rate request */
    };

    static const uint32_t UARTx_ISR_PE_MASK[9] = {
      [5] = 0x00000001U,   /** @brief PE */
      [7] = 0x00000001U,   /** @brief PE */
      [8] = 0x00000001U,   /** @brief PE */
      [4] = 0x00000001U   /** @brief PE */
    };

    static const uint32_t UARTx_ICR_PECF_MASK[9] = {
      [5] = 0x00000001U,   /** @brief Parity error clear flag */
      [7] = 0x00000001U,   /** @brief Parity error clear flag */
      [8] = 0x00000001U,   /** @brief Parity error clear flag */
      [4] = 0x00000001U   /** @brief Parity error clear flag */
    };

    static const uint32_t UARTx_RDR_RDR_MASK[9] = {
      [5] = 0x000001FFU,   /** @brief Receive data value */
      [7] = 0x000001FFU,   /** @brief Receive data value */
      [8] = 0x000001FFU,   /** @brief Receive data value */
      [4] = 0x000001FFU   /** @brief Receive data value */
    };

    static const uint32_t UARTx_TDR_TDR_MASK[9] = {
      [5] = 0x000001FFU,   /** @brief Transmit data value */
      [7] = 0x000001FFU,   /** @brief Transmit data value */
      [8] = 0x000001FFU,   /** @brief Transmit data value */
      [4] = 0x000001FFU   /** @brief Transmit data value */
    };

    static const uint32_t UARTx_PRESC_PRESCALER_MASK[9] = {
      [5] = 0x0000000FU,   /** @brief Clock prescaler */
      [7] = 0x0000000FU,   /** @brief Clock prescaler */
      [8] = 0x0000000FU,   /** @brief Clock prescaler */
      [4] = 0x0000000FU   /** @brief Clock prescaler */
    };

    /**********************************************************************************************
     * @section A_TIM Register Definitions
     **********************************************************************************************/

    /**** @subsection A_TIM Register Pointer Definitions ****/

    static RW_ uint32_t* const A_TIMx_SMCR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010408U,   /** @brief Slave mode control register */
      [1] = (RW_ uint32_t*)0x40010008U   /** @brief Slave mode control register */
    };

    static RW_ uint32_t* const A_TIMx_DIER_PTR[9] = {
      [8] = (RW_ uint32_t*)0x4001040CU,   /** @brief DMA/Interrupt enable register */
      [1] = (RW_ uint32_t*)0x4001000CU   /** @brief DMA/Interrupt enable register */
    };

    static RW_ uint32_t* const A_TIMx_SR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010410U,   /** @brief Status register */
      [1] = (RW_ uint32_t*)0x40010010U   /** @brief Status register */
    };

    static RW_ uint32_t* const A_TIMx_EGR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010414U,   /** @brief Event generation register */
      [1] = (RW_ uint32_t*)0x40010014U   /** @brief Event generation register */
    };

    static RW_ uint32_t* const A_TIMx_CCER_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010420U,   /** @brief Capture/compare enable register */
      [1] = (RW_ uint32_t*)0x40010020U   /** @brief Capture/compare enable register */
    };

    static RW_ uint32_t* const A_TIMx_CNT_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010424U,   /** @brief Counter */
      [1] = (RW_ uint32_t*)0x40010024U   /** @brief Counter */
    };

    static RW_ uint32_t* const A_TIMx_PSC_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010428U,   /** @brief Prescaler */
      [1] = (RW_ uint32_t*)0x40010028U   /** @brief Prescaler */
    };

    static RW_ uint32_t* const A_TIMx_ARR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x4001042CU,   /** @brief Auto-reload register */
      [1] = (RW_ uint32_t*)0x4001002CU   /** @brief Auto-reload register */
    };

    static RW_ uint32_t* const A_TIMx_DCR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010448U,   /** @brief DMA control register */
      [1] = (RW_ uint32_t*)0x40010048U   /** @brief DMA control register */
    };

    static RW_ uint32_t* const A_TIMx_DMAR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x4001044CU,   /** @brief DMA address for full transfer */
      [1] = (RW_ uint32_t*)0x4001004CU   /** @brief DMA address for full transfer */
    };

    static RW_ uint32_t* const A_TIMx_RCR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010430U,   /** @brief Repetition counter register */
      [1] = (RW_ uint32_t*)0x40010030U   /** @brief Repetition counter register */
    };

    static RW_ uint32_t* const A_TIMx_BDTR_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010444U,   /** @brief Break and dead-time register */
      [1] = (RW_ uint32_t*)0x40010044U   /** @brief Break and dead-time register */
    };

    static RW_ uint32_t* const A_TIMx_CRR6_PTR[9] = {
      [8] = (RW_ uint32_t*)0x4001045CU,   /** @brief Capture/compare register 6 */
      [1] = (RW_ uint32_t*)0x4001005CU   /** @brief Capture/compare register 6 */
    };

    static RW_ uint32_t* const A_TIMx_TISEL_PTR[9] = {
      [8] = (RW_ uint32_t*)0x40010468U,   /** @brief TIM1 timer input selection register */
      [1] = (RW_ uint32_t*)0x40010068U   /** @brief TIM1 timer input selection register */
    };

    /**** @subsection A_TIM Register Reset Value Definitions ****/

    static const uint32_t A_TIMx_SMCR_RST[9] = {
      [8] = 0x00000000U,   /** @brief Slave mode control register */
      [1] = 0x00000000U   /** @brief Slave mode control register */
    };

    static const uint32_t A_TIMx_DIER_RST[9] = {
      [8] = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [1] = 0x00000000U   /** @brief DMA/Interrupt enable register */
    };

    static const uint32_t A_TIMx_SR_RST[9] = {
      [8] = 0x00000000U,   /** @brief Status register */
      [1] = 0x00000000U   /** @brief Status register */
    };

    static const uint32_t A_TIMx_EGR_RST[9] = {
      [8] = 0x00000000U,   /** @brief Event generation register */
      [1] = 0x00000000U   /** @brief Event generation register */
    };

    static const uint32_t A_TIMx_CCER_RST[9] = {
      [8] = 0x00000000U,   /** @brief Capture/compare enable register */
      [1] = 0x00000000U   /** @brief Capture/compare enable register */
    };

    static const uint32_t A_TIMx_CNT_RST[9] = {
      [8] = 0x00000000U,   /** @brief Counter */
      [1] = 0x00000000U   /** @brief Counter */
    };

    static const uint32_t A_TIMx_PSC_RST[9] = {
      [8] = 0x00000000U,   /** @brief Prescaler */
      [1] = 0x00000000U   /** @brief Prescaler */
    };

    static const uint32_t A_TIMx_ARR_RST[9] = {
      [8] = 0x00000000U,   /** @brief Auto-reload register */
      [1] = 0x00000000U   /** @brief Auto-reload register */
    };

    static const uint32_t A_TIMx_DCR_RST[9] = {
      [8] = 0x00000000U,   /** @brief DMA control register */
      [1] = 0x00000000U   /** @brief DMA control register */
    };

    static const uint32_t A_TIMx_DMAR_RST[9] = {
      [8] = 0x00000000U,   /** @brief DMA address for full transfer */
      [1] = 0x00000000U   /** @brief DMA address for full transfer */
    };

    static const uint32_t A_TIMx_RCR_RST[9] = {
      [8] = 0x00000000U,   /** @brief Repetition counter register */
      [1] = 0x00000000U   /** @brief Repetition counter register */
    };

    static const uint32_t A_TIMx_BDTR_RST[9] = {
      [8] = 0x00000000U,   /** @brief Break and dead-time register */
      [1] = 0x00000000U   /** @brief Break and dead-time register */
    };

    static const uint32_t A_TIMx_CRR6_RST[9] = {
      [8] = 0x00000000U,   /** @brief Capture/compare register 6 */
      [1] = 0x00000000U   /** @brief Capture/compare register 6 */
    };

    static const uint32_t A_TIMx_TISEL_RST[9] = {
      [8] = 0x00000000U,   /** @brief TIM1 timer input selection register */
      [1] = 0x00000000U   /** @brief TIM1 timer input selection register */
    };

    /**** @subsection A_TIM Register Value Type Definitions ****/

    typedef uint32_t A_TIMx_CRx_vt;            /** @brief A_TIMx_CRx register value type. */
    typedef uint32_t A_TIMx_SMCR_vt;           /** @brief A_TIMx_SMCR register value type. */
    typedef uint32_t A_TIMx_DIER_vt;           /** @brief A_TIMx_DIER register value type. */
    typedef uint32_t A_TIMx_SR_vt;             /** @brief A_TIMx_SR register value type. */
    typedef uint32_t A_TIMx_EGR_vt;            /** @brief A_TIMx_EGR register value type. */
    typedef uint32_t A_TIMx_CCMRx_OUTPUT_vt;   /** @brief A_TIMx_CCMRx_OUTPUT register value type. */
    typedef uint32_t A_TIMx_CCMRx_INPUT_vt;    /** @brief A_TIMx_CCMRx_INPUT register value type. */
    typedef uint32_t A_TIMx_CCER_vt;           /** @brief A_TIMx_CCER register value type. */
    typedef uint32_t A_TIMx_CNT_vt;            /** @brief A_TIMx_CNT register value type. */
    typedef uint32_t A_TIMx_PSC_vt;            /** @brief A_TIMx_PSC register value type. */
    typedef uint32_t A_TIMx_ARR_vt;            /** @brief A_TIMx_ARR register value type. */
    typedef uint32_t A_TIMx_CCRx_vt;           /** @brief A_TIMx_CCRx register value type. */
    typedef uint32_t A_TIMx_DCR_vt;            /** @brief A_TIMx_DCR register value type. */
    typedef uint32_t A_TIMx_DMAR_vt;           /** @brief A_TIMx_DMAR register value type. */
    typedef uint32_t A_TIMx_RCR_vt;            /** @brief A_TIMx_RCR register value type. */
    typedef uint32_t A_TIMx_BDTR_vt;           /** @brief A_TIMx_BDTR register value type. */
    typedef uint32_t A_TIMx_CRR6_vt;           /** @brief A_TIMx_CRR6 register value type. */
    typedef uint32_t A_TIMx_AFx_vt;            /** @brief A_TIMx_AFx register value type. */
    typedef uint32_t A_TIMx_TISEL_vt;          /** @brief A_TIMx_TISEL register value type. */

    /**** @subsection A_TIM Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* A_TIMx_CRx_pt;            /** @brief A_TIMx_CRx pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_SMCR_pt;           /** @brief A_TIMx_SMCR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_DIER_pt;           /** @brief A_TIMx_DIER pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_SR_pt;             /** @brief A_TIMx_SR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_EGR_pt;            /** @brief A_TIMx_EGR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_CCMRx_OUTPUT_pt;   /** @brief A_TIMx_CCMRx_OUTPUT pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_CCMRx_INPUT_pt;    /** @brief A_TIMx_CCMRx_INPUT pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_CCER_pt;           /** @brief A_TIMx_CCER pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_CNT_pt;            /** @brief A_TIMx_CNT pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_PSC_pt;            /** @brief A_TIMx_PSC pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_ARR_pt;            /** @brief A_TIMx_ARR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_CCRx_pt;           /** @brief A_TIMx_CCRx pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_DCR_pt;            /** @brief A_TIMx_DCR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_DMAR_pt;           /** @brief A_TIMx_DMAR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_RCR_pt;            /** @brief A_TIMx_RCR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_BDTR_pt;           /** @brief A_TIMx_BDTR pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_CRR6_pt;           /** @brief A_TIMx_CRR6 pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_AFx_pt;            /** @brief A_TIMx_AFx pointer register pointer type. */
    typedef RW_ uint32_t* A_TIMx_TISEL_pt;          /** @brief A_TIMx_TISEL pointer register pointer type. */

    /**** @subsection A_TIM Field Mask Definitions ****/

    static const uint32_t A_TIMx_CRx_UIFREMAP_MASK[9] = {
      [8] = 0x00000800U,   /** @brief UIF status bit remapping */
      [1] = 0x00000800U   /** @brief UIF status bit remapping */
    };

    static const uint32_t A_TIMx_SMCR_TS_4_3_MASK[9] = {
      [8] = 0x00300000U,   /** @brief Trigger selection - bit 4:3 */
      [1] = 0x00300000U   /** @brief Trigger selection - bit 4:3 */
    };

    static const uint32_t A_TIMx_DIER_COMIE_MASK[9] = {
      [8] = 0x00000020U,   /** @brief COM interrupt enable */
      [1] = 0x00000020U   /** @brief COM interrupt enable */
    };

    static const uint32_t A_TIMx_SR_UIF_MASK[9] = {
      [8] = 0x00000001U,   /** @brief Update interrupt flag */
      [1] = 0x00000001U   /** @brief Update interrupt flag */
    };

    static const uint32_t A_TIMx_EGR_B2G_MASK[9] = {
      [8] = 0x00000100U,   /** @brief Break 2 generation */
      [1] = 0x00000100U   /** @brief Break 2 generation */
    };

    static const uint32_t A_TIMx_CCMRx_INPUT_ICPCS_MASK[9] = {
      [8] = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [1] = 0x0000000CU   /** @brief Input capture 1 prescaler */
    };

    static const uint32_t A_TIMx_CNT_UIFCPY_MASK[9] = {
      [8] = 0x80000000U,   /** @brief UIF copy */
      [1] = 0x80000000U   /** @brief UIF copy */
    };

    static const uint32_t A_TIMx_PSC_PSC_MASK[9] = {
      [8] = 0x0000FFFFU,   /** @brief Prescaler value */
      [1] = 0x0000FFFFU   /** @brief Prescaler value */
    };

    static const uint32_t A_TIMx_ARR_ARR_MASK[9] = {
      [8] = 0x0000FFFFU,   /** @brief Auto-reload value */
      [1] = 0x0000FFFFU   /** @brief Auto-reload value */
    };

    static const uint32_t A_TIMx_DCR_DBA_MASK[9] = {
      [8] = 0x0000001FU,   /** @brief DMA base address */
      [1] = 0x0000001FU   /** @brief DMA base address */
    };

    static const uint32_t A_TIMx_DMAR_DMAB_MASK[9] = {
      [8] = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [1] = 0x0000FFFFU   /** @brief DMA register for burst accesses */
    };

    static const uint32_t A_TIMx_RCR_REP_MASK[9] = {
      [8] = 0x000000FFU,   /** @brief Repetition counter value */
      [1] = 0x000000FFU   /** @brief Repetition counter value */
    };

    static const uint32_t A_TIMx_BDTR_BK2P_MASK[9] = {
      [8] = 0x02000000U,   /** @brief Break 2 polarity */
      [1] = 0x02000000U   /** @brief Break 2 polarity */
    };

    static const uint32_t A_TIMx_CRR6_CCR6_MASK[9] = {
      [8] = 0x0000FFFFU,   /** @brief Capture/Compare 6 value */
      [1] = 0x0000FFFFU   /** @brief Capture/Compare 6 value */
    };

    static const uint32_t A_TIMx_AFx_ETRSEL_MASK[9] = {
      [8] = 0x0003C000U,   /** @brief ETR source selection */
      [1] = 0x0003C000U   /** @brief ETR source selection */
    };

    static const uint32_t A_TIMx_CCMRx_OUTPUT_OCxM_3_MASK[9][3] = {
      [8] = {
        [2] = 0x00010000U   /** @brief Output compare 3 mode - bit 3 */
      },
      [1] = {
        [2] = 0x00010000U   /** @brief Output compare 3 mode - bit 3 */
      }
    };

    static const uint32_t A_TIMx_CCER_CCxNP_MASK[9][5] = {
      [8] = {
        [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
        [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
        [4] = 0x00008000U,   /** @brief Capture/Compare 4 complementary output polarity */
        [1] = 0x00000008U   /** @brief Capture/Compare 1 output polarity */
      },
      [1] = {
        [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
        [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
        [4] = 0x00008000U,   /** @brief Capture/Compare 4 complementary output polarity */
        [1] = 0x00000008U   /** @brief Capture/Compare 1 output polarity */
      }
    };

    static const uint32_t A_TIMx_CCRx_CCRx_MASK[9][6] = {
      [8] = {
        [2] = 0x0000FFFFU,   /** @brief Capture/Compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Capture/Compare value */
        [4] = 0x0000FFFFU,   /** @brief Capture/Compare value */
        [5] = 0x0000FFFFU,   /** @brief Capture/Compare 5 value */
        [1] = 0x0000FFFFU   /** @brief Capture/Compare 1 value */
      },
      [1] = {
        [2] = 0x0000FFFFU,   /** @brief Capture/Compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Capture/Compare value */
        [4] = 0x0000FFFFU,   /** @brief Capture/Compare value */
        [5] = 0x0000FFFFU,   /** @brief Capture/Compare 5 value */
        [1] = 0x0000FFFFU   /** @brief Capture/Compare 1 value */
      }
    };

    static const uint32_t A_TIMx_TISEL_TIxSEL_MASK[9][5] = {
      [8] = {
        [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
        [3] = 0x000F0000U,   /** @brief Selects TI3[0] to TI3[15] input */
        [4] = 0x0F000000U,   /** @brief Selects TI4[0] to TI4[15] input */
        [1] = 0x0000000FU   /** @brief Selects TI1[0] to TI1[15] input */
      },
      [1] = {
        [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
        [3] = 0x000F0000U,   /** @brief Selects TI3[0] to TI3[15] input */
        [4] = 0x0F000000U,   /** @brief Selects TI4[0] to TI4[15] input */
        [1] = 0x0000000FU   /** @brief Selects TI1[0] to TI1[15] input */
      }
    };

    static uint32_t A_TIMx_CCMRx_OUTPUT_OCxM_3[9][2][3] = {
      [8] = {
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      },
      [1] = {
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      }
    };

    /**********************************************************************************************
     * @section FDCAN Register Definitions
     **********************************************************************************************/

    /**** @subsection FDCAN Register Pointer Definitions ****/

    static RO_ uint32_t* const FDCANx_FDCAN_CREL_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A400U,   /** @brief FDCAN core release register */
      [1] = (RO_ uint32_t*)0x4000A000U   /** @brief FDCAN core release register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_ENDN_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A404U,   /** @brief FDCAN core release register */
      [1] = (RO_ uint32_t*)0x4000A004U   /** @brief FDCAN core release register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_DBTP_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A40CU,   /** @brief FDCAN data bit timing and prescaler register */
      [1] = (RO_ uint32_t*)0x4000A00CU   /** @brief FDCAN data bit timing and prescaler register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TEST_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A410U,   /** @brief FDCAN test register */
      [1] = (RO_ uint32_t*)0x4000A010U   /** @brief FDCAN test register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_RWD_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A414U,   /** @brief FDCAN RAM watchdog register */
      [1] = (RO_ uint32_t*)0x4000A014U   /** @brief FDCAN RAM watchdog register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_CCCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A418U,   /** @brief FDCAN CC control register */
      [1] = (RW_ uint32_t*)0x4000A018U   /** @brief FDCAN CC control register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_NBTP_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A41CU,   /** @brief FDCAN nominal bit timing and prescaler register */
      [1] = (RW_ uint32_t*)0x4000A01CU   /** @brief FDCAN nominal bit timing and prescaler register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TSCC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A420U,   /** @brief FDCAN timestamp counter configuration register */
      [1] = (RW_ uint32_t*)0x4000A020U   /** @brief FDCAN timestamp counter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TSCV_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A424U,   /** @brief FDCAN timestamp counter value register */
      [1] = (RW_ uint32_t*)0x4000A024U   /** @brief FDCAN timestamp counter value register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TOCC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A428U,   /** @brief FDCAN timeout counter configuration register */
      [1] = (RW_ uint32_t*)0x4000A028U   /** @brief FDCAN timeout counter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TOCV_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A42CU,   /** @brief FDCAN timeout counter value register */
      [1] = (RW_ uint32_t*)0x4000A02CU   /** @brief FDCAN timeout counter value register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_ECR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A440U,   /** @brief FDCAN error counter register */
      [1] = (RW_ uint32_t*)0x4000A040U   /** @brief FDCAN error counter register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_PSR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A444U,   /** @brief FDCAN protocol status register */
      [1] = (RW_ uint32_t*)0x4000A044U   /** @brief FDCAN protocol status register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TDCR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A448U,   /** @brief FDCAN transmitter delay compensation register */
      [1] = (RO_ uint32_t*)0x4000A048U   /** @brief FDCAN transmitter delay compensation register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_IR_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A450U,   /** @brief FDCAN interrupt register */
      [1] = (RO_ uint32_t*)0x4000A050U   /** @brief FDCAN interrupt register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_IE_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A454U,   /** @brief FDCAN interrupt enable register */
      [1] = (RO_ uint32_t*)0x4000A054U   /** @brief FDCAN interrupt enable register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_ILS_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A458U,   /** @brief FDCAN interrupt line select register */
      [1] = (RO_ uint32_t*)0x4000A058U   /** @brief FDCAN interrupt line select register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_ILE_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A45CU,   /** @brief FDCAN interrupt line enable register */
      [1] = (RW_ uint32_t*)0x4000A05CU   /** @brief FDCAN interrupt line enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_GFC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A480U,   /** @brief FDCAN global filter configuration register */
      [1] = (RW_ uint32_t*)0x4000A080U   /** @brief FDCAN global filter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_SIDFC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A484U,   /** @brief FDCAN standard ID filter configuration register */
      [1] = (RW_ uint32_t*)0x4000A084U   /** @brief FDCAN standard ID filter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_XIDFC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A488U,   /** @brief FDCAN extended ID filter configuration register */
      [1] = (RW_ uint32_t*)0x4000A088U   /** @brief FDCAN extended ID filter configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_XIDAM_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A490U,   /** @brief FDCAN extended ID and mask register */
      [1] = (RW_ uint32_t*)0x4000A090U   /** @brief FDCAN extended ID and mask register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_HPMS_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A494U,   /** @brief FDCAN high priority message status register */
      [1] = (RO_ uint32_t*)0x4000A094U   /** @brief FDCAN high priority message status register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXBC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4ACU,   /** @brief FDCAN rx buffer configuration register */
      [1] = (RW_ uint32_t*)0x4000A0ACU   /** @brief FDCAN rx buffer configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_RXESC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4BCU,   /** @brief FDCAN rx buffer element size configuration register */
      [1] = (RW_ uint32_t*)0x4000A0BCU   /** @brief FDCAN rx buffer element size configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4C0U,   /** @brief FDCAN tx buffer configuration register */
      [1] = (RW_ uint32_t*)0x4000A0C0U   /** @brief FDCAN tx buffer configuration register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TXFQS_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A4C4U,   /** @brief FDCAN tx fifo/queue status register */
      [1] = (RO_ uint32_t*)0x4000A0C4U   /** @brief FDCAN tx fifo/queue status register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXESC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4C8U,   /** @brief FDCAN tx buffer element size configuration register */
      [1] = (RW_ uint32_t*)0x4000A0C8U   /** @brief FDCAN tx buffer element size configuration register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TXBRP_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A4CCU,   /** @brief FDCAN tx buffer request pending register */
      [1] = (RO_ uint32_t*)0x4000A0CCU   /** @brief FDCAN tx buffer request pending register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBAR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4D0U,   /** @brief FDCAN tx buffer add request register */
      [1] = (RW_ uint32_t*)0x4000A0D0U   /** @brief FDCAN tx buffer add request register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBCR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4D4U,   /** @brief FDCAN tx buffer cancellation request register */
      [1] = (RW_ uint32_t*)0x4000A0D4U   /** @brief FDCAN tx buffer cancellation request register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBTO_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4D8U,   /** @brief FDCAN tx buffer transmission occurred register */
      [1] = (RW_ uint32_t*)0x4000A0D8U   /** @brief FDCAN tx buffer transmission occurred register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TXBCF_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A4DCU,   /** @brief FDCAN tx buffer cancellation finished register */
      [1] = (RO_ uint32_t*)0x4000A0DCU   /** @brief FDCAN tx buffer cancellation finished register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBTIE_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4E0U,   /** @brief FDCAN tx buffer transmission interrupt enable register */
      [1] = (RW_ uint32_t*)0x4000A0E0U   /** @brief FDCAN tx buffer transmission interrupt enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXBCIE_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4E4U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
      [1] = (RW_ uint32_t*)0x4000A0E4U   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXEFC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4F0U,   /** @brief FDCAN tx event FIFO configuration register */
      [1] = (RW_ uint32_t*)0x4000A0F0U   /** @brief FDCAN tx event FIFO configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXEFS_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4F4U,   /** @brief FDCAN tx event FIFO status register */
      [1] = (RW_ uint32_t*)0x4000A0F4U   /** @brief FDCAN tx event FIFO status register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TXEFA_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A4F8U,   /** @brief FDCAN tx event FIFO acknowledge register */
      [1] = (RW_ uint32_t*)0x4000A0F8U   /** @brief FDCAN tx event FIFO acknowledge register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTTMC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A500U,   /** @brief FDCAN TT trigger memory configuration register */
      [1] = (RW_ uint32_t*)0x4000A100U   /** @brief FDCAN TT trigger memory configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTRMC_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A504U,   /** @brief FDCAN TT reference message configuration register */
      [1] = (RW_ uint32_t*)0x4000A104U   /** @brief FDCAN TT reference message configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTOCF_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A508U,   /** @brief FDCAN TT operation configuration register */
      [1] = (RW_ uint32_t*)0x4000A108U   /** @brief FDCAN TT operation configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTMLM_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A50CU,   /** @brief FDCAN TT matrix limits register */
      [1] = (RW_ uint32_t*)0x4000A10CU   /** @brief FDCAN TT matrix limits register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TURCF_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A510U,   /** @brief FDCAN TUR configuration register */
      [1] = (RW_ uint32_t*)0x4000A110U   /** @brief FDCAN TUR configuration register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTOCN_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A514U,   /** @brief FDCAN TT operation control register */
      [1] = (RW_ uint32_t*)0x4000A114U   /** @brief FDCAN TT operation control register */
    };

    static RW_ uint32_t* const FDCANx_CAN_TTGTP_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A518U,   /** @brief FDCAN TT global time preset register */
      [1] = (RW_ uint32_t*)0x4000A118U   /** @brief FDCAN TT global time preset register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTTMK_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A51CU,   /** @brief FDCAN TT time mark register */
      [1] = (RW_ uint32_t*)0x4000A11CU   /** @brief FDCAN TT time mark register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTIR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A520U,   /** @brief FDCAN TT interrupt register */
      [1] = (RW_ uint32_t*)0x4000A120U   /** @brief FDCAN TT interrupt register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTIE_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A524U,   /** @brief FDCAN TT interrupt enable register */
      [1] = (RW_ uint32_t*)0x4000A124U   /** @brief FDCAN TT interrupt enable register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTILS_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A528U,   /** @brief FDCAN TT interrupt line select register */
      [1] = (RW_ uint32_t*)0x4000A128U   /** @brief FDCAN TT interrupt line select register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTOST_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A52CU,   /** @brief FDCAN TT operation status register */
      [1] = (RW_ uint32_t*)0x4000A12CU   /** @brief FDCAN TT operation status register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TURNA_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A530U,   /** @brief FDCAN TUR numerator actual register */
      [1] = (RO_ uint32_t*)0x4000A130U   /** @brief FDCAN TUR numerator actual register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTLGT_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A534U,   /** @brief FDCAN TT local and global time register */
      [1] = (RO_ uint32_t*)0x4000A134U   /** @brief FDCAN TT local and global time register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTCTC_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A538U,   /** @brief FDCAN TT cycle time and count register */
      [1] = (RO_ uint32_t*)0x4000A138U   /** @brief FDCAN TT cycle time and count register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTCPT_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A53CU,   /** @brief FDCAN TT capture time register */
      [1] = (RO_ uint32_t*)0x4000A13CU   /** @brief FDCAN TT capture time register */
    };

    static RO_ uint32_t* const FDCANx_FDCAN_TTCSM_PTR[3] = {
      [2] = (RO_ uint32_t*)0x4000A540U,   /** @brief FDCAN TT cycle sync mark register */
      [1] = (RO_ uint32_t*)0x4000A140U   /** @brief FDCAN TT cycle sync mark register */
    };

    static RW_ uint32_t* const FDCANx_FDCAN_TTTS_PTR[3] = {
      [2] = (RW_ uint32_t*)0x4000A700U,   /** @brief FDCAN TT trigger select register */
      [1] = (RW_ uint32_t*)0x4000A300U   /** @brief FDCAN TT trigger select register */
    };

    /**** @subsection FDCAN Register Reset Value Definitions ****/

    static const uint32_t FDCANx_FDCAN_CREL_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN core release register */
      [1] = 0x00000000U   /** @brief FDCAN core release register */
    };

    static const uint32_t FDCANx_FDCAN_ENDN_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN core release register */
      [1] = 0x00000000U   /** @brief FDCAN core release register */
    };

    static const uint32_t FDCANx_FDCAN_DBTP_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN data bit timing and prescaler register */
      [1] = 0x00000000U   /** @brief FDCAN data bit timing and prescaler register */
    };

    static const uint32_t FDCANx_FDCAN_TEST_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN test register */
      [1] = 0x00000000U   /** @brief FDCAN test register */
    };

    static const uint32_t FDCANx_FDCAN_RWD_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN RAM watchdog register */
      [1] = 0x00000000U   /** @brief FDCAN RAM watchdog register */
    };

    static const uint32_t FDCANx_FDCAN_CCCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN CC control register */
      [1] = 0x00000000U   /** @brief FDCAN CC control register */
    };

    static const uint32_t FDCANx_FDCAN_NBTP_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN nominal bit timing and prescaler register */
      [1] = 0x00000000U   /** @brief FDCAN nominal bit timing and prescaler register */
    };

    static const uint32_t FDCANx_FDCAN_TSCC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN timestamp counter configuration register */
      [1] = 0x00000000U   /** @brief FDCAN timestamp counter configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TSCV_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN timestamp counter value register */
      [1] = 0x00000000U   /** @brief FDCAN timestamp counter value register */
    };

    static const uint32_t FDCANx_FDCAN_TOCC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN timeout counter configuration register */
      [1] = 0x00000000U   /** @brief FDCAN timeout counter configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TOCV_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN timeout counter value register */
      [1] = 0x00000000U   /** @brief FDCAN timeout counter value register */
    };

    static const uint32_t FDCANx_FDCAN_ECR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN error counter register */
      [1] = 0x00000000U   /** @brief FDCAN error counter register */
    };

    static const uint32_t FDCANx_FDCAN_PSR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN protocol status register */
      [1] = 0x00000000U   /** @brief FDCAN protocol status register */
    };

    static const uint32_t FDCANx_FDCAN_TDCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN transmitter delay compensation register */
      [1] = 0x00000000U   /** @brief FDCAN transmitter delay compensation register */
    };

    static const uint32_t FDCANx_FDCAN_IR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN interrupt register */
      [1] = 0x00000000U   /** @brief FDCAN interrupt register */
    };

    static const uint32_t FDCANx_FDCAN_IE_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN interrupt enable register */
      [1] = 0x00000000U   /** @brief FDCAN interrupt enable register */
    };

    static const uint32_t FDCANx_FDCAN_ILS_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN interrupt line select register */
      [1] = 0x00000000U   /** @brief FDCAN interrupt line select register */
    };

    static const uint32_t FDCANx_FDCAN_ILE_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN interrupt line enable register */
      [1] = 0x00000000U   /** @brief FDCAN interrupt line enable register */
    };

    static const uint32_t FDCANx_FDCAN_GFC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN global filter configuration register */
      [1] = 0x00000000U   /** @brief FDCAN global filter configuration register */
    };

    static const uint32_t FDCANx_FDCAN_SIDFC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN standard ID filter configuration register */
      [1] = 0x00000000U   /** @brief FDCAN standard ID filter configuration register */
    };

    static const uint32_t FDCANx_FDCAN_XIDFC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN extended ID filter configuration register */
      [1] = 0x00000000U   /** @brief FDCAN extended ID filter configuration register */
    };

    static const uint32_t FDCANx_FDCAN_XIDAM_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN extended ID and mask register */
      [1] = 0x00000000U   /** @brief FDCAN extended ID and mask register */
    };

    static const uint32_t FDCANx_FDCAN_HPMS_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN high priority message status register */
      [1] = 0x00000000U   /** @brief FDCAN high priority message status register */
    };

    static const uint32_t FDCANx_FDCAN_RXBC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN rx buffer configuration register */
      [1] = 0x00000000U   /** @brief FDCAN rx buffer configuration register */
    };

    static const uint32_t FDCANx_FDCAN_RXESC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN rx buffer element size configuration register */
      [1] = 0x00000000U   /** @brief FDCAN rx buffer element size configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TXBC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer configuration register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TXFQS_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx fifo/queue status register */
      [1] = 0x00000000U   /** @brief FDCAN tx fifo/queue status register */
    };

    static const uint32_t FDCANx_FDCAN_TXESC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer element size configuration register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer element size configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TXBRP_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer request pending register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer request pending register */
    };

    static const uint32_t FDCANx_FDCAN_TXBAR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer add request register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer add request register */
    };

    static const uint32_t FDCANx_FDCAN_TXBCR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer cancellation request register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer cancellation request register */
    };

    static const uint32_t FDCANx_FDCAN_TXBTO_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer transmission occurred register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer transmission occurred register */
    };

    static const uint32_t FDCANx_FDCAN_TXBCF_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer cancellation finished register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer cancellation finished register */
    };

    static const uint32_t FDCANx_FDCAN_TXBTIE_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer transmission interrupt enable register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer transmission interrupt enable register */
    };

    static const uint32_t FDCANx_FDCAN_TXBCIE_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
      [1] = 0x00000000U   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
    };

    static const uint32_t FDCANx_FDCAN_TXEFC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx event FIFO configuration register */
      [1] = 0x00000000U   /** @brief FDCAN tx event FIFO configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TXEFS_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx event FIFO status register */
      [1] = 0x00000000U   /** @brief FDCAN tx event FIFO status register */
    };

    static const uint32_t FDCANx_FDCAN_TXEFA_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN tx event FIFO acknowledge register */
      [1] = 0x00000000U   /** @brief FDCAN tx event FIFO acknowledge register */
    };

    static const uint32_t FDCANx_FDCAN_TTTMC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT trigger memory configuration register */
      [1] = 0x00000000U   /** @brief FDCAN TT trigger memory configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TTRMC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT reference message configuration register */
      [1] = 0x00000000U   /** @brief FDCAN TT reference message configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TTOCF_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT operation configuration register */
      [1] = 0x00000000U   /** @brief FDCAN TT operation configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TTMLM_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT matrix limits register */
      [1] = 0x00000000U   /** @brief FDCAN TT matrix limits register */
    };

    static const uint32_t FDCANx_FDCAN_TURCF_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TUR configuration register */
      [1] = 0x00000000U   /** @brief FDCAN TUR configuration register */
    };

    static const uint32_t FDCANx_FDCAN_TTOCN_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT operation control register */
      [1] = 0x00000000U   /** @brief FDCAN TT operation control register */
    };

    static const uint32_t FDCANx_CAN_TTGTP_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT global time preset register */
      [1] = 0x00000000U   /** @brief FDCAN TT global time preset register */
    };

    static const uint32_t FDCANx_FDCAN_TTTMK_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT time mark register */
      [1] = 0x00000000U   /** @brief FDCAN TT time mark register */
    };

    static const uint32_t FDCANx_FDCAN_TTIR_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT interrupt register */
      [1] = 0x00000000U   /** @brief FDCAN TT interrupt register */
    };

    static const uint32_t FDCANx_FDCAN_TTIE_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT interrupt enable register */
      [1] = 0x00000000U   /** @brief FDCAN TT interrupt enable register */
    };

    static const uint32_t FDCANx_FDCAN_TTILS_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT interrupt line select register */
      [1] = 0x00000000U   /** @brief FDCAN TT interrupt line select register */
    };

    static const uint32_t FDCANx_FDCAN_TTOST_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT operation status register */
      [1] = 0x00000000U   /** @brief FDCAN TT operation status register */
    };

    static const uint32_t FDCANx_FDCAN_TURNA_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TUR numerator actual register */
      [1] = 0x00000000U   /** @brief FDCAN TUR numerator actual register */
    };

    static const uint32_t FDCANx_FDCAN_TTLGT_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT local and global time register */
      [1] = 0x00000000U   /** @brief FDCAN TT local and global time register */
    };

    static const uint32_t FDCANx_FDCAN_TTCTC_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT cycle time and count register */
      [1] = 0x00000000U   /** @brief FDCAN TT cycle time and count register */
    };

    static const uint32_t FDCANx_FDCAN_TTCPT_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT capture time register */
      [1] = 0x00000000U   /** @brief FDCAN TT capture time register */
    };

    static const uint32_t FDCANx_FDCAN_TTCSM_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT cycle sync mark register */
      [1] = 0x00000000U   /** @brief FDCAN TT cycle sync mark register */
    };

    static const uint32_t FDCANx_FDCAN_TTTS_RST[3] = {
      [2] = 0x00000000U,   /** @brief FDCAN TT trigger select register */
      [1] = 0x00000000U   /** @brief FDCAN TT trigger select register */
    };

    /**** @subsection FDCAN Register Value Type Definitions ****/

    typedef uint32_t FDCANx_FDCAN_CREL_vt;     /** @brief FDCANx_FDCAN_CREL register value type. */
    typedef uint32_t FDCANx_FDCAN_ENDN_vt;     /** @brief FDCANx_FDCAN_ENDN register value type. */
    typedef uint32_t FDCANx_FDCAN_DBTP_vt;     /** @brief FDCANx_FDCAN_DBTP register value type. */
    typedef uint32_t FDCANx_FDCAN_TEST_vt;     /** @brief FDCANx_FDCAN_TEST register value type. */
    typedef uint32_t FDCANx_FDCAN_RWD_vt;      /** @brief FDCANx_FDCAN_RWD register value type. */
    typedef uint32_t FDCANx_FDCAN_CCCR_vt;     /** @brief FDCANx_FDCAN_CCCR register value type. */
    typedef uint32_t FDCANx_FDCAN_NBTP_vt;     /** @brief FDCANx_FDCAN_NBTP register value type. */
    typedef uint32_t FDCANx_FDCAN_TSCC_vt;     /** @brief FDCANx_FDCAN_TSCC register value type. */
    typedef uint32_t FDCANx_FDCAN_TSCV_vt;     /** @brief FDCANx_FDCAN_TSCV register value type. */
    typedef uint32_t FDCANx_FDCAN_TOCC_vt;     /** @brief FDCANx_FDCAN_TOCC register value type. */
    typedef uint32_t FDCANx_FDCAN_TOCV_vt;     /** @brief FDCANx_FDCAN_TOCV register value type. */
    typedef uint32_t FDCANx_FDCAN_ECR_vt;      /** @brief FDCANx_FDCAN_ECR register value type. */
    typedef uint32_t FDCANx_FDCAN_PSR_vt;      /** @brief FDCANx_FDCAN_PSR register value type. */
    typedef uint32_t FDCANx_FDCAN_TDCR_vt;     /** @brief FDCANx_FDCAN_TDCR register value type. */
    typedef uint32_t FDCANx_FDCAN_IR_vt;       /** @brief FDCANx_FDCAN_IR register value type. */
    typedef uint32_t FDCANx_FDCAN_IE_vt;       /** @brief FDCANx_FDCAN_IE register value type. */
    typedef uint32_t FDCANx_FDCAN_ILS_vt;      /** @brief FDCANx_FDCAN_ILS register value type. */
    typedef uint32_t FDCANx_FDCAN_ILE_vt;      /** @brief FDCANx_FDCAN_ILE register value type. */
    typedef uint32_t FDCANx_FDCAN_GFC_vt;      /** @brief FDCANx_FDCAN_GFC register value type. */
    typedef uint32_t FDCANx_FDCAN_SIDFC_vt;    /** @brief FDCANx_FDCAN_SIDFC register value type. */
    typedef uint32_t FDCANx_FDCAN_XIDFC_vt;    /** @brief FDCANx_FDCAN_XIDFC register value type. */
    typedef uint32_t FDCANx_FDCAN_XIDAM_vt;    /** @brief FDCANx_FDCAN_XIDAM register value type. */
    typedef uint32_t FDCANx_FDCAN_HPMS_vt;     /** @brief FDCANx_FDCAN_HPMS register value type. */
    typedef uint32_t FDCANx_FDCAN_NDATx_vt;    /** @brief FDCANx_FDCAN_NDATx register value type. */
    typedef uint32_t FDCANx_FDCAN_RXFxC_vt;    /** @brief FDCANx_FDCAN_RXFxC register value type. */
    typedef uint32_t FDCANx_FDCAN_RXFxS_vt;    /** @brief FDCANx_FDCAN_RXFxS register value type. */
    typedef uint32_t FDCANx_FDCAN_RXFxA_vt;    /** @brief FDCANx_FDCAN_RXFxA register value type. */
    typedef uint32_t FDCANx_FDCAN_RXBC_vt;     /** @brief FDCANx_FDCAN_RXBC register value type. */
    typedef uint32_t FDCANx_FDCAN_RXESC_vt;    /** @brief FDCANx_FDCAN_RXESC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBC_vt;     /** @brief FDCANx_FDCAN_TXBC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXFQS_vt;    /** @brief FDCANx_FDCAN_TXFQS register value type. */
    typedef uint32_t FDCANx_FDCAN_TXESC_vt;    /** @brief FDCANx_FDCAN_TXESC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBRP_vt;    /** @brief FDCANx_FDCAN_TXBRP register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBAR_vt;    /** @brief FDCANx_FDCAN_TXBAR register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBCR_vt;    /** @brief FDCANx_FDCAN_TXBCR register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBTO_vt;    /** @brief FDCANx_FDCAN_TXBTO register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBCF_vt;    /** @brief FDCANx_FDCAN_TXBCF register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBTIE_vt;   /** @brief FDCANx_FDCAN_TXBTIE register value type. */
    typedef uint32_t FDCANx_FDCAN_TXBCIE_vt;   /** @brief FDCANx_FDCAN_TXBCIE register value type. */
    typedef uint32_t FDCANx_FDCAN_TXEFC_vt;    /** @brief FDCANx_FDCAN_TXEFC register value type. */
    typedef uint32_t FDCANx_FDCAN_TXEFS_vt;    /** @brief FDCANx_FDCAN_TXEFS register value type. */
    typedef uint32_t FDCANx_FDCAN_TXEFA_vt;    /** @brief FDCANx_FDCAN_TXEFA register value type. */
    typedef uint32_t FDCANx_FDCAN_TTTMC_vt;    /** @brief FDCANx_FDCAN_TTTMC register value type. */
    typedef uint32_t FDCANx_FDCAN_TTRMC_vt;    /** @brief FDCANx_FDCAN_TTRMC register value type. */
    typedef uint32_t FDCANx_FDCAN_TTOCF_vt;    /** @brief FDCANx_FDCAN_TTOCF register value type. */
    typedef uint32_t FDCANx_FDCAN_TTMLM_vt;    /** @brief FDCANx_FDCAN_TTMLM register value type. */
    typedef uint32_t FDCANx_FDCAN_TURCF_vt;    /** @brief FDCANx_FDCAN_TURCF register value type. */
    typedef uint32_t FDCANx_FDCAN_TTOCN_vt;    /** @brief FDCANx_FDCAN_TTOCN register value type. */
    typedef uint32_t FDCANx_CAN_TTGTP_vt;      /** @brief FDCANx_CAN_TTGTP register value type. */
    typedef uint32_t FDCANx_FDCAN_TTTMK_vt;    /** @brief FDCANx_FDCAN_TTTMK register value type. */
    typedef uint32_t FDCANx_FDCAN_TTIR_vt;     /** @brief FDCANx_FDCAN_TTIR register value type. */
    typedef uint32_t FDCANx_FDCAN_TTIE_vt;     /** @brief FDCANx_FDCAN_TTIE register value type. */
    typedef uint32_t FDCANx_FDCAN_TTILS_vt;    /** @brief FDCANx_FDCAN_TTILS register value type. */
    typedef uint32_t FDCANx_FDCAN_TTOST_vt;    /** @brief FDCANx_FDCAN_TTOST register value type. */
    typedef uint32_t FDCANx_FDCAN_TURNA_vt;    /** @brief FDCANx_FDCAN_TURNA register value type. */
    typedef uint32_t FDCANx_FDCAN_TTLGT_vt;    /** @brief FDCANx_FDCAN_TTLGT register value type. */
    typedef uint32_t FDCANx_FDCAN_TTCTC_vt;    /** @brief FDCANx_FDCAN_TTCTC register value type. */
    typedef uint32_t FDCANx_FDCAN_TTCPT_vt;    /** @brief FDCANx_FDCAN_TTCPT register value type. */
    typedef uint32_t FDCANx_FDCAN_TTCSM_vt;    /** @brief FDCANx_FDCAN_TTCSM register value type. */
    typedef uint32_t FDCANx_FDCAN_TTTS_vt;     /** @brief FDCANx_FDCAN_TTTS register value type. */

    /**** @subsection FDCAN Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* FDCANx_FDCAN_CREL_pt;     /** @brief FDCANx_FDCAN_CREL pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_ENDN_pt;     /** @brief FDCANx_FDCAN_ENDN pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_DBTP_pt;     /** @brief FDCANx_FDCAN_DBTP pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TEST_pt;     /** @brief FDCANx_FDCAN_TEST pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_RWD_pt;      /** @brief FDCANx_FDCAN_RWD pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_CCCR_pt;     /** @brief FDCANx_FDCAN_CCCR pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_NBTP_pt;     /** @brief FDCANx_FDCAN_NBTP pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TSCC_pt;     /** @brief FDCANx_FDCAN_TSCC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TSCV_pt;     /** @brief FDCANx_FDCAN_TSCV pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TOCC_pt;     /** @brief FDCANx_FDCAN_TOCC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TOCV_pt;     /** @brief FDCANx_FDCAN_TOCV pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_ECR_pt;      /** @brief FDCANx_FDCAN_ECR pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_PSR_pt;      /** @brief FDCANx_FDCAN_PSR pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TDCR_pt;     /** @brief FDCANx_FDCAN_TDCR pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_IR_pt;       /** @brief FDCANx_FDCAN_IR pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_IE_pt;       /** @brief FDCANx_FDCAN_IE pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_ILS_pt;      /** @brief FDCANx_FDCAN_ILS pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_ILE_pt;      /** @brief FDCANx_FDCAN_ILE pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_GFC_pt;      /** @brief FDCANx_FDCAN_GFC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_SIDFC_pt;    /** @brief FDCANx_FDCAN_SIDFC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_XIDFC_pt;    /** @brief FDCANx_FDCAN_XIDFC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_XIDAM_pt;    /** @brief FDCANx_FDCAN_XIDAM pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_HPMS_pt;     /** @brief FDCANx_FDCAN_HPMS pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_NDATx_pt;    /** @brief FDCANx_FDCAN_NDATx pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_RXFxC_pt;    /** @brief FDCANx_FDCAN_RXFxC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_RXFxS_pt;    /** @brief FDCANx_FDCAN_RXFxS pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_RXFxA_pt;    /** @brief FDCANx_FDCAN_RXFxA pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_RXBC_pt;     /** @brief FDCANx_FDCAN_RXBC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_RXESC_pt;    /** @brief FDCANx_FDCAN_RXESC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXBC_pt;     /** @brief FDCANx_FDCAN_TXBC pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TXFQS_pt;    /** @brief FDCANx_FDCAN_TXFQS pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXESC_pt;    /** @brief FDCANx_FDCAN_TXESC pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TXBRP_pt;    /** @brief FDCANx_FDCAN_TXBRP pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXBAR_pt;    /** @brief FDCANx_FDCAN_TXBAR pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXBCR_pt;    /** @brief FDCANx_FDCAN_TXBCR pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXBTO_pt;    /** @brief FDCANx_FDCAN_TXBTO pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TXBCF_pt;    /** @brief FDCANx_FDCAN_TXBCF pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXBTIE_pt;   /** @brief FDCANx_FDCAN_TXBTIE pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXBCIE_pt;   /** @brief FDCANx_FDCAN_TXBCIE pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXEFC_pt;    /** @brief FDCANx_FDCAN_TXEFC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXEFS_pt;    /** @brief FDCANx_FDCAN_TXEFS pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TXEFA_pt;    /** @brief FDCANx_FDCAN_TXEFA pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTTMC_pt;    /** @brief FDCANx_FDCAN_TTTMC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTRMC_pt;    /** @brief FDCANx_FDCAN_TTRMC pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTOCF_pt;    /** @brief FDCANx_FDCAN_TTOCF pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTMLM_pt;    /** @brief FDCANx_FDCAN_TTMLM pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TURCF_pt;    /** @brief FDCANx_FDCAN_TURCF pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTOCN_pt;    /** @brief FDCANx_FDCAN_TTOCN pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_CAN_TTGTP_pt;      /** @brief FDCANx_CAN_TTGTP pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTTMK_pt;    /** @brief FDCANx_FDCAN_TTTMK pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTIR_pt;     /** @brief FDCANx_FDCAN_TTIR pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTIE_pt;     /** @brief FDCANx_FDCAN_TTIE pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTILS_pt;    /** @brief FDCANx_FDCAN_TTILS pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTOST_pt;    /** @brief FDCANx_FDCAN_TTOST pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TURNA_pt;    /** @brief FDCANx_FDCAN_TURNA pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TTLGT_pt;    /** @brief FDCANx_FDCAN_TTLGT pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TTCTC_pt;    /** @brief FDCANx_FDCAN_TTCTC pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TTCPT_pt;    /** @brief FDCANx_FDCAN_TTCPT pointer register pointer type. */
    typedef RO_ uint32_t* FDCANx_FDCAN_TTCSM_pt;    /** @brief FDCANx_FDCAN_TTCSM pointer register pointer type. */
    typedef RW_ uint32_t* FDCANx_FDCAN_TTTS_pt;     /** @brief FDCANx_FDCAN_TTTS pointer register pointer type. */

    /**** @subsection FDCAN Field Mask Definitions ****/

    static const uint32_t FDCANx_FDCAN_CREL_DAY_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Timestamp day */
      [1] = 0x000000FFU   /** @brief Timestamp day */
    };

    static const uint32_t FDCANx_FDCAN_ENDN_ETV_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Endiannes test value */
      [1] = 0xFFFFFFFFU   /** @brief Endiannes test value */
    };

    static const uint32_t FDCANx_FDCAN_DBTP_TDC_MASK[3] = {
      [2] = 0x00800000U,   /** @brief Transceiver delay compensation */
      [1] = 0x00800000U   /** @brief Transceiver delay compensation */
    };

    static const uint32_t FDCANx_FDCAN_TEST_RX_MASK[3] = {
      [2] = 0x00000080U,   /** @brief Control of transmit pin */
      [1] = 0x00000080U   /** @brief Control of transmit pin */
    };

    static const uint32_t FDCANx_FDCAN_RWD_WDC_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Watchdog configuration */
      [1] = 0x000000FFU   /** @brief Watchdog configuration */
    };

    static const uint32_t FDCANx_FDCAN_CCCR_NISO_MASK[3] = {
      [2] = 0x00008000U,   /** @brief Non ISO operation */
      [1] = 0x00008000U   /** @brief Non ISO operation */
    };

    static const uint32_t FDCANx_FDCAN_NBTP_TSEG2_MASK[3] = {
      [2] = 0x0000007FU,   /** @brief Nominal time segment after sample point */
      [1] = 0x0000007FU   /** @brief Nominal time segment after sample point */
    };

    static const uint32_t FDCANx_FDCAN_TSCC_TSS_MASK[3] = {
      [2] = 0x00000003U,   /** @brief Timestamp select */
      [1] = 0x00000003U   /** @brief Timestamp select */
    };

    static const uint32_t FDCANx_FDCAN_TSCV_TSC_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Timestamp counter */
      [1] = 0x0000FFFFU   /** @brief Timestamp counter */
    };

    static const uint32_t FDCANx_FDCAN_TOCC_TOP_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Timeout period */
      [1] = 0xFFFF0000U   /** @brief Timeout period */
    };

    static const uint32_t FDCANx_FDCAN_TOCV_TOC_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Timeout counter */
      [1] = 0x0000FFFFU   /** @brief Timeout counter */
    };

    static const uint32_t FDCANx_FDCAN_ECR_TEC_MASK[3] = {
      [2] = 0x000000FFU,   /** @brief Transmit error counter */
      [1] = 0x000000FFU   /** @brief Transmit error counter */
    };

    static const uint32_t FDCANx_FDCAN_PSR_TDCV_MASK[3] = {
      [2] = 0x007F0000U,   /** @brief Transmitter delay compensation value */
      [1] = 0x007F0000U   /** @brief Transmitter delay compensation value */
    };

    static const uint32_t FDCANx_FDCAN_TDCR_TDCO_MASK[3] = {
      [2] = 0x00007F00U,   /** @brief Transmitter delay compensation offset */
      [1] = 0x00007F00U   /** @brief Transmitter delay compensation offset */
    };

    static const uint32_t FDCANx_FDCAN_IR_ARA_MASK[3] = {
      [2] = 0x20000000U,   /** @brief Access to reserved address */
      [1] = 0x20000000U   /** @brief Access to reserved address */
    };

    static const uint32_t FDCANx_FDCAN_IE_ARAE_MASK[3] = {
      [2] = 0x20000000U,   /** @brief Access to reserved address enable */
      [1] = 0x20000000U   /** @brief Access to reserved address enable */
    };

    static const uint32_t FDCANx_FDCAN_ILS_ARAL_MASK[3] = {
      [2] = 0x20000000U,   /** @brief Access to reserved address line */
      [1] = 0x20000000U   /** @brief Access to reserved address line */
    };

    static const uint32_t FDCANx_FDCAN_GFC_ANFS_MASK[3] = {
      [2] = 0x00000030U,   /** @brief Accept non-matching frames standard */
      [1] = 0x00000030U   /** @brief Accept non-matching frames standard */
    };

    static const uint32_t FDCANx_FDCAN_SIDFC_LSS_MASK[3] = {
      [2] = 0x00FF0000U,   /** @brief List size standard */
      [1] = 0x00FF0000U   /** @brief List size standard */
    };

    static const uint32_t FDCANx_FDCAN_XIDFC_LSE_MASK[3] = {
      [2] = 0x00FF0000U,   /** @brief List size extended */
      [1] = 0x00FF0000U   /** @brief List size extended */
    };

    static const uint32_t FDCANx_FDCAN_XIDAM_EIDM_MASK[3] = {
      [2] = 0x1FFFFFFFU,   /** @brief Extended ID mask */
      [1] = 0x1FFFFFFFU   /** @brief Extended ID mask */
    };

    static const uint32_t FDCANx_FDCAN_HPMS_FLST_MASK[3] = {
      [2] = 0x00008000U,   /** @brief Filter list */
      [1] = 0x00008000U   /** @brief Filter list */
    };

    static const uint32_t FDCANx_FDCAN_RXFxA_FA01_MASK[3] = {
      [2] = 0x0000003FU,   /** @brief Rx FIFO 0 acknowledge index */
      [1] = 0x0000003FU   /** @brief Rx FIFO 0 acknowledge index */
    };

    static const uint32_t FDCANx_FDCAN_RXBC_RBSA_MASK[3] = {
      [2] = 0x0000FFFCU,   /** @brief Rx buffer start address */
      [1] = 0x0000FFFCU   /** @brief Rx buffer start address */
    };

    static const uint32_t FDCANx_FDCAN_RXESC_RBDS_MASK[3] = {
      [2] = 0x00000700U,   /** @brief Rx buffer data field size: */
      [1] = 0x00000700U   /** @brief Rx buffer data field size: */
    };

    static const uint32_t FDCANx_FDCAN_TXBC_TFQM_MASK[3] = {
      [2] = 0x40000000U,   /** @brief Tx fifo/queue mode */
      [1] = 0x40000000U   /** @brief Tx fifo/queue mode */
    };

    static const uint32_t FDCANx_FDCAN_TXFQS_TFQF_MASK[3] = {
      [2] = 0x00200000U,   /** @brief Tx fifo/queue full */
      [1] = 0x00200000U   /** @brief Tx fifo/queue full */
    };

    static const uint32_t FDCANx_FDCAN_TXESC_TBDS_MASK[3] = {
      [2] = 0x00000007U,   /** @brief Tx buffer data field size: */
      [1] = 0x00000007U   /** @brief Tx buffer data field size: */
    };

    static const uint32_t FDCANx_FDCAN_TXBRP_TRP_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Transmission request pending */
      [1] = 0xFFFFFFFFU   /** @brief Transmission request pending */
    };

    static const uint32_t FDCANx_FDCAN_TXBAR_AR_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Add request */
      [1] = 0xFFFFFFFFU   /** @brief Add request */
    };

    static const uint32_t FDCANx_FDCAN_TXBCR_CR_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Cancellation request */
      [1] = 0xFFFFFFFFU   /** @brief Cancellation request */
    };

    static const uint32_t FDCANx_FDCAN_TXBTO_TO_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Transmission occurred. */
      [1] = 0xFFFFFFFFU   /** @brief Transmission occurred. */
    };

    static const uint32_t FDCANx_FDCAN_TXBCF_CF_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Cancellation finished */
      [1] = 0xFFFFFFFFU   /** @brief Cancellation finished */
    };

    static const uint32_t FDCANx_FDCAN_TXBTIE_TIE_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Transmission interrupt enable */
      [1] = 0xFFFFFFFFU   /** @brief Transmission interrupt enable */
    };

    static const uint32_t FDCANx_FDCAN_TXBCIE_CF_MASK[3] = {
      [2] = 0xFFFFFFFFU,   /** @brief Cancellation finished interrupt enable */
      [1] = 0xFFFFFFFFU   /** @brief Cancellation finished interrupt enable */
    };

    static const uint32_t FDCANx_FDCAN_TXEFC_EFWM_MASK[3] = {
      [2] = 0x3F000000U,   /** @brief Event FIFO watermark */
      [1] = 0x3F000000U   /** @brief Event FIFO watermark */
    };

    static const uint32_t FDCANx_FDCAN_TXEFS_TEFL_MASK[3] = {
      [2] = 0x02000000U,   /** @brief Tx event FIFO element lost. */
      [1] = 0x02000000U   /** @brief Tx event FIFO element lost. */
    };

    static const uint32_t FDCANx_FDCAN_TXEFA_EFAI_MASK[3] = {
      [2] = 0x0000001FU,   /** @brief Event FIFO acknowledge index */
      [1] = 0x0000001FU   /** @brief Event FIFO acknowledge index */
    };

    static const uint32_t FDCANx_FDCAN_TTTMC_TME_MASK[3] = {
      [2] = 0x007F0000U,   /** @brief Trigger memory elements */
      [1] = 0x007F0000U   /** @brief Trigger memory elements */
    };

    static const uint32_t FDCANx_FDCAN_TTRMC_RMPS_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Reference message payload select */
      [1] = 0x80000000U   /** @brief Reference message payload select */
    };

    static const uint32_t FDCANx_FDCAN_TTOCF_EVTP_MASK[3] = {
      [2] = 0x04000000U,   /** @brief Event trigger polarity */
      [1] = 0x04000000U   /** @brief Event trigger polarity */
    };

    static const uint32_t FDCANx_FDCAN_TTMLM_ENTT_MASK[3] = {
      [2] = 0x0FFF0000U,   /** @brief Expected number of tx triggers */
      [1] = 0x0FFF0000U   /** @brief Expected number of tx triggers */
    };

    static const uint32_t FDCANx_FDCAN_TURCF_ELT_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Enable local time */
      [1] = 0x80000000U   /** @brief Enable local time */
    };

    static const uint32_t FDCANx_FDCAN_TTOCN_LCKC_MASK[3] = {
      [2] = 0x00008000U,   /** @brief TT operation control register locked */
      [1] = 0x00008000U   /** @brief TT operation control register locked */
    };

    static const uint32_t FDCANx_CAN_TTGTP_CTP_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Cycle time target phase */
      [1] = 0xFFFF0000U   /** @brief Cycle time target phase */
    };

    static const uint32_t FDCANx_FDCAN_TTTMK_LCKM_MASK[3] = {
      [2] = 0x80000000U,   /** @brief TT time mark register locked */
      [1] = 0x80000000U   /** @brief TT time mark register locked */
    };

    static const uint32_t FDCANx_FDCAN_TTIR_CER_MASK[3] = {
      [2] = 0x00040000U,   /** @brief Configuration error */
      [1] = 0x00040000U   /** @brief Configuration error */
    };

    static const uint32_t FDCANx_FDCAN_TTIE_CERE_MASK[3] = {
      [2] = 0x00040000U,   /** @brief Configuration error interrupt enable */
      [1] = 0x00040000U   /** @brief Configuration error interrupt enable */
    };

    static const uint32_t FDCANx_FDCAN_TTILS_CERL_MASK[3] = {
      [2] = 0x00040000U,   /** @brief Configuration error interrupt line */
      [1] = 0x00040000U   /** @brief Configuration error interrupt line */
    };

    static const uint32_t FDCANx_FDCAN_TTOST_SPL_MASK[3] = {
      [2] = 0x80000000U,   /** @brief Schedule phase lock */
      [1] = 0x80000000U   /** @brief Schedule phase lock */
    };

    static const uint32_t FDCANx_FDCAN_TURNA_NAV_MASK[3] = {
      [2] = 0x0003FFFFU,   /** @brief Numerator actual value */
      [1] = 0x0003FFFFU   /** @brief Numerator actual value */
    };

    static const uint32_t FDCANx_FDCAN_TTLGT_GT_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Global time */
      [1] = 0xFFFF0000U   /** @brief Global time */
    };

    static const uint32_t FDCANx_FDCAN_TTCTC_CC_MASK[3] = {
      [2] = 0x003F0000U,   /** @brief Cycle count */
      [1] = 0x003F0000U   /** @brief Cycle count */
    };

    static const uint32_t FDCANx_FDCAN_TTCPT_SWV_MASK[3] = {
      [2] = 0xFFFF0000U,   /** @brief Stop watch value */
      [1] = 0xFFFF0000U   /** @brief Stop watch value */
    };

    static const uint32_t FDCANx_FDCAN_TTCSM_CSM_MASK[3] = {
      [2] = 0x0000FFFFU,   /** @brief Cycle sync mark */
      [1] = 0x0000FFFFU   /** @brief Cycle sync mark */
    };

    static const uint32_t FDCANx_FDCAN_TTTS_EVTSEL_MASK[3] = {
      [2] = 0x00000030U,   /** @brief Event trigger input selection */
      [1] = 0x00000030U   /** @brief Event trigger input selection */
    };

    static const uint32_t FDCANx_FDCAN_ILE_EINTx_MASK[3][2] = {
      [2] = {
        [1] = 0x00000002U,   /** @brief Enable interrupt line 1 */
        [0] = 0x00000001U   /** @brief Enable interrupt line 0 */
      },
      [1] = {
        [1] = 0x00000002U,   /** @brief Enable interrupt line 1 */
        [0] = 0x00000001U   /** @brief Enable interrupt line 0 */
      }
    };

    static const uint32_t FDCANx_FDCAN_RXFxC_FxWM_MASK[3][2] = {
      [2] = {
        [1] = 0x7F000000U,   /** @brief Rx FIFO 1 watermark */
        [0] = 0xFF000000U   /** @brief FIFO 0 watermark */
      },
      [1] = {
        [1] = 0x7F000000U,   /** @brief Rx FIFO 1 watermark */
        [0] = 0xFF000000U   /** @brief FIFO 0 watermark */
      }
    };

    static const uint32_t FDCANx_FDCAN_RXFxS_RFxL_MASK[3][2] = {
      [2] = {
        [1] = 0x02000000U,   /** @brief Rx FIFO 1 message lost */
        [0] = 0x02000000U   /** @brief Rx FIFO 0 message lost */
      },
      [1] = {
        [1] = 0x02000000U,   /** @brief Rx FIFO 1 message lost */
        [0] = 0x02000000U   /** @brief Rx FIFO 0 message lost */
      }
    };

    static uint32_t FDCANx_FDCAN_NDATx_NDx[3][3][64] = {
      [2] = {
        [2] = {
          [32] = 0x00000001U,   /** @brief New data */
          [33] = 0x00000002U,   /** @brief New data */
          [34] = 0x00000004U,   /** @brief New data */
          [35] = 0x00000008U,   /** @brief New data */
          [36] = 0x00000010U,   /** @brief New data */
          [37] = 0x00000020U,   /** @brief New data */
          [38] = 0x00000040U,   /** @brief New data */
          [39] = 0x00000080U,   /** @brief New data */
          [40] = 0x00000100U,   /** @brief New data */
          [41] = 0x00000200U,   /** @brief New data */
          [42] = 0x00000400U,   /** @brief New data */
          [43] = 0x00000800U,   /** @brief New data */
          [44] = 0x00001000U,   /** @brief New data */
          [45] = 0x00002000U,   /** @brief New data */
          [46] = 0x00004000U,   /** @brief New data */
          [47] = 0x00008000U,   /** @brief New data */
          [48] = 0x00010000U,   /** @brief New data */
          [49] = 0x00020000U,   /** @brief New data */
          [50] = 0x00040000U,   /** @brief New data */
          [51] = 0x00080000U,   /** @brief New data */
          [52] = 0x00100000U,   /** @brief New data */
          [53] = 0x00200000U,   /** @brief New data */
          [54] = 0x00400000U,   /** @brief New data */
          [55] = 0x00800000U,   /** @brief New data */
          [56] = 0x01000000U,   /** @brief New data */
          [57] = 0x02000000U,   /** @brief New data */
          [58] = 0x04000000U,   /** @brief New data */
          [59] = 0x08000000U,   /** @brief New data */
          [60] = 0x10000000U,   /** @brief New data */
          [61] = 0x20000000U,   /** @brief New data */
          [62] = 0x40000000U,   /** @brief New data */
          [63] = 0x80000000U   /** @brief New data */
        },
        [1] = {
          [1]  = 0x00000002U,   /** @brief New data */
          [2]  = 0x00000004U,   /** @brief New data */
          [3]  = 0x00000008U,   /** @brief New data */
          [4]  = 0x00000010U,   /** @brief New data */
          [5]  = 0x00000020U,   /** @brief New data */
          [6]  = 0x00000040U,   /** @brief New data */
          [7]  = 0x00000080U,   /** @brief New data */
          [8]  = 0x00000100U,   /** @brief New data */
          [9]  = 0x00000200U,   /** @brief New data */
          [10] = 0x00000400U,   /** @brief New data */
          [11] = 0x00000800U,   /** @brief New data */
          [12] = 0x00001000U,   /** @brief New data */
          [13] = 0x00002000U,   /** @brief New data */
          [14] = 0x00004000U,   /** @brief New data */
          [15] = 0x00008000U,   /** @brief New data */
          [16] = 0x00010000U,   /** @brief New data */
          [17] = 0x00020000U,   /** @brief New data */
          [18] = 0x00040000U,   /** @brief New data */
          [19] = 0x00080000U,   /** @brief New data */
          [20] = 0x00100000U,   /** @brief New data */
          [21] = 0x00200000U,   /** @brief New data */
          [22] = 0x00400000U,   /** @brief New data */
          [23] = 0x00800000U,   /** @brief New data */
          [24] = 0x01000000U,   /** @brief New data */
          [25] = 0x02000000U,   /** @brief New data */
          [26] = 0x04000000U,   /** @brief New data */
          [27] = 0x08000000U,   /** @brief New data */
          [28] = 0x10000000U,   /** @brief New data */
          [29] = 0x20000000U,   /** @brief New data */
          [30] = 0x40000000U,   /** @brief New data */
          [31] = 0x80000000U,   /** @brief New data */
          [0]  = 0x00000001U   /** @brief New data */
        }
      },
      [1] = {
        [2] = {
          [32] = 0x00000001U,   /** @brief New data */
          [33] = 0x00000002U,   /** @brief New data */
          [34] = 0x00000004U,   /** @brief New data */
          [35] = 0x00000008U,   /** @brief New data */
          [36] = 0x00000010U,   /** @brief New data */
          [37] = 0x00000020U,   /** @brief New data */
          [38] = 0x00000040U,   /** @brief New data */
          [39] = 0x00000080U,   /** @brief New data */
          [40] = 0x00000100U,   /** @brief New data */
          [41] = 0x00000200U,   /** @brief New data */
          [42] = 0x00000400U,   /** @brief New data */
          [43] = 0x00000800U,   /** @brief New data */
          [44] = 0x00001000U,   /** @brief New data */
          [45] = 0x00002000U,   /** @brief New data */
          [46] = 0x00004000U,   /** @brief New data */
          [47] = 0x00008000U,   /** @brief New data */
          [48] = 0x00010000U,   /** @brief New data */
          [49] = 0x00020000U,   /** @brief New data */
          [50] = 0x00040000U,   /** @brief New data */
          [51] = 0x00080000U,   /** @brief New data */
          [52] = 0x00100000U,   /** @brief New data */
          [53] = 0x00200000U,   /** @brief New data */
          [54] = 0x00400000U,   /** @brief New data */
          [55] = 0x00800000U,   /** @brief New data */
          [56] = 0x01000000U,   /** @brief New data */
          [57] = 0x02000000U,   /** @brief New data */
          [58] = 0x04000000U,   /** @brief New data */
          [59] = 0x08000000U,   /** @brief New data */
          [60] = 0x10000000U,   /** @brief New data */
          [61] = 0x20000000U,   /** @brief New data */
          [62] = 0x40000000U,   /** @brief New data */
          [63] = 0x80000000U   /** @brief New data */
        },
        [1] = {
          [1]  = 0x00000002U,   /** @brief New data */
          [2]  = 0x00000004U,   /** @brief New data */
          [3]  = 0x00000008U,   /** @brief New data */
          [4]  = 0x00000010U,   /** @brief New data */
          [5]  = 0x00000020U,   /** @brief New data */
          [6]  = 0x00000040U,   /** @brief New data */
          [7]  = 0x00000080U,   /** @brief New data */
          [8]  = 0x00000100U,   /** @brief New data */
          [9]  = 0x00000200U,   /** @brief New data */
          [10] = 0x00000400U,   /** @brief New data */
          [11] = 0x00000800U,   /** @brief New data */
          [12] = 0x00001000U,   /** @brief New data */
          [13] = 0x00002000U,   /** @brief New data */
          [14] = 0x00004000U,   /** @brief New data */
          [15] = 0x00008000U,   /** @brief New data */
          [16] = 0x00010000U,   /** @brief New data */
          [17] = 0x00020000U,   /** @brief New data */
          [18] = 0x00040000U,   /** @brief New data */
          [19] = 0x00080000U,   /** @brief New data */
          [20] = 0x00100000U,   /** @brief New data */
          [21] = 0x00200000U,   /** @brief New data */
          [22] = 0x00400000U,   /** @brief New data */
          [23] = 0x00800000U,   /** @brief New data */
          [24] = 0x01000000U,   /** @brief New data */
          [25] = 0x02000000U,   /** @brief New data */
          [26] = 0x04000000U,   /** @brief New data */
          [27] = 0x08000000U,   /** @brief New data */
          [28] = 0x10000000U,   /** @brief New data */
          [29] = 0x20000000U,   /** @brief New data */
          [30] = 0x40000000U,   /** @brief New data */
          [31] = 0x80000000U,   /** @brief New data */
          [0]  = 0x00000001U   /** @brief New data */
        }
      }
    };

    /**********************************************************************************************
     * @section CAN_CCU Register Definitions
     **********************************************************************************************/

    /**** @subsection CAN_CCU Register Pointer Definitions ****/

    static RW_ uint32_t* const CAN_CCU_CREL_PTR  = (RW_ uint32_t*)0x4000A800U;   /** @brief Clock calibration unit core release register */
    static RW_ uint32_t* const CAN_CCU_CCFG_PTR  = (RW_ uint32_t*)0x4000A804U;   /** @brief Calibration configuration register */
    static RW_ uint32_t* const CAN_CCU_CSTAT_PTR = (RW_ uint32_t*)0x4000A808U;   /** @brief Calibration status register */
    static RW_ uint32_t* const CAN_CCU_CWD_PTR   = (RW_ uint32_t*)0x4000A80CU;   /** @brief Calibration watchdog register */
    static RW_ uint32_t* const CAN_CCU_IR_PTR    = (RW_ uint32_t*)0x4000A810U;   /** @brief Clock calibration unit interrupt register */
    static RW_ uint32_t* const CAN_CCU_IE_PTR    = (RW_ uint32_t*)0x4000A814U;   /** @brief Clock calibration unit interrupt enable register */

    /**** @subsection CAN_CCU Register Reset Value Definitions ****/

    static const uint32_t CAN_CCU_CREL_RST  = 0x00000000U;   /** @brief Clock calibration unit core release register */
    static const uint32_t CAN_CCU_CCFG_RST  = 0x00000000U;   /** @brief Calibration configuration register */
    static const uint32_t CAN_CCU_CSTAT_RST = 0x00000000U;   /** @brief Calibration status register */
    static const uint32_t CAN_CCU_CWD_RST   = 0x00000000U;   /** @brief Calibration watchdog register */
    static const uint32_t CAN_CCU_IR_RST    = 0x00000000U;   /** @brief Clock calibration unit interrupt register */
    static const uint32_t CAN_CCU_IE_RST    = 0x00000000U;   /** @brief Clock calibration unit interrupt enable register */

    /**** @subsection CAN_CCU Register Value Type Definitions ****/

    typedef uint32_t CAN_CCU_CREL_vt;    /** @brief CAN_CCU_CREL register value type. */
    typedef uint32_t CAN_CCU_CCFG_vt;    /** @brief CAN_CCU_CCFG register value type. */
    typedef uint32_t CAN_CCU_CSTAT_vt;   /** @brief CAN_CCU_CSTAT register value type. */
    typedef uint32_t CAN_CCU_CWD_vt;     /** @brief CAN_CCU_CWD register value type. */
    typedef uint32_t CAN_CCU_IR_vt;      /** @brief CAN_CCU_IR register value type. */
    typedef uint32_t CAN_CCU_IE_vt;      /** @brief CAN_CCU_IE register value type. */

    /**** @subsection CAN_CCU Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* CAN_CCU_CREL_pt;    /** @brief CAN_CCU_CREL pointer register pointer type. */
    typedef RW_ uint32_t* CAN_CCU_CCFG_pt;    /** @brief CAN_CCU_CCFG pointer register pointer type. */
    typedef RW_ uint32_t* CAN_CCU_CSTAT_pt;   /** @brief CAN_CCU_CSTAT pointer register pointer type. */
    typedef RW_ uint32_t* CAN_CCU_CWD_pt;     /** @brief CAN_CCU_CWD pointer register pointer type. */
    typedef RW_ uint32_t* CAN_CCU_IR_pt;      /** @brief CAN_CCU_IR pointer register pointer type. */
    typedef RW_ uint32_t* CAN_CCU_IE_pt;      /** @brief CAN_CCU_IE pointer register pointer type. */

    /**** @subsection CAN_CCU Field Mask Definitions ****/

    static const uint32_t CAN_CCU_CREL_REL_MASK   = 0xF0000000U;   /** @brief Core release */
    static const uint32_t CAN_CCU_CCFG_SWR_MASK   = 0x80000000U;   /** @brief Software reset */
    static const uint32_t CAN_CCU_CSTAT_CALS_MASK = 0xC0000000U;   /** @brief Calibration state */
    static const uint32_t CAN_CCU_CWD_WDV_MASK    = 0xFFFF0000U;   /** @brief WDV */
    static const uint32_t CAN_CCU_IR_CSC_MASK     = 0x00000002U;   /** @brief Calibration state changed */
    static const uint32_t CAN_CCU_IE_CSCE_MASK    = 0x00000002U;   /** @brief Calibration state changed enable */

    /**********************************************************************************************
     * @section MDIOS Register Definitions
     **********************************************************************************************/

    /**** @subsection MDIOS Register Pointer Definitions ****/

    static RW_ uint32_t* const MDIOS_MDIOS_CR_PTR    = (RW_ uint32_t*)0x40009400U;   /** @brief MDIOS configuration register */
    static RO_ uint32_t* const MDIOS_MDIOS_WRFR_PTR  = (RO_ uint32_t*)0x40009404U;   /** @brief MDIOS write flag register */
    static RW_ uint32_t* const MDIOS_MDIOS_CWRFR_PTR = (RW_ uint32_t*)0x40009408U;   /** @brief MDIOS clear write flag register */
    static RO_ uint32_t* const MDIOS_MDIOS_RDFR_PTR  = (RO_ uint32_t*)0x4000940CU;   /** @brief MDIOS read flag register */
    static RW_ uint32_t* const MDIOS_MDIOS_CRDFR_PTR = (RW_ uint32_t*)0x40009410U;   /** @brief MDIOS clear read flag register */
    static RO_ uint32_t* const MDIOS_MDIOS_SR_PTR    = (RO_ uint32_t*)0x40009414U;   /** @brief MDIOS status register */
    static RW_ uint32_t* const MDIOS_MDIOS_CLRFR_PTR = (RW_ uint32_t*)0x40009418U;   /** @brief MDIOS clear flag register */

    static RO_ uint32_t* const MDIOS_MDIOS_DINRx_PTR[32] = {
      [1]  = (RO_ uint32_t*)0x40009420U,   /** @brief MDIOS input data register 1 */
      [2]  = (RO_ uint32_t*)0x40009424U,   /** @brief MDIOS input data register 2 */
      [3]  = (RO_ uint32_t*)0x40009428U,   /** @brief MDIOS input data register 3 */
      [4]  = (RO_ uint32_t*)0x4000942CU,   /** @brief MDIOS input data register 4 */
      [5]  = (RO_ uint32_t*)0x40009430U,   /** @brief MDIOS input data register 5 */
      [6]  = (RO_ uint32_t*)0x40009434U,   /** @brief MDIOS input data register 6 */
      [7]  = (RO_ uint32_t*)0x40009438U,   /** @brief MDIOS input data register 7 */
      [8]  = (RO_ uint32_t*)0x4000943CU,   /** @brief MDIOS input data register 8 */
      [9]  = (RO_ uint32_t*)0x40009440U,   /** @brief MDIOS input data register 9 */
      [10] = (RO_ uint32_t*)0x40009444U,   /** @brief MDIOS input data register 10 */
      [11] = (RO_ uint32_t*)0x40009448U,   /** @brief MDIOS input data register 11 */
      [12] = (RO_ uint32_t*)0x4000944CU,   /** @brief MDIOS input data register 12 */
      [13] = (RO_ uint32_t*)0x40009450U,   /** @brief MDIOS input data register 13 */
      [14] = (RO_ uint32_t*)0x40009454U,   /** @brief MDIOS input data register 14 */
      [15] = (RO_ uint32_t*)0x40009458U,   /** @brief MDIOS input data register 15 */
      [16] = (RO_ uint32_t*)0x4000945CU,   /** @brief MDIOS input data register 16 */
      [17] = (RO_ uint32_t*)0x40009460U,   /** @brief MDIOS input data register 17 */
      [18] = (RO_ uint32_t*)0x40009464U,   /** @brief MDIOS input data register 18 */
      [19] = (RO_ uint32_t*)0x40009468U,   /** @brief MDIOS input data register 19 */
      [20] = (RO_ uint32_t*)0x4000946CU,   /** @brief MDIOS input data register 20 */
      [21] = (RO_ uint32_t*)0x40009470U,   /** @brief MDIOS input data register 21 */
      [22] = (RO_ uint32_t*)0x40009474U,   /** @brief MDIOS input data register 22 */
      [23] = (RO_ uint32_t*)0x40009478U,   /** @brief MDIOS input data register 23 */
      [24] = (RO_ uint32_t*)0x4000947CU,   /** @brief MDIOS input data register 24 */
      [25] = (RO_ uint32_t*)0x40009480U,   /** @brief MDIOS input data register 25 */
      [26] = (RO_ uint32_t*)0x40009484U,   /** @brief MDIOS input data register 26 */
      [27] = (RO_ uint32_t*)0x40009488U,   /** @brief MDIOS input data register 27 */
      [28] = (RO_ uint32_t*)0x4000948CU,   /** @brief MDIOS input data register 28 */
      [29] = (RO_ uint32_t*)0x40009490U,   /** @brief MDIOS input data register 29 */
      [30] = (RO_ uint32_t*)0x40009494U,   /** @brief MDIOS input data register 30 */
      [31] = (RO_ uint32_t*)0x40009498U,   /** @brief MDIOS input data register 31 */
      [0]  = (RO_ uint32_t*)0x4000941CU   /** @brief MDIOS input data register 0 */
    };

    static RW_ uint32_t* const MDIOS_MDIOS_DOUTRx_PTR[32] = {
      [1]  = (RW_ uint32_t*)0x400094A0U,   /** @brief MDIOS output data register 1 */
      [2]  = (RW_ uint32_t*)0x400094A4U,   /** @brief MDIOS output data register 2 */
      [3]  = (RW_ uint32_t*)0x400094A8U,   /** @brief MDIOS output data register 3 */
      [4]  = (RW_ uint32_t*)0x400094ACU,   /** @brief MDIOS output data register 4 */
      [5]  = (RW_ uint32_t*)0x400094B0U,   /** @brief MDIOS output data register 5 */
      [6]  = (RW_ uint32_t*)0x400094B4U,   /** @brief MDIOS output data register 6 */
      [7]  = (RW_ uint32_t*)0x400094B8U,   /** @brief MDIOS output data register 7 */
      [8]  = (RW_ uint32_t*)0x400094BCU,   /** @brief MDIOS output data register 8 */
      [9]  = (RW_ uint32_t*)0x400094C0U,   /** @brief MDIOS output data register 9 */
      [10] = (RW_ uint32_t*)0x400094C4U,   /** @brief MDIOS output data register 10 */
      [11] = (RW_ uint32_t*)0x400094C8U,   /** @brief MDIOS output data register 11 */
      [12] = (RW_ uint32_t*)0x400094CCU,   /** @brief MDIOS output data register 12 */
      [13] = (RW_ uint32_t*)0x400094D0U,   /** @brief MDIOS output data register 13 */
      [14] = (RW_ uint32_t*)0x400094D4U,   /** @brief MDIOS output data register 14 */
      [15] = (RW_ uint32_t*)0x400094D8U,   /** @brief MDIOS output data register 15 */
      [16] = (RW_ uint32_t*)0x400094DCU,   /** @brief MDIOS output data register 16 */
      [17] = (RW_ uint32_t*)0x400094E0U,   /** @brief MDIOS output data register 17 */
      [18] = (RW_ uint32_t*)0x400094E4U,   /** @brief MDIOS output data register 18 */
      [19] = (RW_ uint32_t*)0x400094E8U,   /** @brief MDIOS output data register 19 */
      [20] = (RW_ uint32_t*)0x400094ECU,   /** @brief MDIOS output data register 20 */
      [21] = (RW_ uint32_t*)0x400094F0U,   /** @brief MDIOS output data register 21 */
      [22] = (RW_ uint32_t*)0x400094F4U,   /** @brief MDIOS output data register 22 */
      [23] = (RW_ uint32_t*)0x400094F8U,   /** @brief MDIOS output data register 23 */
      [24] = (RW_ uint32_t*)0x400094FCU,   /** @brief MDIOS output data register 24 */
      [25] = (RW_ uint32_t*)0x40009500U,   /** @brief MDIOS output data register 25 */
      [26] = (RW_ uint32_t*)0x40009504U,   /** @brief MDIOS output data register 26 */
      [27] = (RW_ uint32_t*)0x40009508U,   /** @brief MDIOS output data register 27 */
      [28] = (RW_ uint32_t*)0x4000950CU,   /** @brief MDIOS output data register 28 */
      [29] = (RW_ uint32_t*)0x40009510U,   /** @brief MDIOS output data register 29 */
      [30] = (RW_ uint32_t*)0x40009514U,   /** @brief MDIOS output data register 30 */
      [31] = (RW_ uint32_t*)0x40009518U,   /** @brief MDIOS output data register 31 */
      [0]  = (RW_ uint32_t*)0x4000949CU   /** @brief MDIOS output data register 0 */
    };

    /**** @subsection MDIOS Register Reset Value Definitions ****/

    static const uint32_t MDIOS_MDIOS_CR_RST    = 0x00000000U;   /** @brief MDIOS configuration register */
    static const uint32_t MDIOS_MDIOS_WRFR_RST  = 0x00000000U;   /** @brief MDIOS write flag register */
    static const uint32_t MDIOS_MDIOS_CWRFR_RST = 0x00000000U;   /** @brief MDIOS clear write flag register */
    static const uint32_t MDIOS_MDIOS_RDFR_RST  = 0x00000000U;   /** @brief MDIOS read flag register */
    static const uint32_t MDIOS_MDIOS_CRDFR_RST = 0x00000000U;   /** @brief MDIOS clear read flag register */
    static const uint32_t MDIOS_MDIOS_SR_RST    = 0x00000000U;   /** @brief MDIOS status register */
    static const uint32_t MDIOS_MDIOS_CLRFR_RST = 0x00000000U;   /** @brief MDIOS clear flag register */

    static const uint32_t MDIOS_MDIOS_DINRx_RST[32] = {
      [1]  = 0x00000000U,   /** @brief MDIOS input data register 1 */
      [2]  = 0x00000000U,   /** @brief MDIOS input data register 2 */
      [3]  = 0x00000000U,   /** @brief MDIOS input data register 3 */
      [4]  = 0x00000000U,   /** @brief MDIOS input data register 4 */
      [5]  = 0x00000000U,   /** @brief MDIOS input data register 5 */
      [6]  = 0x00000000U,   /** @brief MDIOS input data register 6 */
      [7]  = 0x00000000U,   /** @brief MDIOS input data register 7 */
      [8]  = 0x00000000U,   /** @brief MDIOS input data register 8 */
      [9]  = 0x00000000U,   /** @brief MDIOS input data register 9 */
      [10] = 0x00000000U,   /** @brief MDIOS input data register 10 */
      [11] = 0x00000000U,   /** @brief MDIOS input data register 11 */
      [12] = 0x00000000U,   /** @brief MDIOS input data register 12 */
      [13] = 0x00000000U,   /** @brief MDIOS input data register 13 */
      [14] = 0x00000000U,   /** @brief MDIOS input data register 14 */
      [15] = 0x00000000U,   /** @brief MDIOS input data register 15 */
      [16] = 0x00000000U,   /** @brief MDIOS input data register 16 */
      [17] = 0x00000000U,   /** @brief MDIOS input data register 17 */
      [18] = 0x00000000U,   /** @brief MDIOS input data register 18 */
      [19] = 0x00000000U,   /** @brief MDIOS input data register 19 */
      [20] = 0x00000000U,   /** @brief MDIOS input data register 20 */
      [21] = 0x00000000U,   /** @brief MDIOS input data register 21 */
      [22] = 0x00000000U,   /** @brief MDIOS input data register 22 */
      [23] = 0x00000000U,   /** @brief MDIOS input data register 23 */
      [24] = 0x00000000U,   /** @brief MDIOS input data register 24 */
      [25] = 0x00000000U,   /** @brief MDIOS input data register 25 */
      [26] = 0x00000000U,   /** @brief MDIOS input data register 26 */
      [27] = 0x00000000U,   /** @brief MDIOS input data register 27 */
      [28] = 0x00000000U,   /** @brief MDIOS input data register 28 */
      [29] = 0x00000000U,   /** @brief MDIOS input data register 29 */
      [30] = 0x00000000U,   /** @brief MDIOS input data register 30 */
      [31] = 0x00000000U,   /** @brief MDIOS input data register 31 */
      [0]  = 0x00000000U   /** @brief MDIOS input data register 0 */
    };

    static const uint32_t MDIOS_MDIOS_DOUTRx_RST[32] = {
      [1]  = 0x00000000U,   /** @brief MDIOS output data register 1 */
      [2]  = 0x00000000U,   /** @brief MDIOS output data register 2 */
      [3]  = 0x00000000U,   /** @brief MDIOS output data register 3 */
      [4]  = 0x00000000U,   /** @brief MDIOS output data register 4 */
      [5]  = 0x00000000U,   /** @brief MDIOS output data register 5 */
      [6]  = 0x00000000U,   /** @brief MDIOS output data register 6 */
      [7]  = 0x00000000U,   /** @brief MDIOS output data register 7 */
      [8]  = 0x00000000U,   /** @brief MDIOS output data register 8 */
      [9]  = 0x00000000U,   /** @brief MDIOS output data register 9 */
      [10] = 0x00000000U,   /** @brief MDIOS output data register 10 */
      [11] = 0x00000000U,   /** @brief MDIOS output data register 11 */
      [12] = 0x00000000U,   /** @brief MDIOS output data register 12 */
      [13] = 0x00000000U,   /** @brief MDIOS output data register 13 */
      [14] = 0x00000000U,   /** @brief MDIOS output data register 14 */
      [15] = 0x00000000U,   /** @brief MDIOS output data register 15 */
      [16] = 0x00000000U,   /** @brief MDIOS output data register 16 */
      [17] = 0x00000000U,   /** @brief MDIOS output data register 17 */
      [18] = 0x00000000U,   /** @brief MDIOS output data register 18 */
      [19] = 0x00000000U,   /** @brief MDIOS output data register 19 */
      [20] = 0x00000000U,   /** @brief MDIOS output data register 20 */
      [21] = 0x00000000U,   /** @brief MDIOS output data register 21 */
      [22] = 0x00000000U,   /** @brief MDIOS output data register 22 */
      [23] = 0x00000000U,   /** @brief MDIOS output data register 23 */
      [24] = 0x00000000U,   /** @brief MDIOS output data register 24 */
      [25] = 0x00000000U,   /** @brief MDIOS output data register 25 */
      [26] = 0x00000000U,   /** @brief MDIOS output data register 26 */
      [27] = 0x00000000U,   /** @brief MDIOS output data register 27 */
      [28] = 0x00000000U,   /** @brief MDIOS output data register 28 */
      [29] = 0x00000000U,   /** @brief MDIOS output data register 29 */
      [30] = 0x00000000U,   /** @brief MDIOS output data register 30 */
      [31] = 0x00000000U,   /** @brief MDIOS output data register 31 */
      [0]  = 0x00000000U   /** @brief MDIOS output data register 0 */
    };

    /**** @subsection MDIOS Register Value Type Definitions ****/

    typedef uint32_t MDIOS_MDIOS_CR_vt;       /** @brief MDIOS_MDIOS_CR register value type. */
    typedef uint32_t MDIOS_MDIOS_WRFR_vt;     /** @brief MDIOS_MDIOS_WRFR register value type. */
    typedef uint32_t MDIOS_MDIOS_CWRFR_vt;    /** @brief MDIOS_MDIOS_CWRFR register value type. */
    typedef uint32_t MDIOS_MDIOS_RDFR_vt;     /** @brief MDIOS_MDIOS_RDFR register value type. */
    typedef uint32_t MDIOS_MDIOS_CRDFR_vt;    /** @brief MDIOS_MDIOS_CRDFR register value type. */
    typedef uint32_t MDIOS_MDIOS_SR_vt;       /** @brief MDIOS_MDIOS_SR register value type. */
    typedef uint32_t MDIOS_MDIOS_CLRFR_vt;    /** @brief MDIOS_MDIOS_CLRFR register value type. */
    typedef uint32_t MDIOS_MDIOS_DINRx_vt;    /** @brief MDIOS_MDIOS_DINRx register value type. */
    typedef uint32_t MDIOS_MDIOS_DOUTRx_vt;   /** @brief MDIOS_MDIOS_DOUTRx register value type. */

    /**** @subsection MDIOS Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* MDIOS_MDIOS_CR_pt;       /** @brief MDIOS_MDIOS_CR pointer register pointer type. */
    typedef RO_ uint32_t* MDIOS_MDIOS_WRFR_pt;     /** @brief MDIOS_MDIOS_WRFR pointer register pointer type. */
    typedef RW_ uint32_t* MDIOS_MDIOS_CWRFR_pt;    /** @brief MDIOS_MDIOS_CWRFR pointer register pointer type. */
    typedef RO_ uint32_t* MDIOS_MDIOS_RDFR_pt;     /** @brief MDIOS_MDIOS_RDFR pointer register pointer type. */
    typedef RW_ uint32_t* MDIOS_MDIOS_CRDFR_pt;    /** @brief MDIOS_MDIOS_CRDFR pointer register pointer type. */
    typedef RO_ uint32_t* MDIOS_MDIOS_SR_pt;       /** @brief MDIOS_MDIOS_SR pointer register pointer type. */
    typedef RW_ uint32_t* MDIOS_MDIOS_CLRFR_pt;    /** @brief MDIOS_MDIOS_CLRFR pointer register pointer type. */
    typedef RO_ uint32_t* MDIOS_MDIOS_DINRx_pt;    /** @brief MDIOS_MDIOS_DINRx pointer register pointer type. */
    typedef RW_ uint32_t* MDIOS_MDIOS_DOUTRx_pt;   /** @brief MDIOS_MDIOS_DOUTRx pointer register pointer type. */

    /**** @subsection MDIOS Field Mask Definitions ****/

    static const uint32_t MDIOS_MDIOS_CR_PORT_ADDRESS_MASK = 0x00001F00U;   /** @brief Slaves's address */
    static const uint32_t MDIOS_MDIOS_WRFR_WRF_MASK        = 0xFFFFFFFFU;   /** @brief Write flags for MDIO registers 0 to 31 */
    static const uint32_t MDIOS_MDIOS_CWRFR_CWRF_MASK      = 0xFFFFFFFFU;   /** @brief Clear the write flag */
    static const uint32_t MDIOS_MDIOS_RDFR_RDF_MASK        = 0xFFFFFFFFU;   /** @brief Read flags for MDIO registers 0 to 31 */
    static const uint32_t MDIOS_MDIOS_CRDFR_CRDF_MASK      = 0xFFFFFFFFU;   /** @brief Clear the read flag */
    static const uint32_t MDIOS_MDIOS_SR_TERF_MASK         = 0x00000004U;   /** @brief Turnaround error flag */
    static const uint32_t MDIOS_MDIOS_CLRFR_CTERF_MASK     = 0x00000004U;   /** @brief Clear the turnaround error flag */

    static const uint32_t MDIOS_MDIOS_DINRx_DINx_MASK[32] = {
      [1]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [2]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [3]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [4]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [5]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [6]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [7]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [8]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [9]  = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [10] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [11] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [12] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [13] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [14] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [15] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [16] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [17] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [18] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [19] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [20] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [21] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [22] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [23] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [24] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [25] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [26] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [27] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [28] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [29] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [30] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [31] = 0x0000FFFFU,   /** @brief Input data received from MDIO master during write frames */
      [0]  = 0x0000FFFFU   /** @brief Input data received from MDIO master during write frames */
    };

    static const uint32_t MDIOS_MDIOS_DOUTRx_DOUTx_MASK[32] = {
      [1]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [2]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [3]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [4]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [5]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [6]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [7]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [8]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [9]  = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [10] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [11] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [12] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [13] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [14] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [15] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [16] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [17] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [18] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [19] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [20] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [21] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [22] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [23] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [24] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [25] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [26] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [27] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [28] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [29] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [30] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [31] = 0x0000FFFFU,   /** @brief Output data sent to MDIO master during read frames */
      [0]  = 0x0000FFFFU   /** @brief Output data sent to MDIO master during read frames */
    };

    /**********************************************************************************************
     * @section OPAMP Register Definitions
     **********************************************************************************************/

    /**** @subsection OPAMP Register Pointer Definitions ****/

    static RW_ uint32_t* const OPAMP_OPAMPx_CSR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40009010U,   /** @brief OPAMP2 control/status register */
      [1] = (RW_ uint32_t*)0x40009000U   /** @brief OPAMP1 control/status register */
    };

    static RW_ uint32_t* const OPAMP_OPAMPx_OTR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40009014U,   /** @brief OPAMP2 offset trimming register in normal mode */
      [1] = (RW_ uint32_t*)0x40009004U   /** @brief OPAMP1 offset trimming register in normal mode */
    };

    static RW_ uint32_t* const OPAMP_OPAMPx_HSOTR_PTR[3] = {
      [2] = (RW_ uint32_t*)0x40009018U,   /** @brief OPAMP2 offset trimming register in low-power mode */
      [1] = (RW_ uint32_t*)0x40009008U   /** @brief OPAMP1 offset trimming register in low-power mode */
    };

    /**** @subsection OPAMP Register Reset Value Definitions ****/

    static const uint32_t OPAMP_OPAMPx_CSR_RST[3] = {
      [2] = 0x00000000U,   /** @brief OPAMP2 control/status register */
      [1] = 0x00000000U   /** @brief OPAMP1 control/status register */
    };

    static const uint32_t OPAMP_OPAMPx_OTR_RST[3] = {
      [2] = 0x00000000U,   /** @brief OPAMP2 offset trimming register in normal mode */
      [1] = 0x00000000U   /** @brief OPAMP1 offset trimming register in normal mode */
    };

    static const uint32_t OPAMP_OPAMPx_HSOTR_RST[3] = {
      [2] = 0x00000000U,   /** @brief OPAMP2 offset trimming register in low-power mode */
      [1] = 0x00000000U   /** @brief OPAMP1 offset trimming register in low-power mode */
    };

    /**** @subsection OPAMP Register Value Type Definitions ****/

    typedef uint32_t OPAMP_OPAMPx_CSR_vt;     /** @brief OPAMP_OPAMPx_CSR register value type. */
    typedef uint32_t OPAMP_OPAMPx_OTR_vt;     /** @brief OPAMP_OPAMPx_OTR register value type. */
    typedef uint32_t OPAMP_OPAMPx_HSOTR_vt;   /** @brief OPAMP_OPAMPx_HSOTR register value type. */

    /**** @subsection OPAMP Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* OPAMP_OPAMPx_CSR_pt;     /** @brief OPAMP_OPAMPx_CSR pointer register pointer type. */
    typedef RW_ uint32_t* OPAMP_OPAMPx_OTR_pt;     /** @brief OPAMP_OPAMPx_OTR pointer register pointer type. */
    typedef RW_ uint32_t* OPAMP_OPAMPx_HSOTR_pt;   /** @brief OPAMP_OPAMPx_HSOTR pointer register pointer type. */

    /**** @subsection OPAMP Field Mask Definitions ****/

    static const uint32_t OPAMP_OPAMPx_CSR_CALOUT_MASK[3] = {
      [2] = 0x40000000U,   /** @brief Operational amplifier calibration output */
      [1] = 0x40000000U   /** @brief Operational amplifier calibration output */
    };

    static const uint32_t OPAMP_OPAMPx_OTR_TRIMOFFSETP_MASK[3] = {
      [2] = 0x00001F00U,   /** @brief Trim for PMOS differential pairs */
      [1] = 0x00001F00U   /** @brief Trim for PMOS differential pairs */
    };

    static const uint32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETP_MASK[3] = {
      [2] = 0x00001F00U,   /** @brief Trim for PMOS differential pairs */
      [1] = 0x00001F00U   /** @brief Trim for PMOS differential pairs */
    };

    /**********************************************************************************************
     * @section SWPMI Register Definitions
     **********************************************************************************************/

    /**** @subsection SWPMI Register Pointer Definitions ****/

    static RW_ uint32_t* const SWPMI_CR_PTR  = (RW_ uint32_t*)0x40008800U;   /** @brief SWPMI configuration/control register */
    static RW_ uint32_t* const SWPMI_BRR_PTR = (RW_ uint32_t*)0x40008804U;   /** @brief SWPMI bitrate register */
    static RO_ uint32_t* const SWPMI_ISR_PTR = (RO_ uint32_t*)0x4000880CU;   /** @brief SWPMI interrupt and status register */
    static RW_ uint32_t* const SWPMI_ICR_PTR = (RW_ uint32_t*)0x40008810U;   /** @brief SWPMI interrupt flag clear register */
    static RW_ uint32_t* const SWPMI_IER_PTR = (RW_ uint32_t*)0x40008814U;   /** @brief SWPMI interrupt enable register */
    static RO_ uint32_t* const SWPMI_RFL_PTR = (RO_ uint32_t*)0x40008818U;   /** @brief SWPMI receive frame length register */
    static RW_ uint32_t* const SWPMI_TDR_PTR = (RW_ uint32_t*)0x4000881CU;   /** @brief SWPMI transmit data register */
    static RO_ uint32_t* const SWPMI_RDR_PTR = (RO_ uint32_t*)0x40008820U;   /** @brief SWPMI receive data register */
    static RW_ uint32_t* const SWPMI_OR_PTR  = (RW_ uint32_t*)0x40008824U;   /** @brief SWPMI option register */

    /**** @subsection SWPMI Register Reset Value Definitions ****/

    static const uint32_t SWPMI_CR_RST  = 0x00000000U;   /** @brief SWPMI configuration/control register */
    static const uint32_t SWPMI_BRR_RST = 0x00000001U;   /** @brief SWPMI bitrate register */
    static const uint32_t SWPMI_ISR_RST = 0x000002C2U;   /** @brief SWPMI interrupt and status register */
    static const uint32_t SWPMI_ICR_RST = 0x00000000U;   /** @brief SWPMI interrupt flag clear register */
    static const uint32_t SWPMI_IER_RST = 0x00000000U;   /** @brief SWPMI interrupt enable register */
    static const uint32_t SWPMI_RFL_RST = 0x00000000U;   /** @brief SWPMI receive frame length register */
    static const uint32_t SWPMI_TDR_RST = 0x00000000U;   /** @brief SWPMI transmit data register */
    static const uint32_t SWPMI_RDR_RST = 0x00000000U;   /** @brief SWPMI receive data register */
    static const uint32_t SWPMI_OR_RST  = 0x00000000U;   /** @brief SWPMI option register */

    /**** @subsection SWPMI Register Value Type Definitions ****/

    typedef uint32_t SWPMI_CR_vt;    /** @brief SWPMI_CR register value type. */
    typedef uint32_t SWPMI_BRR_vt;   /** @brief SWPMI_BRR register value type. */
    typedef uint32_t SWPMI_ISR_vt;   /** @brief SWPMI_ISR register value type. */
    typedef uint32_t SWPMI_ICR_vt;   /** @brief SWPMI_ICR register value type. */
    typedef uint32_t SWPMI_IER_vt;   /** @brief SWPMI_IER register value type. */
    typedef uint32_t SWPMI_RFL_vt;   /** @brief SWPMI_RFL register value type. */
    typedef uint32_t SWPMI_TDR_vt;   /** @brief SWPMI_TDR register value type. */
    typedef uint32_t SWPMI_RDR_vt;   /** @brief SWPMI_RDR register value type. */
    typedef uint32_t SWPMI_OR_vt;    /** @brief SWPMI_OR register value type. */

    /**** @subsection SWPMI Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* SWPMI_CR_pt;    /** @brief SWPMI_CR pointer register pointer type. */
    typedef RW_ uint32_t* SWPMI_BRR_pt;   /** @brief SWPMI_BRR pointer register pointer type. */
    typedef RO_ uint32_t* SWPMI_ISR_pt;   /** @brief SWPMI_ISR pointer register pointer type. */
    typedef RW_ uint32_t* SWPMI_ICR_pt;   /** @brief SWPMI_ICR pointer register pointer type. */
    typedef RW_ uint32_t* SWPMI_IER_pt;   /** @brief SWPMI_IER pointer register pointer type. */
    typedef RO_ uint32_t* SWPMI_RFL_pt;   /** @brief SWPMI_RFL pointer register pointer type. */
    typedef RW_ uint32_t* SWPMI_TDR_pt;   /** @brief SWPMI_TDR pointer register pointer type. */
    typedef RO_ uint32_t* SWPMI_RDR_pt;   /** @brief SWPMI_RDR pointer register pointer type. */
    typedef RW_ uint32_t* SWPMI_OR_pt;    /** @brief SWPMI_OR pointer register pointer type. */

    /**** @subsection SWPMI Field Mask Definitions ****/

    static const uint32_t SWPMI_CR_SWPTEN_MASK    = 0x00000800U;   /** @brief Single wire protocol master transceiver enable */
    static const uint32_t SWPMI_BRR_BR_MASK       = 0x000000FFU;   /** @brief Bitrate prescaler */
    static const uint32_t SWPMI_ISR_RDYF_MASK     = 0x00000800U;   /** @brief Transceiver ready flag */
    static const uint32_t SWPMI_ICR_CRDYF_MASK    = 0x00000800U;   /** @brief Clear transceiver ready flag */
    static const uint32_t SWPMI_IER_RDYIE_MASK    = 0x00000800U;   /** @brief Transceiver ready interrupt enable */
    static const uint32_t SWPMI_RFL_RFL_MASK      = 0x0000001FU;   /** @brief Receive frame length */
    static const uint32_t SWPMI_TDR_TD_MASK       = 0xFFFFFFFFU;   /** @brief Transmit data */
    static const uint32_t SWPMI_RDR_RD_MASK       = 0xFFFFFFFFU;   /** @brief Received data */
    static const uint32_t SWPMI_OR_SWP_CLASS_MASK = 0x00000002U;   /** @brief SWP class selection */

    /**********************************************************************************************
     * @section G_TIM Register Definitions
     **********************************************************************************************/

    /**** @subsection G_TIM Register Pointer Definitions ****/

    static RW_ uint32_t* const G_TIMx_SMCR_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000408U,   /** @brief Slave mode control register */
      [4]  = (RW_ uint32_t*)0x40000808U,   /** @brief Slave mode control register */
      [5]  = (RW_ uint32_t*)0x40000C08U,   /** @brief Slave mode control register */
      [12] = (RW_ uint32_t*)0x40001808U,   /** @brief Slave mode control register */
      [13] = (RW_ uint32_t*)0x40001C08U,   /** @brief Slave mode control register */
      [14] = (RW_ uint32_t*)0x40002008U,   /** @brief Slave mode control register */
      [2]  = (RW_ uint32_t*)0x40000008U   /** @brief Slave mode control register */
    };

    static RW_ uint32_t* const G_TIMx_DIER_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x4000040CU,   /** @brief DMA/Interrupt enable register */
      [4]  = (RW_ uint32_t*)0x4000080CU,   /** @brief DMA/Interrupt enable register */
      [5]  = (RW_ uint32_t*)0x40000C0CU,   /** @brief DMA/Interrupt enable register */
      [12] = (RW_ uint32_t*)0x4000180CU,   /** @brief DMA/Interrupt enable register */
      [13] = (RW_ uint32_t*)0x40001C0CU,   /** @brief DMA/Interrupt enable register */
      [14] = (RW_ uint32_t*)0x4000200CU,   /** @brief DMA/Interrupt enable register */
      [2]  = (RW_ uint32_t*)0x4000000CU   /** @brief DMA/Interrupt enable register */
    };

    static RW_ uint32_t* const G_TIMx_SR_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000410U,   /** @brief Status register */
      [4]  = (RW_ uint32_t*)0x40000810U,   /** @brief Status register */
      [5]  = (RW_ uint32_t*)0x40000C10U,   /** @brief Status register */
      [12] = (RW_ uint32_t*)0x40001810U,   /** @brief Status register */
      [13] = (RW_ uint32_t*)0x40001C10U,   /** @brief Status register */
      [14] = (RW_ uint32_t*)0x40002010U,   /** @brief Status register */
      [2]  = (RW_ uint32_t*)0x40000010U   /** @brief Status register */
    };

    static RW_ uint32_t* const G_TIMx_EGR_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000414U,   /** @brief Event generation register */
      [4]  = (RW_ uint32_t*)0x40000814U,   /** @brief Event generation register */
      [5]  = (RW_ uint32_t*)0x40000C14U,   /** @brief Event generation register */
      [12] = (RW_ uint32_t*)0x40001814U,   /** @brief Event generation register */
      [13] = (RW_ uint32_t*)0x40001C14U,   /** @brief Event generation register */
      [14] = (RW_ uint32_t*)0x40002014U,   /** @brief Event generation register */
      [2]  = (RW_ uint32_t*)0x40000014U   /** @brief Event generation register */
    };

    static RW_ uint32_t* const G_TIMx_CCER_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000420U,   /** @brief Capture/compare enable register */
      [4]  = (RW_ uint32_t*)0x40000820U,   /** @brief Capture/compare enable register */
      [5]  = (RW_ uint32_t*)0x40000C20U,   /** @brief Capture/compare enable register */
      [12] = (RW_ uint32_t*)0x40001820U,   /** @brief Capture/compare enable register */
      [13] = (RW_ uint32_t*)0x40001C20U,   /** @brief Capture/compare enable register */
      [14] = (RW_ uint32_t*)0x40002020U,   /** @brief Capture/compare enable register */
      [2]  = (RW_ uint32_t*)0x40000020U   /** @brief Capture/compare enable register */
    };

    static RW_ uint32_t* const G_TIMx_CNT_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000424U,   /** @brief Counter */
      [4]  = (RW_ uint32_t*)0x40000824U,   /** @brief Counter */
      [5]  = (RW_ uint32_t*)0x40000C24U,   /** @brief Counter */
      [12] = (RW_ uint32_t*)0x40001824U,   /** @brief Counter */
      [13] = (RW_ uint32_t*)0x40001C24U,   /** @brief Counter */
      [14] = (RW_ uint32_t*)0x40002024U,   /** @brief Counter */
      [2]  = (RW_ uint32_t*)0x40000024U   /** @brief Counter */
    };

    static RW_ uint32_t* const G_TIMx_PSC_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000428U,   /** @brief Prescaler */
      [4]  = (RW_ uint32_t*)0x40000828U,   /** @brief Prescaler */
      [5]  = (RW_ uint32_t*)0x40000C28U,   /** @brief Prescaler */
      [12] = (RW_ uint32_t*)0x40001828U,   /** @brief Prescaler */
      [13] = (RW_ uint32_t*)0x40001C28U,   /** @brief Prescaler */
      [14] = (RW_ uint32_t*)0x40002028U,   /** @brief Prescaler */
      [2]  = (RW_ uint32_t*)0x40000028U   /** @brief Prescaler */
    };

    static RW_ uint32_t* const G_TIMx_ARR_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x4000042CU,   /** @brief Auto-reload register */
      [4]  = (RW_ uint32_t*)0x4000082CU,   /** @brief Auto-reload register */
      [5]  = (RW_ uint32_t*)0x40000C2CU,   /** @brief Auto-reload register */
      [12] = (RW_ uint32_t*)0x4000182CU,   /** @brief Auto-reload register */
      [13] = (RW_ uint32_t*)0x40001C2CU,   /** @brief Auto-reload register */
      [14] = (RW_ uint32_t*)0x4000202CU,   /** @brief Auto-reload register */
      [2]  = (RW_ uint32_t*)0x4000002CU   /** @brief Auto-reload register */
    };

    static RW_ uint32_t* const G_TIMx_DCR_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000448U,   /** @brief DMA control register */
      [4]  = (RW_ uint32_t*)0x40000848U,   /** @brief DMA control register */
      [5]  = (RW_ uint32_t*)0x40000C48U,   /** @brief DMA control register */
      [12] = (RW_ uint32_t*)0x40001848U,   /** @brief DMA control register */
      [13] = (RW_ uint32_t*)0x40001C48U,   /** @brief DMA control register */
      [14] = (RW_ uint32_t*)0x40002048U,   /** @brief DMA control register */
      [2]  = (RW_ uint32_t*)0x40000048U   /** @brief DMA control register */
    };

    static RW_ uint32_t* const G_TIMx_DMAR_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x4000044CU,   /** @brief DMA address for full transfer */
      [4]  = (RW_ uint32_t*)0x4000084CU,   /** @brief DMA address for full transfer */
      [5]  = (RW_ uint32_t*)0x40000C4CU,   /** @brief DMA address for full transfer */
      [12] = (RW_ uint32_t*)0x4000184CU,   /** @brief DMA address for full transfer */
      [13] = (RW_ uint32_t*)0x40001C4CU,   /** @brief DMA address for full transfer */
      [14] = (RW_ uint32_t*)0x4000204CU,   /** @brief DMA address for full transfer */
      [2]  = (RW_ uint32_t*)0x4000004CU   /** @brief DMA address for full transfer */
    };

    static RW_ uint32_t* const G_TIMx_AF1_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000460U,   /** @brief TIM alternate function option register 1 */
      [4]  = (RW_ uint32_t*)0x40000860U,   /** @brief TIM alternate function option register 1 */
      [5]  = (RW_ uint32_t*)0x40000C60U,   /** @brief TIM alternate function option register 1 */
      [12] = (RW_ uint32_t*)0x40001860U,   /** @brief TIM alternate function option register 1 */
      [13] = (RW_ uint32_t*)0x40001C60U,   /** @brief TIM alternate function option register 1 */
      [14] = (RW_ uint32_t*)0x40002060U,   /** @brief TIM alternate function option register 1 */
      [2]  = (RW_ uint32_t*)0x40000060U   /** @brief TIM alternate function option register 1 */
    };

    static RW_ uint32_t* const G_TIMx_TISEL_PTR[15] = {
      [3]  = (RW_ uint32_t*)0x40000468U,   /** @brief TIM timer input selection register */
      [4]  = (RW_ uint32_t*)0x40000868U,   /** @brief TIM timer input selection register */
      [5]  = (RW_ uint32_t*)0x40000C68U,   /** @brief TIM timer input selection register */
      [12] = (RW_ uint32_t*)0x40001868U,   /** @brief TIM timer input selection register */
      [13] = (RW_ uint32_t*)0x40001C68U,   /** @brief TIM timer input selection register */
      [14] = (RW_ uint32_t*)0x40002068U,   /** @brief TIM timer input selection register */
      [2]  = (RW_ uint32_t*)0x40000068U   /** @brief TIM timer input selection register */
    };

    /**** @subsection G_TIM Register Reset Value Definitions ****/

    static const uint32_t G_TIMx_SMCR_RST[15] = {
      [3]  = 0x00000000U,   /** @brief Slave mode control register */
      [4]  = 0x00000000U,   /** @brief Slave mode control register */
      [5]  = 0x00000000U,   /** @brief Slave mode control register */
      [12] = 0x00000000U,   /** @brief Slave mode control register */
      [13] = 0x00000000U,   /** @brief Slave mode control register */
      [14] = 0x00000000U,   /** @brief Slave mode control register */
      [2]  = 0x00000000U   /** @brief Slave mode control register */
    };

    static const uint32_t G_TIMx_DIER_RST[15] = {
      [3]  = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [4]  = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [5]  = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [12] = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [13] = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [14] = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [2]  = 0x00000000U   /** @brief DMA/Interrupt enable register */
    };

    static const uint32_t G_TIMx_SR_RST[15] = {
      [3]  = 0x00000000U,   /** @brief Status register */
      [4]  = 0x00000000U,   /** @brief Status register */
      [5]  = 0x00000000U,   /** @brief Status register */
      [12] = 0x00000000U,   /** @brief Status register */
      [13] = 0x00000000U,   /** @brief Status register */
      [14] = 0x00000000U,   /** @brief Status register */
      [2]  = 0x00000000U   /** @brief Status register */
    };

    static const uint32_t G_TIMx_EGR_RST[15] = {
      [3]  = 0x00000000U,   /** @brief Event generation register */
      [4]  = 0x00000000U,   /** @brief Event generation register */
      [5]  = 0x00000000U,   /** @brief Event generation register */
      [12] = 0x00000000U,   /** @brief Event generation register */
      [13] = 0x00000000U,   /** @brief Event generation register */
      [14] = 0x00000000U,   /** @brief Event generation register */
      [2]  = 0x00000000U   /** @brief Event generation register */
    };

    static const uint32_t G_TIMx_CCER_RST[15] = {
      [3]  = 0x00000000U,   /** @brief Capture/compare enable register */
      [4]  = 0x00000000U,   /** @brief Capture/compare enable register */
      [5]  = 0x00000000U,   /** @brief Capture/compare enable register */
      [12] = 0x00000000U,   /** @brief Capture/compare enable register */
      [13] = 0x00000000U,   /** @brief Capture/compare enable register */
      [14] = 0x00000000U,   /** @brief Capture/compare enable register */
      [2]  = 0x00000000U   /** @brief Capture/compare enable register */
    };

    static const uint32_t G_TIMx_CNT_RST[15] = {
      [3]  = 0x00000000U,   /** @brief Counter */
      [4]  = 0x00000000U,   /** @brief Counter */
      [5]  = 0x00000000U,   /** @brief Counter */
      [12] = 0x00000000U,   /** @brief Counter */
      [13] = 0x00000000U,   /** @brief Counter */
      [14] = 0x00000000U,   /** @brief Counter */
      [2]  = 0x00000000U   /** @brief Counter */
    };

    static const uint32_t G_TIMx_PSC_RST[15] = {
      [3]  = 0x00000000U,   /** @brief Prescaler */
      [4]  = 0x00000000U,   /** @brief Prescaler */
      [5]  = 0x00000000U,   /** @brief Prescaler */
      [12] = 0x00000000U,   /** @brief Prescaler */
      [13] = 0x00000000U,   /** @brief Prescaler */
      [14] = 0x00000000U,   /** @brief Prescaler */
      [2]  = 0x00000000U   /** @brief Prescaler */
    };

    static const uint32_t G_TIMx_ARR_RST[15] = {
      [3]  = 0x00000000U,   /** @brief Auto-reload register */
      [4]  = 0x00000000U,   /** @brief Auto-reload register */
      [5]  = 0x00000000U,   /** @brief Auto-reload register */
      [12] = 0x00000000U,   /** @brief Auto-reload register */
      [13] = 0x00000000U,   /** @brief Auto-reload register */
      [14] = 0x00000000U,   /** @brief Auto-reload register */
      [2]  = 0x00000000U   /** @brief Auto-reload register */
    };

    static const uint32_t G_TIMx_DCR_RST[15] = {
      [3]  = 0x00000000U,   /** @brief DMA control register */
      [4]  = 0x00000000U,   /** @brief DMA control register */
      [5]  = 0x00000000U,   /** @brief DMA control register */
      [12] = 0x00000000U,   /** @brief DMA control register */
      [13] = 0x00000000U,   /** @brief DMA control register */
      [14] = 0x00000000U,   /** @brief DMA control register */
      [2]  = 0x00000000U   /** @brief DMA control register */
    };

    static const uint32_t G_TIMx_DMAR_RST[15] = {
      [3]  = 0x00000000U,   /** @brief DMA address for full transfer */
      [4]  = 0x00000000U,   /** @brief DMA address for full transfer */
      [5]  = 0x00000000U,   /** @brief DMA address for full transfer */
      [12] = 0x00000000U,   /** @brief DMA address for full transfer */
      [13] = 0x00000000U,   /** @brief DMA address for full transfer */
      [14] = 0x00000000U,   /** @brief DMA address for full transfer */
      [2]  = 0x00000000U   /** @brief DMA address for full transfer */
    };

    static const uint32_t G_TIMx_AF1_RST[15] = {
      [3]  = 0x00000000U,   /** @brief TIM alternate function option register 1 */
      [4]  = 0x00000000U,   /** @brief TIM alternate function option register 1 */
      [5]  = 0x00000000U,   /** @brief TIM alternate function option register 1 */
      [12] = 0x00000000U,   /** @brief TIM alternate function option register 1 */
      [13] = 0x00000000U,   /** @brief TIM alternate function option register 1 */
      [14] = 0x00000000U,   /** @brief TIM alternate function option register 1 */
      [2]  = 0x00000000U   /** @brief TIM alternate function option register 1 */
    };

    static const uint32_t G_TIMx_TISEL_RST[15] = {
      [3]  = 0x00000000U,   /** @brief TIM timer input selection register */
      [4]  = 0x00000000U,   /** @brief TIM timer input selection register */
      [5]  = 0x00000000U,   /** @brief TIM timer input selection register */
      [12] = 0x00000000U,   /** @brief TIM timer input selection register */
      [13] = 0x00000000U,   /** @brief TIM timer input selection register */
      [14] = 0x00000000U,   /** @brief TIM timer input selection register */
      [2]  = 0x00000000U   /** @brief TIM timer input selection register */
    };

    /**** @subsection G_TIM Register Value Type Definitions ****/

    typedef uint32_t G_TIMx_CRx_vt;            /** @brief G_TIMx_CRx register value type. */
    typedef uint32_t G_TIMx_SMCR_vt;           /** @brief G_TIMx_SMCR register value type. */
    typedef uint32_t G_TIMx_DIER_vt;           /** @brief G_TIMx_DIER register value type. */
    typedef uint32_t G_TIMx_SR_vt;             /** @brief G_TIMx_SR register value type. */
    typedef uint32_t G_TIMx_EGR_vt;            /** @brief G_TIMx_EGR register value type. */
    typedef uint32_t G_TIMx_CCMRx_OUTPUT_vt;   /** @brief G_TIMx_CCMRx_OUTPUT register value type. */
    typedef uint32_t G_TIMx_CCMRx_INPUT_vt;    /** @brief G_TIMx_CCMRx_INPUT register value type. */
    typedef uint32_t G_TIMx_CCER_vt;           /** @brief G_TIMx_CCER register value type. */
    typedef uint32_t G_TIMx_CNT_vt;            /** @brief G_TIMx_CNT register value type. */
    typedef uint32_t G_TIMx_PSC_vt;            /** @brief G_TIMx_PSC register value type. */
    typedef uint32_t G_TIMx_ARR_vt;            /** @brief G_TIMx_ARR register value type. */
    typedef uint32_t G_TIMx_CCRx_vt;           /** @brief G_TIMx_CCRx register value type. */
    typedef uint32_t G_TIMx_DCR_vt;            /** @brief G_TIMx_DCR register value type. */
    typedef uint32_t G_TIMx_DMAR_vt;           /** @brief G_TIMx_DMAR register value type. */
    typedef uint32_t G_TIMx_AF1_vt;            /** @brief G_TIMx_AF1 register value type. */
    typedef uint32_t G_TIMx_TISEL_vt;          /** @brief G_TIMx_TISEL register value type. */

    /**** @subsection G_TIM Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* G_TIMx_CRx_pt;            /** @brief G_TIMx_CRx pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_SMCR_pt;           /** @brief G_TIMx_SMCR pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_DIER_pt;           /** @brief G_TIMx_DIER pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_SR_pt;             /** @brief G_TIMx_SR pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_EGR_pt;            /** @brief G_TIMx_EGR pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_CCMRx_OUTPUT_pt;   /** @brief G_TIMx_CCMRx_OUTPUT pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_CCMRx_INPUT_pt;    /** @brief G_TIMx_CCMRx_INPUT pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_CCER_pt;           /** @brief G_TIMx_CCER pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_CNT_pt;            /** @brief G_TIMx_CNT pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_PSC_pt;            /** @brief G_TIMx_PSC pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_ARR_pt;            /** @brief G_TIMx_ARR pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_CCRx_pt;           /** @brief G_TIMx_CCRx pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_DCR_pt;            /** @brief G_TIMx_DCR pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_DMAR_pt;           /** @brief G_TIMx_DMAR pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_AF1_pt;            /** @brief G_TIMx_AF1 pointer register pointer type. */
    typedef RW_ uint32_t* G_TIMx_TISEL_pt;          /** @brief G_TIMx_TISEL pointer register pointer type. */

    /**** @subsection G_TIM Field Mask Definitions ****/

    static const uint32_t G_TIMx_CRx_CEN_MASK[15] = {
      [3]  = 0x00000001U,   /** @brief Counter enable */
      [4]  = 0x00000001U,   /** @brief Counter enable */
      [5]  = 0x00000001U,   /** @brief Counter enable */
      [12] = 0x00000001U,   /** @brief Counter enable */
      [13] = 0x00000001U,   /** @brief Counter enable */
      [14] = 0x00000001U,   /** @brief Counter enable */
      [2]  = 0x00000001U   /** @brief Counter enable */
    };

    static const uint32_t G_TIMx_SMCR_SMS_MASK[15] = {
      [3]  = 0x00000007U,   /** @brief Slave mode selection */
      [4]  = 0x00000007U,   /** @brief Slave mode selection */
      [5]  = 0x00000007U,   /** @brief Slave mode selection */
      [12] = 0x00000007U,   /** @brief Slave mode selection */
      [13] = 0x00000007U,   /** @brief Slave mode selection */
      [14] = 0x00000007U,   /** @brief Slave mode selection */
      [2]  = 0x00000007U   /** @brief Slave mode selection */
    };

    static const uint32_t G_TIMx_DIER_UIE_MASK[15] = {
      [3]  = 0x00000001U,   /** @brief Update interrupt enable */
      [4]  = 0x00000001U,   /** @brief Update interrupt enable */
      [5]  = 0x00000001U,   /** @brief Update interrupt enable */
      [12] = 0x00000001U,   /** @brief Update interrupt enable */
      [13] = 0x00000001U,   /** @brief Update interrupt enable */
      [14] = 0x00000001U,   /** @brief Update interrupt enable */
      [2]  = 0x00000001U   /** @brief Update interrupt enable */
    };

    static const uint32_t G_TIMx_SR_UIF_MASK[15] = {
      [3]  = 0x00000001U,   /** @brief Update interrupt flag */
      [4]  = 0x00000001U,   /** @brief Update interrupt flag */
      [5]  = 0x00000001U,   /** @brief Update interrupt flag */
      [12] = 0x00000001U,   /** @brief Update interrupt flag */
      [13] = 0x00000001U,   /** @brief Update interrupt flag */
      [14] = 0x00000001U,   /** @brief Update interrupt flag */
      [2]  = 0x00000001U   /** @brief Update interrupt flag */
    };

    static const uint32_t G_TIMx_EGR_UG_MASK[15] = {
      [3]  = 0x00000001U,   /** @brief Update generation */
      [4]  = 0x00000001U,   /** @brief Update generation */
      [5]  = 0x00000001U,   /** @brief Update generation */
      [12] = 0x00000001U,   /** @brief Update generation */
      [13] = 0x00000001U,   /** @brief Update generation */
      [14] = 0x00000001U,   /** @brief Update generation */
      [2]  = 0x00000001U   /** @brief Update generation */
    };

    static const uint32_t G_TIMx_CCMRx_INPUT_ICPCS_MASK[15] = {
      [3]  = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [4]  = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [5]  = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [12] = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [13] = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [14] = 0x0000000CU,   /** @brief Input capture 1 prescaler */
      [2]  = 0x0000000CU   /** @brief Input capture 1 prescaler */
    };

    static const uint32_t G_TIMx_CNT_CNT_H_MASK[15] = {
      [3]  = 0xFFFF0000U,   /** @brief High counter value */
      [4]  = 0xFFFF0000U,   /** @brief High counter value */
      [5]  = 0xFFFF0000U,   /** @brief High counter value */
      [12] = 0xFFFF0000U,   /** @brief High counter value */
      [13] = 0xFFFF0000U,   /** @brief High counter value */
      [14] = 0xFFFF0000U,   /** @brief High counter value */
      [2]  = 0xFFFF0000U   /** @brief High counter value */
    };

    static const uint32_t G_TIMx_PSC_PSC_MASK[15] = {
      [3]  = 0x0000FFFFU,   /** @brief Prescaler value */
      [4]  = 0x0000FFFFU,   /** @brief Prescaler value */
      [5]  = 0x0000FFFFU,   /** @brief Prescaler value */
      [12] = 0x0000FFFFU,   /** @brief Prescaler value */
      [13] = 0x0000FFFFU,   /** @brief Prescaler value */
      [14] = 0x0000FFFFU,   /** @brief Prescaler value */
      [2]  = 0x0000FFFFU   /** @brief Prescaler value */
    };

    static const uint32_t G_TIMx_ARR_ARR_L_MASK[15] = {
      [3]  = 0x0000FFFFU,   /** @brief Low auto-reload value */
      [4]  = 0x0000FFFFU,   /** @brief Low auto-reload value */
      [5]  = 0x0000FFFFU,   /** @brief Low auto-reload value */
      [12] = 0x0000FFFFU,   /** @brief Low auto-reload value */
      [13] = 0x0000FFFFU,   /** @brief Low auto-reload value */
      [14] = 0x0000FFFFU,   /** @brief Low auto-reload value */
      [2]  = 0x0000FFFFU   /** @brief Low auto-reload value */
    };

    static const uint32_t G_TIMx_DCR_DBA_MASK[15] = {
      [3]  = 0x0000001FU,   /** @brief DMA base address */
      [4]  = 0x0000001FU,   /** @brief DMA base address */
      [5]  = 0x0000001FU,   /** @brief DMA base address */
      [12] = 0x0000001FU,   /** @brief DMA base address */
      [13] = 0x0000001FU,   /** @brief DMA base address */
      [14] = 0x0000001FU,   /** @brief DMA base address */
      [2]  = 0x0000001FU   /** @brief DMA base address */
    };

    static const uint32_t G_TIMx_DMAR_DMAB_MASK[15] = {
      [3]  = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [4]  = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [5]  = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [12] = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [13] = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [14] = 0x0000FFFFU,   /** @brief DMA register for burst accesses */
      [2]  = 0x0000FFFFU   /** @brief DMA register for burst accesses */
    };

    static const uint32_t G_TIMx_AF1_ETRSEL_MASK[15] = {
      [3]  = 0x0003C000U,   /** @brief ETR source selection */
      [4]  = 0x0003C000U,   /** @brief ETR source selection */
      [5]  = 0x0003C000U,   /** @brief ETR source selection */
      [12] = 0x0003C000U,   /** @brief ETR source selection */
      [13] = 0x0003C000U,   /** @brief ETR source selection */
      [14] = 0x0003C000U,   /** @brief ETR source selection */
      [2]  = 0x0003C000U   /** @brief ETR source selection */
    };

    static const uint32_t G_TIMx_CCER_CCxE_MASK[15][5] = {
      [3] = {
        [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
        [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
        [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
        [4] = 0x00001000U   /** @brief Capture/Compare 4 output enable */
      },
      [4] = {
        [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
        [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
        [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
        [4] = 0x00001000U   /** @brief Capture/Compare 4 output enable */
      },
      [5] = {
        [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
        [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
        [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
        [4] = 0x00001000U   /** @brief Capture/Compare 4 output enable */
      },
      [12] = {
        [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
        [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
        [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
        [4] = 0x00001000U   /** @brief Capture/Compare 4 output enable */
      },
      [13] = {
        [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
        [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
        [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
        [4] = 0x00001000U   /** @brief Capture/Compare 4 output enable */
      },
      [14] = {
        [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
        [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
        [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
        [4] = 0x00001000U   /** @brief Capture/Compare 4 output enable */
      },
      [2] = {
        [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
        [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
        [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
        [4] = 0x00001000U   /** @brief Capture/Compare 4 output enable */
      }
    };

    static const uint32_t G_TIMx_CCRx_CCRx_L_MASK[15][5] = {
      [3] = {
        [2] = 0x0000FFFFU,   /** @brief Low capture/compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [4] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [1] = 0x0000FFFFU   /** @brief Low capture/compare 1 value */
      },
      [4] = {
        [2] = 0x0000FFFFU,   /** @brief Low capture/compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [4] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [1] = 0x0000FFFFU   /** @brief Low capture/compare 1 value */
      },
      [5] = {
        [2] = 0x0000FFFFU,   /** @brief Low capture/compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [4] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [1] = 0x0000FFFFU   /** @brief Low capture/compare 1 value */
      },
      [12] = {
        [2] = 0x0000FFFFU,   /** @brief Low capture/compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [4] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [1] = 0x0000FFFFU   /** @brief Low capture/compare 1 value */
      },
      [13] = {
        [2] = 0x0000FFFFU,   /** @brief Low capture/compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [4] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [1] = 0x0000FFFFU   /** @brief Low capture/compare 1 value */
      },
      [14] = {
        [2] = 0x0000FFFFU,   /** @brief Low capture/compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [4] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [1] = 0x0000FFFFU   /** @brief Low capture/compare 1 value */
      },
      [2] = {
        [2] = 0x0000FFFFU,   /** @brief Low capture/compare 2 value */
        [3] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [4] = 0x0000FFFFU,   /** @brief Low capture/compare value */
        [1] = 0x0000FFFFU   /** @brief Low capture/compare 1 value */
      }
    };

    static const uint32_t G_TIMx_TISEL_TIxSEL_MASK[15][5] = {
      [3] = {
        [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
        [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
        [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
        [1] = 0x0000000FU   /** @brief TI1[0] to TI1[15] input selection */
      },
      [4] = {
        [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
        [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
        [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
        [1] = 0x0000000FU   /** @brief TI1[0] to TI1[15] input selection */
      },
      [5] = {
        [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
        [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
        [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
        [1] = 0x0000000FU   /** @brief TI1[0] to TI1[15] input selection */
      },
      [12] = {
        [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
        [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
        [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
        [1] = 0x0000000FU   /** @brief TI1[0] to TI1[15] input selection */
      },
      [13] = {
        [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
        [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
        [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
        [1] = 0x0000000FU   /** @brief TI1[0] to TI1[15] input selection */
      },
      [14] = {
        [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
        [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
        [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
        [1] = 0x0000000FU   /** @brief TI1[0] to TI1[15] input selection */
      },
      [2] = {
        [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
        [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
        [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
        [1] = 0x0000000FU   /** @brief TI1[0] to TI1[15] input selection */
      }
    };

    static uint32_t G_TIMx_CCMRx_OUTPUT_OCxM_3[15][3][5] = {
      [3] = {
        [2] = {
          [4] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [3] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        },
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      },
      [4] = {
        [2] = {
          [4] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [3] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        },
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      },
      [5] = {
        [2] = {
          [4] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [3] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        },
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      },
      [12] = {
        [2] = {
          [4] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [3] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        },
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      },
      [13] = {
        [2] = {
          [4] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [3] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        },
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      },
      [14] = {
        [2] = {
          [4] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [3] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        },
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      },
      [2] = {
        [2] = {
          [4] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [3] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        },
        [1] = {
          [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
          [1] = 0x00010000U   /** @brief Output compare 1 mode - bit 3 */
        }
      }
    };

    /**********************************************************************************************
     * @section B_TIM Register Definitions
     **********************************************************************************************/

    /**** @subsection B_TIM Register Pointer Definitions ****/

    static RW_ uint32_t* const B_TIMx_DIER_PTR[8] = {
      [7] = (RW_ uint32_t*)0x4000140CU,   /** @brief DMA/Interrupt enable register */
      [6] = (RW_ uint32_t*)0x4000100CU   /** @brief DMA/Interrupt enable register */
    };

    static RW_ uint32_t* const B_TIMx_SR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40001410U,   /** @brief Status register */
      [6] = (RW_ uint32_t*)0x40001010U   /** @brief Status register */
    };

    static RW_ uint32_t* const B_TIMx_EGR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40001414U,   /** @brief Event generation register */
      [6] = (RW_ uint32_t*)0x40001014U   /** @brief Event generation register */
    };

    static RW_ uint32_t* const B_TIMx_CNT_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40001424U,   /** @brief Counter */
      [6] = (RW_ uint32_t*)0x40001024U   /** @brief Counter */
    };

    static RW_ uint32_t* const B_TIMx_PSC_PTR[8] = {
      [7] = (RW_ uint32_t*)0x40001428U,   /** @brief Prescaler */
      [6] = (RW_ uint32_t*)0x40001028U   /** @brief Prescaler */
    };

    static RW_ uint32_t* const B_TIMx_ARR_PTR[8] = {
      [7] = (RW_ uint32_t*)0x4000142CU,   /** @brief Auto-reload register */
      [6] = (RW_ uint32_t*)0x4000102CU   /** @brief Auto-reload register */
    };

    /**** @subsection B_TIM Register Reset Value Definitions ****/

    static const uint32_t B_TIMx_DIER_RST[8] = {
      [7] = 0x00000000U,   /** @brief DMA/Interrupt enable register */
      [6] = 0x00000000U   /** @brief DMA/Interrupt enable register */
    };

    static const uint32_t B_TIMx_SR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Status register */
      [6] = 0x00000000U   /** @brief Status register */
    };

    static const uint32_t B_TIMx_EGR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Event generation register */
      [6] = 0x00000000U   /** @brief Event generation register */
    };

    static const uint32_t B_TIMx_CNT_RST[8] = {
      [7] = 0x00000000U,   /** @brief Counter */
      [6] = 0x00000000U   /** @brief Counter */
    };

    static const uint32_t B_TIMx_PSC_RST[8] = {
      [7] = 0x00000000U,   /** @brief Prescaler */
      [6] = 0x00000000U   /** @brief Prescaler */
    };

    static const uint32_t B_TIMx_ARR_RST[8] = {
      [7] = 0x00000000U,   /** @brief Auto-reload register */
      [6] = 0x00000000U   /** @brief Auto-reload register */
    };

    /**** @subsection B_TIM Register Value Type Definitions ****/

    typedef uint32_t B_TIMx_CRx_vt;    /** @brief B_TIMx_CRx register value type. */
    typedef uint32_t B_TIMx_DIER_vt;   /** @brief B_TIMx_DIER register value type. */
    typedef uint32_t B_TIMx_SR_vt;     /** @brief B_TIMx_SR register value type. */
    typedef uint32_t B_TIMx_EGR_vt;    /** @brief B_TIMx_EGR register value type. */
    typedef uint32_t B_TIMx_CNT_vt;    /** @brief B_TIMx_CNT register value type. */
    typedef uint32_t B_TIMx_PSC_vt;    /** @brief B_TIMx_PSC register value type. */
    typedef uint32_t B_TIMx_ARR_vt;    /** @brief B_TIMx_ARR register value type. */

    /**** @subsection B_TIM Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* B_TIMx_CRx_pt;    /** @brief B_TIMx_CRx pointer register pointer type. */
    typedef RW_ uint32_t* B_TIMx_DIER_pt;   /** @brief B_TIMx_DIER pointer register pointer type. */
    typedef RW_ uint32_t* B_TIMx_SR_pt;     /** @brief B_TIMx_SR pointer register pointer type. */
    typedef RW_ uint32_t* B_TIMx_EGR_pt;    /** @brief B_TIMx_EGR pointer register pointer type. */
    typedef RW_ uint32_t* B_TIMx_CNT_pt;    /** @brief B_TIMx_CNT pointer register pointer type. */
    typedef RW_ uint32_t* B_TIMx_PSC_pt;    /** @brief B_TIMx_PSC pointer register pointer type. */
    typedef RW_ uint32_t* B_TIMx_ARR_pt;    /** @brief B_TIMx_ARR pointer register pointer type. */

    /**** @subsection B_TIM Field Mask Definitions ****/

    static const uint32_t B_TIMx_CRx_CEN_MASK[8] = {
      [7] = 0x00000001U,   /** @brief Counter enable */
      [6] = 0x00000001U   /** @brief Counter enable */
    };

    static const uint32_t B_TIMx_DIER_UIE_MASK[8] = {
      [7] = 0x00000001U,   /** @brief Update interrupt enable */
      [6] = 0x00000001U   /** @brief Update interrupt enable */
    };

    static const uint32_t B_TIMx_SR_UIF_MASK[8] = {
      [7] = 0x00000001U,   /** @brief Update interrupt flag */
      [6] = 0x00000001U   /** @brief Update interrupt flag */
    };

    static const uint32_t B_TIMx_EGR_UG_MASK[8] = {
      [7] = 0x00000001U,   /** @brief Update generation */
      [6] = 0x00000001U   /** @brief Update generation */
    };

    static const uint32_t B_TIMx_CNT_UIFCPY_MASK[8] = {
      [7] = 0x80000000U,   /** @brief UIF copy */
      [6] = 0x80000000U   /** @brief UIF copy */
    };

    static const uint32_t B_TIMx_PSC_PSC_MASK[8] = {
      [7] = 0x0000FFFFU,   /** @brief Prescaler value */
      [6] = 0x0000FFFFU   /** @brief Prescaler value */
    };

    static const uint32_t B_TIMx_ARR_ARR_MASK[8] = {
      [7] = 0x0000FFFFU,   /** @brief Low auto-reload value */
      [6] = 0x0000FFFFU   /** @brief Low auto-reload value */
    };

    /**********************************************************************************************
     * @section NVIC Register Definitions
     **********************************************************************************************/

    /**** @subsection NVIC Register Pointer Definitions ****/

    static RW_ uint32_t* const NVIC_ISERx_PTR[4] = {
      [1] = (RW_ uint32_t*)0xE000E104U,   /** @brief Interrupt set-enable register */
      [2] = (RW_ uint32_t*)0xE000E108U,   /** @brief Interrupt set-enable register */
      [3] = (RW_ uint32_t*)0xE000E10CU,   /** @brief Interrupt set-enable register */
      [0] = (RW_ uint32_t*)0xE000E100U   /** @brief Interrupt set-enable register */
    };

    static RW_ uint32_t* const NVIC_ICERx_PTR[4] = {
      [1] = (RW_ uint32_t*)0xE000E184U,   /** @brief Interrupt clear-enable register */
      [2] = (RW_ uint32_t*)0xE000E188U,   /** @brief Interrupt clear-enable register */
      [3] = (RW_ uint32_t*)0xE000E18CU,   /** @brief Interrupt clear-enable register */
      [0] = (RW_ uint32_t*)0xE000E180U   /** @brief Interrupt clear-enable register */
    };

    static RW_ uint32_t* const NVIC_ISPRx_PTR[4] = {
      [1] = (RW_ uint32_t*)0xE000E204U,   /** @brief Interrupt set-pending register */
      [2] = (RW_ uint32_t*)0xE000E208U,   /** @brief Interrupt set-pending register */
      [3] = (RW_ uint32_t*)0xE000E20CU,   /** @brief Interrupt set-pending register */
      [0] = (RW_ uint32_t*)0xE000E200U   /** @brief Interrupt set-pending register */
    };

    static RW_ uint32_t* const NVIC_ICPRx_PTR[4] = {
      [1] = (RW_ uint32_t*)0xE000E284U,   /** @brief Interrupt clear-pending register */
      [2] = (RW_ uint32_t*)0xE000E288U,   /** @brief Interrupt clear-pending register */
      [3] = (RW_ uint32_t*)0xE000E2C0U,   /** @brief Interrupt clear-pending register */
      [0] = (RW_ uint32_t*)0xE000E280U   /** @brief Interrupt clear-pending register */
    };

    static RO_ uint32_t* const NVIC_IABRx_PTR[4] = {
      [1] = (RO_ uint32_t*)0xE000E304U,   /** @brief Interrupt active bit register */
      [2] = (RO_ uint32_t*)0xE000E308U,   /** @brief Interrupt active bit register */
      [3] = (RO_ uint32_t*)0xE000E30CU,   /** @brief Interrupt active bit register */
      [0] = (RO_ uint32_t*)0xE000E300U   /** @brief Interrupt active bit register */
    };

    static RW_ uint32_t* const NVIC_IPRx_PTR[39] = {
      [1]  = (RW_ uint32_t*)0xE000E404U,   /** @brief Interrupt priority register */
      [2]  = (RW_ uint32_t*)0xE000E408U,   /** @brief Interrupt priority register */
      [3]  = (RW_ uint32_t*)0xE000E40CU,   /** @brief Interrupt priority register */
      [4]  = (RW_ uint32_t*)0xE000E410U,   /** @brief Interrupt priority register */
      [5]  = (RW_ uint32_t*)0xE000E414U,   /** @brief Interrupt priority register */
      [6]  = (RW_ uint32_t*)0xE000E418U,   /** @brief Interrupt priority register */
      [7]  = (RW_ uint32_t*)0xE000E41CU,   /** @brief Interrupt priority register */
      [8]  = (RW_ uint32_t*)0xE000E420U,   /** @brief Interrupt priority register */
      [9]  = (RW_ uint32_t*)0xE000E424U,   /** @brief Interrupt priority register */
      [10] = (RW_ uint32_t*)0xE000E428U,   /** @brief Interrupt priority register */
      [11] = (RW_ uint32_t*)0xE000E42CU,   /** @brief Interrupt priority register */
      [12] = (RW_ uint32_t*)0xE000E430U,   /** @brief Interrupt priority register */
      [13] = (RW_ uint32_t*)0xE000E434U,   /** @brief Interrupt priority register */
      [14] = (RW_ uint32_t*)0xE000E438U,   /** @brief Interrupt priority register */
      [15] = (RW_ uint32_t*)0xE000E43CU,   /** @brief Interrupt priority register */
      [16] = (RW_ uint32_t*)0xE000E440U,   /** @brief Interrupt priority register */
      [17] = (RW_ uint32_t*)0xE000E444U,   /** @brief Interrupt priority register */
      [18] = (RW_ uint32_t*)0xE000E448U,   /** @brief Interrupt priority register */
      [19] = (RW_ uint32_t*)0xE000E44CU,   /** @brief Interrupt priority register */
      [20] = (RW_ uint32_t*)0xE000E450U,   /** @brief Interrupt priority register */
      [21] = (RW_ uint32_t*)0xE000E454U,   /** @brief Interrupt priority register */
      [22] = (RW_ uint32_t*)0xE000E458U,   /** @brief Interrupt priority register */
      [23] = (RW_ uint32_t*)0xE000E45CU,   /** @brief Interrupt priority register */
      [24] = (RW_ uint32_t*)0xE000E460U,   /** @brief Interrupt priority register */
      [25] = (RW_ uint32_t*)0xE000E464U,   /** @brief Interrupt priority register */
      [26] = (RW_ uint32_t*)0xE000E468U,   /** @brief Interrupt priority register */
      [27] = (RW_ uint32_t*)0xE000E46CU,   /** @brief Interrupt priority register */
      [28] = (RW_ uint32_t*)0xE000E470U,   /** @brief Interrupt priority register */
      [29] = (RW_ uint32_t*)0xE000E474U,   /** @brief Interrupt priority register */
      [30] = (RW_ uint32_t*)0xE000E478U,   /** @brief Interrupt priority register */
      [31] = (RW_ uint32_t*)0xE000E47CU,   /** @brief Interrupt priority register */
      [32] = (RW_ uint32_t*)0xE000E480U,   /** @brief Interrupt priority register */
      [33] = (RW_ uint32_t*)0xE000E484U,   /** @brief Interrupt priority register */
      [34] = (RW_ uint32_t*)0xE000E488U,   /** @brief Interrupt priority register */
      [35] = (RW_ uint32_t*)0xE000E48CU,   /** @brief Interrupt priority register */
      [36] = (RW_ uint32_t*)0xE000E490U,   /** @brief Interrupt priority register */
      [37] = (RW_ uint32_t*)0xE000E494U,   /** @brief Interrupt priority register */
      [38] = (RW_ uint32_t*)0xE000E498U,   /** @brief Interrupt priority register */
      [0]  = (RW_ uint32_t*)0xE000E400U   /** @brief Interrupt priority register */
    };

    /**** @subsection NVIC Register Reset Value Definitions ****/

    static const uint32_t NVIC_ISERx_RST[4] = {
      [1] = 0x00000000U,   /** @brief Interrupt set-enable register */
      [2] = 0x00000000U,   /** @brief Interrupt set-enable register */
      [3] = 0x00000000U,   /** @brief Interrupt set-enable register */
      [0] = 0x00000000U   /** @brief Interrupt set-enable register */
    };

    static const uint32_t NVIC_ICERx_RST[4] = {
      [1] = 0x00000000U,   /** @brief Interrupt clear-enable register */
      [2] = 0x00000000U,   /** @brief Interrupt clear-enable register */
      [3] = 0x00000000U,   /** @brief Interrupt clear-enable register */
      [0] = 0x00000000U   /** @brief Interrupt clear-enable register */
    };

    static const uint32_t NVIC_ISPRx_RST[4] = {
      [1] = 0x00000000U,   /** @brief Interrupt set-pending register */
      [2] = 0x00000000U,   /** @brief Interrupt set-pending register */
      [3] = 0x00000000U,   /** @brief Interrupt set-pending register */
      [0] = 0x00000000U   /** @brief Interrupt set-pending register */
    };

    static const uint32_t NVIC_ICPRx_RST[4] = {
      [1] = 0x00000000U,   /** @brief Interrupt clear-pending register */
      [2] = 0x00000000U,   /** @brief Interrupt clear-pending register */
      [3] = 0x00000000U,   /** @brief Interrupt clear-pending register */
      [0] = 0x00000000U   /** @brief Interrupt clear-pending register */
    };

    static const uint32_t NVIC_IABRx_RST[4] = {
      [1] = 0x00000000U,   /** @brief Interrupt active bit register */
      [2] = 0x00000000U,   /** @brief Interrupt active bit register */
      [3] = 0x00000000U,   /** @brief Interrupt active bit register */
      [0] = 0x00000000U   /** @brief Interrupt active bit register */
    };

    static const uint32_t NVIC_IPRx_RST[39] = {
      [1]  = 0x00000000U,   /** @brief Interrupt priority register */
      [2]  = 0x00000000U,   /** @brief Interrupt priority register */
      [3]  = 0x00000000U,   /** @brief Interrupt priority register */
      [4]  = 0x00000000U,   /** @brief Interrupt priority register */
      [5]  = 0x00000000U,   /** @brief Interrupt priority register */
      [6]  = 0x00000000U,   /** @brief Interrupt priority register */
      [7]  = 0x00000000U,   /** @brief Interrupt priority register */
      [8]  = 0x00000000U,   /** @brief Interrupt priority register */
      [9]  = 0x00000000U,   /** @brief Interrupt priority register */
      [10] = 0x00000000U,   /** @brief Interrupt priority register */
      [11] = 0x00000000U,   /** @brief Interrupt priority register */
      [12] = 0x00000000U,   /** @brief Interrupt priority register */
      [13] = 0x00000000U,   /** @brief Interrupt priority register */
      [14] = 0x00000000U,   /** @brief Interrupt priority register */
      [15] = 0x00000000U,   /** @brief Interrupt priority register */
      [16] = 0x00000000U,   /** @brief Interrupt priority register */
      [17] = 0x00000000U,   /** @brief Interrupt priority register */
      [18] = 0x00000000U,   /** @brief Interrupt priority register */
      [19] = 0x00000000U,   /** @brief Interrupt priority register */
      [20] = 0x00000000U,   /** @brief Interrupt priority register */
      [21] = 0x00000000U,   /** @brief Interrupt priority register */
      [22] = 0x00000000U,   /** @brief Interrupt priority register */
      [23] = 0x00000000U,   /** @brief Interrupt priority register */
      [24] = 0x00000000U,   /** @brief Interrupt priority register */
      [25] = 0x00000000U,   /** @brief Interrupt priority register */
      [26] = 0x00000000U,   /** @brief Interrupt priority register */
      [27] = 0x00000000U,   /** @brief Interrupt priority register */
      [28] = 0x00000000U,   /** @brief Interrupt priority register */
      [29] = 0x00000000U,   /** @brief Interrupt priority register */
      [30] = 0x00000000U,   /** @brief Interrupt priority register */
      [31] = 0x00000000U,   /** @brief Interrupt priority register */
      [32] = 0x00000000U,   /** @brief Interrupt priority register */
      [33] = 0x00000000U,   /** @brief Interrupt priority register */
      [34] = 0x00000000U,   /** @brief Interrupt priority register */
      [35] = 0x00000000U,   /** @brief Interrupt priority register */
      [36] = 0x00000000U,   /** @brief Interrupt priority register */
      [37] = 0x00000000U,   /** @brief Interrupt priority register */
      [38] = 0x00000000U,   /** @brief Interrupt priority register */
      [0]  = 0x00000000U   /** @brief Interrupt priority register */
    };

    /**** @subsection NVIC Register Value Type Definitions ****/

    typedef uint32_t NVIC_ISERx_vt;   /** @brief NVIC_ISERx register value type. */
    typedef uint32_t NVIC_ICERx_vt;   /** @brief NVIC_ICERx register value type. */
    typedef uint32_t NVIC_ISPRx_vt;   /** @brief NVIC_ISPRx register value type. */
    typedef uint32_t NVIC_ICPRx_vt;   /** @brief NVIC_ICPRx register value type. */
    typedef uint32_t NVIC_IABRx_vt;   /** @brief NVIC_IABRx register value type. */
    typedef uint32_t NVIC_IPRx_vt;    /** @brief NVIC_IPRx register value type. */

    /**** @subsection NVIC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* NVIC_ISERx_pt;   /** @brief NVIC_ISERx pointer register pointer type. */
    typedef RW_ uint32_t* NVIC_ICERx_pt;   /** @brief NVIC_ICERx pointer register pointer type. */
    typedef RW_ uint32_t* NVIC_ISPRx_pt;   /** @brief NVIC_ISPRx pointer register pointer type. */
    typedef RW_ uint32_t* NVIC_ICPRx_pt;   /** @brief NVIC_ICPRx pointer register pointer type. */
    typedef RO_ uint32_t* NVIC_IABRx_pt;   /** @brief NVIC_IABRx pointer register pointer type. */
    typedef RW_ uint32_t* NVIC_IPRx_pt;    /** @brief NVIC_IPRx pointer register pointer type. */

    /**** @subsection NVIC Field Mask Definitions ****/

    static const uint32_t NVIC_ISERx_SETENA_MASK[3] = {
      [1] = 0xFFFFFFFFU,   /** @brief SETENA */
      [2] = 0xFFFFFFFFU,   /** @brief SETENA */
      [0] = 0xFFFFFFFFU   /** @brief SETENA */
    };

    static const uint32_t NVIC_ICERx_CLRENA_MASK[3] = {
      [1] = 0xFFFFFFFFU,   /** @brief CLRENA */
      [2] = 0xFFFFFFFFU,   /** @brief CLRENA */
      [0] = 0xFFFFFFFFU   /** @brief CLRENA */
    };

    static const uint32_t NVIC_ISPRx_SETPEND_MASK[3] = {
      [1] = 0xFFFFFFFFU,   /** @brief SETPEND */
      [2] = 0xFFFFFFFFU,   /** @brief SETPEND */
      [0] = 0xFFFFFFFFU   /** @brief SETPEND */
    };

    static const uint32_t NVIC_ICPRx_CLRPEND_MASK[3] = {
      [1] = 0xFFFFFFFFU,   /** @brief CLRPEND */
      [2] = 0xFFFFFFFFU,   /** @brief CLRPEND */
      [0] = 0xFFFFFFFFU   /** @brief CLRPEND */
    };

    static const uint32_t NVIC_IABRx_ACTIVE_MASK[3] = {
      [1] = 0xFFFFFFFFU,   /** @brief ACTIVE */
      [2] = 0xFFFFFFFFU,   /** @brief ACTIVE */
      [0] = 0xFFFFFFFFU   /** @brief ACTIVE */
    };

    static const uint32_t NVIC_IPRx_IPR_Nx_MASK[39][4] = {
      [1] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [2] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [3] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [4] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [5] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [6] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [7] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [8] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [9] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [10] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [11] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [12] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [13] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [14] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [15] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [16] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [17] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [18] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [19] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [20] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [21] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [22] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [23] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [24] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [25] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [26] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [27] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [28] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [29] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [30] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [31] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [32] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [33] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [34] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [35] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [36] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [37] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [38] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      },
      [0] = {
        [1] = 0x0000FF00U,   /** @brief IPR_N1 */
        [2] = 0x00FF0000U,   /** @brief IPR_N2 */
        [3] = 0xFF000000U,   /** @brief IPR_N3 */
        [0] = 0x000000FFU   /** @brief IPR_N0 */
      }
    };

    /**********************************************************************************************
     * @section MPU Register Definitions
     **********************************************************************************************/

    /**** @subsection MPU Register Pointer Definitions ****/

    static RO_ uint32_t* const MPU_MPU_TYPER_PTR = (RO_ uint32_t*)0xE000ED90U;   /** @brief MPU type register */
    static RO_ uint32_t* const MPU_MPU_CTRL_PTR  = (RO_ uint32_t*)0xE000ED94U;   /** @brief MPU control register */
    static RW_ uint32_t* const MPU_MPU_RNR_PTR   = (RW_ uint32_t*)0xE000ED98U;   /** @brief MPU region number register */
    static RW_ uint32_t* const MPU_MPU_RBAR_PTR  = (RW_ uint32_t*)0xE000ED9CU;   /** @brief MPU region base address register */
    static RW_ uint32_t* const MPU_MPU_RASR_PTR  = (RW_ uint32_t*)0xE000EDA0U;   /** @brief MPU region attribute and size register */

    /**** @subsection MPU Register Reset Value Definitions ****/

    static const uint32_t MPU_MPU_TYPER_RST = 0x00000800U;   /** @brief MPU type register */
    static const uint32_t MPU_MPU_CTRL_RST  = 0x00000000U;   /** @brief MPU control register */
    static const uint32_t MPU_MPU_RNR_RST   = 0x00000000U;   /** @brief MPU region number register */
    static const uint32_t MPU_MPU_RBAR_RST  = 0x00000000U;   /** @brief MPU region base address register */
    static const uint32_t MPU_MPU_RASR_RST  = 0x00000000U;   /** @brief MPU region attribute and size register */

    /**** @subsection MPU Register Value Type Definitions ****/

    typedef uint32_t MPU_MPU_TYPER_vt;   /** @brief MPU_MPU_TYPER register value type. */
    typedef uint32_t MPU_MPU_CTRL_vt;    /** @brief MPU_MPU_CTRL register value type. */
    typedef uint32_t MPU_MPU_RNR_vt;     /** @brief MPU_MPU_RNR register value type. */
    typedef uint32_t MPU_MPU_RBAR_vt;    /** @brief MPU_MPU_RBAR register value type. */
    typedef uint32_t MPU_MPU_RASR_vt;    /** @brief MPU_MPU_RASR register value type. */

    /**** @subsection MPU Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* MPU_MPU_TYPER_pt;   /** @brief MPU_MPU_TYPER pointer register pointer type. */
    typedef RO_ uint32_t* MPU_MPU_CTRL_pt;    /** @brief MPU_MPU_CTRL pointer register pointer type. */
    typedef RW_ uint32_t* MPU_MPU_RNR_pt;     /** @brief MPU_MPU_RNR pointer register pointer type. */
    typedef RW_ uint32_t* MPU_MPU_RBAR_pt;    /** @brief MPU_MPU_RBAR pointer register pointer type. */
    typedef RW_ uint32_t* MPU_MPU_RASR_pt;    /** @brief MPU_MPU_RASR pointer register pointer type. */

    /**** @subsection MPU Field Mask Definitions ****/

    static const uint32_t MPU_MPU_TYPER_IREGION_MASK   = 0x00FF0000U;   /** @brief Number of MPU instruction regions */
    static const uint32_t MPU_MPU_CTRL_PRIVDEFENA_MASK = 0x00000004U;   /** @brief Enable priviliged software access to default memory map */
    static const uint32_t MPU_MPU_RNR_REGION_MASK      = 0x000000FFU;   /** @brief MPU region */
    static const uint32_t MPU_MPU_RBAR_ADDR_MASK       = 0xFFFFFFE0U;   /** @brief Region base address field */
    static const uint32_t MPU_MPU_RASR_XN_MASK         = 0x10000000U;   /** @brief Instruction access disable bit */

    /**********************************************************************************************
     * @section STK Register Definitions
     **********************************************************************************************/

    /**** @subsection STK Register Pointer Definitions ****/

    static RW_ uint32_t* const STK_CSR_PTR   = (RW_ uint32_t*)0xE000E010U;   /** @brief SysTick control and status register */
    static RW_ uint32_t* const STK_RVR_PTR   = (RW_ uint32_t*)0xE000E014U;   /** @brief SysTick reload value register */
    static RW_ uint32_t* const STK_CVR_PTR   = (RW_ uint32_t*)0xE000E018U;   /** @brief SysTick current value register */
    static RW_ uint32_t* const STK_CALIB_PTR = (RW_ uint32_t*)0xE000E01CU;   /** @brief SysTick calibration value register */

    /**** @subsection STK Register Reset Value Definitions ****/

    static const uint32_t STK_CSR_RST   = 0x00000000U;   /** @brief SysTick control and status register */
    static const uint32_t STK_RVR_RST   = 0x00000000U;   /** @brief SysTick reload value register */
    static const uint32_t STK_CVR_RST   = 0x00000000U;   /** @brief SysTick current value register */
    static const uint32_t STK_CALIB_RST = 0x00000000U;   /** @brief SysTick calibration value register */

    /**** @subsection STK Register Value Type Definitions ****/

    typedef uint32_t STK_CSR_vt;     /** @brief STK_CSR register value type. */
    typedef uint32_t STK_RVR_vt;     /** @brief STK_RVR register value type. */
    typedef uint32_t STK_CVR_vt;     /** @brief STK_CVR register value type. */
    typedef uint32_t STK_CALIB_vt;   /** @brief STK_CALIB register value type. */

    /**** @subsection STK Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* STK_CSR_pt;     /** @brief STK_CSR pointer register pointer type. */
    typedef RW_ uint32_t* STK_RVR_pt;     /** @brief STK_RVR pointer register pointer type. */
    typedef RW_ uint32_t* STK_CVR_pt;     /** @brief STK_CVR pointer register pointer type. */
    typedef RW_ uint32_t* STK_CALIB_pt;   /** @brief STK_CALIB pointer register pointer type. */

    /**** @subsection STK Field Mask Definitions ****/

    static const uint32_t STK_CSR_COUNTFLAG_MASK = 0x00010000U;   /** @brief COUNTFLAG */
    static const uint32_t STK_RVR_RELOAD_MASK    = 0x00FFFFFFU;   /** @brief RELOAD value */
    static const uint32_t STK_CVR_CURRENT_MASK   = 0x00FFFFFFU;   /** @brief Current counter value */
    static const uint32_t STK_CALIB_NOREF_MASK   = 0x80000000U;   /** @brief NOREF flag. Reads as zero */

    /**********************************************************************************************
     * @section NVIC_STIR Register Definitions
     **********************************************************************************************/

    /**** @subsection NVIC_STIR Register Pointer Definitions ****/

    static RW_ uint32_t* const NVIC_STIR_STIR_PTR = (RW_ uint32_t*)0xE000EF00U;   /** @brief Software trigger interrupt register */

    /**** @subsection NVIC_STIR Register Reset Value Definitions ****/

    static const uint32_t NVIC_STIR_STIR_RST = 0x00000000U;   /** @brief Software trigger interrupt register */

    /**** @subsection NVIC_STIR Register Value Type Definitions ****/

    typedef uint32_t NVIC_STIR_STIR_vt;   /** @brief NVIC_STIR_STIR register value type. */

    /**** @subsection NVIC_STIR Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* NVIC_STIR_STIR_pt;   /** @brief NVIC_STIR_STIR pointer register pointer type. */

    /**** @subsection NVIC_STIR Field Mask Definitions ****/

    static const uint32_t NVIC_STIR_STIR_INTID_MASK = 0x000001FFU;   /** @brief Software generated interrupt ID */

    /**********************************************************************************************
     * @section FPU_CPACR Register Definitions
     **********************************************************************************************/

    /**** @subsection FPU_CPACR Register Pointer Definitions ****/

    static RW_ uint32_t* const FPU_CPACR_CPACR_PTR = (RW_ uint32_t*)0xE000ED88U;   /** @brief Coprocessor access control register */

    /**** @subsection FPU_CPACR Register Reset Value Definitions ****/

    static const uint32_t FPU_CPACR_CPACR_RST = 0x00000000U;   /** @brief Coprocessor access control register */

    /**** @subsection FPU_CPACR Register Value Type Definitions ****/

    typedef uint32_t FPU_CPACR_CPACR_vt;   /** @brief FPU_CPACR_CPACR register value type. */

    /**** @subsection FPU_CPACR Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* FPU_CPACR_CPACR_pt;   /** @brief FPU_CPACR_CPACR pointer register pointer type. */

    /**** @subsection FPU_CPACR Field Mask Definitions ****/

    static const uint32_t FPU_CPACR_CPACR_CP_MASK = 0x00F00000U;   /** @brief CP */

    /**********************************************************************************************
     * @section SCB_ACTRL Register Definitions
     **********************************************************************************************/

    /**** @subsection SCB_ACTRL Register Pointer Definitions ****/

    static RW_ uint32_t* const SCB_ACTRL_ACTRL_PTR = (RW_ uint32_t*)0xE000E008U;   /** @brief Auxiliary control register */

    /**** @subsection SCB_ACTRL Register Reset Value Definitions ****/

    static const uint32_t SCB_ACTRL_ACTRL_RST = 0x00000000U;   /** @brief Auxiliary control register */

    /**** @subsection SCB_ACTRL Register Value Type Definitions ****/

    typedef uint32_t SCB_ACTRL_ACTRL_vt;   /** @brief SCB_ACTRL_ACTRL register value type. */

    /**** @subsection SCB_ACTRL Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* SCB_ACTRL_ACTRL_pt;   /** @brief SCB_ACTRL_ACTRL pointer register pointer type. */

    /**** @subsection SCB_ACTRL Field Mask Definitions ****/

    static const uint32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH_MASK = 0x00001000U;   /** @brief DISITMATBFLUSH */

    /**********************************************************************************************
     * @section FPU Register Definitions
     **********************************************************************************************/

    /**** @subsection FPU Register Pointer Definitions ****/

    static RW_ uint32_t* const FPU_FPCCR_PTR = (RW_ uint32_t*)0xE000EF34U;   /** @brief Floating-point context control register */
    static RW_ uint32_t* const FPU_FPCAR_PTR = (RW_ uint32_t*)0xE000EF38U;   /** @brief Floating-point context address register */
    static RW_ uint32_t* const FPU_FPSCR_PTR = (RW_ uint32_t*)0xE000EF3CU;   /** @brief Floating-point status control register */

    /**** @subsection FPU Register Reset Value Definitions ****/

    static const uint32_t FPU_FPCCR_RST = 0x00000000U;   /** @brief Floating-point context control register */
    static const uint32_t FPU_FPCAR_RST = 0x00000000U;   /** @brief Floating-point context address register */
    static const uint32_t FPU_FPSCR_RST = 0x00000000U;   /** @brief Floating-point status control register */

    /**** @subsection FPU Register Value Type Definitions ****/

    typedef uint32_t FPU_FPCCR_vt;   /** @brief FPU_FPCCR register value type. */
    typedef uint32_t FPU_FPCAR_vt;   /** @brief FPU_FPCAR register value type. */
    typedef uint32_t FPU_FPSCR_vt;   /** @brief FPU_FPSCR register value type. */

    /**** @subsection FPU Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* FPU_FPCCR_pt;   /** @brief FPU_FPCCR pointer register pointer type. */
    typedef RW_ uint32_t* FPU_FPCAR_pt;   /** @brief FPU_FPCAR pointer register pointer type. */
    typedef RW_ uint32_t* FPU_FPSCR_pt;   /** @brief FPU_FPSCR pointer register pointer type. */

    /**** @subsection FPU Field Mask Definitions ****/

    static const uint32_t FPU_FPCCR_ASPEN_MASK   = 0x80000000U;   /** @brief ASPEN */
    static const uint32_t FPU_FPCAR_ADDRESS_MASK = 0xFFFFFFF8U;   /** @brief Location of unpopulated floating-point */
    static const uint32_t FPU_FPSCR_N_MASK       = 0x80000000U;   /** @brief Negative condition code flag */

    /**********************************************************************************************
     * @section SCB Register Definitions
     **********************************************************************************************/

    /**** @subsection SCB Register Pointer Definitions ****/

    static RO_ uint32_t* const SCB_CPUID_PTR                = (RO_ uint32_t*)0xE000ED00U;   /** @brief CPUID base register */
    static RW_ uint32_t* const SCB_ICSR_PTR                 = (RW_ uint32_t*)0xE000ED04U;   /** @brief Interrupt control and state register */
    static RW_ uint32_t* const SCB_VTOR_PTR                 = (RW_ uint32_t*)0xE000ED08U;   /** @brief Vector table offset register */
    static RW_ uint32_t* const SCB_AIRCR_PTR                = (RW_ uint32_t*)0xE000ED0CU;   /** @brief Application interrupt and reset control register */
    static RW_ uint32_t* const SCB_SCR_PTR                  = (RW_ uint32_t*)0xE000ED10U;   /** @brief System control register */
    static RW_ uint32_t* const SCB_CCR_PTR                  = (RW_ uint32_t*)0xE000ED14U;   /** @brief Configuration and control register */
    static RW_ uint32_t* const SCB_SHCRS_PTR                = (RW_ uint32_t*)0xE000ED24U;   /** @brief System handler control and state register */
    static RW_ uint32_t* const SCB_CFSR_UFSR_BFSR_MMFSR_PTR = (RW_ uint32_t*)0xE000ED28U;   /** @brief Configurable fault status register */
    static RW_ uint32_t* const SCB_HFSR_PTR                 = (RW_ uint32_t*)0xE000ED2CU;   /** @brief Hard fault status register */
    static RW_ uint32_t* const SCB_MMFAR_PTR                = (RW_ uint32_t*)0xE000ED34U;   /** @brief Memory management fault address register */
    static RW_ uint32_t* const SCB_BFAR_PTR                 = (RW_ uint32_t*)0xE000ED38U;   /** @brief Bus fault address register */

    static RW_ uint32_t* const SCB_SHPRx_PTR[4] = {
      [2] = (RW_ uint32_t*)0xE000ED1CU,   /** @brief System handler priority registers */
      [3] = (RW_ uint32_t*)0xE000ED20U,   /** @brief System handler priority registers */
      [1] = (RW_ uint32_t*)0xE000ED18U   /** @brief System handler priority registers */
    };

    /**** @subsection SCB Register Reset Value Definitions ****/

    static const uint32_t SCB_CPUID_RST                = 0x410FC241U;   /** @brief CPUID base register */
    static const uint32_t SCB_ICSR_RST                 = 0x00000000U;   /** @brief Interrupt control and state register */
    static const uint32_t SCB_VTOR_RST                 = 0x00000000U;   /** @brief Vector table offset register */
    static const uint32_t SCB_AIRCR_RST                = 0x00000000U;   /** @brief Application interrupt and reset control register */
    static const uint32_t SCB_SCR_RST                  = 0x00000000U;   /** @brief System control register */
    static const uint32_t SCB_CCR_RST                  = 0x00000000U;   /** @brief Configuration and control register */
    static const uint32_t SCB_SHCRS_RST                = 0x00000000U;   /** @brief System handler control and state register */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_RST = 0x00000000U;   /** @brief Configurable fault status register */
    static const uint32_t SCB_HFSR_RST                 = 0x00000000U;   /** @brief Hard fault status register */
    static const uint32_t SCB_MMFAR_RST                = 0x00000000U;   /** @brief Memory management fault address register */
    static const uint32_t SCB_BFAR_RST                 = 0x00000000U;   /** @brief Bus fault address register */

    static const uint32_t SCB_SHPRx_RST[4] = {
      [2] = 0x00000000U,   /** @brief System handler priority registers */
      [3] = 0x00000000U,   /** @brief System handler priority registers */
      [1] = 0x00000000U   /** @brief System handler priority registers */
    };

    /**** @subsection SCB Register Value Type Definitions ****/

    typedef uint32_t SCB_CPUID_vt;                  /** @brief SCB_CPUID register value type. */
    typedef uint32_t SCB_ICSR_vt;                   /** @brief SCB_ICSR register value type. */
    typedef uint32_t SCB_VTOR_vt;                   /** @brief SCB_VTOR register value type. */
    typedef uint32_t SCB_AIRCR_vt;                  /** @brief SCB_AIRCR register value type. */
    typedef uint32_t SCB_SCR_vt;                    /** @brief SCB_SCR register value type. */
    typedef uint32_t SCB_CCR_vt;                    /** @brief SCB_CCR register value type. */
    typedef uint32_t SCB_SHPRx_vt;                  /** @brief SCB_SHPRx register value type. */
    typedef uint32_t SCB_SHCRS_vt;                  /** @brief SCB_SHCRS register value type. */
    typedef uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_vt;   /** @brief SCB_CFSR_UFSR_BFSR_MMFSR register value type. */
    typedef uint32_t SCB_HFSR_vt;                   /** @brief SCB_HFSR register value type. */
    typedef uint32_t SCB_MMFAR_vt;                  /** @brief SCB_MMFAR register value type. */
    typedef uint32_t SCB_BFAR_vt;                   /** @brief SCB_BFAR register value type. */

    /**** @subsection SCB Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* SCB_CPUID_pt;                  /** @brief SCB_CPUID pointer register pointer type. */
    typedef RW_ uint32_t* SCB_ICSR_pt;                   /** @brief SCB_ICSR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_VTOR_pt;                   /** @brief SCB_VTOR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_AIRCR_pt;                  /** @brief SCB_AIRCR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_SCR_pt;                    /** @brief SCB_SCR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_CCR_pt;                    /** @brief SCB_CCR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_SHPRx_pt;                  /** @brief SCB_SHPRx pointer register pointer type. */
    typedef RW_ uint32_t* SCB_SHCRS_pt;                  /** @brief SCB_SHCRS pointer register pointer type. */
    typedef RW_ uint32_t* SCB_CFSR_UFSR_BFSR_MMFSR_pt;   /** @brief SCB_CFSR_UFSR_BFSR_MMFSR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_HFSR_pt;                   /** @brief SCB_HFSR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_MMFAR_pt;                  /** @brief SCB_MMFAR pointer register pointer type. */
    typedef RW_ uint32_t* SCB_BFAR_pt;                   /** @brief SCB_BFAR pointer register pointer type. */

    /**** @subsection SCB Field Mask Definitions ****/

    static const uint32_t SCB_CPUID_IMPLEMENTER_MASK              = 0xFF000000U;   /** @brief Implementer code */
    static const uint32_t SCB_ICSR_NMIPENDSET_MASK                = 0x80000000U;   /** @brief NMI set-pending bit. */
    static const uint32_t SCB_VTOR_TBLOFF_MASK                    = 0x3FFFFE00U;   /** @brief Vector table base offset field */
    static const uint32_t SCB_AIRCR_VECTKEYSTAT_MASK              = 0xFFFF0000U;   /** @brief Register key */
    static const uint32_t SCB_SCR_SEVEONPEND_MASK                 = 0x00000010U;   /** @brief Send event on pending bit */
    static const uint32_t SCB_CCR_BP_MASK                         = 0x00040000U;   /** @brief BP */
    static const uint32_t SCB_SHCRS_USGFAULTENA_MASK              = 0x00040000U;   /** @brief Usage fault enable bit */
    static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_MASK = 0x02000000U;   /** @brief Divide by zero usage fault */
    static const uint32_t SCB_HFSR_DEBUG_VT_MASK                  = 0x80000000U;   /** @brief Reserved for debug use */
    static const uint32_t SCB_MMFAR_ADDRESS_MASK                  = 0xFFFFFFFFU;   /** @brief Memory management fault address */
    static const uint32_t SCB_BFAR_ADDRESS_MASK                   = 0xFFFFFFFFU;   /** @brief Bus fault address */

    static const uint32_t SCB_SHPRx_PRI_x_MASK[3] = {
      [2] = 0xFF000000U   /** @brief Priority of system handler 11 */
    };

    static const uint32_t SCB_SHPRx_PRI_x_MASK[4][16] = {
      [3] = {
        [14] = 0x00FF0000U,   /** @brief Priority of system handler 14 */
        [15] = 0xFF000000U   /** @brief Priority of system handler 15 */
      },
      [1] = {
        [5] = 0x0000FF00U,   /** @brief Priority of system handler 5 */
        [6] = 0x00FF0000U,   /** @brief Priority of system handler 6 */
        [4] = 0x000000FFU   /** @brief Priority of system handler 4 */
      }
    };

    /**********************************************************************************************
     * @section PF Register Definitions
     **********************************************************************************************/

    /**** @subsection PF Register Pointer Definitions ****/

    static RO_ uint32_t* const PF_CLIDR_PTR  = (RO_ uint32_t*)0xE000ED78U;   /** @brief Cache level ID register */
    static RO_ uint32_t* const PF_CTR_PTR    = (RO_ uint32_t*)0xE000ED7CU;   /** @brief Cache type register */
    static RO_ uint32_t* const PF_CCSIDR_PTR = (RO_ uint32_t*)0xE000ED80U;   /** @brief Cache size ID register */

    /**** @subsection PF Register Reset Value Definitions ****/

    static const uint32_t PF_CLIDR_RST  = 0x09000003U;   /** @brief Cache level ID register */
    static const uint32_t PF_CTR_RST    = 0x8303C003U;   /** @brief Cache type register */
    static const uint32_t PF_CCSIDR_RST = 0x00000000U;   /** @brief Cache size ID register */

    /**** @subsection PF Register Value Type Definitions ****/

    typedef uint32_t PF_CLIDR_vt;    /** @brief PF_CLIDR register value type. */
    typedef uint32_t PF_CTR_vt;      /** @brief PF_CTR register value type. */
    typedef uint32_t PF_CCSIDR_vt;   /** @brief PF_CCSIDR register value type. */

    /**** @subsection PF Register Pointer Type Definitions ****/

    typedef RO_ uint32_t* PF_CLIDR_pt;    /** @brief PF_CLIDR pointer register pointer type. */
    typedef RO_ uint32_t* PF_CTR_pt;      /** @brief PF_CTR pointer register pointer type. */
    typedef RO_ uint32_t* PF_CCSIDR_pt;   /** @brief PF_CCSIDR pointer register pointer type. */

    /**** @subsection PF Field Mask Definitions ****/

    static const uint32_t PF_CLIDR_LOU_MASK  = 0x38000000U;   /** @brief LoU */
    static const uint32_t PF_CTR_FORMAT_MASK = 0xE0000000U;   /** @brief Format */
    static const uint32_t PF_CCSIDR_WT_MASK  = 0x80000000U;   /** @brief WT */

    /**********************************************************************************************
     * @section AC Register Definitions
     **********************************************************************************************/

    /**** @subsection AC Register Pointer Definitions ****/

    static RW_ uint32_t* const AC_ITCMCR_PTR = (RW_ uint32_t*)0xE000EF90U;   /** @brief Instruction and data tightly-coupled memory control registers */
    static RW_ uint32_t* const AC_DTCMCR_PTR = (RW_ uint32_t*)0xE000EF94U;   /** @brief Instruction and data tightly-coupled memory control registers */
    static RW_ uint32_t* const AC_AHBPCR_PTR = (RW_ uint32_t*)0xE000EF98U;   /** @brief AHBP control register */
    static RW_ uint32_t* const AC_CACR_PTR   = (RW_ uint32_t*)0xE000EF9CU;   /** @brief Auxiliary cache control register */
    static RW_ uint32_t* const AC_AHBSCR_PTR = (RW_ uint32_t*)0xE000EFA0U;   /** @brief AHB slave control register */
    static RW_ uint32_t* const AC_ABFSR_PTR  = (RW_ uint32_t*)0xE000EFA8U;   /** @brief Auxiliary bus fault status register */

    /**** @subsection AC Register Reset Value Definitions ****/

    static const uint32_t AC_ITCMCR_RST = 0x00000000U;   /** @brief Instruction and data tightly-coupled memory control registers */
    static const uint32_t AC_DTCMCR_RST = 0x00000000U;   /** @brief Instruction and data tightly-coupled memory control registers */
    static const uint32_t AC_AHBPCR_RST = 0x00000000U;   /** @brief AHBP control register */
    static const uint32_t AC_CACR_RST   = 0x00000000U;   /** @brief Auxiliary cache control register */
    static const uint32_t AC_AHBSCR_RST = 0x00000000U;   /** @brief AHB slave control register */
    static const uint32_t AC_ABFSR_RST  = 0x00000000U;   /** @brief Auxiliary bus fault status register */

    /**** @subsection AC Register Value Type Definitions ****/

    typedef uint32_t AC_ITCMCR_vt;   /** @brief AC_ITCMCR register value type. */
    typedef uint32_t AC_DTCMCR_vt;   /** @brief AC_DTCMCR register value type. */
    typedef uint32_t AC_AHBPCR_vt;   /** @brief AC_AHBPCR register value type. */
    typedef uint32_t AC_CACR_vt;     /** @brief AC_CACR register value type. */
    typedef uint32_t AC_AHBSCR_vt;   /** @brief AC_AHBSCR register value type. */
    typedef uint32_t AC_ABFSR_vt;    /** @brief AC_ABFSR register value type. */

    /**** @subsection AC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* AC_ITCMCR_pt;   /** @brief AC_ITCMCR pointer register pointer type. */
    typedef RW_ uint32_t* AC_DTCMCR_pt;   /** @brief AC_DTCMCR pointer register pointer type. */
    typedef RW_ uint32_t* AC_AHBPCR_pt;   /** @brief AC_AHBPCR pointer register pointer type. */
    typedef RW_ uint32_t* AC_CACR_pt;     /** @brief AC_CACR pointer register pointer type. */
    typedef RW_ uint32_t* AC_AHBSCR_pt;   /** @brief AC_AHBSCR pointer register pointer type. */
    typedef RW_ uint32_t* AC_ABFSR_pt;    /** @brief AC_ABFSR pointer register pointer type. */

    /**** @subsection AC Field Mask Definitions ****/

    static const uint32_t AC_ITCMCR_SZ_MASK        = 0x00000078U;   /** @brief SZ */
    static const uint32_t AC_DTCMCR_SZ_MASK        = 0x00000078U;   /** @brief SZ */
    static const uint32_t AC_AHBPCR_SZ_MASK        = 0x0000000EU;   /** @brief SZ */
    static const uint32_t AC_CACR_FORCEWT_MASK     = 0x00000004U;   /** @brief FORCEWT */
    static const uint32_t AC_AHBSCR_INITCOUNT_MASK = 0x0000F800U;   /** @brief INITCOUNT */
    static const uint32_t AC_ABFSR_AXIMTYPE_MASK   = 0x00000300U;   /** @brief AXIMTYPE */

    /**********************************************************************************************
     * @section RAMECC Register Definitions
     **********************************************************************************************/

    /**** @subsection RAMECC Register Pointer Definitions ****/

    static RW_ uint32_t* const RAMECCx_IER_PTR[4] = {
      [2] = (RW_ uint32_t*)0x48023000U,   /** @brief RAMECC interrupt enable register */
      [3] = (RW_ uint32_t*)0x58027000U,   /** @brief RAMECC interrupt enable register */
      [1] = (RW_ uint32_t*)0x52009000U   /** @brief RAMECC interrupt enable register */
    };

    /**** @subsection RAMECC Register Reset Value Definitions ****/

    static const uint32_t RAMECCx_IER_RST[4] = {
      [2] = 0x00000000U,   /** @brief RAMECC interrupt enable register */
      [3] = 0x00000000U,   /** @brief RAMECC interrupt enable register */
      [1] = 0x00000000U   /** @brief RAMECC interrupt enable register */
    };

    /**** @subsection RAMECC Register Value Type Definitions ****/

    typedef uint32_t RAMECCx_IER_vt;      /** @brief RAMECCx_IER register value type. */
    typedef uint32_t RAMECCx_MxCR_vt;     /** @brief RAMECCx_MxCR register value type. */
    typedef uint32_t RAMECCx_MxSR_vt;     /** @brief RAMECCx_MxSR register value type. */
    typedef uint32_t RAMECCx_MxFAR_vt;    /** @brief RAMECCx_MxFAR register value type. */
    typedef uint32_t RAMECCx_MxFDRL_vt;   /** @brief RAMECCx_MxFDRL register value type. */
    typedef uint32_t RAMECCx_MxFDRH_vt;   /** @brief RAMECCx_MxFDRH register value type. */
    typedef uint32_t RAMECCx_MxFECR_vt;   /** @brief RAMECCx_MxFECR register value type. */

    /**** @subsection RAMECC Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* RAMECCx_IER_pt;      /** @brief RAMECCx_IER pointer register pointer type. */
    typedef RW_ uint32_t* RAMECCx_MxCR_pt;     /** @brief RAMECCx_MxCR pointer register pointer type. */
    typedef RW_ uint32_t* RAMECCx_MxSR_pt;     /** @brief RAMECCx_MxSR pointer register pointer type. */
    typedef RO_ uint32_t* RAMECCx_MxFAR_pt;    /** @brief RAMECCx_MxFAR pointer register pointer type. */
    typedef RO_ uint32_t* RAMECCx_MxFDRL_pt;   /** @brief RAMECCx_MxFDRL pointer register pointer type. */
    typedef RW_ uint32_t* RAMECCx_MxFDRH_pt;   /** @brief RAMECCx_MxFDRH pointer register pointer type. */
    typedef RW_ uint32_t* RAMECCx_MxFECR_pt;   /** @brief RAMECCx_MxFECR pointer register pointer type. */

    /**** @subsection RAMECC Field Mask Definitions ****/

    static const uint32_t RAMECCx_IER_GECCDEBWIE_MASK[4] = {
      [2] = 0x00000008U,   /** @brief Global ECC double error on byte write (BW) interrupt enable */
      [3] = 0x00000008U,   /** @brief Global ECC double error on byte write (BW) interrupt enable */
      [1] = 0x00000008U   /** @brief Global ECC double error on byte write (BW) interrupt enable */
    };

    static const uint32_t RAMECCx_MxCR_ECCELEN_MASK[2] = {
      [1] = 0x00000020U   /** @brief ECC error latching enable */
    };

    static const uint32_t RAMECCx_MxSR_ECCELEN_MASK[2] = {
      [1] = 0x00000020U   /** @brief ECC error latching enable */
    };

    static const uint32_t RAMECCx_MxFAR_ECCELEN_MASK[2] = {
      [1] = 0x00000020U   /** @brief ECC error latching enable */
    };

    static const uint32_t RAMECCx_MxFDRL_ECCELEN_MASK[2] = {
      [1] = 0x00000020U   /** @brief ECC error latching enable */
    };

    static const uint32_t RAMECCx_MxFDRH_ECCELEN_MASK[2] = {
      [1] = 0x00000020U   /** @brief ECC error latching enable */
    };

    static const uint32_t RAMECCx_MxFECR_DEBWDF_MASK[2] = {
      [1] = 0x00000004U   /** @brief ECC double error on byte write (BW) detected flag */
    };

    static const uint32_t RAMECCx_MxCR_ECCELEN_MASK[4][6] = {
      [2] = {
        [2] = 0x00000020U,   /** @brief ECC error latching enable */
        [3] = 0x00000020U,   /** @brief ECC error latching enable */
        [4] = 0x00000020U,   /** @brief ECC error latching enable */
        [5] = 0x00000020U,   /** @brief ECC error latching enable */
        [1] = 0x00000020U   /** @brief ECC error latching enable */
      },
      [3] = {
        [2] = 0x00000020U,   /** @brief ECC error latching enable */
        [1] = 0x00000020U   /** @brief ECC error latching enable */
      }
    };

    /**********************************************************************************************
     * @section ART Register Definitions
     **********************************************************************************************/

    /**** @subsection ART Register Pointer Definitions ****/

    static RW_ uint32_t* const ART_CTR_PTR = (RW_ uint32_t*)0x40024400U;   /** @brief Control register */

    /**** @subsection ART Register Reset Value Definitions ****/

    static const uint32_t ART_CTR_RST = 0x00000004U;   /** @brief Control register */

    /**** @subsection ART Register Value Type Definitions ****/

    typedef uint32_t ART_CTR_vt;   /** @brief ART_CTR register value type. */

    /**** @subsection ART Register Pointer Type Definitions ****/

    typedef RW_ uint32_t* ART_CTR_pt;   /** @brief ART_CTR pointer register pointer type. */

    /**** @subsection ART Field Mask Definitions ****/

    static const uint32_t ART_CTR_PCACHEADDR_MASK = 0x000FFF00U;   /** @brief Cacheable page index */

